<html>
<head>
<title>Everything You Need to Know About React useState</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的关于反应使用状态的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-about-react-use-state-a2439e3dc29b?source=collection_archive---------3-----------------------#2022-03-28">https://javascript.plainenglish.io/everything-about-react-use-state-a2439e3dc29b?source=collection_archive---------3-----------------------#2022-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="13db" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于React的useState钩子，你需要知道的一切，用一个简单的React项目来解释。</h2></div><p id="479e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几周前，我在世界各地的同事中调查了前端库的使用率。几年来，我第一次惊喜地看到jQuery最终被现代JS库推翻，王者归来👑。</p><p id="a7fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据<a class="ae ky" href="https://www.statista.com/statistics/1124699/worldwide-developer-survey-most-used-frameworks-web/" rel="noopener ugc nofollow" target="_blank">的这些</a>统计，超过40%的前端开发人员首选React。太棒了，🕺🎊！</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/f607f5c2b17294a7fd88202898d8f38b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/0*55CUSz-NePAFvfub"/></div></figure><p id="677b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，在我写这篇文章的时候，我找不到任何相关的统计数据来看有多少React项目是以老式的方式开发的，基于类组件，有多少是类和函数组件的混合，以及只有函数组件有钩子。如果要我猜的话，我会选择mixt方法，因为大多数项目已经有几年了，如果团队想要采用钩子，就必须从类迁移到函数。</p><p id="0aad" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我决定撰写一系列React hooks文章，帮助当前的React开发人员轻松地将他们的遗留代码迁移到现代React，并帮助新开发人员和技术爱好者理解React和hooks。</p><p id="472e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将深入探究React的<code class="fe lh li lj lk b">useState</code>。</p><h1 id="4fd2" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">什么是使用状态？</h1><p id="8581" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated"><code class="fe lh li lj lk b">useState</code>是一个<em class="mi">反应钩。</em></p><p id="17e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mi">挂钩是一种特殊功能，可让您“挂钩”React功能。例如，</em> <code class="fe lh li lj lk b"><em class="mi">useState</em></code> <em class="mi">是一个钩子，可以让你给函数组件添加反应状态。【</em> <a class="ae ky" href="https://reactjs.org/docs/hooks-state.html#whats-a-hook" rel="noopener ugc nofollow" target="_blank"> <em class="mi">来源</em></a><em class="mi">】</em></p><h1 id="3fa2" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">什么时候需要使用状态？</h1><p id="bb02" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">每当你编写一个功能组件时，你都需要这个钩子，你必须在组件中定义一些状态变量。</p><h1 id="7ac2" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">我们在建造什么？</h1><p id="fd37" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们准备建一个<strong class="ke io">投票卡App </strong>。我知道这是一个基本的应用程序，但我们的目的是了解所有的<code class="fe lh li lj lk b">useState</code>功能和概念。</p><p id="7f6b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我为你准备了一个用<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a>和<a class="ae ky" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">顺风CSS </a>连线的React app。</p><p id="b169" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以克隆这个回购，这样我们就可以开始了😄：</p><div class="mj mk gp gr ml mm"><a href="https://github.com/stedda/card-voting" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">GitHub - stedda/card-voting:博客文章公共存储库</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na lf mm"/></div></div></a></div><p id="a513" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只需<code class="fe lh li lj lk b">cd where/you/cloned/the/project</code>并运行<code class="fe lh li lj lk b">npm i</code>。一旦软件包安装完成，运行<code class="fe lh li lj lk b">npm start</code>，你的应用就会启动并运行。</p><h1 id="338c" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">项目结构和技术</h1><p id="39f2" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">首先，让我给你一个项目的快速演练。这是一个标准的CRA项目，带有TypeScript预置和Tailwind CSS。</p><p id="8139" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我为什么喜欢这种结构？</p><ul class=""><li id="fa93" class="nb nc in ke b kf kg ki kj kl nd kp ne kt nf kx ng nh ni nj bi translated">这在大多数项目中很常见</li><li id="a338" class="nb nc in ke b kf nk ki nl kl nm kp nn kt no kx ng nh ni nj bi translated">对于我们当前的例子来说，这已经足够了</li><li id="dbb4" class="nb nc in ke b kf nk ki nl kl nm kp nn kt no kx ng nh ni nj bi translated">它把我们所有的工作文件放在同一个深度和同一个地方</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi np"><img src="../Images/5bdad0f1029c14d1161955fd24215e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*JefAQU2hMPGkwC4jX5MJsA.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">voting-card project structure</figcaption></figure><p id="1681" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我为什么选择这种技术设置？</p><ul class=""><li id="0b5a" class="nb nc in ke b kf kg ki kj kl nd kp ne kt nf kx ng nh ni nj bi translated">我认为TypeScript在任何现代web应用程序中都是必不可少的，不管团队规模或应用程序规模如何，因为它在预防错误、共享数据类型和实施一些急需的规则集方面帮了你很多</li><li id="f5ba" class="nb nc in ke b kf nk ki nl kl nm kp nn kt no kx ng nh ni nj bi translated">Tailwind CSS是一个实用优先的CSS框架。那是什么意思？嗯，它有许多实用类供你使用，而不是写经典的CSS。一旦你习惯了，它会变得非常有用。</li></ul><h1 id="5210" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">让我们开始编码吧🚀 💻</h1><p id="8c92" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">首先，让我们定义我们的数据类型。让我们在<code class="fe lh li lj lk b">src</code>文件夹下创建一个<code class="fe lh li lj lk b">VotingUtils.ts</code>文件。在这里，如果需要，我们将按照数据类型和实用函数来存储所有内容。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">src/VotingUtils.ts</figcaption></figure><p id="1c64" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的下一步是创建投票卡组件。在<code class="fe lh li lj lk b">src</code>文件夹下，我们创建一个名为<code class="fe lh li lj lk b">VotingCard.tsx</code>的文件:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">src/VotingCard.tsx</figcaption></figure><p id="93ab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们转到我们的<code class="fe lh li lj lk b">App.tsx</code>，用下面的代码来修改它:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9dcf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，我们所做的是设置我们的应用程序并显示我们的投票主题。除此之外，我们已经为我们所有的卡准备了一个可重用的组件，我们将要使用的数据模型，以及一个连接在一起的模拟数据常量😄。<br/>现在让我们添加投票图标。让我们安装<code class="fe lh li lj lk b">react-feather</code>:</p><pre class="la lb lc ld gt nw lk nx ny aw nz bi"><span id="8db6" class="oa lm in lk b gy ob oc l od oe">npm i react-feather</span></pre><p id="1b93" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将为我们的应用程序提供一组开源图标，我们可以用它们来投票决定我们的主题👍。</p><p id="30a3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们编辑<code class="fe lh li lj lk b">VotingCard</code>组件并添加投票按钮:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cd88" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果之前一切正常，我们的应用程序应该是这样的:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi of"><img src="../Images/617acb4aa25a9c237d33314f1c84b395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZbWj_PXfsfoq0ZDv6_pww.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Voting card app design</figcaption></figure><p id="d3d8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们到了有趣的部分。我们将使用React <code class="fe lh li lj lk b">useState</code>钩子创建两个状态变量，<code class="fe lh li lj lk b">isLiked</code>和<code class="fe lh li lj lk b">isDisliked</code>。这就是我们将如何能够确定是否有任何卡已被投票或没有。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ok"><img src="../Images/2e6d2a876fea63398967ac5f44f8c841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3DYcW-M8IhdiwdQ_fL9eA.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">useState declaration</figcaption></figure><p id="188e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们从<code class="fe lh li lj lk b">react</code>中导入了<code class="fe lh li lj lk b">useState</code>并在上面使用。我们为什么需要这个？因为我们需要以某种方式确定，在<strong class="ke io"> VotingCard </strong>组件中，这张卡是喜欢还是不喜欢。</p><p id="785f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">useState</code> hook返回一对值。第一个值是状态，第二个值是更新该值的Dispatch函数。这是什么意思？也就是说<code class="fe lh li lj lk b">isLiked</code>和<code class="fe lh li lj lk b">isDisliked</code>代表当前的<em class="mi">状态值，</em>和<em class="mi"> </em> <code class="fe lh li lj lk b">setIsLiked</code> <em class="mi">与<code class="fe lh li lj lk b">setIsDisliked</code>一起，是<em class="mi">更新</em>的功能。</em></p><p id="c497" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们希望每次使用<code class="fe lh li lj lk b">useState</code>时都存储2个变量，因此我们可以用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#array_destructuring" rel="noopener ugc nofollow" target="_blank">数组破坏</a>来优雅地写这个。</p><p id="ca4a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="mi">归根结底，更新状态变量的正确方法是调用相应的函数并向它们传递新值。</em> </strong></p><p id="598e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们稍微解释一下<code class="fe lh li lj lk b">useState&lt;boolean&gt;(false)</code>是做什么的。通过在useState之后附加<code class="fe lh li lj lk b">&lt;boolean&gt;</code>，我们具体地告诉TypeScript，我们的状态值是属于<strong class="ke io"> <em class="mi">类型布尔的。</em> </strong>而在<code class="fe lh li lj lk b">useState</code>中作为参数传递的值，在我们的例子中为<code class="fe lh li lj lk b">false</code>，表示一旦渲染了我们的<strong class="ke io"> VotingCard </strong>组件，则<em class="mi">状态变量</em>将具有的初始值。</p><p id="99b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有鉴于此，让我们在<code class="fe lh li lj lk b">VotingCard</code>组件内部创建两个函数，一个用于LIKE，另一个用于rehave，将它们附加到按钮上，同时为按钮添加活动颜色状态:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4997" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们进入我们的浏览器并测试这一点，我们应该能够喜欢或不喜欢的投票卡。</p><p id="3486" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们增加了2个新功能。让我们把它分解一下:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ol"><img src="../Images/1d16954b314f37c1820ca9e5f5fe1302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_mWAqvB3pCJ3dZ_p0dkng.png"/></div></div></figure><p id="fd40" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个功能<code class="fe lh li lj lk b">onLikeClicked</code>，将我们的状态变量<code class="fe lh li lj lk b">isLiked</code>设置为<code class="fe lh li lj lk b">true</code>，同时将<code class="fe lh li lj lk b">isDisliked</code>变量设置为假，无论其值如何。</p><p id="f404" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个遵循几乎相同的行为，但这一次，我们只是在<code class="fe lh li lj lk b">isLiked</code>和<code class="fe lh li lj lk b">isDisliked</code>变量之间互换角色。</p><p id="a28f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们跳转到我们的<strong class="ke io"> JSX语法</strong>，看看我们在那里更新了什么:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi om"><img src="../Images/173a97da2327fb20d3424d0ad5867e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lRIgsoMa_fMBR6Wo4TFHA.png"/></div></div></figure><p id="8ae2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在两个图标上都添加了一个<code class="fe lh li lj lk b">onClick</code>处理程序，同时，我们也考虑到了是否有任何相应的状态变量处于活动状态，我们希望用蓝色<em class="mi">或红色</em>来突出显示它们。</p><p id="6a41" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="mi">需要注意的一个重要的事情是，在我们的JSX中读取状态就像把我们的状态变量加上花括号</em> </strong> <code class="fe lh li lj lk b"><strong class="ke io"><em class="mi">{ isLiked } / { isDisliked }</em></strong></code> <strong class="ke io"> <em class="mi">一样简单。</em> </strong></p><p id="21f9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于熟悉<strong class="ke io"> <em class="mi">类语法</em> </strong>的人来说，我们到目前为止所做的一切相当于下面的代码:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="717f" class="oa lm in bd ln on oo dn lr op oq dp lv kl or os lx kp ot ou lz kt ov ow mb ox bi translated">setState回调</h2><p id="44d3" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">到目前为止，我们在代码中很容易发现的一点是，当我们试图多次单击同一个动作(喜欢或不喜欢的按钮)时，状态不会改变。那是因为我们总是将点击的按钮设置为<code class="fe lh li lj lk b">true</code>。</p><p id="a552" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，在将<code class="fe lh li lj lk b">ifs</code>创建到您的<code class="fe lh li lj lk b">onClick</code>函数中之前，让我告诉您，我们可以通过<code class="fe lh li lj lk b">setState</code>函数回调轻松处理这个场景。</p><p id="48f2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，我们说<code class="fe lh li lj lk b">setIsLiked</code>和<code class="fe lh li lj lk b">setIsDisliked</code>接受一个值作为参数，但那只对了一半。它也接受一个函数作为参数。该函数将采用先前的状态值，并且必须返回一个新的状态值。让我们看看这是如何工作的:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi oy"><img src="../Images/7654f504c68e8e17deb7db3ce9f3a7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWcU1oSGBHXIE8AeNWLruA.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">setState callback function</figcaption></figure><p id="b5a0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经改变了我们的功能，那就是每次我们点击<code class="fe lh li lj lk b">onLikeClicked</code>，都要考虑到之前的<code class="fe lh li lj lk b">isLiked</code>，重视并否定它。</p><p id="1ff9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样适用于<code class="fe lh li lj lk b">onDislikeClicked</code>功能和<code class="fe lh li lj lk b">isDisliked</code>状态变量。</p><h2 id="0e8d" class="oa lm in bd ln on oo dn lr op oq dp lv kl or os lx kp ot ou lz kt ov ow mb ox bi translated">setState重新呈现</h2><p id="18ff" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">使用由<code class="fe lh li lj lk b">useState</code>提供的<strong class="ke io"> <em class="mi">设置状态回调</em> </strong>的一个最重要的方面是，每次调用任何<strong class="ke io"> <em class="mi">设置状态回调</em> </strong>时，它将对该组件进行重新渲染操作。通过重新渲染，React可以更新您的状态并转换屏幕上的UI元素。</p><p id="fe66" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，每次我们调用<code class="fe lh li lj lk b">setIsLiked</code>或<code class="fe lh li lj lk b">setIsDisliked</code>时，我们的<strong class="ke io"> VotingCard </strong>组件都会在某个时间点执行一次重新渲染操作。这个操作队列由React管理。</p><p id="4211" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一件重要的事情是，在多次状态更新期间，<code class="fe lh li lj lk b">useState</code>返回的第一个值将总是应用更新后的最新状态。</p><h2 id="43c3" class="oa lm in bd ln on oo dn lr op oq dp lv kl or os lx kp ot ou lz kt ov ow mb ox bi translated">setState函数标识</h2><p id="31f0" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">值得一提的是，React保证<strong class="ke io"> <em class="mi"> setState函数</em> </strong>在重新渲染时具有相同的身份。</p><p id="266f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着，在场景背后，函数将在重新渲染之间指向相同的引用，并且不会被检测为变化。</p><p id="c300" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该组件中定义的其他函数或变量将在重新渲染之间指向不同的引用。在React的帮助下，我们有一些例外，但是我们将在以后了解它们。</p><h2 id="7deb" class="oa lm in bd ln on oo dn lr op oq dp lv kl or os lx kp ot ou lz kt ov ow mb ox bi translated">懒惰初始状态</h2><p id="0281" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们提到了这样一个事实，即<code class="fe lh li lj lk b">useState</code>接收一个参数，该参数代表状态变量的初始值，但是它也可以接收一个函数作为参数。</p><p id="24ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，当您有繁重的操作要执行时，您希望将函数作为回调来传递，并用它来初始化状态。</p><pre class="la lb lc ld gt nw lk nx ny aw nz bi"><span id="50e7" class="oa lm in lk b gy ob oc l od oe">const [likes, setLikes] = useState(() =&gt; {<br/> return <strong class="lk io"><em class="mi">someHeavyComputationFunction()</em></strong></span><span id="1a48" class="oa lm in lk b gy oz oc l od oe">})</span><span id="7c0b" class="oa lm in lk b gy oz oc l od oe">// or depending on how you write the function<br/>// you can also write it something like this</span><span id="62fe" class="oa lm in lk b gy oz oc l od oe">const [likes, setLikes] = useState(<strong class="lk io"><em class="mi">someHeavyComputationFunction</em></strong>)</span></pre><p id="e4e6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，通常最好只使用<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#lazy-initial-state" rel="noopener ugc nofollow" target="_blank">惰性初始状态</a>模式，并将一个函数传递给useState，它将只返回您计算的状态一次。</p><p id="14ba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">记住:</strong>将函数作为参数调用将导致与传递值相同的行为，并且它将在重新呈现之间调用该函数。</p><pre class="la lb lc ld gt nw lk nx ny aw nz bi"><span id="eee1" class="oa lm in lk b gy ob oc l od oe">// bad<br/>const [likes, setLikes] = useState(computeHugeAmountOfLikes())</span><span id="3937" class="oa lm in lk b gy oz oc l od oe">// good<br/>const [likes, setLikes] = useState(computeHugeAmountOfLikes)</span></pre><h2 id="46c7" class="oa lm in bd ln on oo dn lr op oq dp lv kl or os lx kp ot ou lz kt ov ow mb ox bi translated">setState更新拯救</h2><p id="67aa" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">为什么我说setState在拯救我们？这是非常优化的，只会更新与以前不同的值的状态。换句话说，如果你试图用相同的值更新当前状态，React将<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-state-update" rel="noopener ugc nofollow" target="_blank">退出</a>，而不渲染子元素或点火效果。</p><h1 id="d0dc" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">结论</h1><p id="110b" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">通过这篇文章，我们学到了很多东西。让我们再回顾一遍:</p><ul class=""><li id="f6e9" class="nb nc in ke b kf kg ki kj kl nd kp ne kt nf kx ng nh ni nj bi translated">我们开发了一个投票应用程序</li><li id="9e8f" class="nb nc in ke b kf nk ki nl kl nm kp nn kt no kx ng nh ni nj bi translated">我们添加了<em class="mi"> Tailwind CSS和TypeScript </em>，并在本文中使用它们</li><li id="c976" class="nb nc in ke b kf nk ki nl kl nm kp nn kt no kx ng nh ni nj bi translated">我们了解了什么是使用状态以及它所有的秘密</li></ul><p id="90c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这看起来微不足道，但是相信我，你会在你的React之旅中经常使用<code class="fe lh li lj lk b">useState</code>，为了掌握React和hooks，你必须完全理解它所有的怪癖和秘密。</p></div><div class="ab cl pa pb hr pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="ig ih ii ij ik"><p id="bf98" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章对你有用！如果你有任何问题或建议，请拍下来，我会尽快参与。</p><p id="5635" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意安全，下次再见🙌！</p><p id="33aa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mi">更多内容请看</em><a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mi">plain English . io</em></strong></a><em class="mi">。报名参加我们的</em> <a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mi">免费周报</em> </strong> </a> <em class="mi">。关注我们关于</em><a class="ae ky" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mi">Twitter</em></strong></a><em class="mi">和</em><a class="ae ky" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mi">LinkedIn</em></strong></a><em class="mi">。加入我们的</em><strong class="ke io"><em class="mi"/></strong><a class="ae ky" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mi">社区不和谐</em> </strong> </a> <em class="mi">。</em></p></div></div>    
</body>
</html>