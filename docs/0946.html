<html>
<head>
<title>React Crash Course — Understanding State and Lifecycle Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React速成班—了解状态和生命周期方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-crash-course-understanding-state-and-lifecycle-methods-df81842a419b?source=collection_archive---------13-----------------------#2022-02-22">https://javascript.plainenglish.io/react-crash-course-understanding-state-and-lifecycle-methods-df81842a419b?source=collection_archive---------13-----------------------#2022-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c150" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第7部分:为状态和生命周期方法构建基础</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/53b90c418a494c38c9b1a29fac9edfb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9uS7PJrQsFfNLLBr"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f4af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Live dev笔记由</em> <a class="ae kv" href="https://www.youtube.com/channel/UCTZRcDjjkVajGL6wd76UnGg" rel="noopener ugc nofollow" target="_blank"> <em class="ls">丹尼斯·艾维</em></a><em class="ls">——</em><a class="ae kv" href="https://www.youtube.com/watch?v=6fM3ueN9nYM" rel="noopener ugc nofollow" target="_blank"><em class="ls">React JS速成班</em> </a></p><blockquote class="lt"><p id="2f56" class="lu lv iq bd lw lx ly lz ma mb mc lr dk translated">在第7部分中，我们看一下React状态和生命周期方法如何工作。通过比较基于类和基于函数的组件，我们将理解为什么选择后者而不是前者。</p></blockquote></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="0733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以参考我的Github repo:</p><div class="mk ml gp gr mm mn"><a href="https://github.com/emilyyleung/notesapp/tree/Part-7/State-and-Lifecycle-Methods" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">GitHub-Emily leung/notes app at Part-7/状态和生命周期方法</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">在GitHub上创建一个帐户，为Emily leung/notes app的开发做出贡献。</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb kp mn"/></div></div></a></div></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="d79f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React中的状态等同于思考:</p><ul class=""><li id="bd8f" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">人的状态→坐着或站着</li><li id="b937" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">主题的状态→暗或亮</li><li id="2b09" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">模态的状态→打开或关闭</li></ul><p id="7d9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这同样适用于反应，因为状态是关于可以随时间改变的事物的信息或数据。每个React组件都可以有自己的状态，这实际上是一个JavaScript对象。</p><p id="b545" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，下面是一个电子商务网站中代表产品的组件的状态——可以用在组件的呈现中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/f18a689de0834d848dcf90a29c13d558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UlORXO6oJ-GXQ2AI"/></div></div></figure><h1 id="e96d" class="nr ns iq bd nt nu nv nw nx ny nz oa ob jw oc jx od jz oe ka of kc og kd oh oi bi translated">基于类的组件</h1><p id="6ed0" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">React组件可以用基于类的组件构建，这是一个在React内部构建类的过程。这个方法仍然可以实现，但这是一种不同的方式，并且需要使用像构造函数方法和<code class="fe oo op oq or b">setState()</code>函数(用于修改状态)这样的东西。</p><p id="684c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这个过程意味着我们将使用构造函数方法并添加状态，比如一个注释列表。通常，注释列表将来自调用API，然后将其呈现出来。</p><pre class="kg kh ki kj gt os or ot ou aw ov bi"><span id="d4c9" class="ow ns iq or b gy ox oy l oz pa">this.state = {<br/>    notes: ['Wash car', 'Build project', 'Workout'],<br/>}</span></pre><p id="5a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，基于类的组件将构造组件，更新状态，然后使用状态数据遍历并创建注释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/e5a688f0b56442bcc98920843ccf4022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*7__b_kgukKvY7V6M"/></div></figure><h1 id="d6db" class="nr ns iq bd nt nu nv nw nx ny nz oa ob jw oc jx od jz oe ka of kc og kd oh oi bi translated">基于功能的组件</h1><p id="3437" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">另一方面，我们有基于功能的组件，它们更加无缝，但也不是那么具有描述性。状态对象仍然存在，但是我们使用一个叫做React Hooks的东西来更新我们的状态。</p><blockquote class="pc pd pe"><p id="0bed" class="kw kx ls ky b kz la jr lb lc ld ju le pf lg lh li pg lk ll lm ph lo lp lq lr ij bi translated"><em class="iq">看起来基于函数的组件也被React团队</em> <a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">所支持</em> </a> <em class="iq">用于基于类的组件之上。</em></p></blockquote><p id="8109" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React钩子是一组允许我们修改、设置和处理状态的函数。我们将在这个项目中使用的两个钩子是内置的。</p><h1 id="910b" class="nr ns iq bd nt nu nv nw nx ny nz oa ob jw oc jx od jz oe ka of kc og kd oh oi bi translated">理解钩子:使用状态</h1><p id="75c1" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">我们将使用的两个钩子之一是<code class="fe oo op oq or b">useState</code>。这是一个简单的函数，它接受一个设置状态值的可选参数，即一个音符数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/093dfdf0feee7ca133fcc0e0782a62db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9isTbu0v1OHasH53"/></div></div></figure><p id="8a45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看上面的例子，我们可以看到<code class="fe oo op oq or b">notes</code>的第一个参数是我们存储数组(或对象)的变量。第二个参数<code class="fe oo op oq or b">setNotes</code>是我们的setter方法。当我们想要更新<code class="fe oo op oq or b">notes</code>状态时，我们将调用这个函数。</p><h1 id="e887" class="nr ns iq bd nt nu nv nw nx ny nz oa ob jw oc jx od jz oe ka of kc og kd oh oi bi translated">生命周期方法和挂钩</h1><p id="6b42" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">如果您熟悉基于类的组件，箭头左边蓝色列出的生命周期方法应该会让您对正在发生的事情有更好的理解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/4a79c54e070e7ebd4ae4da7ef1d94614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zshUiP600pHRm_eu"/></div></div></figure><h2 id="cd38" class="ow ns iq bd nt pk pl dn nx pm pn dp ob lf po pp od lj pq pr of ln ps pt oh pu bi translated">React有3种主要的生命周期方法:</h2><ul class=""><li id="9952" class="nc nd iq ky b kz oj lc ok lf pv lj pw ln px lr nh ni nj nk bi translated"><strong class="ky ir"> componentDidMount </strong> —当组件首次挂载时触发</li><li id="2d34" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">componentDidUpdate</strong>——当发生变化或状态更新时触发——例如调用更多数据或在我们的组件内部做一些事情</li><li id="c753" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">component will unmount</strong>——当一个组件从DOM中被拆除时被触发</li></ul><p id="8c11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于基于功能的组件，不再需要这三种生命周期方法。我们将使用<code class="fe oo op oq or b">useEffect</code>钩子，这是一个考虑到所有这三种情况的函数。</p><h1 id="7fca" class="nr ns iq bd nt nu nv nw nx ny nz oa ob jw oc jx od jz oe ka of kc og kd oh oi bi translated">componentDidMount → useEffect</h1><p id="2e64" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">为了复制这个函数，我们将设置<code class="fe oo op oq or b">useEffect</code>并在其中添加一个函数，以及添加一组依赖项的选项。当组件挂载时，<code class="fe oo op oq or b">useEffect</code>会触发。这通常用于快速获取用于呈现页面、简档或注释的数据。</p><pre class="kg kh ki kj gt os or ot ou aw ov bi"><span id="013b" class="ow ns iq or b gy ox oy l oz pa">useEffect(() =&gt; {</span><span id="ba20" class="ow ns iq or b gy py oy l oz pa">}, [])</span></pre><h1 id="25ec" class="nr ns iq bd nt nu nv nw nx ny nz oa ob jw oc jx od jz oe ka of kc og kd oh oi bi translated">componentDidUpdate → useEffect</h1><p id="fd2c" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">依赖项的空数组意味着<code class="fe oo op oq or b">useEffect</code>只在第一次加载时运行。然而，当组件发生更新时，<code class="fe oo op oq or b">useEffect</code>也可以触发。</p><p id="83ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当没有为第二个参数(代表依赖项)提供任何内容时，<code class="fe oo op oq or b">useEffect</code>将在每次更新时运行。此外，我们可以添加依赖关系，当更新时，就会触发<code class="fe oo op oq or b">useEffect</code></p><pre class="kg kh ki kj gt os or ot ou aw ov bi"><span id="1f8f" class="ow ns iq or b gy ox oy l oz pa"><strong class="or ir">// Runs of every Uupdate, or...</strong><br/>useEffect(() =&gt; {</span><span id="47c1" class="ow ns iq or b gy py oy l oz pa">})</span><span id="cc0c" class="ow ns iq or b gy py oy l oz pa"><strong class="or ir">// ... runs if any dependencies change</strong><br/>useEffect(() =&gt; {</span><span id="23c5" class="ow ns iq or b gy py oy l oz pa">}, [Dependencies])</span></pre><h1 id="53f2" class="nr ns iq bd nt nu nv nw nx ny nz oa ob jw oc jx od jz oe ka of kc og kd oh oi bi translated">组件将卸载→使用效果</h1><p id="2fd7" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">要复制这个功能，我们只需要提供一个拆卸功能。这就像在<code class="fe oo op oq or b">useEffect</code>函数中添加一个返回方法一样简单。</p><pre class="kg kh ki kj gt os or ot ou aw ov bi"><span id="c950" class="ow ns iq or b gy ox oy l oz pa">useEffect(() =&gt; {<br/>  <br/>  return() =&gt; {}</span><span id="d91e" class="ow ns iq or b gy py oy l oz pa">}, [])</span></pre><h1 id="c85f" class="nr ns iq bd nt nu nv nw nx ny nz oa ob jw oc jx od jz oe ka of kc og kd oh oi bi translated">设置基于功能的组件</h1><p id="a9d9" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">我们将从移除项目中的<code class="fe oo op oq or b">data.js</code>开始。因为我们有模拟后端服务器存储我们的笔记，所以从现在开始我们可以使用<code class="fe oo op oq or b">fetch</code>或<code class="fe oo op oq or b">axios</code>与<code class="fe oo op oq or b">db.json</code>交互。</p><p id="b11f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe oo op oq or b">NotesListPage.js</code>中，我们将移除<code class="fe oo op oq or b">data.js</code>导入，并通过导入基于<code class="fe oo op oq or b">useState</code>功能的组件来替换它。</p><p id="0f10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将调用<code class="fe oo op oq or b">useState</code>作为我们的<code class="fe oo op oq or b">notes</code>变量。记住，必须用第二个参数来析构它，以便我们能够更新状态。现在，它将返回一个空数组。</p><pre class="kg kh ki kj gt os or ot ou aw ov bi"><span id="a4bf" class="ow ns iq or b gy ox oy l oz pa">// notesapp &gt; src &gt; pages &gt; NotesListPage.js<br/><br/><strong class="or ir">import { useState } from 'react'</strong><br/>import ListItem from '../components/ListItem'<br/><br/>const NotesListPage = () =&gt; {<br/><br/>    <strong class="or ir">let [notes, setNotes] = useState([])</strong><br/><br/>    return (<br/>        &lt;div className='notes'&gt;<br/>            &lt;div className='notes-header'&gt;<br/>                &lt;h2 className='notes-title'&gt;&amp;#9782; Notes&lt;/h2&gt;<br/>                &lt;p className='notes-count'&gt;{notes.length}&lt;/p&gt;<br/>            &lt;/div&gt;<br/>            &lt;div className='notes-list'&gt;<br/>                {notes.map((note, index) =&gt; <br/>                    &lt;ListItem key={index} note={note}/&gt;<br/>                )}<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}<br/><br/>export default NotesListPage</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/68fead98e5736ec6b16674f991b7f224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k9dKQUr3RnBa8S-f"/></div></div></figure><p id="2a85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，类似地，在<code class="fe oo op oq or b">NotePage.js</code>中，我们将执行以下操作:</p><ul class=""><li id="e7da" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">导入<code class="fe oo op oq or b">useState</code>功能组件</li><li id="5802" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">移除<code class="fe oo op oq or b">data.js</code>导入</li><li id="3d71" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">用带有两个参数的<code class="fe oo op oq or b">useState</code>函数替换<code class="fe oo op oq or b">note</code>——返回一个空值</li></ul><pre class="kg kh ki kj gt os or ot ou aw ov bi"><span id="7e85" class="ow ns iq or b gy ox oy l oz pa">// notesapp &gt; src &gt; pages &gt; NotePage.js</span><span id="9e46" class="ow ns iq or b gy py oy l oz pa"><strong class="or ir">import { useState } from 'react'</strong><br/>import { Link } from 'react-router-dom'<br/>import { ReactComponent as ArrowLeft } from '../assets/arrow-left.svg'</span><span id="b56f" class="ow ns iq or b gy py oy l oz pa">const NotePage = ({match}) =&gt; {<br/>    let noteId = match.params.id</span><span id="ee2c" class="ow ns iq or b gy py oy l oz pa">    <strong class="or ir">let [note, setNote] = useState(null)</strong></span><span id="4e4e" class="ow ns iq or b gy py oy l oz pa">    return (<br/>        &lt;div className='note'&gt;<br/>            &lt;div className='note-header'&gt;<br/>                &lt;h3&gt;<br/>                    &lt;Link to="/"&gt;<br/>                        &lt;ArrowLeft/&gt;<br/>                    &lt;/Link&gt;<br/>                &lt;/h3&gt;<br/>            &lt;/div&gt;<br/>            &lt;textarea value={note?.body}&gt;&lt;/textarea&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span><span id="b372" class="ow ns iq or b gy py oy l oz pa">export default NotePage</span></pre><p id="41aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一篇文章将研究如何调用我们的JSON服务器并检索笔记。</p><p id="4ea3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">更多内容看</em> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。在我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">社区不和谐</em> </strong> </a> <em class="ls">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>