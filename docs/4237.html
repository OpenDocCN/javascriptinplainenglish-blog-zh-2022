<html>
<head>
<title>Create a Proxy Server For APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为API创建代理服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-proxy-server-for-apis-ac62e87d4aa6?source=collection_archive---------1-----------------------#2022-11-12">https://javascript.plainenglish.io/create-a-proxy-server-for-apis-ac62e87d4aa6?source=collection_archive---------1-----------------------#2022-11-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ab34cf01f1234a0163a700e847806bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hUnfRDXAUKl_T4pG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="246a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">在Typescript中创建代理服务器</h1><p id="2c93" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">今天，我们将在Nodejs Typescript版本中创建一个代理服务器。我们将有一个端点，它将被重定向到某个外部路由，并从它们的端点返回一个响应</p><h2 id="0d6c" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">什么是代理？</h2><p id="6837" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你可能会问什么是代理。以及我们为什么需要它。所以基本上任何到你的URL的路径都会被其他代表你的URL所服务。例如，假设我们有一个名为<code class="fe mi mj mk ml b">https://api.any-orm.com/lead/create</code>的路径，但是你不希望你的终端用户看到这个请求，相反，它应该从<code class="fe mi mj mk ml b">POST https://your-url.com/orm/lead</code>开始导航，而不要让用户感觉离开网站。</p><p id="cc86" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated">这个例子是一个特定的路线，但你也可以代理任何路线，如<code class="fe mi mj mk ml b">https://api.any-orm.com/lead/*</code>到你的后端<code class="fe mi mj mk ml b"><a class="ae jz" href="https://your-backend.com/orm/lead/*" rel="noopener ugc nofollow" target="_blank">https://your-backend.com/orm/lead/*</a></code></p><h2 id="dcae" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">开始</h2><p id="4751" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在我们对什么是代理有了一个概念，所以我们可以开始在项目中实现它。在本教程的帮助下，我已经创建了快速ts入门应用程序，因此您也可以遵循它</p><div class="mr ms gp gr mt mu"><a href="https://blog.logrocket.com/how-to-set-up-node-typescript-express/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd io gy z fp mz fr fs na fu fw im bi translated">如何用Node.js和Express - LogRocket Blog设置TypeScript</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">当您构建用JavaScript编写的服务器并使用Node.js和Express时，开发的简易性是非常好的。但是…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">blog.logrocket.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni jt mu"/></div></div></a></div><p id="3d55" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated">现在让我们把注意力集中在代理上。我们将代理5个方法，包括指向端点<code class="fe mi mj mk ml b">/proxy</code>的<code class="fe mi mj mk ml b">GET, POST, PUT, PATCH, DELETE</code></p><p id="c604" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated">每当有人访问网站<code class="fe mi mj mk ml b">http://localhost:8000/api/proxy</code>时，所有的请求都会被重定向到<code class="fe mi mj mk ml b">https://reqres.in/api</code></p><h2 id="900b" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">第一步-创建路线</h2><p id="d5b6" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们在指向我们的<code class="fe mi mj mk ml b">proxyRequest</code>函数的* route之后发出了所有请求，该函数将接收请求和响应。在文章中，我们有时会写<code class="fe mi mj mk ml b">proxyRequest</code>的实现</p><pre class="nj nk nl nm gt nn ml no bn np nq bi"><span id="0e21" class="nr kb in ml b be ns nt l nu nv">import { Router } from "express";<br/>import proxyRequest from "./request";<br/>const router = Router();<br/><br/>router.get('/*', async (req, res) =&gt; await proxyRequest(req, res));<br/>router.post('/*', async (req, res) =&gt; await proxyRequest(req, res));<br/>router.put('/*', async (req, res) =&gt; await proxyRequest(req, res));<br/>router.patch('/*', async (req, res) =&gt; await proxyRequest(req, res));<br/>router.delete('/*', async (req, res) =&gt; await proxyRequest(req, res));<br/><br/>export default router</span></pre><h2 id="15b3" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">第二步—复制所需的标题</h2><p id="aaf0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">代理的一部分意味着网站的行为应该与实际的网站类似，这也意味着所有需要的头也应该只在那个时候被接受，并在我们有请求时被复制</p><pre class="nj nk nl nm gt nn ml no bn np nq bi"><span id="bf1e" class="nr kb in ml b be ns nt l nu nv">import { IncomingHttpHeaders } from "http";<br/>import { Request, Response } from "express";<br/>import fetch, { Headers } from "node-fetch";<br/><br/>async function copyRequiredHeaders(incomingHeaders: IncomingHttpHeaders): Promise&lt;Headers&gt; {<br/>  const localHeaders = new Headers();<br/><br/>  // Preserve the Accept header<br/>  if (incomingHeaders["accept"]) {<br/>    localHeaders.append("accept", incomingHeaders["accept"]);<br/>  }<br/><br/>  // Preserve If-Match<br/>  if (incomingHeaders["if-match"]) {<br/>    localHeaders.append("if-match", incomingHeaders["if-match"]);<br/>  }<br/><br/>  // Preserve Content-Type<br/>  if (incomingHeaders["content-type"]) {<br/>    localHeaders.append("content-type", incomingHeaders["content-type"]);<br/>  }<br/><br/>  return localHeaders;<br/>}</span></pre><p id="3f5f" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated">同样为了简单起见，我只处理了三个主标题<code class="fe mi mj mk ml b">accpet, if-match, content-type</code>，但是如果需要的话，你也可以创建更多的部分</p><p id="b524" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated">现在，头部被复制，我们可以创建一个请求并管理它的响应</p><h2 id="64ac" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">第三步—创建请求并管理响应</h2><p id="bfdf" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">首先，我们将通过用实际路径和域替换我们的路径来创建一个URL，然后我们将从<code class="fe mi mj mk ml b">req.headers</code>复制所需的头，然后如果您想要发送任何自定义数据或任何凭据，您可以发送它，否则我们将获取请求。</p><p id="84ef" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated"><code class="fe mi mj mk ml b">node-fetch</code>相当于来自浏览器的<code class="fe mi mj mk ml b">fetch</code> API，这意味着在响应的第二阶段，我们需要检测我们想要生成什么类型的响应。在我们的例子中，我们想要与用户想要的相同的响应，所以我们将使用<code class="fe mi mj mk ml b">response.headers</code>来确定使用<code class="fe mi mj mk ml b">buffer</code>方法的响应。稍后，如果您想再次向客户端发送更多的数据，那么您可以在响应中设置并返回值</p><pre class="nj nk nl nm gt nn ml no bn np nq bi"><span id="ae83" class="nr kb in ml b be ns nt l nu nv">export default async function proxyRequest(req: Request, res: Response): Promise&lt;void&gt; {<br/>  const url = req.path.replace("/proxy", ``);<br/>  const domain = 'https://reqres.in/api'<br/>  const newUrl = `${domain}${url}`;<br/>  const headers = await copyRequiredHeaders(req.headers);<br/>  const authData = {<br/>    token: 'attached custom token', // amy data you required<br/>    date: new Date().toUTCString()<br/>  }<br/><br/>  const response = await fetch(newUrl, {<br/>    method: req.method,<br/>    headers: {<br/>      ...headers,<br/>      Authorization: authData.token,<br/>      "x-version": "2016-07-11",<br/>      "x-date": authData.date,<br/>    },<br/>    body: req.method !== "GET" ? JSON.stringify(req.body) : undefined,<br/>  });<br/><br/>  const responseType = response.headers.get("content-type") ?? "application/json";<br/>  const bodyData = await response.buffer();<br/>  res<br/>    .status(response.status)<br/>    .type(responseType)<br/>    .set({<br/>      "request-id": response.headers.get("request-id"),<br/>      "client-request-id": response.headers.get("client-request-id"),<br/>    })<br/>    .send(bodyData);<br/>}</span></pre><h2 id="79f6" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">让我们测试</h2><p id="a70a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">为了在运行应用程序后测试这一点，我们可以转到<code class="fe mi mj mk ml b">http://localhost:8000/proxy/users</code>，它将指向实际路线<code class="fe mi mj mk ml b">https://reqres.in/api/users</code>，并将返回相应的数据</p><h2 id="e0e0" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">结论</h2><p id="6145" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这将是它，现在每个请求将从<code class="fe mi mj mk ml b">reqres.in/api</code>服务，你也可以自定义它。</p><p id="5e65" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated">有一些重要的事情需要注意，您应该只为最终用户代理开放API、路由或受保护的REST APIs，以避免任何网关或cors错误。此外，您只能在一定程度上定制身份验证机制，例如，如果路由受到oAuth的保护，那么您将不得不在您的终端管理它的令牌，并为下一个请求处理它们，这可能会成为一个管理难题</p><p id="abd1" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated">我希望您今天学到了一些新的东西，并在将来的类似用例中使用它。可以在<a class="ae jz" href="https://github.com/Piyush-Use-Personal/ts-proxy" rel="noopener ugc nofollow" target="_blank"> ts-proxy repo </a>和快乐编码中找到源代码！</p><p id="5669" class="pw-post-body-paragraph ky kz in la b lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr mq lt lu lv ig bi translated"><em class="nw">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nw">plain English . io</em></strong></a><em class="nw">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="nw">免费周报</em> </strong> </a> <em class="nw">。关注我们上</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nw">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nw">LinkedIn</em></strong></a><strong class="la io"><em class="nw"/></strong><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nw">YouTube</em></strong></a><strong class="la io"><em class="nw"/></strong><em class="nw">和</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="nw">不和</em> </strong> </a>  <em class="nw">对成长黑客感兴趣？检查</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="nw">电路</em> </strong> </a> <strong class="la io"> <em class="nw">。</em> </strong></p></div></div>    
</body>
</html>