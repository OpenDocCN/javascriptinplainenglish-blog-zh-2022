<html>
<head>
<title>JavaScript Engineering: The Science Behind</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript工程:背后的科学</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-concepts-every-programmer-should-know-v1-0-2-cc87f541e05?source=collection_archive---------3-----------------------#2022-05-26">https://javascript.plainenglish.io/javascript-concepts-every-programmer-should-know-v1-0-2-cc87f541e05?source=collection_archive---------3-----------------------#2022-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="91ea" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">软件工程</h2><div class=""/><div class=""><h2 id="96ca" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">每个程序员都应该知道的JavaScript概念</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e61b3044ea6e5d3ff132c29bbcbb642b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyySjhSD7tdqG9J0YZxfdw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Image Credit — Workato</figcaption></figure><p id="905e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">最近我在<a class="ae lx" href="https://be-ja.medium.com/javascript-concepts-every-programmer-should-know-d04731fe7a7c" rel="noopener"> <em class="ly">中写了关于JS的每个程序员都应该知道的JavaScript概念</em> </a>，社区反馈非常好。</p><div class="lz ma gp gr mb mc"><a href="https://be-ja.medium.com/javascript-concepts-every-programmer-should-know-d04731fe7a7c" rel="noopener follow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ix gy z fp mh fr fs mi fu fw iw bi translated">每个程序员都应该知道的JavaScript概念</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">JavaScript是网络的头号编程语言，但除此之外，它也传播到许多平台…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">be-ja.medium.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq kv mc"/></div></div></a></div><p id="99a8" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我注意到相当多的开发人员和读者觉得这很有趣，所以为什么不就这个主题写一个系列呢，因为如果你正在学习JavaScript或者甚至在工作中使用它，有更多有用的概念可以掌握和利用。</p><p id="7493" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">所以，让我们开始吧！</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="bf54" class="my mz in bd na nb nc nd ne nf ng nh ni kc nj kd nk kf nl kg nm ki nn kj no np bi translated">原型</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/96504caab1b9682c89e538da9b6de0ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFDsj8xeBJD93Sl8OF2LDg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Image Credit — <a class="ae lx" href="https://unsplash.com/@helloimnik" rel="noopener ugc nofollow" target="_blank">helloimnik unsplash.com</a></figcaption></figure><p id="5f9d" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">在JavaScript中，每个对象都从原型继承属性和方法。一个<em class="ly">原型</em>，<em class="ly"> </em>简单来说，可以看作是一个默认情况下与所有函数和对象相关联的基础对象。</p><p id="b364" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">例如，一个<code class="fe nr ns nt nu b">Date</code>对象继承了<code class="fe nr ns nt nu b">Date.prototype</code>，一个<code class="fe nr ns nt nu b">Array</code>继承了<code class="fe nr ns nt nu b">Array.prototype</code>，一个<code class="fe nr ns nt nu b">Person</code>对象将继承一个<code class="fe nr ns nt nu b">Person.prototype</code>。</p><p id="1bbd" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">此外，所有这些对象都将继承<code class="fe nr ns nt nu b">Object.prototype</code></p><p id="319c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">这对JavaScript的内部非常有用，我们知道它允许我们使用JavaScript，但一般来说，理解我们使用的所有对象属性和方法都是在原型级别定义的是很好的。您可以通过简单地注销<em class="ly">原型</em>来验证这一点，如下所示:</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="9a6d" class="nz mz in nu b gy oa ob l oc od"># Log prototype on type<br/>console.log(Array.prototype);</span><span id="54b0" class="nz mz in nu b gy oe ob l oc od"># Log prototype on instance<br/>let fruits = new Array("apple", "strawberry");<br/>console.log(fruits.__proto__);</span></pre><p id="c6f9" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">通过记录数组<em class="ly">的原型，</em>您应该能够看到它的属性和方法，比如:</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="7305" class="nz mz in nu b gy oa ob l oc od">keys: ƒ keys()<br/>entries: <em class="ly">ƒ entries()<br/></em>every: <em class="ly">ƒ every()<br/></em>filter: <em class="ly">ƒ filter()<br/></em>forEach: <em class="ly">ƒ forEach()<br/></em>indexOf: <em class="ly">ƒ indexOf()<br/>length: value<br/>...</em></span></pre><p id="6af3" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">如果您想知道<code class="fe nr ns nt nu b">__proto__</code>属性是什么，它只是一个<em class="ly">获取器/设置器</em>，它定义在<code class="fe nr ns nt nu b">Object.prototype</code>中，您也可以通过登录控制台来检查它。</p><h1 id="5f6e" class="my mz in bd na nb of nd ne nf og nh ni kc oh kd nk kf oi kg nm ki oj kj no np bi translated">班级</h1><p id="e628" class="pw-post-body-paragraph lb lc in ld b le ok jx lg lh ol ka lj lk om lm ln lo on lq lr ls oo lu lv lw ig bi translated">很多人不记得了，但是几年前，JavaScript主要被视为一种<em class="ly">函数式语言(不是今天的函数式语言)</em>，主要是因为缺乏基于类的特性。没有定义类的方法，如果你想定义，你基本上是在滥用函数，你会得出这样的结果:</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="7079" class="nz mz in nu b gy oa ob l oc od">function Person(name) {<br/>    this.name = name<br/>}</span><span id="e858" class="nz mz in nu b gy oe ob l oc od">var person = new Person("Medium");</span></pre><p id="9fe8" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">幸运的是，多亏了ECMAScript标准及其背后的委员会，在过去几年中引入了许多特性，其中之一就是<em class="ly">类。</em></p><p id="9fe6" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">为了将属性和函数封装到一个单独的<em class="ly">模板</em>中，您应该像这样声明和使用一个类:</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="d9fb" class="nz mz in nu b gy oa ob l oc od">class Person {<br/>    constructor(firstname, lastname) {<br/>        this.firstname = firstname;<br/>        this.lastname = lastname;<br/>    }<br/>    <br/>    get name(){<br/>        return this.firstname + this.lastname;<br/>    }<br/>    <br/>    sayHello(){<br/>        return `Hello my name is ${this.name}!`<br/>    }<br/>}</span><span id="0592" class="nz mz in nu b gy oe ob l oc od">let person = new Person("Medium", ".com");<br/>let fullname = person.name;<br/>let hello = person.sayHello();</span></pre><p id="02e9" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">显然还有很多课程，请务必查看:</p><ul class=""><li id="66d2" class="op oq in ld b le lf lh li lk or lo os ls ot lw ou ov ow ox bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#static_methods_and_properties" rel="noopener ugc nofollow" target="_blank">静态方法和属性</a></li><li id="aba8" class="op oq in ld b le oy lh oz lk pa lo pb ls pc lw ou ov ow ox bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#static_methods_and_properties" rel="noopener ugc nofollow" target="_blank">私有和公共字段</a></li><li id="99be" class="op oq in ld b le oy lh oz lk pa lo pb ls pc lw ou ov ow ox bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#field_declarations" rel="noopener ugc nofollow" target="_blank">扩展类</a></li></ul><p id="d47a" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我强烈建议阅读Mozilla的MDN Web Docs上的课程。</p><h1 id="5b64" class="my mz in bd na nb of nd ne nf og nh ni kc oh kd nk kf oi kg nm ki oj kj no np bi translated">通过值或引用传递</h1><p id="d426" class="pw-post-body-paragraph lb lc in ld b le ok jx lg lh ol ka lj lk om lm ln lo on lq lr ls oo lu lv lw ig bi translated">在每种编程语言中，都存在参数是按值传递还是按引用传递的问题。</p><p id="8bd9" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">JavaScript主要是<em class="ly">按值传递，这意味着所有参数都是变量的副本。例如，在函数内对参数所做的任何更改都不会反映在函数外传递的变量中。</em></p><p id="fab1" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">上一段中的“<em class="ly">大多”</em>部分是因为对于原始值来说这是真的。例如，下面的代码说明了值是如何被复制的，并且对变量<code class="fe nr ns nt nu b">firstname</code>和<code class="fe nr ns nt nu b">lastname</code> <strong class="ld ix"> </strong>所做的更改不会反映在函数之外。</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="d4c9" class="nz mz in nu b gy oa ob l oc od"># Pass by value for primitives<br/>function changeName(firstname, lastname) {<br/>    firstname = "something";<br/>    lastname = "else";<br/>}</span><span id="33de" class="nz mz in nu b gy oe ob l oc od">let firstname = "First";<br/>let lastname = "Last";</span><span id="2f08" class="nz mz in nu b gy oe ob l oc od">changeName(firstname, lastname);</span><span id="ade3" class="nz mz in nu b gy oe ob l oc od">console.log(firstname, lastname); // Still prints "First" and "Last"</span></pre><p id="d069" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">对于复杂类型，这有一点不同——我们传递给函数的对象不会被复制，<em class="ly">或者它们的数据本身</em>。</p><p id="ccc3" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">简单地说，将一个对象传递给一个函数只会创建该引用的另一个副本，它指向该对象的内存部分。</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="2a88" class="nz mz in nu b gy oa ob l oc od"># Passing an object results in copying the reference only<br/>function changePerson(obj) {<br/>     obj.name = "New Name";<br/>     obj = {name: "Another New Name"};<br/>}</span><span id="ed89" class="nz mz in nu b gy oe ob l oc od">let person = {name: "Medium"};<br/>changePerson(person);<br/>console.log(person); // Prints {name: "New Name"}</span></pre><p id="deb9" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">在上面的例子中，在调用<code class="fe nr ns nt nu b">changePerson</code>并传递<code class="fe nr ns nt nu b">person</code>的时候，一个<em class="ly">新的引用将被创建</em>——这意味着任何<em class="ly">对该对象内的字段的改变，将在函数</em>之外被反映，但是分配一个新的对象ie。<em class="ly">改变</em> <code class="fe nr ns nt nu b">person</code> <em class="ly">所指，不起任何作用</em>。通过分配一个新的对象，我们分配了一个新的内存块，并且只改变了<em class="ly">新复制的引用</em>指向的内容，而不是原来的那个。</p><p id="9c9f" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">为了说明上述内容，还可以用一个等式或身份检查来实现。</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="a2ec" class="nz mz in nu b gy oa ob l oc od"># Passing an object results in copying the reference only<br/>function changePerson(obj) {<br/>     obj.name = "New Name";<br/>     console.log(person === obj); // Results in true<br/>     obj = {name: "New Name"};<br/>     console.log(person === obj); // Results in false<br/>}</span><span id="2ec7" class="nz mz in nu b gy oe ob l oc od">let person = {name: "Medium"};<br/>changePerson(person);<br/>console.log(person); // Prints {name: "New Name"}</span></pre><p id="94b6" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">第一次检查将导致<em class="ly">为真</em>，因为它是所讨论的同一个对象，并且不是副本，即使某个字段已被更改，但是第二次检查将导致<em class="ly">为假</em>，因为由<code class="fe nr ns nt nu b">person</code>和<code class="fe nr ns nt nu b">obj</code>指向的对象不再相同。</p><h1 id="d344" class="my mz in bd na nb of nd ne nf og nh ni kc oh kd nk kf oi kg nm ki oj kj no np bi translated">收集</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pd"><img src="../Images/2714df7f7dc88c4c3e5f69dc1f1ac40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1um4aD7PHfznCeiPTbcHYw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Image Credit — <a class="ae lx" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">unsplash.com</a></figcaption></figure><p id="c973" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">在大多数编程语言中，集合是非常重要的东西。有数组、集合、映射、散列表、树等等。这些都是不同的数据结构，用于不同的目的。</p><p id="ee3c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">JavaScript和其他的相比如何——我们可以利用哪些集合？</p><h2 id="3493" class="nz mz in bd na pe pf dn ne pg ph dp ni lk pi pj nk lo pk pl nm ls pm pn no it bi translated">数组——或者我应该称之为列表</h2><p id="2f57" class="pw-post-body-paragraph lb lc in ld b le ok jx lg lh ol ka lj lk om lm ln lo on lq lr ls oo lu lv lw ig bi translated">首先，有些数组和其他数组列表是一样的。<em class="ly">是的，JavaScript数组实际上更像列表而不是数组。</em>只需运行next就可以显示所有可以在数组上使用的属性和方法，否则这些属性和方法只能在其他语言的列表中找到。</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="f678" class="nz mz in nu b gy oa ob l oc od"># JS Array is more like a List<br/>let fruits = ["apple", "strawberry"];<br/>console.log(fruits.__proto__); // join, filter, map, forEach etc.</span></pre><p id="cf3b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">现在，我经常听到别人说JavaScript中的数组和对象是一样的，数组的索引只是对象<em class="ly">中的<em class="ly">键</em>。</em></p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="d6c4" class="nz mz in nu b gy oa ob l oc od"># Arrays and Objects<br/>let fruits = ["apple", "strawberry"];<br/>let fruitsObj = {0: "apple", 1: "strawberry"};</span></pre><p id="b492" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">以上可能导致持有相同的索引/键和值，但是再次检查类型，这将是清楚的，或者甚至更好地记录这些实例的<code class="fe nr ns nt nu b">__proto__</code>字段，您将看到<em class="ly">所有的差异</em>。同样，这也适用于将对象与以下任何集合进行比较。</p><h2 id="af3e" class="nz mz in bd na pe pf dn ne pg ph dp ni lk pi pj nk lo pk pl nm ls pm pn no it bi translated">设置</h2><p id="dffb" class="pw-post-body-paragraph lb lc in ld b le ok jx lg lh ol ka lj lk om lm ln lo on lq lr ls oo lu lv lw ig bi translated">与大多数语言一样，JavaScript <code class="fe nr ns nt nu b">Set</code>是一个可迭代的集合，允许您存储唯一的值。JavaScript是一种非常动态的语言，允许我们存储任何类型的值，无论是原语还是对象。</p><p id="53b1" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">在大多数语言中，当有人提到一个集合时——他们可能会想到一个散列集合——它通常不保持插入的顺序，这同样适用于映射/散列表。</p><p id="45ee" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">然而，JavaScript的<code class="fe nr ns nt nu b">Set</code>确实保持了插入的顺序，这一点值得注意，而且与人们的预期大相径庭。</p><p id="5da3" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">除此之外，同样重要的是，如前所述，集合中的值可能只出现一次。</p><p id="6c2d" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">还有一件非常重要的事情是，集合的<code class="fe nr ns nt nu b">has</code>方法比数组的<code class="fe nr ns nt nu b">includes</code>方法更快，但是它缺乏通过数组索引的直接访问，考虑到如果您想要实现对元素的快速直接访问，您首先会使用一个对象或一个映射，这可能不是那么重要。</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="a4ec" class="nz mz in nu b gy oa ob l oc od"># Sets<br/>let fruits = new Set(["apple", "strawberry"]);</span><span id="abb8" class="nz mz in nu b gy oe ob l oc od">fruits.add("pear");<br/>let containsPear = fruits.has("pear"); // true</span><span id="d3d5" class="nz mz in nu b gy oe ob l oc od">fruits.delete("apple");<br/>let containsApple = fruits.has("apple"); // false</span><span id="887c" class="nz mz in nu b gy oe ob l oc od">fruits.clear();<br/>let size = fruits.size; // 0</span></pre><p id="6093" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">除了上面的例子，谢天谢地，对于原型，你还可以在set上使用<code class="fe nr ns nt nu b">forEach</code>、<code class="fe nr ns nt nu b">entries</code>、<code class="fe nr ns nt nu b">keys</code>、<code class="fe nr ns nt nu b">values</code>方法！</p><h2 id="99ef" class="nz mz in bd na pe pf dn ne pg ph dp ni lk pi pj nk lo pk pl nm ls pm pn no it bi translated">地图</h2><p id="2a2f" class="pw-post-body-paragraph lb lc in ld b le ok jx lg lh ol ka lj lk om lm ln lo on lq lr ls oo lu lv lw ig bi translated">个人最喜欢的收藏— <code class="fe nr ns nt nu b">Map</code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi po"><img src="../Images/57639ce5dcac1838da324fb5784c2c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_3JMyd5o-_w_hFMAX5h9Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Image Credit — <a class="ae lx" href="https://unsplash.com/@geojango_maps" rel="noopener ugc nofollow" target="_blank">geojango_maps unsplash.com</a></figcaption></figure><p id="cce3" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">正如已经提到的，当有人说<em class="ly">映射</em>时，他们可能指的是<em class="ly">哈希映射，</em>是的，JavaScript映射基本上都是哈希映射。map是键控集合的一种类型，它是可迭代的，和set一样，它保持插入顺序。</p><p id="238e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">除此之外，使用地图的最大好处之一是可以快速直接访问元素。</p><p id="285e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">给定一个人员数组，为了过滤并找到一个特定的值，您必须迭代每个元素，并根据您需要的属性检查它的姓氏属性，只有当您找到第一个匹配时，您才会返回值。</p><p id="7df3" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">还有你要做多少次迭代和运算？嗯，在一个一千长的数组上——可能有一千次迭代。这基本上就是所发生的事情，不仅仅是数组上的for循环，大多数搜索方法都是如此，比如<code class="fe nr ns nt nu b">find</code>或者<code class="fe nr ns nt nu b">includes<strong class="ld ix">.</strong></code></p><p id="a640" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">有了地图，你可以存储以姓氏为关键字的<em class="ly">个人</em>，这样当你搜索一个人的时候——你基本上可以使用地图的<code class="fe nr ns nt nu b">get</code>方法在一个操作中检索到。</p><pre class="km kn ko kp gt nv nu nw nx aw ny bi"><span id="5b88" class="nz mz in nu b gy oa ob l oc od"># Maps<br/>let john = {name: 'John', dob: '1990-10-12'};<br/>let mary = {name: 'Mary', dob: '2001-06-09'};<br/>let alex = {name: 'Alex', dob: '2000-05-10'};</span><span id="21ea" class="nz mz in nu b gy oe ob l oc od">let persons = new Map();<br/>persons.set(john.name, john);<br/>persons.set(mary.name, mary);<br/>persons.set(alex.name, alex);</span><span id="85ee" class="nz mz in nu b gy oe ob l oc od">let name = 'John';<br/>let person = persons.get(name);</span></pre><p id="375e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">这种函数的复杂性、效率和极限通常用数学表达式来描述，称为大O符号。在以后的一些主题中会有更多关于这方面的内容，但我建议阅读一下它以及它与执行和内存所需时间的关系。</p><p id="ff54" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">此外，传统上——几年前，物体基本上被用作地图。您可以获得将值映射到字符串的类似功能，但是映射的一些好处是:</p><ul class=""><li id="a7bd" class="op oq in ld b le lf lh li lk or lo os ls ot lw ou ov ow ox bi translated">映射中的键可以是任何值，而不仅仅是字符串</li><li id="ef61" class="op oq in ld b le oy lh oz lk pa lo pb ls pc lw ou ov ow ox bi translated">贴图有大小属性，而你必须在对象上计算它</li></ul><p id="b831" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我强烈建议阅读更多关于地图的内容，例如在Mozilla的MDN Docs上，因为在你的技能组合中拥有地图是非常重要的，不仅是在JavaScript中，在所有编程语言中都是如此。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="8cc5" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">如果你是一个正在阅读这篇文章的开发人员，我希望它能帮助你，不管你是刚开始还是已经工作了很多年。请不吝赐教，提出更多有可能帮助到别人的概念！</p><p id="18c6" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我希望您觉得这很有用，并且喜欢JavaScript概念系列的第二篇文章。如果你喜欢它的内容，点击follow，和我一起踏上研究和撰写更多关于JavaScript背后的科学和工程的旅程。</p><p id="1ab5" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">感谢您的阅读！🎉</p><p id="22e0" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><em class="ly">更多内容请看</em><a class="ae lx" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ld ix"><em class="ly">plain English . io</em></strong></a><em class="ly">。报名参加我们的</em> <a class="ae lx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ix"> <em class="ly">免费周报</em> </strong> </a> <em class="ly">。关注我们关于</em><a class="ae lx" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ld ix"><em class="ly">Twitter</em></strong></a><em class="ly">和</em><a class="ae lx" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ld ix"><em class="ly">LinkedIn</em></strong></a><em class="ly">。查看我们的</em> <a class="ae lx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ix"> <em class="ly">社区不和谐</em> </strong> </a> <em class="ly">加入我们的</em> <a class="ae lx" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ix"> <em class="ly">人才集体</em> </strong> </a> <em class="ly">。</em></p></div></div>    
</body>
</html>