<html>
<head>
<title>JavaScript Algorithms: Maximum Subarray (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:最大子数组(LeetCode)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithms-maximum-subarray-leetcode-15812b95bc4?source=collection_archive---------6-----------------------#2022-01-12">https://javascript.plainenglish.io/javascript-algorithms-maximum-subarray-leetcode-15812b95bc4?source=collection_archive---------6-----------------------#2022-01-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d0f7b07f24b74f4fa68f64971530337f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-Re2F7Ra_SRHOJYZS35Xg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kupriets?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Bogdan Kupriets</a> on <a class="ae jz" href="https://unsplash.com/explore?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a91b" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">描述</h1><p id="aa38" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">给定一个整数数组<code class="fe lw lx ly lz b">nums</code>，找到具有最大和的连续子数组(至少包含一个数),并返回其和<em class="ma">。</em></p><p id="2dd0" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">一个<strong class="la io">子数组</strong>是一个数组的<strong class="la io">连续</strong>部分。</p><p id="70ff" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io">例1: </strong></p><pre class="mg mh mi mj gt mk lz ml mm aw mn bi"><span id="873c" class="mo kb in lz b gy mp mq l mr ms"><strong class="lz io">Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]<br/><strong class="lz io">Output:</strong> 6<br/><strong class="lz io">Explanation:</strong> [4,-1,2,1] has the largest sum = 6.</span></pre><p id="1bf8" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io">例2: </strong></p><pre class="mg mh mi mj gt mk lz ml mm aw mn bi"><span id="c9d4" class="mo kb in lz b gy mp mq l mr ms"><strong class="lz io">Input:</strong> nums = [1]<br/><strong class="lz io">Output:</strong> 1</span></pre><p id="6809" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io">例3: </strong></p><pre class="mg mh mi mj gt mk lz ml mm aw mn bi"><span id="357a" class="mo kb in lz b gy mp mq l mr ms"><strong class="lz io">Input:</strong> nums = [5,4,-1,7,8]<br/><strong class="lz io">Output:</strong> 23</span></pre><p id="80a5" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><strong class="la io">约束:</strong></p><ul class=""><li id="90b6" class="mt mu in la b lb mb lf mc lj mv ln mw lr mx lv my mz na nb bi translated"><code class="fe lw lx ly lz b">1 &lt;= nums.length &lt;= 105</code></li><li id="7041" class="mt mu in la b lb nc lf nd lj ne ln nf lr ng lv my mz na nb bi translated"><code class="fe lw lx ly lz b">-104 &lt;= nums[i] &lt;= 104</code></li></ul><h1 id="e228" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决办法</h1><p id="ca38" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">解决这个问题有几种选择:<em class="ma">蛮力方法，Kadane的算法</em>和<em class="ma">分而治之方法。</em></p><h2 id="fb41" class="mo kb in bd kc nh ni dn kg nj nk dp kk lj nl nm ko ln nn no ks lr np nq kw nr bi translated">强力方法</h2><p id="8e63" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们可以计算每一个可能的子阵列的和，其中的最大值就是解。非常明显，但是不太好解，因为它有时间复杂度<em class="ma"> O(n)和s </em>步复杂度:<em class="ma"> O(1) </em>。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d0b5" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">在Chrome浏览器中的开始位置<strong class="la io"> <em class="ma"> i = 0 </em> </strong>和<strong class="la io"><em class="ma">j = 0</em></strong><strong class="la io"><em class="ma">maxSum =-9007199254740991</em></strong>。此外，当我们与<strong class="la io"><em class="ma">currentsubraysum</em></strong>的总和进行比较时，我们将覆盖变量<strong class="la io"> <em class="ma"> maxSum。</em>T44】</strong></p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1663c1f79bf1d75a5482920aaab9ae57.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*4pfvRoR44NQQqi01XQ_NCw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Brute Force Approach</figcaption></figure><p id="2670" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">枚举完所有选项后，<strong class="la io"> <em class="ma"> maxSum </em> </strong>将存储顺序子数组的最大和。</p><h2 id="4845" class="mo kb in bd kc nh ni dn kg nj nk dp kk lj nl nm ko ln nn no ks lr np nq kw nr bi translated"><em class="nv">卡丹的算法</em></h2><p id="d41d" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们将从数组<strong class="la io"> <em class="ma"> nums </em> </strong>的第一个元素开始，计算以元素<strong class="la io"> <em class="ma"> nums[i + n]结尾的每个可能的子数组的总和。</em> </strong>更难理解的解但具有更好的时间复杂度<em class="ma"> O(n)和相同的s </em>步复杂度:<em class="ma"> O(1)。</em></p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3803" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">当数组的下一个元素大于prev子数组与current元素之和(<strong class="la io"><em class="ma">running sum = math . max(running sum+nums[I]，nums[i] </em> </strong>)时，我们改变子数组的开头，从当前元素开始。示例<strong class="la io"> <em class="ma"> i =1 </em> </strong>和<strong class="la io"> <em class="ma"> i = 3 </em> </strong>如下图所示。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/46854c068c120de421a2d3ea80b79990.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*2uCRqRGnxpqD4v41YPiShw.png"/></div></figure><p id="749c" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">在计算的最后，我们将得到max sum = 6。</p><h2 id="4ce4" class="mo kb in bd kc nh ni dn kg nj nk dp kk lj nl nm ko ln nn no ks lr np nq kw nr bi translated"><strong class="ak"> <em class="nv">分而治之</em> </strong></h2><p id="2dde" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这种方法比<em class="ma"> Kadane的算法</em>慢，比<em class="ma">蛮力方法<em class="ma"> </em>快<em class="ma"> </em>。</em>有<em class="ma"> t </em>时间复杂度:<em class="ma">)</em>空间复杂度:<em class="ma"> O(log(n)) </em>。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b298" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">这个解决方案很难理解，因为它使用了递归调用自身的函数<em class="ma">findmaxsubaraysum</em>。对于每个递归函数，必须有一个条件，在这个条件下递归调用被中断。在我们的例子中，这是比较左和右数组的索引(<strong class="la io"> <em class="ma">左&gt;右)</em> </strong>)。</p><p id="a618" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">考虑一个更简单的数组作为例子<strong class="la io">【5，4，-1，7，8】<em class="ma">。</em>T9】</strong></p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6c917e08539a3010ed53dfd8a935c526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*e1RfcfVvewCjKO-nwL1R2A.png"/></div></figure><p id="c67b" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">在我们第一次调用<em class="ma">findmaxsubaraysum</em>时，我们在数组中搜索mid，并使用for循环从mid开始访问左侧和右侧的每个元素，并检查最大和。然后，我们将数组分成两半，每一半调用<em class="ma">findmaxsubaraysum</em>。这两个调用都将遍历这一半中的每个元素，这又组合成了nums的每个元素。当数组的开始索引大于数组的结束索引(<strong class="la io"><em class="ma">left&gt;right</em></strong>)时，我们返回可能的最小值。</p><p id="8bd4" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">计算结束时，我们的函数返回数组的最大和，包括其中间的<strong class="la io"> max <em class="ma"> Sum </em> </strong>，或者数组右侧或左侧的和，如果和也较大(<em class="ma">math . max(</em><strong class="la io"><em class="ma">left half</em></strong><em class="ma">，</em><strong class="la io"><em class="ma">right half</em></strong><em class="ma">)。</em></p><p id="1b64" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">希望对你有用！</p><p id="59c0" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated">感谢阅读！回头见。😊</p><p id="fe99" class="pw-post-body-paragraph ky kz in la b lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv ig bi translated"><em class="ma">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ma">plain English . io</em></strong></a><em class="ma">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ma">免费周报</em> </strong> </a> <em class="ma">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ma">Twitter</em></strong></a><em class="ma">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ma">LinkedIn</em></strong></a><em class="ma">。查看我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ma">社区不和谐</em> </strong> </a> <em class="ma">加入我们的</em> <a class="ae jz" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ma">人才集体</em> </strong> </a> <em class="ma">。</em></p></div></div>    
</body>
</html>