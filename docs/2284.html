<html>
<head>
<title>Angular Custom Form Controls &amp; Nested Form Groups Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度定制表单控件和嵌套表单组变得简单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-custom-form-controls-nested-form-groups-made-easy-2ac09e91cf67?source=collection_archive---------0-----------------------#2022-05-27">https://javascript.plainenglish.io/angular-custom-form-controls-nested-form-groups-made-easy-2ac09e91cf67?source=collection_archive---------0-----------------------#2022-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a49" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何让你的表单更具可重用性，拆分，让它们更具动态性。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/95c43fa27f052c1cc55116d6cd39143c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOwr4MG2HbOh53FyKwTP7Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.istockphoto.com/portfolio/ALLVISIONN" rel="noopener ugc nofollow" target="_blank">ALLVISIONN</a></figcaption></figure><p id="5b80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于简单的案例，表单可以变得轻而易举。但是，一旦您开始构建比注册表单更复杂的东西，事情就会变得非常复杂。</p><p id="65a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当表单变得棘手时，有一些东西会让你的生活变得更容易，比如<em class="ls">自定义表单控件</em>和<em class="ls">嵌套表单组</em>。这将是本文的重点。如何让我们的表单更具可重用性，如何拆分它们，让它们更具动态性。</p><p id="9001" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们开始吧！</p><h1 id="1b04" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">自定义窗体控件(控件值访问器)</h1><p id="b795" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">自定义表单控件是与Angular Forms API兼容的指令。所谓兼容，我们的意思是它可以像任何其他本机表单控件元素一样在表单中使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4031" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者等同于模板驱动的表单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="97e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来有多整洁干净？</p><p id="03a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，这个自定义表单控件可以实现为与表单模块无关。它可以用于模板驱动的表单和反应式表单。</p><p id="e245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，假设我们的应用程序使用了很多表单，这些表单又有很多文本字段。大多数文本字段是相同的，需要有一致的显示和行为。</p><p id="a3c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先构建一个简单的定制表单控件，名为<code class="fe ms mt mu mv b">required-field</code>。顾名思义，它将是一个必需的输入字段，显示适当的验证消息，并根据其状态(有效或无效)调整其样式。</p><p id="0a1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们需要实现三件事。</p><p id="2118" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。支持原生文本元素所做的一切</strong></p><p id="7457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了支持原生表单元素所做的一切，我们需要构建一个<code class="fe ms mt mu mv b">ControlValueAccessor (CVA)</code>。该接口充当表单控件的视图和模型之间的桥梁。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/801e7f4bed7e9daa37bbdad2907ec57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4zZ9Lnv87MV4k9XG1J_Qw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Control Value Accessor (CVA) acts as a bridge between the view and the model</figcaption></figure><p id="b524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两者需要同步，表单控件才能正常工作。当您在字段中键入一些内容时，需要将值发送回模型。当您以编程方式设置一个值时，该更改需要反映在视图中。</p><p id="678a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现<code class="fe ms mt mu mv b">ControlValueAccessor</code>接口很简单。我们只需要实现3个强制方法:</p><ul class=""><li id="8b39" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><code class="fe ms mt mu mv b">writeValue(value)</code> —当请求从模型到视图的编程更改时，由表单API调用以写入视图</li><li id="0fe4" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe ms mt mu mv b">registerOnChange(fn)</code> —提供一个回调函数<code class="fe ms mt mu mv b">fn</code>，当我们的输入值发生变化时，就应该调用这个函数</li><li id="9b4c" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe ms mt mu mv b">registerOnTouched(fn)</code> —提供一个回调函数<code class="fe ms mt mu mv b">fn</code>，当我们的输入被认为被触摸或模糊时，应该调用这个函数</li></ul><p id="7361" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且可选地还有1个:</p><ul class=""><li id="86e1" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><code class="fe ms mt mu mv b">setDisabledState(value)</code> —当控件状态变为“禁用”或从“禁用”变为“禁用”时，由forms API调用</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3a03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前一个片段中发生了一些事情。我们使用<code class="fe ms mt mu mv b">writeValue</code>将新值传递给显示视图。我们使用<code class="fe ms mt mu mv b">setDisabledState</code>来存储禁用状态。最后，我们存储由<code class="fe ms mt mu mv b">registerOnChange</code>和<code class="fe ms mt mu mv b">registerOnTouched</code>提供的回调函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3bc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在模板HTML文件中，我们在<code class="fe ms mt mu mv b">(input)</code>和<code class="fe ms mt mu mv b">(blur)</code>上调用存储的回调函数，以允许表单API自我更新。</p><p id="eb74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ms mt mu mv b">CVA</code>已经可以使用了，我们需要提供它。我们需要这样做，以便像<code class="fe ms mt mu mv b">NgModel</code>和<code class="fe ms mt mu mv b">FormControlName</code>这样的表单控制指令可以将我们的组件识别为值访问器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="006a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。应用所需的验证</strong></p><p id="c01e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您首先想到的可能是将<code class="fe ms mt mu mv b">required</code>属性添加到内部文本字段中。但这不会如你所愿。</p><p id="d197" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们不知道也不应该假设组件视图下面是什么。它可以是不支持表单验证属性的任何东西，比如div和spans。</p><p id="5dcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，回想一下我们是如何需要实现一个特定的通信“协议”<code class="fe ms mt mu mv b">CVA</code>接口来支持本地表单元素功能的？我们还需要使用各自的协议来支持验证。</p><p id="7dcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要实现<code class="fe ms mt mu mv b">Validator</code>接口，它有一个强制方法:</p><ul class=""><li id="addf" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><code class="fe ms mt mu mv b">validate(ctrl: AbstractControl)</code> —对提供的控件执行同步验证</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="786e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我们的<code class="fe ms mt mu mv b">Validator</code>已经可以使用了，我们需要提供它。我们需要这样做，以便像<code class="fe ms mt mu mv b">NgModel</code>和<code class="fe ms mt mu mv b">FormControlName</code>这样的表单控制指令可以将我们的组件识别为验证器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="6f90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。控制无效时显示错误信息并调整其样式</strong></p><p id="8328" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一步中，用户可以在这个控件上添加我们不知道的任何自定义验证。在这种情况下，我们需要获得下面的模型，并检查它是有效还是无效。</p><p id="d7e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最明显的方法是创建一个输入并传递表单控件实例本身。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="67f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那会工作得很好。除非它会违背创建自定义窗体控件的初衷。如果每次都要通过控件，过一会儿就开始变得有点烦了。</p><p id="f497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们希望有一种方法可以在内部访问表单控件，而不需要用户将它传入。但是，怎么做呢？进入<em class="ls">依赖注入</em>！</p><p id="21c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也说过我们的自定义窗体控件是窗体模块不可知的，不是吗？</p><p id="8570" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，我们需要为模板驱动的表单注入<code class="fe ms mt mu mv b"><a class="ae kv" href="https://angular.io/api/forms/NgControl" rel="noopener ugc nofollow" target="_blank">NgControl</a></code>而不是<code class="fe ms mt mu mv b">NgModel</code>，或者为反应式表单注入<code class="fe ms mt mu mv b">FormControlName</code>。我们可以这样做，因为<code class="fe ms mt mu mv b">NgModel</code>和<code class="fe ms mt mu mv b">FormControlName</code>都是<code class="fe ms mt mu mv b">NgControl</code>的子类，并且将它们自己提供为<code class="fe ms mt mu mv b">NgControl</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们称之为简单的例子。这个<code class="fe ms mt mu mv b">@Self()</code>装饰工是什么？</p><p id="c1bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe ms mt mu mv b">@Self()</code>装饰器将范围限制在我们当前所在的元素上。这是必要的，因为如果我们的自定义表单控件被包装在其他人的表单控件中，我们可能会得到一个错误的表单控件实例。</p><p id="2ea8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一件事是<code class="fe ms mt mu mv b">NgControl</code>正在注入值访问器和验证器。还记得我们说过需要将组件作为值访问器和验证器来提供吗？</p><p id="6c71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，我们不能同时做这两件事！</p><p id="6744" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们注入<code class="fe ms mt mu mv b">NgControl</code>并且<code class="fe ms mt mu mv b">NgControl</code>正在注入值访问器，其中包括我们提供的组件，这就是一个循环依赖！由于我们需要获得模型，我们确实需要注入<code class="fe ms mt mu mv b">NgControl</code>。因此，我们应该删除提供者以避免循环依赖。</p><p id="0ec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在我们的工作是用正确的值访问器和验证器正确地设置<code class="fe ms mt mu mv b">NgControl</code>。幸运的是，这很容易做到。</p><p id="1e45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于值访问器部分，我们只需将控制指令的<code class="fe ms mt mu mv b">valueAccessor</code>属性设置为<code class="fe ms mt mu mv b">this</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ad1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于验证器部分，我们可以以编程方式添加验证器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="61de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要修改<code class="fe ms mt mu mv b">writeValue</code>方法的实现，以便它使用注入的控制指令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在模板文件中，我们现在可以确定何时显示验证错误消息。在我们的例子中，如果控件被触摸并且无效。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="dfe6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">注意:</em> </strong> <em class="ls">虽然也有一个</em> <code class="fe ms mt mu mv b"><em class="ls">invalid</em></code> <em class="ls">属性，但是我们仍然希望坚持使用</em><code class="fe ms mt mu mv b"><em class="ls">!valid</em></code><strong class="ky ir"><em class="ls"/></strong><em class="ls">选项，这样我们就可以支持异步验证器。这是因为异步验证器在处理时有一个挂起状态。所以当控件挂起时，它既不是有效的也不是无效的。所以我们需要具体说“无效”。</em></p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="a077" class="lt lu iq bd lv lw ns ly lz ma nt mc md jw nu jx mf jz nv ka mh kc nw kd mj mk bi translated">嵌套表单组(复合值访问器)</h1><p id="3be6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们已经研究了如何创建带有单个输入字段的自定义表单控件。但是如果我们需要反复使用多个输入，一组字段呢？例如，如果我们需要应用程序中不同位置的个人信息字段，该怎么办？</p><p id="bdef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要复制粘贴吗？绝不！</p><p id="c495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们可以用我们所学的来创造一个<strong class="ky ir"> <em class="ls">的复合CVA </em> </strong>。让我们创建一个名为<code class="fe ms mt mu mv b">personal</code>的新组件。我们还可以在新组件中使用我们以前的定制表单控件<code class="fe ms mt mu mv b">required-field</code>,让事情变得更加简单！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ca32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对自定义表单控件做了两处修改。我们向组件引入了一个名为placeholder的输入和一个名为blur的输出。该输出是将输入字段的<code class="fe ms mt mu mv b">onTouched</code>事件从<code class="fe ms mt mu mv b">required-field</code>内部冒泡到其父字段所必需的。</p><p id="f341" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个组件的TypeScript文件也有一些变化。我们将一个一个地介绍它们。</p><p id="5e9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要定义表单及其验证。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="38c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有字段都是必填的，如果用户为性别字段选择“其他”选项，他/她需要通过一个额外的字段指定性别，这也是必填的。</p><p id="b753" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要实现<code class="fe ms mt mu mv b">CVA</code>接口方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1557" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们修改方法以使用<code class="fe ms mt mu mv b">form</code>变量。主要区别在于<code class="fe ms mt mu mv b">registerOnChange</code>方法。回想一下，这个方法为我们提供了回调，只要输入值发生变化，就应该调用这个回调。不同之处在于，现在输入的是整个表单。因此，我们最好的选择是每当<code class="fe ms mt mu mv b">valueChanges</code>发出时调用回调。</p><p id="4d6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要实现<code class="fe ms mt mu mv b">Validator</code>接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="60df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你可能会想，这有必要吗？我们不是已经在表单中包含了验证吗？答案是，我们做到了，但只针对存在于这个组件中的形式。如果我们不实现这个接口，父窗体将无法知道这个嵌套窗体的状态。</p><p id="d248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们这次没有注入<code class="fe ms mt mu mv b">NgControl</code>，所以我们还需要使用<code class="fe ms mt mu mv b">NG_VALUE_ACCESSOR</code>令牌将这个组件作为值访问器，使用<code class="fe ms mt mu mv b">NG_VALIDATORS</code>令牌作为验证器。</p><p id="d212" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我们实现了一个表单组来收集用户的个人信息。表单组是可重用的，并且可以嵌套在现有的反应式表单中。</p><p id="d3c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在下面的StackBlitz找到一个工作演示。别忘了<a class="ae kv" href="https://vkagklis.medium.com/subscribe" rel="noopener">订阅我的简讯</a>来关注更多类似的内容！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx mr l"/></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="1b7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">* *更新**: </strong>我们已经使用<code class="fe ms mt mu mv b">NgControl</code>注入实现了<code class="fe ms mt mu mv b">PersonalComponent</code>。你可以在这个StackBlitz链接中找到之前演示<a class="ae kv" href="https://stackblitz.com/edit/custom-form-controls-demo-enhanced" rel="noopener ugc nofollow" target="_blank">的增强版。</a></p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="2cb8" class="lt lu iq bd lv lw ns ly lz ma nt mc md jw nu jx mf jz nv ka mh kc nw kd mj mk bi translated">结论</h1><p id="14b9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这篇文章中，我们检查了一些方法，使我们的生活更容易处理角形。我们看到了如何创建一个独立于表单模块的自定义表单控件。然后，我们使用这些知识来创建一个可重用的嵌套表单组，它由多个输入字段组成。</p><p id="ce10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在AngularConnect 2017的<a class="ae kv" href="https://twitter.com/karaforthewin?lang=en" rel="noopener ugc nofollow" target="_blank"> Kara Erickson </a>精彩的<a class="ae kv" href="https://www.youtube.com/watch?v=CD_t3m2WMM8" rel="noopener ugc nofollow" target="_blank">演讲</a>中了解更多关于角形的知识。</p><p id="f225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我希望你喜欢这篇文章，并且你学到了一些新的东西。</p><p id="e8b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p><p id="3bc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">plain English . io</em></strong></a><em class="ls">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">Twitter</em></strong></a><em class="ls">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">LinkedIn</em></strong></a><em class="ls">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">社区不和谐</em> </strong> </a> <em class="ls">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">人才集体</em> </strong> </a> <em class="ls">。</em></p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="2ea4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">供进一步阅读:</em> </strong></p><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-zone-js-3b5e2347b7"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">关于Angular你应该知道的10件事</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">Zone.js是什么？如何有角度地使用它？本问答指南将回答这些问题以及更多问题。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ok l"><div class="ol l om on oo ok op kp ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://betterprogramming.pub/split-angular-nested-forms-into-subform-components-dcf32d1fb10d" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">将角形嵌套形状拆分为子形状构件</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">如何将有角度的嵌套形状变成更小的子形状组件</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">better编程. pub</p></div></div><div class="ok l"><div class="oq l om on oo ok op kp ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://medium.com/clean-code-practices/7-guidelines-to-write-maintainable-code-be78cd91b81" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">编写可维护代码的7条准则</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">遵循这7条准则来提高代码的可维护性。你未来的自己会感谢你的！</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="or l om on oo ok op kp ob"/></div></div></a></div></div></div>    
</body>
</html>