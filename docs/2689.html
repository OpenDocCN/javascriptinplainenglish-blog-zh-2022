<html>
<head>
<title>Interviewer: How to Modify the Original Array in forEach()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试官:如何在forEach()中修改原数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/interviewer-how-to-modify-the-original-array-in-foreach-fd36a08c6ce1?source=collection_archive---------1-----------------------#2022-06-27">https://javascript.plainenglish.io/interviewer-how-to-modify-the-original-array-in-foreach-fd36a08c6ce1?source=collection_archive---------1-----------------------#2022-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c0383beb9d1c354e40418d83666d34c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yyZvFHVIZNid-8jaju4mLQ.jpeg"/></div></div></figure><p id="6693" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个面试官的真题，有一半的受访者回答不好。今天，我们一起来深挖一下。</p><h1 id="e7e9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">forEach()可以修改原数组吗？</h1><p id="fae4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">案例1:元素是原始数据类型</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b57c" class="mf ku in mb b gy mg mh l mi mj">let arr = [1, 2, 3];<br/>arr.forEach((item) =&gt; { item = item * 2; });<br/>console.log(arr); // result：[1, 2, 3]</span></pre><p id="8dfb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果:<code class="fe mk ml mm mb b">Failed</code></p><p id="c614" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">案例2:元素是引用数据类型</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3832" class="mf ku in mb b gy mg mh l mi mj">let arr = [<br/>{"name": "David", "age": 20},<br/>{"name": "Peter", "age": 21},<br/>{"name": "Bruce", "age": 22}];<br/>arr.forEach((item) =&gt; { item = {"name": "Bob", "age": 23}; });<br/>console.log(JSON.stringify(arr));<br/>// result<br/>// [{"name":"David","age":20},<br/>// {"name":"Peter","age":21},<br/>// {"name":"Bruce","age":22}]</span></pre><p id="be70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果:<code class="fe mk ml mm mb b">Failed</code></p><p id="82f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">案例3:元素是引用数据类型(当事人修改)</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3084" class="mf ku in mb b gy mg mh l mi mj">let arr = [<br/>{"name": "David", "age": 20},<br/>{"name": "Peter", "age": 21},<br/>{"name": "Bruce", "age": 22}];<br/>arr.forEach((item) =&gt; { item.name = "bob"; });<br/>console.log(JSON.stringify(arr));<br/>// result<br/>// [{"name":"bob","age":20},<br/>// {"name":"bob","age":21},<br/>// {"name":"bob","age":22}]</span></pre><p id="59d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果:<code class="fe mk ml mm mb b">Success</code></p><p id="2b7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，其实<code class="fe mk ml mm mb b">forEach()</code>不会直接改变调用它的对象，但是那个对象可能会被回调函数改变。如果你理解基本数据类型赋值是值传递，引用数据类型赋值是引用地址的传递，那么上面的逻辑就很好理解了。</p><h1 id="512e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><em class="mn">修改原数组的正确方法</em></h1><p id="3c6f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">案例1:元素是原始数据类型</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="01a7" class="mf ku in mb b gy mg mh l mi mj">let arr = [1, 2, 3];<br/>arr.forEach((item, index, array) =&gt; { <br/>    array[index] = array[index] * 2; <br/>});<br/>console.log(arr); // result：[2, 4, 6]</span></pre><p id="af3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">案例2:元素是引用数据类型</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e058" class="mf ku in mb b gy mg mh l mi mj">let arr = [<br/>{"name": "David", "age": 20},<br/>{"name": "Peter", "age": 21},<br/>{"name": "Bruce", "age": 22}];<br/>arr.forEach((item, index, array) =&gt; { array[index] = {"name": "Bob", "age": 23}; });<br/>console.log(JSON.stringify(arr));<br/>// result<br/>// [{"name":"Bob","age":20},<br/>// {"name":"Bob","age":21},<br/>// {"name":"Bob","age":22}]</span></pre><p id="f8b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">案例3:元素是引用数据类型(当事人修改)</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="646e" class="mf ku in mb b gy mg mh l mi mj">let arr = [<br/>{"name": "David", "age": 20},<br/>{"name": "Peter", "age": 21},<br/>{"name": "Bruce", "age": 22}];<br/>arr.forEach((item, index, array) =&gt; { array[index].name = "bob"; });<br/>console.log(JSON.stringify(arr));<br/>// result<br/>// [{"name":"bob","age":20},<br/>// {"name":"bob","age":21},<br/>// {"name":"bob","age":22}]</span></pre><h1 id="9ad7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="9cb2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果只想枚举数组，可以使用forEach()方法</p><p id="e20f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，如果你想在枚举时改变数组中元素的内容，那么最好使用<code class="fe mk ml mm mb b">map()</code>方法。<code class="fe mk ml mm mb b">map()</code>方法本身将在处理后返回一个全新的数组，给出了一个明确的预期，即修改后的数据将被返回，不要使用<code class="fe mk ml mm mb b">forEach()</code>方法以避免一些低级错误。</p><h1 id="2ab2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最后</h1><p id="543b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io">感谢阅读。</strong>期待<strong class="jx io"> </strong>期待您的关注和阅读更多高质量的文章。</p><div class="mo mp gp gr mq mr"><a rel="noopener  ugc nofollow" target="_blank" href="/the-difference-between-pseudo-classes-and-pseudo-elements-of-css-properties-e408fcbd68a0"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd io gy z fp mw fr fs mx fu fw im bi translated">CSS属性的伪类和伪元素的区别</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">首先，让我们看看W3C对伪类和伪元素的定义:</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jt mr"/></div></div></a></div><div class="mo mp gp gr mq mr"><a rel="noopener  ugc nofollow" target="_blank" href="/identify-javascript-data-types-two-methods-are-enough-882e2c238e6b"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd io gy z fp mw fr fs mx fu fw im bi translated">识别JavaScript数据类型:两种方法就足够了</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">我们知道，JavaScript数据类型包括原语类型和对象类型。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="na l"><div class="ng l nc nd ne na nf jt mr"/></div></div></a></div><div class="mo mp gp gr mq mr"><a rel="noopener  ugc nofollow" target="_blank" href="/regexp-is-hard-to-write-easy-to-use-2cd94236e48d"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd io gy z fp mw fr fs mx fu fw im bi translated">正则表达式很难写，很容易使用</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">10个有用的正则表达式。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="na l"><div class="nh l nc nd ne na nf jt mr"/></div></div></a></div><p id="e916" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ni">更多内容请看</em><a class="ae nj" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ni">plain English . io</em></strong></a><em class="ni">。报名参加我们的</em> <a class="ae nj" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ni">免费周报</em> </strong> </a> <em class="ni">。关注我们关于</em><a class="ae nj" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ni">Twitter</em></strong></a><em class="ni">和</em><a class="ae nj" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ni">LinkedIn</em></strong></a><em class="ni">。查看我们的</em> <a class="ae nj" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ni">社区不和谐</em> </strong> </a> <em class="ni">加入我们的</em> <a class="ae nj" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ni">人才集体</em> </strong> </a> <em class="ni">。</em></p></div></div>    
</body>
</html>