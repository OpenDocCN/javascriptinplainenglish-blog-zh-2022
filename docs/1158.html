<html>
<head>
<title>Union Types vs. Enums in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的联合类型与枚举</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/union-types-vs-enums-in-typescript-a43c2c01c5fa?source=collection_archive---------4-----------------------#2022-03-07">https://javascript.plainenglish.io/union-types-vs-enums-in-typescript-a43c2c01c5fa?source=collection_archive---------4-----------------------#2022-03-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1518" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">哪个更好？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/40f3c4baccb01a402c0b4a364ddf9794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMhRU5O3fXoWa4SlIGVRpg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@headwayio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Headway</a> on <a class="ae ks" href="https://unsplash.com/s/photos/discussion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f13e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我在处理一个TypeScript项目时，我需要定义一个请求的状态。所以我可以通过<code class="fe lp lq lr ls b">enums</code>或<code class="fe lp lq lr ls b">union types</code>来实现它。但是它们之间有什么区别呢？哪个更好？</p><p id="6396" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你很困惑或者不确定区别在哪里，那就一起来深入探讨一下吧。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="116b" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">申报</h1><p id="40b9" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">首先，让我们比较枚举和联合类型声明。下面是枚举的典型用法:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="019c" class="nb mb in ls b gy nc nd l ne nf">enum Status {<br/>  Idle = "idle",<br/>  Pending = "pending",<br/>  Resolved = "resolved",<br/>  Rejected = "rejected"<br/>};</span></pre><p id="30de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们使用联合类型，它将看起来像这样:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="ebb9" class="nb mb in ls b gy nc nd l ne nf">type Status = "idle" | "pending" | "resolved" | "rejected";</span></pre><p id="a213" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">酷！简单很多！</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="536e" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">使用</h1><p id="e53c" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">如果您想使用枚举，您需要导入它:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/c99d055cede61d939288de3fae6d1e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPseaotuM9Xu5yePqMYInA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using Enum</figcaption></figure><p id="9812" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，对于联合类型，这不是必需的，因为ide足够强大，可以在使用字符串联合时建议值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/9d63a8eeaca8de1b43e9e5c9f88e1ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chSjPnoKXJHCH6Ipe7NWdQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using Union Types</figcaption></figure></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="bae1" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">重新命名</h1><p id="0ca2" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">在某些时候，我们可能会改变主意，或者我们可能不喜欢这个名字或价值，我们可能会说你希望你的<code class="fe lp lq lr ls b">Pending</code>身份被称为<code class="fe lp lq lr ls b">Loading</code>。</p><p id="8b4e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们使用一个枚举，我们可以只<strong class="kv io">右键单击- &gt;重命名</strong>或者只改变值。到处都会变。是的，很简单。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/0b9339d3a01b518ac41383ea6000b151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqbzcXlvRqV5pvE4gOoesQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Renaming Enum Field</figcaption></figure><p id="a895" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们使用联合类型，这需要几个步骤。因为我们需要找到项目中的所有实例并替换它们。这对工会类型来说是一个很大的不利因素。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="51e3" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">循环</h1><p id="a4a5" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">枚举是一个对象，所以我们可以使用<code class="fe lp lq lr ls b">Object</code>方法或者使用<code class="fe lp lq lr ls b">in</code>操作符和for循环来迭代它:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="47c2" class="nb mb in ls b gy nc nd l ne nf">enum Status {<br/>  Idle = "idle",<br/>  Pending = "pending",<br/>  Resolved = "resolved",<br/>  Rejected = "rejected"<br/>};<br/>for (const status in Status) {<br/>  console.log(status);<br/>}<br/>// console - Idle<br/>// console - Pending<br/>// console - Resolved<br/>// console - Rejected</span></pre><p id="0505" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不幸的是，您不能迭代联合类型。如果尝试迭代联合类型，将会引发错误:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="b26f" class="nb mb in ls b gy nc nd l ne nf">type Status = "idle" | "pending" | "resolved" | "rejected";</span><span id="4727" class="nb mb in ls b gy nj nd l ne nf">// Error - ‘Status’ only refers to a type, but is being used as a value here<br/>for (const status in Status) { <br/>  console.log(status);<br/>}</span></pre></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="b004" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">延伸</h1><p id="c085" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">在typescript中，联合类型不仅允许我们使用字符串，还允许我们联合其他类型的值:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="7c43" class="nb mb in ls b gy nc nd l ne nf">type Status = "idle" | "pending" | "resolved" | "rejected";<br/>type UserStatus = Status | "existed";</span></pre><p id="67b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，这给了你太多额外的灵活性:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="1abf" class="nb mb in ls b gy nc nd l ne nf">type Status = "idle" | "pending" | "resolved" | "rejected";<br/>type UserStatus = Status | "existed" | null | [];</span></pre><p id="f371" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是您可能会感到困惑，这会导致代码中出现问题。</p><p id="2aad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">至于枚举，扩展是不可能的。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="9465" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">类型安全</h1><p id="1869" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">从概念上讲，枚举可以是具有数值或字符串值的联合类型的子集。数字枚举不太安全。如果你调用<code class="fe lp lq lr ls b">updateStatus(20)</code>它工作得很好。</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="d28d" class="nb mb in ls b gy nc nd l ne nf">enum Status {<br/>  Idle = 0,<br/>  Pending = 1,<br/>  Resolved = 2,<br/>  Rejected = 3<br/>};</span><span id="648f" class="nb mb in ls b gy nj nd l ne nf">const updateStatus = (newStatus: Status) =&gt; {<br/>  console.log(newStatus); // console -&gt; 20<br/>};</span><span id="9466" class="nb mb in ls b gy nj nd l ne nf">updateStatus(20); // it works</span></pre><p id="8ebd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是字符串枚举总是安全的。让我们更新前面的例子:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="00ea" class="nb mb in ls b gy nc nd l ne nf">enum Status {<br/>  Idle = "idle",<br/>  Pending = "pending",<br/>  Resolved = "resolved",<br/>  Rejected = "rejected"<br/>};</span><span id="bb3b" class="nb mb in ls b gy nj nd l ne nf">const updateStatus = (newStatus: Status) =&gt; {<br/>  console.log(newStatus);<br/>};</span><span id="43e9" class="nb mb in ls b gy nj nd l ne nf">updateStatus("idle"); // Error - Argument of type '"idle"' is not assignable to parameter of type 'Status'.</span></pre><p id="31a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用联合类型通常是一种安全、简单且有效的方式。</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="284b" class="nb mb in ls b gy nc nd l ne nf">type Status = "idle" | "pending" | "resolved" | "rejected";</span><span id="8b62" class="nb mb in ls b gy nj nd l ne nf">const updateStatus = (newStatus: Status) =&gt; { <br/>  console.log(newStatus);<br/>};</span><span id="dc10" class="nb mb in ls b gy nj nd l ne nf">updateStatus("idle"); // it is ok and safe</span></pre></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="0482" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">代码大小</h1><p id="3550" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">如果使用联合类型，这不会改变代码的大小。</p><p id="cec5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很棒很简单！</p><p id="ef78" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是如果用枚举替换联合类型，并再次将代码编译成JavaScript，就会增加代码的大小。让我们编译前面例子中的代码:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="d352" class="nb mb in ls b gy nc nd l ne nf">enum Status {<br/>  Idle = "idle",<br/>  Pending = "pending",<br/>  Resolved = "resolved",<br/>  Rejected = "rejected"<br/>};</span></pre><p id="29c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们编译的代码将如下所示:</p><pre class="kd ke kf kg gt mx ls my mz aw na bi"><span id="8af6" class="nb mb in ls b gy nc nd l ne nf">var Status;<br/>(function (Status) {<br/>    Status["Idle"] = "idle";<br/>    Status["Pending"] = "pending";<br/>    Status["Resolved"] = "resolved";<br/>    Status["Rejected"] = "rejected";<br/>})(Status || (Status = {}));</span></pre></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="66fd" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">结论</h1><p id="f13c" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">在本文中，我们讨论了联合类型和枚举之间的主要区别。如果我在很多地方使用枚举，我更喜欢使用枚举。在一个简单的例子中，我将使用联合类型。</p><p id="c98a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读，希望这篇文章对你有用。编码快乐！</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="f557" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">资源</h1><div class="nk nl gp gr nm nn"><a href="https://stackoverflow.com/questions/40275832/typescript-has-unions-so-are-enums-redundant" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">Typescript有联合，那么枚举是多余的吗？</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">使用最新版本的TypeScript，可以很容易地声明可迭代的联合类型。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">stackoverflow.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.becomebetterprogrammer.com/typescript-union-types-vs-enums/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">TypeScript |联合类型与枚举</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">当我开始我的编程之旅时，我使用C#，这是实现枚举的常用方法。因此，当我开始使用…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.becomebetterprogrammer.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://blog.bam.tech/developer-news/should-you-use-enums-or-union-types-in-typescript" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">在Typescript中应该使用枚举类型还是联合类型？</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在使用TypeScript时，我们需要经常做一些事情:将变量的类型定义为…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">博客. bam.tech</p></div></div></div></a></div><p id="9894" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="od">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="od">plain English . io</em></strong></a><em class="od">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="od">免费周报</em> </strong> </a> <em class="od">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="od">Twitter</em></strong></a><em class="od">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="od">LinkedIn</em></strong></a><em class="od">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="od">社区不和谐</em> </strong> </a> <em class="od">。</em></p></div></div>    
</body>
</html>