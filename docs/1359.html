<html>
<head>
<title>Homemade Caching and Pruning in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的自制缓存和修剪</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/homemade-caching-and-pruning-6f4826b745a5?source=collection_archive---------13-----------------------#2022-03-18">https://javascript.plainenglish.io/homemade-caching-and-pruning-6f4826b745a5?source=collection_archive---------13-----------------------#2022-03-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d769" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中的缓存和修剪指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/839231a5414fa1527097191f4a697ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LYCHqhIj2fb0Ag70wu5BQ.jpeg"/></div></div></figure><p id="6f27" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我最近参与了一个后端项目，该项目有两个主要目标:</p><ul class=""><li id="2fe5" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">为读/写数据库操作构建一个API</li><li id="1fa9" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">在AWS上部署和优化</li></ul><p id="093c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在设置了服务器路由、数据库填充和EC2配置之后，我准备开始对API进行压力测试。</p><p id="b258" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我受限于t2.micros，所以纵向扩展并不是一个真正的选择。这就剩下了两种降低平均响应时间的方法…</p><p id="2b99" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">水平缩放和缓存。今天的帖子讲的是后者。</p><p id="a4a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">缓存选项</strong></p><p id="23e6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有几种健壮的数据存储技术可用(Redis、Memcached ),但是因为缓存是一种非常强大的工具，所以我真的想深入了解并实现自己的技术。</p><p id="52d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">幸运的是，总的原则是如此简单，把它放在一起既简单又有趣。</p><p id="a26b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">实施</strong></p><p id="4ee9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了在O(1)时间内执行这些查找，我们需要一个具有键值对的基本对象(hash)。</p><p id="8448" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我将定义缓存和两个函数来处理我们需要经常进行的事务:</p><p id="07e6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ly">*快速提示:第12行的数字1是第5行也在递增的计数器。这个计数器在以后会有帮助，但是现在可以忽略。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="504d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">checkCache() 将查找先前的匹配响应，如果可用，则返回它。</p><p id="2c3a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">createCache() 将在我们的缓存中创建新记录。</p><p id="7f36" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们只需要将这两个函数编织到所需的服务器路由中，这样，当请求在其他任何事情发生之前(在我的服务器将时间浪费在不必要的工作上之前)到来时，我们将检查缓存，如果可能的话，返回我们所拥有的。</p><p id="e639" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们没有它，我们将根据请求检索数据，然后创建一个记录供将来参考</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="5fe4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你会注意到，为了尽可能简单，我省略了大部分上下文。您的键值对可能看起来非常不同。这是一个电子商务项目，所以我使用一个包含“产品”和产品id的字符串来创建一个唯一的键。</p><p id="99be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个解决方案按原样工作。当缓存预热(存储了值)时，压力测试显示平均延迟显著降低，每秒请求数增加(我使用Loader.io)。</p><p id="b58e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">修剪</strong></p><p id="0e2c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然这对于测试来说可能足够了，但是对于持续运行的生产应用程序来说，这让我陷入了一个棘手的境地。当缓存增长超过可行的大小时会发生什么？</p><p id="1d60" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我如何(自动地)修剪这种过度生长，更重要的是，我如何使它成为一个智能的/战略性的过程？</p><p id="8ae8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">实施</strong></p><p id="5cd0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好吧，首先让我们说，我们要拿出一个以上的修剪模态。目前，我有两个想法——“测试”和“生产”。</p><p id="f245" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于测试，我的关注是单一的-我只是不想让它超载。通常，我的压力测试持续大约一分钟。我希望能够预热我的缓存(通常通过运行几个压力测试来模拟真实的日常使用量)，然后运行我的实际测试。</p><p id="db17" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是初始清理功能的概要:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="109d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们将把当前的缓存和所需的修剪方法传递给它。如果这个方法是' test '，那么我们将简单地返回一个清空的缓存。</p><p id="6bc4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在是生产形态</p><p id="d062" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我在这里想要什么？在生产环境中，我的任务是创造最好的用户体验(很多时候，以UX = <em class="ly">闪电般的速度</em>来说是“最好的”)。因此，我将使用搜索频率来确定要从缓存中删除哪些项目。现在，每个值数组中内置的计数器开始使用。</p><p id="6210" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面代码的第8行，您可以看到我已经将阈值(任意地)设置为10。所以现在，在最后一个清理间隔中查询次数少于10次的所有产品都将从缓存中删除。</p><p id="f147" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，为了保持当前的频率计数，我将在每次修剪时重置剩余缓存项的计数器。换句话说，每个产品都必须证明其受欢迎程度，才能留在缓存中。</p><p id="ed26" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">园丁</strong></p><p id="4ba4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我将创建一个园丁来应用修剪，在这种情况下，它将是一个setInterval方法。为了执行这个，我将使用下面的代码-</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="74dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，prune方法将每分钟应用于缓存，如果pruneMethod = 'production '，我们知道缓存中将清除所有低于我们之前设置的搜索阈值的记录(10)。</p><p id="02cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，如果我想要更彻底的修剪，以便随着时间的推移进一步优化缓存，并将其保持在一定的大小范围内，该怎么办呢？</p><p id="2857" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">只是为了好玩，让我们给园丁#1一个伙伴，园丁#2。</p><p id="3042" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设园丁#2将会比园丁#1多做10次修剪缓存的工作。</p><p id="0450" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有一个稍微高级一点的修剪概念:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="68af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将为这种修剪方法添加第三个参数“容量”。这里我们将为缓存传入一个指定的容量。如果方法仍然是“生产”，在第5行和第6行，我将计算我们的缓存超出容量多少(溢出)。</p><p id="03e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果有溢出，我将在第9行调用一个助手来做进一步的操作。我对助手的要求是:</p><p id="55d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从最少搜索的记录开始，获取现有的缓存并削减指定的减少量(溢出+ 25%的容量-在每个周期将我们的缓存减少到75%的容量)<strong class="kq io"> <em class="ly">。</em> </strong></p><p id="cb6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过这种方式，我们的缓存保持相关性，同时其容量也得到控制。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="5a5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们可以把高级西梅交给我们的第二个园丁了:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0631" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我让1号园丁每小时运行一次(3，600，000毫秒)，2号园丁每10小时跟进一次。</p><p id="3bfb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是每个文件中的完整代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7da7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">修剪的可能性是无限的，可以针对任何使用情形和流量级别进行定制。</p><p id="fdd7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">显然，像Redis和Memcached这样的数据存储将包含更多的特性和改进，但是如果你像我一样喜欢应用实验，自己创建它将会是一次有益的经历。</p><p id="c1b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ly">更多内容请看</em><a class="ae mb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ly">plain English . io</em></strong></a><em class="ly">。报名参加我们的</em> <a class="ae mb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ly">免费周报</em> </strong> </a> <em class="ly">。关注我们关于</em><a class="ae mb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ly">Twitter</em></strong></a><em class="ly">和</em><a class="ae mb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ly">LinkedIn</em></strong></a><em class="ly">。加入我们的</em> <a class="ae mb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ly">社区不和谐</em> </strong> </a> <em class="ly">。</em></p></div></div>    
</body>
</html>