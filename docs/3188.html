<html>
<head>
<title>How to Implement JavaScript Promise</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现JavaScript承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-javascript-promise-part-1-8407a8f75584?source=collection_archive---------7-----------------------#2022-08-07">https://javascript.plainenglish.io/how-to-implement-javascript-promise-part-1-8407a8f75584?source=collection_archive---------7-----------------------#2022-08-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="55e1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:带着承诺处理任务。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/252c8b782e62769766634224a011fcf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7s9n3b3YJn42A7mf"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@joshuaearle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Earle</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="21eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们一直在使用JavaScript承诺，从获取API到等待事情发生。但是信不信由你，我们中没有多少人知道承诺的准确定义是什么。如果没有也没关系。我们不知道很多事情，但我们仍然每天使用它们。</p><p id="6392" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，当涉及到实现时，对定义部分的知识的缺乏最终总是会回来伤害我们。记住这一点。当你想做一些困难或复杂的事情时，你想确保你能记住目标，因为由于一路上各种各样的干扰，你很容易忘记你在做什么。承诺在这里也不例外。</p><h2 id="71e2" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">承诺能做什么？</h2><p id="73c1" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">让我们快速看一下它的一个典型用法:</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="6d2d" class="lp lq in mo b gy ms mt l mu mv">const p = <strong class="mo io">new</strong> Promise((resolve, reject) =&gt; { resolve(3) })<br/>p<strong class="mo io">.then</strong>(res =&gt; { console.log(res })<br/> .<strong class="mo io">catch</strong>(e =&gt; { console.error(e) })</span></pre><p id="a53c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以通过提供一个任务(功能)来创建一个承诺。之后这个任务解决了我们就可以用<code class="fe mw mx my mo b">then</code>来处理了。如果由于某种原因任务被拒绝，我们可以在<code class="fe mw mx my mo b">catch</code>中处理错误。</p><p id="662e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然用法足够简单，但是任务需要写成函数。该函数采用两个名为<code class="fe mw mx my mo b">resolve</code>和<code class="fe mw mx my mo b">reject</code>的函数:</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="ebdf" class="lp lq in mo b gy ms mt l mu mv">const taskFn = (resolve, reject) =&gt; { ... }</span></pre><p id="1847" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很快，这就变成了函数式编程101。给定定义如何解决或拒绝的方法，我们可以定义任务函数。在函数式编程中，方法可以通过函数来定义。在其他编程语言中，它们通常通过类来定义。如果你把函数/类作为一个可以注入另一个的实体，你或多或少可以用同样的方式对待它们。</p><h2 id="3aad" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">什么是承诺？</h2><p id="4ebf" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">好了，定义了任务函数，让我们回到承诺:</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="da76" class="lp lq in mo b gy ms mt l mu mv">const taskFn = (resolve, reject) =&gt; { resolve(5) }<br/>const p = new Promise(taskFn).then(res =&gt; {})</span></pre><p id="9605" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">承诺不会给你从任务中得到的任何回报。上面的例子从任务中解析出数字<code class="fe mw mx my mo b">5</code>，但是承诺<code class="fe mw mx my mo b">p</code>不会给你这个数字。因为这是承诺。它向你承诺(在未来),如果你通过一个<code class="fe mw mx my mo b">then</code>请求，当任务解决时，值可以被返回。在我们的例子中，我们将在<code class="fe mw mx my mo b">then</code>中得到数字<code class="fe mw mx my mo b">5</code>。</p><p id="9eb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更准确的定义是:承诺是一个固定的任务。一旦承诺被创造出来，它不一定会启动任务。因此，任务的结果在创建时不应该可用。关于“<strong class="kv io">不应该</strong>的部分需要多一点解释。因为一个琐碎的任务可以运行得非常快，只需要很少的时间。但是即使对于那种任务，承诺也不能立即调用它并完成它。相反，它只能承诺调用它，因此在某种意义上，<strong class="kv io">承诺在起跑线前增加了一些空间/时间。</strong>当我们实现时，我们将看到如何在代码中实现这一点。</p><h2 id="0997" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">什么是'<code class="fe mw mx my mo b">then'</code>？</h2><p id="035d" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">随着诺言的产生，现在又出现了另一种说法<code class="fe mw mx my mo b">then</code>，到底什么是<code class="fe mw mx my mo b">then</code>？</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="fe0d" class="lp lq in mo b gy ms mt l mu mv">.then(resolve)<br/>.then(value =&gt; {})</span></pre><p id="5265" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mw mx my mo b">then</code>采用一个定义任务完成时做什么的函数。本质上，这是另一个函数编程101。<code class="fe mw mx my mo b">then</code>与任务本身没有太大关系，相反，它处理如何处理任务返回的值。因此，功能<code class="fe mw mx my mo b">value =&gt; {}</code>也被称为<code class="fe mw mx my mo b">resolve</code>功能。</p><p id="b157" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果<code class="fe mw mx my mo b">then</code>不是为承诺而写的，那么当任务完成时什么都不重要，因为我们无论如何都不会得到通知，也没有人知道那个任务发生了什么。</p><p id="c2fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果<code class="fe mw mx my mo b">then</code>是为一个承诺编写的，那么<code class="fe mw mx my mo b">resolve</code>函数会在任务完成时被调用，并且很可能解析为一个值。请记住，这只是在任务完成之后，而不是在任务完成之前或任务定义时。这里最常见的做法是任务可能需要3秒钟才能运行。3秒钟后，调用<code class="fe mw mx my mo b">resolve</code>。这里不太明显的是，如果任务运行需要0.1秒，那么<code class="fe mw mx my mo b">resolve</code>会在0.1秒后被调用。运行该任务可能需要0.000001秒，因此在调用<code class="fe mw mx my mo b">resolve</code>之前应该会有一点延迟。这种理解将有助于我们在编写代码时实现承诺。</p><h1 id="c68d" class="mz lq in bd lr na nb nc lu nd ne nf lx jt ng ju ma jw nh jx md jz ni ka mg nj bi translated">结论</h1><p id="f52b" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们将在第二部分从头开始实现这个承诺。在第一部分中，我们看到承诺是如何处理任务的。通过使用承诺，我们将任务的定义和任务处理分成两个独立的工作。前者在Promise构造函数中定义，而后者在<code class="fe mw mx my mo b">then</code>语句中定义。本质上，涉及承诺的任务需要时间来运行，并且非常适合异步操作。但是也要记住，承诺<strong class="kv io">必须</strong>用于延期的任务。如果您对立即调用的任务感兴趣，请考虑使用基本的函数调用。</p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="5244" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nr">更多内容尽在</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nr">说白了. io </em> </strong> </a> <em class="nr">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nr">免费周报</em> </strong> </a> <em class="nr">。关注我们关于</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nr">推特</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nr">LinkedIn</em></strong></a><em class="nr">，以及</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nr">不和</em> </strong> </a> <em class="nr">。</em></p></div></div>    
</body>
</html>