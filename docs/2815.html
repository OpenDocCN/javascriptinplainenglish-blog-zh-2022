<html>
<head>
<title>TypeScript, RXJS: Which Multicast Operator to Use for Sharing HTTP Request b/w Multiple Observers Over Different Time Periods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript，RXJS:使用哪个多播操作符来共享不同时间段内的多个观察器的HTTP请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-rxjs-which-multicast-operator-can-be-used-for-sharing-http-request-between-multiple-ac0a349bd9c3?source=collection_archive---------5-----------------------#2022-07-06">https://javascript.plainenglish.io/typescript-rxjs-which-multicast-operator-can-be-used-for-sharing-http-request-between-multiple-ac0a349bd9c3?source=collection_archive---------5-----------------------#2022-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="eb43" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">RXJS提供了许多操作符，哪一个操作符将满足您的需求，这肯定需要一些研究和努力。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6f4116f95d1de99253b8dd2b26f9c30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*24EdH3enxlSjTvBr"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@nublson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nubelson Fernandes</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4141" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在多个观察者之间共享HTTP响应对于避免多个API调用非常有用，但是RXJS提供了许多操作符，哪一个操作符将满足您的需求肯定需要一些研究和努力。</p><p id="ad5c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我尝试做的是创建一个HTTP GET请求来获取一个用户的数据，然后将它共享给3个观察者，他们订阅在不同的时间间隔接收这些数据。我的目标是，无论观察者何时订阅，它都必须接收正确的数据，而不需要额外的API调用。只需要一个API调用来满足3个观察者。</p><p id="b563" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我创建了一个TypeScript项目，以避免在Angular中创建多个组件。</p><p id="155e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，整个代码在一个文件中:<strong class="kv io"> index.ts </strong>。为了避免混淆，我将文件中的逻辑分成了不同的要点。</p><p id="478d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一.让我从如何创建发出用户数据的<strong class="kv io">我们的可观察对象开始</strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><ol class=""><li id="8eb0" class="lr ls in kv b kw kx kz la lc lt lg lu lk lv lo lw lx ly lz bi translated">我们已经使用了<strong class="kv io"> RXJS ajax操作符</strong>来创建HTTP GET请求。它返回一个类型为<strong class="kv io"> AjaxResponse </strong>的可观察对象。</li><li id="7944" class="lr ls in kv b kw ma kz mb lc mc lg md lk me lo lw lx ly lz bi translated">用户数据如下所示。我们只需要数据中的name属性。因此，我们使用<strong class="kv io"> map </strong>操作符只返回name属性的值。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mf"><img src="../Images/ceb14c15c871e63dd95d70a5319cc4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-eeOUlUC2I8U17WsWuj4A.png"/></div></div></figure><p id="9fb5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.我们使用了一个<strong class="kv io"> tap </strong>操作符来记录可观察对象发出一个值的时间。</p><p id="564c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.请注意，到目前为止，我们还没有使用任何多播操作符。</p><p id="e09c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">二。下一步，我们将为这种可观察创造观察者。因为我们创建了3个观察者，所以我们创建了一个公共方法<strong class="kv io"> createObserver() </strong>来传递观察者索引作为参数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="6377" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">三。最后，我们通过在不同的时间间隔调用<strong class="kv io"> createObserver() </strong>来创建观察器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><ol class=""><li id="a42e" class="lr ls in kv b kw kx kz la lc lt lg lu lk lv lo lw lx ly lz bi translated">我们已经使用RXJS操作符的<strong class="kv io">创建了一个cold observable，它将发出值<strong class="kv io"> true </strong>。它可以释放出任何价值，这真的无关紧要。</strong></li><li id="15f3" class="lr ls in kv b kw ma kz mb lc mc lg md lk me lo lw lx ly lz bi translated">我们首先使用<strong class="kv io"> delay() RXJS操作符</strong>创建一个1秒的<strong class="kv io">延迟。接下来，我们添加一个<strong class="kv io">点击操作符</strong>来执行两个动作:</strong></li></ol><p id="8f28" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;我们已经记录了观察者将要订阅可观察对象的时间。</p><p id="7b6c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;调用<strong class="kv io"> createObserver() </strong>并传递<strong class="kv io"> 1 </strong>作为参数。这里，参数1表示它是“第一个观察者”。</p><p id="5f53" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.接下来，我们添加了2秒的延迟，并创建了第二个观察点。终于在延迟5秒后创造了第三个观察者。</p><p id="e86a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">四。现在让我们看看没有任何多播操作符的输出。请注意，已经为3个观察者进行了3次API调用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mg"><img src="../Images/69c7cdd4a35eeb0ba78c4c5012be9e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdsWXM97yNHPIBnc-EEwDA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Network Tab</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/1907d88534b9b2e3dfcd58a0d1f76c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjGa66ohYT4ORfCobwCfVA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Console Tab</figcaption></figure><p id="146b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了理解为什么观察者在某个时间收到了数据，您需要首先下载<strong class="kv io">。har文件</strong>如下截图所示。使用GET请求URL搜索文件，并查找<strong class="kv io"> startedDateTime </strong>以检查HTTP请求何时开始，并查找<strong class="kv io"> time </strong>属性以记录完成请求所用的时间(毫秒)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/2f2d5bc54ebf3f2c29ab8a48b303b28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwcjv9VxkVxPfY76ZtSg5w.png"/></div></div></figure><p id="1f8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是第一个观察者订阅时HTTP请求执行的开始时间和持续时间的屏幕截图。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mj"><img src="../Images/2b0dea569bdf627d1a2d52d7f41c4f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1AZOn5vjblz7xFameDiWQ.png"/></div></div></figure><p id="eec3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">动词 （verb的缩写）这不是我们想要的结果。我们只需要对所有3个观察者进行一次API调用。下面是我们现在要测试的多播操作符。</p><ol class=""><li id="502b" class="lr ls in kv b kw kx kz la lc lt lg lu lk lv lo lw lx ly lz bi translated"><strong class="kv io"> publish()+refCount() </strong></li></ol><p id="78ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我已经更新了“源可观察对象的创建”逻辑来添加这两个操作符，如下所示。其他都没变。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="9976" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如您在下面看到的，上面的2个操作符只帮助触发了3个观察者的1个API调用。但是所有的观察者都收到数据了吗？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/8ada03915a46121fecaf1a31e7398a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gb9QX5pR43NMm5W4e3FSGQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Network Tab</figcaption></figure><p id="c3ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们检查控制台以验证这一点。如您所见，只有第一个观察者收到了该值。只有第二个和第三个观察者的<strong class="kv io"> complete() </strong>被执行。这意味着在第二个和第三个观察者订阅时，可观察对象已经完成了用户数据的发送。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/077983428d1f5a73b536780c3230a9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbJEoN6k9UFcTwfT5mdUOA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Console Tab</figcaption></figure><p id="8f6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">发生了什么事？</p><p id="c114" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">=&gt;<strong class="kv io">ref count()操作符</strong>确保只有当至少有一个观察者订阅时，可观察对象才开始执行。</p><p id="dc66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;第一个观察者在<strong class="kv io"> 05:43:37，</strong>订阅，这导致可观察对象开始执行并触发HTTP GET请求。正如我们在<strong class="kv io">中看到的。har文件</strong>下面，GET请求开始于<strong class="kv io"> 05:43:37 </strong>并持续了<strong class="kv io"> 2秒。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/f48139b02f1ac5538b9b103256b7551e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2TTHJC9ncczE1sAsBG3XA.png"/></div></div></figure><p id="cf28" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，可观测对象在<strong class="kv io"> 05:43:39完成了所有数据的发射。</strong></p><p id="f1f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;第二个观察者在<strong class="kv io"> 05:43:39订阅，即在第一个观察者订阅后延迟2秒。在可观测者发送所有数据和第二个观测者订阅之间肯定有几毫秒的间隔。这就是原因，第二个观察者是一个迟订阅者，并且未能接收到数据。</strong></p><p id="49c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">只有第二个观察者的complete()会执行。</p><p id="18bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;同样，第三个观察者在<strong class="kv io"> 05:43:44订阅，即在第二个观察者订阅后5秒延迟。</strong>显然，第三个观察者是一个迟到的订阅者，未能接收到数据。</p><p id="3367" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">只有第三个观察者的complete()会执行。</p><p id="6831" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这不符合我们的目标。</p><p id="22df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.<strong class="kv io">分享()</strong></p><p id="2db1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更新了index.ts以添加share()运算符。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="0a2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如您在下面看到的，API调用又为3个观察者进行了三次。为什么share()没有起作用？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mk"><img src="../Images/d949dbffec3801a39016a0d0a9cac99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6si9qcw3SrrwBofW2wHTUw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Network Tab</figcaption></figure><p id="92ae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">share()操作符将只与在可观察对象发送完所有数据之前订阅的观察对象共享数据。对于后期订户，即第二个和第三个观察者，它将重新执行可观察值，这种情况下将触发新的API调用。</p><p id="c11e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，所有3个观察者都收到了数据，但代价是额外调用了2个API。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mj"><img src="../Images/3f11667cfb349f5af560f1c1d8922da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNtGEhJGbdkrTeLPnzZPrg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Console tab</figcaption></figure><p id="44d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看发生了什么。</p><p id="46ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;<strong class="kv io">share()操作符</strong>在内部使用<strong class="kv io"> refCount() </strong>来确保只有当至少有一个观察者订阅时，可观察对象才开始执行。</p><p id="3e2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;从控制台选项卡日志中，我们可以看到第一个观察者在<strong class="kv io"> 04:40:31订阅。</strong>因此，我们预计可观察到的执行(即HTTP请求)将同时触发。</p><p id="881f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;通过检查<strong class="kv io">。har文件，</strong>第一个HTTP GET请求开始于<strong class="kv io"> 04:40:31 </strong>，持续了<strong class="kv io"> 1.92秒~ 2秒</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ml"><img src="../Images/1957926cda6b2fcba0732edaf950e488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHNjRM5YkJ394RHJkE2xzA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">.har file screenshot for first HTTP GET Request</figcaption></figure><p id="caee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可观测数据在<strong class="kv io"> 4:40:33完成数据发射。因此第一个观察者也在<strong class="kv io"> 4:40:33接收到数据。</strong></strong></p><p id="5136" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.在第二个观察者订阅之前，我们增加了2秒的延迟。从控制台选项卡日志中，我们可以看到第二个观察者在<strong class="kv io"> 04:40:34 </strong>订阅。</p><p id="a2ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于可观察对象已经在<strong class="kv io"> 4:40:33 </strong>完成了值的发送，第二个观察对象是一个迟订阅者，share()操作符重新执行了可观察对象，这触发了第二个API调用</p><p id="0cf8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二个HTTP请求，我们可以从<strong class="kv io">中看到。har文件</strong>从<strong class="kv io"> 04:40:34 </strong>开始，持续<strong class="kv io"> 295.99 ms </strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mm"><img src="../Images/6200d3fee411c019e537aa72d4f6ee0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKOaxRqPPQhX-ksEUpmAEA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">.har file for 2nd HTTP Request</figcaption></figure><p id="b901" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5.在第三个观察者订阅之前，我们增加了5秒的延迟。从控制台选项卡日志中，我们可以看到第三个观察者在<strong class="kv io"> 04:40:39 </strong>订阅。从第二个观察者订阅时起，这是预期的5秒间隔。</p><p id="7205" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于可观察对象已经在<strong class="kv io"> 4:40:33 </strong>完成了值的发送，第三个观察对象是一个迟订阅者，share()操作符重新执行了可观察对象，这触发了第三个API调用</p><p id="fd9c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第三个HTTP请求，我们可以从<strong class="kv io">中看到。har文件</strong>从<strong class="kv io"> 04:40:39 </strong>开始，持续<strong class="kv io"> 638.99 ms </strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/c1e9400573826541a9192de74c134cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*db0H-KFtSHDolPXmd-0Ktg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">.har file for 3rd HTTP Request</figcaption></figure><p id="0a66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.<strong class="kv io">publish last()+ref count()</strong></p><p id="e662" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更新的index.ts如下。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="5f46" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“1个API调用”的目标已经实现，如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mj"><img src="../Images/4b9d7dffa977dd40ebb56bb289be8de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkfSyRkmz2ZWcZfrlv_3xA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Network Tab</figcaption></figure><p id="add2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还可以从下面的控制台响应中观察到，所有3个观察者也都收到了正确的数据。</p><p id="e92c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">publish last()操作符使用AsyncSubject将可观察对象的最后一个值发送给它的所有观察者，而不管观察者何时订阅。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/4f7549980965590995223d304393195b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZMf8HBIrsFn6i7Pm60hiA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Console Tab</figcaption></figure><p id="3242" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们看看实际发生了什么。</p><ol class=""><li id="a128" class="lr ls in kv b kw kx kz la lc lt lg lu lk lv lo lw lx ly lz bi translated"><strong class="kv io"> refCount()操作符</strong>确保只有当至少有<strong class="kv io"> 1个观察者</strong>订阅时，可观察对象才会被执行。</li><li id="8f8c" class="lr ls in kv b kw ma kz mb lc mc lg md lk me lo lw lx ly lz bi translated">查看控制台tab日志，第一个观察者订阅于<strong class="kv io"> 04:32:17 </strong>。可观察对象将开始执行，即HTTP请求将触发第一个观察者订阅的时刻。</li><li id="079a" class="lr ls in kv b kw ma kz mb lc mc lg md lk me lo lw lx ly lz bi translated">望着。har文件，请求开始于<strong class="kv io"> 04:32:17 </strong>，持续了<strong class="kv io"> 1.45秒</strong>。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/c8a042d10e569d2b327120c2c3795b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLU2yRSK27Xw5XRBjaT7xA.png"/></div></div></figure><p id="b724" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可观测数据在<strong class="kv io"> 4:32:18完成数据发射。</strong>因此第一个观察者也在<strong class="kv io"> 4:32:18接收到数据。</strong></p><p id="c06f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.在第二个观察者订阅之前，我们增加了2秒的延迟。从控制台选项卡日志中，我们可以看到第二个观察者在<strong class="kv io"> 04:32:19 </strong>订阅。从第一个观察者订阅时起，这是预期的2秒间隔。</p><p id="562e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于被观察对象已经在<strong class="kv io"> 4:32:18 </strong>完成了值的发送，第二个观察对象是一个迟到的订阅者，但是已经收到了正确的数据，因为<strong class="kv io"> publishLast()操作符</strong>使用的<strong class="kv io"> AsyncSubject </strong>已经将被观察对象发送的最后一个数据推送给迟到的订阅者。</p><p id="7743" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5.在第三个观察者订阅之前，我们增加了5秒的延迟。从控制台选项卡日志中，我们可以看到第三个观察者在<strong class="kv io"> 04:32:24 </strong>订阅。从第二个观察者订阅时起，这是预期的5秒间隔。</p><p id="f473" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于被观察对象已经在<strong class="kv io"> 4:32:18 </strong>完成了值的发送，第三个观察对象是一个迟到的订阅者，但是已经收到了正确的数据，因为<strong class="kv io"> publishLast()操作符</strong>使用的<strong class="kv io"> AsyncSubject </strong>已经将被观察对象发送的最后一个数据推送给迟到的订阅者。</p><p id="88a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就完成了我们的目标。但是，是否有另一个运营商也可以实现这一目标？是啊！</p><p id="2e06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.<strong class="kv io">publish replay()+ref count()</strong></p><p id="1855" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更新的index.ts如下。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="7c88" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们有一个类似于<strong class="kv io"> publishLast() </strong>的输出。</p><p id="b2db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> publishReplay()使用ReplaySubject将所有以前发出的值发送给它的后期观察者。无论何时订阅，所有观察者都将接收数据。我们可以通过将数字作为参数传递给publishReplay()来配置后期观察器将收到多少个值。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/5da29f0c5bdd131ca35912a388f2ce40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmX-78jH_hj-6MnsXWnXTQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Network Tab</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/534082972a952919123b0f33c5f94dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7w8IcCRdWx256bzGhKbzg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Console Tab</figcaption></figure><p id="28d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们看看发生了什么。</p><ol class=""><li id="b5bd" class="lr ls in kv b kw kx kz la lc lt lg lu lk lv lo lw lx ly lz bi translated"><strong class="kv io"> refCount()操作符</strong>确保只有当至少有<strong class="kv io"> 1个观察者</strong>被订阅时，可观察对象才会被执行。</li><li id="13b8" class="lr ls in kv b kw ma kz mb lc mc lg md lk me lo lw lx ly lz bi translated">查看控制台选项卡日志，第一个观察者在<strong class="kv io"> 04:09:17 </strong>订阅。可观察对象将开始执行，即HTTP请求将触发第一个观察者订阅的时刻。</li><li id="b338" class="lr ls in kv b kw ma kz mb lc mc lg md lk me lo lw lx ly lz bi translated">望着。har文件，请求开始于<strong class="kv io"> 04:09:17 </strong>，持续了<strong class="kv io"> 1.21秒</strong>。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/9592bc4bf157868e5c7e094ae0186773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A63ysDhv0JyHQLPBhsxC5g.png"/></div></div></figure><p id="89fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">被观测者在<strong class="kv io"> 4:09:18完成数据发射。</strong>因此，第一个观察者也在<strong class="kv io"> 4:09:18收到了数据。</strong></p><p id="e689" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.在第二个观察者订阅之前，我们增加了2秒的延迟。从控制台选项卡日志中，我们可以看到第二个观察者在<strong class="kv io"> 04:09:19 </strong>订阅。从第一个观察者订阅时起，这是预期的2秒间隔。</p><p id="0b4a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于可观察对象已经在<strong class="kv io"> 4:09:18 </strong>完成了值的发送，第二个观察对象是一个迟订阅者，但是已经收到了正确的数据，因为<strong class="kv io"> publishReplay()操作符</strong>使用的<strong class="kv io"> ReplaySubject </strong>已经将可观察对象之前发送的所有数据推送到迟订阅者。</p><p id="d138" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5.在第三个观察者订阅之前，我们增加了5秒的延迟。从控制台选项卡日志中，我们可以看到第三个观察者在<strong class="kv io"> 04:09:24 </strong>订阅。从第二个观察者订阅时起，这是预期的5秒间隔。</p><p id="3011" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于观察对象已经在<strong class="kv io"> 4:09:18 </strong>完成了值的发送，第三个观察对象是一个迟订阅者，但是已经收到了正确的数据，因为<strong class="kv io"> publishReplay()操作符</strong>使用的<strong class="kv io"> ReplaySubject </strong>已经将观察对象之前发送的所有数据推送给了迟订阅者。</p><p id="091d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以查看下面的完整示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq lq l"/></div></figure><p id="2c84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个题目到此为止。感谢您的阅读。</p><p id="09e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mr">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mr">plain English . io</em></strong></a><em class="mr">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mr">免费周报</em> </strong> </a> <em class="mr">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mr">Twitter</em></strong></a><strong class="kv io"><em class="mr"/></strong><em class="mr">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mr">LinkedIn</em></strong></a><em class="mr">。查看我们的</em><strong class="kv io"><em class="mr"/></strong><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mr">社区不和谐</em> </strong> </a> <em class="mr">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mr">人才集体</em> </strong> </a> <em class="mr">。</em></p></div></div>    
</body>
</html>