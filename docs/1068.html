<html>
<head>
<title>The Difference Between useState and useRef in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中useState和useRef的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-difference-between-usestate-and-useref-in-react-fa3ccd9aeda5?source=collection_archive---------0-----------------------#2022-03-02">https://javascript.plainenglish.io/the-difference-between-usestate-and-useref-in-react-fa3ccd9aeda5?source=collection_archive---------0-----------------------#2022-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f8e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中的useState vs useRef:你需要知道的一切。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/038d0b64e4db12e170c2ff925650a88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ICi8vthKY0HjEBck"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jannisbrandt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jannis Brandt</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="255e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React是一个非常流行的用于构建用户界面的JavaScript库。很多开发人员更喜欢这个库，因为它完全基于组件，并且有很多我们可以使用的很酷的包。除此之外，现在我们有了React钩子，它把我们从复杂的类组件中解救了出来。</p><p id="199c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React钩子非常强大，允许我们在功能组件中使用状态。它们还让我们能够在无状态功能组件中创建逻辑和功能。许多开发人员现在更喜欢使用钩子和功能组件，而不是类组件，因为类语法有点难写。您可以在React代码中使用许多有用的挂钩来创建逻辑并向组件添加特性。</p><p id="842d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么在本文中，我们将通过介绍钩子useState和useRef之间的区别来了解它们。所以让我们开始吧。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f5c0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">useState挂钩</h1><p id="3512" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">挂钩useState只是一个接受一个参数(初始状态)并返回两件事的函数:</p><p id="f545" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当前状态(我们状态的值)。允许我们更新当前状态功能。钩子useState允许我们在功能组件中拥有状态，我们可以用它在React中创建许多很酷的东西。例如，使用useState，我们可以在单击按钮后更改文本，或者创建计数器等等。在React中，您可以使用这个重要的钩子做很多事情。</p><p id="d66c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以如果你想在react中使用useState，你必须首先从React包中导入它。</p><p id="80ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="ee63" class="nb ma iq mx b gy nc nd l ne nf">import React, { useState } from 'react'</span></pre><p id="5075" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，从react包中导入它之后，您就可以在功能组件中使用钩子了，不会有任何问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="757c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">例子</h1><p id="7b16" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在下面的例子中，我们将使用钩子useState来创建文本，并在单击按钮后更新它:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0bc1" class="nb ma iq mx b gy nc nd l ne nf">//import useState.<br/>import React, { useState } from 'react'</span><span id="fdfb" class="nb ma iq mx b gy ng nd l ne nf">function MyComponent() {<br/>    // Using useState.<br/>  const [name, setName] = useState('Mehdi')</span><span id="e140" class="nb ma iq mx b gy ng nd l ne nf">  //JSX.<br/>  return(<br/>      &lt;&gt;<br/>      &lt;h1&gt;{name}&lt;/h1&gt;<br/>      &lt;button onClick={()=&gt; setName("John")}&gt;Change Name&lt;/button&gt;<br/>      &lt;/&gt;<br/>  )<br/>}</span><span id="932f" class="nb ma iq mx b gy ng nd l ne nf">export default MyComponent;</span></pre><p id="aa6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在上面看到的，钩子useState允许我们在点击按钮后更新状态。我们传递了一个字符串名作为钩子函数的参数，你可以传递任何东西，比如数组，数字，布尔值，所有这些都取决于你处理的是什么类型的状态。</p><p id="c6e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意，我们使用ES6数组析构来指定初始状态和更新函数。值名指的是初始状态“Mehdi ”,值集名指的是允许up更新状态的函数。我们还在click事件中调用了更新函数setName，以便将名称状态从“Mehdi”更新为“John”。因此，单击按钮后，标题h1内的值名称会得到更新。</p><p id="26cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以钩子useState非常有用，因为它允许我们在函数组件中使用状态并更新它，而不必使用类语法。</p><p id="d5ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是另一个计数器的例子，它允许我们在单击一个按钮后将数字增加1:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="749f" class="nb ma iq mx b gy nc nd l ne nf">//import useState.<br/>import React, { useState } from 'react'</span><span id="5e2b" class="nb ma iq mx b gy ng nd l ne nf">function MyComponent() {<br/>    // Using useState.<br/>  const [counter, setCounter] = useState(0)</span><span id="391b" class="nb ma iq mx b gy ng nd l ne nf">  //JSX.<br/>  return(<br/>      &lt;&gt;<br/>      &lt;h1&gt;{counter}&lt;/h1&gt;<br/>      &lt;button onClick={()=&gt; setCounter(counter + 1)}&gt;Increment&lt;/button&gt;<br/>      &lt;/&gt;<br/>  )<br/>}</span><span id="3b67" class="nb ma iq mx b gy ng nd l ne nf">export default MyComponent;</span></pre><p id="1168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们将初始状态设置为0，作为钩子函数的参数。这是因为我们在处理数字，我们需要在每次点击按钮时将数字加1。更新函数setCounter允许我们将状态更新为当前状态加1。因此，我们可以在每次点击后将计数器加1。</p><p id="9a5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你愿意，你也可以在<a class="ae kv" href="https://react-7mzbjb.stackblitz.io/" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>上观看现场演示。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c0af" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">useRef挂钩</h1><p id="aee3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">挂钩useRef有点类似于useState，它返回一个具有属性current的对象，我们可以使用对象点标记法访问该对象。属性current接受我们传递给函数useRef()的参数值。</p><p id="6651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此挂钩useRef也接受一个参数(属性current的初始值)。此外，请记住，返回的对象将在组件的整个生存期内保持不变。</p><p id="1f83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，要开始使用钩子，您必须首先从React导入它。然后就可以毫无问题的使用了。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="2d92" class="nb ma iq mx b gy nc nd l ne nf">import React, { useRef } from 'react';</span></pre><p id="443a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试试控制台中的挂钩，看看它是如何工作的:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f26a" class="nb ma iq mx b gy nc nd l ne nf">//using useRef and giving it 0 as a parameter.<br/>const ourRef = useRef(0);</span><span id="c26e" class="nb ma iq mx b gy ng nd l ne nf">console.log(ourRef);<br/>  //{ current: 0 }<br/>console.log(ourRef.current); // 0</span></pre><p id="b4f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，useRef返回一个包含属性的对象，该属性具有我们传递的参数值。我们可以使用对象点符号来访问该值。</p><p id="a4f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">useRef非常强大，因为它在渲染之间是持久的。与useState不同，useRef不会在值或状态改变时导致组件重新呈现。</p><p id="5917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让事情更清楚，我们来看一个实际的例子。我们将向您展示与上面使用useState相同的递增计数器示例，但是现在使用useRef。</p><p id="6eba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个例子:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="a34f" class="nb ma iq mx b gy nc nd l ne nf">//import useRef.<br/>import React, { useRef } from 'react'</span><span id="8e10" class="nb ma iq mx b gy ng nd l ne nf">function MyComponent() {<br/>    // Using useRef.<br/>  const ourRef = useRef(0)</span><span id="1968" class="nb ma iq mx b gy ng nd l ne nf">  //JSX.<br/>  return(<br/>      &lt;&gt;<br/>      &lt;h1&gt;{ourRef.current}&lt;/h1&gt;<br/>      &lt;button onClick={()=&gt; ourRef.current = ourRef.current + 1}&gt;Increment&lt;/button&gt;<br/>      &lt;/&gt;<br/>  )<br/>}</span><span id="87d7" class="nb ma iq mx b gy ng nd l ne nf">export default MyComponent;</span></pre><p id="0e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们将初始值设置为0，并访问返回对象中的属性<code class="fe nh ni nj mx b">current</code>,以将计数器加1。现在的问题是，即使我们点击按钮，数字0也不会递增。这是因为挂钩useRef不会导致组件重新呈现。组件需要呈现才能更新UI。</p><p id="fed5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在控制台中打印了当前属性的值，您会发现当您单击该按钮时，该值实际上会增加1。但是它不会显示在UI中，因为组件不会被重新呈现。所以useRef不是创建计数器的好选择。如果你愿意，你可以在Stackblitz上查看现场演示。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e30f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">UseRef用例</h1><p id="18db" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用钩子useRef的一个主要用例是在React中引用DOM元素。DOM中的每个元素都有一个名为ref的属性，我们可以将ref设置为这个属性。下面是一个示例，它允许我们在单击按钮后访问输入元素并聚焦于它:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="dce4" class="nb ma iq mx b gy nc nd l ne nf">const Mycomponent = ()=&gt; {<br/>  const inputRef = useRef(null)</span><span id="92b1" class="nb ma iq mx b gy ng nd l ne nf">  const inputFocus = () =&gt; {<br/>    inputRef.current.focus()<br/>  }</span><span id="daf0" class="nb ma iq mx b gy ng nd l ne nf">  return (<br/>    &lt;&gt;<br/>      &lt;input ref={inputRef} /&gt;<br/>      &lt;button onClick={inputFocus}&gt;Focus on the Input&lt;/button&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="4e30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">useRef的另一个用例是跨组件呈现持久化的存储。钩子useRef允许我们存储状态的前一个值。如果你感兴趣的话，你可以了解更多。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="40e8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">useState VS useRef</h1><p id="03bf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">对于使用状态:</p><ul class=""><li id="ad29" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">允许功能组件拥有自己的状态。</li><li id="7a8a" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">允许我们更新组件内部的状态。</li><li id="b84c" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">它会导致组件在状态更新后重新呈现。</li><li id="e8ce" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">返回当前状态。</li><li id="8a81" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">有一个更新状态的更新函数。</li></ul><p id="d192" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于useRef:</p><ul class=""><li id="f0f1" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">返回具有包含初始值的属性的对象。</li><li id="8315" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">当值或状态改变时，不会导致组件重新呈现。</li><li id="9d79" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">数据在渲染之间保持不变。</li><li id="e6f2" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">允许引用DOM元素。</li></ul><p id="31f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是这两个非常有用的React钩子之间的区别。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1b17" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="3edc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如您所见，挂钩useState和useRef有点相似。不同之处在于，useState返回当前状态，并有一个更新状态的updater函数。虽然useRef返回一个对象，但不会导致组件重新呈现，它用于引用DOM元素。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="f1d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ny">感谢您阅读本文。此外，如果你觉得我的内容有用，而你不是一个媒体成员，你可以抓住你的媒体成员</em> <a class="ae kv" href="https://mehdiouss.medium.com/membership" rel="noopener"> <em class="ny">这里</em> </a> <em class="ny">(媒体推荐链接)获得无限制访问媒体上的所有文章，并支持我们作为作家。</em></p><div class="nz oa gp gr ob oc"><a href="https://mehdiouss.medium.com/membership" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">通过我的推荐链接加入Medium-Mehdi Aoussiad</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">mehdiouss.medium.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kp oc"/></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="514b" class="nb ma iq bd mb or os dn mf ot ou dp mj lf ov ow ml lj ox oy mn ln oz pa mp pb bi translated"><strong class="ak">延伸阅读:</strong></h2><div class="nz oa gp gr ob oc"><a rel="noopener  ugc nofollow" target="_blank" href="/difference-between-find-and-findindex-in-javascript-63204178bbc1"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">JavaScript中find()和findIndex()的区别</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">JavaScript中的find() vs findindex():你需要知道的一切。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ol l"><div class="pc l on oo op ol oq kp oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a rel="noopener  ugc nofollow" target="_blank" href="/6-awesome-css-shorthand-properties-that-you-probably-dont-know-f593b21ebf3"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">你可能不知道的6个很棒的CSS速记属性</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">每个开发人员都应该知道的有用的CSS速记属性列表。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ol l"><div class="pd l on oo op ol oq kp oc"/></div></div></a></div><p id="3efd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ny">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ny">Twitter</em></strong></a><em class="ny">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ny">LinkedIn</em></strong></a><em class="ny">。加入我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">社区不和谐</em> </strong> </a> <em class="ny">。</em></strong></a></p></div></div>    
</body>
</html>