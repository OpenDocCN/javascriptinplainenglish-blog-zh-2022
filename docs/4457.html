<html>
<head>
<title>How To Set Up GraphQL in Your React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React应用程序中设置GraphQL</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-set-up-graphql-in-your-react-application-45513fcbf710?source=collection_archive---------10-----------------------#2022-12-05">https://javascript.plainenglish.io/how-to-set-up-graphql-in-your-react-application-45513fcbf710?source=collection_archive---------10-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d5335b4135b7fe4f17c28186ff3eebba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjVr87nTkybfJLmZM8QFfg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://codersociety.com/blog/articles/graphql-reasons" rel="noopener ugc nofollow" target="_blank">https://codersociety.com/blog/articles/graphql-reasons</a></figcaption></figure><p id="3a38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您还不熟悉GraphQL，您可以查看本文,它会让您对它的重要性以及何时使用它有一个基本的了解。</p><p id="86e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经是了，你可能还想看看<a class="ae kc" href="https://medium.com/javascript-in-plain-english/how-to-set-up-a-graphql-server-with-node-js-express-8638a068b609" rel="noopener">这篇文章</a>，在这里我们深入探讨了如何用Node.js &amp; Express.js建立一个GraphQL服务器</p><h1 id="6390" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="db39" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本文中，我们将了解如何在<a class="ae kc" href="https://www.apollographql.com" rel="noopener ugc nofollow" target="_blank"> Apollo </a>的帮助下，在React应用程序中实现GraphQL。</p><p id="b3c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多方法可以将GraphQL集成到我们的React应用程序中，但我确实更喜欢Apollo而不是其他任何替代方案。</p><blockquote class="me mf mg"><p id="fc77" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated"><em class="iq">包含本文将要介绍的所有代码的库可以在这里</em>  <em class="iq">找到</em> <a class="ae kc" href="https://github.com/Vlad-Mihet/react-apollo-integration" rel="noopener ugc nofollow" target="_blank"> <em class="iq">。</em></a></p><p id="2472" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated"><em class="iq">请务必在这里</em>  <em class="iq">查看我们将要与之交互的GraphQL服务器存储库。</em></p></blockquote><h1 id="5280" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">项目设置</h1><h1 id="a0db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.设置React项目</h1><p id="69ba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，我们将从创建一个新的React项目开始。这可以通过<strong class="kf ir"> npm </strong>或<strong class="kf ir">纱线</strong>来完成。我个人比较喜欢纱，但是你也可以用npm这里没有问题。</p><h1 id="9aff" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.安装所需的依赖项</h1><p id="c89f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因为我们只会做一些更基础的东西，所以为了安装Apollo，你只需要安装两个库:</p><ul class=""><li id="6a86" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kf ir"> @apollo/client </strong>，其中包含了设置apollo客户端所需的几乎所有内容。</li><li id="714b" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kf ir"> graphql </strong>，它提供了处理graphql查询的逻辑。</li></ul><h1 id="57ed" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.设置Apollo客户端</h1><p id="7246" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们已经安装了两个必需的依赖项，我们可以继续安装Apollo客户机了。</p><p id="f295" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们从<strong class="kf ir"> @apollo/client </strong>添加所需的导入:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="5396" class="ni lc iq ne b be nj nk l nl nm">import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';</span></pre><ul class=""><li id="cca6" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kf ir"> ApolloClient </strong>是主类，一旦实例化，它将创建一个新的Apollo客户端实例(我们可以有多个)。</li><li id="daf4" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">InMemoryCache是一个类，我们将使用它来让Apollo客户端处理其请求的缓存过程。</li><li id="7718" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">ApolloProvider 是一个组件，它接收一个<strong class="kf ir">客户端</strong>，这将允许我们将一个Apollo客户端注入到我们的应用程序中。</li></ul><p id="8c8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们继续创建我们的第一个Apollo客户端:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="6e28" class="ni lc iq ne b be nj nk l nl nm">const apolloClient = new ApolloClient({<br/>  uri: 'http://localhost:8080/graphql',<br/>  cache: new InMemoryCache(),<br/>});</span></pre><p id="b7e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里你可以看到我们将两个属性传递给了ApolloClient的构造器。它们用于指定后端GraphQL服务器的端点，以及Apollo将使用的缓存机制(我们已经通过了导入的默认机制— <strong class="kf ir"> InMemoryCache </strong>)。</p><p id="db42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们为客户做准备的全部内容。</p><h1 id="a08c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4.连接阿波罗客户端</h1><p id="2132" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">设置过程的最后一步是将Apollo客户机连接到我们的React应用程序。我们可以通过将我们的<strong class="kf ir"> &lt; App / &gt; </strong>组件包装在<strong class="kf ir"> &lt; ApolloProvider &gt; </strong>组件中来实现这一点:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="f368" class="ni lc iq ne b be nj nk l nl nm">root.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;ApolloProvider client={apolloClient}&gt;<br/>      &lt;App /&gt;<br/>    &lt;/ApolloProvider&gt;<br/>  &lt;/React.StrictMode&gt;<br/>);</span></pre><p id="565b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<strong class="kf ir"> App.js </strong>现在应该是这样的:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="cb14" class="ni lc iq ne b be nj nk l nl nm">import React from 'react';<br/>import ReactDOM from 'react-dom/client';<br/>import './index.css';<br/>import App from './App';<br/>import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';<br/><br/>const apolloClient = new ApolloClient({<br/>  uri: 'http://localhost:8080/graphql',<br/>  cache: new InMemoryCache(),<br/>});<br/><br/>const root = ReactDOM.createRoot(document.getElementById('root'));<br/><br/>root.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;ApolloProvider client={apolloClient}&gt;<br/>      &lt;App /&gt;<br/>    &lt;/ApolloProvider&gt;<br/>  &lt;/React.StrictMode&gt;<br/>);</span></pre><h1 id="1a71" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用useQuery获取数据</h1><p id="dd75" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们已经完成了Apollo客户端的设置，我们可以开始使用由@apollo/client库以及graphql库提供的一些工具。</p><p id="a210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于本文，还应该有一个展示使用Node.js和Express构建的基本GraphQL服务器的存储库，它允许我们访问一些作者和一些书籍。</p><p id="a552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个作者可以有多本书，但一本书只能有一个作者，因此其背后的模式如下所示:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/563bbf1584988a17029499b32efa34b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E5HEMHjlD5i_HLav.png"/></div></div></figure><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e531b5d93bb663578b052ff9f4d6747f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*t3Irz7-ooVphwyq9.png"/></div></figure><p id="b2d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们深入一些简单的用例，比如检索作者和他们写过的书。首先，我们必须创建一个GraphQL查询，可以这样做:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="db6f" class="ni lc iq ne b be nj nk l nl nm">const GET_AUTHORS_WITH_BOOKS_QUERY = gql`<br/>    query {<br/>      authors {<br/>        id<br/>        firstName<br/>        lastName<br/>        books {<br/>          id<br/>          title<br/>        }<br/>      }<br/>    }<br/>  `;</span></pre><p id="aa36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，我们必须使用<strong class="kf ir"> useQuery </strong>钩子查询我们的数据:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="0f5b" class="ni lc iq ne b be nj nk l nl nm">const { data, loading, error } = useQuery(GET_AUTHORS_WITH_BOOKS_QUERY);</span></pre><p id="4732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们将访问3个重要的属性:</p><ul class=""><li id="3479" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kf ir"> <em class="mh">数据</em> </strong>，代表我们查询到的数据(根据我们之前定义的gql查询)</li><li id="f8e2" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kf ir"> <em class="mh">加载</em> </strong>，它给出了请求的状态，特别是它是否已经完成加载</li><li id="ed2c" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kf ir"> <em class="mh">错误</em> </strong>，在请求失败的情况下，它会向我们指出遇到了什么问题(验证、服务器关闭等)。)</li></ul><p id="1980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以利用这些属性来处理我们的数据:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="c9f1" class="ni lc iq ne b be nj nk l nl nm">return (<br/>    &lt;div className="App"&gt;<br/>      &lt;div className="authors-container"&gt;<br/>        {loading ? (<br/>          &lt;p&gt;Loading Authors...&lt;/p&gt;<br/>        ) : error ? (<br/>          &lt;p&gt;There was an issue loading the data...&lt;/p&gt;<br/>        ) : (<br/>          data?.authors.map((author) =&gt; (<br/>            &lt;div className="user-record" key={author.id}&gt;<br/>              &lt;p&gt;Author: {author.firstName + " " + author.lastName}&lt;/p&gt;<br/>              &lt;div className="author-books-container"&gt;<br/>                {author?.books?.length &amp;&amp; &lt;h3&gt;Books Written:&lt;/h3&gt;}<br/>                {author?.books?.map((book) =&gt; (<br/>                  &lt;div className="author-book-record"&gt;<br/>                    &lt;p&gt;Book Title: {book.title}&lt;/p&gt;<br/>                  &lt;/div&gt;<br/>                ))}<br/>              &lt;/div&gt;<br/>            &lt;/div&gt;<br/>          ))<br/>        )}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );</span></pre><p id="f26d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，如你所见，我们将检索我们存储的所有作者，我们将在屏幕上显示他们的姓名和他们所写书籍的标题。</p><p id="3492" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有预先定义的属性都是<strong class="kf ir">反应性的</strong>，这意味着我们唯一要做的就是使用它们，一切都将与我们的React应用程序很好地挂钩；这意味着一旦加载过程结束，例如，加载变量的值将变为falsy，然后我们将知道我们可以访问数据属性或错误属性。</p><h1 id="89f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用useMutation更新/创建数据</h1><p id="c4a6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">更新或改变数据的过程与查询数据的过程非常相似，唯一的区别是我们使用的关键字(<strong class="kf ir"><em class="mh">query</em></strong>vs<strong class="kf ir"><em class="mh">mutation</em></strong>)，以及我们从调用钩子得到的内容(这是一个为我们提供触发改变的函数的数组)，以及我们从<strong class="kf ir"> useQuery </strong>钩子(<strong class="kf ir"> <em class="mh"> data </em> </strong>，<strong class="kf ir"><em class="mh">loading<em class="mh"/></em></strong></p><p id="d2ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建新作者的变异查询如下所示:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="a923" class="ni lc iq ne b be nj nk l nl nm">const ADD_AUTHOR_MUTATION = gql`<br/>  mutation CreateAuthor($firstName: String!, $lastName: String!) {<br/>    createAuthor(<br/>      firstName: $firstName<br/>      lastName: $lastName<br/>    ) {<br/>      id<br/>    }<br/>  }<br/>`;</span></pre><p id="9358" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="mh"> useMutation </em> </strong>钩子调用应该是这样的:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="85c7" class="ni lc iq ne b be nj nk l nl nm">const [addAuthor] = useMutation(ADD_AUTHOR_MUTATION);</span></pre><p id="2325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不会使用<strong class="kf ir"> <em class="mh">数据</em> </strong>、<strong class="kf ir"> <em class="mh">加载</em> </strong>、以及<strong class="kf ir"> <em class="mh">错误</em> </strong>属性，因为我们只会启动而忘记突变函数。</p><p id="c214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于JSX和React代码的其余部分，我们将创建一个新的表单来输入作者的名字和姓氏，在提交时我们将触发一个<strong class="kf ir"> addAuthor </strong>函数调用来创建新的作者记录。</p><p id="bb39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终的<strong class="kf ir"> App.js </strong>文件如下所示:</p><pre class="mz na nb nc gt nd ne nf bn ng nh bi"><span id="2185" class="ni lc iq ne b be nj nk l nl nm">import { useState } from "react";<br/>import { useQuery, useMutation, gql } from "@apollo/client";<br/>import "./App.css";<br/>function App() {<br/>  const [authorFirstName, setAuthorFirstName] = useState("");<br/>  const [authorLastName, setAuthorLastName] = useState("");<br/>  const GET_AUTHORS_WITH_BOOKS_QUERY = gql`<br/>    query {<br/>      authors {<br/>        id<br/>        firstName<br/>        lastName<br/>        books {<br/>          id<br/>          title<br/>        }<br/>      }<br/>    }<br/>  `;<br/>  const ADD_AUTHOR_MUTATION = gql`<br/>    mutation CreateAuthor($firstName: String!, $lastName: String!) {<br/>      createAuthor(<br/>        firstName: $firstName<br/>        lastName: $lastName<br/>      ) {<br/>        id<br/>      }<br/>    }<br/>  `;<br/>  const { data, loading, error, refetch } = useQuery(GET_AUTHORS_WITH_BOOKS_QUERY);<br/>  const [addAuthor] = useMutation(ADD_AUTHOR_MUTATION);<br/>  const handleSubmitForm = (e) =&gt; {<br/>    e.preventDefault(); // Avoid refreshing the page<br/>    addAuthor({<br/>      variables: {<br/>        firstName: authorFirstName,<br/>        lastName: authorLastName,<br/>      },<br/>    });<br/>    refetch();<br/>  };<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;div className="authors-container"&gt;<br/>        {loading ? (<br/>          &lt;p&gt;Loading Authors...&lt;/p&gt;<br/>        ) : error ? (<br/>          &lt;p&gt;There was an issue loading the data...&lt;/p&gt;<br/>        ) : (<br/>          data?.authors.map((author) =&gt; (<br/>            &lt;div className="user-record" key={author.id}&gt;<br/>              &lt;p&gt;Author: {author.firstName + " " + author.lastName}&lt;/p&gt;<br/>              &lt;div className="author-books-container"&gt;<br/>                {author?.books?.length &amp;&amp; &lt;h3&gt;Books Written:&lt;/h3&gt;}<br/>                {author?.books?.map((book) =&gt; (<br/>                  &lt;div className="author-book-record"&gt;<br/>                    &lt;p&gt;Book Title: {book.title}&lt;/p&gt;<br/>                  &lt;/div&gt;<br/>                ))}<br/>              &lt;/div&gt;<br/>            &lt;/div&gt;<br/>          ))<br/>        )}<br/>      &lt;/div&gt;<br/>      &lt;div className="add-author-container"&gt;<br/>        &lt;form onSubmit={(e) =&gt; handleSubmitForm(e)}&gt;<br/>          &lt;input<br/>            type="text"<br/>            value={authorFirstName}<br/>            onChange={(e) =&gt; setAuthorFirstName(e.target.value)}<br/>          /&gt;<br/>          &lt;input<br/>            type="text"<br/>            value={authorLastName}<br/>            onChange={(e) =&gt; setAuthorLastName(e.target.value)}<br/>          /&gt;<br/>          &lt;button type="submit"&gt;Add Author&lt;/button&gt;<br/>        &lt;/form&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>export default App;</span></pre><h1 id="3cae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="5795" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">所以你有它。现在您应该有了一个基本的Apollo集成，随着应用程序复杂性的增加，您可以在此基础上进行构建。</p><p id="01ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着应用程序的增长，您应该开始考虑在单独的全局、特性或特定于视图的目录中分离查询和变化。您可能还想考虑创建钩子来处理常见的查询或变化，这样可以提高代码的可重用性，并消除多余的重复。</p><p id="ef69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望您喜欢阅读这篇文章，并希望它能帮助您理解在Apollo的帮助下在React应用程序中设置GraphQL的基础知识。如果你觉得我错过了什么，请在下面的评论中告诉我。</p><p id="f677" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次见。干杯！</p><h1 id="10cb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">有用的资源</h1><ul class=""><li id="b646" class="ml mm iq kf b kg lz kk ma ko np ks nq kw nr la mq mr ms mt bi translated"><a class="ae kc" href="https://www.apollographql.com/docs/react/data/queries" rel="noopener ugc nofollow" target="_blank">阿波罗查询</a></li><li id="2b36" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae kc" href="https://www.apollographql.com/docs/react/data/mutations" rel="noopener ugc nofollow" target="_blank">阿波罗突变</a></li><li id="cc2e" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae kc" href="https://www.apollographql.com/docs/react/data/refetching" rel="noopener ugc nofollow" target="_blank">重新提取数据</a></li><li id="54b3" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae kc" href="https://www.apollographql.com/docs/react/api/react/hooks" rel="noopener ugc nofollow" target="_blank">挂钩术语表</a></li><li id="530f" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae kc" href="https://www.apollographql.com/docs/react/api/link/apollo-link-rest" rel="noopener ugc nofollow" target="_blank">REST API与Apollo </a></li></ul><p id="bd6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mh">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mh">plain English . io</em></strong></a><em class="mh">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mh">免费周报</em> </strong> </a> <em class="mh">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mh">Twitter</em></strong></a><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mh">LinkedIn</em></strong></a><em class="mh"/><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mh">YouTube</em></strong></a><em class="mh"/><a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mh">不和</em> </strong> </a> <em class="mh">。对增长黑客感兴趣？检查</em> <a class="ae kc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mh">电路</em> </strong> </a> <em class="mh">。</em></p></div></div>    
</body>
</html>