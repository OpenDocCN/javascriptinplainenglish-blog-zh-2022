<html>
<head>
<title>What is the JavaScript “Array.reduce()” Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript“array . reduce()”方法是什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-array-reduce-method-14b0b6dc0282?source=collection_archive---------12-----------------------#2022-10-17">https://javascript.plainenglish.io/javascript-array-reduce-method-14b0b6dc0282?source=collection_archive---------12-----------------------#2022-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f512" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">reduce()方法用于处理一个数组，并基于数组中的所有元素返回值——下面是reduce()方法的工作原理。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/49144efc8a9b7b5f054b96397cce4fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdIxe5ZMGDhyapvrTiuk3w.png"/></div></div></figure><p id="80f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript reduce方法是一种递归方式，它基于数组中的每个元素执行计算，同时还考虑数组中的前一个元素。它接受一个函数，该函数也可用于根据您选择的逻辑进一步处理数组元素。</p><p id="55ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是非常有用的求和数组，或合并字符串为基础的数组。例如，我们可以将一个数组转换成一个字符串，如下所示:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="eed1" class="ls lt iq lo b gy lu lv l lw lx">let myArray = [ 'hello', 'world', 'welcome!' ]</span><span id="d101" class="ls lt iq lo b gy ly lv l lw lx">let reduceString = myArray.reduce((previousElement, currentElement) =&gt; {<br/>    return `${previousElement} ${currentElement}`;<br/>})</span><span id="4a80" class="ls lt iq lo b gy ly lv l lw lx">console.log(reduceString); // hello world welcome!</span></pre><p id="38ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，我们可以用它将数组中的所有数字相加，并返回一个数字:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="c91c" class="ls lt iq lo b gy lu lv l lw lx">let myArray = [ 5, 10, 15, 20 ]</span><span id="1149" class="ls lt iq lo b gy ly lv l lw lx">let reduceString = myArray.reduce((previousElement, currentElement) =&gt; previousElement + currentElement)</span><span id="9084" class="ls lt iq lo b gy ly lv l lw lx">console.log(reduceString); // 50</span></pre><h1 id="1a8c" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">reduce方法回调函数</h1><p id="53fe" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">reduce中使用的回调函数实际上有4个参数。您不需要使用任何一个，但是前两个是您通常想要的。该函数的格式如下所示:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="a5af" class="ls lt iq lo b gy lu lv l lw lx">Array.reduce((previousElement, currentElement, currentIndex, array) =&gt; {<br/>    // Do something with the array's data<br/>}, initialValue)</span></pre><p id="dec7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们来看看<code class="fe mv mw mx lo b">previousElement</code>、<code class="fe mv mw mx lo b">currentElement</code>、<code class="fe mv mw mx lo b">currentIndex</code>、<code class="fe mv mw mx lo b">array</code>、<code class="fe mv mw mx lo b">initialValue</code>都是什么意思。</p><h1 id="ec4b" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">前一元素</h1><p id="d34d" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">这是不言自明的。它表示我们正在迭代的当前元素的前一个元素。<code class="fe mv mw mx lo b">reduce</code>函数通常会从索引<code class="fe mv mw mx lo b">[1]</code>开始，因此前一个元素确实存在。如果您已经定义了一个<code class="fe mv mw mx lo b">initialValue</code>，那么将使用这个值，并且<code class="fe mv mw mx lo b">reduce</code>函数将从索引<code class="fe mv mw mx lo b">[0]</code>开始，使用<code class="fe mv mw mx lo b">initialValue</code>作为<code class="fe mv mw mx lo b">previousValue</code>。</p><h1 id="db49" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">电流遥测</h1><p id="33c8" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">这是reduce正在迭代的当前元素。</p><h1 id="b075" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">currentIndex</h1><p id="f952" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">因为数组不仅仅由索引组成，而且通常包含有用的数据，所以我们也有能力获取正在迭代的当前索引。这将返回表示当前元素在数组中位置的0索引数字。期望从该参数得到标准数组索引。</p><h1 id="8a82" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">排列</h1><p id="c102" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">这将返回整个数组——如果您计划使用<code class="fe mv mw mx lo b">reduce</code>操作数组，或者如果您想要基于数组中的其他元素进行计算，这将非常有用</p><h1 id="9b71" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">初始值</h1><p id="d4ff" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">如果提供，这将是索引<code class="fe mv mw mx lo b">[0]</code>的<code class="fe mv mw mx lo b">previousElement</code>。</p><p id="d738" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如上所述，这些都是可选的，但是它们都提供了一种有用的方式来操作和计算您的<code class="fe mv mw mx lo b">reduce</code>方法的返回值。</p><h1 id="d3a2" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">在reduce中变异数组</h1><p id="e84a" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">如果你试图改变<code class="fe mv mw mx lo b">reduce</code>中的数组，可能会导致一些有趣的行为——所以在考虑<code class="fe mv mw mx lo b">reduce</code>时，你应该考虑一些边缘情况。</p><p id="a504" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果您在当前元素之前的某个位置更改了数组元素，则归约仍会按预期进行。例如，将<code class="fe mv mw mx lo b">1000</code>加到<code class="fe mv mw mx lo b">myArray[currentIndex + 1]</code>仍会产生预期值:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="8604" class="ls lt iq lo b gy lu lv l lw lx">let myArray = [ 4, 5, 6, 7, 8 ]<br/>let reduceFunction = myArray.reduce((prevValue, currentValue, currentIndex) =&gt; {<br/>    myArray[currentIndex + 1] += 1000<br/>    return prevValue + currentValue<br/>});<br/>console.log(reduceFunction); // 3030</span></pre><p id="c73a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">然而</strong>，试图在运行<code class="fe mv mw mx lo b">reduce</code>的时候给一个数组加值是行不通的。例如，下面我使用<code class="fe mv mw mx lo b">push</code>为数组中的每个元素添加一个元素。这当然会导致一个无限循环，所以Javascript停止这个函数，只处理我们运行<code class="fe mv mw mx lo b">reduce</code>时数组中的值:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="f235" class="ls lt iq lo b gy lu lv l lw lx">let myArray = [ 4, 5, 6, 7, 8 ]<br/>let reduceFunction = myArray.reduce((prevValue, currentValue, currentIndex) =&gt; {<br/>    myArray.push(1000)<br/>    return prevValue + currentValue<br/>});<br/>console.log(reduceFunction); // 30</span></pre><h1 id="17ae" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">关于单值数组的注记</h1><p id="6342" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">如果你的数组只包含一个值，并且你没有使用<code class="fe mv mw mx lo b">initialValue</code>，那么<code class="fe mv mw mx lo b">reduce</code>函数将从数组中返回一个值，并且不调用回调函数。例如:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="8508" class="ls lt iq lo b gy lu lv l lw lx">let myArray = [ 'cat' ]<br/>let reduceFunction = myArray.reduce((prevValue, currentValue) =&gt; {<br/>    return currentValue + '!'<br/>});<br/>console.log(reduceFunction); // cat (does not have exclamation mark, even though we tried to add it)</span></pre><h1 id="b386" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">对对象数组中的值求和并组合</h1><p id="532d" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">您可能已经预料到了这种行为，但是如果您有一个对象数组，您可以引用每个elements对象的子属性来进行计算。例如，将下面所有的<code class="fe mv mw mx lo b">age</code>相加:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="d589" class="ls lt iq lo b gy lu lv l lw lx">let myArray = [ { age: 52 }, { age: 34 }, { age: 104 }, { age: 29 } ]<br/>let reduceFunction = myArray.reduce((prevValue, currentValue) =&gt; {<br/>    return prevValue + currentValue.age<br/>}, 0);<br/>console.log(reduceFunction); // 219</span></pre><p id="94f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能已经注意到了这里的一些奇怪的事情，这就是为什么研究这个例子是有用的:</p><ul class=""><li id="7547" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">我们必须定义一个<code class="fe mv mw mx lo b">initialValue</code>，因为最初，<code class="fe mv mw mx lo b">prevValue</code>是<code class="fe mv mw mx lo b">{ age: 52 }</code>，但后来，<code class="fe mv mw mx lo b">prevValue</code>是一个<code class="fe mv mw mx lo b">number</code>。这意味着我们保持类型一致。</li><li id="d5c0" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">因为每次我们运行<code class="fe mv mw mx lo b">reduce</code>时，它都返回数组元素中当前项的a值，所以我们使用<code class="fe mv mw mx lo b">prevValue</code>而不是<code class="fe mv mw mx lo b">prevValue.age</code>。<code class="fe mv mw mx lo b">prevValue.age</code>未定义，因为<code class="fe mv mw mx lo b">reduce</code>每次返回一个数字。</li></ul><h1 id="0c5d" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="935a" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">方法<code class="fe mv mw mx lo b">reduce</code>是一种非常有用的方法，可以组合数组中的所有内容，或者生成您选择的新数组。它很强大并且是递归的，所以在大型数据集上使用时要小心。如果你喜欢这个，我也在这里写了一篇关于切片法的文章。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="d606" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nu">更多内容请看</em><a class="ae nm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">plain English . io</em></strong></a><em class="nu">。报名参加我们的</em> <a class="ae nm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">免费周报</em> </strong> </a> <em class="nu">。关注我们关于</em><a class="ae nm" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">Twitter</em></strong></a><a class="ae nm" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">LinkedIn</em></strong></a><em class="nu"/><a class="ae nm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">YouTube</em></strong></a><em class="nu"/><a class="ae nm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">不和</em> </strong> </a> <em class="nu">。对增长黑客感兴趣？检查</em> <a class="ae nm" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">电路</em> </strong> </a> <em class="nu">。</em></p></div></div>    
</body>
</html>