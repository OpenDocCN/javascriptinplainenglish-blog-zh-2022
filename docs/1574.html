<html>
<head>
<title>Top React 18 Features Explained in Less Than 5 Mins!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不到5分钟的时间里解释了18个顶级React功能！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/top-react-18-features-explained-in-less-than-5-mins-f0095d1fa22c?source=collection_archive---------2-----------------------#2022-04-04">https://javascript.plainenglish.io/top-react-18-features-explained-in-less-than-5-mins-f0095d1fa22c?source=collection_archive---------2-----------------------#2022-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="03a5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">对变化的总体总结。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8fbbf83e4bf345d48a2e5f5790e5767f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqhX9Bd2VFbJT49mE2LMig.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Source: Canva</figcaption></figure><p id="b9ee" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最近React 18发布了，我也忍不住想试一试。我浏览了React官方网站上的变更日志、讲座和博客帖子，以了解这些功能。这篇博文将分享我的理解，并保持细节简洁，以呈现这些变化的总体总结。</p><p id="cef4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">事不宜迟，让我们直入主题吧！🦘</p><h1 id="3b62" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">React 18有什么新功能？</h1><p id="849b" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">React核心团队努力支持React中的并发性，这实现了新的功能并有助于创建流畅的UI。并发的一个基本属性是React中的呈现是<strong class="ku io">可中断的。</strong> React将决定何时开始、暂停和恢复更新。有了这个功能，它将等待整个树被计算，并在最后执行DOM操作。这种方法保持了主线程的自由，从而实现了流畅的用户体验。如果正在进行繁重的渲染，UI仍然可以通过中断渲染过程来快速响应用户交互。</p><p id="8eb0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">React中的并发实现依赖于优先级队列和多重缓冲等概念。但是作为一个应用程序开发人员，你需要知道它的更高层次的细节，这是我们刚刚在上面学到的。v18的许多功能在核心处使用了并发性，比如过渡和悬念。</p><p id="5705" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">那么并发性会被打破吗？</strong></p><p id="c4eb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">技术上说是的！由于并发性，React呈现是可中断的，因此某些组件的行为可能会改变。但是正如React团队所说，</p><p id="7a0c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在我们的测试中，我们已经升级了数千个组件来响应18。我们发现，几乎所有现有的组件都“能够”与并发渲染一起工作，没有任何改变。但是，其中一些可能需要一些额外的迁移工作。尽管这些变化通常很小，但您仍然有能力按照自己的步调做出改变。</p><h1 id="8973" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">新功能</h1><ol class=""><li id="df7e" class="ml mm in ku b kv mg ky mh lb mn lf mo lj mp ln mq mr ms mt bi translated"><strong class="ku io">改进的自动配料</strong></li></ol><p id="a0e6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在React 18之前，状态更新的批处理仍然是可能的，但是只能使用React事件处理程序。默认情况下，<em class="mu"> promises、setTimeout、本地事件处理程序</em>或任何其他事件中的更新不会在React中批处理。使用<em class="mu">自动批处理</em>，这些更新将被默认批处理。批处理意味着将所有更新操作发送到单个批处理中，以便只呈现一次UI，而不是为所有更新操作重新呈现UI。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/30b13db7c14570edb8430e51031f672c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJZOi8aPuDADamSY9tHiCA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">No event batching for user handlers before React 18</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/c3689cc577d015fea43c42d394f05f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3AKGRHA91HNy60RuBLthqw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Event batching with React 18</figcaption></figure><p id="d25c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">2.<strong class="ku io">服务器渲染悬念</strong></p><p id="af6f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">服务器渲染是一种技术，在这种技术中，服务器将计算出的HTML发送给客户端，以便用户看到一些东西。一旦发送了HTML，服务器就会捆绑JS文件，并在后台将它们传输到客户端。在JS成功加载到客户端之前，UI对用户没有响应。</p><p id="6dd6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在React 18之前，这种方法存在问题。假设在一个应用程序中，有一个组件比其他组件慢。在这种情况下，整个应用程序的HTML不会被加载，直到慢速组件的数据被获取。在HTML到达客户端之前，用户将会看到一个空白的屏幕，从而造成了糟糕的用户体验。</p><p id="b4af" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">React 18在服务器端渲染中对悬念API的支持解决了这个问题。我们现在可以暂停最慢的组件，并显示一个后备组件，直到它的数据到达。这将几乎立即向客户端发送HTML，并显示最慢组件的后备组件。一旦组件有了数据，它的HTML将通过相同的流发送到客户机。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using Suspense for data-heavy component</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/25f8e93cc58b6618b82dbf202ce111ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6psEDLaPllPeQyhXqoogig.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using Suspense to show the fallback spinner for the Main section</figcaption></figure><p id="edf7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">3.<strong class="ku io">用于并发特性的新APIs】</strong></p><p id="75fa" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">React引入了一些新的API来访问它的并发特性。API如下—</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React Concurrent APIs</figcaption></figure><p id="2312" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">React引入了一个新概念——<strong class="ku io">转换</strong>，区分紧急和非紧急任务。紧急任务是指需要对用户交互(如键盘点击、UI交互等)做出即时响应的任务。而非紧急任务(或转换)不需要立即行动。这些可以推迟到紧急行动尽快完成。推迟紧急任务的非优先操作有助于创造流畅的用户体验。</p><p id="b077" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">例如:假设在一个网页上有一个评论组件和一个输入组件来写评论。因为comments组件使用REST API来获取结果，所以组件需要一段时间来加载和呈现数据。因为comments组件需要大量的呈现，所以在comments部分的呈现完成之前，input组件是无意义的。现在，这就是我所说的创造“糟糕体验”的东西。您正在尝试单击输入组件来编写注释，但是它没有响应，因为CPU正忙于呈现注释组件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9cd8b821d92f3b573def83d3c7cd5670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCYWbWkSuOLqEYrHolO9XA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">User events will be blocked until the comments section is rendered completely (Before React 18)</figcaption></figure><p id="b4c0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这就是上面的转换API将提供帮助的地方。在它们的帮助下，您可以让React知道注释组件呈现是一个非紧急任务，它可能会因为紧急任务的发生而被中断，这里是输入组件交互。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="676c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">封装在转换API中的任何更新都将被视为非紧急任务，React将中断它以完成紧急任务。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="4bd4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">以上是React 18的突出特点。这些特性无疑改善了开发者和用户的体验。请在评论中告诉我你喜欢这个博客。如果这分享了一些信息，请给一些掌声。</p><p id="cf07" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="mu">我是一个React和JavaScript的人。我在媒体上与世界分享我的知识。请关注我以获取更多内容。也可以关注我的</em> <a class="ae ng" href="https://twitter.com/utkarsh22garg" rel="noopener ugc nofollow" target="_blank"> <em class="mu">推特</em> </a> <em class="mu">。</em></p><p id="548c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="mu">更多内容请看</em><a class="ae ng" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="mu">plain English . io</em></strong></a><em class="mu">。报名参加我们的</em><strong class="ku io"><em class="mu"/></strong><a class="ae ng" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="mu">免费周报</em> </strong> </a> <em class="mu">。关注我们关于</em> <a class="ae ng" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="mu">推特</em> </strong> </a> <em class="mu">和</em><strong class="ku io"><em class="mu"/></strong><a class="ae ng" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="mu">LinkedIn</em></strong></a><em class="mu">。加入我们的</em> <a class="ae ng" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="mu">社区</em> </strong> </a> <em class="mu">。</em></p></div></div>    
</body>
</html>