<html>
<head>
<title>Mock JavaScript Dates with Fake Timer and Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用假计时器和笑话模拟JavaScript日期</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mock-js-dates-with-fake-timer-and-jest-7d20c6ab9bff?source=collection_archive---------2-----------------------#2022-05-21">https://javascript.plainenglish.io/mock-js-dates-with-fake-timer-and-jest-7d20c6ab9bff?source=collection_archive---------2-----------------------#2022-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="79ff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当涉及日期时，更好地控制你的测试。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/583b82cf4b1239d57310fa86b47ab6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVjRB4tuobki6Kk4PKRuhg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by Bich Tran: <a class="ae kv" href="https://www.pexels.com/photo/white-and-black-weekly-planner-on-gray-surface-1059383/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/white-and-black-weekly-planner-on-gray-surface-1059383/</a></figcaption></figure><p id="ca63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一段时间，Moment.js允许我们避免使用js日期。但是，老实说，他们真的不怎么样。但是从那以后，JS发展了很多，今天，日期JS对象是Javascript的未来。而Moment.js被弃用只是进一步证明了这一点。</p><p id="cef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一些现代的不可变库还在包装自己的日期对象时。其他一些工具，比如date-fns，只是一组更容易操作JS日期的工具。这意味着使用它们的方式会改变，测试它们的方式也会改变！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="84e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以前，我们可以很容易地模仿moment在被调用时返回一个特定的日期。然而，由于日期JS对象完全是JS运行时的一部分，所以没有办法模仿一个模块。不过jest团队想了想，给了我们一个解决方案:useFakeTimers。</p><h1 id="71c0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么嘲笑时代</h1><p id="f1ba" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">时间的主要问题是它从来都不是静止的。时间总是在变化，在你意识到这一点之前，你的测试会失败或者不可预测。这就是为什么你应该在测试时嘲笑你的时间，这样你就可以期待一个恒定的结果。</p><h1 id="af8e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">它是如何工作的</h1><p id="ddc4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">对于本文，我们假设您有一个安装项目(无论是NodeJS还是Web，都没有关系)。</p><p id="1abf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们编写一个简单的测试来打印<code class="fe mw mx my mz b">new Date()</code>的结果</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="328e" class="ne ma iq mz b gy nf ng l nh ni">describe('Testing date', () =&gt; {<br/>  it('Should work', () =&gt; {<br/>    const date = new <strong class="mz ir"><em class="nj">Date</em></strong>();<br/>    <strong class="mz ir"><em class="nj">console</em></strong>.log(date);<br/>  })<br/>})</span></pre><p id="7592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行此测试两次，结果会略有不同。那可不行。这就是为什么我们想要使用<code class="fe mw mx my mz b">useFakeTimer</code>将我们的测试从当前时间中分离出来。</p><p id="eb9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将它添加到我们的测试中</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="cdf3" class="ne ma iq mz b gy nf ng l nh ni">describe('Testing date', () =&gt; {<br/>  it('Should work', () =&gt; {<br/>    <strong class="mz ir"><em class="nj">jest</em></strong>.useFakeTimers();<br/>    const date = new <strong class="mz ir"><em class="nj">Date</em></strong>();<br/>    <strong class="mz ir"><em class="nj">console</em></strong>.log(date);<br/>  })<br/>})</span></pre><p id="b8e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您运行您的测试，什么都没有改变，这是不幸的！实际上，使用假计时器是不够的，因为默认情况下，假计时器正在使用当前时间。我们想在此基础上使用<code class="fe mw mx my mz b">setSystemTime</code>来设置一个特定的时间</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="116d" class="ne ma iq mz b gy nf ng l nh ni">describe('Testing date', () =&gt; {<br/>  it('Should work', () =&gt; {<br/>    <strong class="mz ir"><em class="nj">jest</em></strong>.useFakeTimers();<br/>    <strong class="mz ir"><em class="nj">jest</em></strong>.setSystemTime(new <strong class="mz ir"><em class="nj">Date</em></strong>('2020-02-19'));<br/>    const date = new <strong class="mz ir"><em class="nj">Date</em></strong>();<br/>    <strong class="mz ir"><em class="nj">console</em></strong>.log(date);<br/>  })<br/>})</span></pre><p id="ab34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧啊。现在，我们正在控制台中打印<code class="fe mw mx my mz b">2020–02–19T00:00:00.000Z</code>，我们的日期被嘲弄了！</p><blockquote class="nk nl nm"><p id="eb5c" class="kw kx nj ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">请记住，您必须使用IOS字符串格式来创建新日期。</p></blockquote><p id="c2fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您不必做任何事情来“取消”日期，因为每个jest测试都是独立的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="257f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！一篇非常短但(希望)有帮助的文章！希望你喜欢。</p><p id="b0ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nj">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nj">plain English . io</em></strong></a><em class="nj">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nj">免费周报</em> </strong> </a> <em class="nj">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nj">Twitter</em></strong></a><em class="nj">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nj">LinkedIn</em></strong></a><em class="nj">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nj">社区不和谐</em> </strong> </a> <em class="nj">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nj">人才集体</em> </strong> </a> <em class="nj">。</em></p></div></div>    
</body>
</html>