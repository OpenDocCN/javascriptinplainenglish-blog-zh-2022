<html>
<head>
<title>What is the Temporal Dead Zone in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的时间死区是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/temporal-dead-zone-javascript-c38e63826cd?source=collection_archive---------11-----------------------#2022-01-09">https://javascript.plainenglish.io/temporal-dead-zone-javascript-c38e63826cd?source=collection_archive---------11-----------------------#2022-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/907c03533cfabc55db88ad786ee7a0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1c95WxVi7qnHp8CqAYr9g.png"/></div></div></figure><p id="46f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你以为只有恐怖片才有死亡地带吗？好好读读这个故事，你会惊讶地发现它们也是用JavaScript写的！</p><p id="6be5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是它们出现在哪里呢？嗯，大多数恐怖和幽灵的东西最近开始消失。但JavaScript的死区出现在2015年，当时ECMAScript的TC39发布了JavaScript的新标准(俗称ES6)。然而，在了解死区之前，您需要了解一个简单的概念。所以，我们来讨论一下JavaScript中的提升是什么。</p><h1 id="d01d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是吊装？</h1><p id="543b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">JavaScript引擎在执行之前解析代码，在解析阶段，它将所有的<strong class="ka ir">变量和函数声明</strong>转移到作用域的顶部。JS引擎的这种行为叫做<strong class="ka ir">提升</strong>。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="ab gu cl md"><img src="../Images/ff5a65dae3716f6859c3ae9b956410ac.png" data-original-src="https://miro.medium.com/v2/format:webp/0*OaOSmbVazWufL1oQ.png"/></div></figure><h1 id="75f3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">可变提升</h1><p id="b00a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">考虑下面的代码片段:</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="1a89" class="mj kx iq mf b gy mk ml l mm mn">console.log(greeting); // undefined<br/>var greeting = "Hello";</span></pre><p id="e965" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到,<code class="fe mo mp mq mf b">greeting</code>变量在声明之前可以被访问，尽管它的值是未定义的。发生这种情况是因为JS引擎在执行之前将我们的代码片段修改成这样。</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="a657" class="mj kx iq mf b gy mk ml l mm mn">var greeting;<br/>console.log(greeting); // undefined</span><span id="0688" class="mj kx iq mf b gy mr ml l mm mn">greeting = "Hello";</span></pre><p id="56d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，变量声明被移动到声明它们的作用域的顶部。例如:</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="ea6b" class="mj kx iq mf b gy mk ml l mm mn">function () {<br/>  console.log(x);<br/>  var x = 'hoisted in function scope';<br/>}</span><span id="f881" class="mj kx iq mf b gy mr ml l mm mn">console.log(y);<br/>var y = 'hoisted in global scope';</span></pre><p id="5d23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">吊装后将转换为以下形式</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="9e48" class="mj kx iq mf b gy mk ml l mm mn">var y;<br/>function () {<br/>  var x;<br/>  console.log(x);<br/>  x = 'hoisted in function scope';<br/>}</span><span id="d527" class="mj kx iq mf b gy mr ml l mm mn">console.log(y);<br/>y = 'hoisted in global scope';</span></pre><h1 id="3e0f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">功能提升</h1><p id="ff2b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">JavaScript中的正式函数声明也被提升到了作用域的顶部。例如:</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="a4c7" class="mj kx iq mf b gy mk ml l mm mn">greeting(); // Hello</span><span id="d161" class="mj kx iq mf b gy mr ml l mm mn">function greeting() {<br/>  console.log("Hello");<br/>}</span></pre><p id="5898" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>变量提升和<strong class="ka ir">函数提升</strong>的重要区别在于:一个<code class="fe mo mp mq mf b">var</code>变量被提升后自动初始化为<code class="fe mo mp mq mf b">undefined</code>，而一个函数声明被提升后<strong class="ka ir">初始化为其函数值</strong>。</p><h1 id="fc55" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">函数声明与函数表达式</h1><p id="22f2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><em class="ms">函数提升</em>只适用于形式<code class="fe mo mp mq mf b">function</code>声明，不适用于<code class="fe mo mp mq mf b">function</code>表达式赋值。考虑:</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="b673" class="mj kx iq mf b gy mk ml l mm mn">greeting(); // TypeError: greeting is not a function</span><span id="b5b6" class="mj kx iq mf b gy mr ml l mm mn">console.log(greeting); // undefined</span><span id="7ffa" class="mj kx iq mf b gy mr ml l mm mn">var greeting = function greeting() {<br/>  console.log("Hello!");<br/>};</span></pre><p id="96d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我们可以看到<code class="fe mo mp mq mf b">greeting</code>变量被提升了，但是它没有用函数引用初始化。引擎扔给我们一个<code class="fe mo mp mq mf b">TypeError: greeting is not a function</code>而不是<code class="fe mo mp mq mf b">ReferenceError: greeting is not defined</code>。函数表达式赋值的行为非常类似于<strong class="ka ir">变量提升</strong>。</p><h1 id="1b02" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">let和const呢？</h1><p id="0c3b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">到目前为止，我们只讨论了<code class="fe mo mp mq mf b">var</code>和正式的<code class="fe mo mp mq mf b">function</code>声明。那<code class="fe mo mp mq mf b">let</code>和<code class="fe mo mp mq mf b">const</code>呢。<strong class="ka ir">所有的声明</strong> ( <code class="fe mo mp mq mf b">var</code>、<code class="fe mo mp mq mf b">let</code>、<code class="fe mo mp mq mf b">const</code>、<code class="fe mo mp mq mf b">function</code>、<code class="fe mo mp mq mf b">function*</code>、<code class="fe mo mp mq mf b">class</code> ) <strong class="ka ir">在JavaScript中都是“悬挂”</strong>。这意味着，如果在某个作用域中声明了一个名称，那么在该作用域中，标识符将总是引用该特定变量:</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="089f" class="mj kx iq mf b gy mk ml l mm mn">x = "global";<br/>// function scope:<br/>(function() {<br/>    x; // not "global"<br/>    var/let/… x;<br/>}());</span><span id="8990" class="mj kx iq mf b gy mr ml l mm mn">// block scope (not for `var`s):<br/>{<br/>    x; // not "global"<br/>    let/const/… x;<br/>}</span></pre><p id="8c0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看下面的片段</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="59c3" class="mj kx iq mf b gy mk ml l mm mn">console.log(greeting); // cannot access 'greeting' before initialization</span><span id="a173" class="mj kx iq mf b gy mr ml l mm mn">let greeting = "Hello";</span></pre><p id="accd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们得到一种新的错误，它不是一个<code class="fe mo mp mq mf b">ReferenceError</code>，引擎知道<code class="fe mo mp mq mf b">greeting</code>，但是不允许我们在它初始化之前使用它。JS引擎不允许我们在使用<code class="fe mo mp mq mf b">let</code>和<code class="fe mo mp mq mf b">const</code>声明变量之前访问它们。</p><p id="cd0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看这个片段-</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="a84f" class="mj kx iq mf b gy mk ml l mm mn">let greeting;<br/>console.log(greeting); // undefined<br/>greeting = "Hello";</span></pre><p id="7663" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面我们可以看到，一旦声明了<code class="fe mo mp mq mf b">greeting</code>变量，我们就可以访问它。</p><h1 id="d6f7" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">所以，let和const都不吊？</h1><h2 id="796b" class="mj kx iq bd ky mt mu dn lc mv mw dp lg kj mx my lk kn mz na lo kr nb nc ls nd bi translated"><strong class="ak">颞侧死区</strong></h2><blockquote class="ne nf ng"><p id="867a" class="jy jz ms ka b kb kc kd ke kf kg kh ki nh kk kl km ni ko kp kq nj ks kt ku kv ij bi translated">这被称为<strong class="ka ir">时间死区</strong>。</p></blockquote><p id="dc18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看了上面两个代码片段，似乎很有说服力的是<code class="fe mo mp mq mf b">let</code>和<code class="fe mo mp mq mf b">const</code>没有被吊起来。但它们确实是。我们可以再举几个例子来证明这一点</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="ad76" class="mj kx iq mf b gy mk ml l mm mn">console.log(typeof iDontExist); // undefined<br/>console.log(typeof greeting); // cannot access 'greeting' before initialization</span><span id="428b" class="mj kx iq mf b gy mr ml l mm mn">let greeting = "hello";</span></pre><p id="880b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<code class="fe mo mp mq mf b">greeting</code>变量没有被提升，我们会认为<code class="fe mo mp mq mf b">typeof greeting</code>与<code class="fe mo mp mq mf b">typeof iDontExist</code>相似。这证明JS引擎知道我们的<code class="fe mo mp mq mf b">greeting</code>变量，但是由于<strong class="ka ir">时间死区</strong>，仍然不允许我们访问它。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/b6357170c6493770cfd21d8a8ecd3c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1RTI3HdUgsI37OzN.jpg"/></div></div></figure><p id="88ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看另一个例子-</p><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="b4db" class="mj kx iq mf b gy mk ml l mm mn">let x = 'outer value';<br/>console.log(x); // outer value<br/>{<br/>  // start Temporal Dead Zone (TDZ) for x<br/>  console.log(x); // cannot access 'x' before initialization<br/>  let x = 'inner value'; // declaration ends TDZ for x<br/>}</span></pre><p id="320f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在内部作用域中访问变量<code class="fe mo mp mq mf b">x</code>仍然会导致TDZ错误。如果<code class="fe mo mp mq mf b">let x = 'inner value';</code>没有被吊起，那么在6号线上，它将记录<code class="fe mo mp mq mf b">outer value</code>。</p><p id="c3ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，<code class="fe mo mp mq mf b">var</code> / <code class="fe mo mp mq mf b">function</code> / <code class="fe mo mp mq mf b">function*</code>申报与<code class="fe mo mp mq mf b">let</code> / <code class="fe mo mp mq mf b">const</code> / <code class="fe mo mp mq mf b">class</code>申报的区别在于<strong class="ka ir">初始化</strong>。前者是在作用域顶部创建绑定时用<code class="fe mo mp mq mf b">undefined</code>或(生成器)函数初始化的。然而，用<code class="fe mo mp mq mf b">let</code> / <code class="fe mo mp mq mf b">const</code> / <code class="fe mo mp mq mf b">class</code>声明的变量保持<strong class="ka ir">未初始化</strong>。只有在对<code class="fe mo mp mq mf b">let</code> / <code class="fe mo mp mq mf b">const</code> / <code class="fe mo mp mq mf b">class</code>语句求值时，它才会被初始化，之前(上面)的所有内容都被称为<strong class="ka ir"> <em class="ms">时间死区</em> </strong>。此外，需要注意的是<code class="fe mo mp mq mf b">let y</code>等同于<code class="fe mo mp mq mf b">let y = undefined</code>。这意味着<code class="fe mo mp mq mf b">let</code>关键字在遇到变量时将其初始化为undefined，但是变量在提升时不会被初始化。</p><h1 id="24b9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><ul class=""><li id="995d" class="nl nm iq ka b kb lu kf lv kj nn kn no kr np kv nq nr ns nt bi translated">用<code class="fe mo mp mq mf b">undefined</code>提升并初始化<code class="fe mo mp mq mf b">var</code>声明。</li><li id="195b" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">形式函数声明用它们的函数引用来提升和初始化。</li><li id="c423" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated"><code class="fe mo mp mq mf b">let</code>和<code class="fe mo mp mq mf b">const</code>变量也被提升，但是在它们声明之前不能被访问。这被称为时间死区。</li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="9549" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想学习现代JavaScript概念，TypeScript，React或者Next.js？请关注我的个人资料。我已经在Vue.js上发布了2门课程，并将很快发布一门完整的——使用Next.js和TypeScript进行全栈开发的课程。</p><p id="ade8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae og" href="https://www.udemy.com/user/coding-simplified/" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/user/coding-simplified/</a></p><p id="5ff7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">更多内容请看</em><a class="ae og" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ms">plain English . io</em></a><em class="ms">。报名参加我们的</em> <a class="ae og" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">免费每周简讯</em> </a> <em class="ms">。在我们的</em> <a class="ae og" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="ms">社区</em> </a> <em class="ms">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>