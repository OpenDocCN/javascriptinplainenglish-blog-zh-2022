<html>
<head>
<title>The Difference Between TypeScript interface and type — Final Version</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript接口和type-Final版本的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-difference-between-typescript-interface-and-type-final-version-3e8801a16b2f?source=collection_archive---------8-----------------------#2022-03-10">https://javascript.plainenglish.io/the-difference-between-typescript-interface-and-type-final-version-3e8801a16b2f?source=collection_archive---------8-----------------------#2022-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a889" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">详细讲解接口和类型的区别，以及实际使用场景，团队规范。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f5d6b0a848121ab85537812ae954723d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TsKp1WkHLBzkC_WM"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@mr_vero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Irvan Smith</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fbc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>是JavaScript的超集。它出色的设计架构和流畅的类型系统给我们带来了全面的体验，但它的一些概念和用法非常混乱。</p><p id="32fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从本文中，您可以了解到:</p><ul class=""><li id="61bb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">深入了解<code class="fe mb mc md me b">interface</code>和<code class="fe mb mc md me b">type</code>在TypeScript中的区别是什么。</li><li id="69c6" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">如何在各个场景中正确使用。</li><li id="4574" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">构建您自己的类型脚本工具。</li></ul><p id="2a18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mk">本文假设您已经具备一定的打字技能。</em></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="944e" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">我最明确的观点</h1><p id="ed6a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><code class="fe mb mc md me b">interface</code> <strong class="ky ir">描述了一组数据结构，</strong> <code class="fe mb mc md me b">type</code> <strong class="ky ir">描述了一种类型关系。</strong></p><h1 id="ffe2" class="ms mt iq bd mu mv np mx my mz nq nb nc jw nr jx ne jz ns ka ng kc nt kd ni nj bi translated">接口和类型能做什么？</h1><h2 id="90a8" class="nu mt iq bd mu nv nw dn my nx ny dp nc lf nz oa ne lj ob oc ng ln od oe ni of bi translated">1.可以声明一个对象或函数:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="e909" class="nu mt iq bd mu nv nw dn my nx ny dp nc lf nz oa ne lj ob oc ng ln od oe ni of bi translated">2.<strong class="ak">可以扩展现有类型</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="1c10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe mb mc md me b">interface</code>使用extends关键字来集成<code class="fe mb mc md me b">IUserInfo</code>的类型，类型使用cross-type的类型来集成<code class="fe mb mc md me b">IUserInfo</code>。两者的实现方式不同，但效果是一样的。</p><h2 id="51e1" class="nu mt iq bd mu nv nw dn my nx ny dp nc lf nz oa ne lj ob oc ng ln od oe ni of bi translated">3.<strong class="ak">可以用</strong> <a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">通用</strong> </a></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="59fc" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">界面能做到，但类型不能</h1><p id="cd63" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><code class="fe mb mc md me b"><strong class="ky ir">interface </strong></code> <strong class="ky ir">可以组合重复申报</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The interface can combine duplicate declarations</figcaption></figure><p id="c14a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">用</strong> <code class="fe mb mc md me b"><strong class="ky ir">type</strong></code> <strong class="ky ir">声明重复类型会产生错误</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/ef2d1aeb3b0aa972c1eb7d6593c542fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZ0glMS4DXVFemoLmzd9qA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Declare a duplicate type using the type keyword</figcaption></figure><h1 id="7043" class="ms mt iq bd mu mv np mx my mz nq nb nc jw nr jx ne jz ns ka ng kc nt kd ni nj bi translated">类型可以，但接口不行</h1><ol class=""><li id="a283" class="ls lt iq ky b kz nk lc nl lf oj lj ok ln ol lr om ly lz ma bi translated">使用<code class="fe mb mc md me b">type</code>声明类型别名(一个非常好的技术)想象一个场景，假设后端返回一个产品信息的接口，<code class="fe mb mc md me b">interface</code>包含5个字段，假设它们是这样的:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/51b005da30035237b194ac5177ed3f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*8wqGOBwZOQvQtFmanOihUA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Field information returned from the backend interface</figcaption></figure><p id="a7cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来不错，但是我们在编码过程中不能完全信任后端返回的字段类型，<strong class="ky ir">因为对象内部的一个字段可能是</strong> <code class="fe mb mc md me b"><strong class="ky ir">null</strong></code> <strong class="ky ir">，对象也可能是</strong> <code class="fe mb mc md me b"><strong class="ky ir">null</strong></code>，所以我们需要使用一个类型工具来约束类型，但是<code class="fe mb mc md me b">interface</code>做不到。这个时候，<code class="fe mb mc md me b">type</code>就有了很大的作用。让我们看一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="093c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面使用了<code class="fe mb mc md me b">type</code>关键字来声明一个<code class="fe mb mc md me b">MakeTypeAppendNull </code>类型工具，以帮助我们在出现在线问题时控制类型</p><p id="64e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个工具类型不能用<code class="fe mb mc md me b">interface</code>声明，因为TypeScript会有莫名其妙的错误信息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/2c51ea5862de037bafd9601916d41e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*nfjjA4ibRWZq1FV5dYal-A.png"/></div></div></figure><p id="3c50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.通过利用TypeScript提供的各种概念，<code class="fe mb mc md me b">type</code>关键字可以做任何事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="c1b7" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">那么，什么时候使用接口或者类型呢？</h1><ul class=""><li id="71fe" class="ls lt iq ky b kz nk lc nl lf oj lj ok ln ol lr lx ly lz ma bi translated">当声明后端返回的字段类型时，<strong class="ky ir">使用</strong> <code class="fe mb mc md me b">interface</code></li><li id="5400" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><strong class="ky ir">在React/Vue.js/Angular等前端框架中传递属性声明类型时使用接口</strong></li><li id="526d" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">当声明公用事业类型时，<strong class="ky ir">使用</strong> <code class="fe mb mc md me b">type</code></li><li id="5f03" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><strong class="ky ir">使用<em class="mk"> TypeScript </em>内置类型时，如ReturnType、Pick、Omit、Required等，可以考虑使用</strong> <code class="fe mb mc md me b">type</code> <strong class="ky ir"> </strong>。</li><li id="e396" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">写主类型时(类似ES6中抽象类的概念)用<code class="fe mb mc md me b">interface</code>，辅助类型<strong class="ky ir">用</strong> <code class="fe mb mc md me b">type</code>。</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="0752" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">实际场景—在React类型脚本环境中</h1><p id="1d70" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">这个场景是从定义后端字段的类型到使用<code class="fe mb mc md me b">type</code>关键字定义一个基本类型，然后在React环境中使用，然后渲染DOM。<code class="fe mb mc md me b">interface</code>和<code class="fe mb mc md me b">type</code>的确切用法。</p><p id="5b1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，得到一个如下图所示的文件夹结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/858edaa16c1bb5ba0723f83afc6e8539.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*X6WXZseWFTQQRq3debBkqA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Basic file</figcaption></figure><p id="9051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们在types文件夹中定义该URL返回的字段信息的类型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ab8a61ad48e10c6109b7dc5c428d0948.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*R9UfR9erFnvb8-DdPPelpg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Suppose this information is returned by the backend</figcaption></figure><p id="acb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在类型文件夹中创建新的<em class="mk"> userInfo.ts </em>和<code class="fe mb mc md me b">globalTools.d.ts</code>。这里我们用<code class="fe mb mc md me b">interface</code>定义数据的基本类型，用type关键字对原始类型进行两次扩展。这类似于在JavaScript LOL中复制对对象的引用:)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/0bb1f57d8fea19d7db541519e8657576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8YSyDfr5XIN0uKSmkVmBA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Declare return type</figcaption></figure><p id="030e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在<code class="fe mb mc md me b">services </code>文件夹中，通过axios定义一个函数，帮助我们以标准化的方式获取后端返回的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/f96beb306c90ba552f876ca9a2062607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyGw_qbBthqsaKE8RdvwFQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Define a function to fetch data</figcaption></figure><p id="71c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在<code class="fe mb mc md me b">User.tsx</code>文件中写具体的逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="6709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干得好！相信你已经学会了如何在项目中正确使用<code class="fe mb mc md me b">interface</code>和<code class="fe mb mc md me b">type</code>，然后开始在你的团队中改造项目！</p><h1 id="d262" class="ms mt iq bd mu mv np mx my mz nq nb nc jw nr jx ne jz ns ka ng kc nt kd ni nj bi translated">结论</h1><p id="77d1" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">本文首先讨论了使用<code class="fe mb mc md me b">interface and type</code>的各种方式，然后解释了它们的异同，并通过一个文字工具说明了文字的威力。最后，结合现代前端框架，深入了解<code class="fe mb mc md me b"> interface and type</code>。具体使用场景，希望你工作愉快！</p><p id="6b2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mk">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mk">说白了就是io </em> </strong> </a> <em class="mk">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mk">免费周报</em> </strong> </a> <em class="mk">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mk">Twitter</em></strong></a><em class="mk">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mk">LinkedIn</em></strong></a><em class="mk">。加入我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mk">社区</em> </strong> </a> <em class="mk">。</em></p></div></div>    
</body>
</html>