<html>
<head>
<title>Angular: Ways and Places you can provide Services and the impact it has on the Singleton Status of Services -Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:您可以提供服务的方式和位置，以及它对服务的单体状态的影响——第三部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-ways-and-places-you-can-provide-services-and-the-impact-it-has-on-the-singleton-status-of-4b79a5c6231c?source=collection_archive---------7-----------------------#2022-11-29">https://javascript.plainenglish.io/angular-ways-and-places-you-can-provide-services-and-the-impact-it-has-on-the-singleton-status-of-4b79a5c6231c?source=collection_archive---------7-----------------------#2022-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cc78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是3部分系列的最后一部分。这个故事关注的是如何在延迟加载的特性模块中提供服务，以及它如何影响创建的服务实例的数量。</p><p id="a9af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你对同一个主题更感兴趣，但是对一个<strong class="jm io"> AppModule </strong>更感兴趣，你可以看看下面的故事。</p><div class="ki kj gp gr kk kl"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-different-ways-and-places-you-can-provide-services-and-their-impact-on-the-singleton-81fc2fe538bf"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">Angular:你可以提供服务的不同方式和地点以及它们对单身者的影响…</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">缺省情况下，Angular中的服务是单例的。就这样结束了吗？不完全是。大多数时候，我们唯一的两个地方…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div><p id="ba07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于<strong class="jm io">急切加载的功能模块</strong>你可以查看下面的故事。</p><div class="ki kj gp gr kk kl"><a href="https://ramya-bala221190.medium.com/angular-different-ways-and-places-you-can-provide-services-and-its-impact-on-singleton-status-of-1e9330c60744" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">Angular:你可以提供服务的不同方式和地点及其对单身状态的影响…</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">这个故事只关注在一个加载功能模块中提供服务。如果你有兴趣探索…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">ramya-bala221190.medium.com</p></div></div><div class="ku l"><div class="lb l kw kx ky ku kz la kl"/></div></div></a></div><p id="07ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经创建了一个带有一个名为<strong class="jm io"> LazyModule </strong>的延迟加载功能模块的项目。该模块有3个组件:<strong class="jm io"> ParentComponent、ChildComponent和SiblingComponent </strong>。</p><p id="082d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顾名思义，ChildComponent是ParentComponent的子级，SiblingComponent是ParentComponent的同级。</p><p id="8362" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们只有一项服务<strong class="jm io">数据服务</strong>。</p><p id="bfbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是<strong class="jm io"> AppModule @NgModule()定义</strong>。</p><pre class="lc ld le lf gt lg lh li bn lj lk bi"><span id="67ee" class="ll lm in lh b be ln lo l lp lq">export const routes: Routes = [<br/>{<br/>path: ‘lazy’,<br/>loadChildren: ‘./lazy/lazy.module#LazyModule’,<br/>},<br/>];<br/><br/>@NgModule({<br/>imports: [BrowserModule, FormsModule, RouterModule.forRoot(routes)],<br/>declarations: [AppComponent],<br/>bootstrap: [AppComponent],<br/>providers: [DataService],<br/>})<br/><br/>export class AppModule {}</span></pre><p id="f78f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经编写了加载<strong class="jm io"> LazyModule </strong>的路径。</p><p id="8343" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经将<strong class="jm io">数据服务</strong>添加到NgModule的<strong class="jm io">【providers】</strong>中。提供服务不会创建服务的实例。只有当服务被注入到需要它的类的构造函数中时，才会创建实例。</p><p id="2724" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这意味着每当DataService被注入到应用程序中任何类的构造函数中时，DataService的同一个实例将对所有其他类可用。</strong></p><p id="e08e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种说法确实有例外。我们很快就会看到这一点。</p><p id="2f67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">移动到<strong class="jm io"> LazyModule @NgModule()定义</strong>。</p><pre class="lc ld le lf gt lg lh li bn lj lk bi"><span id="e639" class="ll lm in lh b be ln lo l lp lq">export const routes: Routes = [<br/>{<br/>path: ‘’,<br/>component: ParentComponent,<br/>},<br/>{<br/>path: ‘sibling’,<br/>component: SiblingComponent,<br/>}<br/>];<br/><br/>@NgModule({<br/>imports: [CommonModule, RouterModule.forChild(routes)],<br/>declarations: [ParentComponent, ChildComponent, SiblingComponent],<br/>providers: [DataService],<br/>})<br/><br/>export class LazyModule {}</span></pre><p id="a43e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当<strong class="jm io"> LazyModule </strong>加载时，正如你从上面的Route定义中所猜测的，默认情况下，ParentComponent及其子ChildComponent将被加载。</p><p id="09b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还在LazyModule级别通过<strong class="jm io">【providers】</strong>提供了数据服务。</p><p id="7f33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是数据服务的样子。我们已经创建了一个属性<strong class="jm io"> randomNum </strong>来保存一个随机数。<strong class="jm io"> fetchNumber() </strong>返回这个随机生成的数字。</p><pre class="lc ld le lf gt lg lh li bn lj lk bi"><span id="bb02" class="ll lm in lh b be ln lo l lp lq">@Injectable()<br/>export class DataService {<br/>constructor() {}<br/><br/>public randomNum: number = Math.floor(Math.random() * 100);<br/><br/>fetchNumber() {<br/>return this.randomNum;<br/>}<br/>}</span></pre><p id="f846" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果数据服务的<strong class="jm io">同一个实例被注入到所有的类中，那么所有的类都必须接收到<strong class="jm io">同一个随机数</strong>。</strong></p><p id="b4d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转到组件，所有组件类都是彼此的精确副本。</p><p id="8628" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我只展示一下<strong class="jm io"> AppComponent类</strong>。我们调用了数据服务的<strong class="jm io"> fetchNumber() </strong>来获取生成的随机数。这个随机数将显示在模板中。</p><p id="d411" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其他组件类将遵循相同的模式。</p><pre class="lc ld le lf gt lg lh li bn lj lk bi"><span id="7ee6" class="ll lm in lh b be ln lo l lp lq">@Component({<br/>selector: ‘my-app’,<br/>templateUrl: ‘./app.component.html’,<br/>styleUrls: [ ‘./app.component.css’ ]<br/>})<br/><br/>export class AppComponent {<br/>constructor(private service: DataService) {}<br/>public randomNumber: number;<br/><br/>ngOnInit() {<br/>this.randomNumber = this.service.fetchNumber();<br/>}<br/>}</span></pre><p id="c66e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就组件模板而言，</p><p id="fba9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">LazyModule的组件将被加载到AppComponent的<strong class="jm io"> &lt; router-outlet &gt; </strong>中。</p><p id="5ecc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ChildComponent通过引用承载在ParentComponent内部。</p><p id="4d62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是这个应用程序现在的样子。如您所见，AppComponent从DataService接收到了一个随机数。现在让我们加载LazyModule来检查Parent、Child和SiblingComponent收到的随机数。</p><figure class="lc ld le lf gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lr"><img src="../Images/fc4eb78f9bbc41a6a7976943d0a05b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LkcR9eym39F5ElamTlnc2g.png"/></div></div></figure><p id="6a9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击<strong class="jm io">“Load Lazy Module”</strong>链接将加载&lt; router-outlet &gt;中的<strong class="jm io"> LazyModule </strong>，如下所示。默认情况下，当模块加载时，ParentComponent及其子ChildComponent已经加载。</p><figure class="lc ld le lf gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ly"><img src="../Images/7570210f3fd6729c57b04ba07fbba9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NUquKSd7-4Ilyt12SCwtw.png"/></div></div></figure><p id="4be2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Parent和ChildComponent收到了与AppComponent不同的随机数。</p><p id="0b2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SiblingComponent呢？点击<strong class="jm io">“切换到同级”</strong>链接将加载&lt;路由器出口&gt;中的SiblingComponent。如下所示，SiblingComponent也收到了与Parent和ChildComponent相同的随机数。</p><figure class="lc ld le lf gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lz"><img src="../Images/2bc4b3251349d285661f499e67d5107b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S62A4ra9qM-yT2fDjKn0PA.png"/></div></div></figure><p id="deb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过观察，我们得出结论,<strong class="jm io"> AppComponent使用的DataService实例不同于LazyModule组件使用的DataService实例。</strong></p><p id="663f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一个出现的问题是，为什么实例是不同的？</p><p id="3c87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">AppModule和LazyModule都提供数据服务。AppModule与<strong class="jm io"> RootModuleInjector </strong>相关联。</p><p id="993d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当路由器延迟加载一个特征模块时，<strong class="jm io">它创建一个新的执行上下文，它有自己的注入器，并且这个注入器是RootModuleInjector </strong>的子。</p><p id="57b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">路由器还将LazyModule的提供者及其导入的NgModules的提供者添加到这个子注入器。</strong></p><p id="bcc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于AppModule和LazyModule使用不同的注入器，它们将产生不同的DataService实例。</p><p id="b65f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于实例不同，由数据服务提供的随机数的值也将不同。</p><p id="b8ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我稍微调整一下ParentComponent，这样<strong class="jm io">也可以提供数据服务</strong>。</p><pre class="lc ld le lf gt lg lh li bn lj lk bi"><span id="09ae" class="ll lm in lh b be ln lo l lp lq">@Component({<br/>selector: ‘app-parent’,<br/>templateUrl: ‘./parent.component.html’,<br/>styleUrls: [‘./parent.component.css’],<br/>providers:[DataService]<br/>})<br/><br/>export class ParentComponent implements OnInit {<br/>/*<br/>Nothing changes here. The code remains the same.<br/>*/<br/>}</span></pre><p id="6384" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在请注意，AppModule、LazyModule和ParentComponent提供数据服务。</p><p id="ff09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应用程序现在看起来是这样的。</p><figure class="lc ld le lf gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ma"><img src="../Images/6cb9557286881f17a1ed2fb384cbf974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcAibeDU0ofUp67kfZZvAg.png"/></div></div></figure><figure class="lc ld le lf gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mb"><img src="../Images/d47842059bf93aa6a6df5d12b389ab07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9Xh9ohWF8BWT40VkbNTxA.png"/></div></div></figure><p id="06d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只有父组件和子组件接收的随机数匹配。但这次它们与SiblingComponent不同。SiblingComponent收到了不同的随机数。</p><p id="9275" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么，<strong class="jm io">即使这3个组件属于同一个特征模块，兄弟组件从父组件和子组件接收到不同的随机数？</strong></p><ol class=""><li id="344c" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated">当我将DataService注入到AppComponent的构造函数中时，DI系统将检查服务实例对于与AppComponent关联的注入器是否可用。</li></ol><p id="ccc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于DataService不是在AppComponent级别提供的，并且由于AppComponent没有任何父级，DI系统将使用与<strong class="jm io"> AppModule </strong>相关联的<strong class="jm io"> RootModuleInjector </strong>来检查服务实例是否可用。</p><p id="6eeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在AppModule 的【providers】中提供了<strong class="jm io">数据服务。因此，DI系统可以使用<strong class="jm io"> RootModuleInjector </strong>找到服务实例。</strong></p><p id="79fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.当我将DataService注入到<strong class="jm io"> SiblingComponent </strong>的构造函数中时，DI系统将检查服务实例是否可以使用与SiblingComponent关联的注入器。</p><p id="27cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要！<strong class="jm io">在SiblingComponent级别没有提供数据服务</strong>。因此，DI系统向上移动一个级别，并且<strong class="jm io">检查与SiblingComponent(即AppComponent)的父组件相关联的注入器。</strong></p><p id="f21f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">在AppComponent级别没有提供data service</strong>，由于AppComponent没有任何父级，DI系统将在模块级别开始检查。</p><p id="0901" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它首先<strong class="jm io">检查数据服务是否在LazyModule级别</strong>提供。是的，它提供了！但是我们已经知道，LazyModule和AppModule与不同的注入器相关联。</p><p id="0949" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，与LazyModule关联的注入器将为SiblingComponent创建一个新的DataService实例。这解释了为什么AppComponent和SiblingComponent收到了不同的随机数。</p><p id="eec0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.当我将DataService注入到<strong class="jm io"> ParentComponent </strong>的构造函数中时，DI系统将检查服务实例是否可以使用与<strong class="jm io"> ParentComponent </strong>关联的注入器。</p><p id="54c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，它是可用的！正如我们前面看到的，<strong class="jm io"> DataService是通过ParentComponent </strong>中的【providers】提供的。因此与ParentComponent关联的<strong class="jm io">注入器将创建一个新的DataService实例。</strong></p><p id="b0b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这解释了为什么ParentComponent收到的随机数不同于AppComponent和SiblingComponent。</p><p id="73e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.当我将DataService注入到<strong class="jm io">子组件</strong>的构造函数中时，DI系统将检查服务实例是否可以使用与<strong class="jm io">子组件</strong>关联的注入器。</p><p id="fab7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不，它不可用！因此，DI系统向上移动一个级别，并且<strong class="jm io">检查实例是否可用于与子组件的父组件(即ParentComponent)相关联的注入器。</strong></p><p id="e629" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，它是可用的！DataService通过ParentComponent中的[providers]提供。因为与ParentComponent关联的injector已经创建了一个DataService实例，所以它不会再创建另一个实例。DI系统为ChildComponent重用相同的DataService实例。</p><p id="65cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这解释了为什么ParentComponent和ChildComponent从DataService接收到相同的随机数。</p><p id="8c1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子的最后，我们有3个<strong class="jm io">数据服务</strong>的实例，</p><p id="c6e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;一个是在AppModule级别创建的。</p><p id="8dd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;秒是在LazyModule级别创建的。</p><p id="2291" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;第三个在ParentComponent级别创建。</p><p id="ffe2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在下面找到完整的工作示例。</p><div class="ki kj gp gr kk kl"><a href="https://stackblitz.com/edit/angular-tgqjjv?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">角形(叉形)堆叠</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">stackblitz.com</p></div></div><div class="ku l"><div class="ml l kw kx ky ku kz la kl"/></div></div></a></div><p id="0a97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mm">更多内容看</em> <a class="ae mn" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">说白了就是</em> </strong> </a> <em class="mm">。报名参加我们的</em> <a class="ae mn" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">免费周报</em> </strong> </a> <em class="mm">。关注我们关于</em> <a class="ae mn" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">推特</em> </strong> </a>，<a class="ae mn" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">领英</em> </strong> </a> <strong class="jm io"> <em class="mm">，</em></strong><a class="ae mn" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mm">YouTube</em></strong></a><strong class="jm io"><em class="mm">，</em> </strong> <em class="mm">和</em><strong class="jm io"><em class="mm">不和</em> </strong>   <em class="mm">对成长黑客感兴趣？检查出</em> <a class="ae mn" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">电路</em> </strong> </a> <strong class="jm io"> <em class="mm">。</em>T71】</strong></p></div></div>    
</body>
</html>