<html>
<head>
<title>Build a Custom Theme Provider Using React’s Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React的上下文API构建自定义主题提供程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-custom-theme-provider-using-reacts-context-api-4e10de8eaf43?source=collection_archive---------1-----------------------#2022-04-03">https://javascript.plainenglish.io/building-a-custom-theme-provider-using-reacts-context-api-4e10de8eaf43?source=collection_archive---------1-----------------------#2022-04-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c6bf" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在React应用中添加对切换主题的支持——没有库，从零开始，以简单的方式。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/032dad4fe361f8c421dd799888728b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yc0Ir55gOZGLnngfXAxubA.png"/></div></div></figure><p id="c5a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">老实说，在任何应用程序中，主题都是一个非常好的小特性。以VS代码甚至GitHub为例。他们给用户自由，按照用户想要的方式定制应用程序。你想要黑暗主题吗？好吧！哦不，我想要一个高对比度的主题…好吧，你有了！尽管有不同的主题可供选择很有趣，但这个小特性实际上是一个至关重要的可访问性特性。对吗？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/af527927107d806a03584390207fafc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*A6qRw3SPT_9ENcqPYludmA.gif"/></div></div></figure><p id="faab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在开始向我们的React应用程序添加替代主题之前，我想指出的是，尽管有各种各样的库(如MUI和Antd)可用于添加主题，但了解如何从头开始总是一个好主意。</p><p id="ddeb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">和往常一样，您可以在支持的GitHub资源库中找到本文的完整代码:</p><div class="ll lm gp gr ln lo"><a href="https://github.com/the-devdesigner/react-themes" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">GitHub-the-dev designer/react-themes:构建主题提供程序并为React添加主题支持…</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">构建主题提供程序，并向React应用程序添加主题支持，无需任何外部库。支持存储库…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc km lo"/></div></div></a></div></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="949a" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">在引擎盖下寻找🔍</h1><p id="d486" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">无论如何，主题在任何应用程序中实际上是如何工作的？不是整体的深入工作而是高水平的？为了使事情非常非常简单，让我们假设我们的应用程序只是一个简单的<code class="fe nh ni nj nk b">index.html</code>页面，只有一个<code class="fe nh ni nj nk b">style.css</code>样式表。加载页面时，样式表也会加载，并带有所有预定义的样式和属性。现在，我决定将主题改为更暗的版本(灯光主题是默认的)，这意味着我以某种方式将所有的灯光颜色改为更暗的颜色——动态地。只要页面没有刷新，我就有我的黑暗主题。</p><h1 id="bcde" class="mk ml in bd mm mn nl mp mq mr nm mt mu jt nn ju mw jw no jx my jz np ka na nb bi translated">让我们进一步简化💁‍♂️</h1><ol class=""><li id="96bf" class="nq nr in kq b kr nc ku nd kx ns lb nt lf nu lj nv nw nx ny bi translated">我们知道，在页面刷新时，我们会丢失我们的黑暗主题，这意味着应该有一些适当的状态管理，对吗？毕竟，我们的应用程序必须不断地知道用户将主题从亮/默认改为暗。</li><li id="401f" class="nq nr in kq b kr nz ku oa kx ob lb oc lf od lj nv nw nx ny bi translated">那么我们也必须有某种方式来提供这种输入——一个按钮或一个开关。</li><li id="5027" class="nq nr in kq b kr nz ku oa kx ob lb oc lf od lj nv nw nx ny bi translated">而且肯定的是，CSS是为黑暗版本定义的。</li></ol><h1 id="1678" class="mk ml in bd mm mn nl mp mq mr nm mt mu jt nn ju mw jw no jx my jz np ka na nb bi translated">设置我们的项目💻</h1><ol class=""><li id="9900" class="nq nr in kq b kr nc ku nd kx ns lb nt lf nu lj nv nw nx ny bi translated">要开始，我们需要一个React应用程序。我使用TS和react，所以我将运行<code class="fe nh ni nj nk b">npx create-react-app &lt;app-name&gt; --template typescript</code>来获得一个基本的React应用程序和类型脚本。如果不使用TS，运行相同的命令；只需移除<code class="fe nh ni nj nk b">--template typescript</code>。</li><li id="1f71" class="nq nr in kq b kr nz ku oa kx ob lb oc lf od lj nv nw nx ny bi translated">一旦基本的应用程序完成，如果你愿意，继续清理你的项目目录——删除不需要的文件，切换到ES6方式定义组件(这是我更喜欢做的)。</li><li id="2355" class="nq nr in kq b kr nz ku oa kx ob lb oc lf od lj nv nw nx ny bi translated">我们最常使用的两个默认文件是<code class="fe nh ni nj nk b">App.tsx</code>和<code class="fe nh ni nj nk b">App.css</code>。</li><li id="b04b" class="nq nr in kq b kr nz ku oa kx ob lb oc lf od lj nv nw nx ny bi translated">为了管理全局主题状态(姑且称之为全局主题状态)，我们将使用React附带的上下文API。我们稍后将为此创建一个<code class="fe nh ni nj nk b">ThemeContext.tsx</code>。关于是否应该使用上下文，可能会有不同意见。对我来说，它是React中状态管理的上下文。</li></ol><h1 id="be43" class="mk ml in bd mm mn nl mp mq mr nm mt mu jt nn ju mw jw no jx my jz np ka na nb bi translated">编码时间到了🚀</h1><p id="6df4" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">为了简单起见，我们将从在我们的<code class="fe nh ni nj nk b">App.tsx</code>文件中添加一个<code class="fe nh ni nj nk b">Button</code>开始，它也将是我们用来在亮(默认)和暗主题之间切换的按钮。</p><h1 id="1021" class="mk ml in bd mm mn nl mp mq mr nm mt mu jt nn ju mw jw no jx my jz np ka na nb bi translated">ThemeContext.tsx</h1><p id="e164" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">让我们首先创建ThemeContext，然后在应用程序中使用它。这里我们声明<code class="fe nh ni nj nk b">isDarkTheme</code>状态，默认设置为<code class="fe nh ni nj nk b">false</code>。然后我们有一个<code class="fe nh ni nj nk b">toggleTheme()</code>函数，它本质上翻转了<code class="fe nh ni nj nk b">isDarkTheme</code>标志的值。这个状态将负责应用程序中所有主题相关的魔法，因为所有相关的css都将基于它被应用/删除。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/ee8e038334c2d3898421275e1d6e6008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvLyn1tbrY8Kr-GbNx89gw.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk"><strong class="bd ok">ThemeContext.tsx</strong> — global state management for theme using React’s Context API</figcaption></figure><h1 id="1ecb" class="mk ml in bd mm mn nl mp mq mr nm mt mu jt nn ju mw jw no jx my jz np ka na nb bi translated">index.tsx</h1><p id="3a86" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">要使用我们的<code class="fe nh ni nj nk b">isDarkTheme</code>标志和<code class="fe nh ni nj nk b">toggleTheme()</code>函数，我们必须首先用<code class="fe nh ni nj nk b">ThemeProvider</code>组件包装<code class="fe nh ni nj nk b">App</code>组件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/f773cb58fc2a00545beaf43218053cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fst9UpwTZQf2-sdrT-KMg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk"><strong class="bd ok">index.tsx</strong> — Wrapping the highest component with <strong class="bd ok">ThemeProvider</strong></figcaption></figure><h1 id="eb40" class="mk ml in bd mm mn nl mp mq mr nm mt mu jt nn ju mw jw no jx my jz np ka na nb bi translated">App.tsx</h1><p id="c3b4" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">现在我们引入了<code class="fe nh ni nj nk b">useContext</code>钩子，并将<code class="fe nh ni nj nk b">ThemeContext</code>作为参数传递给钩子，以使用我们的全局状态变量。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/1427175399ca141427e7adc3d256ed52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RH3W0TJ6I4RebDbw.png"/></div><figcaption class="og oh gj gh gi oi oj bd b be z dk">App.tsx — simple setup, a button with dynamic label</figcaption></figure><h1 id="a8df" class="mk ml in bd mm mn nl mp mq mr nm mt mu jt nn ju mw jw no jx my jz np ka na nb bi translated">App.css</h1><p id="b025" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">最后一步，为明暗模式添加样式。默认情况下，灯光主题将被加载，一旦我们将<code class="fe nh ni nj nk b">isDarkMode</code>改为<code class="fe nh ni nj nk b">true</code>，黑暗模式CSS将覆盖默认值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/794d7425374dbf1e9699961b64fa85a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIbRtmvPFaTLAgYPtJ3V1g.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk"><strong class="bd ok">App.css</strong> — chaining .dark class to .app and .button class overrides values on theme mode change.</figcaption></figure><h1 id="fad4" class="mk ml in bd mm mn nl mp mq mr nm mt mu jt nn ju mw jw no jx my jz np ka na nb bi translated">决赛成绩</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/074a51fdd310e6907ae67ddc616fb18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w9PfF5-0aKD8G8bu.gif"/></div></div></figure><p id="c97d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">即使这是一个相当简单的例子，添加主题也不过如此。我们所要做的就是根据用户选择的主题，以某种方式与整个应用程序沟通，告诉它哪个CSS(或CSS的一部分)必须被加载和修改。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="b09a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你希望看到这个实现的完整项目，你可以看看我的投资组合—<a class="ae on" href="https://www.thedevdesigner.com" rel="noopener ugc nofollow" target="_blank">https://www.thedevdesigner.com</a>我用完全相同的方法添加主题。</p><p id="1376" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您喜欢这个项目并觉得它很有趣，请务必查看我的其他文章，在这些文章中，我讨论了React、TypeScript和Node.js。</p><blockquote class="oo"><p id="dde5" class="op oq in bd or os ot ou ov ow ox lj dk translated">结束！再次感谢！</p></blockquote><h2 id="5d63" class="oy ml in bd mm oz pa dn mq pb pc dp mu kx pd pe mw lb pf pg my lf ph pi na pj bi translated">进一步阅读</h2><div class="ll lm gp gr ln lo"><a href="https://bit.cloud/blog/theming-in-components-with-react-and-bit-l386casw" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">使用React和Bit在组件中进行主题化</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">工程和设计团队面临的一个大的组织问题是分离外观和感觉…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">比特云</p></div></div><div class="lx l"><div class="pk l lz ma mb lx mc km lo"/></div></div></a></div><p id="3d33" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="oe">更多内容请看</em><a class="ae on" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="oe">plain English . io</em></strong></a><em class="oe">。报名参加我们的</em> <a class="ae on" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="oe">免费周报</em> </strong> </a> <em class="oe">。关注我们关于</em><a class="ae on" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="oe">Twitter</em></strong></a><a class="ae on" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="oe">LinkedIn</em></strong></a><strong class="kq io"><em class="oe"/></strong><a class="ae on" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="oe">YouTube</em></strong></a><strong class="kq io"><em class="oe">，以及</em></strong><em class="oe"/><a class="ae on" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="oe">不和</em> </strong> </a>  <em class="oe">对成长黑客感兴趣？检查</em> <a class="ae on" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="oe">电路</em> </strong> </a> <strong class="kq io"> <em class="oe">。</em> </strong></p></div></div>    
</body>
</html>