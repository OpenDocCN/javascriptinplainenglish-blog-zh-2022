<html>
<head>
<title>Using the Reflection and Reflection Metadata APIs with TypeScript Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将反射和反射元数据API与TypeScript装饰器一起使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7?source=collection_archive---------7-----------------------#2022-03-02">https://javascript.plainenglish.io/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7?source=collection_archive---------7-----------------------#2022-03-02</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="1cad" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">将反射API和装饰者结合起来给了我们一个强大的组合</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/4747121dc8fe18e86d995ed390618144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yUYQpPzd3kBwt9HJ.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Image by Author using logos from respective projects</figcaption></figure><p id="3b8b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><strong class="ky is">充分利用TypeScript decorators需要了解反射和反射元数据API。后者允许您将数据存储在对象元数据中，以便decorators可以一起工作来创建复杂的行为。</strong></p><p id="aea5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在软件开发中，反射是代码在执行时审视自身、检查或自省其数据结构以及修改其自身结构和行为的能力。但是，这是很多大话，没有足够的实际理解基础。</p><p id="f90d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文试图对在TypeScript中使用反射和反射元数据API以及TypeScript装饰器做一个合理的基础介绍。换句话说，我们会接触一些代码，这样我们就能理解那些大词的意思。这里的许多内容在普通JavaScript中也很有用。</p><p id="9b9a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">JavaScript反射API已经存在好几年了，最早出现在6.0版本的Node.js中，我们大多数人可能都没有用过，可能也不知道这些API。但是反射和反射元数据扩展对于实现TypeScript decorators以及其他用途非常有用。</p><p id="6ab5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">核心反射API侧重于检查JavaScript对象的属性和其他方面的数据。Mozilla文档描述它为可拦截的JavaScript操作提供了<em class="ls">方法，这是更大的词，对我们的理解没有帮助。</em></p><ul class=""><li id="95a3" class="lt lu ir ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">文档:</li></ul><div class="mc md gq gs me mf"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fp"><div class="mh ab mi cl cj mj"><h2 class="bd is gz z fq mk fs ft ml fv fx iq bi translated">Reflect - JavaScript | MDN</h2><div class="mm l"><h3 class="bd b gz z fq mk fs ft ml fv fx dk translated">是一个内置对象，为可拦截的JavaScript操作提供方法。方法和那些一样…</h3></div><div class="mn l"><p class="bd b dl z fq mk fs ft ml fv fx dk translated">developer.mozilla.org</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt kq mf"/></div></div></a></div><p id="c847" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">反射API的方法被附加到<code class="fe mu mv mw mx b">Reflect</code>对象上。那个对象就在那里，你不用做任何特别的事情来让它存在。它没有构造函数，只是简单地存在，它包含静态函数(方法),可以在代码中使用这些函数来做与上面显示的大词相关的事情。也就是说，核心反射API允许代码检索关于对象的数据，并操纵数据或对象结构。</p><p id="47c8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">反射元数据API是对反射API的一个提议的补充，增加了额外的元数据功能。这意味着它与装饰者的提议紧密相关，并且在装饰者标准化之后，它将被标准化。</p><ul class=""><li id="f5f3" class="lt lu ir ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">文档:</li></ul><div class="mc md gq gs me mf"><a href="https://github.com/rbuckton/reflect-metadata" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fp"><div class="mh ab mi cl cj mj"><h2 class="bd is gz z fq mk fs ft ml fv fx iq bi translated">GitHub-rbuckton/reflect-Metadata:ECMAScript元数据反射API的原型</h2><div class="mm l"><h3 class="bd b gz z fq mk fs ft ml fv fx dk translated">ECMAScript的元数据反射API的原型</h3></div><div class="mn l"><p class="bd b dl z fq mk fs ft ml fv fx dk translated">github.com</p></div></div><div class="mo l"><div class="my l mq mr ms mo mt kq mf"/></div></div></a></div><p id="e7c3" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">使用这个API需要一点小小的设置。首先安装<code class="fe mu mv mw mx b">reflect-metadata</code>包，然后在代码中放入<code class="fe mu mv mw mx b">import 'reflect-metadata'</code>。该包包含将元数据API添加到反射对象的polyfill。</p><p id="a8c4" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文是系列文章的一部分:</p><ul class=""><li id="6e25" class="lt lu ir ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">装修工入门</a></li><li id="cdb2" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><a class="ae mz" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装修工</a></li><li id="d081" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">物业装修工</a></li><li id="eed8" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">访问器装饰器</a></li><li id="1e44" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-parameter-decorators-in-typescript-b0042b5474ed">参数装饰器</a></li><li id="a553" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">方法装饰者</a></li><li id="1890" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0">混合装修工</a></li><li id="0de1" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><strong class="ky is">使用反射和反射API与装饰者</strong> <em class="ls">本文</em></li><li id="eca9" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5">运行时使用装饰器进行数据验证</a></li></ul><h1 id="4f7b" class="nf ng ir bd nh ni nj nk nl nm nn no np jx nq jy nr ka ns kb nt kd nu ke nv nw bi translated">为TypeScript设置反射元数据API</h1><p id="3158" class="pw-post-body-paragraph kw kx ir ky b kz nx js lb lc ny jv le lf nz lh li lj oa ll lm ln ob lp lq lr ik bi translated">要在TypeScript中启用这些API以及装饰器，请参见<a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">使用和实现TypeScript装饰器的深入介绍</a>中的说明。</p><p id="4b44" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">启用反射元数据API需要安装<code class="fe mu mv mw mx b">reflect-metadata</code>包，如下所示:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="a552" class="og ng ir mx b gz oh oi l oj ok">$ npm install reflect-metadata --save</span></pre><p id="f9e6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">之后，将此代码添加到您的代码中:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="963b" class="og ng ir mx b gz oh oi l oj ok">import "reflect-metadata";</span></pre><p id="1c07" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在您的<code class="fe mu mv mw mx b">tsconfig.json</code>文件中进行这些设置:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="0c31" class="og ng ir mx b gz oh oi l oj ok">{<br/>     "compilerOptions": {<br/>         ...<br/>         "experimentalDecorators": true,<br/>         "emitDecoratorMetadata": true,<br/>         ...<br/>     } <br/>}</span></pre><p id="7128" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">第一个，<code class="fe mu mv mw mx b">experimentalDecorators</code>，打开装饰器支持。第二个是<code class="fe mu mv mw mx b">emitDecoratorMetadata</code>，发出<code class="fe mu mv mw mx b">reflect-metadata</code>包所需的数据。这个包通过记录关于类、属性、方法和参数的元数据，使我们能够在decorators中做强大的事情。</p><h1 id="c06c" class="nf ng ir bd nh ni nj nk nl nm nn no np jx nq jy nr ka ns kb nt kd nu ke nv nw bi translated">使用反射API检索关于JavaScript对象的数据</h1><p id="b10f" class="pw-post-body-paragraph kw kx ir ky b kz nx js lb lc ny jv le lf nz lh li lj oa ll lm ln ob lp lq lr ik bi translated">让我们从使用反射API检索关于对象的数据开始。</p><p id="10c7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要使用的第一个方法是<code class="fe mu mv mw mx b">Reflect.has</code>，让您检查一个对象是否有一个给定名称的属性。要了解这意味着什么，从这个类开始:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="31f9" class="og ng ir mx b gz oh oi l oj ok">class HasExample {<br/>     year: number;<br/>     #privateYear: number;<br/>     #title: string;</span><span id="bde2" class="og ng ir mx b gz ol oi l oj ok">     set title(nt: string) { this.#title = nt; }<br/>     get title() { return this.#title; }</span><span id="0023" class="og ng ir mx b gz ol oi l oj ok">     // set privateYear(ny: number) { this.#privateYear = ny; }<br/>     // get privateYear() { return this.#privateYear; }</span><span id="5033" class="og ng ir mx b gz ol oi l oj ok">     area(x: number, y: number) {<br/>         return x * y;<br/>     }</span><span id="f28a" class="og ng ir mx b gz ol oi l oj ok">     constructor(privateYear: number) {<br/>         this.#privateYear = privateYear;<br/>     } <br/>}</span></pre><p id="1f5c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这个类定义有一些我们可以运行查询的东西。例如，<code class="fe mu mv mw mx b">#title</code>这样的私有字段有一定的访问限制。要测试它，请添加以下代码:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="9fa4" class="og ng ir mx b gz oh oi l oj ok">const hs = new HasExample(2222);<br/>console.log(`year ${Reflect.has(hs, 'year')}`);<br/>hs.year = 2022; <br/>console.log(`year ${Reflect.has(hs, 'year')}`);  <br/>console.log(`privateYear ${Reflect.has(hs, 'privateYear')}`); <br/>console.log(`title ${Reflect.has(hs, 'title')}`); <br/>console.log(`area ${Reflect.has(hs, 'area')}`); <br/>console.log(`xyzzy ${Reflect.has(hs, 'xyzzy')}`);</span></pre><p id="706f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">运行该程序，我们得到以下输出:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="f4f0" class="og ng ir mx b gz oh oi l oj ok">$ npx ts-node lib/reflection/has.ts <br/>year false <br/>year true <br/>privateYear false <br/>title true <br/>area true <br/>xyzzy false</span></pre><p id="1894" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">属性<code class="fe mu mv mw mx b">year</code>开始时不存在，然后一旦我们设置了一个值，它就存在了。我们在探索<a class="ae mz" href="https://techsparx.com/nodejs/typescript/decorators/properties.html" rel="noopener ugc nofollow" target="_blank">属性装饰器</a>时看到了这种行为，我们看到<code class="fe mu mv mw mx b">Object.hasOwnProperty</code>返回<code class="fe mu mv mw mx b">false</code>，直到我们给属性赋值。</p><p id="efb7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于<code class="fe mu mv mw mx b">#privateYear</code>，即使它有一个通过<code class="fe mu mv mw mx b">constructor</code>分配的值，也是一个私有属性，我们根本无法访问。因此，<code class="fe mu mv mw mx b">Reflect.has</code>为该字段返回<code class="fe mu mv mw mx b">false</code>也就不足为奇了。</p><p id="c273" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">接下来，<code class="fe mu mv mw mx b">Reflect.ownKeys</code>用于获取属性名，<code class="fe mu mv mw mx b">Reflect.getOwnPropertyDescriptor</code>用于检索PropertyDescriptor，<code class="fe mu mv mw mx b">Reflect.getPrototypeOf</code>用于检索对象原型。每个parallels方法在<code class="fe mu mv mw mx b">Object</code>中获得相同的数据。将以下代码添加到脚本中:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="2465" class="og ng ir mx b gz oh oi l oj ok">console.log({<br/>     ownKeys: Reflect.ownKeys(hs),<br/>     keys: Object.keys(hs) <br/>});<br/>console.log({<br/>     ownProperty: Reflect.getOwnPropertyDescriptor(hs, "year"),<br/>     objectProperty: Object.getOwnPropertyDescriptor(hs, "year") <br/>});  <br/>console.log({<br/>     ownProperty: Reflect.getOwnPropertyDescriptor(hs, "title"),<br/>     objectProperty: Object.getOwnPropertyDescriptor(hs, "title") <br/>});  <br/>console.log({<br/>     reflectPrototype: Reflect.getPrototypeOf(hs),<br/>     objectPrototype: Object.getPrototypeOf(hs),<br/>     prototype: HasExample.prototype <br/>});</span></pre><p id="5bc6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这显示了某些<code class="fe mu mv mw mx b">Reflect</code>和<code class="fe mu mv mw mx b">Object</code>方法之间的等价性。运行时，我们得到以下输出:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="504d" class="og ng ir mx b gz oh oi l oj ok">{ ownKeys: [ 'year' ], keys: [ 'year' ] } <br/>{<br/>   ownProperty: { value: 2022, writable: true, enumerable: true, configurable: true },<br/>   objectProperty: { value: 2022, writable: true, enumerable: true, configurable: true } <br/>} <br/>{ ownProperty: undefined, objectProperty: undefined } <br/>{ reflectPrototype: {}, objectPrototype: {}, prototype: {} }</span></pre><p id="7d7e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们通过各种途径获得相同的数据。</p><h1 id="b8b4" class="nf ng ir bd nh ni nj nk nl nm nn no np jx nq jy nr ka ns kb nt kd nu ke nv nw bi translated">使用反射定义、获取、设置和删除属性(CRUD)</h1><p id="666c" class="pw-post-body-paragraph kw kx ir ky b kz nx js lb lc ny jv le lf nz lh li lj oa ll lm ln ob lp lq lr ik bi translated">CRUD原则通常适用于使用数据库的应用程序。但是，使用反射方法，我们可以创建属性、读取属性值、更新属性值和删除属性。换句话说，我们可以使用反射对JavaScript对象进行CRUD操作。</p><p id="b7db" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">让我们从这个简单的对象开始，调用一些方法来读取它的初始状态:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="0c0d" class="og ng ir mx b gz oh oi l oj ok">const example = {<br/>     prop1: "property1",<br/>     prop2: 42 <br/>};  <br/>console.log({<br/>     ownKeys: Reflect.ownKeys(example),<br/>     keys: Object.keys(example) <br/>});  <br/>console.log('prop1', Reflect.get(example, 'prop1')); <br/>console.log('prop2', Reflect.get(example, 'prop2')); <br/>console.log(example);</span></pre><p id="fe42" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们已经创建了一个匿名对象，并使用了几种方法来读取对象中属性的键和它们的值。<code class="fe mu mv mw mx b">Reflect.get</code>方法相当于使用<code class="fe mu mv mw mx b">get</code>访问器。</p><p id="a30c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">输出是:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="d7ee" class="og ng ir mx b gz oh oi l oj ok">{ ownKeys: [ 'prop1', 'prop2' ], keys: [ 'prop1', 'prop2' ] } <br/>prop1 property1 <br/>prop2 42 <br/>{ prop1: 'property1', prop2: 42 }</span></pre><p id="ee9b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们明明有<code class="fe mu mv mw mx b">prop1</code>和<code class="fe mu mv mw mx b">prop2</code>，数值都在意料之中。这演示了几种使用反射从对象中读取数据的方法<em class="ls">。</em></p><p id="ce24" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要<em class="ls">创建</em>一个属性，运行这个方法:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="e816" class="og ng ir mx b gz oh oi l oj ok">Reflect.defineProperty(example, 'prop3', {<br/>     value: "Property #3",<br/>     enumerable: true,<br/>     writable: true,<br/>     configurable: true <br/>});</span></pre><p id="0991" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这类似于<code class="fe mu mv mw mx b">Object.defineProperty</code>，用给定的名称和给定的PropertyDescriptor定义对象的属性。在这种情况下，该属性被命名为<code class="fe mu mv mw mx b">prop3</code>，其值显示在描述符中。<code class="fe mu mv mw mx b">writable</code>、<code class="fe mu mv mw mx b">enumerable</code>和<code class="fe mu mv mw mx b">configurable</code>的设置控制其行为。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="a045" class="og ng ir mx b gz oh oi l oj ok">console.log({<br/>     ownKeys: Reflect.ownKeys(example),<br/>     keys: Object.keys(example) <br/>});  <br/>console.log('prop3', Reflect.get(example, 'prop3')); <br/>console.log(example);  console.log(Object.getOwnPropertyDescriptors(example));</span></pre><p id="18ff" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">让我们再次<em class="ls">读取</em>值，并验证该属性确实被创建了:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="a6b1" class="og ng ir mx b gz oh oi l oj ok">{<br/>   ownKeys: [ 'prop1', 'prop2', 'prop3' ],<br/>   keys: [ 'prop1', 'prop2', 'prop3' ] <br/>} <br/>prop3 Property #3 <br/>{ prop1: 'property1', prop2: 42, prop3: 'Property #3' } <br/>{<br/>   prop1: {<br/>     value: 'property1',<br/>     writable: true,<br/>     enumerable: true,<br/>     configurable: true<br/>   },<br/>   prop2: { value: 42, writable: true, enumerable: true, configurable: true },<br/>   prop3: {<br/>     value: 'Property #3',<br/>     writable: true,<br/>     enumerable: true,<br/>     configurable: true<br/>   } <br/>}</span></pre><p id="015e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">它确实存在，显示在属性键和属性描述符中，并带有预期的值。如果<code class="fe mu mv mw mx b">enumerable</code>为假，它将不会出现在属性键中，也不会出现在简单对象转储中。</p><p id="93ea" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了<em class="ls">更新</em>属性，我们可以使用普通的JavaScript:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="e57b" class="og ng ir mx b gz oh oi l oj ok">example['prop3'] = 'NEW AND IMPROVED Property #3';  <br/>console.log('prop3', Reflect.get(example, 'prop3')); <br/>console.log(example);  <br/>Reflect.set(example, 'prop3', 'ULTIMATELY IMPROVED Property #3');  <br/>console.log('prop3', Reflect.get(example, 'prop3')); <br/>console.log(example);</span></pre><p id="6b39" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为什么我们用了<code class="fe mu mv mw mx b">example['prop3']</code>而不是<code class="fe mu mv mw mx b">example.prop3</code>？TypeScript编译器在编译时执行，而<code class="fe mu mv mw mx b">Reflect.defineProperty</code>在运行时执行，因此编译器无法知道<code class="fe mu mv mw mx b">prop3</code>会存在，因此编译器会给出编译错误。</p><p id="a701" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在这种情况下，使用<code class="fe mu mv mw mx b">example['prop3']</code>非常有效。我们可以使用普通的JavaScript赋值来更新属性，或者使用<code class="fe mu mv mw mx b">Reflect.set</code>来更新属性。</p><p id="1396" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">输出是这样的:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="9d08" class="og ng ir mx b gz oh oi l oj ok">prop3 NEW AND IMPROVED Property #3 {<br/>   prop1: 'property1',<br/>   prop2: 42,<br/>   prop3: 'NEW AND IMPROVED Property #3' <br/>} <br/>prop3 ULTIMATELY IMPROVED Property #3 {<br/>   prop1: 'property1',<br/>   prop2: 42,<br/>   prop3: 'ULTIMATELY IMPROVED Property #3' <br/>}</span></pre><p id="30c3" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这里我们展示了属性是这样更新的。如果将<code class="fe mu mv mw mx b">writable</code>设置为<code class="fe mu mv mw mx b">false</code>，属性不会改变。</p><p id="2b3b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">最后是演示删除属性。</p><p id="58eb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">因为<code class="fe mu mv mw mx b">Reflect.deleteProperty</code>返回一个<code class="fe mu mv mw mx b">Boolean</code>指示删除是否成功。属性的<code class="fe mu mv mw mx b">configurable</code>属性的值决定了它是否可删除。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="f9cf" class="og ng ir mx b gz oh oi l oj ok">{ ownKeys: [ 'prop2' ], keys: [ 'prop2' ] } <br/>{ prop2: 42 } <br/>{<br/>   prop2: { value: 42, writable: true, enumerable: true, configurable: true } <br/>}</span></pre><p id="cf34" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">事实上，那是唯一剩下的财产。</p><p id="5bd0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们可以使用普通的JavaScript代码或反射来创建、读取、更新或删除JavaScript对象的属性。</p><h1 id="e87e" class="nf ng ir bd nh ni nj nk nl nm nn no np jx nq jy nr ka ns kb nt kd nu ke nv nw bi translated">使用反射元数据存储/读取/更新/删除关于TypeScript对象的附加数据</h1><p id="ad94" class="pw-post-body-paragraph kw kx ir ky b kz nx js lb lc ny jv le lf nz lh li lj oa ll lm ln ob lp lq lr ik bi translated">在这种情况下，元数据意味着描述JavaScript对象的结构或数据类型的数据。使用这个API，我们还可以将数据存储为元数据，它与对象存储的实际数据完全分离。稍后我们将使用元数据和一些装饰器来实现一个非常有趣的功能。</p><p id="61b6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">有足够多的反射元数据方法来实现CRUD操作。让我们从这里开始:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="f5ac" class="og ng ir mx b gz oh oi l oj ok">import 'reflect-metadata';  <br/>class MetadataExample {<br/>     prop1: string = 'prop1';<br/>     prop2: number = 42; <br/>}  <br/>const example2 = new MetadataExample();  <br/>console.log({<br/>     ownMetadataKeys: Reflect.getOwnMetadataKeys(example2),<br/>     metadataKeys: Reflect.getMetadataKeys(example2) <br/>});</span></pre><p id="e1a2" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这将创建一个简单的类，创建该类的一个实例，然后读取关于该类的一些数据。一定要记得导入<code class="fe mu mv mw mx b">reflect-metadata</code>。否则会导致以下错误:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="7640" class="og ng ir mx b gz oh oi l oj ok">error TS2339: Property 'getOwnMetadataKeys' does not exist on type 'typeof Reflect'.</span></pre><p id="1532" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">确保导入该包后，输出如下:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="66ff" class="og ng ir mx b gz oh oi l oj ok">$ npx ts-node lib/reflection/metadata.ts <br/>{ ownMetadataKeys: [], metadataKeys: [] }</span></pre><p id="afc9" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">换句话说，还没有<em class="ls">元数据关键字</em>。但是，它们是什么呢？</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="0e22" class="og ng ir mx b gz oh oi l oj ok">Reflect.defineMetadata('metaProp1', 'prop1', example2);<br/>console.log({<br/>     ownMetadataKeys: Reflect.getOwnMetadataKeys(example2),<br/>     metadataKeys: Reflect.getMetadataKeys(example2) <br/>});</span></pre><p id="f8cc" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这样做的是用<code class="fe mu mv mw mx b">metaProp1</code>的<em class="ls">键</em>和<code class="fe mu mv mw mx b">example2</code>对象上的<code class="fe mu mv mw mx b">prop1</code>的<em class="ls">值</em>为创建一个元数据属性。</p><p id="279a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">换句话说，元数据键是元数据属性的名称。这就像一个常规对象键是一个常规JavaScript对象属性的名称。</p><p id="e50d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们还可以在对象的属性上定义元数据:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="0565" class="og ng ir mx b gz oh oi l oj ok">Reflect.defineMetadata('metaKey1ForProp1', 'data stored in prop1',<br/>         example2, 'prop1');  <br/>console.log({<br/>     prop1OwnMetadataKeys: Reflect.getOwnMetadataKeys(example2, 'prop1'),<br/>     prop1MetadataKeys: Reflect.getMetadataKeys(example2, 'prop1') <br/>});</span></pre><p id="26fb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这里我们已经在<code class="fe mu mv mw mx b">example2.prop1</code>上定义了<code class="fe mu mv mw mx b">metaKey1ForProp1</code>，并且正在检索那个属性的元数据键。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="b6c3" class="og ng ir mx b gz oh oi l oj ok">{<br/> prop1OwnMetadataKeys: [ 'metaKey1ForProp1' ],<br/> prop1MetadataKeys: [ 'metaKey1ForProp1' ] <br/>}</span></pre><p id="671d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">另一个函数让我们确定元数据属性是否存在:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="7fca" class="og ng ir mx b gz oh oi l oj ok">console.log({<br/>     hasMetadata: Reflect.hasMetadata('metaProp1', example2),<br/>     hasOwnMetadata: Reflect.hasOwnMetadata('metaProp1', example2),<br/>     prop1NotHasMetadata: Reflect.hasMetadata('metaProp1', example2, 'prop1'),<br/>     prop1NotHasOwnMetadata: Reflect.hasOwnMetadata('metaProp1', example2, 'prop1'),<br/>     prop1HasMetadata: Reflect.hasMetadata('metaKey1ForProp1', example2, 'prop1'),<br/>     prop1HasOwnMetadata: Reflect.hasOwnMetadata('metaKey1ForProp1', example2, 'prop1'), <br/>});</span></pre><p id="815d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这显示了我们使用<code class="fe mu mv mw mx b">hasMetadata</code>和<code class="fe mu mv mw mx b">hasOwnMetadata</code>来查询<code class="fe mu mv mw mx b">example2</code>和<code class="fe mu mv mw mx b">example2.prop1</code>上的元数据属性。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="dc80" class="og ng ir mx b gz oh oi l oj ok">{<br/>   hasMetadata: true,<br/>   hasOwnMetadata: true,<br/>   prop1NotHasMetadata: false,<br/>   prop1NotHasOwnMetadata: false,<br/>   prop1HasMetadata: true,<br/>   prop1HasOwnMetadata: true <br/>}</span></pre><p id="92de" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">显示<code class="fe mu mv mw mx b">false</code>的两个是因为我们使用了错误的元数据键值。</p><p id="a721" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们可以像这样<em class="ls">读取</em>元数据值:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="cdef" class="og ng ir mx b gz oh oi l oj ok">console.log({<br/>     metadata: Reflect.getMetadata('metaProp1', example2),<br/>     ownMetadata: Reflect.getOwnMetadata('metaProp1', example2),<br/>     prop1NotMetadata: Reflect.getMetadata('metaProp1', example2, 'prop1'),<br/>     prop1NotOwnMetadata: Reflect.getOwnMetadata('metaProp1', example2, 'prop1'),<br/>     prop1Metadata: Reflect.getMetadata('metaKey1ForProp1', example2, 'prop1'),<br/>     prop1OwnMetadata: Reflect.getOwnMetadata('metaKey1ForProp1', example2, 'prop1'), <br/>});</span></pre><p id="8a90" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">使用<code class="fe mu mv mw mx b">getMetadata</code>和<code class="fe mu mv mw mx b">getOwnMetadata</code>我们读取元数据属性的当前值。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="0a20" class="og ng ir mx b gz oh oi l oj ok">{<br/>   metadata: 'prop1',<br/>   ownMetadata: 'prop1',<br/>   prop1NotMetadata: undefined,<br/>   prop1NotOwnMetadata: undefined,<br/>   prop1Metadata: 'data stored in prop1',<br/>   prop1OwnMetadata: 'data stored in prop1' <br/>}</span></pre><p id="81e9" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">并且，这返回了预期的值。对于中间的两个，我们再次传递了一个不正确的元数据键，得到的结果是<code class="fe mu mv mw mx b">undefined</code>。</p><p id="137e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了更新元数据值，我们再次调用<code class="fe mu mv mw mx b">defineMetadata</code>:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="e4c9" class="og ng ir mx b gz oh oi l oj ok">Reflect.defineMetadata('metaProp1', 'NEW IMPROVED prop1', example2); <br/>Reflect.defineMetadata('metaKey1ForProp1', 'NEW IMPROVED prop1 on prop1', example2, 'prop1');</span></pre><p id="2c74" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">重新运行上一个示例，我们得到以下输出:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="4272" class="og ng ir mx b gz oh oi l oj ok">{<br/>  metadata: 'NEW IMPROVED prop1',<br/>  ownMetadata: 'NEW IMPROVED prop1',<br/>  prop1NotMetadata: undefined,<br/>  prop1NotOwnMetadata: undefined,<br/>  prop1Metadata: 'NEW IMPROVED prop1 on prop1',<br/>  prop1OwnMetadata: 'NEW IMPROVED prop1 on prop1'<br/>}</span></pre><p id="d504" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">最后，我们可以使用<code class="fe mu mv mw mx b">deleteMetadata</code>删除元数据键:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="f616" class="og ng ir mx b gz oh oi l oj ok">Reflect.deleteMetadata('metaProp1', example2); Reflect.deleteMetadata('metaKey1ForProp1', example2, 'prop1');</span></pre><p id="9c0f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">重新运行该示例，我们得到以下输出:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="8041" class="og ng ir mx b gz oh oi l oj ok">{<br/>   metadata: undefined,<br/>   ownMetadata: undefined,<br/>   prop1NotMetadata: undefined,<br/>   prop1NotOwnMetadata: undefined,<br/>   prop1Metadata: undefined,<br/>   prop1OwnMetadata: undefined <br/>}</span></pre><p id="c2c1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">元数据值现在没有了。</p><h1 id="9849" class="nf ng ir bd nh ni nj nk nl nm nn no np jx nq jy nr ka ns kb nt kd nu ke nv nw bi translated">在TypeScript类上使用<code class="fe mu mv mw mx b">Reflect.metadata</code>装饰器</h1><p id="50f0" class="pw-post-body-paragraph kw kx ir ky b kz nx js lb lc ny jv le lf nz lh li lj oa ll lm ln ob lp lq lr ik bi translated"><code class="fe mu mv mw mx b">reflect-metadata</code>包还提供了一个装饰器，我们可以用它来向事物添加元数据值。它的用法如下:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="a82e" class="og ng ir mx b gz oh oi l oj ok">import 'reflect-metadata';  <br/>@Reflect.metadata('decoratedClass', 'value') <br/>class MetadataDecoratorExample {<br/>   // apply metadata via a decorator to a method (property)<br/>   @Reflect.metadata('decoratedMethod', 'method value')<br/>   method(param1?: number, param2?: string): string {<br/>       return 'Hello, World!';   <br/>   } <br/>}  <br/>const mde = new MetadataDecoratorExample();</span></pre><p id="5445" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这只是设置了一个元数据值。要查询元数据值，我们可以添加以下内容:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="f949" class="og ng ir mx b gz oh oi l oj ok">console.log({<br/>     classClassKeys: Reflect.getMetadataKeys(MetadataDecoratorExample),<br/>     classClassMetadata: Reflect.getMetadata('decoratedClass', MetadataDecoratorExample),<br/>     classKeys: Reflect.getMetadataKeys(mde),<br/>     methodKeys: Reflect.getMetadataKeys(mde, 'method'),<br/>     methodReturn: Reflect.getMetadata('design:returntype', mde, 'method'),<br/>     methodParams: Reflect.getMetadata('design:paramtypes', mde, 'method'),<br/>     methodType: Reflect.getMetadata('design:type', mde, 'method'),<br/>     methodDecorated: Reflect.getMetadata('decoratedMethod', mde, 'method'), <br/>});</span></pre><p id="ab64" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这样的输出是:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="5915" class="og ng ir mx b gz oh oi l oj ok">{<br/>   classClassKeys: [ 'decoratedClass' ],<br/>   classClassMetadata: 'value',<br/>   classKeys: [],<br/>   methodKeys: [<br/>     'design:returntype',<br/>     'design:paramtypes',<br/>     'design:type',<br/>     'decoratedMethod'<br/>   ],<br/>   methodReturn: [Function: String],<br/>   methodParams: [ [Function: Number], [Function: String] ],<br/>   methodType: [Function: Function],<br/>   methodDecorated: 'method value' <br/>}</span></pre><p id="699b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">前两行来自附加到类的装饰器。我们看到这里显示了元数据键和值，但是如果我们对类实例进行相同的查询，就不会出现这种情况。</p><p id="2779" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">从<code class="fe mu mv mw mx b">methodKeys</code>开始，我们对名为<code class="fe mu mv mw mx b">method</code>的实例方法进行查询。我们找到了预期的元数据键，<code class="fe mu mv mw mx b">decoratedMethod</code>，以及其他三个。我们知道，在某些情况下，这三个元数据键是由TypeScript自动提供的。对于<code class="fe mu mv mw mx b">decoratedMethod</code>键，我们收到了预期值。</p><p id="962b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于三个<code class="fe mu mv mw mx b">design</code>键，根据输出和属性名，目的似乎是:</p><ul class=""><li id="4021" class="lt lu ir ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><code class="fe mu mv mw mx b">design:returntype</code> -记录物业的返回类型</li><li id="1fda" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><code class="fe mu mv mw mx b">design:paramtypes</code> -记录属性的参数类型</li><li id="8f8b" class="lt lu ir ky b kz na lc nb lf nc lj nd ln ne lr ly lz ma mb bi translated"><code class="fe mu mv mw mx b">design:type</code> -文件类型的东西是财产</li></ul><h1 id="e6bd" class="nf ng ir bd nh ni nj nk nl nm nn no np jx nq jy nr ka ns kb nt kd nu ke nv nw bi translated">在TypeScript装饰器实现中使用反射元数据</h1><p id="2a3b" class="pw-post-body-paragraph kw kx ir ky b kz nx js lb lc ny jv le lf nz lh li lj oa ll lm ln ob lp lq lr ik bi translated">因为反射元数据API是要和装饰器实现一起使用的，所以让我们探索一下它是如何工作的。在我们关于<a class="ae mz" href="https://techsparx.com/nodejs/typescript/decorators/methods.html" rel="noopener ugc nofollow" target="_blank">方法装饰器</a>的文章中，我们开发了一个例子，它使用一个数组来存储来自参数装饰器的数据，以便在方法装饰器中使用。参数装饰器本身除了记录一些数据之外不能做太多事情。然而，方法装饰器可以拦截方法调用，例如，修改参数，这就是该示例所做的。</p><p id="ed4a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">让我们重写这个例子来使用反射元数据。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="cc67" class="og ng ir mx b gz oh oi l oj ok">class DefaultExample {<br/>      @SetDefaults<br/>     volume(<br/>         z: number,<br/>         @ParamDefault&lt;number&gt;(10) x?: number,<br/>         @ParamDefault&lt;number&gt;(15) y?: number,<br/>         title?: string<br/>     ) {<br/>         const ret = {<br/>             x, y, z, volume: x * y * z, title<br/>         };<br/>         console.log(`volume `, ret);<br/>         return ret;<br/>     } <br/>}</span></pre><p id="38d0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是那个例子中的类定义。它使用装饰器<code class="fe mu mv mw mx b">ParamDefault</code>为没有提供值的可选参数定义默认值。<code class="fe mu mv mw mx b">SetDefaults</code> decorator在这个方法上安装了一个覆盖函数，它使用来自<code class="fe mu mv mw mx b">ParamDefault</code>decorator的数据为调用者没有提供的任何参数提供默认值。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="8699" class="og ng ir mx b gz oh oi l oj ok">import 'reflect-metadata';  <br/>const DEFAULTS = 'defaults';</span></pre><p id="39b5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们导入<code class="fe mu mv mw mx b">reflect-metadata</code>包。然后，我们将<code class="fe mu mv mw mx b">DEFAULTS</code>定义为包含一个字符串，我们将使用该字符串作为存储默认值的元数据键。这种技术类似于我们在C编程中可能会做的事情，我们使用<code class="fe mu mv mw mx b">#define</code>来创建符号常量。对元数据键使用这种方法可以确保一致地使用相同的键字符串。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="8716" class="og ng ir mx b gz oh oi l oj ok">function ParamDefault&lt;T&gt;(value: T) {<br/>     return (target: Object, propertyKey: string | symbol,<br/>         parameterIndex: number)=&gt; {<br/>         const defaults = Reflect.getMetadata(DEFAULTS, target, propertyKey)<br/>                         || {};<br/>         defaults[parameterIndex] = value;<br/>         Reflect.defineMetadata(DEFAULTS, defaults, target, propertyKey);<br/>     } <br/>}</span></pre><p id="8ba2" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是重写的<code class="fe mu mv mw mx b">ParamDefault</code>装饰器。它首先获取现有的元数据值(如果有的话)。从上面我们知道，如果当前没有值存在，将返回<code class="fe mu mv mw mx b">undefined</code>，在这种情况下，我们将替换一个空对象。</p><p id="923b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这样做的结果是,<code class="fe mu mv mw mx b">DEFAULTS</code>元数据值包含我们称之为保存默认值的稀疏数组。只有使用了<code class="fe mu mv mw mx b">ParamDefault</code>装饰器的索引才会有默认值。</p><p id="8d19" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">然后我们使用<code class="fe mu mv mw mx b">Reflect.defineMetadata</code>来更新默认值。</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="e877" class="og ng ir mx b gz oh oi l oj ok">function SetDefaults(target: Object, propertyKey: string,<br/>     descriptor: PropertyDescriptor) {<br/>     const originalMethod = descriptor.value;<br/>     descriptor.value = function (...args: any[]) {<br/>         console.log(`SetDefaults before ${propertyKey}`, args);<br/>         const defaults = Reflect.getMetadata(DEFAULTS, target, propertyKey)<br/>                         || {};<br/>         for (const key of Object.keys(defaults)) {<br/>             let def = defaults[key];<br/>             if (typeof args[key] === 'undefined'<br/>              || args[key] === null) {<br/>                 args[key] = def;<br/>             }<br/>         }<br/>         console.log(`SetDefaults after substitution ${propertyKey}`, args);<br/>         const result = originalMethod.apply(this, args);<br/>         console.log(`SetDefaults after ${propertyKey}`, result);<br/>         return result;<br/>     } <br/>}</span></pre><p id="5a20" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这里我们有<code class="fe mu mv mw mx b">SetDefaults</code>装饰工。阅读关于<a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">方法装饰者</a>的文章，获得对正在发生的事情的完整描述。底线是<code class="fe mu mv mw mx b">originalMethod</code>是实际的功能。我们已经定义了一个替换函数来覆盖那个函数。override函数查找应该提供的任何默认值，更改参数数组，然后调用原始函数。</p><p id="4ac3" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了测试这一点，我们有以下内容:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="0520" class="og ng ir mx b gz oh oi l oj ok">const de = new DefaultExample();  <br/>console.log(de.volume(10)); <br/>console.log('----------------------'); <br/>console.log(de.volume(20, null, 20, "Second")); <br/>console.log('----------------------'); <br/>console.log(de.volume(30, 30, null)); <br/>console.log('----------------------'); <br/>console.log(de.volume(40, 40, 50, "Fourth"));</span></pre><p id="8605" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这将尝试我们的应用程序中默认值的每种组合。我们得到的输出是:</p><pre class="kh ki kj kk gu oc mx od oe aw of bi"><span id="23c5" class="og ng ir mx b gz oh oi l oj ok">SetDefaults before volume [ 10 ] <br/>SetDefaults after substitution volume [ 10, 10, 15 ] <br/>volume  { x: 10, y: 15, z: 10, volume: 1500, title: undefined } <br/>SetDefaults after volume { x: 10, y: 15, z: 10, volume: 1500, title: undefined } <br/>{ x: 10, y: 15, z: 10, volume: 1500, title: undefined } <br/>---------------------- <br/>SetDefaults before volume [ 20, null, 20, 'Second' ] <br/>SetDefaults after substitution volume [ 20, 10, 20, 'Second' ] <br/>volume  { x: 10, y: 20, z: 20, volume: 4000, title: 'Second' } <br/>SetDefaults after volume { x: 10, y: 20, z: 20, volume: 4000, title: 'Second' } <br/>{ x: 10, y: 20, z: 20, volume: 4000, title: 'Second' } <br/>---------------------- <br/>SetDefaults before volume [ 30, 30, null ] <br/>SetDefaults after substitution volume [ 30, 30, 15 ] <br/>volume  { x: 30, y: 15, z: 30, volume: 13500, title: undefined } <br/>SetDefaults after volume { x: 30, y: 15, z: 30, volume: 13500, title: undefined } <br/>{ x: 30, y: 15, z: 30, volume: 13500, title: undefined } <br/>---------------------- <br/>SetDefaults before volume [ 40, 40, 50, 'Fourth' ] <br/>SetDefaults after substitution volume [ 40, 40, 50, 'Fourth' ] <br/>volume  { x: 40, y: 50, z: 40, volume: 80000, title: 'Fourth' } <br/>SetDefaults after volume { x: 40, y: 50, z: 40, volume: 80000, title: 'Fourth' } <br/>{ x: 40, y: 50, z: 40, volume: 80000, title: 'Fourth' }</span></pre><p id="ec08" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如您所见，在每种情况下都替换了正确的值。</p><p id="65e7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">使用反射元数据大大简化了这个例子。像我们所做的那样使用外部数组不是一个干净的解决方案。</p><h1 id="665a" class="nf ng ir bd nh ni nj nk nl nm nn no np jx nq jy nr ka ns kb nt kd nu ke nv nw bi translated">摘要</h1><p id="edb0" class="pw-post-body-paragraph kw kx ir ky b kz nx js lb lc ny jv le lf nz lh li lj oa ll lm ln ob lp lq lr ik bi translated">TypeScript具有默认参数值的功能。因此，我们可以构建注入默认值的decorators，这并不是一个惊天动地的大进步。什么是惊天动地的事情是用几行代码实现这一结果的功能。许多语言没有默认的参数值特性，也没有任何改进这种特性的能力。使用一对TypeScript装饰器和大约50行代码，我们能够实现一个可信的有用特性。</p><p id="6bc8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在下一篇文章中，我们将更进一步，演示使用TypeScript decorators开发自动运行时数据验证。</p><h1 id="e9a5" class="nf ng ir bd nh ni nj nk nl nm nn no np jx nq jy nr ka ns kb nt kd nu ke nv nw bi translated">关于作者</h1><p id="ef16" class="pw-post-body-paragraph kw kx ir ky b kz nx js lb lc ny jv le lf nz lh li lj oa ll lm ln ob lp lq lr ik bi translated"><a class="ae mz" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">大卫·赫伦</em> </strong> </a> <em class="ls">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl om on hv oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ik il im in io"><p id="999c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">原载于</em><a class="ae mz" href="https://techsparx.com/nodejs/typescript/decorators/reflection.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://techsparx.com</em></a><em class="ls">。</em></p><p id="a6f5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">更多内容请看</em><a class="ae mz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky is"><em class="ls">plain English . io</em></strong></a><em class="ls">。报名参加我们的</em> <a class="ae mz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。关注我们关于</em><a class="ae mz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky is"><em class="ls">Twitter</em></strong></a><em class="ls">和</em><a class="ae mz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky is"><em class="ls">LinkedIn</em></strong></a><em class="ls">。加入我们的</em> <a class="ae mz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">社区不和谐</em> </strong> </a> <em class="ls">。</em></p></div></div>    
</body>
</html>