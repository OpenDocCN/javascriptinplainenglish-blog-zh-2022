<html>
<head>
<title>Advanced TypeScript: Type-Level Decimal to Binary Converter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级类型脚本:类型级十进制到二进制转换器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-typescript-type-level-decimal-to-binary-converter-337375531a80?source=collection_archive---------2-----------------------#2022-12-01">https://javascript.plainenglish.io/advanced-typescript-type-level-decimal-to-binary-converter-337375531a80?source=collection_archive---------2-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="72ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我如何只使用类型实现了从基数10到基数2的转换器！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e376484f37e7b030ca0d2797c7f7c2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_4fp8gLAK8hteBzFPSvnw.jpeg"/></div></div></figure><p id="d48f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我总是想提高我的打字技能，最好的方法就是挑战自己，所以几天前我想:我能在Typescript中做一个类型级的十进制到二进制转换器吗？</p><p id="bff2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个简单的问题让我开始了一段不可思议的旅程，我想与你分享，但首先，让我们看看结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/94e9b540bc78dff705fa672441b79b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*3CrJRFaeHOyvCQU4SAiKlg.gif"/></div></figure><p id="d750" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你和我一样，现在你已经在考虑如何自己做这件事，也许你已经打开了你的IDE或者<a class="ae lo" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank">Typescript Playground</a>——在这种情况下，现在就停止阅读，或者注意会有<strong class="kt ir">剧透</strong>。<br/>试着自己去做，然后，如果你在努力，回来看看我的解决方案，或者把你的和我的进行比较——看到一些不同的方法会很棒。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="5d00" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">🎉结果</h1><p id="53a2" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">如果您只是对解决方案感兴趣，这里是:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="a2b3" class="my lx iq mu b be mz na l nb nc">type CastNumber&lt;N extends unknown&gt; = N extends number ? N : never;<br/><br/>type Length&lt;A extends unknown[]&gt; = CastNumber&lt;A["length"]&gt;;<br/><br/>type NumberToArray&lt;<br/>  N extends number,<br/>  Acc extends unknown[] = []<br/>&gt; = N extends Length&lt;Acc&gt; ? Acc : NumberToArray&lt;N, [...Acc, unknown]&gt;;<br/><br/>type Increment&lt;N extends number&gt; = Length&lt;[...NumberToArray&lt;N&gt;, unknown]&gt;;<br/><br/>type Decrement&lt;N extends number&gt; = NumberToArray&lt;N&gt; extends [<br/>  unknown,<br/>  ...infer Rest<br/>]<br/>  ? Length&lt;Rest&gt;<br/>  : 0;<br/><br/>type Sub&lt;L extends number, R extends number&gt; = R extends 0<br/>  ? L<br/>  : Sub&lt;Decrement&lt;L&gt;, Decrement&lt;R&gt;&gt;;<br/><br/>type DivBy2&lt;<br/>  Dividend extends number,<br/>  Quotient extends number = 0<br/>&gt; = Dividend extends 0<br/>  ? [0, Quotient]<br/>  : Dividend extends 1<br/>  ? [1, Quotient]<br/>  : DivBy2&lt;Sub&lt;Dividend, 2&gt;, Increment&lt;Quotient&gt;&gt;;<br/><br/>type ToBinary&lt;N extends number, Result extends string = ""&gt; = N extends 0<br/>  ? Result<br/>  : N extends 1<br/>  ? `1${Result}`<br/>  : DivBy2&lt;N&gt; extends [<br/>      infer Remainder extends 0 | 1,<br/>      infer Quotient extends number<br/>    ]<br/>  ? ToBinary&lt;Quotient, `${Remainder}${Result}`&gt;<br/>  : never;<br/><br/>type BinaryNumber = ToBinary&lt;2&gt;; // 10</span></pre><p id="7bf6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请随意复制粘贴这个解决方案，并使用它。尽管如此，如果你不明白发生了什么，在本文的其余部分，我会解释我是如何想出这个解决方案的。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="b7f1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">🗒解解释道</h1><p id="14cc" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在开始解释之前，为了清楚地理解它，您需要对一些概念有一个基本的了解，特别是:</p><ul class=""><li id="b4a6" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated"><a class="ae lo" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">条件类型</a></li><li id="2a8e" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><a class="ae lo" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types" rel="noopener ugc nofollow" target="_blank">推断</a></li><li id="2fd8" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><a class="ae lo" href="https://www.w3schools.com/typescript/typescript_tuples.php" rel="noopener ugc nofollow" target="_blank">元组</a></li><li id="bb04" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">一点数学知识</li></ul><p id="aae4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您熟悉这些概念，就可以开始了——否则，我希望这些例子能帮助您理解正在发生的事情，但是我强烈建议您跟随这些链接并阅读文档，这不是火箭科学😉</p><h2 id="3fb7" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated">理论</h2><p id="5906" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">你知道如何将基数为10的数转换成基数为2的数吗？</p><p id="060e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这其实很简单，我们只需要尽可能地除以2，然后存储所有除法的余数。<br/>让我们举个例子，把数字10从基数10转换成基数2:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/9b527bcba5469d5ca52158f8ad9b52ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*7uwq8skv32I9Tost8Uh0CA.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk">10 : 2</figcaption></figure><p id="2285" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">10除以2等于5，没有余数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/2bf21709f3f85f0e5a7b4bfc98611970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*w6Qf824cmoszbz-4lOECOQ.png"/></div></figure><p id="0581" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们存储余数，这将是以2为基数的数字的最后一位。<br/>现在，让我们继续将商除以2:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f88cfc0f5283380f22cbbd0ec94bcb2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*03LciU9vrE8Vvtzu2eIfJA.png"/></div></figure><p id="bb1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">5除以2等于2，并带有1的提示。<br/>就像我们之前做的一样，我们存储提醒并将其作为基数2中的倒数第二位数字。<br/>现在让我们进入下一步:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/420733c1865247ca8833731e00cc423d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*E4md2kUZWOx36eUPxgxSow.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk">2:2</figcaption></figure><p id="ff78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2除以2等于1，没有余数，我们再次存储余数，并继续进行最后一步:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/e816efaffc200fb1d4fdb05fceb2b80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezMOk3kbtWjnxN3k_i-xdg.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk">10 (base 10) = 1010 (base 2) 🎉</figcaption></figure><p id="4928" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们终于有号码了！最后一个除法的商是0，这意味着我们可以停在这里。</p><p id="2221" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管如此，我们仍然没有准备好编码！在编程中，最重要的事情之一是将大问题分解成小问题，因此在开始之前，我们必须了解要做什么:</p><p id="54a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所料，真正的问题是:如何仅使用Typescript类型进行数学运算？</p><p id="995d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">答案不是那么简单，因为有很多方法可以做到这一点。<br/>在本文中，我将向您展示一种基于数组的方法，它仅涵盖<strong class="kt ir">自然</strong> <strong class="kt ir">数字</strong>——但是让我们回到问题上来:</p><p id="f8b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要有一种方法来做除法，但是什么是除法呢？我们可以把它看作是<strong class="kt ir">被除数减去除数达到零的次数<em class="om"> ( </em> </strong> <em class="om">)如果它们不能被整除就不是这样了，而是来吧...你知道怎么做除法吗😀我就开门见山吧！)</em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/f2e1c4294980e3adbeb16201c231e03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDfigU74eB0GUjJT5lEMzw.png"/></div></div></figure><p id="96b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了<strong class="kt ir">除以</strong>，我们需要知道如何做两件事:<strong class="kt ir">增加</strong>(用于计算我们减去的次数)和<strong class="kt ir">减去</strong>。<br/> <strong class="kt ir">但是减法如果不是递减的序列又是什么呢？</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/4d208c641433eb6d15a31113448c989a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmHuQWL7K4C_mq-ZtARViw.png"/></div></div></figure><p id="5ef4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以要做除法，我们只需要知道2个基本运算:<strong class="kt ir">增</strong>和<strong class="kt ir">减</strong>。</p><p id="812a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们知道了背后的数学原理，我们可以开始编码了🤓。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="9200" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，我们不能对类型进行数学运算:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="d76b" class="my lx iq mu b be mz na l nb nc">type Three = 3;<br/>type Four = 4;<br/>// Error: 'Four' only refers to a type, but is being used as a value here.<br/>type Seven = Three + Four;</span></pre><p id="2d14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相反，我们可以做的是更接近于"<a class="ae lo" href="https://en.wikipedia.org/wiki/Set_theory" rel="noopener ugc nofollow" target="_blank">集合论</a>"的东西，所以我们必须找到另一种方法来做像加法、减法等运算。</p><p id="aa0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的解决方案全部基于数组(<a class="ae lo" href="https://www.w3schools.com/typescript/typescript_tuples.php" rel="noopener ugc nofollow" target="_blank"> <em class="om">元组，更具体地说是</em> </a>)，特别是它们都具有的一个属性，<code class="fe op oq or mu b">length</code>:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="3b5c" class="my lx iq mu b be mz na l nb nc">type MyArray = ['hello', 'world'];<br/><br/>type MyArrayLength = MyArray["length"]; // 2</span></pre><p id="c79a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe op oq or mu b">length</code>也是在类型级别，表示数组的大小。</p><p id="ed36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一件需要知道的重要事情是，我们可以通过使用<code class="fe op oq or mu b">extends</code>在类型级别比较数字——我们无法知道一个是否大于另一个，但至少，我们可以知道它们是否相等:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="3de1" class="my lx iq mu b be mz na l nb nc">type AreNumbersEqual&lt;<br/>  L extends number,<br/>  R extends number<br/>&gt; = L extends R ? true : false;<br/><br/>type Test_1 = AreNumbersEqual&lt;2, 3&gt;; // false<br/>type Test_2 = AreNumbersEqual&lt;3, 2&gt;; // false<br/>type Test_3 = AreNumbersEqual&lt;3, 3&gt;; // true</span></pre><p id="b68a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开始之前要知道的最后一件事是，spread运算符也适用于类型级！</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="a42a" class="my lx iq mu b be mz na l nb nc">type Array1 = ['Hello'];<br/>type Array2 = ['World'];<br/><br/>type Result = [...Array1, ', ' , ...Array2]; // ['Hello', ',', 'World'];</span></pre><p id="de48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，因为我们可以合并元组，所以我们可以做一些数学计算:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="9dab" class="my lx iq mu b be mz na l nb nc">type Array1 = ['Hello'];<br/>type Array2 = ['My', 'Friend'];<br/><br/>type Length1 = Array1['length']; // 1<br/>type Length2 = Array2['length']; // 2<br/><br/>type Merge = [Array1, ...Array2]; // ['Hello', 'My', 'Friend'];<br/>type MergeLength = Merge['length']; // 3 = 1 + 2</span></pre><p id="50cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用这三个概念做任何事情，信不信由你！</p><h2 id="0f7a" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated">增量</h2><p id="c2ac" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">让我们从创建第一个版本的<code class="fe op oq or mu b">Increment</code>类型开始，给定一个大小为<em class="om"> N </em>的数组，它将定义一个等于<em class="om"> N+1 </em>的类型:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="2fb7" class="my lx iq mu b be mz na l nb nc">type Increment&lt;A extends unknown[]&gt; = [...A, unknown]['length']; <br/><br/>type Result = Increase&lt;['Hello']&gt;; // 2;</span></pre><p id="9cae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这并不是我们真正想要的，但是我们已经很接近了…我们缺少的是将一个数字<strong class="kt ir">转换成一个与该数字的值大小相同的数组</strong>的方法，如果我们能做到这一点，那么类型<code class="fe op oq or mu b">Increment</code>的定义将会很简单:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="ccea" class="my lx iq mu b be mz na l nb nc">type Increment&lt;N extends number&gt; = [...NumberToArray&lt;N&gt;, unknown]['length'];<br/><br/>type Result = Increase&lt;2&gt;; // 3 --&gt; [...[unknown, unknown], unknown]['length']</span></pre><p id="44d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以…让我们建立这种新的类型！</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="67cf" class="my lx iq mu b be mz na l nb nc">type NumberToArray&lt;<br/>  N extends number,<br/>  Acc extends unknown[] = []<br/>&gt; = N extends Acc['length']<br/>    ? Acc<br/>    : NumberToArray&lt;N, [...Acc, unknown]&gt;;<br/><br/>type Result = NumberToArray&lt;4&gt;; // [unknown, unknown, unknown, unknown]</span></pre><p id="8c1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们用一个小动画来想象它是如何工作的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/6ce353902fa1d88994a86dc52aaaf0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*IHyjoOfNxGKd9aJKXeLs1w.gif"/></div></figure><p id="23e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，我们将一个“项目”添加到<code class="fe op oq or mu b">Acc</code>(累加器)数组中，直到它的长度等于数字<em class="om"> N </em>。</p><h2 id="f792" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated">减量</h2><p id="089a" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们将在类型推理的帮助下构建类型<code class="fe op oq or mu b">Decrement</code>，其思路如下:</p><p id="fac5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定一个长度为<em class="om"> N </em>的非空数组，我们可以把它看作一个长度为1的数组和一个长度为<em class="om"> N-1、</em>的数组的并集，除非N = 1，在那种情况下，我不能把数组拆分成2个非空数组。</p><p id="8873" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们把这个想法翻译成打字稿:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="af2b" class="my lx iq mu b be mz na l nb nc">type Decrement&lt;<br/>  N extends number<br/>&gt; = NumberToArray&lt;N&gt; extends [unknown, ...infer Rest]<br/>  ? Rest['length']<br/>  : 0; // In case N is 1 the result is 0 (1 - 1)</span></pre><p id="5a96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">万一有些事情不清楚，我希望一个小动画能帮助你理解正在发生的事情:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/eac50ce9a151807dee54bb523610345d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*prKVmOp40VWnL7j66W91Pg.gif"/></div></figure><h2 id="d902" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated">减法</h2><p id="60d0" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">这种类型很简单，因为我们知道如何减少:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="cf7d" class="my lx iq mu b be mz na l nb nc">type Sub&lt;<br/>  L extends number,<br/>  R extends number<br/>&gt; = R extends 0<br/>  ? L<br/>  : Sub&lt;Decrement&lt;L&gt;, Decrement&lt;R&gt;&gt;;</span></pre><p id="fa7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它是这样工作的:</p><p id="f9db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定两个数<em class="om"> L </em>和<em class="om"> R </em>，如果R等于0，我们返回L，如果不等于0，我们将两个数都减，然后递归调用该类型。<br/>例如:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="f9ff" class="my lx iq mu b be mz na l nb nc">type Result = Sub&lt;4, 1&gt;;</span></pre><p id="77ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">会这样解决:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="72ed" class="my lx iq mu b be mz na l nb nc">// 1st step<br/>type Result = 1 extends 0 ? 4 : Sub&lt;Decrement&lt;4&gt;, Decrement&lt;1&gt;&gt;;<br/>// 2nd step<br/>type Result = 1 extends 0 ? 4 : Sub&lt;3, 0&gt;;<br/>// 3rd step<br/>type Result = 1 extends 0 <br/>  ? 4 <br/>  : 0 extends 0 // this is true<br/>     ? 3  // &lt;---<br/>     : Sub&lt;Decrement&lt;3&gt;, Decrement&lt;0&gt;&gt;;<br/>// 4th step<br/>type Result = 1 extends 0 ? 4 : 3;<br/>// 5th step<br/>type Result = 3; // 4 - 1</span></pre><h2 id="e904" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated">除以2</h2><p id="651e" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们已经接近最终解了，我们缺少最后一个基本运算:除法，特别是<strong class="kt ir">除以2 </strong>。</p><p id="2742" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要将基数为10的数转换为基数为2的数，我们需要余数(只能是零或一)和除法的商。<br/>知道了这一点，让我们以一种能提供这两者的方式来制作类型<code class="fe op oq or mu b">DivBy2</code>:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="194f" class="my lx iq mu b be mz na l nb nc">type DivBy2&lt;<br/>  Dividend extends number,<br/>  Quotient extends number = 0<br/>&gt; = Dividend extends 0<br/>  ? [0, Quotient]<br/>  : Dividend extends 1<br/>  ? [1, Quotient]<br/>  : DivBy2&lt;Sub&lt;Dividend, 2&gt;, Increment&lt;Quotient&gt;&gt;;</span></pre><p id="9661" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了阐明它的实现，让我们举一个例子:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="9cc5" class="my lx iq mu b be mz na l nb nc">type Result = DivBy2&lt;5, 2&gt;;<br/>// 1st step<br/>type Result = 5 extends 0<br/>  ? [0, 0]<br/>  : 5 extends 1<br/>    ? [1, 0]<br/>    : DivBy2&lt;Sub&lt;5, 2&gt;, Increment&lt;0&gt;&gt;;<br/>// 2nd step<br/>type Result = 5 extends 0<br/>  ? [0, 0]<br/>  : 5 extends 1<br/>    ? [1, 0]<br/>    : 3 extends 0<br/>      ? [0, 1]<br/>      : 3 extends 1<br/>        ? [1, 1]<br/>        : DivBy2&lt;Sub&lt;3, 2&gt;, Increment&lt;1&gt;&gt;;<br/>// 3rd step<br/>type Result = 5 extends 0<br/>  ? [0, 0]<br/>  : 5 extends 1<br/>    ? [1, 0]<br/>    : 3 extends 0<br/>      ? [0, 1]<br/>      : 3 extends 1<br/>        ? [1, 1]<br/>        : 1 extends 0<br/>          ? [0, 2]<br/>          : 1 extends 1 // This is true<br/>            ? [1, 2] // Here we stop<br/>// 4th step<br/>type Result = [1, 2] // Where 1 is the remainder and 2 is the quotient.<br/>// In fact 5 : 2 = 2 with a remainder of 1.</span></pre><h2 id="9175" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated">转换器</h2><p id="3b9b" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们终于有了创建转换器所需的所有类型:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="3b73" class="my lx iq mu b be mz na l nb nc">type ToBinary&lt;<br/>  N extends number,<br/>  Result extends string = ""<br/>&gt; = N extends 0<br/>  ? Result<br/>  : N extends 1<br/>  ? `1${Result}`<br/>  : DivBy2&lt;N&gt; extends [<br/>      infer Remainder extends 0 | 1,<br/>      infer Quotient extends number<br/>    ]<br/>  ? ToBinary&lt;Quotient, `${Remainder}${Result}`&gt;<br/>  : never;</span></pre><p id="9c81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种类型是如何工作的:</p><p id="ffa5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定任意数<em class="om"> N </em></p><ul class=""><li id="ab87" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">如果N等于零，它返回累加器的值</li><li id="3ca3" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">如果N等于1，它返回以1为前缀的累加器值</li><li id="9539" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">否则，计算给定数字的<code class="fe op oq or mu b">DivBy2</code>的结果，得到元组[ <code class="fe op oq or mu b">Remainder</code>，<code class="fe op oq or mu b">Quotient</code> ]</li><li id="3533" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">该类型在<code class="fe op oq or mu b">Quotient</code>上被递归调用，累加器以<code class="fe op oq or mu b">Remainder</code>为前缀</li></ul><p id="5f6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们也举一个例子:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="c4c8" class="my lx iq mu b be mz na l nb nc">type Result = ToBinary&lt;3&gt;;<br/>// Step 1<br/>type Result = 3 extends 0<br/>  ? ''<br/>  : 3 extends 1<br/>    ? '1'<br/>    : DivBy2&lt;3&gt; extends [1, 1]<br/>      ? ToBinary&lt;1, `${'1'}${''}`&gt;<br/>      : never;<br/>// Step 2<br/>type Result = 3 extends 0<br/>  ? ''<br/>  : 3 extends 1<br/>    ? '1'<br/>    : DivBy2&lt;3&gt; extends [infer Remainder, infer Quotient]<br/>      ? 1 extends 0<br/>         ? '1'<br/>         : 1 extends 1 // This is true<br/>           ? `1${'1'}` // Will stop here<br/>           : DivBy2&lt;1&gt; extends [1, 0]<br/>             ? ToBinary&lt;0, `${'1'}${'1'}`&gt;<br/>             : never;<br/>      : never;<br/>// Step 3<br/>type Result = '11'; // ToBinary&lt;3&gt;</span></pre><p id="aff7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们把所有东西放在一起:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="dcc3" class="my lx iq mu b be mz na l nb nc">type CastNumber&lt;N extends unknown&gt; = N extends number ? N : never;<br/><br/>type Length&lt;A extends unknown[]&gt; = CastNumber&lt;A["length"]&gt;;<br/><br/>type NumberToArray&lt;<br/>  N extends number,<br/>  Acc extends unknown[] = []<br/>&gt; = N extends Length&lt;Acc&gt; ? Acc : NumberToArray&lt;N, [...Acc, unknown]&gt;;<br/><br/>type Increment&lt;N extends number&gt; = Length&lt;[...NumberToArray&lt;N&gt;, unknown]&gt;;<br/><br/>type Decrement&lt;N extends number&gt; = NumberToArray&lt;N&gt; extends [<br/>  unknown,<br/>  ...infer Rest<br/>]<br/>  ? Length&lt;Rest&gt;<br/>  : 0;<br/><br/>type Sub&lt;L extends number, R extends number&gt; = R extends 0<br/>  ? L<br/>  : Sub&lt;Decrement&lt;L&gt;, Decrement&lt;R&gt;&gt;;<br/><br/>type DivBy2&lt;<br/>  Dividend extends number,<br/>  Quotient extends number = 0<br/>&gt; = Dividend extends 0<br/>  ? [0, Quotient]<br/>  : Dividend extends 1<br/>  ? [1, Quotient]<br/>  : DivBy2&lt;Sub&lt;Dividend, 2&gt;, Increment&lt;Quotient&gt;&gt;;<br/><br/>type ToBinary&lt;N extends number, Result extends string = ""&gt; = N extends 0<br/>  ? Result<br/>  : N extends 1<br/>  ? `1${Result}`<br/>  : DivBy2&lt;N&gt; extends [<br/>      infer Remainder extends 0 | 1,<br/>      infer Quotient extends number<br/>    ]<br/>  ? ToBinary&lt;Quotient, `${Remainder}${Result}`&gt;<br/>  : never;</span></pre><p id="a9a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以看到，这里我们有另外两种类型:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="09aa" class="my lx iq mu b be mz na l nb nc">type CastNumber&lt;N extends unknown&gt; = N extends number ? N : never;<br/><br/>type Length&lt;A extends unknown[]&gt; = CastNumber&lt;A["length"]&gt;;</span></pre><p id="5665" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe op oq or mu b">Length</code>只是我用来代替每次写<code class="fe op oq or mu b">Array["length"]</code>的一个实用程序类型。用<br/> <code class="fe op oq or mu b">CastNumber</code>代替，是因为<em class="om">为</em> <em class="om">某种原因</em>编译器抱怨<code class="fe op oq or mu b">Array[“length”]</code>可能不是一个数字(真的无法想象什么时候tbh)，所以通过使用类型<code class="fe op oq or mu b">Length</code>我确信我总是收到一个数字。将军打字稿。</p><h1 id="4453" class="lw lx iq bd ly lz os mb mc md ot mf mg jw ou jx mi jz ov ka mk kc ow kd mm mn bi translated">还有一件事。</h1><p id="fc06" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我想在这篇文章中再补充一点。<br/>有了我们创建的类型，我们可以构建更多——让我给你举几个例子:</p><h2 id="7e88" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated"><strong class="ak">追加</strong></h2><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="a1a1" class="my lx iq mu b be mz na l nb nc">type Add&lt;L extends number, R extends number&gt; = Length&lt;<br/>  [...NumberToArray&lt;L&gt;, ...NumberToArray&lt;R&gt;]<br/>&gt;;<br/><br/><br/>type Result = Add&lt;8, 2&gt;; // 10</span></pre><h2 id="187a" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated"><strong class="ak">乘法</strong></h2><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="9006" class="my lx iq mu b be mz na l nb nc">type Mul&lt;<br/>  L extends number,<br/>  R extends number,<br/>  Result extends number = L<br/>&gt; = R extends 0<br/>  ? 0<br/>  : R extends 1<br/>  ? Result<br/>  : Mul&lt;L, Decrement&lt;R&gt;, Add&lt;Result, L&gt;&gt;;<br/><br/><br/>type Result = Mul&lt;10, 2&gt;; // 20</span></pre><h2 id="12a5" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated">分开</h2><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="5ca7" class="my lx iq mu b be mz na l nb nc">type GTE&lt;L extends number, R extends number&gt; = L extends R<br/>  ? [true, 0]<br/>  : R extends 0<br/>  ? [true, Sub&lt;L, R&gt;]<br/>  : L extends 0<br/>  ? [false, Sub&lt;R, L&gt;]<br/>  : GTE&lt;Decrement&lt;L&gt;, Decrement&lt;R&gt;&gt;;<br/><br/>type Div&lt;<br/>  L extends number,<br/>  R extends number,<br/>  Result extends number = 0<br/>&gt; = GTE&lt;L, R&gt; extends [infer IsGreater, infer Diff extends number]<br/>  ? IsGreater extends true<br/>    ? Diff extends 0<br/>      ? [Increment&lt;Result&gt;, 0]<br/>      : Div&lt;Diff, R, Increment&lt;Result&gt;&gt;<br/>    : [Result, L]<br/>  : never;<br/><br/>type GTEResult = GTE&lt;3, 2&gt;; // [true, 1] &lt;-- [isGreter: true, Diff: 1]<br/>type Result = Div&lt;10, 3&gt;; // [3, 1] &lt;-- [Quotient: 3, Remainder: 1]</span></pre><h2 id="b339" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated"><strong class="ak">电源</strong></h2><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="fc9f" class="my lx iq mu b be mz na l nb nc">type Pow&lt;<br/>  Base extends number,<br/>  Exp extends number,<br/>  Result extends number = Base<br/>&gt; = Exp extends 0<br/>  ? 1<br/>  : Exp extends 1<br/>    ? Result<br/>    : Pow&lt;Base, Decrement&lt;Exp&gt;, Mul&lt;Result, Base&gt;&gt;;<br/><br/>type Result = Pow&lt;4, 2&gt;; // 16</span></pre><h2 id="bb57" class="nr lx iq bd ly ns nt dn mc nu nv dp mg la nw nx mi le ny nz mk li oa ob mm oc bi translated">检查一个数字是否是偶数</h2><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="958c" class="my lx iq mu b be mz na l nb nc">type IsEven&lt;N extends number&gt; = ToBinary&lt;N&gt; extends `${string}0`<br/>  ? true<br/>  : false;<br/><br/>type Result = IsEven&lt;4&gt;; // true</span></pre><h1 id="8652" class="lw lx iq bd ly lz os mb mc md ot mf mg jw ou jx mi jz ov ka mk kc ow kd mm mn bi translated">警告</h1><p id="a582" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">正如我在文章开头所说的，在Typescript中有其他方法可以进行类型级数学运算，在我看来，我为本文选择的方法是最容易阅读和理解的，但是它也有一些缺点:</p><p id="c7d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将会看到，我们的一些类型，即使它们是正确的，也标有下面的错误:<code class="fe op oq or mu b">Type instantiation is excessively deep and possibly infinite.</code>为了改进这些类型，我们需要以稍微不同的方式编写它们，但是为了可读性，我更喜欢在本文中保持它们的原样。<br/>以下是我们如何改进<code class="fe op oq or mu b">Increment</code>和<code class="fe op oq or mu b">Add</code>类型的一些例子:</p><pre class="kg kh ki kj gt mt mu mv bn mw mx bi"><span id="e733" class="my lx iq mu b be mz na l nb nc">type Increment&lt;N extends number&gt; =<br/>  NumberToArray&lt;N&gt; extends infer A extends unknown[]<br/>    ? Length&lt;[...A, unknown]&gt;<br/>    : never;<br/><br/>type Add&lt;<br/>  L extends number,<br/>  R extends number<br/>&gt; = NumberToArray&lt;L&gt; extends infer LA extends unknown[]<br/>  ? NumberToArray&lt;R&gt; extends infer RA extends unknown[]<br/>    ? Length&lt;[...LA, ...RA]&gt;<br/>    : never<br/>  : never;</span></pre><p id="1c7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，它们和以前差不多，但是数组的计算被延迟了，因为我们正在推断结果。</p><p id="8ed2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无论如何，即使进行了这些优化，对大数字类型的解析也会很慢——Typescript的类型不应该以这种方式使用，这是一种黑客行为。</p><p id="672d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，我们所做的一切都不适用于非自然数。</p><h1 id="82cd" class="lw lx iq bd ly lz os mb mc md ot mf mg jw ou jx mi jz ov ka mk kc ow kd mm mn bi translated">👋结论</h1><p id="f0c8" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我真的希望你喜欢读这篇文章，我想知道你对它的看法，所以请留下评论，让我知道❤️</p><p id="4655" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我做这些高级类型时，我通常会尝试提供一个真实世界的场景，但这一次，我认为，没有，这只是对我的一个有趣的挑战，希望对你也是如此。</p><p id="c32e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我对替代解决方案和不同的方法感兴趣，所以如果你有任何想法，请随时给我发短信或写评论。</p><h1 id="0090" class="lw lx iq bd ly lz os mb mc md ot mf mg jw ou jx mi jz ov ka mk kc ow kd mm mn bi translated">🙆🏻‍♂️关于作者</h1><p id="3ea1" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我是<a class="ae lo" href="https://www.linkedin.com/company/vlk-studio/?source=about_page----------------------------------------" rel="noopener ugc nofollow" target="_blank"> VLK工作室</a>的软件工程师，目前正在从事一个名为<a class="ae lo" href="https://morfeo.dev/?source=about_page----------------------------------------" rel="noopener ugc nofollow" target="_blank"> Morfeo的开源项目。</a></p><p id="bf4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只要我能，我就在媒体上分享一些我知道的东西。</p><p id="a5a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你喜欢我做的事情，请随时支持我的工作:<a class="ae lo" href="https://medium.com/@mauro.erta/membership?source=about_page----------------------------------------" rel="noopener">https://medium.com/@mauro.erta/membership</a></p><p id="602c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者在<a class="ae lo" href="https://twitter.com/mauro_erta" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我。</p><p id="9e54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="om">更多内容看</em> <a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">说白了就是</em> </strong> </a> <em class="om">。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">免费周报</em> </strong> </a> <em class="om">。关注我们关于</em> <a class="ae lo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">推特</em> </strong> </a>，<a class="ae lo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">领英</em> </strong> </a> <em class="om">，</em><a class="ae lo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="om">YouTube</em></strong></a><em class="om">，以及</em> <a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">不和</em> </strong> </a> <em class="om">。对增长黑客感兴趣？检查</em> <a class="ae lo" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">电路</em> </strong> </a> <em class="om">。</em></p></div></div>    
</body>
</html>