<html>
<head>
<title>Component’s Lifecycle Methods in React — Detailed Clarification With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中组件的生命周期方法——用例子详细说明</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/components-lifecycle-methods-in-react-detailed-clarification-with-examples-c3c72b04f735?source=collection_archive---------3-----------------------#2022-06-19">https://javascript.plainenglish.io/components-lifecycle-methods-in-react-detailed-clarification-with-examples-c3c72b04f735?source=collection_archive---------3-----------------------#2022-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb3e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解在React组件生命周期的不同阶段提供的不同生命周期方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8c37ff76f7d869c79b1f8e7b241658e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4okhUWXFOpmJW2NJO-vNw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image created by the author on <a class="ae kv" href="http://canva.com" rel="noopener ugc nofollow" target="_blank">Canva</a></figcaption></figure><p id="707c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React为每个组件提供了几个“生命周期方法”，我们可以在整个过程中的特定时间覆盖这些方法来运行我们的代码。根据React的默认特性，它自动调用React组件当前所在的特定阶段的负责方法。我们可以操纵每种方法来更好地控制我们的组件。</p><p id="be75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件的生命周期分为以下三个部分:</p><ul class=""><li id="305a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">增加</li><li id="7788" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">更新</li><li id="db1a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">卸载</li></ul><p id="06a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个部分都有自己的方法，以特定的顺序调用。让我们了解一下在这些不同阶段可用的不同方法。</p><h1 id="2b1f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">增加</h1><p id="7050" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是React中每个组件的第一个也是最重要的阶段。<strong class="ky ir"> <em class="nd">挂载</em> </strong>这个名字很容易理解。这是初始化、创建React组件并将其插入DOM的阶段。我在下面按照调用的顺序解释了这个阶段的每个方法。</p><h2 id="3735" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">1.构造函数()</h2><p id="a510" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">实际上，构造函数是通过设置状态来初始化组件的旅程。React组件的构造函数在挂载之前被调用。<em class="nd">根据React文档，</em> <em class="nd">如果没有初始化状态，也没有绑定方法，就不需要为React组件实现构造函数。</em></p><p id="5045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现构造函数时，我们需要在任何其他语句之前调用<code class="fe nq nr ns nt b">super(props)</code>。不这样做将会声明<code class="fe nq nr ns nt b">this.props</code>未定义，并且会产生bug。我们只能在构造函数中直接使用<code class="fe nq nr ns nt b">this.state</code>。在所有其他方法中，我们需要使用this.setState()来代替。除了初始化本地状态，我们还可以将事件处理程序方法绑定到构造函数中的实例。请看下面的构造函数示例:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="2815" class="ne mh iq nt b gy ny nz l oa ob">class ContructorDemo extends React.Component {<br/>    <!-- -->constructor(props) {<br/>       super(props);<br/>       this.state = { counter: 0 }; <br/>       <strong class="nt ir"><em class="nd">// Note: </em></strong><em class="nd">Don't call this.setState() in constructor!</em><br/>       this.handleClick = this.handleClick.bind(this);<br/>    }</span></pre><h2 id="67a3" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">2.静态getDerivedStateFromProps()</h2><p id="4e97" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">getDerivedStateFromProps方法在render方法被调用之前被调用。它在初始装载和每次更新时都会调用。它将状态作为参数，并返回一个包含状态更改的对象，或者返回null不更新任何内容。下面的示例演示了静态getDerivedStateFromProps()方法:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="9ba0" class="ne mh iq nt b gy ny nz l oa ob">static getDerivedStateFromProps(props, state) {<br/>    return {counter: props.count };<br/>}</span></pre><h2 id="b8fb" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">3.渲染()</h2><p id="9c06" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">render方法是类组件中唯一的强制方法，也是将HTML实际输出到DOM的方法。当它被调用时，它检查<code class="fe nq nr ns nt b">this.props</code>和<code class="fe nq nr ns nt b">this.state</code>并返回其中一个——React元素、数组&amp;片段、门户、字符串&amp;数字、布尔值或null。请看render方法的给定示例:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="9676" class="ne mh iq nt b gy ny nz l oa ob">render() {<br/>    return (<br/>      &lt;p&gt;Current count is {this.state.counter}&lt;/p&gt;<br/>    );<br/>}</span></pre><h2 id="50c0" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">4.componentDidMount()</h2><p id="dd8b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">组件呈现后将立即调用componentDidMount方法。这些语句需要在运行之前安装一个组件，它们将被放置在此方法中。例如，从远程端点加载数据，设置任何订阅，或者希望在组件呈现后立即更改状态。请看下面给出的例子:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="da83" class="ne mh iq nt b gy ny nz l oa ob">componentDidMount() {<br/>    document.addEventListener("click", this.handleClick);<br/>}</span></pre><h1 id="3e09" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">更新</h1><p id="1499" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">组件生命周期的更新阶段是由属性或状态的变化引起的。顾名思义，在这个阶段中，React组件重新呈现，下面的方法将按照给定的顺序被调用。</p><h2 id="9e8d" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">1.静态getDerivedStateFromProps()</h2><p id="c603" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><em class="nd">这与安装中排在第二位的方法相同。</em>然而，当一个组件重新渲染时，它是第一个被调用的方法。它将使用道具的更新值，并根据它更新状态。其他的都一样。</p><h2 id="bdd4" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">2.shouldComponentUpdate()</h2><p id="0dd6" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当接收到新的道具或状态时，在呈现之前调用shouldComponentUpdate方法。初始呈现时不调用此方法。<em class="nd">shouldcomponentdupdate</em>方法用于通过仅在传递给组件的属性改变时更新组件来提高性能。它返回一个布尔值，指定React是否应该继续渲染。该方法返回的默认值是<em class="nd"> true </em>，但是，使其为<em class="nd"> false </em>将会阻止React将更改重新呈现到状态和道具中。请参见下面的示例来更改默认行为:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="19c7" class="ne mh iq nt b gy ny nz l oa ob">shouldComponentUpdate(<!-- -->nextProps<!-- -->) {<br/>    if<!-- --> <!-- -->(nextProps.value !== this.props.value) {<br/>        return<!-- --> <!-- -->true;<br/>    } <br/>    else<!-- --> <!-- -->{<br/>        return<!-- --> <!-- -->false;<br/>    }<br/>}</span></pre><h2 id="11a4" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">3.渲染()</h2><p id="6127" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">render方法将在更新阶段的第三个地方被调用。调用它来将HTML更新到DOM。该方法的其余行为和用法将保持与安装阶段相同。</p><h2 id="5d9d" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">4.getSnapshotBeforeUpdate()</h2><p id="a170" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">getSnapshotBeforeUpdate方法在最近呈现的输出提交到DOM之前被调用。它使组件能够捕捉一些以前的信息，如属性和状态，然后再进行更改。如果使用这种方法，还应该考虑使用<strong class="ky ir"><em class="nd">componentDidUpdate()</em></strong><em class="nd"/>方法。不这样做可能会导致错误，此生命周期方法返回的任何值都将作为参数传递给componentDidUpdate()。应返回一个<strong class="ky ir"> <em class="nd">快照值</em> </strong>或<strong class="ky ir"> <em class="nd">空值</em> </strong>。参见下面的代码来理解我们如何从DOM中获取信息。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="6936" class="ne mh iq nt b gy ny nz l oa ob">getSnapshotBeforeUpdate(prevProps, prevState) {    <br/>    if (prevState.counter !== this.state.counter)<br/>        return prevState.counter;<br/>    return null;<br/>}</span></pre><h2 id="7903" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">5.componentDidUpdate()</h2><p id="3fa5" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">componentDidUpdate方法在更新发生后被直接调用。初始呈现时不调用此方法。在组件被重新渲染/更新后，我们可以使用这个方法对DOM进行操作。例如，假设我们正在逐个获取每个用户的数据。我们可以比较当前的用户标识和以前的用户标识，如果用户标识已经改变，我们可以获取新用户的数据，否则什么也不做。在这种方法中使用条件时，始终将我们的操作包装在条件中是一个好习惯，否则，它会导致无限循环。请参见React文档中提到的以下示例:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="2489" class="ne mh iq nt b gy ny nz l oa ob">componentDidUpdate(prevProps) {<br/>  // Good Practice remember???<br/>  if (this.props.userID !== prevProps.userID) {<br/>    this.fetchData(this.props.userID);<br/>  }<br/>}</span></pre><h1 id="e0f6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">卸载</h1><p id="fc17" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">卸载是任何React组件的第三个也是最后一个阶段。在生命周期的这个阶段，React组件将从DOM中删除。此阶段只有一种组件生命周期方法，即:</p><h2 id="3cc6" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">componentWillUnmount()</h2><p id="a6b9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在卸载和销毁组件之前，将立即调用此方法。此方法对于执行任何清理活动都很有用，例如取消网络请求或取消订阅在<em class="nd">componentidmount()</em>中创建的任何订阅。请看下面的例子，我们正在删除componentDidMount方法中添加的事件侦听器。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="02b3" class="ne mh iq nt b gy ny nz l oa ob">componentWillUnmount() {<br/>    document.removeEventListener("click", this.handleClick);<br/>}</span></pre><h1 id="f472" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="7a53" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">本文的目的是理解React组件的生命周期。文章还详细阐述了其生命各个阶段的不同方法。此外，我试图解释每种方法的用例，这将有助于操作React的组件。我希望你喜欢这篇文章，并跟随我学习更多有趣的东西，保持更新。</p><div class="oc od gp gr oe of"><a href="https://medium.com/@kardaniyagnik/membership" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">通过我的推荐链接加入Medium-Yagnik Kardani</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://www.buymeacoffee.com/kardaniyagnik" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">Yagnik Kardani正在创建帮助他人成长的技术学习材料。</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">你好👋，我是一名媒体方面的技术作家。我喜欢学习并帮助他人在软件开发和云计算方面成长…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.buymeacoffee.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kp of"/></div></div></a></div><p id="891a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nd">plain English . io</em></strong></a><em class="nd">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nd">免费周报</em> </strong> </a> <em class="nd">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nd">Twitter</em></strong></a><em class="nd">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nd">LinkedIn</em></strong></a><em class="nd">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nd">社区不和谐</em> </strong> </a> <em class="nd">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nd">人才集体</em> </strong> </a> <em class="nd">。</em></p></div></div>    
</body>
</html>