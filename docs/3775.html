<html>
<head>
<title>The Shortest Tutorial to Learn React For a Backend Developer in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年后端开发者学习React的最短教程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-shortest-tutorial-to-learn-react-for-a-backend-developer-in-2022-51b5f02bc13c?source=collection_archive---------1-----------------------#2022-09-25">https://javascript.plainenglish.io/the-shortest-tutorial-to-learn-react-for-a-backend-developer-in-2022-51b5f02bc13c?source=collection_archive---------1-----------------------#2022-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="05ed" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分:React的3个核心维度——基本概念、组件和挂钩——帮助您快速掌握React</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8d8e230e7339ea46e3d48877a1b2b5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eoWWACJWRDhcE_w1"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@juanjodev02?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Juanjo Jaramillo</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="af8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为开发人员，我们总是想学习新的东西。作为后端开发人员，我们只需要扩展视野，不再只关注我们已经熟悉的小领域。</p><p id="8ad6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React，世界上最流行的UI框架非常庞大，需要很长时间才能学会。如果你是一个React老手，你也可以检查一下缺口，留着以后用。我相信阅读这篇文章会比浏览React文档或搜索来解决问题要快得多。</p><p id="acad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文试图从初学者的角度，围绕React的三个核心维度:<code class="fe ls lt lu lv b">basic concepts</code>、<code class="fe ls lt lu lv b">components</code>、<code class="fe ls lt lu lv b">Hooks</code>，讲解React中90%以上的实用特性和常用概念，帮助你快速掌握React。</p><p id="8f02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始最短的旅程。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="d88e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是本文的“第3部分”。如果你想知道“第一部分”或“第二部分”，这里有一个列表:</p><p id="4d25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/the-shortest-tutorial-to-learn-reactjs-for-a-backend-developer-in-2022-part-1-bd7aa96182ed"><strong class="ky ir">2022年后端开发者学习ReactJs的最短教程(第一部分:基础概念</strong> ) </a></p><p id="4571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@malvin.lok/the-shortest-tutorial-to-learn-reactjs-for-a-backend-developer-in-2022-part-2-524182a11741" rel="noopener"><strong class="ky ir">2022年后端开发者学习ReactJs的最短教程(第二部分:组件)</strong> </a></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="761d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">4.钩住</h1><p id="554e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">React 16.8版本之后，React提供了<code class="fe ls lt lu lv b">Hooks</code>机制，允许你用<code class="fe ls lt lu lv b">state</code>创建功能组件，而不是用笨重的<code class="fe ls lt lu lv b">Classes</code>创建组件。当今世界，我们应该避免使用<code class="fe ls lt lu lv b">Class</code>组件，拥抱<code class="fe ls lt lu lv b">Hooks</code>组件。</p><p id="1b66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">钩子有几个规则:</p><ul class=""><li id="a188" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">钩子以前缀开始:<code class="fe ls lt lu lv b">use</code></li><li id="b837" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">只能在React函数组件中使用</li><li id="b932" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">只能在React函数组件的顶层使用</li><li id="e734" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">不能有条件地使用</li></ul><p id="c1d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来解释一下React中的几个钩子。</p><ul class=""><li id="0153" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">使用状态</li><li id="4128" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">使用效果</li><li id="cef6" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">useRef</li><li id="8f7e" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">使用上下文</li><li id="b3bd" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">使用回调</li><li id="fa77" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">使用备忘录</li><li id="8cbb" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">用户教育</li><li id="f87a" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">useLayoutEffect</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="451b" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.1使用状态</h2><p id="858d" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">对外传递的数据称为<code class="fe ls lt lu lv b">props</code>，组件的数据称为<code class="fe ls lt lu lv b">state</code>。</p><p id="7df7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用<code class="fe ls lt lu lv b">useState</code>创建状态。</p><p id="de2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">state</code>和普通变量的区别在于，当<code class="fe ls lt lu lv b">state</code>改变时，组件将被重新渲染。</p><p id="91f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useState</code>的用法如下:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="2238" class="no me iq lv b gy oe of l og oh"><strong class="lv ir">const</strong> [stateValue, setStateValue] = <strong class="lv ir">useState</strong>(initialValue);</span></pre><p id="04a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用它需要传递一个初始值；它返回一个包含两个元素的数组，第一个是当前状态，第二个是更新状态的函数。</p><p id="c902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们调用更新状态的函数时，组件将被重新呈现。</p><p id="5d8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面举一个计数器的例子来理解<code class="fe ls lt lu lv b">useState</code>的实际用法:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="fcc6" class="no me iq lv b gy oe of l og oh">import { useState } from 'react'</span><span id="d864" class="no me iq lv b gy oi of l og oh">function Counter() {<br/>  const [count, setCount] = useState(0)<br/>  return &lt;button onClick={()=&gt; setCount(count+1)}&gt;count: {count}&lt;/button&gt;<br/>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="f367" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.2使用效果</h2><p id="8bad" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果我们需要与组件外部的东西交互，我们需要使用<code class="fe ls lt lu lv b">useEffect</code>，比如后端接口。</p><p id="ba09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useEffect</code>顾名思义，执行副作用，是存在于我们程序之外的操作，没有可预测的结果。</p><p id="c9e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useEffect</code>有两个参数，第一个是副作用函数，第二个是依赖项数组。每当依赖性数组改变时，副作用函数被重新执行。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="d9cf" class="no me iq lv b gy oe of l og oh"><strong class="lv ir">useEffect</strong>(() =&gt; {}, [])</span></pre><p id="931e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个从博客获取帖子列表数据的示例:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="e01e" class="no me iq lv b gy oe of l og oh">import { useEffect } from 'react';</span><span id="ee55" class="no me iq lv b gy oi of l og oh">function PostList() {<br/>  const [posts, setPosts] = useState([]);</span><span id="e3c2" class="no me iq lv b gy oi of l og oh">  useEffect(() =&gt; {<br/>    fetch('<a class="ae kv" href="https://jsonplaceholder.typicode.com/posts'" rel="noopener ugc nofollow" target="_blank">https://yourblog.com/posts'</a>)<br/>       .then(response =&gt; response.json())<br/>       .then(posts =&gt; setPosts(posts));<br/>   }, []);</span><span id="7b3b" class="no me iq lv b gy oi of l og oh">   return posts.map(post =&gt; &lt;div key={post.id}&gt;{post.title}&lt;/div&gt;)<br/>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="0580" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.3用户参考</h2><p id="6c4b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useRef</code>的主要用途之一就是访问元素。</p><p id="28b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">useRef</code>就像调用它一样简单，返回一个值，并通过<code class="fe ls lt lu lv b">props</code>将该值传递给React元素。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="e819" class="no me iq lv b gy oe of l og oh">function MyComponent() {<br/>  const ref = React.useRef();</span><span id="f5c7" class="no me iq lv b gy oi of l og oh">  return &lt;div ref={ref} /&gt;<br/>}</span></pre><p id="c784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦<code class="fe ls lt lu lv b">ref</code>被设置为一个元素，就可以通过<code class="fe ls lt lu lv b">ref.current</code>访问它。</p><p id="518a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在<code class="fe ls lt lu lv b">ref</code>有值之前，必须等待组件完成渲染，否则<code class="fe ls lt lu lv b">ref</code>是未定义的。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="06ab" class="no me iq lv b gy oe of l og oh">function MyComponent() {<br/>  const ref = React.useRef();<br/>  console.log(ref)// undefined<br/>  <br/>  useEffect(() =&gt; {<br/>    console.log(ref.current) //now you can get it<br/>  }, [])</span><span id="6249" class="no me iq lv b gy oi of l og oh"> return &lt;div ref={ref} /&gt;<br/>}</span></pre><p id="ec49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，注意<code class="fe ls lt lu lv b">refs</code>不能设置为组件，只能设置为元素。</p><p id="01ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想要访问组件内部的元素，我们可以使用<code class="fe ls lt lu lv b">refs</code>来转发它们。</p><p id="cc92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这通过以下方式实现:</p><ul class=""><li id="2063" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">使用<code class="fe ls lt lu lv b">React.forwardRef.</code>包装函数组件函数组件的第二个参数是<code class="fe ls lt lu lv b">ref</code>，它被设置为特定的元素。</li><li id="7451" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">使用<code class="fe ls lt lu lv b">React.createRef</code>创建一个<code class="fe ls lt lu lv b">ref</code>对象以设置到封装组件。</li></ul><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="4384" class="no me iq lv b gy oe of l og oh">const FancyButton = React.forwardRef((props, ref) =&gt; (<br/>  &lt;button ref={ref} className="FancyButton"&gt;<br/>    {props.children}<br/>  &lt;/button&gt;<br/>));</span><span id="74c0" class="no me iq lv b gy oi of l og oh">const ref = React.createRef();<br/>&lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;;</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="9ca2" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.4使用上下文</h2><p id="c71a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useContext</code>是比仅仅使用<code class="fe ls lt lu lv b">Context</code>更简单的使用<code class="fe ls lt lu lv b">Context</code>的方法。</p><p id="0704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">语法也很简单:调用<code class="fe ls lt lu lv b">useContext</code>函数并将<code class="fe ls lt lu lv b">Context</code>对象作为参数传递。</p><p id="195c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们重写原来的例子。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="a79f" class="no me iq lv b gy oe of l og oh">const UserNameContext = React.createContext('')</span><span id="92ef" class="no me iq lv b gy oi of l og oh">function App() {<br/>  const username = 'Mary'<br/>  return &lt;UserNameContext.Provider value={username}&gt;<br/>    &lt;Layout&gt;<br/>    &lt;div&gt;Hello&lt;/div&gt;<br/>  &lt;/UserNameContext.Provider&gt;<br/>}</span><span id="defe" class="no me iq lv b gy oi of l og oh">function Layout() {<br/>  return &lt;User /&gt;<br/>}</span><span id="90dd" class="no me iq lv b gy oi of l og oh">function User() {<br/>  const username = React.useContext(UserNameContext)<br/>  return &lt;h1&gt;{username}&lt;/h1&gt;<br/>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="8448" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.4使用回调</h2><p id="fb7a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useCallback</code>的目的是提高性能。</p><p id="2a88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在一个函数组件中创建了一些函数，那么每次重新渲染组件时都会重新创建这些函数，这可能会影响程序的性能。</p><p id="547d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useCallback</code>有两个参数，第一个是要缓存的函数，第二个是依赖项数组。当依赖数组中的任何值改变时，<code class="fe ls lt lu lv b">useCallback</code>重新创建函数。</p><p id="9faf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果这些函数作为参数传递给子组件，将导致子组件被重新呈现。我们可以结合使用<code class="fe ls lt lu lv b">memo</code>和<code class="fe ls lt lu lv b">useCallback</code>来减少子组件的渲染。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="c0bd" class="no me iq lv b gy oe of l og oh">function Button ({ onClick }) {<br/>  console.log("button render");<br/>  return &lt;button onClick={onClick}&gt;count++&lt;/button&gt;;<br/>};</span><span id="4c03" class="no me iq lv b gy oi of l og oh">const MemoButton = React.memo(Button);</span><span id="902e" class="no me iq lv b gy oi of l og oh">function Counter() {<br/>  const [count, setCount] = React.useState(0);<br/>  <br/>  const onClick = React.useCallback(() =&gt; {<br/>    setCount((count) =&gt; count + 1);<br/>  }, []);</span><span id="c16a" class="no me iq lv b gy oi of l og oh">return (<br/>    &lt;&gt;<br/>      &lt;p&gt;count:{count}&lt;/p&gt;<br/>      &lt;MemoButton onClick={onClick} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span><span id="1e97" class="no me iq lv b gy oi of l og oh">ReactDOM.render(&lt;Counter /&gt;, document.getElementById('app'));</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="ea36" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.5使用备忘录</h2><p id="6630" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useMemo</code>和<code class="fe ls lt lu lv b">useCallback</code>的作用相似，也用于提高性能。区别在于<code class="fe ls lt lu lv b">useCallback</code>是缓存的函数，而<code class="fe ls lt lu lv b">useMemo</code>是缓存的值。</p><p id="a12e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">渲染所需的一些变量需要计算，计算的过程可能是非常性能密集型的，因此当组件被重新渲染并且计算所需的状态没有改变时，可以再次避免。</p><p id="8024" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">useEffect</code>和<code class="fe ls lt lu lv b">useCallback</code>类似，<code class="fe ls lt lu lv b">useMemo</code>将在其依赖关系改变时重新计算值。这里有一个例子，说明如何将其应用于<code class="fe ls lt lu lv b">useCallback</code>中的例子。添加了<code class="fe ls lt lu lv b">UserInfo</code>组件，因此当<code class="fe ls lt lu lv b">Counter</code>组件中的计数改变时，<code class="fe ls lt lu lv b">UserInfo</code>不会随之更新。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="e55f" class="no me iq lv b gy oe of l og oh">function Button ({ onClick }) {<br/>  console.log("button render");<br/>  return &lt;button onClick={onClick}&gt;count++&lt;/button&gt;;<br/>};</span><span id="acb6" class="no me iq lv b gy oi of l og oh">const MemoButton = React.memo(Button);</span><span id="3f3b" class="no me iq lv b gy oi of l og oh">function UserInfo({ userInfo: { name, age } }) {<br/>  console.log('UserInfo render')<br/>  return &lt;div&gt;<br/>    &lt;p&gt;{name}&lt;/p&gt;<br/>    &lt;p&gt;{age}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>}</span><span id="253f" class="no me iq lv b gy oi of l og oh">const MemoUserInfo = React.memo(UserInfo)</span><span id="8d91" class="no me iq lv b gy oi of l og oh">function Counter() {<br/>  const [count, setCount] = React.useState(0);<br/>  const [name, setUsername] = React.useState('Mary');<br/>  <br/>  const onClick = React.useCallback(() =&gt; {<br/>    setCount((count) =&gt; count + 1);<br/>  }, []);<br/>  <br/>  const userInfo = React.useMemo(() =&gt; {<br/>    return {<br/>      name,<br/>      age: 15<br/>    }<br/>  }, [name])</span><span id="59a6" class="no me iq lv b gy oi of l og oh">return (<br/>    &lt;&gt;<br/>      &lt;MemoUserInfo userInfo={userInfo} /&gt;<br/>      &lt;p&gt;count:{count}&lt;/p&gt;<br/>      &lt;MemoButton onClick={onClick} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span><span id="da96" class="no me iq lv b gy oi of l og oh">ReactDOM.render(&lt;Counter /&gt;, document.getElementById('app'));</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="7527" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.6用户</h2><p id="ccdd" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useReducer</code>是替代<code class="fe ls lt lu lv b">useState</code>的钩子，用于处理复杂的状态逻辑。</p><p id="def6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你用过<code class="fe ls lt lu lv b">redux</code>，你会很熟悉。</p><p id="7178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它需要两个参数，第一个是<code class="fe ls lt lu lv b">reducer</code>，第二个是初始状态。</p><p id="d173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它返回一个包含两个元素的数组，第一个元素是当前状态，第二个元素是改变状态的调度函数。这与useState非常相似。</p><p id="612a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">reducer</code>是一个带两个参数的函数，当前的<code class="fe ls lt lu lv b">state</code>和用于改变<code class="fe ls lt lu lv b">state</code>的<code class="fe ls lt lu lv b">action</code>，并返回新的<code class="fe ls lt lu lv b">state</code>。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="1e47" class="no me iq lv b gy oe of l og oh">onst initialState = 0</span><span id="5a94" class="no me iq lv b gy oi of l og oh">const reducer = (state, action) =&gt; {<br/>  switch (action) {<br/>    case 'increment':<br/>      return state + 1<br/>    case 'decrement':<br/>      return state - 1<br/>    case 'reset':<br/>      return initialState<br/>    default:<br/>      return state<br/>  }<br/>}</span><span id="43d0" class="no me iq lv b gy oi of l og oh">function Counter() {<br/>  const [count, dispatch] = React.useReducer(reducer, initialState)<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;Count: {count}&lt;/div&gt;<br/>      &lt;button onClick={() =&gt; dispatch('increment')}&gt;ADD&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch('decrement')}&gt;DECREASE&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch('reset')}&gt;RESET&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="07f4" class="no me iq lv b gy oi of l og oh">ReactDOM.render(&lt;Counter /&gt;, document.getElementById('app'));</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="a530" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.7使用延迟效果</h2><p id="fad4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useLayoutEffect</code>和<code class="fe ls lt lu lv b">useEffect</code>的唯一区别是执行的时间不同。<code class="fe ls lt lu lv b">useLayoutEffect</code>是在浏览器完成绘制和布局后执行的，所以<code class="fe ls lt lu lv b">useLayoutEffect</code>可以防止页面闪烁。</p><p id="1dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最常见的一种情况就是<code class="fe ls lt lu lv b">state</code>更新一次，触发效果的回调函数再次更新<code class="fe ls lt lu lv b">state</code>，导致短时间内连续两次<code class="fe ls lt lu lv b">state</code>更新。这可以通过使用下面的主动截止时间倒计时程序来理解。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="3aec" class="no me iq lv b gy oe of l og oh">function useInterval(callback, delay) {<br/>  const savedCallback = React.useRef();</span><span id="00c9" class="no me iq lv b gy oi of l og oh">React.useEffect(() =&gt; {<br/>    savedCallback.current = callback;<br/>  });</span><span id="b2fc" class="no me iq lv b gy oi of l og oh">React.useEffect(() =&gt; {<br/>    function tick() {<br/>      savedCallback.current();<br/>    }<br/>    if (delay !== null) {<br/>      let id = setInterval(tick, delay);<br/>      return () =&gt; clearInterval(id);<br/>    }<br/>  }, [delay]);<br/>}</span><span id="7f1d" class="no me iq lv b gy oi of l og oh">function Draw() {<br/>  const [countdown, setCountdown] = React.useState(3)</span><span id="e113" class="no me iq lv b gy oi of l og oh">  useInterval(()=&gt; setCountdown(countdown - 1), 1000)<br/>  <br/>  React.useLayoutEffect(() =&gt; {<br/>    if(countdown &lt;= 0) {<br/>      setCountdown(3)<br/>    }<br/>  }, [countdown])<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;deadline countdown：{countdown} s&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="5125" class="no me iq lv b gy oi of l og oh">ReactDOM.render(&lt;Draw /&gt;, document.getElementById('app'));</span></pre><p id="2ee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">活动倒计时每秒减少1秒，当减少到0秒时重置为3秒。</p><p id="7172" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在倒计时设置为0时使用<code class="fe ls lt lu lv b">useEffect</code>，页面会重新渲染，倒计时会立即再次设置为3，导致页面在很短的时间内渲染两次。</p><p id="b569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useLayoutEffect</code>在很多场景下不使用，而且会阻碍渲染。这通常可以通过业务逻辑来避免。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="c3c6" class="no me iq bd mf np nq dn mj nr ns dp mn lf nt nu mp lj nv nw mr ln nx ny mt nz bi translated">4.8自定义<code class="fe ls lt lu lv b">Hook</code></h2><p id="0b42" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们可以根据需要定制<code class="fe ls lt lu lv b">Hook</code>，<code class="fe ls lt lu lv b">Hook</code>用于逻辑复用。</p><p id="2ef5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定制<code class="fe ls lt lu lv b">Hook</code>时有几个条件需要注意:</p><ul class=""><li id="7c14" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">钩子是一个以<code class="fe ls lt lu lv b">use</code>开始的函数。</li><li id="57a4" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">其他的<code class="fe ls lt lu lv b">Hook</code>可以在函数内部调用</li></ul><p id="c550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useLayoutEffect</code>中的例子使用了自定义<code class="fe ls lt lu lv b">Hook</code>“使用间隔”:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="5d09" class="no me iq lv b gy oe of l og oh">function useInterval(callback, delay) {<br/>  const savedCallback = React.useRef();</span><span id="d7fa" class="no me iq lv b gy oi of l og oh">  // saving the new callback<br/>  React.useEffect(() =&gt; {<br/>    savedCallback.current = callback;<br/>  });</span><span id="b56b" class="no me iq lv b gy oi of l og oh">  // establish interval<br/>  React.useEffect(() =&gt; {<br/>    function tick() {<br/>      savedCallback.current();<br/>    }<br/>    if (delay !== null) {<br/>      let id = setInterval(tick, delay);<br/>      return () =&gt; clearInterval(id);<br/>    }<br/>  }, [delay]);<br/>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="3d2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。当你作为后端工程师第一次尝试学习React时，这里有三个关于React的基本概念。</p><p id="c22f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我知道，当你看到这篇文章的时候，你会承认，尤其是关于钩子的第三部分。不过没关系，你可以慢慢来。把这篇文章当作一个小字典，当你看到一些你不知道的东西或者你想知道的东西时，请便，用你今天学到的术语搜索更多的信息。</p><p id="1b82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我叫马尔文，是一名后端开发者，想成为全栈开发者。</p><p id="355d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次见。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="a66d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oj">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oj">plain English . io</em></strong></a><em class="oj">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oj">免费周报</em> </strong> </a> <em class="oj">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oj">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oj">LinkedIn</em></strong></a><em class="oj"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oj">YouTube</em></strong></a><em class="oj"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oj">不和</em> </strong> </a> <em class="oj">。对增长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oj">电路</em> </strong> </a> <em class="oj">。</em></p></div></div>    
</body>
</html>