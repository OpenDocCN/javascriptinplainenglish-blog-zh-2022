<html>
<head>
<title>How React Officially Tests React18 Concurrency Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React如何正式测试React18并发特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-react-officially-tests-react18-concurrency-features-33f428de13b?source=collection_archive---------13-----------------------#2022-08-22">https://javascript.plainenglish.io/how-react-officially-tests-react18-concurrency-features-33f428de13b?source=collection_archive---------13-----------------------#2022-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4382" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">下面是React团队如何测试并发特性。</h2></div><p id="b37f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React18已经在你的雷达上有一段时间了，但是你试过“并发特性”吗？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/ef525f2540eeab7cc9d3b71c806af946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7DEDJNjQ78gTJJEr"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@arthurhick?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arthur Hickinbotham</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a210" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当启用并发时，对从“同步更新”到“异步、优先、可中断更新”的变化做出反应。这也使得编写单元测试有点困难。在本文中，我们将讨论React团队如何测试并发特性。</p><p id="86ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">困境</strong> <br/>面临两个主要问题:</p><h2 id="bdde" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">1.渲染结果怎么表达？</h2><p id="b407" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">React可以与来自各种主机环境的渲染器进行通信。最熟悉的渲染器是ReactDOM，用于与“浏览器”和“节点环境”(SSR)接口。对于某些场景，ReactDOM的输出可用于测试。例如，下面是一个使用ReactDOM输出的“无状态组件的渲染结果是否符合预期”的测试(测试框架是jest)。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="74ca" class="ls lt iq mr b gy mv mw l mx my">it('should render stateless component', () =&gt; {<br/>  const el = document.createElement('div');<br/>  ReactDOM.render(&lt;FunctionComponent name="A" /&gt;, el);<br/>  expect(el.textContent).toBe('A');<br/>});</span></pre><p id="bcdd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个缺点，因为这个用例依赖于DOM API和浏览器环境(例如document.createElement)。不言而喻，混合关于主机环境的信息会使测试用例更难构建，例如“React的内部运行时机制”</p><h2 id="dce4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">2.如何测试并发环境？</h2><p id="ad00" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">如果在上面的用例中将ReactDOM.render更改为ReactDOM.createRoot，那么这个用例将会失败。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="7f9c" class="ls lt iq mr b gy mv mw l mx my"><em class="mz">// before</em><br/>ReactDOM.render(&lt;FunctionComponent name="A" /&gt;, el);<br/>expect(el.textContent).toBe('A');<br/><br/><em class="mz">// after</em><br/>ReactDOM.createRoot(el).render(&lt;FunctionComponent name="A" /&gt;);<br/>expect(el.textContent).toBe('A');</span></pre><p id="c85d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为在新的架构下，很多以前的“同步更新”变成了“并发更新”，执行render时页面仍然在呈现。使上述用例起作用的最简单的方法是编辑</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="8ab7" class="ls lt iq mr b gy mv mw l mx my">ReactDOM.createRoot(el).render(&lt;FunctionComponent name="A" /&gt;);<br/><br/>setTimeout(() =&gt; {<br/>  <em class="mz">// </em>synchronous<br/>  expect(el.textContent).toBe('A');<br/>})</span></pre><p id="cf02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你如何优雅地应对这种变化？</p><h2 id="3698" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">React的应对策略</h2><p id="a177" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">React团队的反应是我们要检查的下一件事。</p><p id="083f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从解决第一个查询开始:渲染结果应该如何表示？</p><p id="f0da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与与本机环境兼容的ReactNative相反，ReactDOM对应于浏览器和节点环境。</p><p id="9e40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们能否创建一个专门用于检查“内部运行时流”的渲染器呢？</p><p id="243b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，这就是答案。</p><p id="c7f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React-Noop-Renderer是该渲染器的名称。</p><p id="bdb0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单来说，这个渲染器只会渲染JS对象。</p><h2 id="47e3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">实现渲染器</h2><p id="1eff" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">React有一个内部包叫Reconciler，里面引用了一些“操纵主机环境”的API。</p><p id="22b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，下面的方法用于“将节点插入容器”。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="eb1f" class="ls lt iq mr b gy mv mw l mx my">function appendChildToContainer(child, container) {<br/> <em class="mz">// </em>Implement<br/>}</span></pre><p id="2300" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于浏览器环境(ReactDOM)，这是使用appendChild方法实现的。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="19a1" class="ls lt iq mr b gy mv mw l mx my">function appendChildToContainer(child, container) {<br/>  container.appendChild(child);<br/>}</span></pre><p id="256d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Reconciler包通过rollup工具与上面的“用于浏览器环境的API”打包在一起，就是ReactDOM包。在React-Noop-Renderer中，ReactDOM中的DOM节点与以下数据结构对齐。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="2108" class="ls lt iq mr b gy mv mw l mx my">const instance = {<br/>  id: instanceCounter++,<br/>  type: type,<br/>  children: [],<br/>  parent: -1,<br/>  props<br/>};</span></pre><p id="cc64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意children字段，它用于保存子节点。因此，appendChildToContainer方法可以在React-Noop-Renderer中实现，简单如下:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="eb3a" class="ls lt iq mr b gy mv mw l mx my">function appendChildToContainer(child, container) {<br/> const index = container.children.indexOf(child);<br/> if (index !== -1) {<br/>  container.children.splice(index, 1);<br/> }<br/> container.children.push(child);<br/>};</span></pre><p id="e44f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打包工具将Reconciler包与上面的“React-Noop的API”打包，这是React-Noop-Renderer包。基于React-Noop-Renderer，您可以完全在正常的主机环境之外测试Reconciler的内部逻辑。接下来，我们来看第二个问题。</p><h2 id="1f57" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">如何测试并发环境？</h2><p id="1724" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">再复杂的“并发特性”，说到底也不过是“异步执行代码的各种策略”，最终执行它们的API无非就是setTimeout、setInterval、Promise等等。简而言之，您可以模拟这些异步API并控制它们的执行时间。例如，在上面的异步代码中，React中的测试用例如下所示:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="9b4b" class="ls lt iq mr b gy mv mw l mx my">await act(() =&gt; {<br/>  ReactDOM.createRoot(el).render(&lt;FunctionComponent name="A" /&gt;);<br/>})<br/>expect(el.textContent).toBe('A');</span></pre><p id="a889" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">act方法，他的内部将执行jest.runOnlyPendingTimers方法，以便所有等待的计时器触发回调。例如，下面的代码:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="8afb" class="ls lt iq mr b gy mv mw l mx my">setTimeout(() =&gt; {<br/>  console.log('go');<br/>}, 9999999)</span></pre><p id="f3bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">jest.runOnlyPendingTimers将在执行后立即打印“Execute”。这样，React并发更新的速度就被人为控制了，对框架代码的入侵为零。此外，用于驱动并发更新的调度器模块本身也有一个测试版本。在这个版本中，开发人员可以手动控制调度程序的输入和输出。例如，我想测试组件卸载时useEffect回调的执行顺序。如下面的代码所示，其中Parent是挂载的“被测组件”。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="4a7d" class="ls lt iq mr b gy mv mw l mx my">function Parent() {<br/>  useEffect(() =&gt; {<br/>    return () =&gt; Scheduler.unstable_yieldValue('Unmount parent');<br/>  });<br/>  return &lt;Child /&gt;;<br/>}<br/><br/>function Child() {<br/>  useEffect(() =&gt; {<br/>    return () =&gt; Scheduler.unstable_yieldValue('Unmount child');<br/>  });<br/>  return 'Child';<br/>}<br/><br/>await act(async () =&gt; {<br/>  root.render(&lt;Parent /&gt;);<br/>});</span></pre><p id="c9f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">useEffect的逻辑是否如预期，可以通过yieldValue的插入顺序是否如预期来确定。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="f073" class="ls lt iq mr b gy mv mw l mx my">expect(Scheduler).toHaveYielded(['Unmount parent', 'Unmount child']);</span></pre><h2 id="b66c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">在React中编写测试用例的策略是</h2><ul class=""><li id="0dd4" class="na nb iq kh b ki ml kl mm ko nc ks nd kw ne la nf ng nh ni bi translated">可以用ReactDOM度量的用例，一般结合ReactDOM和ReactTestUtils(浏览器环境的一个helper方法)来完成。</li><li id="d21e" class="na nb iq kh b ki nj kl nk ko nl ks nm kw nn la nf ng nh ni bi translated">需要控制中间进程的用例，使用Scheduler的测试包，使用Scheduler.unstable_yieldValue记录进程信息。</li><li id="bfe9" class="na nb iq kh b ki nj kl nk ko nl ks nm kw nn la nf ng nh ni bi translated">如果你想在宿主环境之外单独测试React的内部进程，使用React-Noop-Renderer。</li><li id="b0f5" class="na nb iq kh b ki nj kl nk ko nl ks nm kw nn la nf ng nh ni bi translated">要测试并发场景，您需要将上述工具与jest-react结合使用。</li></ul><p id="3e7f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想了解更多React中测试相关的技巧，可以看看<a class="ae lr" href="https://www.npmjs.com/package/anujs" rel="noopener ugc nofollow" target="_blank"> RubyLouvre的作品anu </a>。</p><p id="14a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个类似React的框架，但是可以运行800多个React用例。内部实现了ReactTestUtils的简化版本React-Noop-Renderer。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="e537" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="mz">欢迎关注我上</em></strong><a class="ae lr" href="https://twitter.com/yanghui0324" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mz">Twitter</em></strong></a><strong class="kh ir"><em class="mz"/></strong><a class="ae lr" href="https://www.linkedin.com/in/hui-yang-075076245/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mz">LinkedIn</em></strong></a><strong class="kh ir"><em class="mz">，以及</em></strong><a class="ae lr" href="https://github.com/guchen-yh" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mz">GitHub</em></strong><strong class="kh ir"><em class="mz">！</em> </strong></a></p><p id="bb40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">写作一直是我的激情所在，它给了我帮助和激励他人的快乐。如果您有任何问题，请随时联系我们！ </p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="58c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">更多内容看</em> <a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mz">说白了就是</em> </strong> </a> <em class="mz">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mz">免费周报</em> </strong> </a> <em class="mz">。关注我们关于</em> <a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mz">推特</em> </strong> </a>，<a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mz">LinkedIn</em></strong></a><em class="mz">，</em><a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mz">YouTube</em></strong></a><em class="mz">，以及</em> <a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mz">不和</em> </strong></a></p></div></div>    
</body>
</html>