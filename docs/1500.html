<html>
<head>
<title>Deep-Dive into JavaScript Closures: A Step-by-Step Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究JavaScript闭包:分步教程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deep-dive-into-javascript-closures-a-step-by-step-tutorial-89cf0731a4c5?source=collection_archive---------7-----------------------#2022-03-29">https://javascript.plainenglish.io/deep-dive-into-javascript-closures-a-step-by-step-tutorial-89cf0731a4c5?source=collection_archive---------7-----------------------#2022-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b9c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从理论和实践的角度理解闭包。</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/92865c6b7d35a8c883701feab185650d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vrBUUmouzrIhvHeokfIw0g.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Image created by myself</figcaption></figure><blockquote class="kr ks kt"><p id="e96b" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你好，如果你想自己体验媒介，请考虑<strong class="kx ir">支持</strong>我和所有其他作家，注册一个<a class="ae lr" href="https://medium.com/@anton.franzen/membership" rel="noopener"> <strong class="kx ir">会员</strong> </a>每月5美元，以保持独立写作的活力，<a class="ae lr" href="https://medium.com/@anton.franzen/membership" rel="noopener"> <strong class="kx ir">在这里注册；)</strong> </a></p><p id="37ee" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了支持他人，Medium还可以通过写作和在这里找到家的强大、积极参与的社区来支持你。</p></blockquote><p id="638a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">这个主题可能会很混乱，因为关于它是什么有如此不同的解释，而且它对JavaScript开发人员来说也很神秘，因为它一直在使用，但没有多少人知道它到底是如何工作的。</p><p id="4c5f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我最近拿起了第二版的<code class="fe lv lw lx ly b">You Dont Know JS Yet</code>来填补我知识上的一些空白，在那里他谈到了闭包，我认为它非常有意义，尽管我已经知道什么是闭包，我从另一个角度了解了它的内部工作。所以在这篇文章中，我将从我的角度解释闭包是如何工作的以及它们是如何被使用的！</p><p id="09e9" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir">我们将复习的内容:</strong></p><ol class=""><li id="e920" class="lz ma iq kx b ky kz lb lc ls mb lt mc lu md lq me mf mg mh bi translated">闭包的定义</li><li id="8039" class="lz ma iq kx b ky mi lb mj ls mk lt ml lu mm lq me mf mg mh bi translated">闭包的简单解释</li><li id="3f01" class="lz ma iq kx b ky mi lb mj ls mk lt ml lu mm lq me mf mg mh bi translated">一个闭包的深层解释</li></ol><blockquote class="kr ks kt"><p id="441a" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你好！你想每周在邮箱里收到 <strong class="kx ir"> <em class="iq">独家</em> </strong> <em class="iq">关于</em><strong class="kx ir"><em class="iq">full stack JavaScript开发</em> </strong> <em class="iq">的内容、技巧和窍门吗？点击</em> <strong class="kx ir"> <em class="iq">此处</em> </strong> <em class="iq">免费访问。</em></p></blockquote><p id="beb9" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir"> 1。首先让我们看看</strong> <code class="fe lv lw lx ly b">mdn</code> <strong class="kx ir">对闭包的定义:</strong></p><blockquote class="kr ks kt"><p id="7189" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">闭包是对其周围状态(词法环境)的引用捆绑在一起(封闭)的函数的组合。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。</em></p></blockquote><p id="1818" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">好的，我们可以把它看作是另一个函数内部的一个函数，这个函数可以访问外部函数的变量，是的，这没有多大意义，但是如果你看下面的代码，它可能会这样做:</p><pre class="kf kg kh ki gt mn ly mo mp aw mq bi"><span id="4a37" class="mr ms iq ly b gy mt mu l mv mw">function outer() {<br/>const outerVariable = "Hey!"<br/>function inner() {<br/>console.log(outerVariable)<br/>}<br/>inner()<br/>}<br/>outer() // "Hey!"</span></pre><p id="02d0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">正如我们看到的函数<code class="fe lv lw lx ly b">inner</code>可以访问变量<code class="fe lv lw lx ly b">outerVariable</code></p><p id="d4d3" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">这是因为当我们调用函数<code class="fe lv lw lx ly b">outer</code>时，函数<code class="fe lv lw lx ly b">outer</code>创建了一个名为<code class="fe lv lw lx ly b">outerVariable</code>的局部变量和一个函数<code class="fe lv lw lx ly b">inner</code>，所以函数<code class="fe lv lw lx ly b">inner</code>可以访问这个变量。</p><p id="75bb" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">所有的函数都在创建阶段创建一个<code class="fe lv lw lx ly b">closure</code>，我们将在后面讨论，但是我们上面的例子并没有真正使用<code class="fe lv lw lx ly b">closure</code>功能。</p><p id="76d0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">只是快速解释一下不同范围的行话会让你感到困惑:</p><blockquote class="kr ks kt"><p id="7638" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="iq">范围:</em> </strong></p><p id="3c6a" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">作用域是当前执行的上下文，作用域在哪里执行？是全局执行吗？那么作用域是全局的，是函数执行吗？那么这个范围就是局部范围。</em></p><p id="18a5" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="iq">局部范围:</em> </strong></p><p id="217f" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">局部作用域如果我们在函数内部声明一个变量，那么它就在该函数的局部作用域内。Short:是指我们的代码中可以访问的受限区域。</em></p><p id="b18b" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="iq">全局范围:</em> </strong></p><p id="93ff" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">全局作用域是指在我们文件的根中声明的变量，意思是不在任何其他作用域内。</p></blockquote><p id="a0fe" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我希望这有意义，这只是经典的范围和可访问性的东西。</p><p id="7a64" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在让我们更深入地了解一下确切的闭包是什么，尽管我们刚刚写了一个闭包。</p><h1 id="98b1" class="mx ms iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">2.闭包的简单解释</h1><p id="47e8" class="pw-post-body-paragraph ku kv iq kx b ky no jr la lb np ju ld ls nq lg lh lt nr lk ll lu ns lo lp lq ij bi translated">我是这样看待什么是终结的:</p><blockquote class="kr ks kt"><p id="94cd" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">闭包是指函数可以访问自己作用域之外的变量，并随着时间的推移记住它们，即使该函数是从另一个作用域执行的。</em></p></blockquote><p id="2741" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我是从上面提到的那本书里得到这个观点的。</p><p id="4498" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">让我们弄清楚:闭包在JavaScript中无处不在。</p><p id="8788" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">例如，这个<em class="kw">是</em>一个闭包:</p><pre class="kf kg kh ki gt mn ly mo mp aw mq bi"><span id="355b" class="mr ms iq ly b gy mt mu l mv mw">function closure(args){<br/>return function inner(){<br/>return args<br/>}<br/>}<br/>const x = 10;<br/>const useClosure = closure(x)<br/>useClosure()</span></pre><p id="5369" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">没有必要做复杂的例子来理解什么是结束，我刚刚做的就是一个结束，就是这样…</p><p id="eae1" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">但是为了深入理解它，我们需要进入更复杂的例子。</p><p id="740c" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">但还是继续说这个简单的例子吧。</p><p id="1e2f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">函数<code class="fe lv lw lx ly b">inner</code>正在关闭函数<code class="fe lv lw lx ly b">closure</code>的执行上下文环境，<em class="kw">我们将在后面详细讨论！</em></p><p id="9992" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">这就给我们留下了之前说过的定义:</p><p id="df3d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">闭包是一个函数，它可以访问其作用域之外的变量，并且可以从另一个作用域调用。</p><h1 id="107c" class="mx ms iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">3.一个闭包的深层解释</h1><p id="2c45" class="pw-post-body-paragraph ku kv iq kx b ky no jr la lb np ju ld ls nq lg lh lt nr lk ll lu ns lo lp lq ij bi translated">在深入研究之前，我们需要了解javascript中的全局执行上下文。</p><p id="94cb" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">Javascript有两个全局执行上下文阶段，一个创建阶段和一个执行阶段。因此，当我们运行javascript文件时，将执行全局执行上下文，这是第一个阶段，即创建阶段。</p><blockquote class="kr ks kt"><p id="5968" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="iq">创作阶段:</em> </strong></p><p id="413a" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">创建了</em> <strong class="kx ir"> <em class="iq">窗口</em> </strong> <em class="iq"> </em> <strong class="kx ir"> <em class="iq">对象</em></strong><em class="iq"/><strong class="kx ir"><em class="iq">这个</em> </strong> <em class="iq">关键字就是指窗口对象。</em></p><p id="f9ec" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">赋值</em> <strong class="kx ir"> <em class="iq">未定义</em> </strong> <em class="iq">给所有</em> <strong class="kx ir"> <em class="iq">变量</em></strong><em class="iq">&amp;</em><strong class="kx ir"><em class="iq">函数</em> </strong> <em class="iq">用</em><strong class="kx ir"><em class="iq">var</em></strong><em class="iq">关键字声明，这叫做</em><strong class="kx ir"><em class="iq"/></strong><em class="iq">。</em></p><p id="8169" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">为</em> <strong class="kx ir"> <em class="iq">全局作用域</em> </strong> <em class="iq">中的所有</em> <strong class="kx ir"> <em class="iq">函数声明</em> </strong> <em class="iq">创建内存。</em></p><p id="7ca3" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="iq">执行阶段:</em> </strong></p><p id="e7a1" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">从上到下逐行执行javascript文件。</em></p><p id="ee3e" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">将</em> <strong class="kx ir"> <em class="iq">值</em> </strong> <em class="iq">赋值给我们的</em> <strong class="kx ir"> <em class="iq">变量</em></strong><em class="iq"/><strong class="kx ir"><em class="iq">函数表达式</em> </strong> <em class="iq">等。</em></p></blockquote><p id="8509" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在有1个最后的执行阶段，称为<strong class="kx ir">函数执行上下文</strong>。</p><blockquote class="kr ks kt"><p id="1994" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="iq">功能执行上下文:</em> </strong></p><p id="eef8" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">创建一个</em> <strong class="kx ir"> <em class="iq">参数</em></strong><em class="iq"/><strong class="kx ir"><em class="iq">对象</em> </strong> <em class="iq">。</em></p><p id="e588" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">创建一个</em> <strong class="kx ir"> <em class="iq">对象</em> </strong> <em class="iq">称为</em> <strong class="kx ir"> <em class="iq">这个</em> </strong></p><p id="b52a" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">赋值</em> <strong class="kx ir"> <em class="iq">未定义</em> </strong> <em class="iq">给所有</em> <strong class="kx ir"> <em class="iq">变量</em></strong><em class="iq">&amp;</em><strong class="kx ir"><em class="iq">函数</em> </strong> <em class="iq">用</em><strong class="kx ir"><em class="iq">var</em></strong><em class="iq">关键字声明，这就叫</em></p><p id="72ae" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">为</em> <strong class="kx ir"> <em class="iq">局部范围内的所有</em> <strong class="kx ir"> <em class="iq">函数声明</em> </strong> <em class="iq">创建内存。</em>T171】</strong></p></blockquote><p id="bd96" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">函数执行上下文仅在函数被调用时创建，仅在函数被调用时创建。</p><p id="5204" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">当函数被调用时，它被推到<strong class="kx ir">调用栈</strong>并创建变量，但是一旦函数<strong class="kx ir">返回</strong>，它就被<strong class="kx ir">从<strong class="kx ir">调用栈</strong>中弹出</strong>，并且变量不再存在，这就是为什么我们不能访问它所在的局部范围之外的变量。</p><p id="3c3a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在，当我们解决了这个问题，让我们再次回到闭包。</p><p id="6721" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">每个函数<strong class="kx ir">在<strong class="kx ir">创建阶段</strong>都会创建一个闭包</strong>，但是要真正使用<strong class="kx ir">闭包</strong>的<strong class="kx ir">特性</strong>，我们能做的就是<strong class="kx ir">在函数中返回</strong>一个<strong class="kx ir">内部函数</strong>，并且<strong class="kx ir">内部函数</strong>会在<strong class="kx ir">父函数执行上下文环境</strong>上创建一个<strong class="kx ir">闭包作用域</strong>。这样我们通过<strong class="kx ir">作用域链</strong>让<strong class="kx ir">访问</strong>到<strong class="kx ir">参数</strong>和<strong class="kx ir">变量</strong>。</p><h1 id="295c" class="mx ms iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">关键点:</h1><pre class="kf kg kh ki gt mn ly mo mp aw mq bi"><span id="3e59" class="mr ms iq ly b gy mt mu l mv mw">function first(args){<br/>const foo = args<br/>return function inner(){<br/>return foo<br/>}<br/>}<br/>const a = first(10)<br/>a() // will return 10</span></pre><p id="a236" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">当我们<strong class="kx ir">调用</strong>上面的<strong class="kx ir">函数</strong>时，会发生这种情况:</p><p id="da6b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir">函数创建阶段:</strong>创建一个<strong class="kx ir">自变量</strong> <strong class="kx ir">对象</strong>，<strong class="kx ir">该对象</strong>，将<strong class="kx ir">变量</strong>赋值给<strong class="kx ir">变量</strong>未定义的<strong class="kx ir">，将<strong class="kx ir">函数声明</strong>添加到<strong class="kx ir">内存中。</strong></strong></p><p id="6afe" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir">函数执行阶段:</strong>它被推送到<strong class="kx ir">调用栈</strong>，将<strong class="kx ir">值</strong>赋给<strong class="kx ir">变量</strong>、<strong class="kx ir">函数表达式、</strong>等，从上到下运行函数中的代码，一旦到达底部，它将返回，<strong class="kx ir">将</strong>弹出<strong class="kx ir">调用栈</strong>并将函数中的所有内容<strong class="kx ir">但是:</strong></p><p id="75fd" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">内部函数是<strong class="kx ir">在<strong class="kx ir">父函数执行上下文环境上关闭</strong>:</strong>即使<code class="fe lv lw lx ly b">variable</code> <code class="fe lv lw lx ly b">a</code>只是持有函数<code class="fe lv lw lx ly b">inner</code><code class="fe lv lw lx ly b">inner</code>该函数可以访问父函数执行上下文，因为<code class="fe lv lw lx ly b">inner</code>函数在父函数执行上下文环境上创建了一个闭包，所以我们可以访问在函数范围内声明的参数和变量。</p><p id="695a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">关于闭包和它们是什么有很多解释，这是我的，我也可能是错的，所以如果你认为这里有什么完全错了，请评论；)</p><h1 id="c876" class="mx ms iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">你可能也会喜欢:</h1><div class="nt nu gp gr nv nw"><a href="https://betterprogramming.pub/callbacks-vs-promises-vs-async-await-a-step-by-step-guide-f93d13447604" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">回调vs .承诺vs .异步Await:逐步指南</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">引擎盖下也有点。</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">better编程. pub</p></div></div><div class="of l"><div class="og l oh oi oj of ok kl nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://betterprogramming.pub/ec6-magic-you-wish-you-knew-8494da448866" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">3个简洁的Ec6技巧，加快编码速度</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">你希望知道的魔法</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">better编程. pub</p></div></div><div class="of l"><div class="ol l oh oi oj of ok kl nw"/></div></div></a></div><p id="cdfa" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><em class="kw">更多内容请看</em><a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="kw">plain English . io</em></strong></a><em class="kw">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="kw">免费周报</em> </strong> </a> <em class="kw">。关注我们关于</em><a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="kw">Twitter</em></strong></a><em class="kw">和</em><a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="kw">LinkedIn</em></strong></a><em class="kw">。加入我们的</em> <a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="kw">社区不和谐</em> </strong> </a> <em class="kw">。</em></p></div></div>    
</body>
</html>