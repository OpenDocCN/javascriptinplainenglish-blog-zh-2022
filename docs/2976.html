<html>
<head>
<title>Lift State Up or Push State Down in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中提升状态还是下推状态？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lift-state-up-or-push-state-down-in-react-2b592cc5dbaf?source=collection_archive---------9-----------------------#2022-07-19">https://javascript.plainenglish.io/lift-state-up-or-push-state-down-in-react-2b592cc5dbaf?source=collection_archive---------9-----------------------#2022-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fb1c00172e9f41981f251972244706c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adsUt5GFM6u8DsHBFtkn9Q.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">State management in React</figcaption></figure><p id="4998" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">React中的状态管理并不总是一项简单的任务。React提供了强大而简单的存储状态的方法，但是随着应用程序的增长，需要仔细考虑数据流。</p><p id="ddef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文不是关于使用什么状态管理工具，因为React本身就是一个强大而充分的状态管理工具，而是关于在React应用程序中何处存储状态。</p><p id="4324" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我描述存储状态的两种主要方法之前，重要的是要问我们自己:我们正在处理什么类型的状态？我们还应该问问自己，React组件被分配了哪些职责。</p><p id="2f6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">描述状态类型的一种简单方式是，关于UI的本地信息应该保存在本地状态中，而需要跨组件共享的信息应该被提升。虽然这是真的，但这是React应用程序的一个非常简化的版本。</p><p id="1b28" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看一个不需要共享状态的例子:</p><h2 id="6e3c" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">1.将状态向下推</h2><p id="4db2" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">假设我们有一个窗口组件，其职责是允许用户输入文本值，然后允许用户通过单击“保存”按钮来保存该值。</p><p id="61f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该组件可能如下所示:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="14a8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们假设父组件需要这个文本值。第一个立即想到的想法是“让我们提升这个状态，因为这个状态需要被我们的父母分享”。这将是一个有效的解决方案，但在全局公开状态之前，我们应该三思。一般来说，只要不需要公开数据，数据就应该保持封装状态。此外，软件组件不应该太了解其他软件组件的内部实现细节。</p><p id="e2c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，我们实际上不需要提升状态来共享它。我们可以做的是将一个函数作为道具发送给窗口组件，并允许窗口组件用我们感兴趣的值调用我们的函数:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="31f2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用这种方法，我们不必提升状态，因为我们可以将一个事件挂接到子组件，并允许组件在某个时间点触发该方法。我喜欢把这种方法理解为“推动”或保持状态下降，而不是提升状态。</p><h2 id="4c8e" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">2.提升状态</h2><p id="8889" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">根据React文档，这是跨组件共享状态的推荐方法。这里，有必要注意一下React中的数据流。当你学习React时，你首先听到的是React中的数据流是单向的。与其他一些框架不同，在这些框架中，数据可以在多个组件之间单向流动，React通常只允许数据使用所谓的props从父组件流向其子组件。这是设计React应用程序时要考虑的最重要的事情之一，因为随着应用程序的增长，不正确的数据处理会导致许多架构问题。</p><p id="67ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了举例说明这一点，请考虑以下组件:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="e08d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个组件，根据发送给它的类型呈现不同的用户控件。它目前只支持两种类型:文本输入和复选框。</p><p id="11d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们创建了另一个组件，该组件应该使用该组件，然后保存该组件的值:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="952a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于React中单向数据流的性质，这是不可能的。默认情况下，父组件不能访问子组件的状态。尽管有一些方法可以实现类似的行为，比如使用<code class="fe me mf mg mh b">useImperativeHandle</code>钩子，但是这违反了React中的自然数据流。</p><p id="6145" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，当前存储在子组件中的状态必须提升一级，以便与其父组件共享该状态:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fb1c00172e9f41981f251972244706c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adsUt5GFM6u8DsHBFtkn9Q.jpeg"/></div></div></figure><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="a5c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过提升状态，数据现在单向流动，子组件从父组件接收状态。</p><h2 id="7c74" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">提升状态总是理想的吗？</h2><p id="d76a" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">当频繁提升状态时，可能出现的一个问题是，倾向于创建在组件树的上层管理的大块状态。如果有状态逻辑变得很重，这可能是使用React中内置的“useReducer”钩子将有状态逻辑移动到reducer的原因。<code class="fe me mf mg mh b">useReducer</code>钩子的一个用例是，如果需要同时更新多个状态，或者状态包含需要以特定方式处理的复杂数据结构。</p><p id="7249" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果有状态逻辑在组件之间是重复的，那么它可能是一个定制钩子的有效用例。每个场景都各不相同，但底线是开发人员必须仔细考虑React应用程序的整体架构，以避免引入反模式和违反数据流。</p><p id="e9a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读！</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="efc4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mp">更多内容请看</em><a class="ae mq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mp">plain English . io</em></strong></a><em class="mp">。报名参加我们的</em> <a class="ae mq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="mp">免费周报</em> </strong> </a> <em class="mp">。关注我们关于</em><a class="ae mq" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mp">Twitter</em></strong></a><em class="mp">和</em><a class="ae mq" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mp">LinkedIn</em></strong></a><em class="mp">。查看我们的</em> <a class="ae mq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="mp">社区不和谐</em> </strong> </a> <em class="mp">加入我们的</em> <a class="ae mq" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="mp">人才集体</em> </strong> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>