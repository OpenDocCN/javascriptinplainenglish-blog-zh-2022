<html>
<head>
<title>Reverse Stack Using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript反转堆栈</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reverse-stack-using-javascript-393592d96484?source=collection_archive---------22-----------------------#2022-01-10">https://javascript.plainenglish.io/reverse-stack-using-javascript-393592d96484?source=collection_archive---------22-----------------------#2022-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d080" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何使用JavaScript反转堆栈的教程。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/72de794832085b439159004cf8bcdf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*_fg92z4kXuJGQNna6-k7GA.jpeg"/></div></figure><p id="04e8" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">先说栈的定义。</p><h1 id="cecf" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">什么是堆栈？</h1><p id="0f09" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">堆栈是一种线性数据结构，其工作原理是<strong class="km io">后进先出</strong>(俗称LIFO)。</p><p id="3cb1" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果你知道<em class="md">递归</em>的话，程序控制必须深入(向下)并向上构建解决方案，栈是显而易见的选择。</p><p id="c4b2" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">堆栈最适用的其他问题:</p><ul class=""><li id="cfed" class="me mf in km b kn ko kq kr kt mg kx mh lb mi lf mj mk ml mm bi translated">检查括号是否平衡</li><li id="6453" class="me mf in km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">使用堆栈反转数组</li><li id="8991" class="me mf in km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">表达式计算</li></ul></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="7378" class="lg lh in bd li lj mz ll lm ln na lp lq jt nb ju ls jw nc jx lu jz nd ka lw lx bi translated">如何在JavaScript中创建堆栈？</h1><p id="253c" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">堆栈数据结构支持以下原语操作:</p><ul class=""><li id="ac38" class="me mf in km b kn ko kq kr kt mg kx mh lb mi lf mj mk ml mm bi translated">推动(值)</li><li id="3135" class="me mf in km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">流行()</li><li id="9db7" class="me mf in km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">peek()</li><li id="58d6" class="me mf in km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">is_empty()</li></ul><p id="194d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们为栈定义对象原型，然后实现每个原语操作。</p><p id="6989" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io"> <em class="md">注意:</em> </strong>栈可以用数组、队列、链表实现。为了简单起见，我们将使用数组来创建堆栈。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="1212" class="nj lh in nf b gy nk nl l nm nn">function Stack() {<br/>  this.arr = []; // to store the stack data<br/>  this.top = 0; // to point the top of the stack<br/>}</span></pre><h1 id="ed2a" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">推送(值):</h1><p id="8d24" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">push函数接受参数“value ”,并将其插入堆栈的顶部。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="49e8" class="nj lh in nf b gy nk nl l nm nn">Stack.prototype.push = function (value) {<br/>  this.arr[this.top] = value; // store the value at the top<br/>  this.top = this.top + 1; // increment top pointer<br/>}</span></pre><p id="83e7" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">时间复杂度:O(1) <br/>空间复杂度:O(1)</p><h1 id="5b2c" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">Pop():</h1><p id="7c5c" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">pop在移除栈顶元素后返回它。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="846e" class="nj lh in nf b gy nk nl l nm nn">Stack.prototype.pop = function () {<br/>  if (this.is_empty()) {<br/>    throw new Error("Underflow, stack is empty");<br/>  }<br/><br/>  var topEl = this.arr[this.top - 1];<br/><br/>  this.top = this.top - 1;<br/>  this.arr.pop();<br/><br/>  return topEl;<br/>}</span></pre><p id="1d0b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">时间复杂度:O(1) <br/>空间复杂度:O(1)</p><h1 id="fca9" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">peek():</h1><p id="dd92" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">peek函数不从堆栈中删除数据，而是返回堆栈的顶部</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="d8a8" class="nj lh in nf b gy nk nl l nm nn">Stack.prototype.peek = function () {<br/>  if (this.is_empty()) {<br/>    throw new Error("Underflow, stack is empty");<br/>  }<br/><br/>  return this.arr[this.top - 1]; <br/><br/>}</span></pre><p id="ae0d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">时间复杂度:O(1) <br/>空间复杂度:O(1)</p><h1 id="71fc" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">is_empty():</h1><p id="8948" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">如果堆栈为空，is_empty函数返回true，否则返回false</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="8734" class="nj lh in nf b gy nk nl l nm nn">Stack.prototype.is_empty = function () {<br/>  return this.top === 0;<br/>}</span></pre><p id="2161" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">时间复杂度:O(1) <br/>空间复杂度:O(1)</p><p id="50c6" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io"> <em class="md">注:</em> </strong>我们可以看到所有的图元操作都在花费恒定的时间。因此，如果我们从其他线性数据结构创建堆栈，那么我们必须确保原始操作也是常量时间。</p><p id="9578" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们把所有的代码放在一起:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="be71" class="nj lh in nf b gy nk nl l nm nn">function Stack() {<br/>  this.arr = [];<br/>  this.top = 0;<br/>}<br/><br/>Stack.prototype.push = function (val) {<br/>  this.arr[this.top] = val;<br/>  this.top = this.top + 1;<br/>}<br/><br/>Stack.prototype.pop = function () {<br/>  if (this.is_empty()) {<br/>    throw new Error("Underflow, stack is empty");<br/>  }<br/><br/>  var topEl = this.arr[this.top - 1];<br/><br/>  this.top = this.top - 1;<br/>  this.arr.pop();<br/><br/>  return topEl;<br/>}<br/><br/>Stack.prototype.is_empty = function () {<br/>  return this.top === 0;<br/>}</span></pre></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="6ead" class="lg lh in bd li lj mz ll lm ln na lp lq jt nb ju ls jw nc jx lu jz nd ka lw lx bi translated">怎么反叠？</h1><h2 id="45c3" class="nj lh in bd li no np dn lm nq nr dp lq kt ns nt ls kx nu nv lu lb nw nx lw ny bi translated">方法1 —修改原始堆栈</h2><p id="7077" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">从堆栈中逐个弹出元素并存储在新字符串中，这个新字符串将是原字符串的反向。</p><p id="d378" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们创建一个反转堆栈并返回反转字符串的反转函数。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="6d17" class="nj lh in nf b gy nk nl l nm nn">Stack.prototype.reverse = function () {<br/>  if (this.is_empty()) {<br/>    throw new Error("Underflow, stack is empty");<br/>  }<br/><br/>  var revStr = '';<br/><br/>  while(!this.is_empty()) {<br/>    revStr += this.pop();<br/>  }<br/><br/>  return revStr;<br/>}</span></pre><p id="a28b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">时间复杂度:O(n) →处理完整的堆栈<br/>空间复杂度:O(n) →存储字符串中的n项</p><h2 id="be0c" class="nj lh in bd li no np dn lm nq nr dp lq kt ns nt ls kx nu nv lu lb nw nx lw ny bi translated">方法2 —保持原始堆栈不变</h2><p id="efbf" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">因为，在栈实现中，我们有栈<code class="fe nz oa ob nf b">arr</code>的引用，它有栈数据。现在有了<code class="fe nz oa ob nf b">top</code>指针，我们可以循环遍历<code class="fe nz oa ob nf b">arr</code>，处理堆栈，存储反向字符串并返回。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="d78e" class="nj lh in nf b gy nk nl l nm nn">Stack.prototype.reverseAlternate = function () {<br/>  if (this.is_empty()) {<br/>    throw new Error("Underflow, stack is empty");<br/>  }<br/><br/>  var revStr = '';<br/><br/>  for (var i = this.top - 1; i &gt;= 0; i--) {<br/>    revStr += this.arr[i];<br/>  }<br/><br/>  return revStr;<br/>}</span></pre><p id="7b95" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">时间复杂度:O(n) →处理驻留在<code class="fe nz oa ob nf b">arr</code> <br/>的栈数据空间复杂度:O(n) →存储字符串中的n项</p><p id="3a4f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">将所有代码与一个示例结合在一起:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="9cad" class="nj lh in nf b gy nk nl l nm nn">function Stack() {<br/>  this.arr = [];<br/>  this.top = 0;<br/>}<br/><br/>Stack.prototype.push = function (val) {<br/>  this.arr[this.top] = val;<br/>  this.top = this.top + 1;<br/>}<br/><br/>Stack.prototype.pop = function () {<br/>  if (this.is_empty()) {<br/>    throw new Error("Underflow, stack is empty");<br/>  }<br/><br/>  var topEl = this.arr[this.top - 1];<br/><br/>  this.top = this.top - 1;<br/>  this.arr.pop();<br/><br/>  return topEl;<br/>}<br/><br/>Stack.prototype.is_empty = function () {<br/>  return this.top === 0;<br/>}<br/><br/>Stack.prototype.reverse = function () {<br/>  if (this.is_empty()) {<br/>    throw new Error("Underflow, stack is empty");<br/>  }<br/><br/>  var revStr = '';<br/><br/>  for (var i = this.top - 1; i &gt;= 0; i--) {<br/>    revStr += this.arr[i];<br/>  }<br/><br/>  return revStr;<br/>}<br/><br/>Stack.prototype.reverseV1 = function () {<br/>  if (this.is_empty()) {<br/>    throw new Error("Underflow, stack is empty");<br/>  }<br/><br/>  var revStr = '';<br/><br/>  while(!this.is_empty()) {<br/>    revStr += this.pop();<br/>  }<br/><br/>  return revStr;<br/>}<br/><br/>var stack = new Stack();<br/><br/>stack.push('a');<br/>stack.push('b');<br/>stack.push('c');<br/><br/>console.log(stack.reverse()); // cba<br/>console.log(stack.reverseV1()); // cba</span></pre><h2 id="d887" class="nj lh in bd li no np dn lm nq nr dp lq kt ns nt ls kx nu nv lu lb nw nx lw ny bi translated">方法3—反转原始堆栈</h2><p id="bfc8" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">需要明确的是，在O(1)的空间复杂度下，反转栈是做不到的。</p><p id="323f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们深入了解以下有趣的场景-</p><p id="40ba" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果要求在不使用除stack之外的其他线性数据结构的情况下反转原始堆栈。</p><p id="4f97" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">用数组反转堆栈很简单，但是我们不允许使用它，但是，我们可以用<strong class="km io"> <em class="md"> n </em> </strong>数量的堆栈来解决它但是不能用其他的线性数据结构。</p><p id="ef44" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">例如</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="2ed5" class="nj lh in nf b gy nk nl l nm nn"><br/>stack1 = [1, 2, 3, 4, 5], lets reverse it</span><span id="1576" class="nj lh in nf b gy oc nl l nm nn">pop each element to other stack, let’s say stack2</span><span id="67a2" class="nj lh in nf b gy oc nl l nm nn">stack2 = [5, 4, 3, 2, 1]</span><span id="6e18" class="nj lh in nf b gy oc nl l nm nn">It should be clear that popping each element from stack2 and pushing to stack1 will result in the original stack1. </span><span id="9214" class="nj lh in nf b gy oc nl l nm nn">let's use one more stack, say stack3</span><span id="4035" class="nj lh in nf b gy oc nl l nm nn">pop each element from stack2 to stack3</span><span id="db1b" class="nj lh in nf b gy oc nl l nm nn">stack3 = [1, 2, 3, 4, 5]</span><span id="838a" class="nj lh in nf b gy oc nl l nm nn">Now popping each element from the stack3 to stack1 will reverse the stack1.</span></pre><p id="5384" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">所以，<strong class="km io"> <em class="md">要用其他栈反转一个栈，我们正好需要2个栈。</em> </strong></p><p id="be8b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个问题一般在数据结构回合的很多面试中都会被问到。</p><p id="0b1a" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">时间复杂度:O(n) →处理堆栈<br/>空间复杂度:O(n) →存储其他堆栈中的项目</p><p id="fe26" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae od" href="https://github.com/ajayv1/dsa/blob/main/stack.js" rel="noopener ugc nofollow" target="_blank"> Github链接</a></p><p id="e2ba" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在https://weekendtutorial.com/<a class="ae od" href="https://weekendtutorial.com/" rel="noopener ugc nofollow" target="_blank">查看更多这样的文章和教程</a></p><h1 id="6e44" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">进一步阅读的推荐书籍:</h1><ol class=""><li id="d3b7" class="me mf in km b kn ly kq lz kt oe kx of lb og lf oh mk ml mm bi translated"><a class="ae od" href="https://amzn.to/3F6VozP" rel="noopener ugc nofollow" target="_blank">数据结构和算法变得简单— Narasimha Karumanchi </a></li><li id="f7c7" class="me mf in km b kn mn kq mo kt mp kx mq lb mr lf oh mk ml mm bi translated"><a class="ae od" href="https://amzn.to/3GdjEBr" rel="noopener ugc nofollow" target="_blank">算法介绍— T.H.Cormen </a></li></ol><p id="a8a8" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="md">更多内容看</em> <a class="ae od" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="km io"> <em class="md">说白了就是</em> </strong> </a> <em class="md">。报名参加我们的</em> <a class="ae od" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="km io"> <em class="md">免费每周简讯</em> </strong> </a> <em class="md">。在我们的</em> <a class="ae od" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="km io"> <em class="md">社区不和谐</em> </strong> </a> <em class="md">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>