<html>
<head>
<title>Recipes for Express &amp; React Full-Stack Apps in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中Express &amp; React全栈应用程序的配方</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recipes-for-express-and-react-fullstack-apps-in-type-8bcd4644bed0?source=collection_archive---------8-----------------------#2022-06-09">https://javascript.plainenglish.io/recipes-for-express-and-react-fullstack-apps-in-type-8bcd4644bed0?source=collection_archive---------8-----------------------#2022-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ea8a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用TypeScript在Express中构建优雅的全栈应用</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2d9f978b1d215b98fd68919b9a38df3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKol8qk8jdR_JaTUglOnWg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@chrisliverani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Chris Liverani</a> on <a class="ae ks" href="https://unsplash.com/s/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1eb8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我用Flask用Python写了不少应用后端，所以想试试它的JavaScript表亲Express。</p><p id="efb0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我找到了一些关于如何在全栈应用中做到这一点的教程。然而，它们似乎都不太详细。我感兴趣的是如何编写一些可以很好地扩展以包括许多路由，容易与前端集成，以及如何将其全部容器化的东西。</p><p id="0055" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是这篇文章的内容😏如果你想直接跳到代码，点击<a class="ae ks" href="https://github.com/osintalex/express-react-poc" rel="noopener ugc nofollow" target="_blank">这里</a>。(没有判断，我在看文章的时候一直都是这样😉).</p><h2 id="5c2a" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">概观</h2><p id="2535" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">首先，这里是我想通过这个概念验证解决的所有问题:</p><ol class=""><li id="8e0e" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">拥有超级模块化的应用配置方式，即轻松允许不同的开发、生产和测试值；</li><li id="8940" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">采用模块化方式处理申请路线；</li><li id="0dbf" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">有一种处理数据库操作的方法，愉快地注入数据库依赖关系，最好这样它们可以在测试中很容易地模拟出来；</li><li id="c881" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">将React应用程序与express应用程序捆绑在一起的非常简单的方法；</li><li id="a1c0" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">一个容器化应用的最终交付物；</li><li id="1344" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">具有预提交挂钩的良好代码林挺；</li><li id="c50d" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">所有东西都是打字稿！</li></ol><p id="013c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，这是我的应用程序布局的样子:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="2b1d" class="lp lq in nc b gy ng nh l ni nj">backend/<br/>--package.json<br/>--tsconfig.json<br/>--yarn.lock<br/>--src/<br/>  --index.ts //entrypoint<br/>  --configs/<br/>  --controllers/<br/>  --db/<br/>  --models/<br/>  --tests/</span><span id="2288" class="lp lq in nc b gy nk nh l ni nj">frontend/<br/>  --package.json<br/>  --tsconfig.json<br/>  --yarn.lock<br/>  --src/<br/>    --index.tsx //entrypoint<br/>    --App.tsx</span></pre><p id="f26d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你从上面看到的，我在反应部分没有做任何工作。我刚刚确保您可以轻松集成React应用程序，这意味着您的应用程序有一个很好的前端，您可以对后端进行API调用，而不会出现任何问题。</p><h2 id="e846" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">模块化配置</h2><p id="66e0" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我真的很喜欢在Python中这样做的典型方式，因为它使得在不同配置之间切换变得如此容易。下面是在一个<code class="fe nl nm nn nc b">backend/src/configs/config.ts</code>文件中的TypeScript中的样子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0e9d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我认为这很酷的原因是，你可以在应用程序的任何地方做这样的事情:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="2e03" class="lp lq in nc b gy ng nh l ni nj">import { configByEnvironment, environmentName, ConfigType } from "./configs/config";</span><span id="c57a" class="lp lq in nc b gy nk nh l ni nj">const configuration: <em class="nq">ConfigType</em> = configByEnvironment(environmentName);<br/>const { port } = configuration;</span><span id="386e" class="lp lq in nc b gy nk nh l ni nj">app.use(morgan(configuration.morganFormat));</span></pre><p id="43d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以你只需要修改<code class="fe nl nm nn nc b">config.ts</code>文件中的内容就可以了——很简单。</p><h2 id="9f50" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">模块化路线</h2><p id="005d" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这非常简单，但我花了一段时间才从网上阅读的材料中弄明白，所以下面是我如何做的，以防其他人发现它有用:</p><p id="a7cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe nl nm nn nc b">controllers/</code>内这样定义路线:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c912" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后你可以像这样在<code class="fe nl nm nn nc b">index.ts</code>中注册它们:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="f508" class="lp lq in nc b gy ng nh l ni nj">import example from "./controllers/example";<br/>import express, { Express} from "express";</span><span id="9ed0" class="lp lq in nc b gy nk nh l ni nj">const app: <em class="nq">Express</em> = express();<br/>app.use("/example", example);</span></pre><h2 id="fb8a" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">数据库依赖性</h2><p id="d4d1" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我发现最简洁的方法是使用<code class="fe nl nm nn nc b">typeorm</code>并在我的<code class="fe nl nm nn nc b">db</code>目录中定义一个这样的数据库读取操作模块:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4603" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第28行非常关键——这使得在测试中模拟数据库操作变得非常容易，并且很容易将读取报告放到视图中。回头看看上面控制器中的<code class="fe nl nm nn nc b">example.ts</code>文件，明白我的意思。</p><p id="58e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了测试，我发现很容易用sinon来模拟这一点:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3abb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">..这样你就不必做任何奇怪的事情，从<code class="fe nl nm nn nc b">typeorm</code>库或者你正在使用的任何其他ORM中模仿更大范围的方法。</p><h2 id="0c47" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">与React捆绑</h2><p id="c6b6" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这在你的<code class="fe nl nm nn nc b">index.ts</code>里很容易做到。你所要做的就是:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="3e36" class="lp lq in nc b gy ng nh l ni nj">app.get("*", (<em class="nq">_req</em>: <em class="nq">Request</em>, <em class="nq">res</em>: <em class="nq">Response</em>): <em class="nq">void</em> =&gt; {</span><span id="608e" class="lp lq in nc b gy nk nh l ni nj"><em class="nq">res</em>.sendFile(configuration.frontendStaticFilesPath, "index.html");</span><span id="ac82" class="lp lq in nc b gy nk nh l ni nj">});</span></pre><p id="74b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其中<code class="fe nl nm nn nc b">frontendStaticFilesPath</code>指向运行<code class="fe nl nm nn nc b">react-scripts build</code>产生的构建输出。我认为这非常好，因为它避免了您在全栈工作时经常遇到的一些其他问题:</p><ul class=""><li id="2111" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo nr mt mu mv bi translated">无需进行任何CORS配置😍。你的前端实际上和你的后端在同一个原点上！</li><li id="5e07" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo nr mt mu mv bi translated">您可以非常轻松地在一个容器中运行所有内容，无需分离前端或后端服务。当然，你可能会因为其他原因想这么做，比如缩放等等，但是对于一个快速原型，我认为这是🆒</li></ul><p id="874c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这使我想到…</p><h2 id="cbaa" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">将您的应用容器化</h2><p id="4945" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">由于一切都在一个服务中运行，并且因为您的TypeScript正在编译为JavaScript，所以您可以通过如下三阶段构建将一切巧妙地结合在一起:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1351" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将产生一个超级轻量级的最终映像，它作为非根用户节点运行，并利用了<code class="fe nl nm nn nc b">pm2</code>。如果你对我在这里做出的一些选择感到好奇，在Docker <a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/build-a-production-ready-node-express-api-with-docker-9a45443427a0">这里</a>有一篇关于发布快递应用的很好的文章。</p><h2 id="3764" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">代码林挺</h2><p id="f00d" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">有很多方法可以设置ESLint，所以我就不深究了。我建议阅读一些关于如何做到这一点的具体帖子，或者如果你不介意，那么就使用<code class="fe nl nm nn nc b">npx eslint init</code>或它的等效物<code class="fe nl nm nn nc b">yarn eslint init</code>。</p><p id="205a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦这样做了，尽管将husky添加到全栈应用程序设置中有点麻烦，例如，带有2个<code class="fe nl nm nn nc b">package.json</code>文件的repo。</p><p id="2237" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我是这样做的:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="64af" class="lp lq in nc b gy ng nh l ni nj">// Add this to package.json scripts in backend<br/>"prepare": "cd .. &amp;&amp; husky install backend/.husky"<br/>// Add this in frontend<br/>"prepare": "cd .. &amp;&amp; husky install frontend/.husky"</span></pre><p id="d449" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后在前端目录中，你可以点击<code class="fe nl nm nn nc b">yarn prepare</code>然后<code class="fe nl nm nn nc b">yarn husky add .husky/pre-commit "cd frontend &amp;&amp; &lt;lint command goes here&gt;"</code>，然后对后端做完全相同的事情。</p><p id="3601" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就对了。希望这有帮助。😅</p><p id="e1b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nq">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nq">plain English . io</em></strong></a><em class="nq">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nq">免费周报</em> </strong> </a> <em class="nq">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nq">Twitter</em></strong></a><em class="nq">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nq">LinkedIn</em></strong></a><em class="nq">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nq">社区不和谐</em> </strong> </a> <em class="nq">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nq">人才集体</em> </strong> </a> <em class="nq">。</em></p></div></div>    
</body>
</html>