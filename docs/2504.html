<html>
<head>
<title>Build End-to-End .NET Core API and Angular Application using Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端构建。使用Kubernetes的NET Core API和Angular应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-end-to-end-net-core-api-and-angular-application-using-kubernetes-b1b75ea4bda9?source=collection_archive---------0-----------------------#2022-06-12">https://javascript.plainenglish.io/build-end-to-end-net-core-api-and-angular-application-using-kubernetes-b1b75ea4bda9?source=collection_archive---------0-----------------------#2022-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/09a55ccd6739152b752e49f528ea8688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9yF3bPKr8EBb_XBQ6W8xg.png"/></div></div></figure><p id="10ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天我们将使用构建一个端到端的应用程序。NET Core API 6和Angular 14。</p><p id="12fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">先决条件</strong></p><ol class=""><li id="b161" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">对码头工人的理解</li><li id="e020" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">对Kubernetes的基本了解</li><li id="8970" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">对…的基本了解。网络核心</li><li id="452c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">对角度的理解</li><li id="f39c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">那边启用了Kubernetes的Docker桌面。</li></ol><p id="0011" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于以上所有的话题，你可以访问我下面的博客，这些博客有助于你更容易地理解我们将要在这个博客中讨论的事情。</p><ul class=""><li id="f708" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lh kz la lb bi translated"><a class="ae li" href="https://blog.devops.dev/introduction-of-kubernetes-fc044018fd03" rel="noopener ugc nofollow" target="_blank">库伯内特的介绍</a></li><li id="ebe9" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated"><a class="ae li" href="https://medium.com/@jaydeepvpatil225/architecture-of-kubernetes-d17afd3428db" rel="noopener">库伯内特的建筑</a></li><li id="3385" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated"><a class="ae li" href="https://blog.devops.dev/docker-introduction-and-architecture-8637d9d1c4dc" rel="noopener ugc nofollow" target="_blank">介绍Docker </a></li><li id="1c30" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated"><a class="ae li" href="https://medium.com/@jaydeepvpatil225/build-net-core-rest-api-and-angular-application-using-docker-aa2249fc7d92" rel="noopener">基础。Net Core REST API和Angular应用使用Docker </a></li></ul><p id="9df3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第一步:</strong></p><p id="bfd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创造。NET Core API 6应用程序使用VS代码来使用以下命令</p><p id="6cf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，在您的本地机器上创建一个目录，我们把后端和前端应用程序放在那里。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="b9b9" class="ls lt in lo b gy lu lv l lw lx">mkdir Product</span><span id="f47e" class="ls lt in lo b gy ly lv l lw lx">cd Product</span></pre><p id="9c86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，创建另一个文件夹ProductWebAPI</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="dd98" class="ls lt in lo b gy lu lv l lw lx">mkdir ProductWebAPI</span><span id="d68b" class="ls lt in lo b gy ly lv l lw lx">cd ProductWebAPI</span></pre><p id="b2c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">稍后，创建一个新的。ProductWebAPI文件夹中的. NET解决方案</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="5e59" class="ls lt in lo b gy lu lv l lw lx">dotnet new sln</span></pre><p id="5a0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，在名为ProductWebAPI的项目中创建新的web API项目</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="5679" class="ls lt in lo b gy lu lv l lw lx">dotnet new ProductWebAPI -o</span></pre><p id="fae6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，使用以下命令将ProductWebAPI的csproj文件添加到sln文件中</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="add6" class="ls lt in lo b gy lu lv l lw lx">dotnet sln ADD ProductWebAPI.csproj</span></pre><p id="d8ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，我们就创建了一个新的。NET核心API项目使用Visual Studio 2022 in。NET版本6</p><p id="4039" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第二步:</strong></p><p id="7d54" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们创建ProductController并创建一个简单的端点，它返回一个产品列表，如下所示</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d975" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，您可以看到我们创建了一个名为list的端点，它将返回一个产品列表的字典，我们将使用Angular 14应用程序显示这些产品。</p><p id="52ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第三步:</strong></p><p id="f168" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将把CORS策略添加到中使用的程序类中。网络核心6</p><p id="b3b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> CORS支持</strong></p><p id="6e14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CORS的完整形式是跨产地资源共享。它是一个W3C标准，允许服务器从指定的域进行跨域调用，同时由于浏览器的安全性，默认情况下拒绝其他调用。它防止网页从一个域向另一个域发出Ajax请求。</p><p id="3393" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是很多时候我们使用多域应用程序，这些应用程序需要从一个域调用另一个域；在这种情况下，我们需要允许跨来源策略。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="fa66" class="ls lt in lo b gy lu lv l lw lx">builder.Services.AddCors();<br/>app.UseCors(builder =&gt;<br/>    {<br/>        builder<br/>        .AllowAnyOrigin()<br/>        .AllowAnyMethod()<br/>        .AllowAnyHeader();<br/>    });</span></pre><p id="0e41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，您可以看到我们放置了一些设置了CORS策略的代码，我们要求Angular应用程序从后端应用程序获取数据。</p><p id="0d5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第四步:</strong></p><p id="537f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建Docker文件来创建我们将在Kubernetes中使用的Docker图像。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="857e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以这里你可以看到</p><ul class=""><li id="80ba" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lh kz la lb bi translated">首先，我们采取。NET Core SDK并为我们的应用程序设置工作目录</li><li id="2468" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">然后将我们的项目csproj文件复制到docker目录中</li><li id="648f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">稍后，将所有剩余内容从本地复制到Docker目录，并为此创建publish。</li><li id="8e7e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">在最后一节中，我们获取asp net映像，并在设置工作目录后将我们的构建内容复制到它们的目录中，然后最后创建应用程序端点。</li></ul><p id="e8f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第五步:</strong></p><p id="60a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果您想看到输出，使用下面的代码运行应用程序。NET CLI命令</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="6ea2" class="ls lt in lo b gy lu lv l lw lx">dotnet run</span></pre><p id="e66d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第六步:</strong></p><p id="cc6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个docker映像，然后使用下面的命令检查它是否工作正常</p><p id="b203" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(注意:确保Docker桌面运行良好，并且在其上启用了Kubernetes)</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="dca9" class="ls lt in lo b gy lu lv l lw lx">docker build -t productapi:v1 .</span></pre><p id="8062" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后将这个图像运行到docker容器中</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="3db9" class="ls lt in lo b gy lu lv l lw lx">docker run -p 3000:80 productapi:v1</span></pre><p id="3b98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后可以看到点击网址<a class="ae li" href="http://localhost:3000/product/list" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/product/list</a>后的输出</p><p id="5d08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是关于docker的所有内容，我们看到了如何创建docker映像并将其运行到容器中。现在停止容器，并遵循后续步骤</p><p id="fa39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们将为后端应用程序创建清单文件</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="577a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，您可以看到我们创建了部署、pod和服务，然后提到了docker映像、容器、策略和应用程序副本数量的所有详细信息</p><p id="ecaf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们应用这个清单文件并创建部署、pod、服务和端点来管理Kubernetes集群和访问应用程序</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="9a05" class="ls lt in lo b gy lu lv l lw lx">kubectl apply -f manifest.yml</span></pre><p id="65eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个命令将在Kubernetes中创建Pods和服务</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="06ba" class="ls lt in lo b gy lu lv l lw lx">kubectl get pods</span><span id="aff8" class="ls lt in lo b gy ly lv l lw lx">kubectl get services</span><span id="70fe" class="ls lt in lo b gy ly lv l lw lx">kubectl get endpoints</span><span id="abdb" class="ls lt in lo b gy ly lv l lw lx">kubectl get deployment</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/12c76dc1a6124d51b29a798fcc066c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D3PPu3n6Jd65lVBH.png"/></div></div></figure><p id="86a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务部分，您可以看到访问应用程序的端点，现在您可以使用URL<a class="ae li" href="http://localhost:3224/product/list" rel="noopener ugc nofollow" target="_blank">http://localhost:32224/product/list</a>访问应用程序，您可以看到下面的输出</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/7c1cb3c11010522e4d928b675b904a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zexEtMocySJozdUX.png"/></div></div></figure><p id="0528" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，这都是关于后端应用程序。</p><p id="49a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从<strong class="jx io"> Angular </strong>应用程序开始，我们将使用Angular 14创建该应用程序，并在从后端应用程序获取数据后用于显示数据</p><p id="453f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第一步:</strong></p><p id="b9da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在项目文件夹中创建一个新项目</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="674d" class="ls lt in lo b gy lu lv l lw lx">ng new ProductWebAPP</span></pre><p id="42d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">进入ProductWebAPP目录</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="48d2" class="ls lt in lo b gy lu lv l lw lx">cd ProductWebAPP</span></pre><p id="fe59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第二步:</strong></p><p id="2ab3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个新的服务，使用HTTP客户端模块从后端应用程序获取数据</p><p id="46fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ng g服务演示</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9fef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第三步:</strong></p><p id="2b01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将HTTP客户端模块导入app.module.ts</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b337" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第四步:</strong></p><p id="fcfb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在app.component.ts中添加以下代码</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a4c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第五步:</strong></p><p id="459e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，添加下面的HTML片段来显示我们要从后端应用程序获取的数据</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="19da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第六步:</p><p id="a06d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建用于设置动态端口配置的appEntryPoint.sh文件</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="100c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第七步:</strong></p><p id="77bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，创建一个nginx-custom.conf文件，该文件设置一些默认的nginx服务器配置</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f396" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第八步:</strong></p><p id="7c86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在根目录中创建Dockerfile</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="560a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，你可以看到，</p><ul class=""><li id="e819" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lh kz la lb bi translated">首先，我们获取应用程序的节点映像并设置docker目录，然后复制package.json文件和docker目录中的剩余数据</li><li id="7fc2" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">在第二部分中，我们采用Nginx服务器映像，并设置默认配置</li><li id="25bb" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">最后，我们设置应用程序和文件的入口点，用于在运行时设置动态端口。</li></ul><p id="eab0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第九步:</strong></p><p id="5cac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，在用于设置后端API URL的assets文件夹和config目录中创建config.json和config.template.json文件</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="a9be" class="ls lt in lo b gy lu lv l lw lx">{<br/>    "apiServer": {<br/>    "url": "<a class="ae li" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>",<br/>    "version": "v1"<br/>    }<br/>}</span></pre><p id="6a23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建config.template.json</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="182c" class="ls lt in lo b gy lu lv l lw lx">{<br/>    "apiServer": {<br/>        "url": "${API_LINK}",<br/>        "version": "v1"<br/>    }<br/>}</span></pre><p id="bee8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第十步:</strong></p><p id="c3a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们将创建一个docker映像，并在docker文件所在的根目录下使用以下命令将其运行到容器中。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="5333" class="ls lt in lo b gy lu lv l lw lx">docker build -t productapi:v1</span><span id="c9a5" class="ls lt in lo b gy ly lv l lw lx">docker run -p 3002:80 productapi:v1</span></pre><p id="8be6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，您可以看到我们使用URL <a class="ae li" href="http://localhost:3002/," rel="noopener ugc nofollow" target="_blank"> http://localhost:3002/，</a>从后端应用程序获得的输出。现在，停止容器并按照下面的步骤操作</p><p id="af7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第11步)</strong></p><p id="1437" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个manifest.yml文件，并在Kubernetes上应用它来创建一个集群</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="678b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，将这个清单文件应用到Kubernetes集群</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="b800" class="ls lt in lo b gy lu lv l lw lx">kubectl apply -f manifest.yml</span></pre><p id="831e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个命令将在Kubernetes中创建Pods和服务</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="533e" class="ls lt in lo b gy lu lv l lw lx">kubectl get pods</span><span id="fc3e" class="ls lt in lo b gy ly lv l lw lx">kubectl get services</span><span id="13ac" class="ls lt in lo b gy ly lv l lw lx">kubectl get endpoints</span><span id="b858" class="ls lt in lo b gy ly lv l lw lx">kubectl get deployment</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/b05f9eb06f15ad664da688b14156b2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TESg5w3AxEV5BZpN.png"/></div></div></figure><p id="d7ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务部分，您可以看到访问应用程序的端点，现在您可以使用URL<a class="ae li" href="http://localhost:30055/product/list" rel="noopener ugc nofollow" target="_blank">http://localhost:30055/</a>访问应用程序，您可以看到下面的输出</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/8b5bf4bfbf8be0538fbb0b7382f68ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e6YrPY7WvdUIboKx.png"/></div></div></figure><h2 id="e5c7" class="ls lt in bd me mf mg dn mh mi mj dp mk kg ml mm mn kk mo mp mq ko mr ms mt mu bi translated"><strong class="ak">结论</strong></h2><p id="759e" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">我们讨论了如何创造？NET Core API 6和Angular 14 web应用程序，然后使用Kubernetes一步一步地将其容器化。</p><p id="72f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你明白我们在这个博客中讨论的所有事情</p><p id="ea47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">快乐编码！</strong></p><p id="8988" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="na">更多内容请看</em><a class="ae li" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="na">plain English . io</em></strong></a><em class="na">。报名参加我们的</em> <a class="ae li" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="na">免费周报</em> </strong> </a> <em class="na">。关注我们关于</em><a class="ae li" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="na">Twitter</em></strong></a><em class="na">和</em><a class="ae li" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="na">LinkedIn</em></strong></a><em class="na">。查看我们的</em> <a class="ae li" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="na">社区不和谐</em> </strong> </a> <em class="na">加入我们的</em> <a class="ae li" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="na">人才集体</em> </strong> </a> <em class="na">。</em></p></div></div>    
</body>
</html>