<html>
<head>
<title>Micro Frontends Using Webpack’s Module Federation with create-react-app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Webpack的模块联邦和create-react-app的微前端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/micro-frontends-using-webpacks-module-federation-with-create-react-app-f6a890600bae?source=collection_archive---------0-----------------------#2022-11-27">https://javascript.plainenglish.io/micro-frontends-using-webpacks-module-federation-with-create-react-app-f6a890600bae?source=collection_archive---------0-----------------------#2022-11-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4761f2addf03ec4723770c109644483f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8DCaAksYksfwpmPq"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@joeel56?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicole Wolf</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4dee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模块联合使我们能够使用多个独立的构建来形成一个应用程序。</p><p id="677c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它是在Webpack 5中引入的，它确实是前端开发领域的游戏改变者。至少，它支持在同一产品的不同前端之间共享<strong class="kc io">组件</strong>，例如管理面板、用户网站。但不仅如此，它使我们能够<strong class="kc io">将前端嵌入到其他前端中</strong>，让我们能够拥有独立的库栈、不同的代码风格、结构等等。</p><p id="fc71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">官方文件说得好:</p><blockquote class="ky kz la"><p id="b67f" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io">用例</strong></p><p id="9d2a" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io">每页独立构建</strong></p><p id="8894" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">单页应用程序的每一页都从单独版本的容器版本中公开。应用程序外壳也是一个单独的构建，将所有页面作为远程模块引用。这样，每个页面都可以单独部署。当更新路由或添加新路由时，部署应用程序外壳。应用程序外壳将常用的库定义为共享模块，以避免在页面构建中重复使用它们。</p><p id="bfc2" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io">组件库作为容器</strong></p><p id="610f" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">许多应用程序共享一个公共的组件库，该组件库可以构建为一个容器，每个组件都是公开的。每个应用程序都使用组件库容器中的组件。对组件库的更改可以单独部署，而无需重新部署所有应用程序。应用程序自动使用组件库的最新版本。</p></blockquote><p id="a18d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模块联合给了我们一个真正无痛的体验，将你的代码分布在不同的包中，并且配置的数量是最小的。这使得您的代码在不同的团队之间适应性更强，更易于维护。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="9ee7" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">让我们构建一个示例应用程序</h1><p id="1ad0" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我们将构建一个应用程序，它由三个不同的模块组成:</p><ul class=""><li id="16b4" class="mp mq in kc b kd ke kh ki kl mr kp ms kt mt kx mu mv mw mx bi translated"><strong class="kc io">库</strong> —包含共享组件</li><li id="99a0" class="mp mq in kc b kd my kh mz kl na kp nb kt nc kx mu mv mw mx bi translated"><strong class="kc io"> app2 </strong> —一个独立的应用程序，它使用组件，也可以在其他地方使用(我们将在app1中使用它)</li><li id="6ade" class="mp mq in kc b kd my kh mz kl na kp nb kt nc kx mu mv mw mx bi translated"><strong class="kc io"> app1 </strong> —一个使用组件的容器应用，也包括app2</li></ul><p id="1ee9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的目标是使用create-react-app，因为您可能已经在所有react项目中使用它了。我们希望模块联合能够补充我们已经很好的设置。当然，我们不希望取消create-react-app配置。</p><p id="22de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们将添加一些webpack插件，我们也需要<strong class="kc io"> craco </strong>。Craco是Create React App配置覆盖，一个简单易懂的配置层。详见<a class="ae jz" href="https://github.com/dilanx/craco." rel="noopener ugc nofollow" target="_blank">https://github.com/dilanx/craco</a>。</p><p id="87c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有两个webpack插件<strong class="kc io">可以实现这一点:</strong></p><ul class=""><li id="5d84" class="mp mq in kc b kd ke kh ki kl mr kp ms kt mt kx mu mv mw mx bi translated"><code class="fe nd ne nf ng b">craco-mf</code><strong class="kc io"/>(<a class="ae jz" href="https://github.com/bfaulk96/craco-mf" rel="noopener ugc nofollow" target="_blank">https://github.com/bfaulk96/craco-mf</a>)</li></ul><p id="3cf7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它使我们能够在我们的CRA应用程序中使用模块联合。</p><ul class=""><li id="034b" class="mp mq in kc b kd ke kh ki kl mr kp ms kt mt kx mu mv mw mx bi translated"><code class="fe nd ne nf ng b">@cloudbeds/webpack-module-federation-types-plugin</code>(<a class="ae jz" href="https://github.com/cloudbeds/webpack-module-federation-types-plugin" rel="noopener ugc nofollow" target="_blank">https://github . com/cloudbeds/web pack-module-Federation-types-plugin</a>)</li></ul><p id="715c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为我们提供了类型安全的开发——这意味着我们的应用程序不会充满ts忽略，我们有一个自动系统来在应用程序之间共享类型。这对于任何现实世界的开发场景都是必要的。</p><h2 id="fdc9" class="nh ln in bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated"><strong class="ak">配置</strong></h2><p id="814d" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">涉及的配置非常少。但是，每个模块中都有两个重要的文件:</p><ul class=""><li id="5b36" class="mp mq in kc b kd ke kh ki kl mr kp ms kt mt kx mu mv mw mx bi translated"><code class="fe nd ne nf ng b">modulefedration.config.js</code></li><li id="ee55" class="mp mq in kc b kd my kh mz kl na kp nb kt nc kx mu mv mw mx bi translated"><code class="fe nd ne nf ng b">craco.config.js</code></li></ul><p id="8fa1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nd ne nf ng b">craco.config.js</code>将成为所有套件的标准配置:</p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="c7a5" class="ob ln in ng b be oc od l oe of">const { join } = require("path");<br/>const cracoModuleFederationPlugin = require("craco-mf");<br/>const { ModuleFederationTypesPlugin } = require( '@cloudbeds/webpack-module-federation-types-plugin' );<br/><br/>module.exports = {<br/>  webpack: {<br/>    plugins: {<br/>      add: [<br/>        new ModuleFederationTypesPlugin({<br/>          downloadTypesWhenIdleIntervalInSeconds: 1,<br/>        }),<br/>      ]<br/>    },<br/>    configure: (webpackConfig) =&gt; {<br/>      webpackConfig.devServer = { static: {} };<br/>      webpackConfig.devServer.static.directory = join(process.cwd(), "public");<br/>      return webpackConfig;<br/>    },<br/>  },<br/>  plugins: [<br/>    {<br/>      plugin: cracoModuleFederationPlugin,<br/>    },<br/>  ],<br/>};</span></pre><p id="de45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe nd ne nf ng b">modulefederation.config.js</code>中，我们将配置哪些包在不同的应用程序之间共享，哪些组件向其他应用程序公开，以及我们希望在我们的应用程序中访问哪些其他应用程序以及它们驻留在哪里。</p><p id="82a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于<strong class="kc io">库</strong>应用程序，我们将使用这个:</p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="d300" class="ob ln in ng b be oc od l oe of">module.exports = {<br/>  name: "library",<br/>  exposes: {<br/>    "./NameContextProvider": "./src/components/NameContextProvider.ts",<br/>    "./Button": "./src/components/Button",<br/>    "./Logo": "./src/components/Logo",<br/>  },<br/>  filename: "remoteEntry.js",<br/>  shared: {<br/>    react: {<br/>      singleton: true,<br/>      requiredVersion: deps["react"],<br/>    },<br/>    "react-dom": {<br/>      singleton: true,<br/>      requiredVersion: deps["react-dom"],<br/>    },<br/>  },<br/>};</span></pre><p id="bb12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">配置告诉我们，我们将与其他两个应用程序共享一个上下文、一个按钮组件和一个徽标组件。它还告诉我们，我们将在三个模块之间共享<code class="fe nd ne nf ng b">react</code>和<code class="fe nd ne nf ng b">react-dom</code>。</p><p id="2edd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于<strong class="kc io">应用2 </strong>，我们将使用这个:</p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="e277" class="ob ln in ng b be oc od l oe of">module.exports = {<br/>  name: "app2",<br/>  exposes: {<br/>    './App2Index': './src/Homepage',<br/>  },<br/>  filename: "remoteEntry.js",<br/>  remotes: {<br/>    library: `library@http://localhost:3003/remoteEntry.js`,<br/>  },<br/>  shared: {<br/>    react: {<br/>      singleton: true,<br/>      requiredVersion: deps["react"],<br/>    },<br/>    "react-dom": {<br/>      singleton: true,<br/>      requiredVersion: deps["react-dom"],<br/>    },<br/>  },<br/>};</span></pre><p id="faee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个配置告诉我们，我们将向其他应用程序公开app2的主页(我们将在app1中使用它)，并且我们将在这个应用程序中使用library remote。这将使我们能够使用按钮和标志。</p><p id="782d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于<strong class="kc io">应用1 </strong>，我们将使用以下内容:</p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="8cee" class="ob ln in ng b be oc od l oe of">module.exports = {<br/>  name: "app1",<br/>  exposes: {<br/>  },<br/>  remotes: {<br/>    app2: `app2@http://localhost:3002/remoteEntry.js`,<br/>    library: `library@http://localhost:3003/remoteEntry.js`,<br/>  },<br/>  filename: "remoteEntry.js",<br/>  shared: {<br/>    ...deps,<br/>    react: {<br/>      singleton: true,<br/>      requiredVersion: deps["react"],<br/>    },<br/>    "react-dom": {<br/>      singleton: true,<br/>      requiredVersion: deps["react-dom"],<br/>    },<br/>  },<br/>};</span></pre><p id="63ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个配置使我们能够使用库组件和app2。</p><p id="f6fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本质上，这就是我们需要的所有配置。这个设置的另一个特殊之处是使用路由。如果我们将app2作为独立的应用程序使用，我们将需要自己的路由包装器(例如来自<strong class="kc io"> react-router-dom </strong>的<strong class="kc io"> BrowserRouter </strong>)，但是如果我们将app2嵌入到app1中，我们将使用来自app1的路由包装器。</p><h2 id="19b1" class="nh ln in bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">库模块</h2><p id="9376" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我们将跳过如何创建从库中暴露的按钮和徽标的部分。这都是标准反应。</p><p id="37cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还将公开一个简单的上下文:</p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="16cd" class="ob ln in ng b be oc od l oe of">import React from "react";<br/><br/>export default React.createContext({<br/>  name: "Mr.Noname" as string,<br/>  setName: (name: string) =&gt; {},<br/>});</span></pre><p id="0089" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将向其他两个应用程序共享一个上下文、一个按钮组件和一个徽标组件。</p><h2 id="c18b" class="nh ln in bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">App2模块</h2><p id="d137" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">好玩的部分从<strong class="kc io"> app2 </strong>开始！App2可以作为一个独立的应用程序运行，也可以包含在另一个应用程序中。让我们看看指数成分:</p><p id="7229" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nd ne nf ng b">App.tsx</code> <strong class="kc io"> : </strong></p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="7834" class="ob ln in ng b be oc od l oe of">import NameContextProvider from "library/NameContextProvider";<br/>import { useState } from "react";<br/>import { BrowserRouter } from "react-router-dom";<br/>import Homepage from "./Homepage";<br/><br/>function App2() {<br/>  const [name, setName] = useState("Mojca");<br/><br/>  return (<br/>    &lt;BrowserRouter&gt;<br/>      &lt;NameContextProvider.Provider value={{ name, setName }}&gt;<br/>        &lt;Homepage /&gt;<br/>      &lt;/NameContextProvider.Provider&gt;<br/>    &lt;/BrowserRouter&gt;<br/>  );<br/>}<br/><br/>export default App2;</span></pre><p id="a134" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，我们在这里使用了自己的路由包装器，我们还使用了自己的提供者，这就是为什么我们没有将这个组件公开给app1，而是公开给下面的homepage组件。App1将有自己的名称提供者，当我们将app2嵌入app1时，上下文将被共享。神奇！</p><p id="8a16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nd ne nf ng b">Homepage.tsx</code> <strong class="kc io"> : </strong></p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="1477" class="ob ln in ng b be oc od l oe of">import Button from "library/Button";<br/><br/>import NameContextProvider from "library/NameContextProvider";<br/>import React from "react";<br/>import { Route, Routes } from "react-router-dom";<br/><br/>function Homepage() {<br/>  const ctx = React.useContext(NameContextProvider);<br/><br/>  return (<br/>    &lt;Routes&gt;<br/>      &lt;Route<br/>        path="/"<br/>        element={<br/>          &lt;div&gt;<br/>            &lt;div style={{ marginBottom: 20 }}&gt;<br/>              Hello again {ctx.name}. This is app2. The button &amp;amp; context<br/>              used is from components app.<br/>            &lt;/div&gt;<br/>            &lt;div&gt;<br/>              &lt;Button<br/>                text="Change name from app2"<br/>                onClick={() =&gt; ctx.setName("Jozica")}<br/>              /&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        }<br/>        index<br/>      /&gt;<br/>    &lt;/Routes&gt;<br/>  );<br/>}<br/><br/>export default Homepage;</span></pre><h2 id="3b7b" class="nh ln in bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">App1</h2><p id="aaa3" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">App1是容器应用程序，它将使我们的整个项目变得生动起来。让我们看看指数成分:</p><p id="1767" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nd ne nf ng b">App.tsx</code> <strong class="kc io"> : </strong></p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="465a" class="ob ln in ng b be oc od l oe of">import "./App.css";<br/><br/>import App2 from "app2/App2Index";<br/><br/>import { BrowserRouter, Navigate, Route, Routes } from "react-router-dom";<br/>import Homepage from "./Homepage";<br/><br/>const app2RoutingPrefix = "app2";<br/><br/>function App1() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;BrowserRouter&gt;<br/>        &lt;Routes&gt;<br/>          &lt;Route path="/" element={&lt;Homepage /&gt;}&gt;<br/>            &lt;Route index element={&lt;Navigate to={`/${app2RoutingPrefix}`} /&gt;} /&gt;<br/>            &lt;Route path={`/${app2RoutingPrefix}/*`} element={&lt;App2 /&gt;} /&gt;<br/>          &lt;/Route&gt;<br/>        &lt;/Routes&gt;<br/>      &lt;/BrowserRouter&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default App1;</span></pre><p id="3b16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它包含所有主要路由，并包括app2。</p><p id="0ef1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nd ne nf ng b">Homepage.tsx</code> <strong class="kc io"> : </strong></p><pre class="nt nu nv nw gt nx ng ny bn nz oa bi"><span id="a075" class="ob ln in ng b be oc od l oe of">import React, { useState } from "react";<br/>import "./App.css";<br/><br/>import Logo from "library/Logo";<br/>import NameContextProvider from "library/NameContextProvider";<br/><br/>import Button from "library/Button";<br/>import { Outlet } from "react-router-dom";<br/><br/>function Homepage() {<br/>  const [name, setName] = useState("Mojca");<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;NameContextProvider.Provider value={{ name, setName }}&gt;<br/>        &lt;React.Suspense fallback="loading"&gt;<br/>          &lt;div style={{ marginBottom: 20, marginTop: 20 }}&gt;<br/>            &lt;Logo style={{ width: 90 }} /&gt;<br/>          &lt;/div&gt;<br/>          &lt;div style={{ marginBottom: 20 }}&gt;<br/>            Hello {name}. This is app1 - container app. The button &amp;amp; context<br/>            used is from the components app.<br/>          &lt;/div&gt;<br/>          &lt;div style={{ marginBottom: 60 }}&gt;<br/>            &lt;Button<br/>              text="Change name from app1"<br/>              onClick={() =&gt; setName("Lojza")}<br/>            /&gt;<br/>          &lt;/div&gt;<br/>          &lt;Outlet /&gt;<br/>        &lt;/React.Suspense&gt;<br/>      &lt;/NameContextProvider.Provider&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default Homepage;</span></pre><p id="84fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在主页组件中，我们提供了上下文，使用了一些共享库，并为子路由提供了一个出口——app2是这些子路由中的一个，它将在其位置上呈现。</p><p id="1f9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我们所需要的！</p><h2 id="44bd" class="nh ln in bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated"><strong class="ak">开发中的运行</strong></h2><p id="cba1" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我们有两个选择:</p><ul class=""><li id="3bd3" class="mp mq in kc b kd ke kh ki kl mr kp ms kt mt kx mu mv mw mx bi translated">我们可以使用<strong class="kc io"> lerna，</strong>它将为我们在每个包中运行<code class="fe nd ne nf ng b">yarn run start</code></li><li id="c540" class="mp mq in kc b kd my kh mz kl na kp nb kt nc kx mu mv mw mx bi translated">每个应用程序也可以通过在各自的repos中运行<code class="fe nd ne nf ng b">yarn run start</code> <strong class="kc io"> </strong>来单独运行</li></ul><h2 id="9806" class="nh ln in bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated"><strong class="ak">生产用建筑</strong></h2><p id="2e7b" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">如果我们要将应用程序部署到S3，我们会将每个模块分别部署到其各自的S3存储桶中。</p><p id="7205" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">唯一需要的配置是在每个包的<code class="fe nd ne nf ng b">modulefederation.config.js</code>文件中使用正确的远程URL，这需要指向S3 URL而不是本地主机URL。</p><h2 id="8454" class="nh ln in bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">完整源代码</h2><p id="87b6" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">本例的完整源代码也可以在github上的<a class="ae jz" href="https://github.com/xtrinch/create-react-app-module-federation-example" rel="noopener ugc nofollow" target="_blank">https://github . com/xtr inch/create-react-app-module-Federation-example</a>下找到</p><p id="a852" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lb">plain English . io</em></strong></a><em class="lb">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lb">免费周报</em> </strong> </a> <em class="lb">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lb">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lb">LinkedIn</em></strong></a><em class="lb"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lb">YouTube</em></strong></a><em class="lb"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lb">不和</em> </strong> </a> <em class="lb">。对增长黑客感兴趣？检查</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lb">电路</em> </strong> </a> <em class="lb">。</em></p></div></div>    
</body>
</html>