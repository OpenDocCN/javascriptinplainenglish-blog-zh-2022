<html>
<head>
<title>Thundering Herd Problem - Solution With Node.js and Promise</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">雷群问题Node.js和Promise的解决方案</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/thundering-herd-problem-solution-with-node-js-and-promise-e8bc55dc5105?source=collection_archive---------3-----------------------#2022-12-17">https://javascript.plainenglish.io/thundering-herd-problem-solution-with-node-js-and-promise-e8bc55dc5105?source=collection_archive---------3-----------------------#2022-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="3b47" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">在<a class="ae km" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>中，当大量等待事件的进程或线程在事件发生时被唤醒，但只有一个进程能够处理该事件时，就会出现<strong class="jq io">雷群问题</strong>。当进程醒来时，它们将各自尝试处理事件，但只有一个会胜出。所有进程都会争夺资源，可能会冻结计算机，直到群体再次平静下来。— <a class="ae km" href="https://en.wikipedia.org/wiki/Thundering_herd_problem" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="e773" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">对于web服务，当许多客户端请求相同的数据时，应该在服务器端缓存这些数据。问题是许多请求从缓存中读取空值，并试图从数据库中加载数据。因此，我们会有许多不必要的数据库负载，因为所有请求都对数据库执行相同的查询。</p><h1 id="ee0c" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">证明</h1><p id="5f8a" class="pw-post-body-paragraph jn jo in jq b jr lo jt ju jv lp jx jy kn lq kb kc ko lr kf kg kp ls kj kk kl ig bi translated">我们使用一个返回json对象的基本API来演示。</p><p id="1b47" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">当<code class="fe lt lu lv lw b">GET /posts</code> API被触发时，将调用<code class="fe lt lu lv lw b">PostService</code>的<code class="fe lt lu lv lw b">getPosts</code>函数。</p><p id="8aa4" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated"><code class="fe lt lu lv lw b">index.ts</code></p><pre class="lx ly lz ma gt mb lw mc bn md me bi"><span id="b28e" class="mf kr in lw b be mg mh l mi mj">import express from 'express';<br/>import postService from './post.service';<br/><br/>const app = express();<br/><br/>app.get('/', (req, res) =&gt; {<br/>  res.json({ message: 'Hello World!' });<br/>});<br/><br/>app.get('/posts', async (req, res) =&gt; {<br/>  res.json({ posts: await postService.getPosts() });<br/>});<br/><br/>app.listen(3000, () =&gt; {<br/>  console.log('Server is listening on :3000');<br/>});</span></pre><p id="d87d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated"><code class="fe lt lu lv lw b">getPosts</code>是一个支持缓存的从数据库中检索数据的常用函数。</p><p id="b1e6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated"><code class="fe lt lu lv lw b">post.service.ts</code></p><pre class="lx ly lz ma gt mb lw mc bn md me bi"><span id="0e60" class="mf kr in lw b be mg mh l mi mj">import postRepository, { IPost } from './post.repository';<br/>import cacheService from './cache.service';<br/><br/>const getPosts = async (): Promise&lt;IPost[]&gt; =&gt; {<br/>  const cache = await cacheService.getPosts();<br/>  if (cache) {<br/>    console.count('Hit cache');<br/>    return cache;<br/>  }<br/><br/>  console.count('Hit database');<br/>  const posts = await postRepository.getPosts();<br/>  await cacheService.setPosts(posts);<br/><br/>  return posts;<br/>};<br/><br/>export default {<br/>  getPosts,<br/>} as const;</span></pre><p id="e15e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">看起来没问题，所以我们首先从缓存中检索数据。如果数据存在，我们立即返回；否则，我们从数据库中检索它，保存到缓存中，然后返回它(<a class="ae km" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" rel="noopener ugc nofollow" target="_blank"> cache-aside pattern </a>)。).</p><p id="a893" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">当对服务功能的请求很多，但缓存中没有数据时，就会出现雷群问题。相同的查询将用于所有访问数据库的请求。</p><figure class="lx ly lz ma gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mk"><img src="../Images/65d627cff3af01eacdcf94b5d642207b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1u583g3yPujys18Y3oAbSA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Thundering herd issue</figcaption></figure><p id="5f3e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">当服务器最近重启时，我同时向<code class="fe lt lu lv lw b">POST /posts</code> API发送了20个请求:</p><pre class="lx ly lz ma gt mb lw mc bn md me bi"><span id="c66d" class="mf kr in lw b be mg mh l mi mj">#!/bin/bash<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts &amp;<br/>curl http://localhost:3000/posts</span></pre><p id="1254" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">之后，数据库将被多次命中</p><pre class="lx ly lz ma gt mb lw mc bn md me bi"><span id="3793" class="mf kr in lw b be mg mh l mi mj">Server is listening on :3000<br/>Hit database: 1<br/>Hit database: 2<br/>Hit database: 3<br/>Hit database: 4<br/>Hit database: 5<br/>Hit database: 6<br/>Hit database: 7<br/>Hit database: 8<br/>Hit database: 9<br/>Hit database: 10<br/>Hit database: 11<br/>Hit database: 12<br/>Hit database: 13<br/>Hit database: 14<br/>Hit database: 15<br/>Hit database: 16<br/>Hit database: 17<br/>Hit database: 18<br/>Hit database: 19<br/>Hit database: 20</span></pre><h1 id="1aec" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">解决办法</h1><p id="6efd" class="pw-post-body-paragraph jn jo in jq b jr lo jt ju jv lp jx jy kn lq kb kc ko lr kf kg kp ls kj kk kl ig bi translated">要解决这个问题——雷霆万钧，如何应对是个好主意？我们需要解决太多缓存未命中的根本原因。<br/>为了解决缓存未命中，我们将有两个标题:</p><ul class=""><li id="4f8d" class="mw mx in jq b jr js jv jw kn my ko mz kp na kl nb nc nd ne bi translated">缓存预热:尽可能减少缓存未命中，我们应该保证缓存中的数据始终存在——避免出现保留空间未被填满的情况。初始化、重新启动缓存服务器时缓存为空，或者缓存中的数据已过期。</li><li id="40ea" class="mw mx in jq b jr nf jv ng kn nh ko ni kp nj kl nb nc nd ne bi translated">缓存锁定:只有第一个请求可以访问数据库，其他请求将被锁定，直到第一个请求将结果更新到缓存。</li></ul><p id="e4b7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">我的服务器用的是Node.js，那我就用Promise API实现缓存锁定。</p><p id="3945" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">更新发布服务:</p><pre class="lx ly lz ma gt mb lw mc bn md me bi"><span id="fe38" class="mf kr in lw b be mg mh l mi mj">import postRepository, { IPost } from './post.repository';<br/>import cacheService from './cache.service';<br/><br/>let promise: Promise&lt;IPost[]&gt; | null = null;<br/><br/>const getPosts = async (): Promise&lt;IPost[]&gt; =&gt; {<br/>  const cache = await cacheService.getPosts();<br/>  if (cache) {<br/>    console.count('Hit cache');<br/>    return cache;<br/>  }<br/><br/>  if (promise) {<br/>    return promise;<br/>  }<br/><br/>  try {<br/>    console.count('Hit database');<br/>    promise = postRepository.getPosts();<br/><br/>    const posts = await promise;<br/>    await cacheService.setPosts(posts);<br/><br/>    return posts;<br/>  } finally {<br/>    promise = null;<br/>  }<br/>};<br/><br/>export default {<br/>  getPosts,<br/>} as const;</span></pre><p id="244a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">变量将作为一个锁。当缓存为空并且<code class="fe lt lu lv lw b">promise</code>为空(第一个请求)时，我们访问数据库以获取帖子并生成帖子结果的承诺(将其存储在<code class="fe lt lu lv lw b">promise</code>变量中)。得到帖子后，我们将它们保存到缓存中并释放锁柜。</p><p id="3431" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">另一个请求将从缓存中获取数据或等待相同的承诺，它们将永远不会触及数据库。<br/> <code class="fe lt lu lv lw b">promise = postRepository.getPosts();</code> —是的，我们不是<code class="fe lt lu lv lw b">getPosts()</code>功能上的<code class="fe lt lu lv lw b">await</code>。</p><p id="e1b7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">再次运行测试，现在只有一个数据库命中:</p><pre class="lx ly lz ma gt mb lw mc bn md me bi"><span id="5343" class="mf kr in lw b be mg mh l mi mj">Server is listening on :3000<br/>Hit database: 1</span></pre><h1 id="3005" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="da6d" class="pw-post-body-paragraph jn jo in jq b jr lo jt ju jv lp jx jy kn lq kb kc ko lr kf kg kp ls kj kk kl ig bi translated">在实现缓存时，最著名的问题之一就是雷群或缓存踩踏。我们可以用很多方法解决这个问题，有时解决方案会基于你的编程语言。这个故事是Node.js和Promise API的一个例子。</p><p id="1622" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">参考:<a class="ae km" href="https://instagram-engineering.com/thundering-herds-promises-82191c8af57d" rel="noopener ugc nofollow" target="_blank">雷霆万钧&amp;承诺</a></p><p id="dcd2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">感谢您的阅读！</p><p id="a8bf" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated"><em class="jp">更多内容看</em> <a class="ae km" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq io"> <em class="jp">说白了。报名参加我们的</em> <a class="ae km" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq io"> <em class="jp">免费周报</em> </strong> </a> <em class="jp">。关注我们关于</em> <a class="ae km" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jq io"> <em class="jp">推特</em> </strong> </a>，<a class="ae km" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jq io"><em class="jp">LinkedIn</em></strong></a><em class="jp">，</em><a class="ae km" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jq io"><em class="jp">YouTube</em></strong></a><em class="jp">，以及</em> <a class="ae km" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jq io"> <em class="jp">不和</em> </strong> </a> <strong class="jq io"> <em class="jp">。</em>T59】</strong></strong></a></p><p id="81d8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">有兴趣缩放你的软件启动</em> </strong> <em class="jp">？检查出</em> <a class="ae km" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jq io"> <em class="jp">电路</em> </strong> </a> <em class="jp">。</em></p></div></div>    
</body>
</html>