<html>
<head>
<title>TypeScript: Typing Form Events in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:在React中键入表单事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-typing-form-events-in-react-3beb88eb467d?source=collection_archive---------15-----------------------#2022-09-05">https://javascript.plainenglish.io/typescript-typing-form-events-in-react-3beb88eb467d?source=collection_archive---------15-----------------------#2022-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f05fe588a5644fc2eaba1e7e45f231c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LW7CpOOGXzcg-85r.jpg"/></div></div></figure><p id="242b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React中处理事件的方式与DOM元素上处理事件的方式非常接近。</p><p id="9c74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一些小的区别，例如，事件名称遵循camel大小写约定，而在DOM中它们都是小写的；函数本身作为事件处理程序传递，而不是以字符串形式传递其名称。</p><p id="29d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，最大的区别是，React将原生DOM事件包装到<code class="fe kw kx ky kz b">SyntheticEvent</code>中，使它们的行为与原生事件略有不同。<a class="ae la" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a>详细解释了合成事件的来龙去脉。因此，在React中键入表单事件与本地事件不同，React提供了自己的类型。在这篇文章中，我们将看到如何在React中以一个简单的组件为例输入表单事件，并讨论最常见的陷阱。</p><p id="77e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们以这个简单的注册表单为例:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="60de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想收集表单数据并将其发送到服务器，有两个主要选项。第一个是保持表单不受控制并在<code class="fe kw kx ky kz b">onSubmit</code>回调中获取数据，第二个是存储表单状态的数据并在表单提交时发送。我们将在这里考虑这两种方法。</p><h1 id="5be4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">非受控形式</h1><p id="8288" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">为了在提交时获取表单数据，我们将添加<code class="fe kw kx ky kz b">onSubmit</code>回调，并通过其<code class="fe kw kx ky kz b">name</code>属性从每个元素中检索数据。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="5cfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们在这里省略了数据验证和错误处理(以及CSS样式)。重要的叫<code class="fe kw kx ky kz b">event.preventDefault()</code>；首先，因为表单提交将在我们收集数据之前重新加载页面。从回调返回<code class="fe kw kx ky kz b">false</code>在这里不起作用，这是合成事件和原生DOM事件的区别之一。为了收集表单数据，我们可以通过元素的id或者目标的<code class="fe kw kx ky kz b">elements</code>属性直接从事件的目标访问它，例如<code class="fe kw kx ky kz b">email: event.target.email.value</code>和<code class="fe kw kx ky kz b">email: event.target.elements.email.value</code>都工作。也可以使用<code class="fe kw kx ky kz b">name</code>属性来获取表单元素的值，但是因为我们已经设置了id(通过<code class="fe kw kx ky kz b">htmlFor</code>属性将我们的输入连接到它们的标签)，我们将在这里使用<code class="fe kw kx ky kz b">id</code>。</p><p id="b698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会注意到事件的类型是<code class="fe kw kx ky kz b">any</code>,这意味着现在没有类型检查。为了解决这个问题，我们需要为<code class="fe kw kx ky kz b">onSubmit</code>回调定义事件的类型。对于合成事件，我们将使用React提供的类型定义。第一种选择是使用带有<code class="fe kw kx ky kz b">HTMLFormElement</code>类型参数的<code class="fe kw kx ky kz b">React.FormEvent</code>。这种方法虽然通常是正确的，但对我们的表单并不适用，因为我们想要从<code class="fe kw kx ky kz b">target</code>属性中检索数据，该属性获得通用的<code class="fe kw kx ky kz b">EventTarget</code>类型。这是因为<code class="fe kw kx ky kz b">FormEvent</code>类型最终归结为<code class="fe kw kx ky kz b">BaseSyntheticEvent&lt;E, EventTarget &amp; T, EventTarget&gt;</code>，其中最后一个<code class="fe kw kx ky kz b">EventTarget</code>参数用于<code class="fe kw kx ky kz b">target</code>属性类型。似乎我们无法控制目标属性的类型，即使我们控制了(如果需要，我们总是可以断言类型),它仍然不知道我们的表单有哪些表单元素。深入查看<code class="fe kw kx ky kz b">BaseSyntheticEvent</code>的类型定义，我们可以看到第二个类型参数<code class="fe kw kx ky kz b">EventTarget &amp; T</code>被分配给事件的<code class="fe kw kx ky kz b">currentTarget</code>属性。似乎要解决我们的类型问题，我们只需要从<code class="fe kw kx ky kz b">event.target</code>切换到<code class="fe kw kx ky kz b">event.currentTarget</code>。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="dfe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果表单中没有id为<code class="fe kw kx ky kz b">name</code>的input元素，这个<em class="mk">几乎</em>也能正常工作。目前，我们的<code class="fe kw kx ky kz b">currentTarget.name</code>覆盖了<code class="fe kw kx ky kz b">HTMLFormElement</code>的<code class="fe kw kx ky kz b">name</code>属性。然而，这种方法有一个更大的问题，那就是缺乏对目标属性的正确类型检查。例如，我们可以尝试通过<code class="fe kw kx ky kz b">address: target.address.value</code>访问一个不存在的表单元素，它不会被TS捕获，因为它不知道表单中有什么元素。如果我们能够定义id - element对并相应地键入当前目标，那就更好了。为此，我们需要研究一下<code class="fe kw kx ky kz b">HTMLFormElement</code>的类型定义。我们可以看到它有<code class="fe kw kx ky kz b">readonly elements: HTMLFormControlsCollection;</code>，有随手可得的文档——<code class="fe kw kx ky kz b">Retrieves a collection, in source order, of all controls in a given form</code>。这是我们之前讨论过的<code class="fe kw kx ky kz b">event.target.elements</code>属性，除了在这种情况下它在<code class="fe kw kx ky kz b">currentEvent</code>上。</p><p id="d162" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">连接一切，看起来我们可以用表单元素扩展<code class="fe kw kx ky kz b">HTMLFormControlsCollection</code>，然后用那个接口覆盖<code class="fe kw kx ky kz b">HTMLFormElement.elements</code>。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="5fb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这解决了类型问题，并在访问表单元素的值时提供了正确的类型检查。</p><h1 id="3330" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">受控形式</h1><p id="dfcd" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">虽然知道如何正确地键入不受控制的表单的事件处理程序很有用，但这种表单在React组件中并不常见。大多数情况下，我们希望表单包含受控元素，这些元素的值/回调也可以来自父组件。在这种情况下，通常将表单值保存到组件的状态，然后在提交表单时将它们发送到服务器，甚至不使用表单的submit事件。幸运的是，键入这样的事件处理程序比上面的例子更简单。</p><p id="1377" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，让我们将用户输入的值保存到状态中，然后在用户单击<code class="fe kw kx ky kz b">Sign up</code>时通过API发送它们。为了简单起见，我们将使用一个状态对象(类似于状态在基于类的组件中的保存方式)。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="889c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常最好使用<code class="fe kw kx ky kz b">useReducer</code>钩子来处理复杂的状态，但是,<code class="fe kw kx ky kz b">useState</code>适用于本演示。为了更新表单元素的状态值，我们需要为每个字段分配<code class="fe kw kx ky kz b">onChange</code>处理程序。这里最明显的做法是给每个元素分配不同的<code class="fe kw kx ky kz b">onChange</code>处理程序，例如:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="ab76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，有一种更简单的方法。类似于表单的submit事件将所有元素id或名称保存到目标中，change事件的目标具有<code class="fe kw kx ky kz b">name</code>和<code class="fe kw kx ky kz b">id</code>属性，可以用来将相应元素的值分配给状态。由于我们已经在字段上定义了id(这些id与我们收集数据的字段同名)，我们将使用它们将字段数据与州匹配。不过这种方法有一个小问题，那就是我们有一个复选框元素。对于复选框元素，我们寻找的是<code class="fe kw kx ky kz b">checked</code>属性，而不是<code class="fe kw kx ky kz b">value</code>。在这种情况下，每个元素类型都有一个单独的处理程序是可以的，例如<code class="fe kw kx ky kz b">onInputChange</code>和<code class="fe kw kx ky kz b">onCheckboxChange</code>，但是，因为我们有一个只有一个复选框的简单表单，所以让我们给处理程序添加一个条件，它将根据目标的类型检索复选框字段的<code class="fe kw kx ky kz b">checked</code>属性。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="4c0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，对于提交事件，我们还恢复到了<code class="fe kw kx ky kz b">FormEvent&lt;HTMLFormElement&gt;</code>类型，因为我们不再访问它的值。现在我们只需要输入<code class="fe kw kx ky kz b">onChange</code>事件。最初，我们试图将事件类型化为<code class="fe kw kx ky kz b">React.ChangeEvent</code>，但是这似乎还不够，因为我们得到了一个类型错误，即我们试图访问的所有属性在事件的目标上都不存在。查看<code class="fe kw kx ky kz b">ChangeEvent</code>的定义，我们可以看到它接受类型参数，默认为泛型<code class="fe kw kx ky kz b">Element</code>。因为表单的所有元素都是输入，我们将把这个类型传递给<code class="fe kw kx ky kz b">ChangeEvent</code> - <code class="fe kw kx ky kz b">const onFieldChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {</code>。现在，所有目标的属性都被正确识别了，但是，当将<code class="fe kw kx ky kz b">event.target.checked</code>重新分配给值- <code class="fe kw kx ky kz b">Type 'boolean' is not assignable to type 'string'</code>时，出现了一个新问题。这是因为当我们用<code class="fe kw kx ky kz b">let value = event.target.value;</code>声明value时，TS推断它的类型是string，这是输入值的类型。为了解决这个问题，我们需要让TS知道我们的值也可以是一个布尔值:<code class="fe kw kx ky kz b">let value: string | boolean = event.target.value;</code>。这工作得很好，但是，如果TS能根据状态自动推断出值的类型不是更好吗？例如，假设我们添加了一个新字段<code class="fe kw kx ky kz b">age</code>，它输入了一个类型号。为了将它保存到state中，我们将这个块添加到<code class="fe kw kx ky kz b">onFieldChange</code>:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="6485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了消除TS错误，我们必须将值的类型更新为<code class="fe kw kx ky kz b">boolean | string | number</code>。但是如果我们最终决定删除年龄字段呢？我们还需要记住再次更新值类型。我们可以定义一个单独的<code class="fe kw kx ky kz b">State</code>类型，在这里我们声明所有字段的类型，然而，有一个更好的方法。我们已经从状态中获得了状态值的类型，并且我们知道这些类型是每个字段仅有的类型。在这种情况下，最好从现有数据中推断出类型，因为这样会在数据结构发生变化时自动保持它们的同步。为了从状态中推断出类型，我们可以使用简洁的TS符号- <code class="fe kw kx ky kz b">let value: typeof state[keyof typeof state] = event.target.value;</code>。这里我们告诉TS，我们期望<code class="fe kw kx ky kz b">value</code>是状态上存在的值的类型，如果将来它们中的任何一个发生变化，这些变化将自动反映在<code class="fe kw kx ky kz b">value</code>的类型中。表单的最终代码如下所示:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="89a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mk">原载于</em><a class="ae la" href="https://claritydev.net/blog/typescript-typing-form-events-in-react/" rel="noopener ugc nofollow" target="_blank"><em class="mk"/></a><em class="mk">。</em></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="894c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mk">更多内容请看</em> <a class="ae la" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mk">说白了。报名参加我们的</em> <a class="ae la" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mk">免费周报</em> </strong> </a> <em class="mk">。关注我们</em> <a class="ae la" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mk">推特</em> </strong> </a>，<a class="ae la" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mk">LinkedIn</em></strong></a><em class="mk">，</em><a class="ae la" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mk">YouTube</em></strong></a><em class="mk">，以及</em> <a class="ae la" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mk">不和</em> </strong> </a> <em class="mk">。</em></strong></a></p></div></div>    
</body>
</html>