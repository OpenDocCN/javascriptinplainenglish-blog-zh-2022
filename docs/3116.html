<html>
<head>
<title>Is setState Executed Synchronously or Asynchronously in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中setState是同步执行还是异步执行？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/is-setstate-executed-synchronously-or-asynchronously-in-react-9b81d67f3e03?source=collection_archive---------2-----------------------#2022-08-02">https://javascript.plainenglish.io/is-setstate-executed-synchronously-or-asynchronously-in-react-9b81d67f3e03?source=collection_archive---------2-----------------------#2022-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="010a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">找出在React中setState是同步执行还是异步执行。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e1ada3a4c0104c9d02ea939c6220569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*70GASofLc5Qd5UU0"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@blakeverdoorn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Blake Verdoorn</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="db36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">setState是同步的还是异步的？它必须是异步的。你确定吗？然后看看这段代码输出了什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">状态在setTimeout中被修改两次，并且状态的值被打印出来。如果是异步的，它应该打印count没有被修改，仍然是0，所以它打印0两次。然后初始化渲染一次，setState再次渲染后应该渲染两次，计数分别为0和2。异步分析确实应该如此。我们执行吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/b81cdba7ee4dd8e69999aaba9c802e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*I6KIdik5B0yqk7oOar6bGg.png"/></div></figure><p id="5aed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们发现这两个打印是1和2，也就是说setState同步修改了状态，然后每次都触发渲染，所以渲染了3次，分别是0，1，2。所以setState是同步的？你确定吗？然后看看这段代码输出了什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b83f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果setState是同步的，它将在执行后修改状态并应分别打印1、2和3，然后触发render三次，加上第一次，总共四次，打印0、1、2和3。我们执行吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/40b03475ac9f96db90aba67779130761.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*-q_zeyzm36XmBRADhHw2vw.png"/></div></figure><p id="3b17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">三次打印都是0，这意味着setState是异步的。并且三个setStates只触发了一次render，加上第一次render，两次，打印0和3。什么鬼，怎么又异步了？不仅是类组件的setState，还有函数组件的useState。例如，如果状态被修改三次，它将只呈现一次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/118cbbc75dbacd8b2b412f7c8db969c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*Yl_vp3GHIdvStuRY9JfTmA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/d3669245a91e543cfe00c902b5ba69c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*TA6MuZZ_XC_C8okrrQ0jDQ.png"/></div></figure><p id="a0ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在setTimeout中，每次修改状态时，都会呈现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/d6360d1e9ea9766edd61cc1d663bdc13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*Wcr_G6F7quLB9vhPd0muOg.png"/></div></figure><p id="d540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是不是有点混乱，setState什么时候同步，什么时候异步？我们来看看setState的源代码。首先，我们来了解一下React渲染的流程。</p><h2 id="dc2a" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">反应渲染流</h2><p id="517c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">react通过JSX描述接口，可以通过babel等编译器编译成渲染函数，然后执行产生vdom。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f78bbcb08c242c86d431056ee39852c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*C23DkUxjnTxADCELGqC8Yw.png"/></div></figure><p id="8a66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该vdom不是直接渲染的，而是首先转换成纤维，然后进行渲染。由于vdom中的每个节点只记录子节点，而不是兄弟节点，因此必须不间断地同时渲染。转换成纤程的链表结构会记录父(返回)、子(子)和兄弟(兄弟)节点，所以它变得可中断。这里vdom是React元素对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/014b879de572b1433a063f59abed62d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*ZNrJw53YW2G0pBKhbwBJDQ.png"/></div></figure><p id="32e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在转换成纤维后，它是FiberNode的对象:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/418620078be10c1c3d8531f240364693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*4Ct2YQzvzZQKPj4kEDzQ_Q.png"/></div></figure><p id="11af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从vdom转换到纤程的过程称为reconcile，它在这个过程中创建相应的dom元素，然后在所有转换完成后立即提交到dom。这个过程不是一次性的，而是由调度程序执行的，所以它可以批量执行，这意味着它可以被中断。这是React的纤程架构下的渲染过程。理论说完了，让我们看看源代码(这里是v17源代码)。</p><p id="5b51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React调用调度和协调渲染阶段，这是将vdom转换为纤程的阶段。(schedule只是允许reconcile执行多次，可以被中断，但是它做的事情是一样的，所以schedule也是渲染阶段的一部分)。将纤程更新为dom的过程称为提交阶段。源代码中的等效代码如下</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/8526de5a6020a0a9eea0a272f8c83734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*P8LAb3gEXpxQT5anIh8KTA.png"/></div></div></figure><p id="1da3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个performSyncWorkOnRoot是渲染的入口点，如前所述，它首先执行渲染阶段，将vdom转换为纤程，然后执行提交，更新为dom。渲染阶段执行一个调度循环:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/52b63166c733116d5b7544a593c53703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*DjLWX8xSKnwHJ7dlMeD4uw.png"/></div></figure><p id="0dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个循环是不断处理一个又一个纤程的协调:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e73abc37ed4a99ccbf399a46b893cd96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*U2Ciyci5XLLe6ef7KrUVgw.png"/></div></figure><p id="209d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个节点有两个阶段:beginWork和completeWork，因为vdom为纤程，而vdom是树形结构，需要递归处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/ce8e09ab7b6c53fcdb864b101b40fe91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*lC5moCF8BHgsHV0Q6DbZJw.png"/></div></figure><p id="1a1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不同节点的协调逻辑不同:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/4590d337a6038d5eb09396546cf33cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*ogcrimpFkr1u3LwKIi_6DA.png"/></div></figure><p id="6911" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，将调用函数组件来获取呈现的vdom并继续协调:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/4d9be5bc06ff083d7f0197d37c8e1827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2GqJrOQxI5LFt0JwQEMFA.png"/></div></div></figure><p id="a68a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，类组件将创建一个实例，调用render方法，获取vdom，然后继续处理renconcileChildren。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/5dfb2b6f434fbdfa606e73ce56ba011b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*MTSTYFzn3tpVj_wQIhPYlg.png"/></div></figure><p id="8d0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，vdom到光纤是一个递归过程。之后，将进入提交阶段。整个渲染过程的入口点是performSyncWorkOnRoot函数。渲染过程完成后，下一步是setState如何触发渲染过程。</p><h2 id="935a" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">setState的流程</h2><p id="ce15" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们知道渲染的入口点是performSyncWorkOnRoot函数，那么在setState修改状态后触发这个函数还不够吗？确实如此。setState调用dispathAction创建一个update对象放在纤程节点的updateQueue上，然后调度呈现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c654b31d7a039e1edb7a42e071c4eaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*DA-gGaeVPWQOM_cf8hfPdA.png"/></div></figure><p id="7d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调度更新自然意味着调度上面描述的performSyncWorkOnRoot函数。React将首先从触发更新的纤程中找到根纤程节点，然后调用performSyncWorkOnRoot函数来呈现它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/563ea4f5ff40fbabb85eb00cefe76ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*brLQekwVhHRE29SPpW5XRg.png"/></div></figure><p id="0fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是在setState之后触发重新呈现的实现。这是我们控制setState是同步还是异步的地方。我们看到判断条件中有一个excutionContext，用来标识当前环境，比如是批处理还是非批处理，是否执行了render阶段或者commit阶段。执行ReactDOM.render时，首先调用unbatchUpdates函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/61784b5d9fa4dd690a7283fa0404ba64.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*YdTizKd-BJKly3hpWdcO0Q.png"/></div></figure><p id="65fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此函数在excutionContext中设置一个unbatch标志:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fd00e618685f8d52ae5e401645b955f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*oj0dKdbTZ46coMpRqx4PHQ.png"/></div></figure><p id="48bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以便在进行更新时，将立即执行performSyncWorkOnRoot进行渲染。因为第一次渲染是立即完成的，所以不需要安排时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/5ab7134e8efb1e494924d4c0cbe8a596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*chRNe370EalF7ebASMc-Hw.png"/></div></figure><p id="0c44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此后，当我们到达提交阶段时，将设置一个提交标志:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9a6136858ec84b522897fdaaf9ce44bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*fu5k2p38iBLxKAv4OVaxIQ.png"/></div></figure><p id="6e53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后再次设置State，这样它就不会转到unbatch分支。<strong class="ky ir">那么为什么setTimeout里面的setState是同步执行的呢？</strong>因为直接从setTimeout执行的异步代码没有设置为excutionContext，所以转到NoContext分支，立即渲染。(这里的flush最终会调用performSyncWorkOnRoot函数进行渲染)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ed9712ba9541d19236d6ddeb7040a301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*QBK4kofDndkFUht7ZLvyGA.png"/></div></figure><p id="9a32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有没有办法让setTimeout中执行的函数也有一个excutionContext？React17公开了batchUpdates API，它将setState封装在其中，并批量执行它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b111e087116af5ad18df4bb093412589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*ezbLkjsPRMD0gufa7SbJyA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/04ccbe8002bbbfee976c2899e121834f.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*Eh6ZZbstvLiLsDmTefm9Uw.png"/></div></figure><p id="d0a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的源代码实际上设置了excutionContext:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/44c02904c832517c6cc29f738cbb2df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*5PJlAYnrkvZ8rQKhvUaEGg.png"/></div></figure><p id="65af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样当setState全部执行完再刷新时，调用peformSyncWorkOnRoot进行渲染，效果就是一个批处理setState。事实上，根据定义，setState不能被异步调用，或者在同一个调用堆栈中执行，只是顺序不同。只能称之为批量或非批量。react17就是这样处理的。如果我们使用react18中的createRoot API，就不会有这个问题，甚至setTimeout中的代码也可以批量执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/dccdd2c48185d6c987f619e62bec89c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*u3i7Utz_MeUyh2DJ_OM7Fg.png"/></div></figure><p id="4d0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了与React17兼容，进行了特殊处理，以便在未启用并发模式时，即仍使用ReactDOM.render API时，不指定excutionContext，而是立即呈现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c06a1e24e7d0b7415c4db5fabe18ddf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*v1RzkZQSKIbDAVli7xcRQg.png"/></div></figure><p id="b22d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等React 18普及了，所有的setState都是批处理的，就不会再有批处理和非批处理的问题了。</p><h2 id="2bb3" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">摘要</h2><p id="c2b7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">虽然我们说的是同步异步setState，但这并不是像setTimeout或者Promise那样的异步，而只是setState之后状态是否立即改变，是否立即呈现。</p><p id="2d9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们梳理了React的渲染过程，包括渲染阶段和提交阶段，渲染阶段是从vdom到fiber的过渡，包括调度和调和，提交阶段是fiber到dom的更新。功能。</p><p id="7c1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">setState创建一个update对象来挂钩纤程对象，然后调度performSyncWorkOnRoot来重新呈现它。</p><p id="660f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React 17中，setState是批量执行的，因为executionContext是在执行前设置的，但是在setTimeout和事件监听器这样的函数中，executionContext是不设置的，setState是同步执行的。您可以将batchUpdates函数包装在外部，并手动设置excutionContext以切换到异步批处理执行。</p><p id="fd29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React 18中，如果使用createRoot API，就不会有这个问题。</p><p id="89db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React 18普及之后，setState是同步还是异步的问题就不是问题了，因为所有的setState都是批量异步执行的。</p><p id="e9bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">请关注我，阅读更多高质量文章。</strong></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="5ae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ny">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ny">plain English . io</em></strong></a><em class="ny">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ny">Twitter</em></strong></a><strong class="ky ir"><em class="ny"/></strong><em class="ny">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ny">LinkedIn</em></strong></a><em class="ny">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">社区不和谐</em> </strong> </a> <em class="ny">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">人才集体</em> </strong> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>