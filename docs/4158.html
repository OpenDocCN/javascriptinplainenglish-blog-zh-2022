<html>
<head>
<title>What’s New in Next.js 13 — and Why it Matters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js 13中的新特性——以及它的重要性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-new-in-next-js-13-and-why-it-matters-e174171976a8?source=collection_archive---------7-----------------------#2022-11-01">https://javascript.plainenglish.io/whats-new-in-next-js-13-and-why-it-matters-e174171976a8?source=collection_archive---------7-----------------------#2022-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="50a8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React的服务器端渲染框架一直在变得越来越好——下面是新特性</h2></div><p id="4ed9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上周，<a class="ae lb" href="http://vercel.com" rel="noopener ugc nofollow" target="_blank"> Vercel </a>在他们的开发者大会上宣布了<a class="ae lb" href="https://nextjs.org/blog/next-13" rel="noopener ugc nofollow" target="_blank"> Next.js 13 </a>。目前处于测试阶段的新版本引入了大量令人兴奋的新功能，并有助于围绕React的服务器端渲染以及它如何与交互式客户端组件联系在一起讲述一个更强大、更有凝聚力的故事。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/a2ed23a7e2d16d2c2637a93c75f4d9d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HTVdPh1EvYSb9nyi.png"/></div></div></figure><p id="8137" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将简要介绍Next.js，然后分解Next.js 13中的一些新功能，并讨论它们为什么重要。</p><h1 id="94dc" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Next.js是什么，为什么用它？</h1><p id="6ed7" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Next.js 是一个基于React的开发框架，支持服务器端渲染、额外的服务器端功能和改进的开发和部署工具链。</p><p id="08df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Next.js进行服务器端呈现的最大好处是在性能和SEO方面:通过在服务器上呈现，应用程序完全呈现的初始状态可以在单个请求中提供。这意味着浏览器要做的工作更少，也意味着内容可以很容易地被搜索引擎索引。这也意味着渲染数据可以被缓存(部分或全部)以进一步提高性能。</p><p id="32b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些Next.js特性有助于建立在React的强大基础之上，并弥补了纯客户端方法的一些缺点。对于任何重视性能和搜索引擎优化的应用来说，Next.js是一个受欢迎的补充。因此，有了Next.js的背景知识，让我们深入了解即将到来的Next.js 13版本中会有什么。</p><h1 id="435b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">基于文件的路由的应用程序/目录</h1><p id="0f1f" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Next.js最大的特性之一是<em class="ml">基于文件的路由。</em>不用在像<a class="ae lb" href="https://reactrouter.com/en/main" rel="noopener ugc nofollow" target="_blank"> react-router </a>这样的工具中处理复杂的路由配置，可以使用项目目录的结构来指定路由。只需在<code class="fe mm mn mo mp b">pages</code>目录中放置一个入口点，就创建了一条新路径。</p><p id="40e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Next.js 13建立在这个概念之上，并提供了新目录的<a class="ae lb" href="https://beta.nextjs.org/docs/routing/fundamentals" rel="noopener ugc nofollow" target="_blank">重新设计的文件路由。app directory(可选)引入了一个新的布局结构，具有几个新的特性和增强功能。</a></p><p id="e1de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了新的路由方案，目录结构有所改变。在Next.js 13中，路径中的每个路径现在都有一个专用的<em class="ml">目录</em>，其中有一个包含内容入口点的<code class="fe mm mn mo mp b">page.js</code>。下表显示了Next.js 12和13中的基本路由有何不同:</p><pre class="ld le lf lg gt mq mp mr ms aw mt bi"><span id="062c" class="mu lp iq mp b gy mv mw l mx my"># Route      Next.js 12          Next.js 13 <br/>/            pages/index.js      app/page.js <br/>/blog        pages/blog.js.      app/blog/page.js <br/>/blog/new    pages/blog/new.js   app/blog/new/page.js</span></pre><p id="18b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了一个路径的<code class="fe mm mn mo mp b">page.js</code>，新的结构让我们在每个路径目录中包含另外几个<em class="ml">特殊的</em>文件，包括:<code class="fe mm mn mo mp b">layout.js</code>，一个路径(和所有子路径)的布局组件；<code class="fe mm mn mo mp b">loading.js</code>，一个组件为瞬间加载状态使用<code class="fe mm mn mo mp b">React.Suspense</code>罩下；以及<code class="fe mm mn mo mp b">error.js</code>，主组件加载失败时渲染的组件。</p><p id="fe1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为每个路径现在都是它自己的目录，所以我们还可以在路径目录中<a class="ae lb" href="https://beta.nextjs.org/docs/routing/fundamentals#colocation" rel="noopener ugc nofollow" target="_blank">存放源文件。我们可以包括其他组件，以及样式、测试等:</a></p><pre class="ld le lf lg gt mq mp mr ms aw mt bi"><span id="7c24" class="mu lp iq mp b gy mv mw l mx my">app/blog/page.js <br/>app/blog/Header.js <br/>app/blog/Header.css <br/>app/blog/Header.test.js</span></pre><p id="b3e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于文件的路由一直是一个很棒的特性，新的<code class="fe mm mn mo mp b">app/</code>目录将它推向了一个新的高度。它简化了开发，并且(可能有点怀旧)有助于恢复构建更多静态站点的简单性:内容路径与内容目录结构相匹配。同样，使用新的<code class="fe mm mn mo mp b">app/</code>目录是完全可选的，因此您不必马上迁移到新的结构。</p><h1 id="3ad3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">React服务器组件</h1><p id="96cb" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Next.js 13下一个令人兴奋的变化是增加了对<a class="ae lb" href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> React服务器组件</em> </a> <em class="ml">的支持。</em>服务器组件让我们可以在服务器端执行和渲染React组件，以实现更快的交付、更小的JavaScript包和更低的客户端渲染成本。</p><p id="e36a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，根据渲染路线所需的数据类型，服务器组件可以在构建时或运行时自动缓存，以获得额外的性能优势。</p><p id="a59b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务器和客户机组件的功能确实有些不同，所以您需要相应地设计您的应用程序。下表摘自文档，概述了这两种不同类型的组件所具有的功能以及它们的最佳用途。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mz"><img src="../Images/fb77e6b00714e74a57a172ba12797b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czgUzrn9Bhx_6VnAHNVUnw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Table comparing server and client component, taken from the <a class="ae lb" href="https://beta.nextjs.org/docs/rendering/server-and-client-components" rel="noopener ugc nofollow" target="_blank">Next.js documentation</a>.</figcaption></figure><p id="d08d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务器和客户端组件<em class="ml">可以混合使用</em>，这意味着您可以将服务器组件用于应用程序的快速加载、非交互式部分，但在需要交互性、浏览器API等的地方利用客户端组件。</p><p id="a7f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当在Next.js应用程序中构建客户端组件时，您将在文件顶部使用<code class="fe mm mn mo mp b">'use client';</code>指令对其进行相应的标记。注意，如果您使用第三方包，您可能需要<a class="ae lb" href="https://beta.nextjs.org/docs/rendering/server-and-client-components#third-party-packages" rel="noopener ugc nofollow" target="_blank">为那些组件</a>创建一个客户端包装器。</p><h1 id="f8e1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">异步组件和数据提取</h1><p id="bd10" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Next.js 13还引入了一种<a class="ae lb" href="https://beta.nextjs.org/docs/data-fetching/fetching" rel="noopener ugc nofollow" target="_blank">新方法来获取服务器呈现组件</a>的数据:异步组件。对于异步组件，我们可以使用async &amp; await的承诺来呈现组件。如果我们需要从外部服务或其他返回承诺的API获取数据，我们将组件声明为async，并简单地<em class="ml">等待</em>结果:</p><pre class="ld le lf lg gt mq mp mr ms aw mt bi"><span id="3020" class="mu lp iq mp b gy mv mw l mx my">async function getData() { <br/>  const res = await fetch('https://api.example.com/...'); <br/>  return res.json(); <br/>} </span><span id="ce9b" class="mu lp iq mp b gy ne mw l mx my">export default async function Page() { <br/>  const name = await getData(); <br/>  return '...'; <br/>}</span></pre><p id="6196" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以前版本的Next.js使用完全不同的API来解析组件生命周期之外的请求数据，然后将这些数据用作组件道具。此示例显示了从外部服务加载数据的Next.js 12方法:</p><pre class="ld le lf lg gt mq mp mr ms aw mt bi"><span id="9922" class="mu lp iq mp b gy mv mw l mx my">// This gets called on every requestexport async function getServerSideProps() { <br/>  // Fetch data from external API <br/>  const res = await fetch(`https://.../data`) <br/>  const data = await res.json() <br/>  // Pass data to the page via props return <br/>  { props: { data } } <br/>}</span></pre><p id="fc27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">旧的方法仍然受支持<strong class="kh ir">，但是在新的</strong> <code class="fe mm mn mo mp b"><strong class="kh ir">app/</strong></code> <strong class="kh ir">目录</strong>中不受支持。如果你想利用新的<code class="fe mm mn mo mp b">app/</code>目录结构及其所有很酷的新特性，你需要更新你的服务器组件。然而，如果你还没有准备好，你仍然可以为你的应用程序使用Next.js 12 <code class="fe mm mn mo mp b">pages/</code>路由。</p><p id="89ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意，异步渲染和承诺支持<strong class="kh ir">还不可用于客户端组件</strong>——但它正在通过<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/all-about-reacts-proposed-new-use-hook-ba468a2302f6">提议的新挂钩</a>实现:</p><div class="nf ng gp gr nh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/all-about-reacts-proposed-new-use-hook-ba468a2302f6"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">关于React提出的新用途()钩子的所有内容</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">对承诺的一流支持开始起作用了——这是关于它应该如何运作的建议</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw lm ni"/></div></div></a></div><p id="c457" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，与此同时，客户端组件可以使用更传统的异步方法，比如<a class="ae lb" href="https://reactjs.org/docs/react-api.html#suspense" rel="noopener ugc nofollow" target="_blank"> React。悬念</a>和生命周期挂钩，比如<code class="fe mm mn mo mp b">useEffect()</code>，或者使用第三方库来实现这样的功能。</p><h1 id="2946" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">快速捆绑的涡轮包</h1><p id="b5aa" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Next.js 13引入的最后一个主要变化是一个新的JavaScript bundler，<a class="ae lb" href="https://turbo.build/pack" rel="noopener ugc nofollow" target="_blank"> Turbopack </a>，号称是“Webpack的继承者”。Webpack ，最普遍的JavaScript构建工具之一，具有惊人的可配置性和强大的功能，但也可能相当缓慢和笨拙。</p><div class="nf ng gp gr nh ni"><a href="https://blog.devgenius.io/you-dont-need-webpack-3-better-alternatives-for-building-your-javascript-8e8fad5c15cb" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">你不需要web pack——构建JavaScript的3个更好的选择</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">新一代JavaScript bundlers提供了极大改进的开发人员体验</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">blog.devgenius.io</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw lm ni"/></div></div></a></div><p id="4e89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Turbopack由Webpack的创建者创作，但使用Rust构建，并承诺比原始Webpack快700倍(比更现代的替代产品Vite快10倍)。关于相似性和差异的完整分析，请查看<a class="ae lb" href="https://turbo.build/pack/docs/comparisons/turbopack-vs-webpack" rel="noopener ugc nofollow" target="_blank"> Webpack &amp; Turbopack比较</a>。</p><p id="9e24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，Turbopack目前处于alpha阶段，还没有准备好投入生产使用，但它的状态绝对足以进行开发中的试驾。还要注意，Turbopack目前缺少一个公共插件API(这是Webpack最大的优势之一)，但这将在未来得到解决。</p><p id="8194" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您创建了一个新的Next.js 13应用程序，您可以使用<code class="fe mm mn mo mp b">next dev --turbo</code>来启动您的开发服务器，尝试新的Turbopack bundler。</p><h1 id="bed3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">其他改进</h1><p id="cbb7" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">虽然我们在这篇文章中关注了一些重要的项目，但是Next.js 13中还包含了许多其他重要的特性:</p><ul class=""><li id="e6b8" class="ny nz iq kh b ki kj kl km ko oa ks ob kw oc la od oe of og bi translated">利用<code class="fe mm mn mo mp b">next/image</code>提供更好的图像加载支持和性能</li><li id="9358" class="ny nz iq kh b ki oh kl oi ko oj ks ok kw ol la od oe of og bi translated">使用<code class="fe mm mn mo mp b">next/font</code>改进了字体性能</li><li id="c1fd" class="ny nz iq kh b ki oh kl oi ko oj ks ok kw ol la od oe of og bi translated">将API改进与<code class="fe mm mn mo mp b">next/link</code>联系起来</li></ul><p id="d9a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获得完整的变化列表，请查看来自Vercel的<a class="ae lb" href="https://nextjs.org/blog/next-13#nextimage" rel="noopener ugc nofollow" target="_blank"> Next.js 13博客文章</a>。</p><h1 id="5796" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">重述—服务器端React正在成长</h1><p id="b252" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在这篇文章中，我们介绍了Next.js 13中的一些新特性。虽然这里描述的新特性涉及了许多不同的领域，但对我来说，总的主题是框架的成熟。Next.js 13以及React本身即将到来的变化开始讲述一个关于在服务器和客户机上混合React的坚实、连贯的故事。</p><p id="f043" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您过去还没有看过Next.js或服务器端React，<a class="ae lb" href="http://nextjs.org/" rel="noopener ugc nofollow" target="_blank">现在是查看它的好时机</a>！</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="8e01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">原载于</em><a class="ae lb" href="https://blixtdev.com/whats-new-in-next-js-13-and-why-it-matters/" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://blixtdev.com</em></a><em class="ml">。</em></p><p id="8e7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乔纳森写了一些关于创业、软件工程和健康科学的文章。如果你喜欢这篇文章，请考虑加入Medium来支持 <a class="ae lb" href="/@jonnystartup/membership" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> Jonathan和其他数千位作者</em> </a> <em class="ml">。</em></p><p id="4ddf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">更多内容看</em> <a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ml">说白了。报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ml">免费周报</em> </strong> </a> <em class="ml">。关注我们关于</em> <a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ml">推特</em> </strong> </a>，<a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ml">LinkedIn</em></strong></a><em class="ml">，</em><a class="ae lb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ml">YouTube</em></strong></a><em class="ml">，以及</em> <a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ml">不和</em> </strong> </a> <em class="ml">。对增长黑客感兴趣？检查</em> <a class="ae lb" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ml">电路</em> </strong> </a> <em class="ml">。</em></strong></a></p></div></div>    
</body>
</html>