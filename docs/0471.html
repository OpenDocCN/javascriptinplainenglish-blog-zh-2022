<html>
<head>
<title>3 Scenarios Where You Shouldn’t Use Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不应该使用箭头函数的3种情况</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-scenarios-where-you-shouldnt-use-arrow-functions-862388acd05d?source=collection_archive---------5-----------------------#2022-01-27">https://javascript.plainenglish.io/3-scenarios-where-you-shouldnt-use-arrow-functions-862388acd05d?source=collection_archive---------5-----------------------#2022-01-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/76eb77c2aaca80917a26c81e75bacb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sN8TkWijx4N9ZVzC"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Fewings</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0288" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与普通函数(用<code class="fe ky kz la lb b">function</code>关键字声明)相比，箭头函数有许多不同之处，包括:</p><ul class=""><li id="3843" class="lc ld in kc b kd ke kh ki kl le kp lf kt lg kx lh li lj lk bi translated">箭头函数没有自己的<code class="fe ky kz la lb b"><a class="ae jz" href="https://www.javascripttutorial.net/javascript-this/" rel="noopener ugc nofollow" target="_blank">this</a></code>值</li><li id="fc37" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">它没有<code class="fe ky kz la lb b">arguments</code>的对象。</li><li id="f7dc" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">它没有<code class="fe ky kz la lb b">[[construct]]</code>内部插槽。</li></ul><p id="ff6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有3种不应该使用箭头函数的情况。</p><h1 id="b3e2" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">1.在对象上定义方法</h1><p id="f93b" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">在JavaScript中，方法是存储在对象的属性中的函数。当调用该方法时，<code class="fe ky kz la lb b">this</code>成为该方法所属的对象。</p><h2 id="4a42" class="mt lr in bd ls mu mv dn lw mw mx dp ma kl my mz me kp na nb mi kt nc nd mm ne bi translated">1a。对象文字</h2><p id="8e52" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">因为arrow函数有一个简短的语法，所以把它用于方法定义是很有吸引力的。让我们试一试:</p><figure class="nf ng nh ni gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3be7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">calculate.sum</code>用箭头函数定义方法。但是在调用时<code class="fe ky kz la lb b">calculate.sum()</code>抛出一个<code class="fe ky kz la lb b">TypeError</code>，因为<code class="fe ky kz la lb b">this.array</code>被赋值为<code class="fe ky kz la lb b">undefined</code>。<br/>在<code class="fe ky kz la lb b">calculate</code>对象上调用方法<code class="fe ky kz la lb b">sum()</code>时，上下文保持<code class="fe ky kz la lb b">window</code>。这是因为arrow函数用<code class="fe ky kz la lb b">window</code>对象在词汇上绑定了上下文。<br/>执行<code class="fe ky kz la lb b">this.array</code>相当于<code class="fe ky kz la lb b">window.array</code>，也就是<code class="fe ky kz la lb b">undefined</code>。</p><p id="2ce9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解决方案是使用函数表达式或<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" rel="noopener ugc nofollow" target="_blank">速记语法</a>进行方法定义(ECMAScript 6中提供)。在这种情况下，<code class="fe ky kz la lb b">this</code>由调用决定，而不是由封闭上下文决定。我们来看看修复版:</p><figure class="nf ng nh ni gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c9b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为<code class="fe ky kz la lb b">sum</code>是一个常规函数，调用<code class="fe ky kz la lb b">calculate.sum()</code>时的<code class="fe ky kz la lb b">this</code>是<code class="fe ky kz la lb b">calculate</code>对象。<code class="fe ky kz la lb b">this.array</code>是数组引用，因此元素之和计算正确:<code class="fe ky kz la lb b">6</code>。</p><h2 id="1e5f" class="mt lr in bd ls mu mv dn lw mw mx dp ma kl my mz me kp na nb mi kt nc nd mm ne bi translated">1b。对象原型</h2><p id="f90d" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">当在一个<code class="fe ky kz la lb b">prototype</code>对象上定义方法时，同样的规则也适用。<br/>没有使用箭头函数来定义<code class="fe ky kz la lb b">sayCatName</code>方法，这带来了不正确的上下文<code class="fe ky kz la lb b">window</code>:</p><figure class="nf ng nh ni gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d01e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<em class="nl">老校</em>函数表达式:</p><figure class="nf ng nh ni gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="a242" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">2.具有动态上下文的回调函数</h1><p id="62db" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated"><code class="fe ky kz la lb b">this</code>在JavaScript中是一个强大的特性。它允许根据调用函数的方式改变上下文。上下文通常是发生调用的目标对象，这使得代码更加自然。它像是在说“这个物体发生了一些事情”。</p><p id="e6e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，arrow函数将上下文静态地绑定在声明上，不可能使其成为动态的。这是奖牌的另一面，在这种情况下词汇<code class="fe ky kz la lb b">this</code>是不必要的。</p><p id="b243" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将事件侦听器附加到DOM元素是客户端编程中的一项常见任务。一个事件触发以<code class="fe ky kz la lb b">this</code>为目标元素的处理函数。动态上下文的便捷使用。</p><p id="9b1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的示例尝试对这样的处理程序使用箭头函数:</p><figure class="nf ng nh ni gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8f71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">this</code>是在全局上下文中定义的箭头函数中的<code class="fe ky kz la lb b">window</code>。当点击事件发生时，浏览器试图用<code class="fe ky kz la lb b">button</code>上下文调用处理函数，但是箭头函数不会改变其预定义的上下文。</p><p id="0664" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">this.innerHTML</code>相当于<code class="fe ky kz la lb b">window.innerHTML</code>，没有意义。</p><p id="c264" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您必须应用一个函数表达式，它允许根据目标元素改变<code class="fe ky kz la lb b">this</code>:</p><pre class="nf ng nh ni gt nm lb nn no aw np bi"><span id="be4b" class="mt lr in lb b gy nq nr l ns nt">const button = document.getElementById('myButton');<br/>button.addEventListener('click', function() {<br/>  console.log(this === button); // =&gt; true<br/>  this.innerHTML = 'Clicked button';<br/>});</span></pre><p id="9999" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用户点击按钮时，处理函数中的<code class="fe ky kz la lb b">this</code>为<code class="fe ky kz la lb b">button</code>。因此<code class="fe ky kz la lb b">this.innerHTML = 'Clicked button'</code>正确修改按钮文本以反映点击状态。</p><h1 id="9fb8" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">3.调用构造函数</h1><p id="8efc" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated"><code class="fe ky kz la lb b">this</code>在构造调用中是新创建的对象。执行<code class="fe ky kz la lb b">new MyFunction()</code>时，构造函数<code class="fe ky kz la lb b">MyFunction</code>的上下文是一个新对象:<code class="fe ky kz la lb b">this instanceof MyFunction === true</code>。</p><p id="cd1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，箭头函数不能用作构造函数。JavaScript通过抛出一个异常隐式地阻止了这样做。</p><p id="d3e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之<code class="fe ky kz la lb b">this</code>是从封闭上下文中设置的，不是新创建的对象。换句话说，一个箭头函数构造函数调用是没有意义的，而且是不明确的。</p><p id="66f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看，如果尝试:</p><pre class="nf ng nh ni gt nm lb nn no aw np bi"><span id="0f08" class="mt lr in lb b gy nq nr l ns nt">const Message = (text) =&gt; {<br/>  this.text = text;<br/>};<br/>// Throws "TypeError: Message is not a constructor"<br/>const helloMessage = new Message('Hello World!');</span></pre><p id="e12f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">执行<code class="fe ky kz la lb b">new Message('Hello World!')</code>，其中<code class="fe ky kz la lb b">Message</code>是一个箭头函数，JavaScript抛出一个<code class="fe ky kz la lb b">Message</code>不能作为构造函数的<code class="fe ky kz la lb b">TypeError</code>。</p><p id="3598" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为在这种情况下，ECMAScript 6失败并显示详细的错误消息是一种有效的做法。与<em class="nl">相反，静默失败</em>特定于以前的JavaScript版本。</p><p id="3f95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子是使用<a class="ae jz" href="https://developer.mozilla.org/en/docs/web/JavaScript/Reference/Operators/function" rel="noopener ugc nofollow" target="_blank">函数表达式</a>修复的，这是创建构造函数的正确方法(包括<a class="ae jz" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function" rel="noopener ugc nofollow" target="_blank">函数声明</a>):</p><pre class="nf ng nh ni gt nm lb nn no aw np bi"><span id="1321" class="mt lr in lb b gy nq nr l ns nt">const Message = function(text) {<br/>  this.text = text;<br/>};<br/>const helloMessage = new Message('Hello World!');<br/>console.log(helloMessage.text); // =&gt; 'Hello World!'</span></pre><h1 id="5091" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">语法太短</h1><p id="9c3a" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">arrow函数有一个很好的特性，如果函数体只有一个语句，它可以省略参数圆括号<code class="fe ky kz la lb b">()</code>，块花括号<code class="fe ky kz la lb b">{}</code>和<code class="fe ky kz la lb b">return</code>。这有助于编写非常短的函数。</p><p id="22de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的大学编程教授给学生布置了一个有趣的任务:用C语言写出计算字符串长度的最短函数。这是学习和探索一门新语言的好方法。</p><p id="fd7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，在现实世界的应用程序中，许多开发人员都会阅读这些代码。最短的语法并不总是适合帮助你的同事即时理解函数。</p><p id="1924" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在某种程度上，压缩的函数变得难以阅读，所以尽量不要激动。让我们看一个例子:</p><pre class="nf ng nh ni gt nm lb nn no aw np bi"><span id="aea1" class="mt lr in lb b gy nq nr l ns nt">const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b;<br/>const double = multiply(2);<br/>double(3);      // =&gt; 6<br/>multiply(2, 3); // =&gt; 6</span></pre><p id="5d51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">multiply</code>返回两个数字的乘法结果或一个与第一个参数相关联的闭包，用于后面的乘法。</p><p id="dc5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该功能运行良好，看起来很短。但是第一眼看上去可能很难理解它的作用。</p><p id="5045" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了提高可读性，可以从arrow函数中恢复可选的花括号和<code class="fe ky kz la lb b">return</code>语句，或者使用常规函数:</p><pre class="nf ng nh ni gt nm lb nn no aw np bi"><span id="6394" class="mt lr in lb b gy nq nr l ns nt">function multiply(a, b) {<br/>  if (b === undefined) {<br/>    return function(b) {<br/>      return a * b;<br/>    }<br/>  }<br/>  return a * b;<br/>}<br/>const double = multiply(2);<br/>double(3);      // =&gt; 6<br/>multiply(2, 3); // =&gt; 6</span></pre><p id="e86f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在简短和冗长之间找到一个平衡点是很好的，这样可以让你的JavaScript简单明了。</p><h1 id="927c" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="fb73" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">毫无疑问，箭头功能是一个很好的补充。当正确使用时，它在以前你不得不使用<code class="fe ky kz la lb b">.bind()</code>或试图抓住上下文的地方带来了简单性。这也使得代码更轻。</p><p id="ac41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">某些情况下的优势会带来其他情况下的劣势。需要动态上下文时不能使用箭头函数:定义方法，用构造函数创建对象，处理事件时从<code class="fe ky kz la lb b">this</code>获取目标。</p><p id="bb85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nl">plain English . io</em></strong></a><em class="nl">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nl">免费周报</em> </strong> </a> <em class="nl">。在我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nl">社区</em> </strong> </a> <em class="nl">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>