<html>
<head>
<title>Dynamic Programming Using Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用记忆的动态规划</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dynamic-programming-using-memoization-e1fd31bc9a55?source=collection_archive---------7-----------------------#2022-09-28">https://javascript.plainenglish.io/dynamic-programming-using-memoization-e1fd31bc9a55?source=collection_archive---------7-----------------------#2022-09-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e5e2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript算法基础第5部分:用记忆技术理解动态编程</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fc7467163e44224c830acaf8b6eed673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1dgu7rKN6IBjC1uR"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ks" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="08ed" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><strong class="ak">动态编程</strong></h1><p id="6f70" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">动态编程是一种<strong class="ln io">优化技术</strong>，可以应用于使用相同输入重复调用的<strong class="ln io">递归算法</strong>。这里的基本思想是，如果我们已经为给定的输入解决了一个问题，那么我们将结果保存为一个参考，并使用这个保存的结果，而不是为相同的输入重新计算整个问题，从而节省运行时间。</p><p id="79d2" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在上一篇文章中，我们看到了<strong class="ln io">斐波那契递归解</strong>如何导致<strong class="ln io">的指数时间复杂度</strong>。在本文中，我们将使用<strong class="ln io">动态规划</strong>优化相同的Fibonacci递归解决方案，以获得线性时间复杂度。你可以在下面的链接中参考上一篇文章的例子。</p><p id="1734" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><a class="ae ks" href="https://medium.com/p/713856ad4e2" rel="noopener">第四部分:递归算法及其时间复杂度O(n) vs O(2^n) </a></p><h2 id="5270" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated"><strong class="ak">记忆化</strong></h2><p id="c309" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们将在这里使用动态编程的<strong class="ln io">记忆技术</strong>来优化斐波纳契问题的递归解决方案。记忆化简单地意味着<strong class="ln io">存储数据</strong>，以便它可以在以后用于执行某个过程。</p><p id="2474" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们知道，递归对于重复计算非常有用，但是正如我们在下面的递归树中看到的，它会导致<strong class="ln io">重复工作</strong>，这取决于我们正在解决的问题。斐波纳契递归函数中的<strong class="ln io"> fib(2) </strong>函数分支被多次执行<strong class="ln io"/>。我们多次重复同样的计算，这正是导致指数增长率问题的原因。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/79686a42eeb5bcd4733ee8e83a31747d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEz1s7BX_DAEKU--cq1rHA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Recursive Fibonacci Algorithm Function Executions</figcaption></figure><h2 id="b006" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">那么储存一些数据对我们有什么帮助呢？</h2><p id="a852" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">如果我们在第一次执行时将<strong class="ln io"> fib(2) </strong>的结果存储在某个地方，那么我们可以检查在第二次执行时是否有<strong class="ln io"> fib(2) </strong>的结果，然后我们就不再进行第二次计算了。相反，我们第二次使用保存的结果。这样，我们可以在下一次中保存对<strong class="ln io"> fib(2)的额外函数调用，这又为我们保存了对<strong class="ln io"> fib(1) </strong>和<strong class="ln io"> fib(0) </strong>的进一步调用，这些调用已经被计算为<strong class="ln io"> fib(2) </strong>的一部分。</strong></p><p id="3d7f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">这就是我们的想法，如果我们能消除额外的函数调用，我们就消除了递归树的所有分支。这就是动态编程的意义所在。这是关于递归的，用记忆解决一个特殊的问题。所以通过存储一些中间结果，我们可以优化递归算法。现在让我们用记忆化来实现相同的斐波那契解。</p><h2 id="be86" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">记忆解决方案</h2><p id="6fe2" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">为了实现记忆化，我们需要<strong class="ln io">存储</strong>。对于我们的例子，我们将使用一个本地<strong class="ln io">对象</strong>，它将作为一个参数传递给递归函数。最初，存储器将是空的，随着更多递归步骤的执行，它将被中间结果填充。</p><p id="82c9" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因此，每个递归进程都有自己的存储空间，只用于特定的递归树。</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="f293" class="mm ku in na b gy ne nf l ng nh">function fib(n, <strong class="na io">storage</strong>) {<br/> let result;<br/> <br/> if(n === 0 || n === 1) {<br/>  result = 1;<br/> } else {<br/>  result = fib(n - 1, <strong class="na io">storage</strong>) + fib (n - 2, <strong class="na io">storage</strong>)<br/> }</span><span id="2432" class="mm ku in na b gy ni nf l ng nh">return result;<br/>}</span><span id="fa12" class="mm ku in na b gy ni nf l ng nh"><strong class="na io">fib(3, {})  // Passing empty object initially</strong></span></pre><p id="7607" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在上面的函数中，我们引入了第二个参数作为<strong class="ln io">对象传递给函数，以存储中间结果</strong>。</p><p id="1e23" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">但是，函数仍然不完整，因为我们没有存储中间结果。</p><p id="8252" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">为此，我们可以通过动态添加键将结果保存在“<strong class="ln io">存储</strong>”对象中。</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="28bd" class="mm ku in na b gy ne nf l ng nh">function fib(n, <strong class="na io">storage</strong>) {<br/> let result;<br/> <br/> if(n === 0 || n === 1) {<br/>  result = 1;<br/> } else {<br/>  result = fib(n - 1, <strong class="na io">storage</strong>) + fib (n - 2, <strong class="na io">storage</strong>)<br/> }</span><span id="29ec" class="mm ku in na b gy ni nf l ng nh"><strong class="na io">storage[n] = result;  // Memoization</strong></span><span id="6e36" class="mm ku in na b gy ni nf l ng nh"> return result;<br/>}</span></pre><p id="9de3" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因为“<strong class="ln io">存储</strong>”对象是一个引用类型，所以它的值将在所有函数调用中保持不变，并且我们动态添加的属性将在所有函数调用中可用。即使现在，我们也只是存储中间结果，但是我们并没有对它做任何事情。</p><p id="c755" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">所以，我们仍然没有优化到位。因此，还缺少最后一步。</p><p id="4afd" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">这一步将检查对于<strong class="ln io"> n </strong>，我们是否已经在我们的“<strong class="ln io">存储”</strong>对象中有一个条目。并且，如果我们在<code class="fe nj nk nl na b"><strong class="ln io">storage[n]</strong></code>中有一个保存的结果，那么我们返回结果，从而跳过剩余的代码。</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="89b2" class="mm ku in na b gy ne nf l ng nh">function fib(n, <strong class="na io">storage</strong>) {<br/> let result;</span><span id="4e3c" class="mm ku in na b gy ni nf l ng nh"><strong class="na io">if(storage[n]){      // Memoization<br/>  return storage[n]<br/> }</strong><br/> <br/> if (n === 0 || n === 1) {<br/>  result = 1;<br/> } else {<br/>  result = fib(n - 1, <strong class="na io">storage</strong>) + fib (n - 2, <strong class="na io">storage</strong>)<br/> }</span><span id="a2d1" class="mm ku in na b gy ni nf l ng nh"><strong class="na io">storage[n] = result;  // Memoization</strong></span><span id="3db5" class="mm ku in na b gy ni nf l ng nh">return result;<br/>}</span></pre><p id="f429" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">通过这种优化，我们跳过了所有进一步的步骤，这些步骤可能会导致更多的函数调用，从而导致函数调用的重复分支。因此，我们的函数执行更少。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/adaf0d446cc72594ed037879a602839f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0amd2bFutLUwQxk_QjiDNg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Optimized Recursive Fibonacci Function</figcaption></figure><p id="eed0" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">正如您在上面的树中所看到的，完全跳过了<strong class="ln io"> fib(2) </strong>的重复分支，并使用了来自另一个分支的<strong class="ln io"> fib(2) </strong>函数的保存值。</p><h2 id="02cd" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">我们新的时间复杂度是多少？</h2><p id="49bd" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><strong class="ln io">它的线性时间复杂度</strong>。因为如果我们执行上述算法并进行<strong class="ln io">渐近分析</strong>，那么我们会看到，随着<strong class="ln io"> n </strong>的增加，我们会得到<strong class="ln io"> 2n </strong>次迭代。</p><p id="973e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因此，<strong class="ln io"> 2n </strong>听起来像我们的<strong class="ln io">时间复杂度</strong>，正如我们所学的，我们只是将其简化为<strong class="ln io"> O(n) </strong>，因为我们关心一般的模式。所以我们从<strong class="ln io"> O(2^n) </strong>到仅仅<strong class="ln io"> O(n) </strong>，这是一个巨大的进步。<strong class="ln io">我们将指数时间复杂度解决方案转换为线性复杂度解决方案</strong>。原因是，借助于动态编程，我们用这种优化技术跳过了树中的整个分支。而且，这种技术在解决一些复杂棘手的问题时非常强大。</p><h2 id="37ec" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated"><strong class="ak">爬楼梯问题</strong></h2><p id="d9f4" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">下面是爬楼梯问题，这是使用动态规划方法解决的最佳问题之一。编码面试的时候也问过很多类似的DP问题。</p><h2 id="23f4" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">问题陈述</h2><p id="c4a0" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">你正在爬一个需要n级台阶才能到达顶端的楼梯。每次只能爬1步或2步。我们需要计算并返回爬上楼梯顶部的独特方式的总数。</p><p id="c770" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">例1 </strong></p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="97a6" class="mm ku in na b gy ne nf l ng nh"><strong class="na io">Input</strong>: n = 2<br/><strong class="na io">Output</strong>: 2</span><span id="890f" class="mm ku in na b gy ni nf l ng nh"><strong class="na io">Explanation</strong>: There are two ways to climb to the top<br/>1. 1 step + 1 step<br/>2. 2 steps</span></pre><p id="c18f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">例2 </strong></p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="e12f" class="mm ku in na b gy ne nf l ng nh"><strong class="na io">Input</strong>: n = 3<br/>Output: 3</span><span id="84e5" class="mm ku in na b gy ni nf l ng nh"><strong class="na io">Explanation</strong>: There are three ways to climb to the top<br/>1. 1 step + 1 step + 1 step<br/>2. 1 step + 2 steps<br/>3. 2 steps + 1 step</span></pre><p id="7b67" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们可以使用上面讨论的同样的记忆技术来解决这个问题。</p><p id="6f14" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">希望这篇文章对你有用。感谢阅读。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="b3c3" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="nt">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="nt">plain English . io</em></strong></a><em class="nt">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="nt">免费每周简讯</em> </strong> </a> <em class="nt">。关注我们</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="nt">推特</em> </strong> </a>，<a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="nt">LinkedIn</em></strong></a><em class="nt">，</em><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="nt">YouTube</em></strong></a><em class="nt">，</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="nt">不和</em> </strong> </a> <em class="nt">。对增长黑客感兴趣？检查出</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="nt">电路</em> </strong> </a> <em class="nt">。</em></p></div></div>    
</body>
</html>