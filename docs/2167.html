<html>
<head>
<title>Server-Sent Events with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js的服务器发送的事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/server-sent-events-with-nodejs-bbdc9a9584cb?source=collection_archive---------1-----------------------#2022-05-19">https://javascript.plainenglish.io/server-sent-events-with-nodejs-bbdc9a9584cb?source=collection_archive---------1-----------------------#2022-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="026f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从您的后端接收定期更新，而不发送垃圾HTTP请求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/75c3c5b9ac688bf66fcb38be06980f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ei6vnOcvX73EByRduzTJlQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Unrelated, I just liked the image (Photo by panumas nikhomkhai: <a class="ae kv" href="https://www.pexels.com/photo/close-up-photo-of-mining-rig-1148820/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/close-up-photo-of-mining-rig-1148820/</a>)</figcaption></figure><p id="4b86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的一份工作中，我们正在处理一个案例，前端必须每分钟检查是否有新的通知。我们还使用了HTTP2，所以WebSocket并不是一个真正的选择。然而，我听说过一个叫做服务器发送事件(或SSE)的JavaScript特性。我建议，但由于“复杂性”(或懒惰，不确定)，领导决定去用HTTP请求垃圾邮件后端…</p><p id="5be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我今天写这篇文章的原因，向您展示这是多么简单，SSE应该比实际使用的更多！</p><h1 id="e9ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是SSE</h1><p id="065d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">SSE是一个服务器推送的事件系统，与WebSockets不同，它是单向的。一旦客户端请求与后端连接，就会打开一个通道，后端就可以发送我们想要的任意多的事件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/924999173bb7cc96490cc3c7b3978bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZo6ceVIMCdDIOQTgZ_gTA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Browser compatibility</figcaption></figure><p id="486e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SSE兼容所有现代浏览器(如果2022年你还在支持IE11，那就是你的问题了！)哪个用起来都是好加分！</p><h2 id="09e2" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">它是如何工作的</h2><p id="6bc5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">SSE非常简单。客户端(浏览器)将使用HTTP2请求与后端建立新的连接。一旦接受，通道将打开，后端将能够发送请求。通道将一直打开，直到前端决定关闭连接，这意味着如果后端关闭连接，前端将立即请求新的通道，因为它会将其视为错误。</p><h1 id="09e1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们试试吧！</h1><h2 id="5e5e" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">服务器</h2><p id="9597" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将从服务器开始。在nodeJS中SSE是现成可用的，但是为了使事情更容易，我们将使用express来代替。</p><p id="9e74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装时使用:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="ae33" class="mq lt iq nd b gy nh ni l nj nk">npm install -S express cors</span></pre><p id="cb50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们编写一个小型express服务器:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="1b36" class="mq lt iq nd b gy nh ni l nj nk">const express = require("express");<br/>const cors = require("cors");</span><span id="2908" class="mq lt iq nd b gy nl ni l nj nk">const app = express();<br/>app.use(cors());</span><span id="b12e" class="mq lt iq nd b gy nl ni l nj nk">const headers = {<br/>  "Content-Type": "text/event-stream",<br/>  Connection: "keep-alive",<br/>  "Cache-Control": "no-cache",<br/>};</span><span id="b47c" class="mq lt iq nd b gy nl ni l nj nk">let counter = 0;<br/>let interval;</span><span id="7208" class="mq lt iq nd b gy nl ni l nj nk">app.get("/event", (req, res) =&gt; {<br/>  res.writeHead(200, headers);</span><span id="4fb3" class="mq lt iq nd b gy nl ni l nj nk">interval = setInterval(() =&gt; {<br/>    const data = `${JSON.stringify({ counter })}\n\n`;<br/>    res.write(data);<br/>    counter++;<br/>  }, 1000);<br/>  req.on('close', () =&gt; {<br/>    clearInterval(interval);<br/>  });<br/>});</span><span id="026c" class="mq lt iq nd b gy nl ni l nj nk">app.listen(4000, () =&gt; {<br/>  console.log("listening...");<br/>});</span></pre><p id="3bfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们快速浏览一下这个文件。</p><p id="fe40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Headers只是定义了服务器发送给客户端的头。(别忘了我们使用的是HTTP2，SSE基本上是发送一种不同的响应)</p><p id="f971" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们使用<code class="fe nm nn no nd b">writeHead</code>将头部发送回客户端并打开流。</p><p id="cd68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在<code class="fe nm nn no nd b">setInterval</code>中，我们每秒向客户端发送一个新版本的计数器。</p><p id="b52a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，响应需要是一个字符串，我们需要两个<code class="fe nm nn no nd b"><em class="np">\n</em></code>在末尾，否则浏览器永远不会接受数据。</p><p id="2840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nm nn no nd b">req.on('close')</code>，我们监听客户端关闭连接(记住，客户端拥有控制权！)</p><p id="38a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用了<code class="fe nm nn no nd b">cors</code>模块，因为我们的客户端和服务器不在同一个地方，否则我们会有严重的错误！</p><h2 id="7a3d" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">前端</h2><p id="68a0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于前端，我们将使用一个基本的HTML/JavaScript页面，因为我们不需要使用任何大的框架，并且SSE是框架不可知的:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="fe3e" class="mq lt iq nd b gy nh ni l nj nk">&lt;html&gt;<br/>  &lt;body&gt;<br/>    &lt;button id="connect-btn"&gt;Connect&lt;/button&gt;<br/>    &lt;button id="stop-btn"&gt;Stop&lt;/button&gt;<br/>    &lt;script&gt;<br/>      const onMessage = (event) =&gt; {<br/>        const data = JSON.parse(event.data);<br/>        console.log(data);<br/>      };</span><span id="8cc8" class="mq lt iq nd b gy nl ni l nj nk">let eventSource;</span><span id="a7c5" class="mq lt iq nd b gy nl ni l nj nk">const connectBtn = document.getElementById("connect-btn");<br/>      const stopBtn = document.getElementById("stop-btn");<br/>      connectBtn.addEventListener("click", () =&gt; {<br/>        eventSource = new EventSource("<a class="ae kv" href="http://localhost:4000/event" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/event</a>");<br/>        eventSource.onopen = () =&gt; {<br/>          console.log("opened");<br/>        };<br/>        eventSource.onmessage = onMessage;<br/>      });<br/>      stopBtn.addEventListener("click", () =&gt; {<br/>        eventSource.close();<br/>      });<br/>    &lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="32d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们不要太关注HTML，有趣的是我们的JavaScript代码。</p><p id="467d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当点击connect按钮时，我们正在实例化一个新的<code class="fe nm nn no nd b">EventSource</code>，它将连接到我们的后端。然后我们分配两个监听器。</p><p id="bc2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个在连接打开<br/> ( <code class="fe nm nn no nd b">eventSource.onopen</code>)时触发，将触发一次(连接时)</p><p id="2092" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个是为每条消息触发的(<code class="fe nm nn no nd b">onmessage</code>)。我们将接收一个事件作为参数(参见JS标签顶部的<code class="fe nm nn no nd b">onMessage</code>箭头功能)</p><p id="c3d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，当单击stop按钮时，我们只需关闭eventSource！</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="257e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这么简单！SSE使用起来非常简单，允许您打开一个通道，而不必使用WebSockets(或者向后端发送新数据)</p><p id="a956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章，如果你喜欢，不要犹豫鼓掌或关注！</p><p id="6251" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="np">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="np">说白了就是</em> </strong> </a> <em class="np">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="np">免费周报</em> </strong> </a> <em class="np">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="np">Twitter</em></strong></a><em class="np">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="np">LinkedIn</em></strong></a><em class="np">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="np">社区不和谐</em> </strong> </a> <em class="np">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="np">人才集体</em> </strong> </a> <em class="np">。</em></p></div></div>    
</body>
</html>