<html>
<head>
<title>Handling “this” with call(), apply() and bind()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用call()、apply()和bind()处理“this”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handling-this-with-call-apply-and-bind-55fb059d20bb?source=collection_archive---------7-----------------------#2022-05-03">https://javascript.plainenglish.io/handling-this-with-call-apply-and-bind-55fb059d20bb?source=collection_archive---------7-----------------------#2022-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3bd16a32707100f94f9f979a6692c494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqFw0_--byo3stBuJXNK3A.png"/></div></div></figure><p id="50cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以在<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/demystifying-this-in-javascript-5a38d920f216">之前的博文</a>中，我们看了一下<code class="fe ku kv kw kx b">this</code>关键字在JavaScript中是如何工作的。每个函数都自动获取<code class="fe ku kv kw kx b">this</code>关键字，其工作方式是，每当调用一个函数时，关键字都指向当前的<strong class="jx io">执行上下文</strong>。因此它的值将取决于调用函数的方式。这也是为什么有时你可能<strong class="jx io">会丢失对它的引用</strong>的原因。</p><p id="c7a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ky">你可以在这里观看这篇文章的视频版本:</em></p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="3552" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看一下这个例子。</p><pre class="kz la lb lc gt lf kx lg lh aw li bi"><span id="6f8f" class="lj lk in kx b gy ll lm l ln lo">class Person {<br/>    constructor(firstName, lastName) {<br/>        this.firstName = firstName;<br/>        this.lastName = lastName;<br/>    }</span><span id="20f0" class="lj lk in kx b gy lp lm l ln lo">    printNameAfter2Seconds() {<br/>        setTimeout(function () {<br/>            console.log(`${this.firstName} ${this.lastName}`)<br/>        }, 2000);<br/>    }<br/>}</span><span id="c3ec" class="lj lk in kx b gy lp lm l ln lo">let person = new Person("John", "Doe");<br/>person.printNameAfter2Seconds();   // undefined undefined</span></pre><p id="6014" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的类有一个运行<code class="fe ku kv kw kx b"><strong class="jx io">setTimeout</strong></code>函数的方法，延迟2秒。这个<code class="fe ku kv kw kx b"><strong class="jx io">setTimout</strong></code>函数还有一个回调函数，试图访问类的firstName和lastName属性。但是如果你试图在一个实例上执行这个方法，你将得到两个属性的<code class="fe ku kv kw kx b"><strong class="jx io">undefined</strong></code>。</p><p id="6d59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这背后的原因是，由于每个函数都将获得自己的值<code class="fe ku kv kw kx b">this</code>，这里的回调函数也将获得自己的<code class="fe ku kv kw kx b">this</code>，它并不引用类实例。因此，在回调函数之外的任何地方，<code class="fe ku kv kw kx b">this</code>将指向类实例，但是在回调函数内部，它指向某个其他对象(在本例中是窗口对象)。</p><p id="f65c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解决这个问题的一个简单方法是使用箭头函数。箭头函数本身没有<code class="fe ku kv kw kx b">this</code>值。所以它从它的封闭范围中得到<code class="fe ku kv kw kx b">this</code>的值。</p><pre class="kz la lb lc gt lf kx lg lh aw li bi"><span id="adaa" class="lj lk in kx b gy ll lm l ln lo">...<br/>printNameAfter2Seconds() {<br/>   setTimeout(<strong class="kx io">() =&gt;</strong> {<br/>       console.log(`${this.firstName} ${this.lastName}`)<br/>   }, 2000);<br/>}<br/>...</span></pre><p id="72fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在回调函数中的<code class="fe ku kv kw kx b">this</code>关键字将引用其父作用域<code class="fe ku kv kw kx b">printNameAfter2Seconds</code>中的<code class="fe ku kv kw kx b">this</code>关键字。<code class="fe ku kv kw kx b">printName</code>函数中的<code class="fe ku kv kw kx b">this</code>指向类实例，这就是为什么您会得到预期的结果。</p><p id="9c7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了箭头函数，JavaScript还有一些专门的方法可以解决这个问题。它们是<strong class="jx io">函数原型</strong>上出现的<strong class="jx io">调用</strong>、<strong class="jx io">应用</strong>和<strong class="jx io">绑定</strong>方法。</p><h2 id="2137" class="lj lk in bd lq lr ls dn lt lu lv dp lw kg lx ly lz kk ma mb mc ko md me mf mg bi translated">呼叫方法</h2><p id="b56b" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">事实上这很简单。假设你有两个类，第一个类有一个方法，第二个类想要使用。您可以使用call方法，而不是在第二个类中再次编写它。</p><pre class="kz la lb lc gt lf kx lg lh aw li bi"><span id="5c69" class="lj lk in kx b gy ll lm l ln lo">class Car {<br/>    constructor(model) { this.model = model }</span><span id="3eff" class="lj lk in kx b gy lp lm l ln lo">    start() { console.log(`${this.model} is starting`) }<br/>}</span><span id="a15f" class="lj lk in kx b gy lp lm l ln lo">class Bike {<br/>    constructor(model) { this.model = model }<br/>}</span><span id="2710" class="lj lk in kx b gy lp lm l ln lo">let bmw = new Car("BMW");<br/>bmw.start();</span><span id="45c5" class="lj lk in kx b gy lp lm l ln lo">let honda = new Bike("Honda");<br/>bmw.start.<strong class="kx io">call</strong>(honda);</span></pre><p id="1b12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们可以从Car类的实例中获得的start方法将运行call函数，并将第一个参数设置为新的上下文。我们希望上下文是bike实例，因为我们希望调用bike(honda)对象的start方法。所以我们传递本田对象。启动方法将被执行，<code class="fe ku kv kw kx b">this.model</code>将指向自行车的型号名称“Honda”。</p><p id="4be5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果该方法有一些参数，您仍然可以通过在第一个参数后添加参数来使用<code class="fe ku kv kw kx b">call</code>函数。</p><pre class="kz la lb lc gt lf kx lg lh aw li bi"><span id="e90a" class="lj lk in kx b gy ll lm l ln lo">class Car {<br/>    constructor(model) { this.model = model }</span><span id="52af" class="lj lk in kx b gy lp lm l ln lo">    start(<strong class="kx io">time</strong>) { console.log(`${this.model} is starting at    ${<strong class="kx io">time</strong>}`) }<br/>}</span><span id="34b3" class="lj lk in kx b gy lp lm l ln lo">class Bike {<br/>    constructor(model) { this.model = model }<br/>}</span><span id="333a" class="lj lk in kx b gy lp lm l ln lo">let bmw = new Car("BMW");<br/>bmw.start(new Date().toDateString());</span><span id="5bdc" class="lj lk in kx b gy lp lm l ln lo">let honda = new Bike("Honda");<br/>bmw.start.call(honda, <strong class="kx io">new Date().toDateString()</strong>);</span></pre><blockquote class="mm"><p id="c666" class="mn mo in bd mp mq mr ms mt mu mv ks dk translated">所以本质上，<code class="fe ku kv kw kx b">call()</code>函数允许一个属于一个对象的方法被分配给另一个不同的对象调用。它只是为函数/方法提供了一个新的值，反过来让你重用这个函数。</p><p id="398c" class="mn mo in bd mp mq mw mx my mz na ks dk translated">你也可以在普通函数上使用call，它不一定只是一个类中的方法。</p></blockquote><h2 id="3eb1" class="lj lk in bd lq lr nb dn lt lu nc dp lw kg nd ly lz kk ne mb mc ko nf me mf mg bi translated">运用方法</h2><p id="ed2b" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">现在一旦你知道了<code class="fe ku kv kw kx b">call</code>是如何工作的，你就会自动理解<code class="fe ku kv kw kx b">apply</code>的方法。它本质上做同样的事情，但是在<code class="fe ku kv kw kx b">call</code>的情况下，你将会单独传递<strong class="jx io"/>的参数现在将会在一个数组中传递。就是这样，这就是<code class="fe ku kv kw kx b">call</code>和<code class="fe ku kv kw kx b">apply</code>之间唯一的根本区别。</p><pre class="kz la lb lc gt lf kx lg lh aw li bi"><span id="9e9a" class="lj lk in kx b gy ll lm l ln lo">class Car {<br/>  constructor(model) { this.model = model }</span><span id="52a3" class="lj lk in kx b gy lp lm l ln lo">  start(<strong class="kx io">time, fuelLeft</strong>) { <br/>		console.log(`${this.model} is starting at ${time} with ${fuelLeft} left`) <br/>	}<br/>}</span><span id="133a" class="lj lk in kx b gy lp lm l ln lo">class Bike {<br/>    constructor(model) { this.model = model }<br/>}</span><span id="a879" class="lj lk in kx b gy lp lm l ln lo">let bmw = new Car("BMW");<br/>bmw.start();</span><span id="3f19" class="lj lk in kx b gy lp lm l ln lo">let honda = new Bike("Honda");<br/>bmw.start.apply(honda, <strong class="kx io">[new Date().toDateString(), "1ltr"]</strong>);</span></pre><h2 id="4e03" class="lj lk in bd lq lr ls dn lt lu lv dp lw kg lx ly lz kk ma mb mc ko md me mf mg bi translated">绑定方法</h2><p id="f612" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">现在，最后一种方法是<code class="fe ku kv kw kx b">bind</code>方法，同样与这两种方法非常相似。这或多或少是相同的方法，但这里的关键区别在于，虽然<code class="fe ku kv kw kx b">call</code>会立即运行具有新值<code class="fe ku kv kw kx b">this</code>的函数，但<code class="fe ku kv kw kx b">bind</code>会将<code class="fe ku kv kw kx b">this</code>附加到该函数并返回整个函数。</p><p id="062f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ky">所以现在无论你何时运行这个函数，它都绑定了一个特定的值</em> <code class="fe ku kv kw kx b"><em class="ky">this</em></code> <em class="ky">，它总是会给你相同的结果</em>。</p><p id="0cb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以用<code class="fe ku kv kw kx b">bind</code>解决本帖的第一个例子。</p><pre class="kz la lb lc gt lf kx lg lh aw li bi"><span id="62cd" class="lj lk in kx b gy ll lm l ln lo">class Person {<br/>    constructor(firstName, lastName) {<br/>        this.firstName = firstName;<br/>        this.lastName = lastName;<br/>    }</span><span id="0ab1" class="lj lk in kx b gy lp lm l ln lo">    printNameAfter2Seconds() {<br/>        setTimeout(function () {<br/>            console.log(`${this.firstName} ${this.lastName}`)<br/>        }.<strong class="kx io">bind(this)</strong>, 2000);<br/>    }<br/>}</span><span id="9918" class="lj lk in kx b gy lp lm l ln lo">let person = new Person("John", "Doe");<br/>person.printNameAfter2Seconds();</span></pre><p id="b792" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们为firstName和lastName都获取了<code class="fe ku kv kw kx b">undefined</code>,因为它的值指向了<code class="fe ku kv kw kx b">window</code>对象，而不是person类实例。这可以用<code class="fe ku kv kw kx b">bind</code>方法解决。</p><p id="d31e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您需要做的唯一更改是在回调函数的末尾附加绑定函数，并传递新的上下文。因为我们知道在函数之外的任何地方，上下文都将是类实例，所以我们可以在bind方法中使用它。</p><p id="647e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以本质上，我们获取了<code class="fe ku kv kw kx b">printNameAfter2Seconds</code>函数的<code class="fe ku kv kw kx b">this</code>值，并将其绑定到回调函数。2秒钟后，当这个函数运行时，它将把<code class="fe ku kv kw kx b">this</code>的值绑定到类实例，并因此产生预期的输出。</p><h2 id="01fa" class="lj lk in bd lq lr ls dn lt lu lv dp lw kg lx ly lz kk ma mb mc ko md me mf mg bi translated">结论</h2><p id="62c3" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">如果你明白<code class="fe ku kv kw kx b">this</code>是如何工作的，这三种方法对你来说会非常有意义。您可以使用它们来重用函数和方法，或者手动设置函数上下文，因为有时，尤其是在嵌套函数的情况下，您可能会丢失上下文。所以在那个时候，这些方法就派上用场了。</p><p id="fd56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">youtube上也有这篇文章的视频版本。 </p><p id="f9d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我建议你反复阅读这篇文章和上一篇文章，以便更好地理解这些话题。这些都是非常重要的概念，将有助于您在未来编写更有意义、更高效的代码。所以，请仔细观看，如果你有任何疑问或建议，你可以在评论中提出，或者通过我的社交网站与我联系。干杯！</p><p id="60bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/><a class="ae kt" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae kt" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae kt" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">GitHub</a></p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><p id="6406" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ky">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ky">plain English . io</em></strong></a><em class="ky">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ky">免费周报</em> </strong> </a> <em class="ky">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ky">Twitter</em></strong></a><em class="ky">和</em><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ky">LinkedIn</em></strong></a><em class="ky">。加入我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ky">社区不和谐</em> </strong> </a> <em class="ky">。</em></p></div></div>    
</body>
</html>