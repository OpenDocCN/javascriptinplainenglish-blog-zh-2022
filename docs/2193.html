<html>
<head>
<title>React Refs: The Difference Between useRef and createRef Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react Refs:useRef和createRef之间的区别变得简单了</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-refs-the-difference-between-useref-and-createref-made-easy-1b11a1df80b9?source=collection_archive---------4-----------------------#2022-05-20">https://javascript.plainenglish.io/react-refs-the-difference-between-useref-and-createref-made-easy-1b11a1df80b9?source=collection_archive---------4-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="836c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解在React中创建引用的用例以及不同方法之间的差异。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/62c04247e137ebce2edf8e32d074d3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*38eT0Np3GCiZwWds"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@emreturkan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Emre Turkan</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们看创建ref的不同方法之前，让我们先提醒自己ref实际上是什么。React团队将其定义为:</p><blockquote class="ls"><p id="aa62" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">…一种访问在render方法中创建的DOM节点或React元素的方式。</p></blockquote><figure class="md me mf mg mh kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/14e12e848c01a469663ce12c2d8ca6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2QzP-99_Mmn5M1v8.jpeg"/></div></div></figure><p id="e0ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这有点道理，但我们可能会打破这一点。Refs是我们在通常的React流之外与DOM和定制组件进行交互的一种方式。</p><p id="47c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React在我们的屏幕上呈现的是道具和状态的组合——如果它们发生变化，React将不得不重新呈现以向我们显示新的UI。裁判有点难以掌握，因为他们打破了这种循环；它们允许我们摆弄DOM，而不关心道具或状态。</p><p id="6b53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会在文本字段等元素中看到refs，在这些元素中，它们可以执行聚焦等操作，而无需更改属性/状态。此外，refs是一个<em class="mi">可变对象，</em>意味着您可以访问/更改它们的值，而不会导致任何重新呈现。(想象一下使用<code class="fe mj mk ml mm b">onFocus</code> useState变量的相同焦点的有状态实现——太多不必要的工作！)</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="b008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们对引用有了更好的理解，让我们看看创建引用的两种方式，并看看它们的用例。</p><h1 id="4bbe" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">useRef</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/f87c6d647c38f937c0e3ab244ed7704a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rWBZpDB0yI3GJNZvBJ9Ng.png"/></div></div></figure><p id="b903" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你写的是基于功能组件的React(也就是说不是基于类的)，那么这就是适合你的方法。</p><p id="950e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果useRef这个名字看起来很熟悉，那是因为它是一个类似于useState和useEffect的<strong class="ky ir">钩子</strong>。因为它是一个钩子，它遵循钩子的规则，这意味着如果你还在编写基于类的React，那么这不是你的选择，抱歉。</p><p id="bbbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React团队这样描述useRef:</p><blockquote class="ls"><p id="55fd" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">…一个可以在其<code class="fe mj mk ml mm b">.current</code>属性中保存可变值的“盒子”。</p></blockquote><p id="95d2" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">当我们定义useRef <code class="fe mj mk ml mm b">foo</code>时，我们可以用<code class="fe mj mk ml mm b">foo.current.</code>访问它所附加的DOM节点</p><pre class="kg kh ki kj gt ns mm nt nu aw nv bi"><span id="fc97" class="nw mv iq mm b gy nx ny l nz oa">const foo = useRef(null); //Convetion is to set ref to null before                         attaching to a DOM element</span></pre><p id="a786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据引用所附加的内容，我们可以在<code class="fe mj mk ml mm b">.current</code>对象上调用不同的方法——在我们的文本字段示例中，我们可以调用<code class="fe mj mk ml mm b">foo.current.focus</code>。</p><h1 id="b8e4" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">createRef</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/2ac9dfbe92d7996b17d0f4c23c1baa00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DkuqZJkgv33TCCcJ.jpg"/></div></div></figure><p id="de34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你关注useRef，你就会知道createRef是为你的基于类的React爱好者准备的。然而，也可以在函数式React中使用createRef(再次证明没有人需要仍然编写基于类的React，hot take)。</p><p id="f0ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">createRef还返回一个对象，该对象可通过Ref的<code class="fe mj mk ml mm b">.current</code>属性访问。与useRef不同，createRef是一个函数，所以它不必遵循钩子的规则。</p><h1 id="7313" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">所以都是回裁判…有什么区别？</h1><p id="a137" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">useRef和createRef确实非常相似。它们之间的主要区别是引用完整性。</p><blockquote class="ls"><p id="e3ca" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated"><code class="fe mj mk ml mm b">useRef</code>在每次渲染后保持相同的值，而<code class="fe mj mk ml mm b">createRef</code>则不然</p></blockquote><p id="7d2b" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">如果我使用useRef创建一个Ref，然后通过更新它的状态来重新呈现我的组件，我可以<strong class="ky ir">保证</strong>我的ref仍然具有与我的组件第一次挂载时相同的值。</p><p id="01b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我使用createRef创建一个Ref，然后通过更新它的状态来重新呈现我的组件，我的ref的值将<strong class="ky ir">不同。</strong></p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="7967" class="mu mv iq bd mw mx oh mz na nb oi nd ne jw oj jx ng jz ok ka ni kc ol kd nk nl bi translated">用例</h1><h2 id="4455" class="nw mv iq bd mw om on dn na oo op dp ne lf oq or ng lj os ot ni ln ou ov nk ow bi translated">useRef</h2><p id="46eb" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">在大多数需要使用引用的情况下，您可能会想要使用它。useRef对于存储静态的DOM节点/组件特别有用——例如，如果我们知道我们总是显示一个inputfield，useRef是访问它的好方法。这是因为无论有多少个重新呈现器，useRef都返回相同的值。</p><p id="b045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">useRef的另一个用途是捕获组件挂载时收到的属性。考虑以下情况:</p><pre class="kg kh ki kj gt ns mm nt nu aw nv bi"><span id="8e89" class="nw mv iq mm b gy nx ny l nz oa">const propRefs = useRef(props);<br/>console.log(propRefs) //Will be the same regardless if props change</span></pre><p id="cecb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法利用了useRef返回相同值的事实。</p><h2 id="f537" class="nw mv iq bd mw om on dn na oo op dp ne lf oq or ng lj os ot ni ln ou ov nk ow bi translated">createRef</h2><p id="dc10" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">如果你是基于类的，那么这是你唯一的选择，但是仍然有理由在功能组件中使用createRef。因为createRef将在每次渲染时重新创建，所以它非常适合处理动态DOM节点，在这种情况下，我们不必知道渲染了多少元素。</p><p id="750d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您正在一个在线购物网站上输入您的PIN码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/38051a89ee73f6d3177463e30875410f.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/0*Cl5-tObF_I5EE_DM"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Not my actual PIN (Obviously).</figcaption></figure><p id="9b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个好的UX应该是在输入一个数字时让下一个输入自动聚焦。</p><p id="06be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以用useRef来处理这个问题，但是我们需要为每个输入元件定义4个独立的Ref。现在想象我们正在输入<code class="fe mj mk ml mm b">n</code>号码，显然我们不能手动定义<code class="fe mj mk ml mm b">n</code>裁判。这就是createRef有用的地方。与钩子不同，我们可以编程方式调用createRef(在循环内部)，因为它只是一个函数。这意味着我们可以轻松地创建<code class="fe mj mk ml mm b">n</code> refs来处理<code class="fe mj mk ml mm b">n</code> DOM元素。</p><p id="64fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想看看它的代码实现，我在这里找到了Github用户<a class="ae kv" href="https://gist.github.com/bytecodepandit" rel="noopener ugc nofollow" target="_blank"> bytecodepandit </a>的<a class="ae kv" href="https://gist.github.com/bytecodepandit/46f34a6e788bde2ba07aa9fa1375cd3a#file-singleinputboxgroup-jsx" rel="noopener ugc nofollow" target="_blank">伟大的要旨。</a></p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="94e7" class="mu mv iq bd mw mx oh mz na nb oi nd ne jw oj jx ng jz ok ka ni kc ol kd nk nl bi translated">结论</h1><p id="994f" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">在不知道需要使用哪种创建方法的情况下，Refs就已经够混乱的了。希望这篇文章能让你对它们之间的区别和潜在的用例有一个更清晰的认识。</p><blockquote class="ls"><p id="ec53" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">功能组件、持久值、静态DOM元素— <strong class="ak">想想useRef() </strong></p><p id="7523" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">基于类的反应、基于当前渲染的值、动态DOM元素— <strong class="ak">想想createRef() </strong></p></blockquote></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="ca6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mi">如果你喜欢这篇文章或者觉得它有用，那么欢迎关注。或者，你可以在这里的Medium </em> <a class="ae kv" href="https://jamesmbrightman.medium.com/membership" rel="noopener"> <em class="mi">上支持我</em> </a> <em class="mi">或者给我买一杯</em> <a class="ae kv" href="https://ko-fi.com/jamesbrightman" rel="noopener ugc nofollow" target="_blank"> <em class="mi">咖啡</em> </a> <em class="mi">！非常感谢所有的支持。</em></p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="495d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mi">更多内容请看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mi">说白了就是</em> </strong> </a> <em class="mi">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mi">免费每周简讯</em> </strong> </a> <em class="mi">。关注我们</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mi">Twitter</em></strong></a><em class="mi">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mi">LinkedIn</em></strong></a><em class="mi">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mi">社区不和谐</em> </strong> </a> <em class="mi">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mi">人才集体</em> </strong> </a> <em class="mi">。</em></p></div></div>    
</body>
</html>