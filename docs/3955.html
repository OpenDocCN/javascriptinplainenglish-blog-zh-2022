<html>
<head>
<title>Angular DOM Manipulation: ElementRef, TemplateRef, and ViewContainerRef</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度DOM操作:ElementRef、TemplateRef和ViewContainerRef</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-elementref-templateref-viewcontainerref-8517b7ce3274?source=collection_archive---------1-----------------------#2022-10-13">https://javascript.plainenglish.io/angular-elementref-templateref-viewcontainerref-8517b7ce3274?source=collection_archive---------1-----------------------#2022-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="30e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">概述Angular中的元素、模板、视图和视图容器，以及如何以编程方式修改DOM。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f42bfe56487a7e2d45d9ca2d71254008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KenS9UunhuYwGD3xeoiXYw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo created using Canva — Resources from the <a class="ae kv" href="https://angular.io/presskit" rel="noopener ugc nofollow" target="_blank">Angular PressKit</a></figcaption></figure><p id="4ea0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将研究Angular中的一些DOM操作技术。如果元素、模板、视图和视图容器这些术语听起来令人困惑或陌生，那么这一个就是为您准备的。</p><p id="1a6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们开始吧！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d310" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">元素ElementRef</h1><p id="c2b8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">元素几乎是我们在网页上看到(或看不到)的所有东西。例如，输入字段、链接、图像和其他可能不可见的东西都是元素。</p><p id="ec22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><a class="ae kv" href="https://angular.io/api/core/ElementRef" rel="noopener ugc nofollow" target="_blank">ElementRef</a></code>类是本地元素的简单包装器，本地元素通常是浏览器中的DOM元素。它提供了一种访问<code class="fe mx my mz na b">nativeElement</code>对象的方法，公开了相关本地元素的所有方法和属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="780a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何得到一个ElementRef？</p><p id="6a8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是使用<code class="fe mx my mz na b">@ViewChild</code>装饰器。我们在模板文件中分配一个模板变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="df02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们使用<code class="fe mx my mz na b">@ViewChild</code>装饰器来查询来自<em class="mw">视图</em>的元素(很快会有更多关于这个术语的内容)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2e50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是第8行在控制台中显示的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c63cbcff11aca5515b12acf02a6ab79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*Nac34w2upF-W9Yx7v-uWTQ.png"/></div></figure><p id="444c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我们可以在感兴趣的元素上使用指令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3157" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并在指令的构造函数中使用依赖注入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="caea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过<code class="fe mx my mz na b">nativeElement</code>对象，我们可以访问它的所有方法和属性，并操纵元素。</p><p id="2352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe mx my mz na b">nativeElement</code>的默认类型是<code class="fe mx my mz na b">any</code>类型(<code class="fe mx my mz na b">T = any</code>)。这意味着如果我们仅仅使用<code class="fe mx my mz na b">ElementRef</code>作为类型，我们的<code class="fe mx my mz na b">nativeElement</code>将是<code class="fe mx my mz na b">any</code>类型。我们可以做得更好！</p><p id="b890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们使用像这样的强类型<code class="fe mx my mz na b">ElementRef&lt;HTMLElement&gt;</code>，它支持智能感知。我们还可以使用更具体的类型，比如如果元素是一个输入标签，就使用<code class="fe mx my mz na b">HTMLInputElement</code>等等。</p><p id="f6f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的演示中，我们修改了<code class="fe mx my mz na b">appElement</code>指令来接收一个<code class="fe mx my mz na b">boolean</code>输入，并根据它的值来转换<code class="fe mx my mz na b">div</code>元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/87f22965fdac622583ca924fe60a7545.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/1*2bWO-MdePWWifRNQyLeBNQ.gif"/></div></figure><p id="b043" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不会深入这个实现的细节，因为有更重要的事情需要关注。您可以在本文末尾提供的StackBlitz中找到并研究代码。</p><p id="9ec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，使用<code class="fe mx my mz na b">ElementRef</code>操作DOM应该小心！</p><p id="9cf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">官方的角度文件指出</p><blockquote class="nf"><p id="bd78" class="ng nh iq bd ni nj nk nl nm nn no lr dk translated">“[……]允许直接访问DOM会使您的应用程序更容易受到XSS攻击。”</p></blockquote><p id="4d7a" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">简单地说，如果我们只是想使用<code class="fe mx my mz na b">ElementRef</code>获得关于DOM元素的信息，这没有任何风险。风险在于修改DOM元素的特定情况。</p><p id="b84e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">长话短说，为了防止XSS攻击，Angular默认将所有值视为不可信。当一个值从模板绑定或插值中插入到DOM中时，Angular会自动清理和转义不受信任的值。</p><p id="203d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过直接通过<code class="fe mx my mz na b">ElementRef</code>访问和修改DOM，我们绕过了这种净化机制，这可能使我们的应用程序容易受到XSS攻击。</p><p id="3550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阅读<a class="ae kv" href="https://angular.io/guide/security#preventing-cross-site-scripting-xss" rel="noopener ugc nofollow" target="_blank">安全指南</a>了解更多信息。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5235" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">视图— ViewRef</h1><p id="0826" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们在上一节中使用了术语<em class="mw">视图</em>。那么，到底什么是视图呢？</p><p id="5d5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据Angular的文档，<a class="ae kv" href="https://angular.io/guide/glossary#view" rel="noopener ugc nofollow" target="_blank">视图</a>是“可以一起创建和销毁的显示元素的最小分组”。</p><p id="d4da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个定义听起来耳熟吗？</p><p id="d8f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没错。简单地说，组件类及其模板文件定义了一个视图。</p><p id="7652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><a class="ae kv" href="https://angular.io/api/core/ViewRef" rel="noopener ugc nofollow" target="_blank">ViewRef</a></code>类代表代码中的角度视图。一个<code class="fe mx my mz na b">ViewRef</code>可以是一个组件模板(<em class="mw">宿主视图</em>)或者一个<code class="fe mx my mz na b">TemplateRef</code> ( <em class="mw">嵌入视图</em>)。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a542" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">查看容器—视图容器参考</h1><p id="65c3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="mw">视图容器</em>是用于动态创建、添加或删除视图的容器。视图容器可以包含:</p><ul class=""><li id="911f" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated"><em class="mw">主机视图</em>，通过用<code class="fe mx my mz na b">createComponent</code>方法实例化一个组件来创建</li><li id="2c5d" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><em class="mw">嵌入式视图</em>，通过用<code class="fe mx my mz na b">createEmbeddedView</code>方法实例化一个<code class="fe mx my mz na b">TemplateRef</code>来创建</li></ul><p id="0968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><a class="ae kv" href="https://angular.io/api/core/ViewContainerRef" rel="noopener ugc nofollow" target="_blank">ViewContainerRef</a></code>类代表代码中的视图容器。它是我们用来以编程方式管理视图的API。</p><p id="a428" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是如何工作的？</p><p id="d0bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了通过代码动态地添加或删除组件，我们需要获得一个视图容器。像使用<code class="fe mx my mz na b">ElementRef</code>一样，这可以使用<code class="fe mx my mz na b">@ViewChild</code>装饰器或指令来完成。</p><p id="237e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查第一种方法。</p><p id="b99c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将模板变量分配给想要添加组件的容器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在类文件中，我们查询视图。只是这一次我们做的有点不同。观察<code class="fe mx my mz na b">{ read: ViewContainerRef }</code>部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6b9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当用户点击按钮时，一个<code class="fe mx my mz na b">SomeComponent</code>实例被创建并添加到每个视图容器中。</p><p id="0cb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分别，有一个<code class="fe mx my mz na b">remove</code>方法。我们可以有选择地传递我们想要销毁的视图的从0开始的索引。如果我们不传递任何东西，那么最后一个视图将被删除。</p><p id="d659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你知道吗？</p><p id="92ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个视图容器都有一个唯一的锚元素(一对一的关系)。在我们的演示中，HTML最初看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/a86b161f7b130dc909492ac432fe7d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*wiCNAbNtYCQoppJsAiWJ8Q.png"/></div></figure><p id="5f72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">&lt;!--ng-container--&gt;</code>和<code class="fe mx my mz na b">&lt;!--container--&gt;</code>是我们两个视图容器的锚元素。</p><p id="0292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，下面这个案例呢？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b1c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使在什么都不渲染的情况下，Angular仍然会使用锚元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/59de69e9b629fb6c66a67df2bfacbe62.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*nrj3imKvUyHWc-8MpNTdjQ.png"/></div></figure><p id="8517" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，当视图被添加到视图容器中时，它们将成为锚元素的兄弟！</p><p id="ce73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单击“创建组件”按钮将创建组件，并将其作为同级组件添加到锚定元素，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/335e67321d98b6474ef8ed942dab03e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*b4r5RE9WtOTjKaczlRBD8A.png"/></div></figure><p id="c645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，这也正是<code class="fe mx my mz na b">&lt;router-outlet&gt;</code>的情况。布线元件的标签没有出现在<code class="fe mx my mz na b">&lt;router-outlet&gt;</code>标签内。相反，它以兄弟姐妹的形式出现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f18b9bc323a6f2b51c657fa0067ae828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*2hyC1X2XSeRRd-GdTHA4Og.png"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a281" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">模板— <ng-template> —模板参考—嵌入视图</ng-template></h1><p id="9a2b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">模板是一组可以重用的HTML元素。在<code class="fe mx my mz na b">&lt;ng-template&gt;</code>中定义的视图被称为嵌入式视图。嵌入式视图在实例化之前不会呈现。</p><p id="807a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><a class="ae kv" href="https://angular.io/api/core/TemplateRef" rel="noopener ugc nofollow" target="_blank">TemplateRef</a></code>类“代表一个可以用来实例化嵌入式视图的嵌入式模板”。</p><p id="e29e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用组件模板文件中的<code class="fe mx my mz na b">&lt;ng-template&gt;</code>标签来定义一个模板。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4a5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在组件类中，我们可以通过使用<code class="fe mx my mz na b">ViewContainerRef</code>的<code class="fe mx my mz na b">createEmbeddedView</code>方法按需实例化一个嵌入式视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="97b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想从一开始就嵌入视图，我们可以简单地使用<code class="fe mx my mz na b">ngTemplateOutlet</code>，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6d13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/creating-reusable-configurable-angular-components-b7fcba2f5f38">阅读更多关于</a> <code class="fe mx my mz na b"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/creating-reusable-configurable-angular-components-b7fcba2f5f38">ngTemplateOutlet</a></code> <a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/creating-reusable-configurable-angular-components-b7fcba2f5f38">的文章</a>。</p><p id="78d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在下面的StackBlitz中找到一个工作演示。别忘了<a class="ae kv" href="https://vkagklis.medium.com/subscribe" rel="noopener">订阅我的简讯</a>来关注更多类似的内容！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om nc l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5882" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="afaf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本文中，我们讨论了一些术语(元素、模板、视图和视图容器)及其代码内表示(ElementRef、TemplateRef、ViewRef和ViewContainerRef)。</p><p id="9cf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还用简单的例子演示了如何利用这些类以编程方式操作DOM。</p><p id="0f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章，并且你学到了一些新的东西。</p><p id="f178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">感谢阅读！</em></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="8718" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mw">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">LinkedIn</em></strong></a><em class="mw"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">YouTube</em></strong></a><em class="mw"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">不和</em> </strong> </a> <em class="mw">。对增长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mw">电路</em> </strong> </a> <em class="mw">。</em></strong></a></p></div></div>    
</body>
</html>