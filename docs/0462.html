<html>
<head>
<title>An Introduction to IIFEs for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者生活入门</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-iifes-64d1b8f234ce?source=collection_archive---------14-----------------------#2022-01-26">https://javascript.plainenglish.io/understanding-iifes-64d1b8f234ce?source=collection_archive---------14-----------------------#2022-01-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5570" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是生活？IIFEs或立即调用的函数表达式是在定义时就被调用的函数。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3ac5af6b0a20a0a85a20c93415141dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d2_IBtbvQiATTWNpoq4jg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Immediately Invoked Function Expression</figcaption></figure><p id="e1c8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">立即调用函数表达式，你在不知情的情况下使用它们</p><p id="e95d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">生活就是你所说的立即被调用的函数表达式，是一个在定义的时候就被调用的函数。这也是一种被称为<a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Glossary/Self-Executing_Anonymous_Function" rel="noopener ugc nofollow" target="_blank">自执行匿名函数</a>的模式。基本的生活看起来像</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="5683" class="lu lv in lq b gy lw lx l ly lz">(function (){<br/> console.log("You Don't Invoke Me, I Invoke Me");<br/>})()</span></pre><p id="98d7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当函数被读取时，它被调用:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ma"><img src="../Images/145be8dfe145059b3468ce01366b3fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*enRRZ8gHGfppdUiKr6Ncqw.png"/></div></div></figure><p id="d9b7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">乍一看，它看起来很简单，而且确实如此。事情变得有点复杂的地方是决定在哪里使用它们。所以让我们看一些例子和用例来理解它们是如何工作的，最终的结果可能会比你想象的更令人惊讶。</p><h2 id="923e" class="lu lv in bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">让我们保持全局名称空间的整洁</h2><p id="e0e6" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">对于现代的JavaScript应用程序，我们注入了大量的依赖关系，其中一些是在全局/窗口对象中定义的依赖关系。但是如果我们定义了一个全局变量，它覆盖了另一个依赖项使用的变量，事情会变糟。总是建议将全局变量的数量保持在最小是有原因的(也有助于内存)。<br/>在我们看这个例子之前，让我提醒你，在JS中，一个函数中的所有变量/函数都被认为是局部的。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="f1ac" class="lu lv in lq b gy lw lx l ly lz">// global scope<br/>var sum = 100;</span><span id="7440" class="lu lv in lq b gy mx lx l ly lz">var getSum = num =&gt; (function(num){<br/>    // local scope<br/>    var sum = 10;<br/>    return sum + num;<br/>})(num)</span><span id="dbc8" class="lu lv in lq b gy mx lx l ly lz">console.log(getSum(40)); // =&gt; 50<br/>console.log(sum) // =&gt; 100</span></pre><p id="e91c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">变量<em class="my"> sum </em>的局部范围不影响全局定义的<em class="my"> sum </em>。这是一个基本的例子，但是当处理多个文件和暴露的全局范围时，很有可能会有同名的变量。为了防止它们互相覆盖，IIFE可能是定义局部作用域的一种方法。</p><h2 id="d370" class="lu lv in bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated"><strong class="ak"> <em class="mz">封装</em> </strong></h2><p id="f28b" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">封装是OOPs(面向对象编程)的核心概念之一。它指的是将数据以及对数据进行操作的方法捆绑到一个单元中，您也可以将它视为一个类。这让我们只公开实现功能所需的内容，这可以通过公共方法和变量的形式来完成。</p><p id="1141" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们使用IIFE来创建salary util，它公开了供用户交互的方法:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="0337" class="lu lv in lq b gy lw lx l ly lz">var salary = (function (){<br/>   // deduct 10% of basic salary<br/>   var tax = 10;<br/>   // add 5 % to basic salary<br/>   var houseAlowance = 5;</span><span id="6a93" class="lu lv in lq b gy mx lx l ly lz">// user can check savings;<br/>   function checkSaving(percent,salary){<br/>       var savings = (percent/100) * salary;<br/>       return savings<br/>   }</span><span id="b9b1" class="lu lv in lq b gy mx lx l ly lz">// returns salary after adding houseAlowance and tax deductions<br/>   function getSalary(amount){<br/>      var withHouseAlowance =  ((houseAlowance/100) * amount) +amount;<br/>      var taxCut =  (tax/100) * withHouseAlowance;<br/>      var salary = withHouseAlowance - taxCut<br/>      return salary;<br/>   }</span><span id="ad7a" class="lu lv in lq b gy mx lx l ly lz">   // exposed interface for the dev/user to work with<br/>    return {<br/>       checkSaving,getSalary<br/>   }<br/>})()</span></pre><p id="6fc6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如您在下面所看到的，只有IIFE返回的方法才暴露给用户进行交互。所以我们只暴露需要的东西，防止私有变量泄露，帮助我们实现封装。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/40242ffc1849a6e3dc38857b3fa71306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qeXumaYi5yXURSlzeJ3uNQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Encapsulation exposes only what we want to be public</figcaption></figure><h2 id="7ff6" class="lu lv in bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">模块模式</h2><p id="ad9b" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">因为这是一个很大的话题，所以我不会深入讨论这个模式的细节，但是这就是我所说的“如果你在不知情的情况下使用了它们”的意思如果您曾经将外部依赖项导入到您的项目中，则很有可能使用了以下语法:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="3f11" class="lu lv in lq b gy lw lx l ly lz">import {} from 'module'<br/>Or<br/>const abc = require('module')</span></pre><p id="1205" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这种模式中，立即调用的函数表达式(IIFE)用于创建私有范围，只导出应该是公共的部分(封装)。因为函数中定义的任何东西都是局部函数的一部分，所以不能被破坏。这有助于我们导入两个不同的模块，公开同名的方法。如果您想了解关于模块模式的更多信息，您可以查看:</p><ul class=""><li id="e9be" class="nb nc in ku b kv kw ky kz lb nd lf ne lj nf ln ng nh ni nj bi translated">https://github.com/umdjs/umd</li><li id="ed21" class="nb nc in ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">AMD:<a class="ae lo" href="https://en.wikipedia.org/wiki/Asynchronous_module_definition" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Asynchronous _ module _ definition</a></li><li id="e6f8" class="nb nc in ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">https://requirejs.org/docs/commonjs.html<a class="ae lo" href="https://requirejs.org/docs/commonjs.html" rel="noopener ugc nofollow" target="_blank"/></li></ul></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="da2d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">希望这能帮助你理解生命，以及它是如何成为JS开发的核心部分的。如果你有任何疑问，请让我知道。</p><p id="8c3c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢您的阅读。</p><p id="ce75" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="my">更多内容看</em> <a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="my">说白了就是io </em> </strong> </a> <em class="my">。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="my">免费周报</em> </strong> </a> <em class="my">。在我们的</em> <a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="my">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>