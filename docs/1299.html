<html>
<head>
<title>Common JavaScript Mistakes and Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的JavaScript错误和最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/part-2-common-javascript-mistakes-and-best-practices-8d60b210617e?source=collection_archive---------2-----------------------#2022-03-15">https://javascript.plainenglish.io/part-2-common-javascript-mistakes-and-best-practices-8d60b210617e?source=collection_archive---------2-----------------------#2022-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="dfa4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:每个JavaScript开发人员都应该熟悉的基本JavaScript编程技能。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/868c4c1c01c76a5532a94c7a00f57940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BupSKq1lJsZ613ZD"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clay Banks</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2aaa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">ES6发布后，JavaScript开发人员采用了ES6标准，并开始在日常编程中使用它们。但是等等，我们不是经常使用这些功能吗？就像传播一个对象并制作它的副本，以确保我们没有改变原始对象的值。但是你知道通过传播和克隆对象，你可能会也可能不会改变原始对象的值。让我们看一个例子。</p><h1 id="387e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated"><strong class="ak"> 1。浅层复制</strong></h1><p id="8199" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">你有一个对象:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/e4ac21db07b4c309b785c0eb6cee26b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*RrjMk3Zf9vDDYuMs_7V7yg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Original laptop object</figcaption></figure><p id="b8c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，我们需要这个laptop对象的一个副本，因此对该副本的任何更改都不会改变这个原始的laptop对象。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/2cf64cfc6a17216020c9390ef03d61d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*gIj_FxmXAGLNPtYLfgfLbw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Making a clone of laptop object</figcaption></figure><p id="cf05" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在将<strong class="kv io"> <em class="mo"> copyOfLaptop </em> </strong>中的属性改为<strong class="kv io"><em class="mo">copyOfLaptop . brand = " Dell "</em>。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/60f4e98f4551687cc4f8b75983b6aaad.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*F3UvXZ4iGznQPKQk1kGrsg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">after changing property in cloned object</figcaption></figure><p id="c908" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您检查原始的laptop对象，它将保持不变。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/e4ac21db07b4c309b785c0eb6cee26b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*RrjMk3Zf9vDDYuMs_7V7yg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Original laptop object log after changing the brand value in cloned object</figcaption></figure><p id="7dad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">似乎意料之中？也许…</p><p id="e900" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是你猜怎么着？如果我在<strong class="kv io"><em class="mo">copyofliptop</em></strong>(克隆的那个)内改变嵌套层次对象<em class="mo"> storage </em>的值，你觉得会不会变异原来的对象？</p><p id="4251" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们检查一下。</p><p id="b56a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们想更改<strong class="kv io"> <em class="mo"> copyOfLaptop中的存储类型和容量。</em>T19】</strong></p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="d6ab" class="mv lq in mr b gy mw mx l my mz"><em class="mo">copyOfLaptop.storage.type = “HDD”, <br/>copyOfLaptop.storage.capacity = “500”</em></span></pre><p id="591b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它改变了<strong class="kv io"><em class="mo">copyofliptop</em></strong>中的值，但是原始对象呢？</p><p id="b0b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们检查原始(笔记本电脑)对象。</p><p id="1887" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">…你猜怎么着？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/035ab6d23120645d615a2e2c40ecb965.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*j-_39O8vCGO80W7P2JB6kg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Log of the original object which mutates by its clone</figcaption></figure><p id="693b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">原因？</strong> 🧐</p><p id="5813" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为我们使用了spread操作符来克隆对象。它基本上克隆了一个完整的对象，但它只是防止了JSON本身第一层的变异。</p><p id="cfb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">也就是说，如果您更改了<strong class="kv io"><em class="mo">copy of laptop</em></strong><em class="mo">，</em>中的品牌、型号、操作系统或价格(位于对象的第一层)，原始对象将不会改变这些值。但是，如果您在嵌套数组或除JSON第一层之外的任何更深的层中更改值，它也会同时操作原始JSON值，因为两者共享相同的地址或位置。这叫浅抄。</p><p id="3c1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">👉<strong class="kv io">更好的解决方案</strong></p><p id="f902" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">深度复制/深度克隆</strong></p><p id="abd2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们不确定一个对象是否可以有嵌套层次的任何情况下，我们都可以使用深度克隆。</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="6319" class="mv lq in mr b gy mw mx l my mz"><strong class="mr io"><em class="mo">const copyOfLaptop = JSON.parse(JSON.stringify(laptop));</em></strong></span></pre><p id="d21e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将使用不同的地址复制整个对象，因此它永远不会改变原始的JSON。</p><blockquote class="nb nc nd"><p id="eefc" class="kt ku mo kv b kw kx jo ky kz la jr lb ne ld le lf nf lh li lj ng ll lm ln lo ig bi translated"><strong class="kv io"> <em class="in">注意</em> : </strong> <em class="in">使用</em><strong class="kv io"><em class="in">JSON . parse(JSON . stringify())</em></strong><em class="in">不会帮助你深度复制一个对象内部的任何函数。</em></p></blockquote></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><h1 id="76b9" class="lp lq in bd lr ls no lu lv lw np ly lz jt nq ju mb jw nr jx md jz ns ka mf mg bi translated"><strong class="ak"> 2。for…each还是findIndex还是find？</strong></h1><p id="d140" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">让我们假设我们有一个名为<strong class="kv io"> <em class="mo"> laptopList </em> </strong>的对象数组，并希望将操作系统值操作为“Windows 11”，其中brand = "DELL "。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0049aa23bd445f4e6fe972f9e61c2a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*hAE-BGeOtMxGKyW_pKgfHQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Array of objects</figcaption></figure><p id="7965" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在你可能猜对了在这种情况下该用什么。但是在我的代码评审中，我看到很多开发者在这里使用forEach或者findIndex来匹配值。这就是我在这里包括这个例子的原因。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/acb4b561e580837283615da27932be8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*T4__mLWI3R8qDmDNg8vmBA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Iterate through the array to check the matching object using forEach</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/3806dbbbbbfe0009af1b54496ce17679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOs4C2bBOdSq50WzG9p12g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Iterate through the array using findIndex</figcaption></figure><p id="1e66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">👉<strong class="kv io">更好的解决方案</strong></p><p id="cbcc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">使用查找</strong></p><p id="e070" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，只需确保匹配值应该是唯一的，这意味着一个数组中只有一个对象具有“Dell”品牌。如果是这样，您可以使用<strong class="kv io"> find </strong>迭代器来迭代和操作对象。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/42a557d38cc1a23d63ef993ecdf50249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8R7scQbnA8VrJz31pCLMA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Update values using the find inside an array</figcaption></figure><p id="ec80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将操作品牌为“Dell”的原始阵列的特定对象值。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><h1 id="cc1b" class="lp lq in bd lr ls no lu lv lw np ly lz jt nq ju mb jw nr jx md jz ns ka mf mg bi translated"><strong class="ak"> 3。开关还是对象？</strong></h1><p id="f050" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">有时，我们有一个值要比较，根据选择的值，我们必须提供它的结果。</p><p id="e97d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们通常避免if…else语句，因为它会导致多个if…else语句，并且代码会失去良好的可读性和速度。因此，我们使用switch-case语句来代替if..否则。但是如果你有多种选择呢？switch-case语句阅读和理解起来也很冗长。</p><p id="af55" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们来举个例子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/94a46749cddc32dcf75e970eb2059a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*tzahqNnttpzgR1iINaCCpw.png"/></div></figure><p id="dd80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，它看起来很长，它接受一个输入并提供一个匹配的输出。</p><p id="0977" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">👉<strong class="kv io">更好的解决方案</strong></p><p id="fd43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里使用switch完全没问题，但是如果您想要一个好的可读代码示例来解决这个问题，您可以在这里使用一个对象来解决这个问题。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0fffeaf25220a296371c6322e2f1e162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*A-9puKqJapAZAyQgYQ8XwQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Use object instead of the switch statement</figcaption></figure><p id="491c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我想澄清一下，用什么完全取决于你。使用对象不会降低时间复杂度，但是我在这里提到的原因是为了提高代码的可读性。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><h1 id="7d83" class="lp lq in bd lr ls no lu lv lw np ly lz jt nq ju mb jw nr jx md jz ns ka mf mg bi translated">4.等待还是承诺？</h1><p id="a88f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在ES6之后，我们非常习惯异步等待语法。我们通常在返回结果是承诺的地方使用它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/802e272f2163bcf13f3ecd57af402f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeStMjPu2VAp-WWS19tINw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using await for function execution</figcaption></figure><p id="f0da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们不得不举一个随机的例子，我们假设fetch将获得书和日历的细节。</p><p id="331f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">👉<strong class="kv io">更好的解决方案</strong></p><p id="04b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果函数不依赖于彼此的输出来进一步处理，请使用Promise.all。使用它不仅有利于可读性，而且它允许函数独立执行，不像await语法那样需要等待其他函数执行完毕。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/aa5e83c123a968333587bc103fa02087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxB15H4U_BOu11Ya4HYFMA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using Promise.all for function execution</figcaption></figure></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="aa06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以现在就这样了。我希望你喜欢这篇文章，并从中学到一些东西。你可以随时在社交媒体上联系我，寻求任何建议或意见。</p><p id="e9e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，如果您还没有阅读<a class="ae ks" href="https://hardik-thakar.medium.com/basic-javascript-mistakes-and-best-practices-aa97ffc0e553" rel="noopener"> <strong class="kv io">常见JavaScript错误和最佳实践:第1部分</strong> </a>，那么请继续查看。</p><p id="9e3e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mo">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mo">plain English . io</em></strong></a><em class="mo">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mo">免费周报</em> </strong> </a> <em class="mo">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mo">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mo">LinkedIn</em></strong></a><em class="mo"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mo">YouTube</em></strong></a><em class="mo"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mo">不和</em> </strong> </a> <em class="mo">。</em></p></div></div>    
</body>
</html>