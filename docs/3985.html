<html>
<head>
<title>Centralized Error Handling in NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS中的集中式错误处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/centralized-error-handling-in-nest-js-b230d5912a09?source=collection_archive---------0-----------------------#2022-10-16">https://javascript.plainenglish.io/centralized-error-handling-in-nest-js-b230d5912a09?source=collection_archive---------0-----------------------#2022-10-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1200" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何处理NestJS应用程序中所有错误的指南。</h2></div><blockquote class="kc kd ke"><p id="f8d8" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">背景——我有一个需求，我需要在一个地方捕获所有错误，记录它们(如果我们需要记录这样的错误)，增加错误度量(Prometheus和prom——grafana dashboard的客户端)。</p><p id="25d9" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">存在的问题——我们使用通用的nestjs模式传递来自控制器-&gt;服务-&gt;存储库的数据。因为所有的代码块都被try-catch块包围着，所以非常需要我们在每个模块中注入[度量服务&amp;日志服务]。然后调用一个通用函数来执行所有必要的检查和进一步的操作</p></blockquote><p id="41b8" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">解决方案——我们通过使用NestJs拦截器找到了解决方案，该拦截器可以捕捉异常+错误，而异常过滤器只捕捉和响应异常。现在，一旦被注入，我们就在任何需要的地方移除我们的try catch块，现在几乎90%的模块都没有这些块了。</p><p id="c252" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在拦截器中，我们注入了度量服务和日志服务，这将负责这两个操作。我们可以转换错误，并通过包含一些属性将其作为通用消息回复给用户。</p><p id="94d7" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">为了更好地理解这个流程，让我们看一下nestjs应用程序中的请求-响应生命周期</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/b12e197ef4b279166a6dd3d7aa84e177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ZXNh7ea7SBYkJdJD4YLTw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Complete Application Flow</figcaption></figure><p id="aa0a" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">最上面的块由请求生命周期组成。下半部分包含处理和响应。如果整个应用程序出现任何问题，它将总是通过{拦截器Post请求}传递，这就是我们可以利用的。</p><p id="dda6" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">拦截器的一个例子可以在</p><div class="lv lw gp gr lx ly"><a href="https://github.com/akshay271703/nest-email-otp/blob/c6a982e3a93c1a370c3c48957bae8e6904dcdc16/src/utilities/interceptors/app.interceptor.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd io gy z fp md fr fs me fu fw im bi translated">nest-email-OTP/app . interceptor . ts at c 6 a 982 E3 a 93 C1 a 370 C3 c 48957 bae8e 6904 dcdc 16…</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm lp ly"/></div></div></a></div><p id="0b7c" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">本文是从我以前的一个小项目扩展而来的，该项目使用基于OTP的用户注册。我现在已经用Nest Js / TypeScript创建了项目。邮寄是通过AWS SES完成的。链接可以在下面找到。</p><div class="lv lw gp gr lx ly"><a rel="noopener  ugc nofollow" target="_blank" href="/create-otp-based-user-sign-up-using-node-js-cc4defc54123"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd io gy z fp md fr fs me fu fw im bi translated">使用Node.js创建一个基于OTP的用户注册</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">这篇文章是关于创建一个OTP风格的用户注册系统。我将把路线图分成几个部分，以便您…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm lp ly"/></div></div></a></div><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5c40" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">拦截器使用的简要总结—</p><p id="e17e" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">每当我的应用程序抛出一个错误，它就会被这个拦截器捕获，然后</p><ul class=""><li id="5a73" class="mq mr in ki b kj kk km kn lc ms ld mt le mu lb mv mw mx my bi translated">我检查这是什么类型的错误。在我的案例中，它曾经是—</li></ul><p id="f52f" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">[1]数据库错误—我可以使用TypeORMError的instanceof来检查</p><p id="ab94" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">[2]应用程序错误—我可以通过实例f HttpException再次检查该错误</p><p id="90df" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">[3]未确定。你可以改进这个过滤器，但是为了简单起见，我只添加了几个。</p><ul class=""><li id="6a53" class="mq mr in ki b kj kk km kn lc ms ld mt le mu lb mv mw mx my bi translated">我可以通过转换并附加到原始错误消息中，抛出一个简单的用户友好的错误细节。</li><li id="7a43" class="mq mr in ki b kj mz km na lc nb ld nc le nd lb mv mw mx my bi translated">我可以在这里执行日志记录，并限制我需要记录的错误类型。</li><li id="b164" class="mq mr in ki b kj mz km na lc nb ld nc le nd lb mv mw mx my bi translated">我可以在本模块中处理我的指标。</li></ul></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="2b9b" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><em class="kh">更多内容请看</em><a class="ae nl" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ki io"><em class="kh">plain English . io</em></strong></a><em class="kh">。报名参加我们的</em> <a class="ae nl" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki io"> <em class="kh">免费周报</em> </strong> </a> <em class="kh">。关注我们关于</em><a class="ae nl" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ki io"><em class="kh">Twitter</em></strong></a><a class="ae nl" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ki io"><em class="kh">LinkedIn</em></strong></a><em class="kh"/><a class="ae nl" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ki io"><em class="kh">YouTube</em></strong></a><em class="kh"/><a class="ae nl" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ki io"><em class="kh">不和</em> </strong> </a> <em class="kh">。对增长黑客感兴趣？检查</em> <a class="ae nl" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki io"> <em class="kh">电路</em> </strong> </a> <em class="kh">。</em></p></div></div>    
</body>
</html>