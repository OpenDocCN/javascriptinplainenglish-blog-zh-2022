<html>
<head>
<title>Async/Await in Angular ngOnInit using TypeScript Decorator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript装饰器在Angular ngOnInit中异步/等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/async-await-in-angular-ngoninit-using-typescript-decorator-b8b35963407c?source=collection_archive---------1-----------------------#2022-07-04">https://javascript.plainenglish.io/async-await-in-angular-ngoninit-using-typescript-decorator-b8b35963407c?source=collection_archive---------1-----------------------#2022-07-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/690620f47028f8c672db09fbaa291394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eipu9kkYnoP8ahM1LbDwgQ.jpeg"/></div></div></figure><p id="9aca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很多时候，在页面加载或类初始化之前，需要使用API的承诺来加载数据。</p><p id="0c2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了实现这一点，我看到我的许多开发伙伴在<code class="fe kt ku kv kw b">ngOnInit</code>上使用<code class="fe kt ku kv kw b">async</code>，这样他们就可以在<code class="fe kt ku kv kw b">ngOnInit</code>内对数据获取API方法进行<code class="fe kt ku kv kw b">await</code></p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="2a18" class="lf lg in kw b gy lh li l lj lk">async ngOnit {<br/>  this.movies = await this.service.getMovies();<br/>}</span></pre><p id="c3fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果你仔细观察，没有人在等<code class="fe kt ku kv kw b">ngOnInit</code>，即使你想等也等不到<code class="fe kt ku kv kw b">await ngOnInit</code>。</p><p id="6dcf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将运行异步函数，但不会等待它完成，它只允许你使用<code class="fe kt ku kv kw b">await</code>关键字，但它不是<code class="fe kt ku kv kw b">aysnc</code>函数，尽管有<code class="fe kt ku kv kw b">async</code>关键字。</p><p id="c73c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这看起来有点尴尬，有点难以理解，似乎不是传统。</p><p id="aec6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理想情况下，方法是使用路由解析器，以便在路由完成导航之前加载数据，并且我可以知道在视图加载之前数据是可用的。</p><p id="ca59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">许多堆栈溢出的答案指出了一种可读性更好的方法，不用给<code class="fe kt ku kv kw b">ngOnInit</code>添加<code class="fe kt ku kv kw b">async</code>关键字，但是解决方案的行为是一样的。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="1941" class="lf lg in kw b gy lh li l lj lk">ngOnInit() {<br/>  (async () =&gt; {<br/>    this.movies = await this.service.getMovies();<br/>  });<br/>}</span></pre><blockquote class="ll lm ln"><p id="1396" class="jv jw lo jx b jy jz ka kb kc kd ke kf lp kh ki kj lq kl km kn lr kp kq kr ks ig bi translated">乔纳森·甘布尔(Jonathan Gamble)在迫使Angular等待你的异步函数(Async Function)方面也有一个有趣的地方。</p></blockquote><p id="169d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这不仅仅是角度分量。想象一个简单的类，它装载一些数据，并且有数据的getters和setters。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="9b5a" class="lf lg in kw b gy lh li l lj lk">class MovieService {<br/>  private movies: Movie[];</span><span id="eac2" class="lf lg in kw b gy lv li l lj lk">  constructor(){<br/>    this.loadMovies();<br/>  }</span><span id="322e" class="lf lg in kw b gy lv li l lj lk">  getMovieById(id: number) {<br/>    return this.movies.find(movie =&gt; movie.id === id);<br/>  }</span><span id="81f7" class="lf lg in kw b gy lv li l lj lk">  getAllMovies() {<br/>    return this.movies;<br/>  }</span><span id="d3ea" class="lf lg in kw b gy lv li l lj lk">  private async loadMovies(){<br/>    this.movies = await MovieStore.getTodos();<br/>  }<br/>}</span></pre><p id="3a9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，当类的实例被创建时，数据将立即开始加载，并且构造函数不能被阻塞，直到数据被完全提取。因此，如果在请求挂起时调用getters，它可能会以默认的empty或<code class="fe kt ku kv kw b">undefined</code> movies对象结束。</p><p id="85f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以你只能希望在调用任何getters的时候数据已经被加载了。改变这种情况的方法是添加一些延迟加载，让访问器等待加载请求，如下所示。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="5e28" class="lf lg in kw b gy lh li l lj lk">async getMoviesById(id: number){<br/>  if(!this.movies){<br/>    await this.loadMovies();<br/>  }<br/>  return this.movies.find(movie =&gt; movie.id === id);<br/>}</span></pre><p id="531f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看起来不错，但是这段代码现在变成了重复的代码，如果我们能够找到一种方法用其他东西抽象所有这些连接，加载请求可能会被触发不止一次。</p><h2 id="38b8" class="lf lg in bd lw lx ly dn lz ma mb dp mc kg md me mf kk mg mh mi ko mj mk ml mm bi translated"><a class="ae lu" href="https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-composition" rel="noopener ugc nofollow" target="_blank">打字稿装饰工</a>来救场了🎉</h2><p id="565b" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated"><em class="lo">装饰器</em>是一种特殊的声明，可以附加到<a class="ae lu" href="https://www.typescriptlang.org/docs/handbook/decorators.html#class-decorators" rel="noopener ugc nofollow" target="_blank">类声明</a>、<a class="ae lu" href="https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators" rel="noopener ugc nofollow" target="_blank">方法</a>、<a class="ae lu" href="https://www.typescriptlang.org/docs/handbook/decorators.html#accessor-decorators" rel="noopener ugc nofollow" target="_blank">访问器</a>、<a class="ae lu" href="https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators" rel="noopener ugc nofollow" target="_blank">属性</a>或<a class="ae lu" href="https://www.typescriptlang.org/docs/handbook/decorators.html#parameter-decorators" rel="noopener ugc nofollow" target="_blank">参数</a>上。</p><p id="dea9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单明了地说，<strong class="jx io">装饰器是</strong> <strong class="jx io">一个函数，它接受另一个函数并扩展后一个函数的行为，而无需显式修改它。</strong></p><p id="5051" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">抽象连接的一个好方法是在我们可以等待的地方使用decorators，首先调用所有要运行和完成的方法，然后运行依赖于这些方法的方法。如下图所示:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Movies Service using Init decorator</figcaption></figure><p id="cea0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是如何让这些装饰工作。您可以将每个装饰器添加到任意多的方法中。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Init/WaitForInit Decorator implmentation</figcaption></figure></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h2 id="71b9" class="lf lg in bd lw lx ly dn lz ma mb dp mc kg md me mf kk mg mh mi ko mj mk ml mm bi translated">对装饰新手的代码解释</h2><p id="2694" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">为了理解init/waitForInit装饰器代码，我们首先必须理解装饰器是如何被评估的。</p><blockquote class="ll lm ln"><p id="7b54" class="jv jw lo jx b jy jz ka kb kc kd ke kf lp kh ki kj lq kl km kn lr kp kq kr ks ig bi translated">这里很好地解释了装饰者是如何被评估的，我推荐你去看看。</p></blockquote><p id="62d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以下面的例子来理解评估:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="506a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同上，我们所有的<code class="fe kt ku kv kw b">init</code>修饰的方法将首先被评估，其中在电影服务案例中，<code class="fe kt ku kv kw b">loadMovies</code>将被注册为<code class="fe kt ku kv kw b">INIT_METHODS</code>之一，然后当任何一个用<code class="fe kt ku kv kw b">waitForInit</code>修饰的方法如<code class="fe kt ku kv kw b">getAllMovies</code>被调用时，它将首先运行<code class="fe kt ku kv kw b">loadMovies</code>承诺，然后运行相应的调用函数。</p><blockquote class="nf"><p id="e25d" class="ng nh in bd ni nj nk nl nm nn no ks dk translated">等待🤔我们正在讨论代码在哪里？👊</p></blockquote><p id="048f" class="pw-post-body-paragraph jv jw in jx b jy np ka kb kc nq ke kf kg nr ki kj kk ns km kn ko nt kq kr ks ig bi translated">别担心，我们会掩护你的。下面是如何在<code class="fe kt ku kv kw b">ngOnInit</code>上使用相同的<code class="fe kt ku kv kw b">init/waitForInit</code>装饰器。</p><p id="ea15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是Stackblitz示例，演示了<code class="fe kt ku kv kw b">ngOnInit</code>上的装饰器。</p><p id="ef31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lu" href="https://angular-ivy-kq23e9.stackblitz.io" rel="noopener ugc nofollow" target="_blank">https://angular-ivy-kq23e 9 . stack blitz . io</a></p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">init/waitForInit on ngOnit in Angular</figcaption></figure><p id="b4d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们简要讨论了在Angular中使用TypeScript decorator预加载任何类中的数据或在模板初始化之前的实现。</p><p id="4085" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请在下面留下评论，让我知道其他各种方法，如果有的话，或者如果有任何即兴创作。我很乐意回答这些问题。</p><p id="6fc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">推荐人:</strong></p><ol class=""><li id="9b1e" class="nu nv in jx b jy jz kc kd kg nw kk nx ko ny ks nz oa ob oc bi translated"><a class="ae lu" href="https://dev.to/jdgamble555/forcing-angular-to-wait-on-your-async-function-2ck1" rel="noopener ugc nofollow" target="_blank">强制Angular等待您的异步函数</a></li><li id="e5af" class="nu nv in jx b jy od kc oe kg of kk og ko oh ks nz oa ob oc bi translated"><a class="ae lu" href="https://romkevandermeulen.nl/2018/05/10/waitoninit.html" rel="noopener ugc nofollow" target="_blank"> @init / @waitOnInit类型脚本方法装饰器</a></li><li id="0883" class="nu nv in jx b jy od kc oe kg of kk og ko oh ks nz oa ob oc bi translated"><a class="ae lu" href="https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-composition" rel="noopener ugc nofollow" target="_blank">打字稿装璜师</a></li><li id="3b7c" class="nu nv in jx b jy od kc oe kg of kk og ko oh ks nz oa ob oc bi translated"><a class="ae lu" href="https://stackoverflow.com/questions/56092083/async-await-in-angular-ngoninit/58474585#58474585" rel="noopener ugc nofollow" target="_blank">[stack overflow]async/await in Angular ` ngoninit</a>`中</li></ol><p id="d705" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lo">更多内容请看</em> <a class="ae lu" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lo">说白了。报名参加我们的</em> <a class="ae lu" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lo">免费周报</em> </strong> </a> <em class="lo">。关注我们</em><a class="ae lu" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lo">Twitter</em></strong></a><em class="lo">和</em><a class="ae lu" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lo">LinkedIn</em></strong></a><em class="lo">。查看我们的</em> <a class="ae lu" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lo">社区不和谐</em> </strong> </a> <em class="lo">加入我们的</em> <a class="ae lu" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lo">人才集体</em> </strong> </a> <em class="lo">。</em></strong></a></p></div></div>    
</body>
</html>