<html>
<head>
<title>Rethinking the Data Management for React Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对React表单数据管理的再思考</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rethinking-the-data-management-for-react-forms-de1a78fe328?source=collection_archive---------10-----------------------#2022-02-04">https://javascript.plainenglish.io/rethinking-the-data-management-for-react-forms-de1a78fe328?source=collection_archive---------10-----------------------#2022-02-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="912d" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">这个简单的技术可以让你在一个表单中省去多次重新渲染。</h2><div class=""/><div class=""><h2 id="9b8c" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">当用户更新字段时，如何在表单中保存不必要的重新呈现。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a4f3155bbef0045523534d56478f1f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W_khlWNo10DGJjGV"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@impatrickt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Patrick Tomasso</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="5b8c" class="lc ld in bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw it bi translated">这是一个真实的故事</h2><p id="b806" class="pw-post-body-paragraph lx ly in lz b ma mb jx mc md me ka mf ll mg mh mi lp mj mk ml lt mm mn mo mp ig bi translated">这篇文章描述的事件发生在现实生活中。作者想用假名来避免尴尬。但是后来他意识到他是无名之辈，没有人关心他在日常生活中经历了什么。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="112c" class="lc ld in bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw it bi translated">问题是</h2><p id="482c" class="pw-post-body-paragraph lx ly in lz b ma mb jx mc md me ka mf ll mg mh mi lp mj mk ml lt mm mn mo mp ig bi translated">所以，我去年在React上写了一篇关于“<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/a-better-way-to-handle-forms-and-input-with-react-e01500ac73c">如何处理表单</a>”的帖子。这是一个很好的技巧。但后来我意识到，我们是在一次字段更新中重新呈现所有内容。我意识到了这个问题，但我对这个问题视而不见，认为“这没什么大不了的。我的表单中永远不会有超过10个字段。但是时代变了，我加入了一个新的组织。现在，我要在一个表单中处理50多个字段。然后这个重新渲染对我们来说是一个很大的问题。</p><p id="d260" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">架构很简单:</p><ul class=""><li id="838c" class="nc nd in lz b ma mx md my ll ne lp nf lt ng mp nh ni nj nk bi translated">表单组件像HOC一样，在其状态中存储所有字段的值。</li><li id="ad12" class="nc nd in lz b ma nl md nm ll nn lp no lt np mp nh ni nj nk bi translated">特设公开其状态和通过上下文更新它的函数。</li><li id="d150" class="nc nd in lz b ma nl md nm ll nn lp no lt np mp nh ni nj nk bi translated">当用户更新时，输入字段调用公开的函数。</li></ul><p id="131d" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">乍一看，这是一个干净的架构。但是，在一次字段更新中重新呈现所有内容是非常昂贵的。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="2a99" class="lc ld in bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw it bi translated">解决中的问题</h2><p id="8992" class="pw-post-body-paragraph lx ly in lz b ma mb jx mc md me ka mf ll mg mh mi lp mj mk ml lt mm mn mo mp ig bi translated">当然，解决这个问题有多种方法。我认为记忆输入字段是我的第一直觉。而且也没什么不好(至少我是这么想的)。但是后来我意识到我所有的输入组件都依赖于上下文。出于某种原因，如果我不传递上下文，整个系统就会崩溃。这是我书中的一个问题。另外，Memoizing本身并不坏，但是在这里使用它并不是一个优雅的解决方案(是的，我说过)。就好像我仍然对糟糕的建筑问题视而不见。</p><p id="741b" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">那么，有什么更好的解决方案可以拯救我作为前端架构师的尊严呢？</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="ce25" class="lc ld in bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw it bi translated">解决方案</h2><p id="0892" class="pw-post-body-paragraph lx ly in lz b ma mb jx mc md me ka mf ll mg mh mi lp mj mk ml lt mm mn mo mp ig bi translated">让我们回顾一下我们的理想解决方案应该是什么样的:</p><ul class=""><li id="6d93" class="nc nd in lz b ma mx md my ll ne lp nf lt ng mp nh ni nj nk bi translated">不应该在一次更新中重新呈现整个表单。</li><li id="a556" class="nc nd in lz b ma nl md nm ll nn lp no lt np mp nh ni nj nk bi translated">输入字段应该独立工作。如果这要求太高，那么至少它应该更优雅地处理错误场景(即没有上下文)。</li><li id="693d" class="nc nd in lz b ma nl md nm ll nn lp no lt np mp nh ni nj nk bi translated">不应该使用记忆，因为这不是我们情况下的解决方案。</li><li id="bc22" class="nc nd in lz b ma nl md nm ll nn lp no lt np mp nh ni nj nk bi translated">表单组件应该管理顶层的所有数据。</li></ul><p id="6d6c" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">有一天，我阅读了Kent C Dodds的一篇文章，文章中提到，应该让状态尽可能靠近使用它的组件。这有助于您节省一些重新渲染，并且您不必像一个无知的白痴一样通过多个组件传递状态。这在我脑海中引发了一个问题— <em class="nq">如果每个输入字段都处理自己的状态会怎么样？</em>它解决了我们一半的问题:</p><ul class=""><li id="95fc" class="nc nd in lz b ma mx md my ll ne lp nf lt ng mp nh ni nj nk bi translated">表单不会在每次更新时重新呈现。</li><li id="491e" class="nc nd in lz b ma nl md nm ll nn lp no lt np mp nh ni nj nk bi translated">输入字段将独立于上下文。即使没有任何特设，它仍然可以工作。</li><li id="f857" class="nc nd in lz b ma nl md nm ll nn lp no lt np mp nh ni nj nk bi translated">记忆化绝对是不可能的。</li></ul><p id="e4c9" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">但是这里有一个巨大的问题。如果每个字段处理自己的状态，我们如何在一个点收集所有表单数据？现在，为什么我们需要所有的数据在一个地方？显而易见的答案是，我们需要将数据发送到服务器。假设我们将数据存储在表单组件的状态中，并公开一个函数(通过上下文)来更新状态。您可以在表单提交或任何需要的地方访问数据。一切看起来都很好(目前)，但是如果您需要根据一个字段的值更新另一个字段，该怎么办呢？你会说也公开表单状态，对吗？嗯，我也是这么想的。但是现在我们回到了最初的问题——状态更新，这反过来又他妈的重新渲染了一遍整个事情。有人，请杀了我吧。不不等等。有一个解决办法。</p><h2 id="9def" class="lc ld in bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw it bi translated">拯救世界的裁判</h2><p id="afaf" class="pw-post-body-paragraph lx ly in lz b ma mb jx mc md me ka mf ll mg mh mi lp mj mk ml lt mm mn mo mp ig bi translated">从事React工作的聪明人知道，有些情况下，即使数据更新了，你也不想更新UI。所以他们创建了Ref API。现在我们知道，当Ref更新时，组件不会重新呈现自己。</p><p id="a677" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">参考文献可能是我们潜在的解决方案。如果我们不使用状态，而是使用Ref，并公开Ref和一个函数来更新它，会怎么样？它也解决了我们的最后一个问题——表单不会在Ref更新时重新呈现自己。而且我们在一个地方也有完整的表单数据，任何输入都可以访问整个表单数据。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="1ea5" class="lc ld in bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw it bi translated">说够了，给我们看些代码(WTF你怎么了？)</h2><p id="0b39" class="pw-post-body-paragraph lx ly in lz b ma mb jx mc md me ka mf ll mg mh mi lp mj mk ml lt mm mn mo mp ig bi translated">好吧，我知道从文章一开始就只是说说而已。现在让我们快速看看如何适度地实现这种方法。</p><h2 id="df3b" class="lc ld in bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw it bi translated"><strong class="ak">处理表单数据的钩子:</strong></h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/ef28ebde5484f02355e5d7c3215275a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7FJLzNFdQfb1kS_PVtoxQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">A form data handler hook that takes care of everything.</figcaption></figure><p id="c83c" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">在这里，我创建了一个自定义钩子:<code class="fe ns nt nu nv b">useFormData</code>。您可以将初始的表单状态传递给钩子，它将返回一个函数<code class="fe ns nt nu nv b">getFormData</code>来获取当前的表单数据。它还返回另一个函数<code class="fe ns nt nu nv b">handleInputChange</code>，来更新存储表单数据的Ref对象。当用户更新输入时，我们需要调用这个函数。所以我们基本上保留了表单数据的副本。请注意，我们绝不会在上层操纵这些数据。只有输入字段可以(并且应该)改变数据。</p><h2 id="4dd2" class="lc ld in bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw it bi translated">使用钩子的表单组件:</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/882cf602680b5949982ddbfb033e87ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGekdavciXjmJarzWyMBJA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">The Form component</figcaption></figure><p id="211b" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">它是一个简单的表单组件，使用我们刚刚创建的钩子。它呈现两个文本输入字段。并将<code class="fe ns nt nu nv b">handleInputChange</code>函数传递给每个文本字段。当用户更新字段值时，Input将调用这个函数。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="858e" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">这里是一个完整的工作代码沙盒链接:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Fully working codesandbox</figcaption></figure></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="14c6" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">现在你知道如何以更好的方式处理表单了。我希望你在这里学到了新东西。</p><h1 id="acb1" class="nz ld in bd le oa ob oc lh od oe of lk kc og kd lo kf oh kg ls ki oi kj lw oj bi translated">关于作者</h1><p id="f24b" class="pw-post-body-paragraph lx ly in lz b ma mb jx mc md me ka mf ll mg mh mi lp mj mk ml lt mm mn mo mp ig bi translated">Bharat自2011年以来一直是前端开发人员。他对“前端开发经验”情有独钟。他喜欢学习和教授技术。</p><p id="e2c4" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated">总的来说是个好人。在<a class="ae lb" href="https://twitter.com/iiisoni" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lb" href="https://github.com/iiison" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae lb" href="https://www.linkedin.com/in/iiison/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到他。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ok ny l"/></div></figure><p id="c434" class="pw-post-body-paragraph lx ly in lz b ma mx jx mc md my ka mf ll mz mh mi lp na mk ml lt nb mn mo mp ig bi translated"><em class="nq">更多内容看</em> <a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ix"> <em class="nq">说白了就是io </em> </strong> </a> <em class="nq">。报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ix"> <em class="nq">免费周报</em> </strong> </a> <em class="nq">。在我们的</em> <a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ix"> <em class="nq">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="nq">。</em></p></div></div>    
</body>
</html>