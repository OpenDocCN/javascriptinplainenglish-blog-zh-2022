<html>
<head>
<title>How to Prevent a Function From Being Called Multiple Times</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何防止一个函数被多次调用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-prevent-a-function-from-being-called-multiple-times-c8d59b2d637d?source=collection_archive---------6-----------------------#2022-11-17">https://javascript.plainenglish.io/how-to-prevent-a-function-from-being-called-multiple-times-c8d59b2d637d?source=collection_archive---------6-----------------------#2022-11-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4446" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你使用一个事件处理程序，比如<strong class="jm io"> onClick </strong>、<strong class="jm io"> onChange、</strong>或者<strong class="jm io"> onScroll </strong>，并且想要防止回调被过快地触发，那么你可以限制回调的执行速率。这可以通过以下可能的方式实现。</p><h1 id="532c" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">节流</h1><p id="9dc8" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">基于基于时间的频率的变化。比如可以用<strong class="jm io"> _。油门</strong> lodash功能。</p><pre class="ll lm ln lo gt lp lq lr bn ls lt bi"><span id="3b53" class="lu kj in lq b be lv lw l lx ly">_.throttle(func, wait, options)</span></pre><p id="a782" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Lodash的<strong class="jm io"> _。throttle() </strong>方法创建一个每毫秒只能调用一次函数参数的throttled函数。该方法至少需要两个参数，即函数和节流时间。</p><h1 id="401e" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">去抖动</h1><p id="9b35" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">当一个函数被传递给Lodash的去抖函数时，它会延迟函数的执行。例如，当我们想要通过键入输入来实现搜索时，它会很有帮助。我们不应该为每个输入的字符调用搜索API请求，而应该只在用户停止输入后才调用它。</p><pre class="ll lm ln lo gt lp lq lr bn ls lt bi"><span id="b474" class="lu kj in lq b be lv lw l lx ly">export default function App() {<br/>  const [results, setResults] = React.useState([])<br/><br/>  const debouncedSearch = React.useRef(<br/>    debounce(async () =&gt; {<br/>      const response = await fetch(`/api/search?query=${query}`)<br/>      const body = await response.json()<br/>      const results = body.results.map((result) =&gt; result.name)<br/>      setResults(results)<br/>    }, 300)<br/>  ).current<br/><br/>  async function handleChange(e) {<br/>    debouncedSearch(e.target.value)<br/>  }<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;input<br/>        type="search"<br/>        placeholder="Enter your search"<br/>        onChange={handleChange}<br/>      /&gt;<br/>      &lt;ul&gt;<br/>        {results.map((result) =&gt; (<br/>          &lt;li key={result}&gt;{result}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="dde2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在ReactJS中使用Lodash去反跳方法最好是将其包装在useRef函数中，因为这样可以跟踪去反跳函数并防止在每次渲染时创建它们。</p><h1 id="b787" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">RequestAnimationFrame节流</h1><p id="998f" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">当一个函数用于渲染动画或者计算元素的位置时，我们可以使用RequestAnimationFrame来防止它被触发太多次。</p><pre class="ll lm ln lo gt lp lq lr bn ls lt bi"><span id="c763" class="lu kj in lq b be lv lw l lx ly">const rafId = requestAnimationFrame(callback);</span></pre><p id="a1d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每次浏览器开始下一次绘制页面之前，Windows.requestAnimationFrame都会执行您的回调(通常每秒60次)。要停止它，您需要调用<strong class="jm io"> cancelAnimationFrame </strong>并传递请求的id(示例中的<strong class="jm io"> rafId </strong>)。</p><p id="b6ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lz">更多内容请看</em><a class="ae ma" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lz">plain English . io</em></strong></a><em class="lz">。报名参加我们的</em> <a class="ae ma" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="lz">免费周报</em> </strong> </a> <em class="lz">。关注我们关于</em><a class="ae ma" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lz">Twitter</em></strong></a><a class="ae ma" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lz">LinkedIn</em></strong></a><em class="lz"/><a class="ae ma" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lz">YouTube</em></strong></a><em class="lz"/><a class="ae ma" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lz">不和</em> </strong> </a> <em class="lz">。对增长黑客感兴趣？检查</em> <a class="ae ma" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="lz">电路</em> </strong> </a> <em class="lz">。</em></p></div></div>    
</body>
</html>