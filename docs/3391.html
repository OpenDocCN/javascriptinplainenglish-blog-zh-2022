<html>
<head>
<title>Front-End CSR, SSR, SSG — Can You Really Tell the Difference?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端CSR、SSR、SSG——你真的能区分它们吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/front-end-csr-ssr-ssg-can-you-really-tell-the-difference-8ddedc9c05d6?source=collection_archive---------9-----------------------#2022-08-24">https://javascript.plainenglish.io/front-end-csr-ssr-ssg-can-you-really-tell-the-difference-8ddedc9c05d6?source=collection_archive---------9-----------------------#2022-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c56d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">许多人无法区分客户端渲染(CSR)、服务器端渲染(SSR)和静态站点生成(SSG)。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/69990a2b3d18e403c986b42915e16fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JsFC-2zHuBqzAHG3"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@davehoefler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dave Hoefler</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e217" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多人无法区分客户端渲染(CSR)、服务器端渲染(SSR)和静态站点生成(SSG)。下面简单介绍一下各自的特点。看完之后，相信你一定能清晰地感受到它们之间的区别。</p><h2 id="1e72" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">页面的呈现过程</h2><p id="628f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在开始之前，让我们回顾一下页面最基本的呈现过程是如何工作的。</p><ul class=""><li id="4dba" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">浏览器通过请求获取HTML文本。</li><li id="f5d5" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">呈现过程解析HTML文本并构建DOM树。</li><li id="7f86" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">当浏览器解析HTML时，如果遇到内嵌样式或样本样式，它会下载并构建样式规则。如果遇到JavaScript脚本，则下载并执行该脚本。</li><li id="8c41" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">构建DOM树和样式规则后，渲染过程会将它们合并到一个渲染树中。</li><li id="7a28" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">渲染过程从布局渲染树开始，创建布局树。</li><li id="5925" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">渲染过程绘制布局树并生成绘图记录。</li><li id="ca98" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">渲染过程将布局树分层，分别光栅化每一层并获得复合帧。</li><li id="1fd7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">渲染过程将复合帧发送到GPU，然后将图像绘制到页面上。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/7fff3fcd63cdaee4f8f3839824c7a81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HiDQfGcaiS336uu4DYH4Bg.png"/></div></div></figure><p id="f6f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，页面渲染实际上是浏览器将HTML文本转换为页面框架的过程，我们将在下面介绍刚才提到的技术。</p><h2 id="1039" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">企业社会责任</h2><p id="5e09" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们的web应用大多使用JavaScript框架(Vue、React、Angular)进行页面渲染，页面上的DOM元素大多是通过JavaScript插入的。换句话说，在JavaScript脚本执行之前，HTML页面就已经解析好了，DOM树也已经构建好了，JavaScript脚本只是动态改变DOM树的结构，让页面变成你想要的样子。这种渲染方式称为动态渲染，通常称为客户端渲染(CSR)。</p><p id="f5c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码是浏览器在请求React编写的单页应用页面时响应的HTML文档，实际上只是一个空壳，没有具体的文本内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="d143" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">苏维埃社会主义共和国</h2><p id="46a1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">顾名思义，服务器端渲染就是当浏览器请求页面URL时，服务器组装我们需要的HTML文本并返回给浏览器。浏览器解析完这个HTML文本后，就可以直接构建所需的DOM树并显示在页面上，而不需要经过JavaScript脚本下载过程。这个服务器端HTML组装的过程称为服务器端呈现(SSR)。</p><p id="969b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是服务器端渲染返回的HTML文档。由于代码量太多，只保留了代码的符号部分，但是很容易发现服务器端渲染返回的HTML文档中有页面的核心文本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="df48" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">SSG</h2><p id="fbf1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">React官网上用的技术是这样的，和SSR一样的是对应的服务器端也是直接把合并后的HTML文档返回给客户端，所以客户端还是不需要下载Javascript文件来渲染整个页面。有什么区别？</p><p id="9ba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用SSG技术构建网站时，每个页面都对应于项目构建包中的HTML文档。用户请求时，服务器不需要发送其他请求和二次组装，直接向客户端响应HTML文档即可。客户端和服务器的通信变得更加简单！</p><p id="c30e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是很容易发现它有几个致命的弱点。</p><ul class=""><li id="8a8e" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">由于项目打包时HTML文档已经生成，所有用户只能看到同一个页面，就像一个静态的网站，这就是这项技术的关键词——静态</li><li id="183a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">每次内容更改时都需要构建和部署应用程序，这使得它非常有限，不适合内容经常更改的网站。</li></ul><p id="b5e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是每种技术都有自己的场景。我们不能因为一项技术的缺点而否定它，也不能因为一项技术的优点而滥用它！该技术仍有一些应用场景。如果你想建立一个充满静态内容的网站，如个人博客、项目使用文档和其他Web应用程序，使用SSG再合适不过了。使用这项技术后，相信你一定能感受到这项技术的强大！</p><h2 id="1486" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">摘要</h2><p id="e09f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">无论使用哪种呈现方法，我们都从请求一个HTML文本开始，但区别在于该文本是否已经由服务器组装。</p><ul class=""><li id="1d42" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">客户端渲染还需要下载并执行额外的JavaScript脚本才能得到我们想要的页面效果，所以速度比服务器端渲染慢很多。</li><li id="3d0f" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">HTML文档的服务器端渲染已经组装了相应的文本，浏览器请求后可以直接解析渲染，不需要下载执行额外的JavaScript脚本，所以速度会比客户端渲染快很多。</li><li id="afba" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">对于一些内容变化不频繁的网站，我们甚至可以在服务器端渲染的基础上进行改进，将每次向服务器端请求渲染一个HTML文档变成总共只有一次渲染，这就是静态网站生成技术</li></ul></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="9867" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="no">欢迎关注我上</em></strong><a class="ae kv" href="https://twitter.com/yanghui0324" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="no">Twitter</em></strong></a><strong class="ky ir"><em class="no"/></strong><a class="ae kv" href="https://www.linkedin.com/in/hui-yang-075076245/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="no">LinkedIn</em></strong></a><strong class="ky ir"><em class="no">，以及</em></strong><a class="ae kv" href="https://github.com/guchen-yh" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="no">GitHub</em></strong><strong class="ky ir"><em class="no">！</em> </strong></a></p><p id="bb40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写作一直是我的激情所在，它给了我帮助和激励他人的快乐。如果您有任何问题，请随时联系我们！ </p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="58c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="no">说白了就是</em> </strong> </a> <em class="no">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="no">免费周报</em> </strong> </a> <em class="no">。关注我们关于</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="no">推特</em> </strong> </a>，<a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="no">LinkedIn</em></strong></a><em class="no">，</em><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="no">YouTube</em></strong></a><em class="no">，以及</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="no">不和</em> </strong></a></p></div></div>    
</body>
</html>