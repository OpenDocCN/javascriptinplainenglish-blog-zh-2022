<html>
<head>
<title>How to Fetch Data in JavaScript Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何像专业人士一样在JavaScript中获取数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-fetch-data-in-javascript-like-a-pro-6394d38ed255?source=collection_archive---------6-----------------------#2022-10-10">https://javascript.plainenglish.io/how-to-fetch-data-in-javascript-like-a-pro-6394d38ed255?source=collection_archive---------6-----------------------#2022-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a5f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你在摸索API吗？本教程将教你如何像专业人士一样使用fetch API获取JavaScript中的数据。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/638a30112df8b8a296adacd474f77338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDB0FCS5nQ9b5YSCO3oV9g.png"/></div></div></figure><p id="b1ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">fetch</code> API允许我们创建一个HTTP请求，这样我们就可以在JavaScript中完成很多事情——比如从API中检索数据，向服务器发送数据，或者甚至只是获取一个网页的全部内容。这个HTTP请求将从提供的URL中异步检索数据，并生成某种HTTP响应。让我们看看它是如何工作的。</p><p id="c300" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">fetch()</code>函数是一个全局函数，它最常用于与API交互。如果你是新手，你并不孤单——所以让我们来看看<code class="fe ln lo lp lq b">fetch()</code>是如何工作的。</p><h1 id="3a53" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">在JavaScript中使用fetch</h1><p id="0f76" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">fetch最基本的用法是接受一个参数——我们要获取的URL。由于<code class="fe ln lo lp lq b">fetch</code>生成HTTP请求，我们总是需要提供一个URL:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="d3a5" class="ms ls iq lq b gy mt mu l mv mw">let fetchExample = fetch("https://fjolt.com").then((res) =&gt; {<br/>    // Do something with res<br/>});</span></pre><p id="4feb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于获取的结果是异步的，我们可以使用<code class="fe ln lo lp lq b">then()</code>来捕捉响应，并对其进行处理。关于返回的<code class="fe ln lo lp lq b">res</code>或响应，很酷的一点是它有一堆内置方法，让我们可以立即解析从<code class="fe ln lo lp lq b">fetch</code>获得的内容:</p><ul class=""><li id="a17d" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">res.text()</code> -返回一个URL的文本内容。如果是一个网站，它返回HTML。</li><li id="67cf" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">res.json()</code> -返回格式化的JSON数据，如果存在的话。</li><li id="0d34" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">res.blob()</code> -返回blob数据，如果有的话。</li><li id="7240" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">res.arrayBuffer()</code> -返回arrayBuffer数据，如果有的话。</li><li id="98d3" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">res.formData()</code> -返回表单数据数据(如果有)。</li></ul><p id="c41c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于不同的URL产生不同类型的内容，上述方法允许我们以任何我们喜欢的方式解析内容。为了理解这一切是如何工作的，让我们看两个非常常见的例子。</p><h1 id="475b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">示例1:使用JavaScript fetch获取网站的HTML内容</h1><p id="2388" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">如上所述，<code class="fe ln lo lp lq b">res.text()</code>给了我们一个URL的文本内容——所以我们可以用它来获得一个URL的全部HTML内容。一旦我们使用<code class="fe ln lo lp lq b">res.text()</code>捕捉到我们的响应，我们就可以使用另一个<code class="fe ln lo lp lq b">then</code>捕捉响应，允许我们下载并返回所提供的URL的内容:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="8c7e" class="ms ls iq lq b gy mt mu l mv mw">let websiteData = fetch("https://fjolt.com").then(res =&gt; res.text()).then((data) =&gt; {<br/>    return data;<br/>}); <br/>// Now contains our website's HTML.</span></pre><p id="f776" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果链接不存在，或者发生错误，我们的<code class="fe ln lo lp lq b">response</code>对象将包含一个错误。例如，未找到的页面将返回<code class="fe ln lo lp lq b">404</code>，或者坏网关错误将返回<code class="fe ln lo lp lq b">502</code>。</p><h1 id="05a2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">示例2:通过JavaScript Fetch获取JSON</h1><p id="576b" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">如果一个URL的内容由JSON组成，我们可以使用<code class="fe ln lo lp lq b">res.json()</code>。例如，下面的代码将从URL返回一个JSON对象，假设URL发送回有效的JSON:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="5fb0" class="ms ls iq lq b gy mt mu l mv mw">let apiResponse = fetch("https://fjolt.com/api").then(res =&gt; res.json()).then((data) =&gt; {<br/>    return data;<br/>});<br/>// Now contains a JSON object - assuming one exists</span></pre><h1 id="31e7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">JavaScript提取选项</h1><p id="f791" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">理解fetch中可用的选项也很重要。它们跟在URL后面，作为一个对象—即<code class="fe ln lo lp lq b">fetch(URL, { options })</code>。如果您以前处理过HTTP请求，有些可能会很熟悉。下面显示的<code class="fe ln lo lp lq b">fetch</code>功能包含了您可以使用的所有可能选项:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="5442" class="ms ls iq lq b gy mt mu l mv mw">fetch("https://fjolt.com/", {<br/>    body: JSON.stringify({ someData: "value" })<br/>    method: 'POST'<br/>    mode: 'cors'<br/>    cache: 'no-cache'<br/>    credentials: 'same-origin'<br/>    headers: {<br/>      'Content-Type': 'application/json'<br/>    },<br/>    redirect: 'follow'<br/>    referrerPolicy: 'no-referrer'<br/>});</span></pre><p id="c2d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是对每一项含义的总结:</p><ul class=""><li id="fb50" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">body</code>包含正文的正文。在这个例子中，我们发送一些JSON，需要进行字符串化。</li><li id="1d6f" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">method</code>是一种标准的HTTP方法。可以是<code class="fe ln lo lp lq b">POST</code>/<code class="fe ln lo lp lq b">GET</code>/<code class="fe ln lo lp lq b">DELETE</code>/<code class="fe ln lo lp lq b">PUT</code>/<code class="fe ln lo lp lq b">CONNECT</code>/<code class="fe ln lo lp lq b">PATCH</code>/<code class="fe ln lo lp lq b">TRACE</code>/<code class="fe ln lo lp lq b">OPTIONS</code>。</li><li id="cb88" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">mode</code>表示是否接受跨来源请求。可以是<code class="fe ln lo lp lq b">cors</code> / <code class="fe ln lo lp lq b">no-cors</code> / <code class="fe ln lo lp lq b">same-origin</code>。</li><li id="acad" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">cache</code>指浏览器将如何与缓存交互。可以是<code class="fe ln lo lp lq b">default</code> / <code class="fe ln lo lp lq b">no-cache</code> / <code class="fe ln lo lp lq b">reload</code> / <code class="fe ln lo lp lq b">force-cache</code> / <code class="fe ln lo lp lq b">only-if-cached</code>。</li><li id="4b96" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">credentials</code>指跨来源cookies是否应随请求一起发送。可以是<code class="fe ln lo lp lq b">include</code> / <code class="fe ln lo lp lq b">same-origin</code> / <code class="fe ln lo lp lq b">omit</code>。</li><li id="35c1" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">headers</code>包含任何与请求相关的头。它可以包含任何HTTP头——例如，这里显示的是<code class="fe ln lo lp lq b">Content-Type</code>——但是也可以有自定义的HTTP头。</li><li id="acda" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">redirect</code>确定如果提取的URL重定向会发生什么。可以是<code class="fe ln lo lp lq b">follow</code> / <code class="fe ln lo lp lq b">error</code> / <code class="fe ln lo lp lq b">manual</code>。</li><li id="aee5" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe ln lo lp lq b">referrerPolicy</code>确定请求中传递了多少推荐信息。可以是<code class="fe ln lo lp lq b">no-referrer</code>/<code class="fe ln lo lp lq b">no-referrer-when-downgrade</code>/<code class="fe ln lo lp lq b">origin</code>/<code class="fe ln lo lp lq b">origin-when-cross-origin</code>/<code class="fe ln lo lp lq b">same-origin</code>/<code class="fe ln lo lp lq b">strict-origin</code>/<code class="fe ln lo lp lq b">strict-origin-when-cross-origin</code>/<code class="fe ln lo lp lq b">unsafe-url</code>。</li></ul><h1 id="231d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">记住，JavaScript获取是异步的</h1><p id="65a9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当我们使用fetch时，它会转到URL，收集信息，并向我们返回一个<code class="fe ln lo lp lq b">response</code>。这并不是立竿见影的，因为加载、下载和恢复URL需要时间。如果我们简单地单独运行fetch，紧随其后的控制台日志将只返回一个<code class="fe ln lo lp lq b">Promise</code>，而不是来自我们想要的URL的<code class="fe ln lo lp lq b">response</code>:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="1d17" class="ms ls iq lq b gy mt mu l mv mw">let apiResponse = fetch("https://fjolt.com/api");</span><span id="0b97" class="ms ls iq lq b gy nl mu l mv mw">console.log(apiResponse); // Returns Promise&lt;Pending&gt;</span></pre><p id="4ebb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">发生这种情况是因为<code class="fe ln lo lp lq b">fetch()</code>函数运行了，但是JavaScript没有等待<code class="fe ln lo lp lq b">response</code>。因此，如果我们想要访问<code class="fe ln lo lp lq b">response</code>，我们必须明确地告诉JavaScript等待它。</p><p id="f49c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">等待<code class="fe ln lo lp lq b">fetch()</code>有两种方式:</p><ul class=""><li id="35ef" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">我们可以使用<code class="fe ln lo lp lq b">then</code>，并在<code class="fe ln lo lp lq b">then()</code>中操纵<code class="fe ln lo lp lq b">fetch()</code>的响应。</li><li id="32b1" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">我们可以使用<code class="fe ln lo lp lq b">await</code>，并在使用其内容之前等待fetch返回。</li></ul><h1 id="66fe" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">使用then等待JavaScript中的提取</h1><p id="3128" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">Using <code class="fe ln lo lp lq b">then</code>经常用于捕捉和处理fetch的响应。可以在<code class="fe ln lo lp lq b">then()</code>回调函数内操作<code class="fe ln lo lp lq b">fetch()</code>的内容，但不能在函数外操作。例如:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="ecca" class="ms ls iq lq b gy mt mu l mv mw">let apiResponse = fetch("https://fjolt.com/api").then(res =&gt; res.json()).then((data) =&gt; {<br/>    console.log(data);<br/>    // We can do anything with the data from our api here. <br/>    return data;<br/>});</span><span id="51dd" class="ms ls iq lq b gy nl mu l mv mw">console.log(apiResponse); // This will return Promise&lt;Pending&gt;<br/>                          // That means we can't use the apiResponse variable<br/>                          // outside of the then() function.</span></pre><p id="ab76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想在<code class="fe ln lo lp lq b">then</code>之外使用<code class="fe ln lo lp lq b">fetch()</code>中的内容，我们必须使用<code class="fe ln lo lp lq b">await</code>。</p><h1 id="f8fd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">在JavaScript中使用await等待提取</h1><p id="ec31" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">另一种等待获取的方法是使用<code class="fe ln lo lp lq b">await</code>关键字。大多数现代浏览器支持<a class="ae nm" href="https://caniuse.com/?search=top%20level%20await" rel="noopener ugc nofollow" target="_blank">顶级等待</a>，但是如果你担心支持，还是使用Node的版本。在14.8之前的JS中，您会希望将任何<code class="fe ln lo lp lq b">await</code>代码包装在一个<code class="fe ln lo lp lq b">async function</code>中。</p><p id="e46f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们使用await，我们可以在函数或代码中的任何地方使用来自API的响应，并在其上使用任何<code class="fe ln lo lp lq b">response</code>函数，比如<code class="fe ln lo lp lq b">text()</code>或<code class="fe ln lo lp lq b">json()</code>。例如:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="ad6f" class="ms ls iq lq b gy mt mu l mv mw">// Typically we wrap await in an async function<br/>// But most modern browsers and Node.JS support<br/>// await statements outside of async functions now.<br/>async getAPI() {<br/>    let apiResponse = await fetch("https://fjolt.com/api");<br/>    let response = apiResponse.json();<br/>    // Since we waited for our API to respond using await<br/>    // The response variable will return the response from the API<br/>    // And not a promise.<br/>    console.log(response);<br/>}</span><span id="bc8d" class="ms ls iq lq b gy nl mu l mv mw">getAPI();</span></pre><p id="589b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想了解更多关于异步操作的知识，<a class="ae nm" href="https://fjolt.com/article/javascript-async" rel="noopener ugc nofollow" target="_blank">点击这里</a>阅读我们的异步JavaScript教程。</p><h1 id="c9bd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="b30c" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">在本指南中，我们已经了解了fetch的工作原理。我们已经展示了可以随<code class="fe ln lo lp lq b">fetch()</code>请求一起发送的不同选项，以及如何使用JavaScript中的异步概念等待响应。<code class="fe ln lo lp lq b">fetch()</code>是JavaScript中一个非常强大的工具，在大型产品中经常使用。我希望你喜欢这篇文章。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="5dd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nu">更多内容看</em> <a class="ae nm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">说白了。报名参加我们的</em> <a class="ae nm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">免费周报</em> </strong> </a> <em class="nu">。关注我们关于</em> <a class="ae nm" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">推特</em> </strong> </a>，<a class="ae nm" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">LinkedIn</em></strong></a><em class="nu">，</em><a class="ae nm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">YouTube</em></strong></a><em class="nu">，</em> <a class="ae nm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">不和</em> </strong> </a> <em class="nu">。对增长黑客感兴趣？检查</em> <a class="ae nm" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">电路</em> </strong> </a> <em class="nu">。</em></strong></a></p></div></div>    
</body>
</html>