<html>
<head>
<title>How to Build an SPA with React and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React和Node.js构建SPA</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-spa-with-react-and-node-cef18dccef17?source=collection_archive---------3-----------------------#2022-02-17">https://javascript.plainenglish.io/building-a-spa-with-react-and-node-cef18dccef17?source=collection_archive---------3-----------------------#2022-02-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2f34" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">为React项目运行一个节点服务器后端——用户界面和服务器之间不再有冲突</h2></div><p id="1197" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React无疑是一个非常棒的UI库，它让很多前端开发人员的生活变得更加轻松。但是尽管有很多好东西——hooks是我个人最喜欢的——很多人担心的事情之一是SEO。</p><p id="d774" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我继续之前，我只想说，我绝不是想把React扔到公共汽车下面，但是说实话，SEO确实是一个值得关注的问题。对吗？</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/1e875e661cdaca33fa34066679e65272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Md_txi0W968aP_Yt_Py3LA.png"/></div></div></figure><p id="5130" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Next.js的出现有很多原因，但解决SEO问题是一个重要原因。使用Next.js，我们可以将我们的前端移到服务器上，并在用户请求时将其作为渲染页面发送。另一方面，使用React，是客户端(浏览器)完成所有繁重的工作，并将生成的HTML注入到一个类似空白模板的HTML文档中。如果页面有大量图形或动画相关的内容，这可能是一个缓慢的过程。</p><h1 id="7262" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">另一种方式？</h1><p id="cbe3" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">现在，我是一个有反应的人。对Angular有经验，对Next.js有一点了解(我知道它是基于React的)，我仍然会选择React。不，我也不想使用任何模板引擎，如EJS或车把。我仍然要使用React构建我的UI，但是让我的Node/Express服务器为所有与API无关的路由提供一个HTML文件。</p><p id="895b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这与在节点应用程序中处理错误或不存在的路由非常相似，我们添加一个通配符路由来返回一些error.html页面；类似这样的-</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mh"><img src="../Images/83541903323a8411e33cda25ae4aed90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1DxbUkpSuK6z1E-QP9_Kg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">All requests to non-API related routes will be forwarded to index.html</figcaption></figure><h1 id="13c3" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">MERN·斯塔克！集合！</h1><p id="f2ff" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">我假设在将来的某个时候，或者从一开始，您将需要某种管理数据的方法，到时候您会选择MongoDB。<em class="mm">没有压力。</em>玩笑归玩笑，真实的对话……你可能已经在一个节点或React(或两者)项目上工作过很多次，但让我们一步一步来……</p><h2 id="53bf" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt lw kp mu mv ly kt mw mx ma my bi translated">目录结构</h2><p id="4889" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">通常，当使用<code class="fe mz na nb nc b">npx create-react-app</code>创建React应用程序时，git存储库会自动初始化。这是我们不需要的东西，因为我们的项目将(本质上)分为<code class="fe mz na nb nc b">client</code>和<code class="fe mz na nb nc b">server</code>代码，每个代码都在自己的文件夹中，这两个代码将存在于单个根文件夹中——这也将在git repo之外。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nd"><img src="../Images/a83ef01a0e892133c52f3a421be2e780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4aefldRIlGuaNZfo1o6Dg.png"/></div></div></figure><ol class=""><li id="6431" class="ne nf in ke b kf kg ki kj kl ng kp nh kt ni kx nj nk nl nm bi translated"><code class="fe mz na nb nc b">react-node-project</code>是我们的根文件夹，也是我们的单一git repo。</li><li id="021d" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated"><code class="fe mz na nb nc b">client</code>文件夹包含了我们所有与React相关的代码。假设除了删除git repo之外，您没有接触过它，那么这里有所有常见的东西— <code class="fe mz na nb nc b">index.js</code>、<code class="fe mz na nb nc b">App.js</code>等等。</li><li id="ac28" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated"><code class="fe mz na nb nc b">server</code>文件夹中有我们所有的服务器相关代码——所有的<code class="fe mz na nb nc b">routes</code>、<code class="fe mz na nb nc b">controllers</code>、<code class="fe mz na nb nc b">tests</code>和其他所有东西。你也可以看到一个<code class="fe mz na nb nc b">webpack.config.js</code>，那是因为这是我实际的项目目录，我使用webpack作为捆绑器。你也会需要它的。</li><li id="1b92" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated">如果您决定在您的节点服务器中使用环境变量，您将需要一个<code class="fe mz na nb nc b">.env</code>文件，它将与<code class="fe mz na nb nc b">package.json</code>、<code class="fe mz na nb nc b">package-lock.json</code>和<code class="fe mz na nb nc b">node_modules</code>一起位于项目的根目录下。</li></ol><p id="0a6a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完全有可能把你所有的东西都放在根目录的<code class="fe mz na nb nc b">server</code>文件夹中，而只有一个<code class="fe mz na nb nc b">client</code>文件夹，但是你不同意吗，这样看起来更干净，更容易维护？</p><h2 id="6036" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt lw kp mu mv ly kt mw mx ma my bi translated">它实际上将如何工作？</h2><p id="b83d" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">还记得几分钟前我们看到的为错误路线的error.html发球的例子吗？这正是我们要做的。相反，这一次，它将在每个与服务器无关的路线上为我们的React应用程序提供快速服务。想想看，如果<code class="fe mz na nb nc b">/home</code>不是已知的express，它应该返回一个错误页面，但相反，我们的主页在<code class="fe mz na nb nc b">/home</code>路线上提供服务。如果路线是<code class="fe mz na nb nc b">/api/home</code>，那么express可能会返回一些数据或执行一些操作。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ns"><img src="../Images/b552ef83724bd18f935808c5fd2016e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*py0ABAtllx9jmsMxOdH86g.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">A valid express route (on top) and the route that will handle requests to all non-existing routes (bottom)</figcaption></figure><p id="ced1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了让我们的UI在栏中有正确的URL，我们将为此使用<code class="fe mz na nb nc b">react-router</code>和<code class="fe mz na nb nc b">react-router-dom</code>。这样，尽管它仍然是一个水疗中心，我们会觉得我们实际上是在移动。需要记住的一点是，这只有在我们构建React应用程序(使用<code class="fe mz na nb nc b">npm run build</code>)时才有效——因为路线需要编译代码。</p><h2 id="419a" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt lw kp mu mv ly kt mw mx ma my bi translated"><code class="fe mz na nb nc b">package.json</code>中的最终检查</h2><p id="3ff4" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">假设您遵循相同或相似的目录结构，并且已经将一个简单的react应用程序(在客户端文件夹中)和node/express应用程序(在服务器文件夹中)放在一起，那么是时候调整我们的package.json文件了——大部分只是与服务器相关的。</p><p id="cbfc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Package.json非常有用，因为我们可以创建简单甚至复杂的脚本，并自动执行重复的任务。比方说，现在你的package.json (server)中的脚本部分是这样的——一个使用<code class="fe mz na nb nc b">nodemon</code>启动开发服务器的<code class="fe mz na nb nc b">dev</code>脚本。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nt"><img src="../Images/73d5e52aae86aead131dd0702b7d3464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUJ75KXY9TTIdXbjk3cOAQ.png"/></div></div></figure><p id="c10e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将添加一些脚本来处理-</p><ol class=""><li id="e4ac" class="ne nf in ke b kf kg ki kj kl ng kp nh kt ni kx nj nk nl nm bi translated">构建我们的服务器代码</li><li id="4950" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated">将构建文件夹从客户机移动到dist文件夹(我们的服务器代码的最终输出文件夹)</li><li id="0413" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated">创建一个类似生产的本地环境。</li></ol><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nu"><img src="../Images/b17b8a831f5306599cc8dfc6ab68cd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2ZAUo2Kyp0KaVh9cR6-ww.png"/></div></div></figure><ul class=""><li id="cede" class="ne nf in ke b kf kg ki kj kl ng kp nh kt ni kx nv nk nl nm bi translated"><code class="fe mz na nb nc b">build-server</code> —使用webpack构建服务器代码。</li><li id="1a50" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nv nk nl nm bi translated"><code class="fe mz na nb nc b">build-client</code> —为了构建客户端代码，我们需要首先将<code class="fe mz na nb nc b">cd</code>放入那个文件夹，然后运行<code class="fe mz na nb nc b">npm run build</code>，这样我们就可以使用<code class="fe mz na nb nc b">react-scripts</code>。</li><li id="2101" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nv nk nl nm bi translated"><code class="fe mz na nb nc b">build</code> —同时运行<code class="fe mz na nb nc b">build-server</code>和<code class="fe mz na nb nc b">build-client</code>。</li><li id="29d6" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nv nk nl nm bi translated"><code class="fe mz na nb nc b">pre-deploy</code> —将<code class="fe mz na nb nc b">build</code>文件夹从<code class="fe mz na nb nc b">client</code>移至<code class="fe mz na nb nc b">dist</code>文件夹。</li><li id="4bff" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nv nk nl nm bi translated"><code class="fe mz na nb nc b">local</code> —首先运行<code class="fe mz na nb nc b">pre-deploy</code>，然后使用以<code class="fe mz na nb nc b">main</code>开头的<code class="fe mz na nb nc b">dist</code>文件夹中的任意<code class="fe mz na nb nc b">.js</code>文件启动节点服务器。</li></ul><p id="f731" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在启动脚本之前，我们必须做的最后一个更改是在React项目的<code class="fe mz na nb nc b">package.json</code>中添加一个代理。这将使我们不必为每个api调用编写“<code class="fe mz na nb nc b">http://localhost:4000</code>”。相反，我们将能够只通过<code class="fe mz na nb nc b">/api/home</code>而逃脱。添加代理的另一大好处是，如果你决定将你的应用程序部署到Heroku，你所要做的就是将代理值改为Heroku的URL。你就一切就绪了。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nw"><img src="../Images/f15d929fdf6cfdfec683ae2b99b3f903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8_ENl8TFPKgJjQ8brbWvw.png"/></div></div></figure><h2 id="b90e" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt lw kp mu mv ly kt mw mx ma my bi translated">关键时刻到了</h2><p id="0e82" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">终于！是时候运行我们的脚本来构建和运行我们的应用程序了。我们只需要<code class="fe mz na nb nc b">npm run build &amp;&amp; npm run local</code>。您还可以创建另一个脚本来同时运行这两个脚本。而且，如果我们没有犯愚蠢的错误，我们的应用程序应该在端口4000上启动和运行(或者您自己的，如果您使用任何其他端口)。</p><blockquote class="nx ny nz"><p id="9cda" class="kc kd mm ke b kf kg jo kh ki kj jr kk oa km kn ko ob kq kr ks oc ku kv kw kx ig bi translated">注意:请记住…您总是需要在预部署之前进行构建。而且，如果您决定执行npm run local，您将需要更改' *' get请求的路径，以指向<strong class="ke io"> dist/build中的index.html。</strong></p></blockquote><p id="ad32" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读。</p><p id="4921" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章对你有用。</p><p id="7e12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请在评论中告诉我你使用哪个框架/库来构建前端和后端项目。</p><p id="7c9e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结束。</p><p id="0445" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mm">更多内容请看</em><a class="ae od" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mm">plain English . io</em></strong></a><em class="mm">。报名参加我们的</em> <a class="ae od" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mm">免费周报</em> </strong> </a> <em class="mm">。关注我们关于</em><a class="ae od" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mm">Twitter</em></strong></a><em class="mm">和</em><a class="ae od" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mm">LinkedIn</em></strong></a><em class="mm">。加入我们的</em> <a class="ae od" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mm">社区不和谐</em> </strong> </a> <em class="mm">。</em></p></div></div>    
</body>
</html>