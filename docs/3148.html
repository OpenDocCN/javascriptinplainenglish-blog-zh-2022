<html>
<head>
<title>React SPA with Path-Based Routing in AWS Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS云中使用基于路径的路由反应SPA</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-spa-with-path-based-routing-in-aws-cloud-2e5b0e4739b6?source=collection_archive---------6-----------------------#2022-08-04">https://javascript.plainenglish.io/react-spa-with-path-based-routing-in-aws-cloud-2e5b0e4739b6?source=collection_archive---------6-----------------------#2022-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4470dfa74b55f62ead9273aa97a2782b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmpgXeat7GEP8OpNJw9pig.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(1): architecture diagram</figcaption></figure><h2 id="14f9" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><span class="l kv kw kx bm ky kz la lb lc di"> I </span> ntro</h2><p id="52b5" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln ki lo lp lq km lr ls lt kq lu lv lw lx ig bi translated">作为一个组织，我们正在Node.js中编写新的应用程序和/或服务，Go，React，并在AWS云中部署它们。这意味着不再需要向遗留代码库添加代码，也不再需要为更新的开发/增强进行内部部署。因此，微服务和微前端的想法为我们提供了一种制定迁移计划和开发新的客户增强请求的方法。我们基于路径的路由探索就是这样开始的。</p><p id="9183" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">在这篇博文中，我将概述我们的架构，并分享一些挑战和我一路走来的收获。</p><h2 id="e078" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">动机</h2><p id="d496" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln ki lo lp lq km lr ls lt kq lu lv lw lx ig bi translated">经过仔细的客户请求筛选，我们决定构建一个独立的应用程序，允许用户浏览和搜索我们所有应用程序的内容。新的应用程序应该尊重现有的用户权限，应该允许用户在遗留应用程序之间导航，并且应该避免任何功能对等和延迟。</p><h2 id="76a3" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">功能要求</h2><ul class=""><li id="25eb" class="md me in lf b lg lh lk ll ki mf km mg kq mh lx mi mj mk ml bi translated">用户应该能够访问旧应用程序的新应用程序。</li><li id="b1bc" class="md me in lf b lg mm lk mn ki mo km mp kq mq lx mi mj mk ml bi translated">在新的应用程序中应该尊重用户的特权。</li><li id="bae2" class="md me in lf b lg mm lk mn ki mo km mp kq mq lx mi mj mk ml bi translated">用户应该无缝地浏览/搜索新应用程序中的任何数据</li></ul><h2 id="ade9" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">非功能需求</h2><ul class=""><li id="dc77" class="md me in lf b lg lh lk ll ki mf km mg kq mh lx mi mj mk ml bi translated">新的应用程序应该使用新的技术堆栈来构建</li><li id="ada9" class="md me in lf b lg mm lk mn ki mo km mp kq mq lx mi mj mk ml bi translated">新的应用程序应该部署在AWS云中</li><li id="d456" class="md me in lf b lg mm lk mn ki mo km mp kq mq lx mi mj mk ml bi translated">潜伏</li></ul><h2 id="162e" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">设计Node.js服务</h2><p id="4dd8" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln ki lo lp lq km lr ls lt kq lu lv lw lx ig bi translated">可以把它想象成一个中间人，来促进我们的新SPA、用于用户认证的登录服务、用于授权和内容的分级服务以及用于更多内容细节的元存储服务之间的通信。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/c6de44cd2d338ea734a3bfd5fda058aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QCr9D-H2mF9WGHLhmSJ1g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(2): microservice communication flow</figcaption></figure><h2 id="279d" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">设计基于路径的路由</h2><p id="4968" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln ki lo lp lq km lr ls lt kq lu lv lw lx ig bi translated">在本节中，我们将建立平地机应用程序与浏览应用程序之间的通信。然后，我们将研究如何在AWS云中实现这一点。我们的一些主要需求是提供应用程序之间的无缝转换，避免任何差异，并为未来的用例建立一个基本的微前端。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/e9fcb2bdd07524fce1b53688c1359497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zS6W9KQv3sGrdHj1ldLIyw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(3): communication between old and new app</figcaption></figure><p id="bd3c" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">正如我们所看到的，如果用户单击我们的遗留应用程序中的catalog选项卡，那么我们只会将用户重定向到AWS上托管的新应用程序。为了避免任何差异，我们为新的spa借用了相同的设计、布局和导航条。</p><h2 id="517d" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">设计决策一:域名</strong></h2><p id="6f08" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln ki lo lp lq km lr ls lt kq lu lv lw lx ig bi translated">我们的传统平地机应用程序有一个类似于https://grader.com<a class="ae mx" href="https://grader.com" rel="noopener ugc nofollow" target="_blank">的名字，并在本地托管。因此，我们不能在AWS云中选择相同的域名，但是，我们希望选择一个与现有域名相同的名称，并反映下一代的变化。因此，我们得到了一个类似于https://product-name-grader.com的域名。</a></p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/5f611c30d3c1f0208f6297607e070070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bs56duajXbV3K_1dVXzEKg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(4): domain names between apps</figcaption></figure><h2 id="cebd" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">设计决策二:应用名称</strong></h2><p id="5ebd" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln ki lo lp lq km lr ls lt kq lu lv lw lx ig bi translated">我们希望使用这个新域名来托管许多spa，因此我们的新应用程序将在“/catalogs”下提供服务。将来，我们希望在“/licensing”下添加licensing SPA，在“/coursework”下添加course work SPA等。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/ae72d33ddc6ed22d0406a449afbf8879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUp_6-WrUjSmUzRhhdbf0w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(5): new app domain name and possible spa’s</figcaption></figure><h2 id="f237" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">设计决策三:创建React应用构建</strong></h2><p id="2776" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln ki lo lp lq km lr ls lt kq lu lv lw lx ig bi translated">我们的SPA是使用<a class="ae mx" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> CRA </a>脚手架构建的，如果您运行“npm run build ”,它会以一种结构良好的方式生成一个包含javascript块、资产等的构建文件夹，所有这些都是从构建文件夹根目录下的“index.html”文件中引用的。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><blockquote class="nc nd ne"><p id="4a70" class="ld le nf lf b lg ly li lj lk lz lm ln ng ma lp lq nh mb ls lt ni mc lv lw lx ig bi translated"><strong class="lf io">注意</strong>:为了减少讨论中的噪音，我减少了CRA构建过程中的文件。</p></blockquote><p id="2381" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">“index.html”将在应用程序初始化时加载。暂时保留这个想法，因为它在配置我们的CloudFront和s3 bucket时起着至关重要的作用。</p><h2 id="b62c" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">设计决策四:部署</strong></h2><p id="2b50" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln ki lo lp lq km lr ls lt kq lu lv lw lx ig bi translated"><strong class="lf io">第一部分(概述):</strong></p><p id="5869" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">下面的架构概述显示了我们的代码部署到S3桶所需的所有组件。我们公司的构建过程与maven紧密相关，但是在您的案例中可能不需要。简而言之，maven插件帮助我们进行代码健全，并构建构建文件，然后由TeamCity作业将该文件复制到S3桶中。</p><blockquote class="nc nd ne"><p id="dbd1" class="ld le nf lf b lg ly li lj lk lz lm ln ng ma lp lq nh mb ls lt ni mc lv lw lx ig bi translated"><strong class="lf io">注意</strong>:可以跳过maven，使用npm来构建文件。然后手动将构建文件复制到没有TeamCity的S3存储桶中。</p></blockquote><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/82edc630dafcd5c92211c847a2df35ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nu-ZUkdBao_nus5QQ6pQ_A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(5): AWS CloudFront and S3 deployment</figcaption></figure><p id="60cf" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">我们的S3位于云锋之后，云锋充当面向前方(用户)的入口点。对CloudFront的任何更新，如版本变化等。将使用云形成来完成。</p><p id="36d1" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">用户可以通过从传统评分应用程序导航和/或直接访问SPA来访问SPA。所有的SPA请求都将由CloudFront处理，然后从S3桶中加载适当的文件(毕竟S3就像一个文件夹)。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/e928623dc645f4c0d537401888e8d5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLcACZ1YHjQIsokABcsaMw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(6): AWS CloudFront and S3</figcaption></figure><p id="5d0d" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">如果你回头看一下<strong class="lf io">第三部分:创建React应用构建</strong>，我们的构建文件夹有一个index.html文件，每当用户访问<a class="ae mx" href="https://product-name-grader.com" rel="noopener ugc nofollow" target="_blank">https://product-name-grader.com</a>(即与访问<a class="ae mx" href="https://product-name-grader.com/index.html" rel="noopener ugc nofollow" target="_blank">https://product-name-grader.com/index.html</a>相同)时，该文件就会被CloudFront加载。但是，我们希望我们的URL路径能够反映预期的SPA，即目录。</p><p id="1b12" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">我们<em class="nf">重命名</em>这个‘index . html’文件来编目(没有。html)所以它将作为一个对象被加载，加载SPA的URL将是<a class="ae mx" href="https://product-name-grader.com/catalog" rel="noopener ugc nofollow" target="_blank">https://product-name-grader.com/catalog</a></p><blockquote class="nc nd ne"><p id="2c23" class="ld le nf lf b lg ly li lj lk lz lm ln ng ma lp lq nh mb ls lt ni mc lv lw lx ig bi translated"><strong class="lf io">注意</strong>:如果你尝试给目录添加一个. html扩展名，那么每当用户试图访问https://product-name-grader.com/catalog.html的时候，它就会把catalog.html文件下载到你的机器上，因为它只不过是一个存储在桶/文件夹中的文件。</p></blockquote><p id="5f3a" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">第二部分(构建和后期构建):</strong></p><p id="f40e" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">通过添加构建后脚本，我们可以在“npm运行构建”步骤中重命名和/或移动文件。请在此阅读更多关于此<a class="ae mx" href="https://docs.npmjs.com/cli/v8/using-npm/scripts" rel="noopener ugc nofollow" target="_blank">的内容。下面是我们需要在package.json中进行的更改，然后在项目根目录中添加一个后期构建脚本。</a></p><blockquote class="nc nd ne"><p id="3534" class="ld le nf lf b lg ly li lj lk lz lm ln ng ma lp lq nh mb ls lt ni mc lv lw lx ig bi translated"><strong class="lf io">学习技巧</strong>:我们将了解npm项目中构建后脚本的好处。</p></blockquote><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c80e" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">到此结束时，我们将有一个更新的构建文件夹，其中index.html被重命名为catalog.html，然后一个新的子文件夹目录将托管构建的静态内容。下面是后期生成过程文件/文件夹的概述。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="81a3" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">下面是带有构建后更改的<a class="ae mx" href="https://github.com/citta-lab/medium/tree/475cc9bcd43d0811dca03f762e66099b54c4d67b/catalog" rel="noopener ugc nofollow" target="_blank">提交</a>。</p><p id="c83d" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">第三部分(成功抵达S3): </strong></p><p id="3f75" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">正如我在前面几节中提到的，我们有一个maven进程来运行构建脚本，并将其压缩到主页名称下(在package.json中提到)和pom版本下。然后，team city作业会将构建文件夹结构复制到artifactory (JFrog ),下一个team city作业会从artifactory获取最新的构建，并将其放在S3存储桶名称下(即catalogs-name-us-east-1 ),并将catalog.html文件重命名为catalog(使其成为对象而不是HTML页面)。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/6bd81327530b4286c4f76f84ee5d3439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_S9z7ihya8UyPEurf4A_A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(7): code to S3</figcaption></figure><p id="5d6d" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">重要提示:</strong>但是，您可以跳过所有这些自动化过程，手动构建代码，然后将内容复制到S3存储桶。</p><blockquote class="nc nd ne"><p id="46fc" class="ld le nf lf b lg ly li lj lk lz lm ln ng ma lp lq nh mb ls lt ni mc lv lw lx ig bi translated"><strong class="lf io">手动更新(亚马逊S3): </strong> <br/>【选择】catalogs.html&gt;动作&gt;重命名对象&gt;目录&gt;保存更改。<br/>【选择】catalogs.html&gt;动作&gt;编辑元数据&gt;值【text/html】&gt;保存修改。</p></blockquote><p id="3bda" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">下面是亚马逊S3控制台，以及我们完成上述过程(自动或手动)后文件应该是什么样子。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/d382151b2a55ea756ded6801f537fa15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58OjTSlQfDp5ivJrQBu0tA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(8): AWS S3 console with our build code</figcaption></figure><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/d76e58d2c18e6c599dde0db2c8c1fc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOpsPYhefY1A_k9pETUn8w.png"/></div></div></figure><p id="4381" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">第四部分(云锋):</strong></p><p id="ec88" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">在这一节中，我们将关注用户请求如何从CloudFront到达S3桶，以及实现这一点所需的CloudFront配置。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/15615c27d8ba22cce5612ebc73fb7564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6LYwrSzvywH0xrgJbB0nw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(9): CloudFront to S3 bucket</figcaption></figure><p id="072e" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">发行起点:</strong></p><p id="7a4e" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">下面我们有两个原点名称，一个用于我们的节点服务，一个用于我们的S3存储桶。有了节点服务并定义了行为，我们就可以将流量从我们的SPA路由到我们的节点服务，而无需定义完整的API URL。</p><p id="e5f8" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">示例:</strong>通常，当我们在SPA中提取API调用时，我们会提到一个API的完整URL，类似于<a class="ae mx" href="https://service-name.company.com/catalogs/v1/admin/healthcheck" rel="noopener ugc nofollow" target="_blank">https://service-name . company . com/catalogs/v1/admin/healthcheck</a>，但是通过结合路径模式、优先级和源域，我们可以简单地在定义的路径上调用fetch方法，如“catalogs/v1/admin/health check”。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/e8cd6c18f39b19d2d26a1760d7263e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpEs5e_OKJ9FXpStvBXCOw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(10): Origins details in CloudFront</figcaption></figure><p id="b28f" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">分布行为:</strong></p><p id="a77b" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">基于优先级匹配路径模式，然后将各个请求定向到它们各自的起点。在我们的例子中，首先匹配节点服务路径(优先级0，1)，然后我们匹配S3桶。如果这些路径模式中的任何一个不匹配，默认情况下路由到S3(因此默认设置为*)。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/d0dc79989e4bb60244b7c28474a8f3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01nwaXi49eUUM-A0joyk7Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(11): Behaviour to route the requests</figcaption></figure><p id="e27a" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">分配错误页面:</strong></p><p id="d464" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">在本节中，如果由于某种原因我们无法进行路径模式匹配，我们将把请求恢复到我们的S3存储桶。</p><p id="02d3" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">示例:</strong>当我们用自定义路径(如catalogs/1234)更新URL时，这特别有用，但是我们的S3桶没有名为catalogs/1234的对象，所以它会出错(如403)。因此，我们将请求路由回catalogs对象(从catalogs.html重命名为catalog对象),这将触发react-router逻辑来查找适当的页面。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/ea4c5254d75f690a4d0277b382e8a76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrzzhklUQ7GPrbyRSAZRIg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(13): fallback to S3 root directory (i.e catalogs)</figcaption></figure><p id="5d22" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated">到目前为止，我们应该已经构建好了我们的SPA并部署到AWS云。</p><p id="6bca" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><strong class="lf io">我之前的三篇博客:</strong> <br/> 1。<a class="ae mx" rel="noopener ugc nofollow" target="_blank" href="/react-search-component-design-6b0e618dbf5f"> React:搜索组件设计</a> <br/> 2。<a class="ae mx" href="https://citta-lab.medium.com/react-node-why-should-we-care-about-dependencies-a8d3e904689b" rel="noopener"> React | Node:为什么要关心依赖关系？</a> <br/> 3。<a class="ae mx" href="https://citta-lab.medium.com/diy-how-to-fix-your-hvac-zone-damper-4a7a5b21d3be" rel="noopener"> DIY:如何修理你的HVAC区域风门</a></p><p id="0c12" class="pw-post-body-paragraph ld le in lf b lg ly li lj lk lz lm ln ki ma lp lq km mb ls lt kq mc lv lw lx ig bi translated"><em class="nf">更多内容请看</em><a class="ae mx" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lf io"><em class="nf">plain English . io</em></strong></a><em class="nf">。报名参加我们的</em> <a class="ae mx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf io"> <em class="nf">免费周报</em> </strong> </a> <em class="nf">。关注我们关于</em> <a class="ae mx" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lf io"> <em class="nf">推特</em></strong></a><a class="ae mx" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lf io"><em class="nf">领英</em></strong></a><strong class="lf io"><em class="nf"/></strong><em class="nf">和</em> <a class="ae mx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lf io"> <em class="nf">不和</em> </strong> </a> <strong class="lf io"> <em class="nf">。</em>T45】</strong></p></div></div>    
</body>
</html>