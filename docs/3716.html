<html>
<head>
<title>Do You Really Know “this” in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你真的知道JavaScript中的“这个”吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/do-you-really-know-this-in-javascript-cbdd80b79442?source=collection_archive---------1-----------------------#2022-09-20">https://javascript.plainenglish.io/do-you-really-know-this-in-javascript-cbdd80b79442?source=collection_archive---------1-----------------------#2022-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/51e7a96f89565a82f1f816c5935579f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jZk7ANxDsPBsF9OV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@castillcc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cristian Castillo</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0ea0" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="66f1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在前端面试过程中，面试官经常会问到关于<code class="fe lz ma mb mc b">this</code>这个关键词的问题，即使是工作多年的人可能也只是一知半解。因此，本文对<code class="fe lz ma mb mc b">this</code>关键词进行了详细的分析，以便他人能够深入理解。</p><h1 id="6966" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">地图轮廓</h1><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/34ed13ecb12e12a846d630df6abbe995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYESfXNz0I-sCWCnqELneQ.png"/></div></div></figure><h1 id="bf61" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><code class="fe lz ma mb mc b">this</code>是什么？</h1><p id="e7e5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当一个函数被调用时，一个执行环境将被创建。<code class="fe lz ma mb mc b">this</code>在运行时根据函数的执行环境进行绑定。它允许函数在内部引用上下文中的执行变量，使得函数编程更加优雅和简洁。</p><p id="83fb" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">看看下面的代码，想想为什么不同的调用方法会打印出不同的结果。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="534e" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">其实很简单，因为不同调用方法的<code class="fe lz ma mb mc b">this</code>指向不同的点。为什么这指向不同的函数调用方法？这是由什么决定的？现在我们带着问题开始深入了解<code class="fe lz ma mb mc b">this</code>问题吧！</p><h1 id="80b8" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">“这个”的约束规则</h1><h2 id="40d1" class="mp ke iq bd kf mq mr dn kj ms mt dp kn lm mu mv kr lq mw mx kv lu my mz kz na bi translated">默认绑定</h2><p id="0052" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在默认绑定规则下，函数的运行环境是全局环境，<code class="fe lz ma mb mc b">this</code>默认指向<code class="fe lz ma mb mc b">Window</code>。</p><p id="ac66" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">默认绑定规则如下:</p><ol class=""><li id="9f0d" class="nb nc iq ld b le mi li mj lm nd lq ne lu nf ly ng nh ni nj bi translated"><strong class="ld ir">全局功能</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">this</strong></code> <strong class="ld ir">指向</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">Window</strong></code></li></ol><p id="792e" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在全局函数中直接打印<code class="fe lz ma mb mc b">this</code>时，可以看到<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/00e8d3158cd8402f9dc61b301403d7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVUzK_G7lI3E9DjOpTa4QQ.png"/></div></div></figure><p id="5437" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><strong class="ld ir"> 2。独立函数调用</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">this</strong></code> <strong class="ld ir">指向</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">Window</strong></code></p><p id="02ff" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">独立函数调用，即直接调用函数，比如<code class="fe lz ma mb mc b">foo()</code>。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6838" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">这里的<code class="fe lz ma mb mc b">foo</code>默认链接<code class="fe lz ma mb mc b">Window</code>，相当于<code class="fe lz ma mb mc b">window.foo()</code>。根据函数的隐式绑定规则，谁调用就指向谁。<code class="fe lz ma mb mc b">this</code>这里指的是<code class="fe lz ma mb mc b">Window</code>。结果如下:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/7886040379f7cc4ea90efe816cea8484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-0yZyhM3DHvvxmiNjeq7w.png"/></div></div></figure><p id="2457" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">同样，如果嵌套函数中直接调用的函数也是独立函数调用，那么<code class="fe lz ma mb mc b">this</code>也指向<code class="fe lz ma mb mc b">Window</code>:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6037" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在上面的代码中，子函数<code class="fe lz ma mb mc b">son</code>也嵌套在对象<code class="fe lz ma mb mc b">obj</code>的方法<code class="fe lz ma mb mc b">foo</code>中。当直接调用<code class="fe lz ma mb mc b">son</code>方法时，<code class="fe lz ma mb mc b">son</code>里面的<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>，那么<code class="fe lz ma mb mc b">son</code>里面的<code class="fe lz ma mb mc b">this.a</code>结果就是全局变量<code class="fe lz ma mb mc b">a</code>，也就是10。</p><p id="3637" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">如果要在<code class="fe lz ma mb mc b">son</code>函数中使用<code class="fe lz ma mb mc b">obj</code>中的变量<code class="fe lz ma mb mc b">a</code>怎么办？只需将<code class="fe lz ma mb mc b">this</code>对象赋给另一个变量<code class="fe lz ma mb mc b">that</code>，并在<code class="fe lz ma mb mc b">son</code>方法中引用该变量:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="424e" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><strong class="ld ir"> 3。对于自执行函数调用，</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">this</strong></code> <strong class="ld ir">指向</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">window</strong></code></p><p id="5e23" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">自执行函数，顾名思义，就是在函数定义后自动调用的函数。自执行功能的<code class="fe lz ma mb mc b">this</code>指向如下代码:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9d54" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">上面代码中的<code class="fe lz ma mb mc b">foo</code>函数内部嵌套了一个自执行函数<code class="fe lz ma mb mc b">son</code>，<code class="fe lz ma mb mc b">son</code>内部的<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>。这里，<code class="fe lz ma mb mc b">this</code>指向的原理类似于独立函数调用，即先声明一个<code class="fe lz ma mb mc b">son</code>方法，然后通过<code class="fe lz ma mb mc b">son()</code>执行函数。如果想获取<code class="fe lz ma mb mc b">son</code>中上层对象<code class="fe lz ma mb mc b">obj</code>的变量，可以在调用时将<code class="fe lz ma mb mc b">this</code>点作为参数传递给自执行函数<code class="fe lz ma mb mc b">son </code>。</p><p id="845c" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><strong class="ld ir"> 4。闭包内的</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">this</strong></code> <strong class="ld ir">指向</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">Window</strong></code></p><p id="43e8" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">闭包可以理解为一个函数内部定义的函数，它可以访问其他函数的内部变量。当我们查看闭包中的<code class="fe lz ma mb mc b">this</code>点时，我们可以看到<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="97ab" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在上面的代码中，<code class="fe lz ma mb mc b">foo</code>函数的第一个<code class="fe lz ma mb mc b">this.a</code>的<code class="fe lz ma mb mc b">this</code>指向了<code class="fe lz ma mb mc b">obj</code>对象，所以结果是20。返回函数调用的<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>，结果为10。<code class="fe lz ma mb mc b">obj.foo()()</code>可以理解为:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c2ba" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><code class="fe lz ma mb mc b">fn</code>是<code class="fe lz ma mb mc b">obj.foo()</code>返回的函数。函数的<code class="fe lz ma mb mc b">fn</code>被独立调用，<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>。</p><h2 id="da71" class="mp ke iq bd kf mq mr dn kj ms mt dp kn lm mu mv kr lq mw mx kv lu my mz kz na bi translated">隐式结合</h2><p id="704f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当一个函数作为方法调用时，<code class="fe lz ma mb mc b">this</code>指向该函数的直接父对象，称为隐式绑定。</p><p id="a338" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在隐式绑定规则中，认为<code class="fe lz ma mb mc b">this</code>指向调用函数的人，并且将指向函数的直接父对象。比如<code class="fe lz ma mb mc b">obj.foo()</code>中<code class="fe lz ma mb mc b">foo</code>函数内部的<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">obj</code>，而obj1中的<code class="fe lz ma mb mc b">foo</code>函数。<code class="fe lz ma mb mc b">obj2.foo()</code>指向<code class="fe lz ma mb mc b">obj2</code>。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3262" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">上面的代码也是对<code class="fe lz ma mb mc b">foo</code>函数的调用。调用方法不同，结果也不同。</p><p id="8307" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">‘exp1’中的<code class="fe lz ma mb mc b">foo</code>被独立函数直接调用，所以<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>，结果是10；‘exp2’中的调用方法是<code class="fe lz ma mb mc b">obj. Foo()</code>,<code class="fe lz ma mb mc b">foo</code>函数的<code class="fe lz ma mb mc b">this</code>指向上级调用对象<code class="fe lz ma mb mc b">obj</code>；结果是20。' exp3 '中<code class="fe lz ma mb mc b">foo</code>函数的直接上级对象是<code class="fe lz ma mb mc b">obj2</code>，所以结果是30。</p><p id="2b57" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><strong class="ld ir">隐式绑定丢失</strong></p><p id="a300" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">隐式绑定丢失是指隐式绑定的函数丢失了绑定对象，所以默认绑定到<code class="fe lz ma mb mc b">Window</code>。这种方法很容易在我们的项目中造成错误，但也很常见。</p><ol class=""><li id="d54f" class="nb nc iq ld b le mi li mj lm nd lq ne lu nf ly ng nh ni nj bi translated"><strong class="ld ir">隐式绑定的函数被赋值为变量，没有</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">this</strong></code> <strong class="ld ir">指向。</strong></li></ol><p id="59ab" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在下面的代码中，<code class="fe lz ma mb mc b">obj</code>下的<code class="fe lz ma mb mc b">foo</code>值实际上是<code class="fe lz ma mb mc b">foo</code>函数的地址信息，而不是真正的<code class="fe lz ma mb mc b">foo</code>函数。调用<code class="fe lz ma mb mc b">obj. foo()</code>时，<code class="fe lz ma mb mc b">this</code>的<code class="fe lz ma mb mc b">this</code>被隐式绑定到<code class="fe lz ma mb mc b">obj</code>。当<code class="fe lz ma mb mc b">var fn=obj.foo</code>向<code class="fe lz ma mb mc b">fn</code>分配功能时。相当于把<code class="fe lz ma mb mc b">foo</code>函数的地址分配给<code class="fe lz ma mb mc b">fn</code>。此时<code class="fe lz ma mb mc b">fn</code>与<code class="fe lz ma mb mc b">obj</code>没有关联，所以这里是<code class="fe lz ma mb mc b">fn()</code>的运行环境是全局环境，<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>，<code class="fe lz ma mb mc b">this. a</code>的结果是10。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6843" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">2.<strong class="ld ir">隐式绑定的函数作为参数传递给函数，</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">this</strong></code> <strong class="ld ir">点丢失。</strong></p><p id="5d16" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">当一个隐式绑定的函数作为参数直接传递给另一个函数时，<code class="fe lz ma mb mc b">this</code>绑定会丢失，从而指向全局<code class="fe lz ma mb mc b">Window</code>。如下图，<code class="fe lz ma mb mc b">obj.foo</code>作为参数传递给bar函数后，<code class="fe lz ma mb mc b">this.a</code>的结果是10。在这里，<code class="fe lz ma mb mc b">bar(obj.foo)</code>相当于<code class="fe lz ma mb mc b">var fn=obj.foo; bar(fn)</code>。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="32bf" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><strong class="ld ir"> 3。内置对象</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">setTimeout</strong></code> <strong class="ld ir">和</strong> <code class="fe lz ma mb mc b"><strong class="ld ir">setInterval</strong></code> <strong class="ld ir">中函数的隐式绑定丢失</strong></p><p id="eb64" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">内置函数<code class="fe lz ma mb mc b">setTimeout</code>和<code class="fe lz ma mb mc b">setInterval</code>的<code class="fe lz ma mb mc b">this</code>默认指向<code class="fe lz ma mb mc b">Window</code>。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="fc15" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">顺便说一下，当<code class="fe lz ma mb mc b">setTimeout</code>或<code class="fe lz ma mb mc b">setInterval</code>的第一个参数是箭头函数时，<code class="fe lz ma mb mc b">this</code>会指向上层的函数执行环境。代码如下:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="d883" class="mp ke iq bd kf mq mr dn kj ms mt dp kn lm mu mv kr lq mw mx kv lu my mz kz na bi translated">显式绑定</h2><p id="27d9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们要将函数绑定到指定对象时，可以使用<code class="fe lz ma mb mc b">call</code>、<code class="fe lz ma mb mc b">apply</code>、<code class="fe lz ma mb mc b">bind</code>等方法手动改变<code class="fe lz ma mb mc b">this</code>方向，即显式绑定。</p><p id="1206" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在下面的代码中，分别使用<code class="fe lz ma mb mc b">call</code>、apply和<code class="fe lz ma mb mc b">bind</code>举例说明了将<code class="fe lz ma mb mc b">foo</code>显式绑定到<code class="fe lz ma mb mc b">p</code>对象的方法。显式绑定<code class="fe lz ma mb mc b">call</code>和<code class="fe lz ma mb mc b">apply</code>的方法会在显式绑定后直接调用，而显式绑定<code class="fe lz ma mb mc b">this</code>到<code class="fe lz ma mb mc b">bind</code>的方法需要手动调用。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c85b" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><strong class="ld ir">关于硬装订</strong></p><p id="6d18" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">显式绑定可以帮助我们将<code class="fe lz ma mb mc b">this</code>改为指定的对象，但是无法解决隐式绑定缺失的问题，比如:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="be36" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">上面的代码中，<code class="fe lz ma mb mc b">call</code>用于绑定<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">p</code>对象，但最后<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">Window</code>。此时，我们可以通过硬绑定来解决这个问题。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="27c9" class="mp ke iq bd kf mq mr dn kj ms mt dp kn lm mu mv kr lq mw mx kv lu my mz kz na bi translated">“新”绑定</h2><p id="6f38" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe lz ma mb mc b">new</code>捆绑是我们常用的方法。事实上，我们可以创建一个构造，然后<code class="fe lz ma mb mc b">new</code>一个实例对象。此时，<code class="fe lz ma mb mc b">this</code>指向了从<code class="fe lz ma mb mc b">new</code>出来的实例对象。</p><p id="eb12" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">当我们认识对方时，我们主要做以下事情:</p><p id="7d46" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">a.创建新对象</p><p id="e889" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">b.让这个点指向新的对象并执行构造的主体</p><p id="4556" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">c.设置新对象的<code class="fe lz ma mb mc b">proto</code>属性指向构造的原型对象</p><p id="0f40" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">d.判断构造的返回类型。如果是，则返回新对象。如果它是引用类型，它将返回该类型的对象。</p><p id="8ff3" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">首先创建了“人”的构造，然后通过“新建”创建了“张三”的一个实例对象。在“张三”的“foo”函数中，“this”指向了“张三”的实例。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="d8a7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在严格模式下，“这”指出了一个问题</h1><h2 id="5962" class="mp ke iq bd kf mq mr dn kj ms mt dp kn lm mu mv kr lq mw mx kv lu my mz kz na bi translated">1.独立调用函数的内部“this”是“未定义的”</h2><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="dfe4" class="mp ke iq bd kf mq mr dn kj ms mt dp kn lm mu mv kr lq mw mx kv lu my mz kz na bi translated">2.“call()”和“apply()”中的this总是他们的第一个参数</h2><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="4f7a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><p id="9d03" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe lz ma mb mc b">this</code>是一个相对复杂的知识点。当然，如果我们真的理解了<code class="fe lz ma mb mc b">this</code>的原理，那么遇到<code class="fe lz ma mb mc b">this</code>指出的问题就很简单了。如果我们理解了<code class="fe lz ma mb mc b">this</code>，这不仅是前端面试的加分项，也有利于我们的发展和学习。</p><p id="5dd4" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">我们总结一下。<code class="fe lz ma mb mc b">this</code>的约束原则如下:</p><ol class=""><li id="b693" class="nb nc iq ld b le mi li mj lm nd lq ne lu nf ly ng nh ni nj bi translated">默认绑定，<code class="fe lz ma mb mc b">this</code>指向全局<code class="fe lz ma mb mc b">Window</code>。</li><li id="1ff1" class="nb nc iq ld b le nm li nn lm no lq np lu nq ly ng nh ni nj bi translated">叫<code class="fe lz ma mb mc b">this</code>的会指着他。不要忘记隐藏绑定的丢失。</li><li id="d000" class="nb nc iq ld b le nm li nn lm no lq np lu nq ly ng nh ni nj bi translated">它显示了约束。他用<code class="fe lz ma mb mc b">call</code>、<code class="fe lz ma mb mc b">apply</code>、<code class="fe lz ma mb mc b">bind</code>改变了这个方向。</li><li id="c9f4" class="nb nc iq ld b le nm li nn lm no lq np lu nq ly ng nh ni nj bi translated"><code class="fe lz ma mb mc b">new</code>绑定，构造<code class="fe lz ma mb mc b">new</code>的实例，<code class="fe lz ma mb mc b">this</code>指向<code class="fe lz ma mb mc b">new</code>的实例对象。</li></ol><p id="6ed7" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">最后，如果文章有什么错误或者需要改正的地方，可以在评论区留下评论。</p><p id="86a4" class="pw-post-body-paragraph lb lc iq ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><em class="nr">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="nr">plain English . io</em></strong></a><em class="nr">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir"> <em class="nr">免费周报</em> </strong> </a> <em class="nr">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="nr">Twitter</em></strong></a><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="nr">LinkedIn</em></strong></a><strong class="ld ir"><em class="nr"/></strong><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="nr">YouTube</em></strong></a><strong class="ld ir"><em class="nr">，以及</em></strong><em class="nr"/><a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="nr">不和</em> </strong> </a>  <em class="nr">对成长黑客感兴趣？检查</em> <a class="ae kc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir"> <em class="nr">电路</em> </strong> </a> <strong class="ld ir"> <em class="nr">。</em> </strong></p></div></div>    
</body>
</html>