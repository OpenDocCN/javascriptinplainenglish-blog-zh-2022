<html>
<head>
<title>Speed Up Delightful Jest Tests Execution with GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GitHub动作加速愉快的Jest测试执行</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/speed-up-delightful-jest-tests-execution-with-github-actions-2572f823d113?source=collection_archive---------3-----------------------#2022-05-19">https://javascript.plainenglish.io/speed-up-delightful-jest-tests-execution-with-github-actions-2572f823d113?source=collection_archive---------3-----------------------#2022-05-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f18fe00c372608000d4efabcb631be20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9lW27Ik7E_tbzrdY"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image from <a class="ae jz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">unsplash.com</a></figcaption></figure><blockquote class="ka kb kc"><p id="b1ec" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">人们喜欢编写测试，编写大量的测试，为编写越来越多的测试创建像TDD/BDD这样的方法，甚至在实现之前。目标是有尽可能多的测试，以保护你的代码不被破坏并提高质量。</p></blockquote><p id="8487" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">但是每天都有“如何在流水线中更快地执行它们”的问题变得越来越尖锐。当你在执行所有测试之前等待10分钟来合并你的拉请求并开始下一个任务或去你甜蜜的家时，这真是令人讨厌。这里的问题不仅仅是团队成员的福祉。它增加了与修复/解决应用程序问题相关的MTTR和其他指标。您的SLA/SLO可能会因为慢节奏的管道而被违反。</p><p id="d913" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">无论如何，管道应该和法拉利一样快。让我们看看如何在GitHub Actions工作流中更快地执行Jest测试。</p><h2 id="052b" class="lf lg in bd lh li lj dn lk ll lm dp ln lc lo lp lq ld lr ls lt le lu lv lw lx bi translated">1.我们就不能增加设施吗？</h2><p id="9ced" class="pw-post-body-paragraph kd ke in kg b kh ly kj kk kl lz kn ko lc ma kr ks ld mb kv kw le mc kz la lb ig bi translated">默认情况下，GitHub Action runner有一个2核CPU，很可能，想到的第一个选项是使用<a class="ae jz" href="https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners" rel="noopener ugc nofollow" target="_blank">自托管runners </a>。但这增加了一些复杂性，我们应该由<strong class="kg io">负责更新和维护操作系统更新，配置和支付云</strong>等等。当然，这不是最简单的方法，但这是一种选择。</p><p id="8a26" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">为了清楚起见，让我们更深入地研究Jest CLI以及它如何有助于实现我们的目标。</p><h2 id="10a5" class="lf lg in bd lh li lj dn lk ll lm dp ln lc lo lp lq ld lr ls lt le lu lv lw lx bi translated">2.是否应该立即执行所有测试？</h2><p id="7be0" class="pw-post-body-paragraph kd ke in kg b kh ly kj kk kl lz kn ko lc ma kr ks ld mb kv kw le mc kz la lb ig bi translated">策略是只运行在提交之后添加的测试。逻辑很简单:<strong class="kg io">如果之前所有的测试都运行执行成功，全新的测试也成功，看起来应该没什么问题</strong>。</p><p id="02e2" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">根据Jest CLI 的<a class="ae jz" href="https://jestjs.io/docs/cli" rel="noopener ugc nofollow" target="_blank">官方文档，有可能通过</a><a class="ae jz" href="https://jestjs.io/docs/cli#--changedsince" rel="noopener ugc nofollow" target="_blank">–changed-since</a>&lt;commit _ hash&gt;，然后Jest运行与提供的分支或提交hash之后的更改相关的测试。如果当前分支已经从给定分支偏离，那么只测试本地做出的改变。</p><p id="a687" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">您的“package.json”应该是这样的:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/f86b36fa14e4d216dda3ed90f3fb4dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UZZSnn9CPGElVBQg"/></div></div></figure><p id="7348" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在您的工作流中，运行命令:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/0714732fa0bf9d74eaee05d9a4f4d578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aOABZiHarl31wXTO"/></div></div></figure><p id="08ea" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">但是这种方法也有自己的缺点。例如，<strong class="kg io">您所做的更改可能会破坏一些外部隐藏的逻辑，那么与之相关的测试将根本不会运行，并且它们可能会失败</strong>。</p><p id="1732" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">几年来，这种情况只发生过几次。但是，如果你不接受这一点，偏执狂让你逃避现实，下一个方法是给你的。</p><h2 id="e0ab" class="lf lg in bd lh li lj dn lk ll lm dp ln lc lo lp lq ld lr ls lt le lu lv lw lx bi translated">3.有可能拆分所有测试并并行运行组块吗？</h2><p id="1896" class="pw-post-body-paragraph kd ke in kg b kh ly kj kk kl lz kn ko lc ma kr ks ld mb kv kw le mc kz la lb ig bi translated">为什么不呢？也许，如果我们把测试分成几个部分，然后<strong class="kg io">并行运行</strong>，可能会更快。</p><p id="0f7e" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">让我们看看这可能是怎么做的。</p><p id="fe95" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">首先，我们需要了解如何做到这一点，Jest CLI再次登场。<strong class="kg io">参数</strong><a class="ae jz" href="https://jestjs.io/docs/cli#--listtests" rel="noopener ugc nofollow" target="_blank"><strong class="kg io">list tests</strong></a><strong class="kg io">将打印我们拥有的所有测试，并且</strong><a class="ae jz" href="https://jestjs.io/docs/cli#--json" rel="noopener ugc nofollow" target="_blank"><strong class="kg io">json</strong></a><strong class="kg io">标志将以JSON格式打印它们</strong>。</p><p id="a4ca" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">现在我们有了一个带有JSON格式的具体测试文件路径的字符串数组。它需要被平均分成N个块。当然，我们可以通过迭代一个数组并将它分成更小的数组来编写脚本，但是我建议给<a class="ae jz" href="https://stedolan.github.io/jq/manual/" rel="noopener ugc nofollow" target="_blank">JQ·util</a>一个机会。</p><blockquote class="mi"><p id="3c9e" class="mj mk in bd ml mm mn mo mp mq mr lb dk translated">JQ是一种“过滤器”或“格式化程序”:它接受输入，产生输出。有许多内置的过滤器，用于提取对象的特定字段，或者将数字转换为字符串，或者其他各种标准任务。</p></blockquote><p id="97da" class="pw-post-body-paragraph kd ke in kg b kh ms kj kk kl mt kn ko lc mu kr ks ld mv kv kw le mw kz la lb ig bi translated">那么，让我们来看看这个命令:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/1e57dd7e9c7203847079f07a346a1df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7fDXsLAnSy2P-Px6"/></div></div></figure><p id="6a47" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">长话短说，我们接受了JSON格式的所有测试，然后把它交给了JQ。基本上，过滤器获取数组的长度，将其分为10(块的数量)并对其进行舍入。然后一个神奇的函数“_nwise”把结果拆分成数组。</p><p id="2782" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这是第一部分，所以我们有一个数组的数组。</p><p id="b5d4" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">因此，让我们创建一个作业<strong class="kg io"> setup-tesh-chunks </strong>，我们将在其中使用上面的命令。该作业将返回块和块id(嵌套数组的索引)。</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/4f8baedfc8a2652f62df6735996209e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QplxZFfxAjZiak9T"/></div></div></figure><p id="12f1" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">还有一个作业<strong class="kg io">测试——检查</strong>是否通过策略矩阵运行它们<strong class="kg io">,这将克隆作业的次数与传递给它的数组长度一样多(在我们的例子中是10次)。<strong class="kg io">快速失败</strong>值为false，简单地说就是当其中一个任务失败时不取消其他任务。更多关于战略矩阵的信息请点击。</strong></p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/c13f2aafa87ab74309361a8634b36ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RD3WYim4sOfjPQK6"/></div></div></figure><p id="1ddf" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">动作<strong class="kg io">遍历块id为</strong>的数组，并运行特定的块。最终，您的管道应该是这样的:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/f7c122661ae104607b2aed8f7be6ca36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fa3bmzd1kQQCteJg"/></div></div></figure></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h2 id="7adc" class="lf lg in bd lh li lj dn lk ll lm dp ln lc lo lp lq ld lr ls lt le lu lv lw lx bi translated"><strong class="ak">总而言之。</strong></h2><p id="fb10" class="pw-post-body-paragraph kd ke in kg b kh ly kj kk kl lz kn ko lc ma kr ks ld mb kv kw le mc kz la lb ig bi translated">GitHub Actions仍然年轻且充满活力，但它已经拥有了大量有用的功能。在我们的项目中，我们最终使用了最后一种方法，<strong class="kg io">它有助于将测试速度提高到大约3-5倍</strong>。</p><p id="7f14" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">请在评论中分享你的观点和方法。</p><p id="ea57" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">感谢阅读！</p><p id="7006" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><em class="kf">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kg io"><em class="kf">plain English . io</em></strong></a><em class="kf">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kg io"> <em class="kf">免费周报</em> </strong> </a> <em class="kf">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kg io"><em class="kf">Twitter</em></strong></a><em class="kf">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kg io"><em class="kf">LinkedIn</em></strong></a><em class="kf">。查看我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kg io"> <em class="kf">社区不和谐</em> </strong> </a> <em class="kf">加入我们的</em> <a class="ae jz" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kg io"> <em class="kf">人才集体</em> </strong> </a> <em class="kf">。</em></p></div></div>    
</body>
</html>