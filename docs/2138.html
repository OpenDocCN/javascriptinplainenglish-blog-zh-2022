<html>
<head>
<title>TypeScript Generics: Explained with Practical Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本泛型:用实例解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-generics-explained-with-practical-examples-ff9865bc8f4a?source=collection_archive---------6-----------------------#2022-05-17">https://javascript.plainenglish.io/typescript-generics-explained-with-practical-examples-ff9865bc8f4a?source=collection_archive---------6-----------------------#2022-05-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ea5b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">面向初学者的TypeScript泛型——通过实例探索泛型的用法。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d44c43238294ea8890c11d4d80ead97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l3ggYMYa7610rtdl"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@cebbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Robin Ebbinghaus</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b455" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我知道，有时阅读带有虚构示例的原始文档并不有趣，因此在本文中，我提供了一些基于我在实践中遇到的真实示例的泛型用法。很可能，它对你来说更有意义，也更容易理解。</p><p id="41eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，我试图将泛型的用法分成对我个人有意义的几个类别。</p><h1 id="83c9" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated"><strong class="ak">仿制药</strong></h1><p id="5f7c" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">什么是通用的？它允许我们编写一个类型安全的代码，该代码将与各种各样的原语和对象一起工作。泛型可以在新类型、接口、函数和类的声明中使用。事不宜迟，让我们看看泛型的一些用例。</p><h2 id="4352" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">1.为了消除代码中的重复</h2><p id="e155" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">让我们假设我们的服务器应该为两个不同的资源返回以下响应:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/8e628d2854ff6d0d68a4c42ea407a802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKSE50t1dQS92E2C0Lb6EA.png"/></div></div></figure><p id="b9d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果没有泛型，我们需要分别描述每个响应的类型:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/65517f57218cd4717bf1dd581431438e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7veh4cE5HePfOSnWGl8LOA.png"/></div></div></figure><p id="a04d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用Generic，我们只需立即定义响应形状并重用它:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/09d1b5b8da270fd22a894cda2b232ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64ymERM2wpik19GcJAGmZg.png"/></div></div></figure><h2 id="419e" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">2.表达自变量和函数返回值之间的关系</h2><p id="95f3" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">让我们假设我们有以下函数实现:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/da49efc6cece4b3015eb10da4b06da06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MXDdwHmAxn5tXt5k5oQ_w.png"/></div></div></figure><p id="c141" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过分析这个函数，我们了解到，我们根据第二个和第三个参数中传递的属性和值来过滤任何项目的数组。显然，所有函数参数和返回值都是耦合在一起的。</p><p id="f8a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们揭示第一个参数<code class="fe nc nd ne nf b">items</code>和返回值之间的简单关系。应该是相同类型的数组:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/b8bf8703ab575f7d8f69b667e951dcc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mox8d0aqfSmpnKALPItvhw.png"/></div></div></figure><p id="966d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们说这个函数接受一个包含类型为<code class="fe nc nd ne nf b">T</code>的数组，并返回一个相同类型的数组。到目前为止一切顺利。</p><p id="a1e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可能注意到了，我们用字符串类型定义了<code class="fe nc nd ne nf b">propertyName</code>参数，这没问题。但是这里的问题是，我们可能会意外地传递一个在类型为<code class="fe nc nd ne nf b">T</code>的项目中不存在的属性名，例如:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/525013c7592d67426c0a364f3e66307b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNr-trgNwT6NdPOkA7cwqA.png"/></div></div></figure><p id="b266" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，在这种情况下，它不会破坏应用程序，只是返回一个空数组，但这是一个我们需要尽快揭示的问题。让我们定义第二个泛型，它将描述<code class="fe nc nd ne nf b">T</code>类型的所有允许属性:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/ce0e25ea4b89798317835e2bd748a37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MindoJxJNLwsWDn3lnpvw.png"/></div></div></figure><p id="6479" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦我们这样做了，我们就发现了在运行时阶段之前传递错误属性的问题:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/303a0780c7946b699deea0084ec4e1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBjx2GA4LiK27EiZVv0zFQ.png"/></div></div></figure><p id="e87e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一部分，我们将第三个参数<code class="fe nc nd ne nf b">value</code>定义为一个字符串，直到<code class="fe nc nd ne nf b">T</code>的所有属性都只有<code class="fe nc nd ne nf b">string</code>类型。让我们假设类型<code class="fe nc nd ne nf b">User</code>包括类型<code class="fe nc nd ne nf b">number</code>的<code class="fe nc nd ne nf b">age</code>属性。正如您所料，当我们尝试按此字段过滤项目时，会遇到一个问题:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/edff37ba58539dbeb20bbfe8149cf733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sei5UURFTuAZW5H6t3fX0g.png"/></div></div></figure><p id="9ed2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这很容易解决，我们只需要以这种方式表达第三个参数的最后一个关系:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/cf34d5d82ce97325b1ea453890d57317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdHbvvgR0Xn5q8Y-LkCcvQ.png"/></div></div></figure><p id="a8f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个问题已经过去了:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/02855591c01f61d67d52ff3f5e6e2a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKAPwMXRzgqwWP6M_qq0fg.png"/></div></div></figure><p id="cdee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，现在我们不能将类型不是<code class="fe nc nd ne nf b">number</code>的值作为<code class="fe nc nd ne nf b">age</code>属性的第三个参数传递，因为<code class="fe nc nd ne nf b">User</code>类型只允许该属性有<code class="fe nc nd ne nf b">number</code>:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/123ab88e1c2b283b0c1b6e11e721cc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHWmt_-EGuDBxf6XXpXeKg.png"/></div></div></figure><p id="82bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你是一名Rect开发人员，我很确定你已经遇到过这种情况:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d2cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如你所见，我们有地方改进了函数<code class="fe nc nd ne nf b">setUserField</code>的<code class="fe nc nd ne nf b">field</code>和<code class="fe nc nd ne nf b">value</code>参数的类型。花些时间解决它，直到你看到下面的解决方案。</p><p id="1dcf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以下是解决方案:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1c8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 3。既灵活又严格(关键字“用泛型扩展”)</strong></p><p id="1175" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有时我们需要开发一个API，它应该与一组特定的类型一起工作，我们对它的能力有一些了解。</p><p id="5ed0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最近，我需要扩展React本机组件的样式功能，并增加根据屏幕断点应用不同样式的可能性。它应该是一个高阶组件，其目的是将此功能<strong class="kv io"> <em class="nq">仅</em> </strong>添加到具有<code class="fe nc nd ne nf b">style</code>属性的组件中。Typescript允许我们使用下面的泛型语法来表达这种必要性:<code class="fe nc nd ne nf b">T extends K</code>这意味着假设类型<code class="fe nc nd ne nf b">T</code>的值也属于类型<code class="fe nc nd ne nf b">K</code>是安全的。对于我们的例子，它看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c111" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们需要注意，一旦我们定义了那个<code class="fe nc nd ne nf b">Props extend { style?: StyleProp }</code>，Typescript就允许我们在HOC内部使用这个属性(见第6行)。另一方面，如果您试图对没有<code class="fe nc nd ne nf b">style</code>属性的组件使用这个特设，Typescript会引发一个问题:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/68be42b65e181ebf1bd8bf4e9b7d66ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRG_w-H1ad7y4v2xfbJ3dQ.png"/></div></div></figure><p id="97ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们总结一下:一方面，我们只对具有<code class="fe nc nd ne nf b">style</code>属性的组件限制使用HOC，另一方面，这个组件可以具有任何其他属性，没有任何限制。此外，由于Typescript知道我们可以对具有<code class="fe nc nd ne nf b">style</code>属性的组件使用我们的HOC——我们可以安全地从组件props中提取它，并在HOC中操纵它。</p><p id="2856" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你有兴趣了解关于这个HOC的更多细节，我写了一篇文章，可以在这里找到:<a class="ae ks" href="https://betterprogramming.pub/how-to-extend-react-native-paper-component-for-developing-responsive-ux-4874c127e12" rel="noopener ugc nofollow" target="_blank">如何扩展React Native Paper组件来开发响应式UX </a>。</p><h1 id="ed5d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">一些额外的笔记</h1><p id="34ca" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">Typescript有一个惊人的特性——它试图从可能的上下文中推断类型。当我在代码中看到这样的内容时:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/b0d5dd834d00118223a1b23ab02dec29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nE8OTtclkfwcJ7U_uBVwxA.png"/></div></div></figure><p id="1524" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">意思是一个开发者不知道这件事。Typescript从值中知道<code class="fe nc nd ne nf b">a</code>是一个数字。</p><p id="5ae2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们假设，我们用泛型来定义这个函数:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/5a42bfbf20c8e40c7615c7bc5de5f32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiKyJ-CNU35OUxj9YY4ISg.png"/></div></div></figure><p id="72d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你是初学者，你可能会这样使用它:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/fdd23dd1b43c4efd5c9eec0110ab8477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4V7ntzhAYk9v8o_tTiR4A.png"/></div></div></figure><p id="a560" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是Typescript可能会从作为第一个参数传递的值中推断出泛型类型，最好这样使用它:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/3e8e5d4233fe5915292a8d2be7a12563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2Uq_NrIyT2z1VuhMHtoTw.png"/></div></div></figure><p id="bda9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您是React开发人员，您可能会看到许多这样的时间片段:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/de7494fcc5d24f033b0e81d94be9d53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6XMePdzlnZ-2443ZmpGaA.png"/></div></div></figure><p id="7a1d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是同样，在这里显式定义泛型的类型是多余的，它将从您作为第一个参数传递的值中推断出来，如果您是一个有经验的开发人员，您的代码将如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/db8a7c9ba032440fb1f41f04532b910b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNGDuMqRO2Acqa-qudyAIw.png"/></div></div></figure><p id="4886" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另外，我遇到过一个案例，一个开发人员害怕对React组件属性使用泛型。是的，我们在JSX中使用我们的组件，他们不知道这个语法是有效的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/14185bec855538714b1836d5da6fc3cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8uWD5SYKXru9dtuQ9Jo4A.png"/></div></div></figure><p id="bbe2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">是的，这看起来很奇怪，但是这里我们可以依靠Typescript功能，根据传递给组件的属性类型来推断泛型类型:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/6dde094245526f181d5b136bcf28f8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Ign1wDnLjSt_nT8j2PpPg.png"/></div></div></figure><p id="5504" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同意代码更好，你看起来像一个有经验的开发人员。</p></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><p id="61e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望你喜欢阅读这篇文章。很高兴看到任何评论或任何项目，应该已经涵盖。感谢任何有助于改进文章的帮助。谢谢你。</p><p id="2061" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nq">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nq">plain English . io</em></strong></a><em class="nq">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nq">免费周报</em> </strong> </a> <em class="nq">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nq">Twitter</em></strong></a><em class="nq">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nq">LinkedIn</em></strong></a><em class="nq">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nq">社区不和谐</em> </strong> </a> <em class="nq">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nq">人才集体</em> </strong> </a> <em class="nq">。</em></p></div></div>    
</body>
</html>