<html>
<head>
<title>How to Make Old Code Clean and Clear</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让旧代码干净清晰</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-old-code-clean-and-clear-44918a318d1c?source=collection_archive---------13-----------------------#2022-08-04">https://javascript.plainenglish.io/how-to-make-old-code-clean-and-clear-44918a318d1c?source=collection_archive---------13-----------------------#2022-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7e23" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">干净的代码冒险</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9024339170bdfc2ecd85bafa0b37270c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aH4_rgoaWgGoFOPNZ_bfA.jpeg"/></div></div></figure><p id="8676" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这篇文章的想法是从一个没有考虑干净代码原则的函数开始，用一种干净清晰的方式重写它。整个过程将由测试驱动。</p><p id="4eaa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">目的是验证一种<em class="lk">的工作方式</em>，这种方式可以用来重构旧的代码基础并提高它们的质量。</p><p id="f4b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将创建一组在不同抽象层次分解原始函数算法的函数，从旧代码中汲取灵感，并尽可能重用它。</p><p id="03bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，我们将跟踪每个新引入的特性覆盖了旧代码的哪些行，以确保我们实现了所有的旧特性。</p><p id="d01e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们从我在一篇旧文章中描述的一个函数开始:自然排序的高性能比较算法。</p><p id="006d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是旧代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="ed05" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">没错，是晦涩难懂。我们手中力量的阴暗面。<br/>是的，代码不能处理包含前导零的数字部分。但是修改它来处理它们是非常容易的。而且干净的代码重构之后会更容易！</p><p id="6ca9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我理想的高级功能如下:</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="dea2" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> <em class="lk">natural_sort_comparison</em> = <strong class="lo io">(</strong>a: string, b: string<strong class="lo io">) =&gt;</strong><br/>  compare<em class="lk">_chars_or_numbers_of</em><strong class="lo io">(</strong><br/>    a,<br/>    <em class="lk">with_corresponding_char_or_number_of</em><strong class="lo io">(</strong>b<strong class="lo io">)</strong><br/>  <strong class="lo io">)</strong></span></pre><p id="7ef7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这与维基百科中自然排序的定义非常接近:</p><blockquote class="ly lz ma"><p id="526f" class="ko kp lk kq b kr ks jo kt ku kv jr kw mb ky kz la mc lc ld le md lg lh li lj ig bi translated">在计算中，<strong class="kq io">自然排序顺序</strong>(或<strong class="kq io">自然排序</strong>)是按照<a class="ae me" href="https://en.wikipedia.org/wiki/Alphabetical_order" rel="noopener ugc nofollow" target="_blank">字母顺序</a>对字符串进行的<a class="ae me" href="https://en.wikipedia.org/wiki/Collation" rel="noopener ugc nofollow" target="_blank">排序，除了多位数被自动处理，即，就像它们是单个字符一样。</a></p></blockquote><p id="b135" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它准确地反映了算法的本质，但包含了一个技术难点:它需要使用一个函数，该函数关闭另一个有效执行任务的函数中的参数b。</p><p id="d448" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有人可能会说使用闭包会使代码晦涩难懂。所以我会选择一个更简单、不那么优雅的版本:</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="4bad" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> <em class="lk">natural_sort_comparison</em> = <strong class="lo io">(</strong>a: string, b: string<strong class="lo io">)</strong> <strong class="lo io">=&gt;</strong><br/>  compare<em class="lk">_chars_or_numbers</em><strong class="lo io">(</strong>a, b<strong class="lo io">)</strong></span></pre><p id="c793" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是我的最终解决方案将使用我的第一个想法，因为我不认为优雅和复杂会损害清晰。</p><p id="22ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面我将使用这三个常量:</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="5a57" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> EQUAL = 0<br/><strong class="lo io">const</strong> SMALLER = -1<br/><strong class="lo io">const</strong> BIGGER = 1</span></pre><p id="ddad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的初始测试集将验证循环在字符串a的字符上的正确“移植”。出于这个简单的目的，测试字符串只包含字母字符，并且每个字符串都不是另一个字符串的前缀。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="9845" class="ls lt in lo b gy lu lv l lw lx"><em class="lk">test</em><strong class="lo io">(</strong>'Basic string comparisons', <strong class="lo io">() =&gt; {</strong><br/>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'abc', 'bc'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong><em class="lk">SMALLER</em><strong class="lo io">)<br/></strong>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'bc', 'abc'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong>BIGGER<strong class="lo io">)<br/></strong>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong> 'abcde', 'abcde'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong>EQUAL<strong class="lo io">)</strong><br/><strong class="lo io">))</strong></span></pre><p id="274f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们覆盖了原始代码的第2、3、4、5、24、25行和部分第28行。</p><p id="8704" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">代码是这样的:</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="3868" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> compare<em class="lk">_chars_or_numbers </em>= <strong class="lo io">(</strong>a, b<strong class="lo io">)</strong> <strong class="lo io">=&gt; {</strong><br/>  <strong class="lo io">let </strong>charIndex = 0<br/>  <strong class="lo io">while ( </strong>charIndex &lt; a.lenght <strong class="lo io">)</strong> <strong class="lo io">{</strong><br/>    <strong class="lo io">const </strong>comparisonResult =<br/>      <em class="lk">compare_one_char_or_number</em><strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong><br/>    <strong class="lo io">if (</strong>comparisonResult !== EQUAL<strong class="lo io">)</strong> <strong class="lo io">return </strong>comparisonResult<br/>    charIndex++<br/>  <strong class="lo io">}</strong><br/>  <strong class="lo io">return </strong>EQUAL<br/><strong class="lo io">}</strong></span><span id="6a3c" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const</strong> <em class="lk">compare_one_char_or_number </em>= <strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong> <strong class="lo io">=&gt;</strong> <strong class="lo io">{</strong><br/>  <strong class="lo io">const </strong>aCode = a.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">const </strong>bCode = b.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">return </strong>aCode - bCode<br/><strong class="lo io">}</strong></span></pre><p id="b9ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我用<em class="lk">替换了</em>循环的<em class="lk">,而</em>是因为在最终代码中，我想将第3行的增量的<em class="lk">和第21行的增量合并成一条指令。</em></p><p id="c06c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下一步是重新组织前缀的解决方案。</p><p id="232e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些是附加测试:</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="96bd" class="ls lt in lo b gy lu lv l lw lx"><em class="lk">test</em><strong class="lo io">(</strong>'Strings that are prefixed by the other', <strong class="lo io">() =&gt; {</strong><br/>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'abc', 'abcd'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong><em class="lk">SMALLER</em><strong class="lo io">)<br/></strong>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'abcd', 'abc'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong>BIGGER<strong class="lo io">)</strong><br/><strong class="lo io">))</strong></span></pre><p id="8b8b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第6行和第28行的检查应该插入到<em class="lk">compare _ one _ char _ or _ number</em>函数中，但是我们需要找到一种方法将第28行的测试包含到<em class="lk"> a </em>元素的循环中:</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="d5ba" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> compare<em class="lk">_chars_or_numbers </em>= <strong class="lo io">(</strong>a, b<strong class="lo io">)</strong> <strong class="lo io">=&gt; {</strong><br/>  <strong class="lo io">let </strong>charIndex = 0<br/>  <strong class="lo io">const</strong> maxComparisonChars = a.length + OneMoreToCheckIfAisPrefixOfB<br/>  <strong class="lo io">while ( </strong>charIndex &lt; maxComparisonChars <strong class="lo io">)</strong> <strong class="lo io">{</strong><br/>    <strong class="lo io">const </strong>comparisonResult =<br/>      <em class="lk">compare_one_char_or_number</em><strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong><br/>    <strong class="lo io">if (</strong>comparisonResult !== EQUAL<strong class="lo io">)</strong> <strong class="lo io">return </strong>comparisonResult<br/>    charIndex++<br/>  <strong class="lo io">}</strong><br/>  <strong class="lo io">return </strong>EQUAL<br/><strong class="lo io">}</strong></span><span id="a6c0" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const </strong>OneMoreToCheckIfAisPrefixOfB = 1</span></pre><p id="a1fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，该函数必须处理一个超过字符串大小的charIndex。这不是一个大问题，因为在这种情况下<em class="lk"> chartAt(i) </em>返回<em class="lk"> NaN。</em>还要注意，现在比较相等的字符串，我们得到的charIndex超过了两个字符串的大小。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="4ec9" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> <em class="lk">compare_one_char_or_number </em>= <strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong> <strong class="lo io">=&gt;</strong> <strong class="lo io">{</strong><br/>  <strong class="lo io">const </strong>aCode = a.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">const </strong>bCode = b.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">return </strong><em class="lk">compare_char_codes</em><strong class="lo io">(</strong>aCode, bCode<strong class="lo io">)</strong><br/><strong class="lo io">}</strong></span><span id="d4e4" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const</strong> <em class="lk">compare_char_codes</em> = <strong class="lo io">(</strong>aCode, bCode<strong class="lo io">)</strong> <strong class="lo io">=&gt;</strong> <strong class="lo io">{</strong><br/>  <strong class="lo io">if (</strong>are_strings_equal<strong class="lo io">(</strong>aCode, bCode<strong class="lo io">))</strong> <strong class="lo io">return </strong>EQUAL<br/>  <strong class="lo io">if (</strong>is_the_string_prefix_of_the_other<strong class="lo io">(</strong>aCode<strong class="lo io">))</strong> <strong class="lo io">return </strong>SMALLER<br/>  <strong class="lo io">if (</strong>is_the_string_prefix_of_the_other<strong class="lo io">(</strong>bCode<strong class="lo io">))</strong> <strong class="lo io">return </strong>BIGGER<br/>  return aCode - bCode<br/><strong class="lo io">}</strong></span><span id="f495" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const </strong>is_the_string_prefix_of_the_other =<br/>  charCode <strong class="lo io">=&gt; </strong>isNaN<strong class="lo io">(</strong>charCode<strong class="lo io">)</strong></span><span id="4ff0" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const </strong>are_strings_equal =<br/>  <strong class="lo io">(</strong>aCode, bCode<strong class="lo io">)</strong> <strong class="lo io">=&gt;</strong> isNaN<strong class="lo io">(</strong>aCode<strong class="lo io">)</strong> &amp;&amp; isNaN<strong class="lo io">(</strong>bCode<strong class="lo io">)</strong></span></pre><p id="c9d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个改进版本的<em class="lk">compare _ one _ char _ or _ number</em>覆盖了第5行和第28行的其余部分。</p><p id="0f2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下一步是处理带有数字部分的字符串。首先要考虑的是<em class="lk">compare _ one _ character _ or _ one _ number</em>现在可以一次比较多个字符(一个数字可以由多个数字组成)。<br/>在相等的子字符串的情况下，比较的字符数用于递增<em class="lk">compare _ chars _ or _ numbers</em>中的循环计数器，因此该函数必须向调用者返回两个值。<br/>在这些情况下，一个众所周知的习语(广泛用于React挂钩)是返回一个向量并使用ES6语法提取值:</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="784f" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> compare<em class="lk">_chars_or_numbers </em>= <strong class="lo io">(</strong>a, b<strong class="lo io">)</strong> <strong class="lo io">=&gt; {</strong><br/>  <strong class="lo io">let </strong>charIndex = 0<br/>  <strong class="lo io">const</strong> maxComparisonChars = a.length + OneMoreToCheckIfAisPrefixOfB<br/>  <strong class="lo io">while ( </strong>charIndex &lt; maxComparisonChars <strong class="lo io">)</strong> <strong class="lo io">{</strong><br/>    <strong class="lo io">const [</strong>comparisonResult, comparedChars<strong class="lo io">]</strong> =<br/>      <em class="lk">compare_one_char_or_number</em><strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong><br/>    <strong class="lo io">if (</strong>comparisonResult !== EQUAL<strong class="lo io">)</strong> <strong class="lo io">return </strong>comparisonResult<br/>    charIndex += comparedChars<br/>  <strong class="lo io">}</strong><br/>  <strong class="lo io">return </strong>EQUAL<br/><strong class="lo io">}</strong></span><span id="d9bb" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const</strong> <em class="lk">compare_one_char_or_number </em>= <strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong> <strong class="lo io">=&gt;</strong> <strong class="lo io">{</strong><br/>  <strong class="lo io">const </strong>aCode = a.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">const </strong>bCode = b.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)<br/>  const</strong> comparedChars = 1<br/>  <strong class="lo io">return [</strong><em class="lk">compare_char_codes</em><strong class="lo io">(</strong>aCode, bCode<strong class="lo io">), </strong>comparedChars]<br/><strong class="lo io">}</strong></span></pre><p id="ae76" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意<em class="lk"> charIndex </em>递增，直到两个子字符串相等，但是当它们变得不同时<em class="lk"> comparedChars </em>不被使用。</p><p id="13dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">单元测试的重新运行确保了变更不会引入中断。</p><p id="76e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们准备好为带有数字部分的字符串定义测试。我们从长度为1的数字部分开始。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="e199" class="ls lt in lo b gy lu lv l lw lx"><em class="lk">test</em><strong class="lo io">(</strong>'Strings that are prefixed by the other', <strong class="lo io">() =&gt; {</strong><br/>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'ab2c1', 'ab2c2'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong><em class="lk">SMALLER</em><strong class="lo io">)<br/></strong>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'ab2c2', 'ab2c1'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong>BIGGER<strong class="lo io">)</strong><br/><strong class="lo io">))</strong></span></pre><p id="2d24" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数<em class="lk">compare _ one _ char _ or _ number</em>应区分标准字符和数字序列:</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="54b7" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> <em class="lk">compare_one_char_or_number </em>= <strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong> <strong class="lo io">=&gt;</strong> <strong class="lo io">{</strong><br/>  <strong class="lo io">const </strong>aCode = a.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">const </strong>bCode = b.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)<br/>  if (</strong>is_digit<strong class="lo io">(</strong>aCode<strong class="lo io">)</strong> &amp;&amp; is_digit<strong class="lo io">(</strong>bCode<strong class="lo io">)) {<br/>    return </strong><em class="lk">compare_digits</em><strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)<br/>  }<br/>  const</strong> comparedChars = 1<br/>  <strong class="lo io">return [</strong><em class="lk">compare_char_codes</em><strong class="lo io">(</strong>aCode, bCode<strong class="lo io">), </strong>comparedChars<strong class="lo io">]</strong><br/><strong class="lo io">}</strong></span><span id="6760" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const </strong><em class="lk">compare_digits </em>= <strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">) =&gt; {</strong><br/>  return [a - b, 1]<br/>}</span><span id="7be0" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const </strong><em class="lk">is_digit </em>= charCode <strong class="lo io">=&gt;</strong> charCode&gt;=48 &amp;&amp; charCode&lt;=57</span></pre><p id="1284" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意<em class="lk"> is_digit(NaN) </em>为false，所以前缀和相等字符串的处理只发生在<em class="lk"> compare_char_codes </em>内部。</p><p id="cbeb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">compare _ one _ char _ or _ number</em>中的两个返回语句有问题:我们混合了两个不同层次的抽象:谁负责返回两个函数值？我们不能从<em class="lk"> compare_digits </em>中提取这个责任，所以我们甚至在字母字符的情况下委托它。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="4196" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> <em class="lk">compare_one_char_or_number </em>= <strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong> <strong class="lo io">=&gt;</strong> <strong class="lo io">{</strong><br/>  <strong class="lo io">const </strong>aCode = a.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">const </strong>bCode = b.charCodeAt<strong class="lo io">(</strong>charIndex<strong class="lo io">)<br/>  if (</strong>is_digit<strong class="lo io">(</strong>aCode<strong class="lo io">)</strong> &amp;&amp; is_digit<strong class="lo io">(</strong>bCode<strong class="lo io">)) {<br/>    return </strong><em class="lk">compare_digits</em><strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)<br/>  }</strong><br/>  <strong class="lo io">return </strong><em class="lk">compare_one_char_code_pair</em><strong class="lo io">(</strong>aCode, bCode<strong class="lo io">)</strong><br/><strong class="lo io">}</strong></span><span id="100e" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const</strong> <em class="lk">compare_one_char_code_pair</em> = <strong class="lo io">(</strong>aCode, bCode<strong class="lo io">) =&gt; {<br/>  const</strong> comparedChars = 1<br/>  <strong class="lo io">return [</strong><em class="lk">compare_char_codes</em><strong class="lo io">(</strong>aCode, bCode<strong class="lo io">), </strong>comparedChars<strong class="lo io">]<br/>}</strong></span></pre><p id="f27c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">compare _ one _ char _ or _ number</em>的最终版本也覆盖了旧代码的第7行。</p><p id="9cd5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下一步是比较不同长度的数量。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="25e4" class="ls lt in lo b gy lu lv l lw lx"><em class="lk">test</em><strong class="lo io">(</strong>'Strings that are prefixed by the other', <strong class="lo io">() =&gt; {</strong><br/>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'abc2', 'abc11'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong><em class="lk">SMALLER</em><strong class="lo io">)<br/>  </strong>expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'abc111', 'abc21'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong>BIGGER<strong class="lo io">)</strong><br/><strong class="lo io">))</strong></span></pre><p id="0b2c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">数字越多的数字越大。因此，计算两个字符串中连续数字的个数并比较计数器就足够了。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="3c06" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const </strong><em class="lk">compare_digits </em>= <strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">) =&gt; {</strong><br/>  <strong class="lo io">const </strong>aDigits = <em class="lk">number_of_consecutive_digits</em><strong class="lo io">(</strong>a, charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">const </strong>bDigits = <em class="lk">number_of_consecutive_digits</em><strong class="lo io">(</strong>b, charIndex<strong class="lo io">)<br/>  if</strong> <strong class="lo io">(</strong>aDigits &gt; bDigits<strong class="lo io">)</strong> <strong class="lo io">return </strong>[BIGGER]<br/>  <strong class="lo io">if</strong> <strong class="lo io">(</strong>aDigits &lt; bDigits<strong class="lo io">)</strong> <strong class="lo io">return </strong>[SMALLER]<br/>  // cannot be here for the moment<br/><strong class="lo io">}</strong></span><span id="1e52" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const </strong><em class="lk">number_of_consecutive_digits </em>= <strong class="lo io">(</strong>str, startIndex<strong class="lo io">) =&gt; {<br/>  let </strong>lastIndex<br/>  <strong class="lo io">for (</strong>lastIndex=startIndex+1; lastIndex&lt;str.length; lastIndex++<strong class="lo io">)</strong><br/>    <strong class="lo io">if (</strong>!<em class="lk">is_digit</em><strong class="lo io">(</strong>str.charCodeAt<strong class="lo io">(</strong>lastIndex<strong class="lo io">)))</strong><br/>      <strong class="lo io">return </strong>lastIndex - startIndex<br/>  <strong class="lo io">return </strong>lastIndex - startIndex<br/><strong class="lo io">}</strong></span></pre><p id="6703" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，现在是最后一步:测试数字部分长度相同的字符串。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="a2d3" class="ls lt in lo b gy lu lv l lw lx"><em class="lk">test</em><strong class="lo io">(</strong>'Strings that are prefixed by the other', <strong class="lo io">() =&gt; {</strong><br/>  expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'abc12', 'abc12'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong><em class="lk">EQUAL</em><strong class="lo io">)<br/>  </strong>expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'abc11', 'abc12'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong><em class="lk">SMALLER</em><strong class="lo io">)<br/>  </strong>expect<strong class="lo io">(</strong><em class="lk">natural_sort_comparison</em><strong class="lo io">(</strong>'abc13', 'abc12'<strong class="lo io">))</strong>.toBe<strong class="lo io">(</strong>BIGGER<strong class="lo io">)</strong><br/><strong class="lo io">))</strong></span></pre><p id="575c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果两个数字部分具有相同的长度，只需检查其数字的字符代码顺序。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="66ce" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const </strong><em class="lk">compare_digits </em>= <strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">) =&gt; {</strong><br/>  <strong class="lo io">const </strong>aDigits = <em class="lk">number_of_consecutive_digits</em><strong class="lo io">(</strong>a, charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">const </strong>bDigits = <em class="lk">number_of_consecutive_digits</em><strong class="lo io">(</strong>b, charIndex<strong class="lo io">)<br/>  if</strong> <strong class="lo io">(</strong>aDigits &gt; bDigits<strong class="lo io">)</strong> <strong class="lo io">return </strong>[BIGGER]<br/>  <strong class="lo io">if</strong> <strong class="lo io">(</strong>aDigits &lt; bDigits<strong class="lo io">)</strong> <strong class="lo io">return </strong>[SMALLER]<br/>  <strong class="lo io">return</strong> compare_equal_length_numbers<strong class="lo io">(</strong>a, b, charIndex, aDigits<strong class="lo io">)</strong><br/><strong class="lo io">}</strong></span><span id="2f87" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const</strong> compare_equal_length_numbers =<br/> <strong class="lo io">(</strong>a, b, startIndex, numberOfDigits<strong class="lo io">) =&gt; {<br/>   for (let</strong> charIndex = startIndex;<br/>        charIndex &lt; startIndex + numberOfDigits;<br/>        charIndex++<strong class="lo io">) {<br/>     const</strong> aCode = a.charCodeAt(charIndex)<br/>     <strong class="lo io">const</strong> bCode = b.charCodeAt(charIndex)<br/>     <strong class="lo io">if (</strong>aCode &lt; bCode<strong class="lo io">) return</strong> [SMALLER]<br/>     <strong class="lo io">if (</strong>aCode &gt; bCode<strong class="lo io">) return</strong> [BIGGER]<br/><strong class="lo io">  }<br/>  return</strong> [EQUAL, numberOfDigits]<br/><strong class="lo io">}</strong></span></pre><p id="4791" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数<em class="lk">compare _ equal _ length _ numbers</em>覆盖旧代码的第13-18行，而<em class="lk"> compare_digits </em>覆盖第8-11行</p><p id="4292" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">仅此而已。但是在展示整个重构的代码之前，请记住我在开头说过的话……我更喜欢优雅和复杂的代码。毕竟，闭包是语言的一部分…</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="1921" class="ls lt in lo b gy lu lv l lw lx"><strong class="lo io">const</strong> <em class="lk">natural_sort_comparison</em> = <strong class="lo io">(</strong>a: string, b: string<strong class="lo io">) =&gt;</strong><br/>  compare<em class="lk">_chars_or_numbers_of</em><strong class="lo io">(</strong><br/>    a,<br/>    <em class="lk">with_corresponding_char_or_number_of</em><strong class="lo io">(</strong>b<strong class="lo io">)</strong><br/>  <strong class="lo io">)</strong></span><span id="8816" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const</strong> compare<em class="lk">_chars_or_numbers_of </em>= <strong class="lo io">(</strong>a, compare_with_b<strong class="lo io">)</strong> <strong class="lo io">=&gt; {</strong><br/>  <strong class="lo io">let </strong>charIndex = 0<br/>  <strong class="lo io">const</strong> maxComparisonChars = a.length + OneMoreToCheckIfAisPrefixOfB<br/>  <strong class="lo io">while ( </strong>charIndex &lt; maxComparisonChars <strong class="lo io">)</strong> <strong class="lo io">{</strong><br/>    <strong class="lo io">const [</strong>comparisonResult, comparedChars<strong class="lo io">]</strong> =<br/>      compare_with_b<strong class="lo io">(</strong>a, charIndex<strong class="lo io">)</strong><br/>    <strong class="lo io">if (</strong>comparisonResult !== EQUAL<strong class="lo io">)</strong> <strong class="lo io">return </strong>comparisonResult<br/>    charIndex += comparedChars<br/>  <strong class="lo io">}</strong><br/>  <strong class="lo io">return </strong>EQUAL<br/><strong class="lo io">}</strong></span><span id="5b10" class="ls lt in lo b gy mf lv l lw lx"><strong class="lo io">const</strong> <em class="lk">with_corresponding_char_or_number_of</em> = b<strong class="lo io"> =&gt; {<br/>  const</strong> compare_with_b = <strong class="lo io">(</strong>a, charIndex<strong class="lo io">) =&gt;<br/>    </strong><em class="lk">compare_one_char_or_number</em><strong class="lo io">(</strong>a, b, charIndex<strong class="lo io">)</strong><br/>  <strong class="lo io">return</strong> compare_with_b<br/><strong class="lo io">}</strong></span></pre><p id="3f0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我只修改了主函数的名称和签名，并在它的主体中调用了对<em class="lk"> compare_with_b </em>的调用:一个在b上关闭的函数，它调用了<em class="lk">compare _ one _ char _ or _ number</em>以及所有需要的参数。<br/>一个黑暗的片段在干净的代码天空中幸存下来，允许对顶级函数进行富有表现力的调用。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="be87" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，代码行增加了一倍(考虑到旧清单中没有skipDigit函数),但是我们添加了很多信息，现在代码可以像小说一样阅读了。</p><p id="21b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">很好奇大家对这个实验的看法，尤其是黑暗碎片。请不吝赐教。</p><p id="e2df" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容看</em> <a class="ae me" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">说白了就是io </em> </strong> </a> <em class="lk">。报名参加我们的</em> <a class="ae me" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。关注我们关于</em> <a class="ae me" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">推特</em> </strong> </a>，<a class="ae me" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">领英</em> </strong> </a> <em class="lk">和</em> <a class="ae me" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">不和</em> </strong> </a> <strong class="kq io"> <em class="lk">。</em>T46】</strong></p></div></div>    
</body>
</html>