<html>
<head>
<title>How to Test React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试React组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-test-react-components-2eff11d8cd75?source=collection_archive---------3-----------------------#2022-01-31">https://javascript.plainenglish.io/how-to-test-react-components-2eff11d8cd75?source=collection_archive---------3-----------------------#2022-01-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1213a040c95fcec5b2260cdd6ae5cf94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IQR5SrYGgSmg_e2j.png"/></div></div></figure><p id="870c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编写测试React组件的测试可能很棘手。我花时间寻找做这件事的正确方法，但我几乎找不到解决问题所需的例子。这让我想写这篇文章来分享我的经验和见解。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="86ef" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置环境</h1><p id="2a62" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">如果你想知道如何设置Jest和React测试库环境，你也可以阅读这篇文章。</p><h1 id="5888" class="la lb in bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx bi translated">演示存储库</h1><p id="180d" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">如果你想看一个完整的例子，我创建了一个样板用于演示:【https://github.com/tabsteveyang/react-jest-rtl-boilerplate<a class="ae md" href="https://github.com/tabsteveyang/react-jest-rtl-boilerplate" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="0414" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">嘲弄的</h1><p id="6b2d" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在设置了运行Jest和React测试库的环境之后，您可能很快就会发现，当您在测试中渲染它时，您的一些组件会崩溃。</p><p id="e644" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为测试中呈现的组件只能在特定的环境下运行。它通常已经在开发和生产环境中设置好了，但是我们必须在运行测试时模拟一个假的。</p><p id="57b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将把本节中创建的文件放在jest/mock/目录下，并在webpack.config.js文件中添加一个@jest别名。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7aae" class="ms lb in mo b gy mt mu l mv mw">alias: {<br/>  '@js': path.resolve(__dirname, 'src/js/'),<br/>  '@scss': path.resolve(__dirname, 'src/scss/'),<br/>  '@img': path.resolve(__dirname, 'img/'),<br/>  '@jest': path.resolve(__dirname, 'jest/')<br/>}</span></pre><p id="ddb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并将它添加到jest.config.js中</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="2371" class="ms lb in mo b gy mt mu l mv mw">moduleNameMapper: {<br/>  '^@js(.*)$': '&lt;rootDir&gt;/src/js$1',<br/>  '^@scss(.*)$': '&lt;rootDir&gt;/src/scss$1',<br/>  '^@img(.*)$': '&lt;rootDir&gt;/img$1',<br/>  '^@jest(.*)$': '&lt;rootDir&gt;/jest$1'<br/>},</span></pre><h2 id="e42c" class="ms lb in bd lc mx my dn lg mz na dp lk kg nb nc lo kk nd ne ls ko nf ng lw nh bi translated">嘲讽Redux</h2><p id="d2f1" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">1.创建实际商店的副本</p><p id="f6b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在某些情况下，我们只需要一个可以用默认状态呈现组件的环境。您可以通过复制实际的故事文件并删除不必要的配置(比如Redux DevTools的配置)来实现这一点</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1c58" class="ms lb in mo b gy mt mu l mv mw">// jest/mock/store/index.js</span><span id="1f5b" class="ms lb in mo b gy ni mu l mv mw">import { createStore, applyMiddleware, compose } from 'redux'<br/>import thunk from 'redux-thunk'<br/>import reducer from '@js/reducers'</span><span id="9784" class="ms lb in mo b gy ni mu l mv mw">const composeEnhancers = compose</span><span id="490b" class="ms lb in mo b gy ni mu l mv mw">const middleware = [thunk]<br/>export default createStore(<br/>  reducer,<br/>  composeEnhancers(applyMiddleware(...middleware))<br/>)</span></pre><p id="253c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.模仿提供者</p><p id="bfa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们使用React with Redux，我们需要将组件包装到react-redux库中的提供者组件中。我们需要在测试中渲染组件时做同样的事情。为了避免重复编写相同的逻辑，我们可以创建一个组件来处理它。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1169" class="ms lb in mo b gy mt mu l mv mw">// jest/mock/MockProvider.jsx</span><span id="02bb" class="ms lb in mo b gy ni mu l mv mw">import { Provider } from 'react-redux'<br/>// use the replica one as the default store<br/>import store from './store'</span><span id="116f" class="ms lb in mo b gy ni mu l mv mw">const MockProvider = ({ children = null, mockStore = null }) =&gt; {<br/>  return (<br/>    &lt;Provider store={mockStore || store}&gt;<br/>      { children }<br/>    &lt;/Provider&gt;<br/>  )<br/>}</span><span id="f8b9" class="ms lb in mo b gy ni mu l mv mw">MockProvider.propTypes = {<br/>  mockStore: PropTypes.object,  // this prop allows us to set the store to specific state<br/>  children: PropTypes.node<br/>}</span><span id="8250" class="ms lb in mo b gy ni mu l mv mw">export default MockProvider</span></pre><p id="bed0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还必须创建一个模块来创建商店的不同状态。该模块使用redux-mock-store库创建模拟存储，并用Jest模拟函数替换模拟存储的dispatch属性，以便我们可以在需要时跟踪状态。我们可以用这个参数来设置存储的初始状态。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bfa3" class="ms lb in mo b gy mt mu l mv mw">// jest/mock/store/createMockStore.js</span><span id="085b" class="ms lb in mo b gy ni mu l mv mw">import configureMockStore from 'redux-mock-store'<br/>import thunk from 'redux-thunk'<br/>const middleware = [thunk]<br/>export default (initialState) =&gt; {<br/>  const mockStore = configureMockStore(middleware)(initialState)<br/>  // eslint-disable-next-line no-undef<br/>  // replace the dispatch method with a spy and keep the funtionality<br/>  mockStore.dispatch = jest.fn(mockStore.dispatch)<br/>  return mockStore<br/>}</span></pre><h2 id="3e4e" class="ms lb in bd lc mx my dn lg mz na dp lk kg nb nc lo kk nd ne ls ko nf ng lw nh bi translated">嘲讽路线和历史</h2><p id="4f05" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">这里还有一个类似的案例。为了使使用react-router-dom库的组件工作，我们必须将它们包装在路由器组件中。因此，我们也可以为此创建一个模块。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="04e3" class="ms lb in mo b gy mt mu l mv mw">// jest/mock/mockRouter.jsx</span><span id="4113" class="ms lb in mo b gy ni mu l mv mw">import { Router } from 'react-router-dom'<br/>import { createBrowserHistory } from 'history'</span><span id="a27a" class="ms lb in mo b gy ni mu l mv mw">const MockRouter = ({ children }) =&gt; {<br/>  return (<br/>    &lt;Router history={createBrowserHistory()}&gt;<br/>      { children }<br/>    &lt;/Router&gt;<br/>  )<br/>}</span><span id="3a08" class="ms lb in mo b gy ni mu l mv mw">MockRouter.propTypes = {<br/>  children: PropTypes.node  // prop for sending in the components that you want to render<br/>}</span><span id="5a44" class="ms lb in mo b gy ni mu l mv mw">export default MockRouter</span></pre><h2 id="7f27" class="ms lb in bd lc mx my dn lg mz na dp lk kg nb nc lo kk nd ne ls ko nf ng lw nh bi translated">模拟导入模块</h2><p id="3b9a" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在某些情况下，有必要在测试中模拟模块(包括来自npm的包),下面是这样做的一个例子:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7978" class="ms lb in mo b gy mt mu l mv mw">import { render, cleanup } from '@testing-library/react'<br/>import MainPage from '../MainPage'</span><span id="06a8" class="ms lb in mo b gy ni mu l mv mw">// *** must write it in the global scope ***<br/>// mock the react-router-dom library<br/>// and replace the useHistory attribute of the module<br/>jest.mock('react-router-dom', () =&gt; ({<br/>  useHistory: () =&gt; ({<br/>    push: jest.fn()<br/>  })<br/>}))</span><span id="4f43" class="ms lb in mo b gy ni mu l mv mw">afterEach(cleanup)<br/>beforeEach(() =&gt; {<br/>  // ...<br/>})</span><span id="6c0d" class="ms lb in mo b gy ni mu l mv mw">describe('MainPage.jsx', () =&gt; {<br/>  // ...<br/>}</span></pre><p id="b0ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在<a class="ae md" href="https://jestjs.io/docs/mock-functions" rel="noopener ugc nofollow" target="_blank">官方文档</a>中阅读更多关于模拟函数的内容，稍后你会看到更多的例子。</p><h1 id="f919" class="la lb in bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx bi translated">考什么？</h1><p id="7102" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">react-testing-library的创建者(Kent C. Dodds)创建了一个工具来帮助开发人员避免测试<a class="ae md" href="https://kentcdodds.com/blog/testing-implementation-details" rel="noopener ugc nofollow" target="_blank">实现细节</a>，这样我们就不会在试图重构组件时忙于修复测试用例。</p><p id="f2dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着您应该专注于测试组件如何与用户交互。编写测试时，假设用户正在使用组件，并测试组件是否反应正常。因此，了解如何做到以下几点至关重要:</p><p id="0b59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 1。模仿用户</strong></p><p id="dba3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用<a class="ae md" href="https://testing-library.com/docs/ecosystem-user-event/" rel="noopener ugc nofollow" target="_blank">@ testing-library/user-event</a>库来模拟一个用户。对于用户事件不能实现的事件，使用@testing-library/react库中的fireEvent。</p><p id="21fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。查询DOM </strong></p><ul class=""><li id="e3b8" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">来自屏幕对象的查询</li></ul><p id="4e56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用render方法呈现组件后，可以使用screen对象访问结果，并使用它进行查询。你可以在官方的<a class="ae md" href="https://testing-library.com/docs/react-testing-library/cheatsheet/" rel="noopener ugc nofollow" target="_blank">备忘单</a>中读到更多相关信息。(有一张顺手的桌子！)</p><ul class=""><li id="a098" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">按类名查询</li></ul><p id="a0ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">screen对象没有提供按类名查询的方法，但还是有办法做到的；您可以使用容器属性获取根DOM，然后调用getElementsByClassName方法:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="5eee" class="ms lb in mo b gy mt mu l mv mw">import { render } from '@testing-library/react'</span><span id="2ce8" class="ms lb in mo b gy ni mu l mv mw">it('some description', () =&gt; {<br/>  const screen = render(&lt;Component /&gt;)<br/>  screen.container.getElementsByClassName('&lt;the_target_class_name&gt;')<br/>}</span></pre><h1 id="e408" class="la lb in bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx bi translated">情节</h1><p id="9872" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated"><strong class="jx io"> 1。一个简单的组件</strong></p><ul class=""><li id="2ad2" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">根据道具渲染</li></ul><p id="4049" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你要测试的组件仅仅因为它们的属性不同而不同，你要做的就是编写向组件发送不同属性的测试并检查。</p><p id="b4bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使它更简单，在一般情况下，我将只编写测试用例:</p><p id="ed1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">a.所有具有真实价值的道具</p><p id="6f7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">b.所有有虚假价值的道具</p><p id="0a10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并使用react-test-renderer库对这些场景进行快照测试，以节省测试这些细节的查询时间。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b785" class="ms lb in mo b gy mt mu l mv mw">import { cleanup } from '@testing-library/react'<br/>import renderer from 'react-test-renderer'  // renderer for snapshot test<br/>import UserInfo from '../UserInfo'</span><span id="1100" class="ms lb in mo b gy ni mu l mv mw">afterEach(cleanup)</span><span id="2894" class="ms lb in mo b gy ni mu l mv mw">describe('UserInfo.jsx', () =&gt; {<br/>  it('snapshot renders correctly, truthy values', () =&gt; {<br/>    const tree = renderer<br/>      .create(&lt;UserInfo<br/>          userId="202200001"<br/>          userName="Test User"<br/>          userImg="./test_user.img"<br/>        /&gt;)<br/>      .toJSON()<br/>    expect(tree).toMatchSnapshot()<br/>  })<br/>  it('snapshot renders correctly, falsy values', () =&gt; {<br/>    const tree = renderer<br/>      .create(&lt;UserInfo/&gt;)<br/>      .toJSON()<br/>    expect(tree).toMatchSnapshot()<br/>  })<br/>})</span></pre><ul class=""><li id="4238" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">根据缩减器渲染</li></ul><p id="ff45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">测试因减速器状态而异的组件与最后一种情况非常相似。您可以将reducers的状态模拟成特定的值，并呈现组件。然后，同样，您可以通过执行一些查询或快照测试来检查结果。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1186" class="ms lb in mo b gy mt mu l mv mw">import { cleanup } from '@testing-library/react'<br/>import renderer from 'react-test-renderer'<br/>import MockProvider from '@jest/mock/MockProvider'<br/>import createMockStore from '@jest/mock/store/createMockStore'<br/>import UserInfoV2 from '../UserInfoV2'</span><span id="0774" class="ms lb in mo b gy ni mu l mv mw">afterEach(cleanup)</span><span id="14d1" class="ms lb in mo b gy ni mu l mv mw">describe('UserInfoV2.jsx', () =&gt; {<br/>  it('snapshot renders correctly, truthy values', () =&gt; {<br/>    const store = createMockStore({<br/>      userInfo: {<br/>        userId: '202200001',<br/>        userName: 'Test User',<br/>        userImg: './test_user.img'<br/>      }<br/>    })<br/>    const tree = renderer<br/>      .create(&lt;MockProvider mockStore={store}&gt;<br/>        &lt;UserInfoV2 /&gt;<br/>      &lt;/MockProvider&gt;)<br/>      .toJSON()<br/>    expect(tree).toMatchSnapshot()<br/>  })<br/>  it('snapshot renders correctly, falsy values', () =&gt; {<br/>    const store = createMockStore({<br/>      userInfo: {<br/>        userId: '',<br/>        userName: '',<br/>        userImg: ''<br/>      }<br/>    })<br/>    const tree = renderer<br/>      .create(&lt;MockProvider mockStore={store}&gt;<br/>        &lt;UserInfoV2 /&gt;<br/>      &lt;/MockProvider&gt;)<br/>      .toJSON()<br/>    expect(tree).toMatchSnapshot()<br/>  })<br/>})</span></pre><p id="ac6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。具有间隔和承诺的组件</strong></p><p id="0daf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果有什么事情需要等待一段时间才能完成，您应该尝试waitFor和findBy查询。你可以很容易地在网上找到例子，所以我将跳过细节。</p><p id="a50c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。带挂钩的组件</strong></p><p id="940c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如在模仿部分提到的，我们可以使用jest来模仿所有导入的模块。钩子也是一样的！</p><ul class=""><li id="b721" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">SPA路由参数</li></ul><p id="998c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，假设有一个使用react-router-dom库中的useParams钩子的数据页面组件:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="63be" class="ms lb in mo b gy mt mu l mv mw">import { useParams } from 'react-router-dom'</span><span id="3065" class="ms lb in mo b gy ni mu l mv mw">const DataPage = (props) =&gt; {<br/>  const { dataId = '' } = useParams()<br/>  const data = {<br/>    data1: 'this is the content form data 1',<br/>    data2: 'this is the content form data 2',<br/>  }<br/>  return (<br/>    &lt;div className="data-page"&gt;<br/>      { <br/>        data[dataId]<br/>          ? &lt;div className="data-page__content"&gt;{data[dataId]}&lt;/div&gt;<br/>          : &lt;div className="data-page__not-found"&gt;content not found&lt;/div&gt;<br/>      }<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="15f4" class="ms lb in mo b gy ni mu l mv mw">export default DataPage</span></pre><p id="87d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一种模拟useParams将返回的值的方法:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="8c9d" class="ms lb in mo b gy mt mu l mv mw">import { screen, render, cleanup } from '@testing-library/react'<br/>import DataPage from '../DataPage'</span><span id="c145" class="ms lb in mo b gy ni mu l mv mw">afterEach(cleanup)</span><span id="1666" class="ms lb in mo b gy ni mu l mv mw">jest.mock('react-router-dom', () =&gt; ({<br/>  ...jest.requireActual('react-router-dom'),<br/>  useParams: () =&gt; ({<br/>    dataId: 'data1'<br/>  })<br/>}))</span><span id="7bb0" class="ms lb in mo b gy ni mu l mv mw">describe('DataPage.jsx', () =&gt; {<br/>  it('render the content if data exist', () =&gt; {<br/>    render(&lt;DataPage /&gt;)<br/>    screen.getByText('this is the content form data 1')<br/>  })<br/>})</span></pre><ul class=""><li id="626d" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">自定义挂钩返回数组中的函数</li></ul><p id="3cba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设有这样一个组件:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="a115" class="ms lb in mo b gy mt mu l mv mw">import { useSearchData } from '@js/hooks/searchData'</span><span id="6391" class="ms lb in mo b gy ni mu l mv mw">const SearchPage = (props) =&gt; {<br/>  const [search] = useSearchData() // the custom hook<br/>  const onSearchButtonClick = () =&gt; {<br/>    search()<br/>  }</span><span id="6981" class="ms lb in mo b gy ni mu l mv mw">return (<br/>    &lt;div className="search-page"&gt;<br/>      &lt;button onClick={onSearchButtonClick}&gt;search&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="4b01" class="ms lb in mo b gy ni mu l mv mw">export default SearchPage</span></pre><p id="0e82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以用这种方式模仿自定义挂钩:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="67ae" class="ms lb in mo b gy mt mu l mv mw">import { screen, render, cleanup } from '@testing-library/react'<br/>import userEvent from '@testing-library/user-event'<br/>import SearchPage from '../SearchPage'<br/>import { useSearchData } from '@js/hooks/searchData'</span><span id="686a" class="ms lb in mo b gy ni mu l mv mw">afterEach(cleanup)</span><span id="7904" class="ms lb in mo b gy ni mu l mv mw">jest.mock('@js/hooks/searchData', () =&gt; {<br/>  const spy = jest.fn()<br/>  return {<br/>    useSearchData: () =&gt; {<br/>      return [spy]<br/>    }<br/>  }<br/>})</span><span id="32c2" class="ms lb in mo b gy ni mu l mv mw">describe('SearchPage.jsx', () =&gt; {<br/>  it('render the content if data exist', () =&gt; {<br/>    render(&lt;SearchPage /&gt;)<br/>    // initialize the imported function,<br/>    // and get the reference of the spy<br/>    const [search] = useSearchData()<br/>    userEvent.click(screen.getByText('search'))<br/>    expect(search).toHaveBeenCalled()<br/>  })<br/>})</span></pre><p id="e0d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。带有导入模块的组件</strong></p><p id="0d4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们更深入地研究测试数据页面组件的情况。在前面的例子中，我们只能模拟一次useParams的实现。</p><p id="d0cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果希望保持可操作性，可以先模拟整个模块，在呈现组件之前使用mockImplementationOnce或mockReturnValueOnce方法。通过这样做，您可以为每个测试用例模拟函数的实现或返回值。</p><p id="5a86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，如果组件中的代码依赖于函数的结果，模仿函数的实现可以让我们避免错误。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="5830" class="ms lb in mo b gy mt mu l mv mw">import { screen, render, cleanup } from '<a class="ae md" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>-library/react'<br/>import { useParams } from 'react-router-dom'<br/>import DataPage from '../DataPage'</span><span id="d68b" class="ms lb in mo b gy ni mu l mv mw">afterEach(cleanup)</span><span id="93fb" class="ms lb in mo b gy ni mu l mv mw">jest.mock('react-router-dom', () =&gt; {<br/>  const spy = jest.fn()<br/>  return {<br/>    ...jest.requireActual('react-router-dom'),<br/>    useParams: spy<br/>  }<br/>})</span><span id="97ae" class="ms lb in mo b gy ni mu l mv mw">describe('DataPage.jsx', () =&gt; {<br/>  it('render the content if data exist', () =&gt; {<br/>    useParams.mockImplementationOnce(() =&gt; ({<br/>      dataId: 'data1'<br/>    }))<br/>    render(&lt;DataPage /&gt;)<br/>    screen.getByText('this is the content form data 1')<br/>  })<br/>  it('render the hint if data does not exist', () =&gt; {<br/>    useParams.mockReturnValueOnce({<br/>      dataId: ''<br/>    })<br/>    render(&lt;DataPage /&gt;)<br/>    screen.getByText('content not found')<br/>  })<br/>})</span></pre><p id="a559" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，您可以模仿整个库并继续:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9e12" class="ms lb in mo b gy mt mu l mv mw">jest.mock('react-router-dom')</span></pre><p id="f02d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果我们模仿整个react-router-dom库，由于某种原因，useParams属性将变得未定义，所以我使用上一个例子中的方法。</p><p id="6fe0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 5。分派动作的组件</strong></p><p id="656b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管指南告诉我们要避免测试实现细节，但我仍然认为测试组件分派的动作是必要的。我关心的事情是:</p><ul class=""><li id="a190" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated"><strong class="jx io">时机:</strong>是否在正确的时间以正确的行动调度火灾？</li><li id="5575" class="nj nk in jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><strong class="jx io">参数:</strong>发送给动作的参数是否正确？</li></ul><p id="0ae9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上，您还可以测试那些导入的函数(包括导入的模块、动作和库)的计时和参数</p><p id="bfd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可能是一个奇怪的例子，但我试图在一个组件中涵盖更广泛的场景:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3bdc" class="ms lb in mo b gy mt mu l mv mw">import { useEffect } from 'react'<br/>import { useDispatch, useSelector } from 'react-redux'<br/>import {<br/>  setSettings,  // a plain object action<br/>  startGetSettings  // a redux-thunk action<br/>} from '@js/actions'</span><span id="f894" class="ms lb in mo b gy ni mu l mv mw">const DemoPage = (props) =&gt; {<br/>  const dispatch = useDispatch()<br/>  const { title = '' } = useSelector(state =&gt; state.settings)</span><span id="4a07" class="ms lb in mo b gy ni mu l mv mw">  useEffect(() =&gt; {<br/>    dispatch(setSettings({<br/>      title: 'Title set when the component mount.'<br/>    }))<br/>  }, [])</span><span id="36b8" class="ms lb in mo b gy ni mu l mv mw">  const onFetchClick = () =&gt; {<br/>    dispatch(startGetSettings({ foo: 'bar' }))<br/>  }</span><span id="e9e0" class="ms lb in mo b gy ni mu l mv mw">  return (<br/>    &lt;div className="demo-page"&gt;<br/>      &lt;h1&gt;{title}&lt;/h1&gt;<br/>      &lt;button onClick={onFetchClick}&gt;fetch settings&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="b3bb" class="ms lb in mo b gy ni mu l mv mw">export default DemoPage</span></pre><p id="877a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们测试一个返回普通对象的动作，这是非常简单的:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1126" class="ms lb in mo b gy mt mu l mv mw">it('should dispatch setSettings action when the component mount', () =&gt; {<br/>  const mockStore = createMockStore({<br/>    settings: {}<br/>  })<br/>  render(&lt;MockProvider mockStore={mockStore}&gt;<br/>    &lt;DemoPage /&gt;<br/>  &lt;/MockProvider&gt;)<br/>  // the Nth element from the result of the getActions method<br/>  // will be the object sent by Nth dispatch.<br/>  expect(mockStore.getActions()[0].type).toBe(actions.SET_SETTINGS)<br/>  expect(mockStore.getActions()[0].data.title).toBe('Title set when the component mount.')<br/>  expect(mockStore.dispatch).toHaveBeenCalledTimes(1)<br/>})</span></pre><p id="e8df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，如果你正在测试一个redux-thunk动作，这将是非常难以管理的。因为动作应该返回一个对象，所以如果你把返回值当作一个承诺，就会导致一个错误。</p><p id="cbed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我决定把这些动作模仿成一般的动作:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b618" class="ms lb in mo b gy mt mu l mv mw">jest.mock('@js/actions', () =&gt; ({<br/>  // keep the functionality of the action module<br/>  ...jest.requireActual('@js/actions'),<br/>  // replace the thunk-action into a plain object action,<br/>  // to test the received parameters.<br/>  startGetSettings: parameters =&gt; ({ type: 'MOCK', parameters })<br/>}))</span></pre><p id="3988" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并用getActions方法的结果验证时间和参数:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b0a8" class="ms lb in mo b gy mt mu l mv mw">it('should dispatch startGetSettings action when user click the button', async () =&gt; {<br/>  const mockStore = createMockStore({<br/>    settings: {}<br/>  })<br/>  render(&lt;MockProvider mockStore={mockStore}&gt;<br/>    &lt;DemoPage /&gt;<br/>  &lt;/MockProvider&gt;)<br/>  userEvent.click(screen.getByText('fetch settings'))<br/>  await waitFor(() =&gt; {<br/>    expect(mockStore.getActions()[1].parameters)<br/>      .toEqual({ foo: 'bar' })<br/>    expect(mockStore.dispatch).toHaveBeenCalledTimes(2)<br/>  })<br/>})</span></pre><p id="c360" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的关键点是定义边界。如果您正在为一个组件编写测试，那么您应该关注该组件中的逻辑。测试那些导入函数的时间和参数就足够了。最好创建相关的测试文件来测试这些部分的细节。</p><h1 id="759f" class="la lb in bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx bi translated">结局</h1><p id="df62" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">我想每个人都有自己编写测试的方式，这就是我实现自己的方式。欢迎在评论中留下你的想法，这样我们都能成为更好的开发者🤓</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="aab7" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">阅读更多关于单元测试的内容</h1><ul class=""><li id="87ce" class="nj nk in jx b jy ly kc lz kg nx kk ny ko nz ks no np nq nr bi translated"><a class="ae md" href="https://medium.com/@tabsteveyang/setup-jest-and-react-testing-library-for-unit-testing-9be43df32fd5" rel="noopener">为单元测试建立Jest和React测试库</a></li></ul><h1 id="d6b2" class="la lb in bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx bi translated">参考</h1><ol class=""><li id="06c0" class="nj nk in jx b jy ly kc lz kg nx kk ny ko nz ks oa np nq nr bi translated"><a class="ae md" href="https://jestjs.io/docs/mock-functions" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/mock-functions</a></li><li id="adbc" class="nj nk in jx b jy ns kc nt kg nu kk nv ko nw ks oa np nq nr bi translated"><a class="ae md" href="https://kentcdodds.com/blog/testing-implementation-details" rel="noopener ugc nofollow" target="_blank">https://kentcdodds.com/blog/testing-implementation-details</a></li><li id="36f0" class="nj nk in jx b jy ns kc nt kg nu kk nv ko nw ks oa np nq nr bi translated">https://testing-library.com/docs/ecosystem-user-event/<a class="ae md" href="https://testing-library.com/docs/ecosystem-user-event/" rel="noopener ugc nofollow" target="_blank"/></li><li id="587d" class="nj nk in jx b jy ns kc nt kg nu kk nv ko nw ks oa np nq nr bi translated"><a class="ae md" href="https://testing-library.com/docs/react-testing-library/cheatsheet/" rel="noopener ugc nofollow" target="_blank">https://testing-library . com/docs/react-testing-library/cheat sheet/</a></li><li id="4a74" class="nj nk in jx b jy ns kc nt kg nu kk nv ko nw ks oa np nq nr bi translated"><a class="ae md" href="https://www.codecademy.com/learn/learn-react-testing/modules/react-testing-library/cheatsheet" rel="noopener ugc nofollow" target="_blank">https://www . codecademy . com/learn/learn-react-testing/modules/react-testing-library/cheat sheet</a></li></ol><p id="7f21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ob">更多内容看</em> <a class="ae md" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ob">说白了。报名参加我们的</em> <a class="ae md" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ob">免费周报</em> </strong> </a> <em class="ob">。在我们的</em> <a class="ae md" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ob">社区不和谐</em> </strong> </a> <em class="ob">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>