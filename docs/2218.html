<html>
<head>
<title>Proper Data Service Architecture in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中合适的数据服务架构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/proper-data-service-architecture-in-react-b8348e365e4a?source=collection_archive---------5-----------------------#2022-05-23">https://javascript.plainenglish.io/proper-data-service-architecture-in-react-b8348e365e4a?source=collection_archive---------5-----------------------#2022-05-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ff94" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何为React世界中的变化做好准备</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/24e93f9d7976c9cae824a224e892a07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LpKt8tm1Kl0cpqbGmc3M4w.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@ryanquintal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ryan Quintal</a> on <a class="ae ks" href="https://unsplash.com/s/photos/building-blocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ac59" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很多时候，开发人员努力构建合适的数据服务。一开始，我们得到了React类服务→它很快过渡到Redux和Sagas，以轻松处理副作用并对加载状态变化做出“反应”,但在学习和理解生命周期中发生的事情时，它变得势不可挡，然后hooks通过magic useEffect()进入游戏，当我们开始使用它时，像<a class="ae ks" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React Query </a>这样新的更智能的库出现了。我们如何为React world中的这些变化准备我们的应用程序？我们能做到既便宜又安全，不需要重写一半的代码库吗？在这篇文章中，我将向您展示一个简单的方法，如何为变化做好准备。</p><h1 id="0982" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">耦合问题</h1><p id="224f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">先说耦合问题。我这么说是什么意思？上述所有问题都来自于对所提到的库的错误使用。我并不是说这些技术中的任何一种是好的或坏的，可能所有这些技术在某一点上都是好的，真正的问题是这些库的使用！我知道，我知道……每个人都在阅读文档并尽力而为，但真正的问题是这些技术被直接用于应用程序——这归结为耦合问题。</p><p id="1a7f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们来看一个将Redux Saga重写为ReactQuery的例子，我们有这样的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d5f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以想象你有多少地方和额外的reducer，actions，和sagas文件。所以现在你需要重构它——如果所有的代码都是像这样创建的——我们总是有<code class="fe mo mp mq mr b">data</code>，<code class="fe mo mp mq mr b">loading</code>,它是通过<code class="fe mo mp mq mr b">useSelector</code>直接从状态中获取的。我们可以开始认为它是非常通用的，我们可以编写一些codemod来更新它以实现一种新的数据服务方式(例如React Query)。但是我们都知道现实是不同的，一些开发者自己做了一些选择，例如<code class="fe mo mp mq mr b">useSelector(selectFunction)</code>等等。所有这些情况对于codemods来说都变得太复杂了，所以我们最终只能手动重写所有的地方。所以我们需要做的是把这段代码改成:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="99e5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们检查完所有的文件，最终进行重构的时候，我们就可以开香槟庆祝了(当然前提是我们的老板不会问我们为什么在一些看不见的重构上花了很多时间)。但是后来……React Query改变了他们的API，现在<code class="fe mo mp mq mr b">useQuery</code> hook返回一个数组，而不是一个对象，例如<code class="fe mo mp mq mr b">[data, loading, error]</code>——好吧，这并不坏，我们仍然可以创建codemod，当然在这之前我们需要向我们的老板解释，并要求时间进行更新，因为我们所有人都想使用更新的库。但是我们都知道JS世界的变化有多快，所以我们可以假设新的“超级酷”库会出现。然后我们需要再次去找我们的老板…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/934efdddc1c3003353244430484a803c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJedc_HjuB8zjzjFRpSN5g.png"/></div></div></figure><p id="4fcc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">求时间重构。</p><h1 id="547d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">解决办法</h1><p id="5fbb" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">也许你能想到一个解决办法，我有一个非常简单的办法——让我们创建自己的API并抽象出库。这么简单对吧？让我们想象一下，如果我们有一个带有全公司API的服务挂钩包，那么重构会有多简单？让我们在示例中这样做，并让我们将Redux代码转换为自定义服务挂钩:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="74e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将这个逻辑移到一个单独的钩子上非常重要，更重要的是始终保持相同的输出形状——因为这将节省我们很多时间，让我们在组件中使用它:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="cae9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们想从Redux迁移到React Query，你可以看到我们可以很容易地做到这一点，因为我们唯一需要改变的是我们的服务挂钩:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="79a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而且组件看起来也是一样的，没有必要对组件做改动！唯一需要改变的是我们的服务挂钩。</p><p id="7ad3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如您所看到的，这真的很酷，因为无论React Query API是否会改变，或者我们是否希望从一种技术迁移到另一种技术，我们都只有一层需要测试和重写。此外，你可以想象一个团队交付服务，第二个团队只是从服务库中使用它，这真的很容易，因为我们总是知道我们将拥有什么API，从开发人员的角度来看，我们不在乎在引擎盖下使用什么——是React Query，Redux Saga，还是完全不同的东西。</p><h1 id="4582" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">摘要</h1><p id="1447" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我向您展示了代码迁移问题的一个非常简单的解决方案——我们都知道，有时候抽象可能会让人不知所措，而且要明确的是，它并不是适用于所有情况的模式。创建一个服务挂钩包并公开一个API是一个经过充分测试的模式(重要的是，这个API应该像我们的合同一样，不应该改变)。由于这一点，我们只有一层要测试，我们可以将整个公司的爆炸半径降至最低。</p><p id="9c30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以在<a class="ae ks" href="https://twitter.com/novakPe_" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，感谢阅读！</p><p id="850a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mt">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mt">plain English . io</em></strong></a><em class="mt">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mt">免费周报</em> </strong> </a> <em class="mt">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mt">Twitter</em></strong></a><em class="mt">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mt">LinkedIn</em></strong></a><em class="mt">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mt">社区不和谐</em> </strong> </a> <em class="mt">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mt">人才集体</em> </strong> </a> <em class="mt">。</em></p></div></div>    
</body>
</html>