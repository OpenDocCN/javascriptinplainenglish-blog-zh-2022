<html>
<head>
<title>Data Structures and Algorithms: Generate Parentheses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构和算法:生成括号</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-structures-and-algorithms-generate-parentheses-768e3a77a22c?source=collection_archive---------0-----------------------#2022-06-05">https://javascript.plainenglish.io/data-structures-and-algorithms-generate-parentheses-768e3a77a22c?source=collection_archive---------0-----------------------#2022-06-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a776" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">写一个生成括号的算法——常见的面试问题。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/19e9d30f77f57a8f419feff3bbe8e56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fLAWkWD7AORKZCon"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8b10" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为工作面试学习数据结构和算法问题可能很难。这些问题都是废话，所以要熟悉哪种类型似乎是随机的。我在不同的工作面试中多次遇到过这样的问题:</p><p id="dabf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">给定<code class="fe lp lq lr ls b">n</code>对括号，编写一个函数来<em class="lt">生成所有格式良好的括号的组合。</em></p><p id="7c00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，输入3将导致:</p><p id="3ddb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi">[“((()))”, “(()())”, “(())()”, “()(())”, “()()()”]</p><p id="f3b0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输入为3时，“格式良好”意味着每个排列将有三个左“(”和三个右“)”括号。让我们看看如何解决这个问题。</p><p id="4f25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，让我们看看一些约束条件。我们已经确定了什么是格式良好的括号。我们也知道右括号不应该出现在左括号之前。左括号和右括号的数量应该相等，并且它们的数量不应大于<code class="fe lp lq lr ls b">n</code>。</p><p id="1997" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑到这些限制，让我们创建一个基本案例，其中的条件大致描绘了需要实现的目标。</p><ul class=""><li id="7691" class="lu lv in kv b kw kx kz la lc lw lg lx lk ly lo lz ma mb mc bi translated">需要存储有效的排列。因此，需要一个数组。我们称它为<code class="fe lp lq lr ls b">result</code>。</li><li id="c4cf" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">我们的函数应该检查创建的左括号和右括号的数量是否等于<code class="fe lp lq lr ls b">n</code>。为了保持跟踪，我们将在每次使用左括号和右括号时增加一个计数。如果等于<code class="fe lp lq lr ls b">n</code>，将该排列添加到数组中。如果没有，则添加另一个左括号并增加其计数。然后检查左括号的数量是否大于右括号的数量。如果是，我们将添加另一个右括号并增加它的计数。</li><li id="e055" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">我们需要确保在<code class="fe lp lq lr ls b">result</code>数组中没有任何重复的排列</li></ul><p id="7d78" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看看上面的大纲，重复和迭代的数量是使用递归的一个很好的例子。虽然我们可以从字面上找到每一个排列，然后过滤掉任何重复的，这将是低效的。我们将采用以下方法来避免重复并仅生成有效的排列:</p><ol class=""><li id="df3a" class="lu lv in kv b kw kx kz la lc lw lg lx lk ly lo mi ma mb mc bi translated">如果左括号的数量小于<code class="fe lp lq lr ls b">n</code>，则递归调用函数，同时增加一个左括号。</li><li id="99cb" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo mi ma mb mc bi translated">如果右括号的数量少于左括号，则递归调用该函数，同时添加一个右括号。</li></ol><p id="7165" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们实际上将创建两个函数。一个递归函数将产生所有的排列。它将接受<code class="fe lp lq lr ls b">result</code>数组、括号字符串、括号计数和输入<code class="fe lp lq lr ls b">n</code>。另一个函数将输入作为参数，创建<code class="fe lp lq lr ls b">result</code>数组，对递归函数进行初始调用以收集所有排列并返回数组。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="17d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们按照这个输入为2的代码。</p><p id="2f50" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">genParentheses(2)</code></p><p id="0626" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">创建了<code class="fe lp lq lr ls b">result</code>数组，然后调用递归函数。</p><p id="a146" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">getParens(result, "", 0, 0, 2)</code></p><p id="fff7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在关注函数调用的这一部分，因为这是理解其工作原理的关键:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7937" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本例中，<code class="fe lp lq lr ls b">n</code>为2，if语句实际上创建了两个分支。</p><p id="8322" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">分支1 </strong></p><ul class=""><li id="fa21" class="lu lv in kv b kw kx kz la lc lw lg lx lk ly lo lz ma mb mc bi translated">检查<code class="fe lp lq lr ls b">open</code>的值，当前为0，递归调用<code class="fe lp lq lr ls b">genParens</code>。</li><li id="0afb" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">"("被添加到字符串<code class="fe lp lq lr ls b">s</code>并且<code class="fe lp lq lr ls b">open</code>增加到1。</li><li id="346b" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">再次检查<code class="fe lp lq lr ls b">open</code>的值，该值现在为1。对<code class="fe lp lq lr ls b">genParens</code>进行另一次递归调用。</li><li id="006c" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">"("被添加到字符串<code class="fe lp lq lr ls b">s</code>中，现在等于<code class="fe lp lq lr ls b">"(("</code>。<code class="fe lp lq lr ls b">open</code>的值增加到2。</li><li id="b0d5" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated"><code class="fe lp lq lr ls b">open</code>的值现在与<code class="fe lp lq lr ls b">n</code>相同，不再触发第一个if语句。</li><li id="7d6c" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">转到第二个if语句，<code class="fe lp lq lr ls b">close</code>当前处于小于<code class="fe lp lq lr ls b">open</code>的0，因此对<code class="fe lp lq lr ls b">getParens</code>进行递归调用。</li><li id="3d6b" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">”)加到<code class="fe lp lq lr ls b">s</code>上，现在等于<code class="fe lp lq lr ls b">"(()"</code>。<code class="fe lp lq lr ls b">close </code>现在增加到1。</li><li id="8df3" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated"><code class="fe lp lq lr ls b">close</code>为1，仍然小于<code class="fe lp lq lr ls b">open</code>，因此再次调用<code class="fe lp lq lr ls b">getParens</code>。</li><li id="54aa" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">”)加到<code class="fe lp lq lr ls b">s</code>上，现在等于<code class="fe lp lq lr ls b">"(())"</code>，而<code class="fe lp lq lr ls b">close</code>增加到2。</li><li id="1a91" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated"><code class="fe lp lq lr ls b">open</code>和<code class="fe lp lq lr ls b">close</code>现在都等于<code class="fe lp lq lr ls b">n</code>。字符串<code class="fe lp lq lr ls b">s</code>被添加到数组<code class="fe lp lq lr ls b">result</code>中。</li></ul><p id="64c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">分支2 </strong></p><ul class=""><li id="f6e9" class="lu lv in kv b kw kx kz la lc lw lg lx lk ly lo lz ma mb mc bi translated">在对<code class="fe lp lq lr ls b">getParens</code>的第一次递归调用中，当<code class="fe lp lq lr ls b">s</code>当前等于<code class="fe lp lq lr ls b">"("</code>时，<code class="fe lp lq lr ls b">close</code>的值小于<code class="fe lp lq lr ls b">open</code>，因此它递归并开始第二个分支。</li><li id="ed50" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated">”)加到<code class="fe lp lq lr ls b">s</code>，现在等于<code class="fe lp lq lr ls b">"()"</code>，<code class="fe lp lq lr ls b">close</code>现在等于1。</li><li id="77bc" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated"><code class="fe lp lq lr ls b">open</code>此时为1，因此它递归，将“(”添加到<code class="fe lp lq lr ls b">s</code>，并增加到2。</li><li id="b0ad" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated"><code class="fe lp lq lr ls b">close</code>现在再次小于<code class="fe lp lq lr ls b">open</code>，所以它递归，将“)”加到<code class="fe lp lq lr ls b">s</code>，并且也增加到2。</li><li id="e27d" class="lu lv in kv b kw md kz me lc mf lg mg lk mh lo lz ma mb mc bi translated"><code class="fe lp lq lr ls b">s</code>现为<code class="fe lp lq lr ls b">"()()"</code>。<code class="fe lp lq lr ls b">open</code>和<code class="fe lp lq lr ls b">close</code>都等于<code class="fe lp lq lr ls b">n</code>，所以<code class="fe lp lq lr ls b">s</code>被添加到数组<code class="fe lp lq lr ls b">result</code>中。</li></ul><p id="901b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这两个分支现在都满足了停止递归的条件。数组<code class="fe lp lq lr ls b">result</code>被返回，看起来像这样:<code class="fe lp lq lr ls b">["(())", "()()"]</code></p><p id="4de0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输入值越高，获得所有不同排列的分支就越多。最终结果返回格式良好且唯一的括号组合。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d06d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望这有所帮助。感谢阅读。下次见！</p><p id="1906" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lt">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lt">说白了就是</em> </strong> </a> <em class="lt">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lt">免费每周简讯</em> </strong> </a> <em class="lt">。关注我们</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lt">推特</em> </strong> </a> <em class="lt">和</em><strong class="kv io"><em class="lt"/></strong><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lt">LinkedIn</em></strong></a><em class="lt">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lt">社区不和谐</em> </strong> </a> <em class="lt">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lt">人才集体</em> </strong> </a> <em class="lt">。</em></p></div></div>    
</body>
</html>