<html>
<head>
<title>10 JavaScript Tricks Front End Developers Should Know in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年前端开发人员应该知道的10个JavaScript技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-javascript-tricks-front-end-developers-should-know-in-2022-ee6c8cb8767c?source=collection_archive---------5-----------------------#2022-08-03">https://javascript.plainenglish.io/10-javascript-tricks-front-end-developers-should-know-in-2022-ee6c8cb8767c?source=collection_archive---------5-----------------------#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d5b6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这些技巧有助于提高您的JavaScript开发效率。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/693eb1914047e70365c0d645d742fcb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8yqiV725HrmYJVRI"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/es/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="135f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">你知道<em class="ls"> 0的值吗？？1 </em> </strong></p><p id="06ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你好！今天我们将讨论一些你应该在2022年了解的新功能！</p><p id="848d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在前端发展很快，各种技术和框架层出不穷，百花齐放，很多人都在喊学不下去了！JavaScript是主要的前端语言，虽然它发展很快，每年都有新的功能出现，但JavaScript开发人员发展更快，因为许多相对较新的功能采用率很高！</p><p id="437e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是一些高采用率的新功能和2022年你应该知道的10个JS hacks。</p><h2 id="eea5" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated"><strong class="ak"> 1。？？</strong></h2><p id="bd93" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="ky ir">使用？？而不是||在将值返回到右边之前，确定运算符左边的值是null还是未定义。</strong> <br/>那个？？运算符是由ES2020引入的，也称为Nullish合并运算符。</p><p id="f3f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其行为类似于||但更严格。</p><p id="5ca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">||运算符将左侧后面的值作为空字符串或false值(如false或0)返回。那。？运算符左侧必须为空或未定义，才能在右侧返回值。所以0 || 1导致1和0？？1产生0。</p><p id="e017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/066643c147aa2e8fbc0c44bd30541443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ybc6SVyL_xMVxOrBng1Tlw.png"/></div></div></figure><div class="mu mv gp gr mw mx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">零化合并算子(？？)- JavaScript | MDN</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">早些时候，当一个人想给一个变量赋一个默认值时，一种常见的模式是使用逻辑OR运算符…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.mozilla.org</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl kp mx"/></div></div></a></div><h2 id="2b89" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">2.<strong class="ak">？。</strong></h2><p id="7c07" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="ky ir">使用？。简化&amp; &amp;和三元运算符<br/>？。ES2020也推出了，称为可选链接运算符。</strong></p><p id="13f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">？。以确定左边的对象是空的还是未定义的。如果是，它不会向下运行并返回undefined。如果没有，它返回右边的值。</p><p id="3067" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:常见的写法</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/3acc6e31b8981ec0390eeccb561fcaf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gT96Rc1zd3MsLYnvMYDX2Q.png"/></div></div></figure><div class="mu mv gp gr mw mx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">可选链接(？。)- JavaScript | MDN</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">可选的链接操作符提供了一种在可能的情况下简化通过连接对象访问值的方法…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.mozilla.org</p></div></div><div class="ng l"><div class="nn l ni nj nk ng nl kp mx"/></div></div></a></div><h2 id="266f" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">3.使用动态导入()按需加载(优化静态导入)</h2><p id="7743" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们可以使用import语句初始化来加载依赖项。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="ce56" class="lt lu iq np b gy nt nu l nv nw">import defaultExport from “module-name”;<br/>import * as name from “module-name”;<br/>//…</span></pre><p id="e23d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是静态引入的导入语句依赖于<code class="fe nx ny nz np b">type=“module”</code>脚本标签，有时我们希望能够根据条件按需加载模块，例如以下场景:</p><ul class=""><li id="a6ff" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated">当静态导入的模块明显降低了代码的加载速度，被使用的可能性很低，或者不是立即需要时。</li><li id="7750" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">当很明显静态导入的模块占用了大量系统内存并且不太可能占用时。</li><li id="bf23" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">当导入的模块在加载时不存在，需要异步获取时。</li><li id="35ed" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">当导入的模块具有仅在某些条件被触发时才需要的副作用时。</li></ul><p id="cbd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们可以使用import()的动态引入，它可以像函数一样用在各种地方，并返回一个承诺。</p><p id="be1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用了两种形式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/d07a43814feb2288a4c6f3fb8e350bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epnmuYHUIZKUJXeHZmPHcw.png"/></div></div></figure><div class="mu mv gp gr mw mx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">导入- JavaScript | MDN</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">导入声明语法(从“某处”导入某物)是静态的，并且总是导致导入的…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.mozilla.org</p></div></div><div class="ng l"><div class="op l ni nj nk ng nl kp mx"/></div></div></a></div><h2 id="2b6f" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">4.用顶级await简化异步函数</h2><p id="b392" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">事实上，上面的代码对以下方面很有用:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="b06c" class="lt lu iq np b gy nt nu l nv nw">let module = await import(‘/modules/my-module.js’);</span></pre><p id="a4ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顶级await允许开发人员在异步函数之外使用await字段。</p><p id="2fc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/d1f319839d95b49d43bd30123e70be07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_Q1S5CLIZmSkrmHgoaqLg.png"/></div></div></figure><div class="mu mv gp gr mw mx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function*" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">异步函数*表达式- JavaScript | MDN</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">函数名。可以省略，在这种情况下，该函数是匿名的。该名称仅适用于该函数…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.mozilla.org</p></div></div><div class="ng l"><div class="or l ni nj nk ng nl kp mx"/></div></div></a></div><h2 id="4c5e" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">5.使用String.prototype.replaceAll()简化replace以一次替换所有子字符串。</h2><p id="59cf" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">String.prototype.replaceAll()类似于String.prototype.replace()。但是replace只替换子串的第一个匹配项，而replaceAll替换所有匹配项。</p><p id="b42d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，要用Ahui替换所有a:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/918270e9e92cb138d4e90bce7e794ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9sfSHykSXp1lcvCcVQfZw.png"/></div></div></figure><div class="mu mv gp gr mw mx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">string . prototype . replace all()-JavaScript | MDN</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">replaceAll()方法返回一个新字符串，其中所有匹配的模式都被替换。该模式可以…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.mozilla.org</p></div></div><div class="ng l"><div class="ot l ni nj nk ng nl kp mx"/></div></div></a></div><h2 id="c24d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">6.使用代理代替Object.defineProperty</h2><p id="6f82" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">为什么要用Proxy而不是Object.defineProperty？简单总结一下代理的几个优点:</p><ul class=""><li id="95f0" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated">代理是整个对象的代理，是一个对象，defineProperty只能代理某个属性。</li><li id="d64e" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">代理可以侦听添加到对象中的新属性，而Object.defineProperty不能。</li><li id="ffef" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">代理可以侦听数组的新更改，但Object.defineProperty不能。</li><li id="a812" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">如果对象内部的所有属性都要递归代理，那么Proxy只能在被调用时递归，而Object.definePropery需要一次完成所有的递归，这比Proxy更糟糕。</li><li id="2387" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">代理本质上是一个构造函数，它从头开始生成一个对象，并接受两个参数。</li><li id="6932" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">目标是要拦截的目标对象(代理)。</li><li id="13fc" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">处理程序用于定制拦截行为(13种)。</li></ul><p id="0cf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如响应式反应式的基本实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/d3997b1822e0c375bf7dbe0b2e9c99df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiJmksy2LX7D-APUCeD0Bw.png"/></div></div></figure><div class="mu mv gp gr mw mx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">代理- JavaScript | MDN</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">代理对象允许您创建一个可以用来代替原始对象的对象，但是它可能…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.mozilla.org</p></div></div><div class="ng l"><div class="ov l ni nj nk ng nl kp mx"/></div></div></a></div><h2 id="d203" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">7.Promise.any快速获得一组Promise实例中第一个实现的承诺。</h2><p id="1253" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">Promise.any将一组Promise实例作为参数。</p><ul class=""><li id="7b54" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated">一旦其中一个承诺成功，它就返回已经成功的承诺。</li><li id="d7e4" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">如果iterable对象集中的承诺都不成功，则返回一个失败的承诺和一个AggregateError类型的实例。<br/>推荐的写法:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="36b4" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">8.使用BigInt支持大整数计算问题</h2><p id="de18" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="ky ir"> ES2020引入了一种新的数据类型BigInt，用来表示任意位数的整数。</strong></p><p id="e878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了使用BigInt来声明大整数之外，您还可以使用后跟n的数字，其形式为:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="d6d4" class="lt lu iq np b gy nt nu l nv nw">1234 // ordinary integer<br/>1234n // BigInt</span></pre><p id="3f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要了解对BigInt数值运算的支持，以避免陷入这个陷阱。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/500812c5da3b62d555825854017d8802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iivJvf6jC6nFcR952Xg9dw.png"/></div></div></figure><div class="mu mv gp gr mw mx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">BigInt - JavaScript | MDN</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">一个bigint值，有时也叫做BigInt，是一个BigInt原语，通过在一个…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.mozilla.org</p></div></div><div class="ng l"><div class="ox l ni nj nk ng nl kp mx"/></div></div></a></div><h2 id="b0de" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">9.使用Array.prototype.at()简化arr.length</h2><p id="60cf" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="ky ir"> Array.prototype.at()取一个正整数或负整数作为参数来获取指定位置的成员</strong></p><p id="3f71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参数的正数表示向下的第一个数字，负数表示向下的第一个数字，这对数组末尾的元素非常方便。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/a99cfe30014c966282c4fc6671d86cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xD5slzTq7dQl5RFC89nBw.png"/></div></div></figure><div class="mu mv gp gr mw mx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">array . prototype . at()-JavaScript | MDN</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">at()方法接受一个整数值并返回该索引处的项目，允许使用正整数和负整数…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.mozilla.org</p></div></div><div class="ng l"><div class="oz l ni nj nk ng nl kp mx"/></div></div></a></div><h2 id="bedb" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">10.使用散列前缀#使类字段私有</h2><p id="9dde" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">类中由散列前缀#标记的字段将是私有的，不会被子类实例继承。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="c14f" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">最后</h2><p id="8b56" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">许多用户目前正在使用许多新功能，尤其是<strong class="ky ir">？？</strong>和<strong class="ky ir">？。</strong>和<strong class="ky ir">导入()</strong>引入；我想知道你用过哪些？</p><p id="9dfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，以上信息构成了文章的内容；如果有任何错误，请让我知道。</p><p id="a4a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">请关注我阅读更多优质文章。</strong></p></div><div class="ab cl pa pb hu pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="ij ik il im in"><p id="25fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。关注我们上</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">推特</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">LinkedIn</em></strong></a><em class="ls"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">不和谐</em> </strong> </a> <em class="ls">。</em></strong></a></p></div></div>    
</body>
</html>