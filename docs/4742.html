<html>
<head>
<title>NextAuth.js: Authentication API for Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">next auth . js:next . js的身份验证API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nextauth-js-authentication-api-for-next-js-41ea7da062c5?source=collection_archive---------1-----------------------#2022-12-29">https://javascript.plainenglish.io/nextauth-js-authentication-api-for-next-js-41ea7da062c5?source=collection_archive---------1-----------------------#2022-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b6b7e881dd5095d243b8b375fcfa64d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2b_uecco1MijfHU6PxkJA.jpeg"/></div></div></figure><p id="9945" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">NextAuth.js自诩为Next.js应用程序中用户注册和认证的高效开源解决方案。它的极简方法与对流行服务的内置支持相结合，允许您在几分钟内将身份验证添加到web应用程序流中。</p><p id="a5a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我们将建造什么？:</strong>我们将使用NextAuth和Next.js API路由构建一个基本级别的认证API。身份验证将包括使用NextAuth的CredentialsProvider和bcrypt模块的散列密码的电子邮件注册。</p><p id="69aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">安装:</strong>通过运行以下代码，在Next.js应用程序中安装NextAuth:</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="45bc" class="lc ld in ky b be le lf l lg lh">npm i next-auth<br/>or <br/>yarn add next-auth</span></pre><p id="9586" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">环境变量:</strong>在您的Next.js项目中，在项目的根目录下找到环境变量文件<code class="fe li lj lk ky b">.env.local</code>，并添加您的web应用程序URL和端口，以及一个用于NextAuth的<code class="fe li lj lk ky b">secret</code>，它可以是任何随机的字符串。您可以在开发过程中跳过它，但是不提供<code class="fe li lj lk ky b">secret</code>会在生产中抛出一个错误。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="caf4" class="lc ld in ky b be le lf l lg lh">NEXTAUTH_URL=http://localhost:3000<br/>SECRET=&lt;any random string&gt;</span></pre><p id="3299" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ll">注意:默认情况下，你的Next.js项目应该有一个. env.local文件。如果没有，请随意手动创建一个。</em></p><p id="86fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> SessionProvider: </strong>是NextAuth的<code class="fe li lj lk ky b">SessionProvider</code>施展魔法的时候了。打开pages目录中的<code class="fe li lj lk ky b">_app.tsx</code>文件，并添加以下代码块:</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="0916" class="lc ld in ky b be le lf l lg lh">import "../styles/globals.css";<br/>import type { AppProps } from "next/app";<br/>import { SessionProvider } from "next-auth/react";<br/><br/>function MyApp({ Component, pageProps }: AppProps) {<br/>return (     <br/>&lt;SessionProvider session={pageProps.session}&gt;       <br/>&lt;Component {...pageProps} /&gt;<br/>&lt;/SessionProvider&gt;   <br/>)<br/>}</span></pre><p id="9bfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe li lj lk ky b">SessionProvider</code>使我们能够利用React上下文跨组件共享会话对象。这反过来负责保持会话在浏览器的所有选项卡和窗口中更新和同步。</p><p id="e3d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">会话钩子:</strong>现在您已经准备好在您的<code class="fe li lj lk ky b">index.tsx</code>文件中导入NextAuth钩子，即<code class="fe li lj lk ky b">useSession</code>和<code class="fe li lj lk ky b">signOut</code>。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="aee9" class="lc ld in ky b be le lf l lg lh">import { useSession, signOut } from ‘next-auth/react’;<br/><br/>const Page: NextPage = () =&gt; {<br/> <br/> const { data: session } = useSession();<br/><br/>return (<br/> &lt;div&gt;<br/> <br/> &lt;/div&gt;<br/> )<br/>}<br/><br/>export default Page;</span></pre><p id="96d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">来自<code class="fe li lj lk ky b">useSession</code>的<code class="fe li lj lk ky b">data:session</code>将包含用户的会话细节，或者如果会话不存在，它将返回null。我们可以使用session对象有条件地呈现登录、注册和注销按钮。</p><p id="f7de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在您的<code class="fe li lj lk ky b">index.tsx</code>的return语句中添加以下代码块:</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="9bc4" class="lc ld in ky b be le lf l lg lh">{session &amp;&amp; &lt;button onClick={handleSignout}&gt;Sign out&lt;/a&gt;}<br/> <br/>{!session &amp;&amp; <br/>&lt;a href="/register"&gt;Sign Up&lt;/a&gt;<br/>&lt;a href="/login&gt;Sign In&lt;/a&gt;<br/>}</span></pre><p id="7a83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe li lj lk ky b">handleSignout</code>是当用户从他的会话退出时调用的NextAuth事件。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="4ea3" class="lc ld in ky b be le lf l lg lh">const handleSignout = (e) =&gt; {<br/>  e.preventDefault()<br/>  signOut()<br/>}</span></pre><p id="a954" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的<code class="fe li lj lk ky b">index.tsx</code>现在应该是这样的:</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="f26c" class="lc ld in ky b be le lf l lg lh">import { useSession, signOut } from 'next-auth/react';<br/><br/>export default function Header () {<br/><br/>const { data: session } = useSession();<br/><br/>  const handleSignout = (e) =&gt; {<br/>    e.preventDefault()<br/>    signOut()<br/>  }<br/><br/>  return (<br/>    &lt;div&gt;<br/><br/>    {session &amp;&amp; &lt;button onClick={handleSignout}&gt;Sign out&lt;/a&gt;}<br/><br/>    {!session &amp;&amp; <br/>    &lt;a href="/register"&gt;Sign Up&lt;/a&gt;<br/>    &lt;a href="/login&gt;Sign In&lt;/a&gt;<br/>    }<br/><br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="b69d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">用户注册</strong>:现在在pages文件夹中创建一个<code class="fe li lj lk ky b">register.tsx</code>文件，并粘贴以下代码块。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="4cce" class="lc ld in ky b be le lf l lg lh">import type { NextPage } from "next";<br/>import { signIn, getSession } from "next-auth/react";<br/>import Router from "next/router";<br/>import { GetServerSideProps } from "next";<br/><br/>const Page: NextPage = () =&gt; {<br/><br/>return (<br/><br/>&lt;form onSubmit={handleSubmit} method="post"&gt;<br/><br/>&lt;label&gt;Email&lt;/label&gt;<br/>&lt;input type="text" placeholder="Email" name="name" required/&gt;<br/><br/>&lt;label&gt;Password:&lt;/label&gt;<br/>&lt;input type="password" placeholder="Password" name="password" <br/>required/&gt;<br/><br/>&lt;button type="submit"&gt;Submit&lt;/button&gt;<br/><br/>&lt;/form&gt;<br/><br/>);<br/><br/>};<br/><br/>const handleSubmit = async (e) =&gt; {<br/> <br/> e.preventDefault();<br/><br/> const email = e.target.email.value;<br/> const password = e.target.password.value;<br/><br/>if (<br/> !email.trim().length ||<br/> !email.includes("@") ||<br/> !password.trim().length<br/> )<br/> return alert("Invalid details");<br/><br/> const res = await fetch("/api/auth/register", {<br/> method: "POST",<br/> headers: {"Content-Type": "application/json"},<br/> body: JSON.stringify({email: email,password: password}),<br/> });<br/><br/> const data = await res.json();<br/><br/> if (res.status != 201) return alert(data.message);<br/><br/> const status = await signIn("credentials", {<br/> email: email,<br/> password: password,<br/> });<br/><br/> Router.push("/");<br/> <br/> };<br/><br/> export const getServerSideProps: GetServerSideProps = async (ctx) =&gt; {<br/><br/> const session = await getSession(ctx);<br/><br/> if (session)<br/> return { redirect: { destination: "/", permanent: false } };<br/> <br/> return { props: {} };<br/><br/> };<br/><br/> export default Page;</span></pre><p id="9bdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe li lj lk ky b">register.tsx</code>文件中，我们创建了一个带有电子邮件&amp;密码输入字段的常规表单。在表单提交时，我们调用一个<code class="fe li lj lk ky b">handleSubmit</code>函数来验证电子邮件和密码输入。一旦通过验证，这些值就会被发送到Next.js api，<code class="fe li lj lk ky b">/api/auth/register</code>。</p><p id="e3ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当从register api收到成功的响应时，我们利用NextAuth钩子<code class="fe li lj lk ky b">signIn</code>让用户成功登录并创建一个会话。下一步，我们还将使用Next.js的<code class="fe li lj lk ky b">Router</code>方法将用户重定向到主页。</p><p id="1b49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe li lj lk ky b">register.tsx</code>页面的<code class="fe li lj lk ky b">getServerSideProps</code>中，我们使用<code class="fe li lj lk ky b">getSession</code>来确保页面只能在访客模式下访问。</p><p id="fdb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注册API </strong>:为了让<code class="fe li lj lk ky b">/api/auth/register</code> api工作，我们还需要创建一个<code class="fe li lj lk ky b">register.ts</code>文件。</p><p id="5188" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的<code class="fe li lj lk ky b">register.ts</code>文件需要放在您的<code class="fe li lj lk ky b">/pages/api/auth/</code>文件夹中。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="4df5" class="lc ld in ky b be le lf l lg lh">import type { NextApiRequest, NextApiResponse } from “next”;<br/>import { hash } from “bcryptjs”;<br/>import { findOne, insertOne } from “./models/user”;<br/><br/>const handler = async (req: NextApiRequest, res: NextApiResponse) =&gt; {<br/><br/>if (req.method === "POST") {<br/> <br/> const { email, password } = req.body;<br/><br/>if (!email || !email.includes("@") || !password || !username)<br/>return res.status(422).json({ message: "Invalid Data" });<br/><br/>const userExists = await findOne(email);<br/><br/>if (userExists)<br/> return res.status(422).json({ message: "user already exists" });<br/><br/>const obj = {<br/> email: email,<br/> password: await hash(password, 12)<br/>};<br/><br/>const insert = await insertOne(obj);<br/><br/>res.status(201).json({ message: "User created", …insert });<br/><br/>} <br/>else {<br/> res.status(500).json({ message: "Route not valid" });<br/>}<br/>};<br/>export default handler;</span></pre><p id="db05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它从数据库模型文件<code class="fe li lj lk ky b">./model/user</code>中导入<code class="fe li lj lk ky b">findOne</code>和<code class="fe li lj lk ky b">insertOne</code>方法，首先验证用户是否已经存在，如果不存在，则插入新的用户记录。我们还使用Node.js的<code class="fe li lj lk ky b">bycrypt</code>模块进行密码散列。您可以让上面的代码与您选择的任何流行的关系或非关系数据库一起工作。</p><p id="55fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">用户登录</strong>:登录时，只需在<code class="fe li lj lk ky b">handleSubmit</code>功能中稍作代码调整，即可复制大部分<code class="fe li lj lk ky b">register.tsx</code>文件。查看<code class="fe li lj lk ky b">login.tsx</code>页面下面的<code class="fe li lj lk ky b">handleSubmit</code>功能。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="de29" class="lc ld in ky b be le lf l lg lh">const handleSubmit = async (e) =&gt; {<br/> <br/> e.preventDefault();<br/><br/> const email = e.target.email.value;<br/> const password = e.target.password.value;<br/><br/>if (<br/> !email.trim().length ||<br/> !email.includes("@") ||<br/> !password.trim().length<br/> )<br/> return alert("Invalid details");<br/><br/> const status = await signIn("credentials", {<br/>    email: email,<br/>    password: password,<br/> });<br/><br/> if (status.error) return alert(status.error);<br/><br/>  Router.push("/");<br/> <br/> };</span></pre><p id="0efc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在完全依靠<code class="fe li lj lk ky b">signIn</code> hook来为现有用户完成这项工作。<code class="fe li lj lk ky b">signIn</code>使用NextAuth的<code class="fe li lj lk ky b">CredentialsProvider</code>调用签到函数，传递我们需要认证的邮箱和密码。简而言之，对于用于登录的<code class="fe li lj lk ky b">handleSubmit</code>函数，与它在<code class="fe li lj lk ky b">register.tsx</code>中的用法相比，我们简单地移除了Next.js api end。</p><p id="356a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">credentials provider:</strong><code class="fe li lj lk ky b">CredentialsProvider</code>是NextAuth.js提供的众多提供者之一，处理使用任意凭证的登录，例如用户名和密码、域、双因素身份验证或硬件设备(例如YubiKey U2F / FIDO)。</p><p id="fb17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步，您需要在<code class="fe li lj lk ky b">/pages/api/auth/</code>文件夹中创建一个<code class="fe li lj lk ky b">[...nextauth].js</code>文件。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="ad04" class="lc ld in ky b be le lf l lg lh">import NextAuth from “next-auth”;<br/>import { findOne } from “./database/user”;<br/>import { compare } from “bcryptjs”;<br/>import CredentialsProvider from “next-auth/providers/credentials”;<br/><br/>export default NextAuth({<br/> providers: [<br/><br/>CredentialsProvider({<br/> authorize: async (credentials: object, req) =&gt; {<br/><br/>const user = await findOne(credentials.email);<br/><br/>if (!user)<br/> throw new Error(“No user found with the email “ + credentials.email);<br/> <br/> const verifyPassword = await compare(<br/> credentials.password,<br/> user.password<br/> );<br/><br/>if (!verifyPassword)<br/> throw new Error(“Invalid password”);<br/><br/>return Promise.resolve({<br/> id: user.id,<br/> email: credentials.email<br/> });<br/> },<br/> }),<br/> ],<br/> callbacks: {<br/> session: async ({ session, token }) =&gt; {<br/> session.user = token.user; <br/> return session;<br/> },<br/> },<br/>secret: process.env.SECRET,<br/>});</span></pre><p id="239d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe li lj lk ky b">authorize</code>处理程序接受通过HTTP POST提交的凭证作为输入，或者在我们的例子中，由注册和登录流中使用的<code class="fe li lj lk ky b">signIn</code>钩子传递。每当检查一个会话时，就会调用<code class="fe li lj lk ky b">session</code>回调。作为回报，我们将收到一个<code class="fe li lj lk ky b">session.user</code>对象来表明凭证是有效的。<code class="fe li lj lk ky b">session.user</code>将包含使用<code class="fe li lj lk ky b">findOne</code>方法从数据库获取的用户的唯一id和电子邮件地址。</p><pre class="kt ku kv kw gt kx ky kz bn la lb bi"><span id="edd3" class="lc ld in ky b be le lf l lg lh">return Promise.resolve({<br/> id: user.id,<br/> email: credentials.email<br/> });</span></pre><p id="5e60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">结论:</strong>希望这篇教程对你有帮助！请随意浏览NextAuth的提供者列表，了解可用于身份验证的各种服务。</p><p id="5d4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ll">更多内容请看</em> <a class="ae lm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ll">说白了。</em></strong></a></p><p id="2c98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ll">报名参加我们的</em> <a class="ae lm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ll">免费每周简讯</em> </strong> </a> <em class="ll">。关注我们</em> <a class="ae lm" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ll">推特</em> </strong> </a>，<a class="ae lm" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ll">领英</em> </strong> </a> <em class="ll">，</em><a class="ae lm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ll">YouTube</em></strong></a><em class="ll">，</em> <a class="ae lm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ll">不和</em> </strong> </a> <strong class="jx io"> <em class="ll">。</em> </strong></p><p id="8c73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ll">有兴趣缩放你的软件启动</em> </strong> <em class="ll">？检查出</em> <a class="ae lm" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ll">电路</em> </strong> </a> <em class="ll">。</em></p></div></div>    
</body>
</html>