<html>
<head>
<title>Create an Authentication Server and Use it Across Backend Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个认证服务器，并在后端应用中使用它</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-an-authentication-server-and-use-it-across-backend-apps-307af4ef69f9?source=collection_archive---------3-----------------------#2022-09-03">https://javascript.plainenglish.io/create-an-authentication-server-and-use-it-across-backend-apps-307af4ef69f9?source=collection_archive---------3-----------------------#2022-09-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8922c7297746996c21f17ff9e1002870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BK07A_HN6kx0esK4"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="23d8" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="afc8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">今天，我们将讨论如何创建一个隔离的环境来管理您的身份验证请求，以及如何有效地将其添加为保护API的中间件</p><p id="b142" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们要遵循的总体思路是，首先，我们将创建一个常规服务器，它将有一个简单的请求，我们需要保护它，因此我们将创建一个中间件，它将接收标头并确保我们有正确的访问权限。我们还将使用API_KEY身份验证来防止内部使用。现在你有了基本的想法，让我们开始吧</p><h2 id="6676" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">为什么我们需要认证服务器？</h2><p id="0ff7" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你可能想知道为什么我们需要一个认证服务器，我们不能只在一个服务器上处理吗？显然，你可以，但当你的应用开始增长时，你可能需要将你的单片应用转移到微服务级别，这种策略将帮助你</p><h1 id="d36f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">设计认证服务器</h1><p id="3c42" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们会让事情变得简单。在我们的身份验证中，我们不会查看来源或网关，而只查看身份验证令牌和API密钥。首先，我已经创建了一个样例Express应用程序，其中我们只是导入了路由，并使用了默认的错误处理和一个解析器</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f4fa80e526ef3315b25ab41706ed2e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*2BWXD-3NZ6af3EnzlosDvw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">express app</figcaption></figure><p id="ce1f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">甚至认证服务器也需要保护，所以我们也将定义一个中间件规则来保护它。对于这个例子，我使用的是<a class="ae jz" href="https://en.wikipedia.org/wiki/API_key" rel="noopener ugc nofollow" target="_blank"> API_KEY </a>，但是你也可以创建<a class="ae jz" href="https://en.wikipedia.org/wiki/OAuth" rel="noopener ugc nofollow" target="_blank"> oAuth </a>或者<a class="ae jz" href="https://en.wikipedia.org/wiki/Basic_access_authentication" rel="noopener ugc nofollow" target="_blank"> Basic Auth </a>。为了使用它，我创建了一个文件，其中包含一个中间件，该中间件将检查API_KEY，如果有任何不正确的地方，就会使用一个伪数据源抛出一个错误</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/dd3278171f1c23014386814f31afcd48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*mk39Gz919MngVP2WrwfVCg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">API-key middleware</figcaption></figure><p id="f51c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里，我们使用我们的虚拟数据源检查API键是否存在和有效，如果案例失败则抛出错误，否则从路由调用下一个控制器</p><p id="43c6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，我们有了一个中间件设置，我们实际上可以从API开发开始了。我们将只创建2条路线，但您可以根据需要创建多条路线</p><ul class=""><li id="ca9c" class="mt mu in la b lb lw lf lx lj mv ln mw lr mx lv my mz na nb bi translated">注册</li><li id="b365" class="mt mu in la b lb nc lf nd lj ne ln nf lr ng lv my mz na nb bi translated">确认</li></ul><p id="5dfe" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我已经创建了一个实用程序文件，它将创建或验证令牌，以便我们可以直接使用控制器内部的方法。我使用<code class="fe nh ni nj nk b">jsonwebtoken</code>包来生成或验证，但你可以使用你喜欢的</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/14e7bd8ee14eb19f6ceb7f80920e49d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*uK6RU--TAAqcfOjLzqPJbw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Jwt utility functions</figcaption></figure><p id="25c2" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里，我们仅使用<code class="fe nh ni nj nk b">sign</code>和<code class="fe nh ni nj nk b">verify</code>方法，但理想情况下，您也应该使用<code class="fe nh ni nj nk b">decode</code>方法让您的应用程序为过期令牌及其后的流程做好准备</p><p id="662f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">既然现在我们已经设置好了一切，让我们创建路线</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/95d317ef85ed373dc9afd38a86762c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMKStBUIOHxve0YXy86QOQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">routes</figcaption></figure><p id="8173" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这里，我们导入了所有的依赖项，并为登录和验证创建了一个路由。在登录API中，您可以执行任何与数据库相关的操作，然后有条件地生成令牌，但是在本例中，我跳过了这一部分，直接从<code class="fe nh ni nj nk b">req.body.payload</code>发送令牌。另一方面，对于验证，我们获取授权头，然后使用<code class="fe nh ni nj nk b">verifyToken</code>方法来验证令牌是否有效</p><p id="791b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果一切正常，那么在运行服务器和API之后，我们将收到以下输出:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/711f7a1c1106dd488b57d8bfdc9bb0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8aEz9rSS3tGAb_TsouQmw.png"/></div></div></figure><p id="5d39" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这是它，我们的认证服务器准备好响应。下一步将是在任何其他微服务应用程序中使用该服务</p><h1 id="c39f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用认证服务</h1><p id="cd78" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">要使用我们刚刚创建的认证服务，我们需要使用HTTP请求提供者。我会选择Axios，但是您可以选择任何您选择的提供商</p><p id="c8ad" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我写了一篇文章，将帮助我们创建外部API调用，并使之更加敏捷。下面是这篇文章的链接，我会推荐你也去看看。</p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-handle-different-endpoints-in-axios-and-nodejs-8b288d92e940"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">如何处理Axios和NodeJs中的不同端点</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">为Axios创建基于类的实例，并有效地使用它们。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jt nr"/></div></div></a></div><h2 id="6515" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">服务生成器</h2><p id="ca47" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们将从创建一个生成器类开始，它将为所有请求处理<code class="fe nh ni nj nk b">api_key</code>逻辑:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/cc96d8870551f951478454ba8733accb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*yVxymbTy7m4gnenIwJYasQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Auth service generator</figcaption></figure><p id="35e7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里，我们创建了一个将API_KEY作为构造函数参数的类。这个类将创建一个axios实例，头中有<code class="fe nh ni nj nk b">baseURL</code>和<code class="fe nh ni nj nk b">api_key</code>，还将<code class="fe nh ni nj nk b">10000ms</code>设置为任何API的超时。除了这些属性，我们还将公开<code class="fe nh ni nj nk b">login</code>和<code class="fe nh ni nj nk b">verify</code>方法，这些方法将调用我们为auth service创建的API</p><p id="1c4b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">除了生成器之外，我们还将创建一个<code class="fe nh ni nj nk b">index.js</code>文件，该文件将创建该类的一个实例，并向我们公开该方法:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/0d566aa968a4c20f3f0c3bf367ec47d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*ZRYXYMrGm4GXHSB_RPvluQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">instance creation</figcaption></figure><p id="985c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这将是它，我们有一个类，将与认证服务互动，并负责管理变化单例。</p><h2 id="1815" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">创建验证中间件</h2><p id="a058" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在，我们的服务到位了。下一步是创建一个为我们处理验证的中间件:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e4a92e80852d82e3c7ad29f7e5690ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*F9VrdqAPKZtb1pRLPEaIOg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">auth service middleware</figcaption></figure><p id="e94d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里，我们创建了一个中间件，它将从req对象中提取消息头，并将其传递给我们之前创建的<code class="fe nh ni nj nk b">verify</code>方法</p><h2 id="44eb" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">创建路线</h2><p id="b6bd" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这个过程的最后一步是创建一个路由并使用中间件。首先，我们需要导入我们创建的中间件，然后在任何路线上使用它进行测试。通过的情况是所有未授权的请求将被阻止，只有授权的请求才能访问API。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oj"><img src="../Images/096ee78e71a03febda604331a98437bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*su-HofE4qps7G5NL6iZExg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">creating route</figcaption></figure><p id="879b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">为了测试这个API，我们需要传递我们在<code class="fe nh ni nj nk b">login</code> API上获得的授权令牌，并将其传递到这里。我们不需要通过<code class="fe nh ni nj nk b">api_key</code>，因为它对服务级别有限制。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ok"><img src="../Images/99bdaed2bbe5a4d6321492f98b159292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSesJJ2FGf2skAWNjVme7Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fail case scenario</figcaption></figure><p id="bdfc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果我们没有传递令牌或者传递了一个格式错误的令牌，那么它将导致一个未授权的请求。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ol"><img src="../Images/4128f4e7d833506ce2a6e8389230de3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfvshyy-UxprtLZlESc6wA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">pass case scenario</figcaption></figure><p id="ef12" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们微服务架构的通过案例场景</p><h1 id="9467" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="c946" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们为微服务创建了2个服务架构，但您可以增加服务以使用授权服务，它将在复制处理程序时完美地工作。您可以在下面找到源代码:</p><div class="no np gp gr nq nr"><a href="https://github.com/Piyush-Use-Personal/create-auth-service" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">GitHub-Piyush-Use-Personal/create-auth-service</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="om l oc od oe oa of jt nr"/></div></div></a></div><p id="9366" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">谢谢，祝编码愉快！</p><p id="e298" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="on">更多内容看</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="on">说白了。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="on">免费周报</em> </strong> </a> <em class="on">。关注我们关于</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="on">推特</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="on">LinkedIn</em></strong></a><em class="on"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="on">YouTube</em></strong></a><em class="on"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="on">不和</em> </strong> </a> <em class="on">。</em></strong></a></p></div></div>    
</body>
</html>