<html>
<head>
<title>What Are Micro-Frontend Web Applications?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是微前端Web应用？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-micro-frontend-web-applications-9df3bc212cb8?source=collection_archive---------1-----------------------#2022-11-03">https://javascript.plainenglish.io/what-are-micro-frontend-web-applications-9df3bc212cb8?source=collection_archive---------1-----------------------#2022-11-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3aef427363e2c6734440f4afe8d0cee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y5SWorvXCS_13L3i.png"/></div></div></figure><p id="5789" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">微前端(mfe)是最近web开发界的热门话题。但是它们是什么呢？简而言之，mfe是一种将web应用程序组织成一组小型的、可独立部署的模块的方式。每个模块都有自己的UI、业务逻辑和数据模型，并且可以独立于其他模块进行开发、测试和部署。尽管微前端作为一个术语在过去的许多文章和项目中使用过，但直到Zack Jackson在2020年发布了名为Module federation的主插件，这一概念的宣传活动才真正开始，带来了广泛的采用和关注。</p><h1 id="c582" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">微前端的好处</h1><p id="93cb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在新的和现有的项目中使用微前端架构有几个好处，其中最明显的是在用户界面和表示层的设计中具有更大的灵活性和模块化。每个团队都可以开发自己的UI组件，而不必担心破坏其他团队的功能。其他一些好处包括:</p><ul class=""><li id="7c0b" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><strong class="jx io">更好的分离顾虑。</strong>每个团队可以专注于自己的应用领域，而不必担心其他团队的实现细节。</li><li id="aa63" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">更容易平行发展。</strong>多个团队可以同时处理应用程序的不同部分，而无需协调他们的工作。</li><li id="3188" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">单个模块的测试和调试更容易、更简单。每个团队都可以测试和调试自己的UI组件，而不必担心其他团队的组件。</strong></li><li id="72d5" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">性能更佳。</strong>每个团队都可以优化自己的UI组件，而不必担心其他团队的性能。</li><li id="ae49" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">可扩展性和扩展相关的问题可以轻松解决。</strong>每个团队都可以扩展自己的UI组件，而不必担心其他团队、组件或模块。</li><li id="ab7d" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">部署。</strong>每个模块都可以根据需要分配资源，而不会影响更大应用程序的其他部分，每个模块都可以单独部署，这使其成为高效管理资源的最佳选择。</li></ul><h1 id="48cd" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">微前端的缺点</h1><p id="eb5f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">使用微前端架构有一些缺点，最明显的是如果不小心，可能会产生大量的代码重复，有时在组件之间管理和共享数据是不可避免的挑战。其他一些明显的缺点列举如下。</p><ul class=""><li id="4c3d" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><strong class="jx io">难以保持不同模块之间的同步。</strong>如果一个团队做出了改变，破坏了两个模块之间的接口，就很难找到问题的根源。</li><li id="56d1" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">测试或调试整个应用程序的难度。当有多个团队在代码的不同部分工作时，可能很难重现错误发生的条件。</li><li id="7f30" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">微前端架构使得在应用程序的不同部分之间共享代码变得困难。</strong>如果每个团队都独立工作，那么重用由另一个团队开发的代码可能会很困难。</li><li id="938d" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">有人可能会说这种模式是<strong class="jx io">形式胜于功能</strong>。</li><li id="7196" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">具有讽刺意味的是，<strong class="jx io">如果不同的组件相互依赖，那么将它们集成在一起可能会很困难</strong>。为了使这成为一个问题，建立跨团队的最佳实践和惯例。</li></ul><p id="bd74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，在部署和跟踪整个应用程序的当前状态时，遵循微前端架构可能会很困难。如果每个团队负责部署他们自己的代码，可能很难跟踪在何时何地发生了什么，从而在更高的层次上对应用程序的实际状态产生混淆。</p><p id="8af1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的缺点都可以通过使用更适合工作的不同工具和过程来适当地管理，然而，其中一些在本文中有所涉及，其他的通过进一步的研究。</p><h1 id="c9c9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何实现微前端架构？</h1><p id="650a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有几种不同的方法来实现微前端模块或组件。最常见的方法是使用JavaScript库，如React、Vue甚至SSR(服务器端渲染)库和工具。每个团队可以使用自己选择的库开发自己的UI组件，然后使用webpack或rollup等工具构建一个包含所有UI组件的包。</p><p id="5621" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种方法是使用Ember或Angular等框架，这有助于正确组织组件，并使它们易于拆卸。值得注意的是，使用微前端架构，每个团队可以使用他们选择的框架或库开发自己的组件，然后使用webpack或rollup等工具来构建包含所有组件的单个包。实现微前端架构的示例随处可见，其中一个流行的来源是GitHub上的模块联合示例库，有关更多信息，请参见<a class="ae kt" href="https://github.com/module-federation/module-federation-examples" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/module-Federation/module-Federation-examples</a>。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/eb7771f8f9e2f76442bcf19e19288305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MntS1kNbaZP2fGN2.png"/></div></div></figure><h1 id="4355" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">存储和共享代码</h1><p id="67f1" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Monorepo是使用基于git的代码库时广泛使用的设置之一。这个概念允许在本地访问其他组件，并允许开发人员轻松地对组件进行更改，而无需额外的工作。然而，一些团队不共享代码库，仍然高效地工作。人们必须考虑团队交互的频率，组件的相关性，并决定如何根据这些信息组织代码。同样重要的是，以这样一种方式适当地划分组件，使得它们在代码方面、数据方面和特性方面尽可能地独立。</p><p id="5882" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">共享组件或功能可以组织在单独的存储库中，也可以组织在由文件夹分隔的单个存储库中，但是建议对它们进行版本控制。如果一个团队更改了一个特定的共享组件，它应该反映在更改后构建的组件版本中。应保存描述共享组件变更的适当变更日志，以确保有效记录所做的变更。</p><p id="9c38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将单个组件集成到单个应用或容器中</p><p id="88be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了在模块联盟的帮助下使用webpack等构建工具之外，其他工具如<a class="ae kt" href="https://www.itmagination.com/blog/react-18-what-changes-does-it-bring" rel="noopener ugc nofollow" target="_blank"> React </a> Router、Angular Router、Next.js、Astro甚至Nginx都可以用来创建单页面应用程序，我们将称之为容器应用程序。这种设置通常包括所有组件，并作为项目的入口点。每个团队都可以开发自己的UI组件，然后使用choice工具在不同的组件之间传递，并将其作为单个可交付项目或多个小项目来呈现。值得注意的是，制作容器应用程序需要额外的工作，因此一些组织将容器应用程序项目分配给专门的团队。</p><h1 id="17fe" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">构建和部署</h1><p id="6052" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在构建单个组件时，有许多选项可用，在大多数情况下，库或框架的默认构建工具通常就足够了。在其他情况下，可以集成webpack等第三方工具。</p><p id="f7b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有组件都应该有自己专用的构建过程或阶段，或者作为更大管道的一部分，或者作为单独管道的一部分。这使得组件真正独立，可以单独部署。团队可以利用容器化(例如Docker)来帮助组织部署过程和构建。可以使用语义版本控制对组件的每个更改进行版本控制，并且可以根据业务需求自动、受控或手动部署版本更新。</p><p id="ec44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在大多数情况下，现有的管道解决方案，如GitLab和GitHub Actions、Jenkins等，应该足以构建和部署单个组件。不管它们是部署到云还是定制服务器、pods、azure应用服务，甚至是s3 bucket上的文件，现有的解决方案都应该足够了，因为它们是高度可定制的，可以将一个大项目分成更小的部分。</p><p id="c537" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单个组件也可以部署到私有的包注册中心，比如使用NPM或其他可用选项的nexus。这样，组件可以很容易地导入、构建和管理。团队可以决定他们想要安装的第三方组件的版本，并跟踪变更的历史。这对于共享组件和服务尤其有用。</p><p id="392a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">值得注意的是，虽然使用webpack或rollup构建一个包含来自所有不同团队的所有UI组件的包是一件好事，因为它允许您使用任何JavaScript库或框架，但它确实需要您有一个可以有效处理不同依赖关系的构建系统。</p><h1 id="ea0f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">公开MFE模块以供公共访问</h1><p id="a602" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">容器app大多作为微前端应用的入口。用户将访问容器应用程序，该应用程序进而根据用户交互决定呈现哪个微前端组件。有时，容器应用程序可能包含菜单、标题组件和呈现应用程序所需的必要结构。</p><p id="ddae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了使用内置于框架和库中的现有解决方案进行数据传输、路由和为您的组件构建容器之外，容器应用程序还可以是简单或复杂的Ngnix服务器、Express应用程序、Astro项目以及其他可用选项，因为它们的核心作用是路由流量并呈现在专用端口、本地网络内的url、Kubernetes集群或公共网络上运行的不同组件。应用程序的不同部分可以有自己的防火墙配置、访问级别和权限，并且仍然可以有效地协同工作，不会出现问题，因为每个部分都将在自己的迷你网络、容器和端口上运行，可以在顶层应用规则，可以配置负载平衡器，并且可以无缝管理流量。</p><h1 id="e900" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">共享数据</h1><p id="9242" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在基于MFE的应用程序中，在不同的模块和组件之间共享数据可能很棘手。有一些重要的部分需要注意，也有一些适用的基本规则。在大多数情况下，可以使用状态管理器来帮助本地组件的数据管理，以及在外部组件之间共享数据。像Redux这样的状态管理工具在微前端组件中表现良好，因为每个团队都可以在他们的组件中管理他们的本地数据，此外还可以共享数据。在Angular中，可以使用像RxJS和带有observables的服务这样的工具，而不是使用外部状态管理工具来无缝地管理和共享组件数据。</p><p id="8860" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意的一件重要事情是，数据应该尽可能地分离，当从第三方API或用户输入中接收数据时，目标应该是使它们独立于各个组件并且是唯一的。最小化组件之间共享的数据量，并确保以这样的方式管理共享的状态，即只有负责修改它的组件具有写访问权，而其他组件仅消费/读取数据。当更新中涉及多个组件时，应该以类似队列的方式更新数据，其中首先到达的更新被应用，接着是下一个更新，以创建状态的平滑转换和通常高效的系统。确保组件可以忽略不必要的数据、事件和数据变化也很重要，当组件内部没有直接变化时，这些数据、事件和数据变化可能会导致组件重新呈现。强烈建议实施高效的更改检测策略，并在不再需要数据流时取消订阅。</p><h1 id="745b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">微前端的最佳实践</h1><p id="3c98" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在开发微前端应用程序时，应该遵循一些最佳实践。</p><ul class=""><li id="1ca7" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><strong class="jx io">每个团队都应该在一个单独的存储库中开发自己的UI组件。</strong>这将允许每个团队独立工作，并使团队之间共享UI组件变得更加容易。</li><li id="b1d3" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">每个团队都应该使用webpack或rollup等工具来构建一个包含所有UI组件的包。</strong>这将使部署和更新UI组件变得更加容易。</li><li id="537c" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">每个团队应该为他们的UI组件使用一致的编码风格和命名约定。这将使其他团队更容易理解和使用UI组件。</li><li id="632c" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">使用微前端框架很重要，它将允许团队在UI组件之间轻松共享数据和状态。这将使开发由多个微前端组成的复杂应用程序变得更加容易。</li><li id="d773" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">每个团队都应该对他们的UI组件进行单元测试。这将确保组件按预期工作，并有助于防止将错误引入应用程序。</li></ul><p id="bfdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，微前端架构正在彻底改变前端开发、表示和管理。它展示了一些令人兴奋的可能性，每个人都想成为其中的一部分。在转换现有项目或利用MFE架构进行新项目之前，进行适当的研究是至关重要的。</p><p id="a167" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">‍</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="331d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mx">原载于</em><a class="ae kt" href="https://www.itmagination.com/blog/what-are-micro-frontend-web-applications-mfes" rel="noopener ugc nofollow" target="_blank"><em class="mx">https://www.itmagination.com</em></a><em class="mx">。</em></p><p id="fe1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mx">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">plain English . io</em></strong></a><em class="mx">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mx">免费周报</em> </strong> </a> <em class="mx">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">Twitter</em></strong></a><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">LinkedIn</em></strong></a><em class="mx"/><a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">YouTube</em></strong></a><em class="mx"/><a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">不和</em> </strong> </a> <em class="mx">。对增长黑客感兴趣？检查</em> <a class="ae kt" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mx">电路</em> </strong> </a> <em class="mx">。</em></p></div></div>    
</body>
</html>