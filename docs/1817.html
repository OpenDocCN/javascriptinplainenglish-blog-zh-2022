<html>
<head>
<title>Video to GIF Conversion with Client-Side JavaScript —Decoding FPS for GIF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用客户端JavaScript将视频转换为GIF—解码GIF的FPS</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/video-to-gif-conversion-with-client-side-javascript-decoding-fps-for-gif-bf96b8bc4d7c?source=collection_archive---------14-----------------------#2022-04-21">https://javascript.plainenglish.io/video-to-gif-conversion-with-client-side-javascript-decoding-fps-for-gif-bf96b8bc4d7c?source=collection_archive---------14-----------------------#2022-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a443" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帧速率= FPS。检索视频的FPS和指定GIF的FPS。包括完整的源代码实现。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cf52e9bac1f3cf07d233c3a7a7ac70ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2RW9v-o4LBZ2MTcaxS5DQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Illustration by Author | A pictorial overview of VIdeo-to-GIF encoding process</figcaption></figure><h1 id="f787" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">附带项目的基本原理</h1><p id="566e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">今年早些时候，在寻找将视频剪辑转换为GIF文件的轻量级实现时(最好使用客户端JavaScript)，我在网上找到的大多数建议都倾向于要求Node.js(即服务器端实现)。由于具有上述功能的现成插件往往被捆绑成节点模块，因此关于构建纯浏览器实现的细节很少。因此，这让我创造了自己的原型:</p><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-convert-a-video-clip-to-a-gif-file-with-client-side-javascript-56575d093191"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">如何使用客户端JavaScript将视频剪辑转换为GIF文件</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">基于浏览器的离线实现。包含完整代码的链接。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mv l"><div class="mw l mx my mz mv na kp mm"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/41807807028e3098ff91ea5e45b32ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*xoEEZqtHD9dHUbBxZi6BZQ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screencapture by Author | Prototype implemented for video-to-GIF web app</figcaption></figure><p id="ce3e" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">决心微调上面的实现，我决定对动画gif进行更多的研究，并注意到我忽略了一个至关重要的设置——每秒帧数(FPS)又称帧速率。因此，我决定在这个迭代中包含一个选项，让用户自定义选择他们喜欢的fps值。</p><h1 id="893e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">每秒帧数(FPS)</h1><p id="c06e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在进入实现细节之前，理解FPS的重要性是至关重要的。</p><blockquote class="nh ni nj"><p id="e0c3" class="ln lo nk lp b lq nc jr ls lt nd ju lv nl ne ly lz nm nf mc md nn ng mg mh mi ij bi translated">在任何动画媒体的开始和消逝时间之间，已经对视图进行了一定数量的图像更新。每个更新的图像视图被称为一个<strong class="lp ir"><em class="iq"/></strong><em class="iq">。</em></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/a57898b4877e80a173b2089421cd6a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9UcvQWX4g3aMoD4iqXsYg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Illustration by Author | Top: GIF Preview | Bottom: Every single frame captured</figcaption></figure><p id="eb38" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir">原始视频片段总长度:</strong> ≈ 6 s</p><p id="29f6" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir">总帧数:</strong> 34</p><p id="f9bc" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir"> ∴每秒帧数</strong> = 34 ÷ 6 ≈ 5.6 fps</p><p id="4eb8" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">—假设我希望将<strong class="lp ir"> </strong>的fps值调整为<strong class="lp ir"> 3.5 fps </strong>:</p><p id="6891" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir">每秒帧数</strong>= 3.5 fps =(5.6<strong class="lp ir">𝓍</strong>)fps</p><p id="f62e" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir">∴</strong>𝓍<strong class="lp ir"/>= 5.6 3.5 =<strong class="lp ir">2.1s</strong></p><p id="172d" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir">注:𝓍 </strong>是指下一帧渲染前<strong class="lp ir">延迟</strong>的秒数。</p><ul class=""><li id="8fb5" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">确定动画媒体的最佳fps值</li></ul><blockquote class="nh ni nj"><p id="50e2" class="ln lo nk lp b lq nc jr ls lt nd ju lv nl ne ly lz nm nf mc md nn ng mg mh mi ij bi translated"><em class="iq">❝[…】</em>延迟时间—如果不为0，该字段指定在继续处理数据流之前等待的百分之一秒(1/100)。<em class="iq"> ❞ </em></p><p id="582d" class="ln lo nk lp b lq nc jr ls lt nd ju lv nl ne ly lz nm nf mc md nn ng mg mh mi ij bi translated">来源:<a class="ae ny" href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/Graphics/GIF/spec-gif89a.txt</a></p></blockquote><p id="8dee" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir">以上要点如下:</strong></p><ul class=""><li id="0d01" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated"><strong class="lp ir"> 𝓍 </strong>的计量单位是秒的<strong class="lp ir"> ⁄₁₀₀</strong></li><li id="14ec" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated">转换度量是:<strong class="lp ir"> 1单位= ⁄₁₀₀秒</strong></li><li id="fafb" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated">假设<strong class="lp ir"> 𝓍 &gt; 0 </strong>，则最小延迟时间应为<strong class="lp ir"> 1单位</strong>(对于<strong class="lp ir"> 100 fps </strong></li></ul><p id="cd28" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">∵ <strong class="lp ir"> ⁄₁₀₀ s </strong>渲染<strong class="lp ir"> 1帧</strong> = <strong class="lp ir"> 0.01 s </strong>渲染<strong class="lp ir"> 1帧</strong></p><p id="8bb8" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">∴<strong class="lp ir">(0.01÷0.01)</strong><strong class="lp ir">s</strong>渲染<strong class="lp ir"> (1 ÷ 0.01) </strong> <strong class="lp ir">帧</strong> = <strong class="lp ir"> 1 s </strong>渲染<strong class="lp ir"> 100帧</strong>，转化为<strong class="lp ir"> 100 fps </strong></p><p id="81d6" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">由于延迟时间是以单位数(⁄₁₀₀秒)来测量的，下图说明了<strong class="lp ir"> FPS和延迟时间</strong>之间的关系:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/33d9ae9432cec485d3e08fea9a54902f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yc3WuzaF-08CmUvREqiSRw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author | Displays all possible values of variable <strong class="bd of">[Frame per Second]</strong></figcaption></figure><p id="46a6" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir">注:</strong>完整的图表数据表可从my GitHub — <a class="ae ny" href="https://gist.github.com/incubated-geek-cc/52c33eeac8c26450b43b39477f62fd9b" rel="noopener ugc nofollow" target="_blank"> FPS.csv </a>获取</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Under the column [Frame Per Second (FPS)], values have been rounded up to the nearest Integer. | In total, there are 19 unique possible values for fps.</figcaption></figure><ul class=""><li id="5824" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">虽然理论上100 fps是可能的，但是大多数设备都不能做到。因此，这可以被忽略，以便在以后的应用中进行选择。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/ff48d3e0fcb82be7475e2d7cdfb96d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkgahvcOBtx8RtR5vkdcFg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author | The list of fps values selectable in application | Note that the value 100 fps has been excluded</figcaption></figure><p id="011c" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">最后，下一节将介绍使用JavaScript插件<a class="ae ny" href="https://raw.githubusercontent.com/incubated-geek-cc/video-to-GIF/main/js/GIFEncoder.js" rel="noopener ugc nofollow" target="_blank"> GIFEncoder.js </a>实现视频到GIF Maker的技术概述。</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h1 id="8278" class="kv kw iq bd kx ky oq la lb lc or le lf jw os jx lh jz ot ka lj kc ou kd ll lm bi translated">技术实施—总共4个步骤</h1><h2 id="49ab" class="ov kw iq bd kx ow ox dn lb oy oz dp lf lw pa pb lh ma pc pd lj me pe pf ll pg bi translated">先决条件:包含在以下3个文件中+ <a class="ae ny" href="https://raw.githubusercontent.com/antimatter15/jsgif/master/b64.js" rel="noopener ugc nofollow" target="_blank"> b64.js </a>如下:</h2><ul class=""><li id="91a5" class="np nq iq lp b lq lr lt lu lw ph ma pi me pj mi nu nv nw nx bi translated"><a class="ae ny" href="https://raw.githubusercontent.com/incubated-geek-cc/video-to-GIF/main/js/GIFEncoder.js" rel="noopener ugc nofollow" target="_blank"> GIFEncoder.js </a></li><li id="ab68" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated"><a class="ae ny" href="https://raw.githubusercontent.com/incubated-geek-cc/video-to-GIF/main/js/LZWEncoder.js" rel="noopener ugc nofollow" target="_blank"> LZWEncoder.js </a></li><li id="97bf" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated"><a class="ae ny" href="https://github.com/incubated-geek-cc/video-to-GIF/blob/main/js/NeuQuant.js" rel="noopener ugc nofollow" target="_blank"> NeuQuant.js </a></li></ul><p id="45c1" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir">参考消息:</strong>这些插件最初是由GitHub用户<a class="ae ny" href="https://github.com/antimatter15" rel="noopener ugc nofollow" target="_blank"> Kevin Kwok </a>(创建者)从GitHub repo <a class="ae ny" href="https://github.com/antimatter15/jsgif" rel="noopener ugc nofollow" target="_blank"> jsgif </a>中检索出来的。</p><ul class=""><li id="8a5f" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">然后，继续将上述文件导入HTML标记文件，如下所示:</li></ul><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="caca" class="pp kw iq pl b be pq pr l ps pt">&lt;script type="text/javascript" src="LZWEncoder.js"&gt;&lt;/script&gt;<br/>&lt;script type="text/javascript" src="NeuQuant.js"&gt;&lt;/script&gt;<br/>&lt;script type="text/javascript" src="GIFEncoder.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="b64.js"&gt;&lt;/script&gt;</span></pre><h2 id="f00b" class="ov kw iq bd kx ow ox dn lb oy oz dp lf lw pa pb lh ma pc pd lj me pe pf ll pg bi translated">步骤(1):上传视频片段(≤ 30秒)</h2><p id="8a81" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">使用HTML文件输入元素创建简单的用户输入界面:</p><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="1116" class="pp kw iq pl b be pq pr l ps pt">&lt;input id='inputVideoClipFile' type='file' multiple='false' accept='.mp4,.webm,.avi,.mpeg,.flv,.mov,.3gp' /&gt;</span></pre><p id="beb2" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">将一个事件监听器(Event: change)标记到上面，并继续用JavaScript初始化一个<a class="ae ny" href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" rel="noopener ugc nofollow" target="_blank"> FileReader </a>实例:</p><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="2d0d" class="pp kw iq pl b be pq pr l ps pt">function readFileAsDataURL(file) {<br/>    return new Promise((resolve,reject) =&gt; {<br/>        let fileredr = new FileReader();<br/>        fileredr.onload = () =&gt; resolve(fileredr.result);<br/>        fileredr.onerror = () =&gt; reject(fileredr);<br/>        fileredr.readAsDataURL(file);<br/>    });<br/>}<br/>inputVideoClipFile.addEventListener('change', async(evt) =&gt; {<br/>    let file = evt.target.files[0];<br/>    if(!file) return;<br/>    let fileName=file.name;<br/>    let fileType=file.type;<br/>    let fileSize=(file.size/1024).toFixed(2);<br/>    let b64Str = await readFileAsDataURL(file);<br/>    /* TO DO CODE HERE */<br/>});</span></pre><ul class=""><li id="73f7" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">注意，<code class="fe pu pv pw pl b">new FileReader()</code>实例调用<code class="fe pu pv pw pl b">readAsDataURL</code>，因此分配给<code class="fe pu pv pw pl b">b64Str</code>的视频文件内容被读取为一个<a class="ae ny" href="https://developer.mozilla.org/en-US/docs/Glossary/Base64" rel="noopener ugc nofollow" target="_blank"> Base64 </a>字符串</li><li id="dc2b" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated">从<code class="fe pu pv pw pl b">file</code>对象中检索视频文件的信息，用于后续显示</li></ul><h2 id="ec14" class="ov kw iq bd kx ow ox dn lb oy oz dp lf lw pa pb lh ma pc pd lj me pe pf ll pg bi translated">步骤(2):处理视频二进制数据并提取帧。需要考虑两个主要部分——</h2><p id="f721" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp ir">第一部分</strong>通过在JavaScript中创建<code class="fe pu pv pw pl b">&lt;video&gt;&lt;/video&gt;</code> DOM元素来预览视频内容</p><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="b1fb" class="pp kw iq pl b be pq pr l ps pt">// rendered as &lt;video&gt;&lt;/video&gt; in HTML code<br/>const loadVideo = (url) =&gt; new Promise((resolve, reject) =&gt; {<br/>    var vid = document.createElement('video');<br/>    vid.addEventListener('canplay', () =&gt; resolve(vid));<br/>    vid.addEventListener('error', (err) =&gt; reject(err));<br/>    vid.src = url;<br/>});<br/>inputVideoClipFile.addEventListener('change', async(evt) =&gt; {<br/>    let file = evt.target.files[0];<br/>    if(!file) return;<br/>    let fileName=file.name;<br/>    let fileType=file.type;<br/>    let fileSize=(file.size/1024).toFixed(2);<br/>    let b64Str = await readFileAsDataURL(file);<br/>    /* TO DO CODE HERE */<br/>    let videoObj=await loadVideo(b64Str);<br/>    videoObj.autoplay=false;<br/>    videoObj.muted=true;<br/>    videoObj.loop=false;<br/>    let vidDuration=parseInt(videoObj.duration);<br/>    let vidHeight=videoObj.videoHeight; // 720<br/>    let vidWidth=videoObj.videoWidth; // 1280<br/>    videoObj.height=vidHeight;<br/>    videoObj.width=vidWidth;<br/>    videoObj['style']['height']=`${vidHeight}px`;<br/>    videoObj['style']['width']=`${vidWidth}px`;<br/>    document.getElementById('inputVideoPreview').appendChild(videoObj);<br/>});</span></pre><ul class=""><li id="dcbc" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">请注意，<code class="fe pu pv pw pl b">b64Str</code>是在之前的步骤中由<code class="fe pu pv pw pl b">FileReader()</code>读取的视频文件数据</li><li id="4284" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated"><strong class="lp ir">KIV:</strong><code class="fe pu pv pw pl b">autoplay</code>、<code class="fe pu pv pw pl b">muted</code>、<code class="fe pu pv pw pl b">loop</code>的视频设置设为<code class="fe pu pv pw pl b">false</code></li><li id="2c90" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated">HTML标记代码应该包含<code class="fe pu pv pw pl b">&lt;div id='inputVideoPreview'&gt;&lt;/div&gt;</code></li></ul><p id="cacc" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">第二部分。帧提取— 每个视频帧指的是在唯一时间戳的剪辑的图像快照。</p><blockquote class="px"><p id="49f9" class="py pz iq bd qa qb qc qd qe qf qg mi dk translated"><em class="qh">由于GIF文件是通过合并一组连续图像创建的，对于视频的每次按时间顺序的图形更新，应提取一帧嵌入图像数据，用于后续的GIF创建过程。</em></p></blockquote><p id="6f64" class="pw-post-body-paragraph ln lo iq lp b lq qi jr ls lt qj ju lv lw qk ly lz ma ql mc md me qm mg mh mi ij bi translated">虽然不能从DOM元素<code class="fe pu pv pw pl b">&lt;video&gt;&lt;/video&gt;</code>中直接提取每个视频帧<strong class="lp ir">所需的图像数据，但是可以将<code class="fe pu pv pw pl b">&lt;video&gt;&lt;/video&gt;</code>中预览的内容<strong class="lp ir">渲染到</strong> <code class="fe pu pv pw pl b">&lt;canvas&gt;&lt;/canvas&gt;</code> <strong class="lp ir">元素</strong>上以提取帧图像数据。</strong></p><p id="a64b" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">因此，在JavaScript中创建一个<code class="fe pu pv pw pl b">&lt;canvas&gt;&lt;/canvas&gt;</code>元素(类似于<code class="fe pu pv pw pl b">&lt;video&gt;&lt;/video&gt;</code>)，然后相应地缩放<code class="fe pu pv pw pl b">&lt;video&gt;&lt;/video&gt;</code>和<code class="fe pu pv pw pl b">&lt;canvas&gt;&lt;/canvas&gt;</code>进行显示:</p><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="cead" class="pp kw iq pl b be pq pr l ps pt">const byteToKBScale = 0.0009765625;<br/>const displayedSize=500;<br/>const scale = window.devicePixelRatio;<br/>function scaleCanvas(_CANVAS, videoObj, vidHeight, vidWidth, scale){<br/>    _CANVAS['style']['height'] = `${vidHeight}px`;<br/>    _CANVAS['style']['width'] = `${vidWidth}px`;<br/>    let cWidth=vidWidth*scale;<br/>    let cHeight=vidHeight*scale;<br/>    _CANVAS.width=cWidth;<br/>    _CANVAS.height=cHeight;<br/>    _CANVAS.getContext('2d').scale(scale, scale);<br/>}<br/>inputVideoClipFile.addEventListener('change', async(evt) =&gt; {<br/>    /* THIS SEGMENT IS OMMITTED FOR VISUAL CONVENIENCE */<br/>    /* ACTUAL CODE REFERS TO THE ABOVE IMPLEMENTED */<br/>    let _CANVAS = document.createElement('canvas');<br/>    scaleCanvas(_CANVAS, videoObj, vidHeight, vidWidth, scale);<br/>    <br/>    document.getElementById('hiddenCanvas').appendChild(_CANVAS)<br/>    let sizeBenchmark=vidHeight;<br/>    if(vidWidth&gt;vidHeight) {<br/>        sizeBenchmark=vidWidth;<br/>    }<br/>    let scaleRatio=parseFloat(displayedSize/sizeBenchmark);<br/>    let displayedHeight=scaleRatio*vidHeight;<br/>    let displayedWidth=scaleRatio*vidWidth;<br/>    videoObj['style']['height']=`${displayedHeight}px`;<br/>    videoObj['style']['width']=`${displayedWidth}px`;<br/>    scaleCanvas(_CANVAS, videoObj, displayedHeight, displayedWidth, scale);<br/>});</span></pre><ul class=""><li id="563e" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">注意<code class="fe pu pv pw pl b">vidWidth</code> &amp; <code class="fe pu pv pw pl b">vidHeight</code>是从<code class="fe pu pv pw pl b">&lt;video&gt;&lt;/video&gt;</code>中检索出来的。<em class="nk">(这是胸针的原始尺寸。)</em></li><li id="90e4" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated">由于每一帧都被渲染到一个<code class="fe pu pv pw pl b">&lt;canvas&gt;&lt;/canvas&gt;</code>元素上，因此必须根据像素密度对其进行缩放，以保持原始的视频分辨率和纵横比(在实用程序<code class="fe pu pv pw pl b">function scaleCanvas()</code>中实现)</li><li id="a1c2" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated">HTML标记代码应该包含<code class="fe pu pv pw pl b">&lt;div id='hiddenCanvas'&gt;&lt;/div&gt;</code></li></ul><p id="e8f4" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">随着<code class="fe pu pv pw pl b">&lt;video&gt;&lt;/video&gt;</code>和<code class="fe pu pv pw pl b">&lt;canvas&gt;&lt;/canvas&gt;</code>元素的初始化和缩放，实际的帧提取将继续进行。为了实现这一点，必须在每帧提取中按顺序执行以下<strong class="lp ir">:</strong></p><p id="658f" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir"> a) </strong>视频帧的图像数据被绘制到<code class="fe pu pv pw pl b">&lt;canvas&gt;&lt;/canvas&gt;</code>上</p><p id="06cf" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">需要<strong class="lp ir"> b) </strong> A <code class="fe pu pv pw pl b">GIFEncoder()</code>将<strong class="lp ir"> a) </strong>的输出相加，作为后续编码的帧。</p><p id="d008" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><strong class="lp ir"> c) </strong>计算未调整的fps和下一帧渲染的延迟时间</p><ul class=""><li id="b337" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">在HTML代码中，包含一个下拉列表，其中包含所有<strong class="lp ir"> 18个选项</strong> <em class="nk">(不包括100 fps) </em>供选择。</li></ul><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="2f7a" class="pp kw iq pl b be pq pr l ps pt">&lt;select id='fpsDropdownList'&gt;&lt;/select&gt;</span></pre><ul class=""><li id="04d9" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated"><code class="fe pu pv pw pl b">GIFEncoder()</code>的实例初始化如下</li></ul><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="eab4" class="pp kw iq pl b be pq pr l ps pt">var encoder = new GIFEncoder(vidWidth, vidHeight);<br/>encoder.setRepeat(0);<br/>encoder.setDelay(0);<br/>encoder.setQuality(10); // default value</span></pre><ul class=""><li id="ef72" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">然后创建效用函数<code class="fe pu pv pw pl b">step()</code>来封装<strong class="lp ir"> a) </strong>，<strong class="lp ir"> b) </strong> &amp; <strong class="lp ir"> c) </strong></li></ul><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="bc0e" class="pp kw iq pl b be pq pr l ps pt">var startTime=0;<br/>var frameIndex=0;<br/>var requiredFPSDelay=0;<br/>var FPS=0; // used to capture current fps<br/>const step = async() =&gt; {<br/>  if(startTime == 0) { startTime=(Date.now()); } // in ms<br/>  let _CANVAS_CTX=_CANVAS.getContext('2d');<br/>  _CANVAS_CTX.drawImage(videoObj, 0, 0, displayedWidth, displayedHeight);<br/>  encoder.addFrame(_CANVAS_CTX);<br/>  if(FPS==0) {<br/>    let elapsed = ((Date.now()) - startTime) / 1000.0;<br/>    FPS=(frameIndex / elapsed)*1000.0;<br/>    let fpsDropdownList=document.getElementById('fpsDropdownList');<br/>    let requiredFPS=parseInt(fpsDropdownList.value);<br/>    let requiredFPSDelay=FPS-(requiredFPS*1000);<br/>    if(requiredFPSDelay&lt;0){ requiredFPSDelay=0; }<br/>  }<br/>  await new Promise((resolve, reject) =&gt; setTimeout(resolve, 0));<br/>  videoObj.requestVideoFrameCallback(step);<br/>};<br/>videoObj.addEventListener('play', (vEvt) =&gt; {<br/>   encoder.start();<br/>   videoObj.requestVideoFrameCallback(step);<br/>}, false);<br/>videoObj.addEventListener('ended', (vEvt) =&gt; {<br/>   encoder.finish();<br/>}, false);<br/>videoObj.play();</span></pre><ul class=""><li id="b883" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated">为了确定所需的延迟时间，在第一帧渲染后，变量<code class="fe pu pv pw pl b">FPS</code>根据经过的时间<em class="nk">(注意延迟时间不能小于0) </em>捕捉当前fps值</li><li id="f98f" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated">由于<code class="fe pu pv pw pl b">autoplay=false</code>，当<code class="fe pu pv pw pl b">videoObj.requestVideoFrameCallback(step)</code>请求后续帧时<code class="fe pu pv pw pl b">&lt;video&gt;&lt;/video&gt; </code>必须调用<code class="fe pu pv pw pl b">play()</code>，并接受一个回调函数(即<code class="fe pu pv pw pl b">step()</code>)来处理每一帧的图像数据</li><li id="7fdb" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated"><code class="fe pu pv pw pl b">_CANVAS_CTX.drawImage()</code>继续将每个图像快照渲染到<code class="fe pu pv pw pl b">_CANVAS</code>上，以便<code class="fe pu pv pw pl b">GIFEncoder()</code>用<code class="fe pu pv pw pl b">addFrame()</code>捕捉一帧</li><li id="1e77" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated">当<code class="fe pu pv pw pl b">play</code>和<code class="fe pu pv pw pl b">ended</code>事件都发出时，<code class="fe pu pv pw pl b">GIFEncoder()</code>分别调用<code class="fe pu pv pw pl b">start()</code>和<code class="fe pu pv pw pl b">finish()</code></li></ul><h2 id="e591" class="ov kw iq bd kx ow ox dn lb oy oz dp lf lw pa pb lh ma pc pd lj me pe pf ll pg bi translated">步骤(4):通过GIFEncoder创建GIF</h2><p id="1cb9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了从<code class="fe pu pv pw pl b">encoder</code>中提取出所有帧<em class="nk">(即GIF输出)</em>的合并版本，需要实现以下JavaScript代码片段:</p><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="e931" class="pp kw iq pl b be pq pr l ps pt">var fileType='image/gif';<br/>var readableStream=encoder.stream();<br/>var binary_gif=readableStream.getData();<br/>var b64Str='data:'+fileType+';base64,'+encode64(binary_gif);</span></pre><ul class=""><li id="1de3" class="np nq iq lp b lq nc lt nd lw nr ma ns me nt mi nu nv nw nx bi translated"><code class="fe pu pv pw pl b">encode64()</code>是<a class="ae ny" href="https://raw.githubusercontent.com/antimatter15/jsgif/master/b64.js" rel="noopener ugc nofollow" target="_blank"> b64.js </a>中的一个方法，用于将<code class="fe pu pv pw pl b">GIFEncoder()</code>捕获的流数据转换为Base64格式。</li><li id="6a88" class="np nq iq lp b lq nz lt oa lw ob ma oc me od mi nu nv nw nx bi translated"><code class="fe pu pv pw pl b">b64Str</code>指的是通过合并<code class="fe pu pv pw pl b">GIFEncoder()</code>中出现的所有帧为GIF文件编码的数据。因此，在HTML代码中，继续包含:<code class="fe pu pv pw pl b">&lt;img id='outputGif' src=’${b64Str}’ alt=’${fileName}’ /&gt;</code>以预览输出的GIF文件。</li></ul><h2 id="3c3d" class="ov kw iq bd kx ow ox dn lb oy oz dp lf lw pa pb lh ma pc pd lj me pe pf ll pg bi translated">最后，GIF文件的下载链接创建如下:</h2><pre class="kg kh ki kj gt pk pl pm bn pn po bi"><span id="2410" class="pp kw iq pl b be pq pr l ps pt">let dwnlnk = document.createElement('a');<br/>dwnlnk.download = fileName;<br/>dwnlnk.innerHTML = `💾 &lt;small&gt;Save&lt;/small&gt;`;<br/>dwnlnk.className = 'btn btn-outline-dark';<br/>dwnlnk.href = b64Str;</span></pre><h2 id="928b" class="ov kw iq bd kx ow ox dn lb oy oz dp lf lw pa pb lh ma pc pd lj me pe pf ll pg bi translated">仅供参考:完整的代码实现在我的GitHub: <a class="ae ny" href="https://github.com/incubated-geek-cc/video-to-GIF" rel="noopener ugc nofollow" target="_blank"> video-to-GIF </a>(请随意★它或🔱叉起来！)或者在<a class="ae ny" href="https://incubated-geek-cc.github.io/video-to-GIF/" rel="noopener ugc nofollow" target="_blank"> demo </a>上试试看！</h2></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="b913" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">现在你知道了！非常感谢你坚持到这篇文章的结尾！❤希望你觉得这个指南很有用，如果你想了解更多GIS、数据分析和网络应用相关的内容，请随时关注我。会非常感激—😀</p><p id="1289" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated">— 🌮<a class="ae ny" href="https://www.buymeacoffee.com/geekcc" rel="noopener ugc nofollow" target="_blank">请给我买一份玉米卷🎀˶❛◡❛)</a></p><div class="mj mk gp gr ml mm"><a href="https://geek-cc.medium.com/membership" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">通过我的推荐链接加入灵媒——李思欣·崔</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">获得李思欣·崔和其他作家在媒体上的所有帖子！😃您的会员费直接…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">geek-cc.medium.com</p></div></div><div class="mv l"><div class="qn l mx my mz mv na kp mm"/></div></div></a></div><p id="3a83" class="pw-post-body-paragraph ln lo iq lp b lq nc jr ls lt nd ju lv lw ne ly lz ma nf mc md me ng mg mh mi ij bi translated"><em class="nk">更多内容请看</em><a class="ae ny" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="nk">plain English . io</em></strong></a><em class="nk">。报名参加我们的</em> <a class="ae ny" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="nk">免费周报</em> </strong> </a> <em class="nk">。关注我们关于</em><a class="ae ny" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="nk">Twitter</em></strong></a><em class="nk">和</em><a class="ae ny" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="nk">LinkedIn</em></strong></a><em class="nk">。加入我们的</em> <a class="ae ny" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="nk">社区不和谐</em> </strong> </a> <em class="nk">。</em></p></div></div>    
</body>
</html>