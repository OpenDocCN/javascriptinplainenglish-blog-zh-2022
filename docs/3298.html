<html>
<head>
<title>5 Things That Helped Me Survive JS Utility Function Hell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助我度过JS实用函数地狱的5件事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-things-that-helped-me-survive-enterprise-js-utility-function-hell-313cdb117b3f?source=collection_archive---------5-----------------------#2022-08-16">https://javascript.plainenglish.io/5-things-that-helped-me-survive-enterprise-js-utility-function-hell-313cdb117b3f?source=collection_archive---------5-----------------------#2022-08-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7f62" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">为什么开发人员应该将JavaScript实用函数重构为独立的组件，正确共享实用函数而不是复制粘贴，等等。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fb239aa3e67c5ceba9709a1905f5c644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvAzuoDU9znSl_YnM2ktdQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="https://www.pexels.com/photo/woman-sitting-in-front-of-macbook-313690/" rel="noopener ugc nofollow" target="_blank">Photo </a>by energepic.com @ Pexels</figcaption></figure><p id="040e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">陪审团可能不知道究竟什么构成了企业应用程序(剧透一下:<em class="lp">企业</em>是一个松散定义的架构特性集的管理术语；这与技术指标或代码质量无关)，但几乎所有和我一起工作过的人都同意一件事。</p><p id="490c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">边缘案例。边缘案例<em class="lp">比比皆是</em>。</p><p id="4a0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有些东西会坏掉。相信我，在如此大规模的代码基础上，非标准的网络配置、压迫性的安全策略、过时的软件和分散/非统一的系统都生活在一个混乱、丑陋的生态系统中，这一切会发生什么？</p><p id="b85e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你<em class="lp">不想</em>站在错误的一边:杂乱无章的项目结构。</p><p id="2002" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以很自然地，以我的运气，那就是<em class="lp">恰好</em>发生在我身上的事。</p><p id="f2d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">具体来说:这个特定的工作场所如何处理其助手/实用程序功能集合的组织和共享(或者更准确地说，<em class="lp">没有</em>)。</p><p id="5814" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，这更像是一篇开发日记，而不是一篇教程，讲述了我如何使开发这个代码库变得更容易——并在整个过程中保持理智。</p><h1 id="75db" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">“休斯顿？我们有一个问题。”</h1><p id="be16" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我所在的团队将他们的物流跟踪套件从本地PySide应用移植到React 17。</p><p id="aadb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它有大约24个实用程序/助手函数——位于一个<code class="fe mn mo mp mq b">/tools</code>目录中，由于不存在维护，这个目录已经不再是一个实用程序函数的集合，而更像是一个函数的转储场，过去的开发人员无法决定逻辑上放在哪里。</p><p id="256b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当其中一些需要共享时，最常用的解决方案是从repos中复制粘贴旧代码，这造成了版本管理的混乱。更糟糕的是，其中一些有嵌套依赖，所以测试是一场噩梦，调试更糟糕。</p><p id="1f3f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果这些描述了你目前正在从事的项目，我向你致以最深切的同情。下面是我做的一些实际上有帮助的事情，希望它们也能为你服务。</p><h2 id="8b8e" class="mr lr in bd ls ms mt dn lw mu mv dp ma lc mw mx mc lg my mz me lk na nb mg nc bi translated">1.将实用函数重构到每个上下文的一个专用组件中。</h2><p id="7fe4" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">所以第一件事是从<code class="fe mn mo mp mq b">/tools</code>目录中提取实用函数，并按照上下文/功能对它们进行分类。</p><p id="57aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在你可以把它们命名为<code class="fe mn mo mp mq b">string-utils.js</code>、<code class="fe mn mo mp mq b">form-utils.js </code>，并在每个组中有相关的功能。这样做没问题，但我发现非常有用的是一个更细粒度的结构/命名标准，它使浏览文件结构一眼就能判断是否有满足我需要的实现，而不是猜测和查看每个utils文件。</p><p id="fc2a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将意味着更冗长的文件名，如<code class="fe mn mo mp mq b">sanitize-string.js</code>、<code class="fe mn mo mp mq b">check-deep-equality.js</code>和<code class="fe mn mo mp mq b">validate-input.js</code>，但是你将使每个人的生活更容易——包括你自己。</p><p id="a15a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每个上下文都有<strong class="kv io">一个专用组件，一旦看到</strong>，你就会<strong class="kv io">确切地知道它</strong> <strong class="kv io">做什么。第一个概念<a class="ae ks" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的原理</a>在起作用。</strong></p><p id="07d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">理论上，你可以想多深就多深，但是收益递减规律在这里很强。运用常识，保持名称简短易读，使用一致的茶色或烤肉串色；仅为组件保留PascalCase。</p><h2 id="4970" class="mr lr in bd ls ms mt dn lw mu mv dp ma lc mw mx mc lg my mz me lk na nb mg nc bi translated">2.共享实用程序功能正常，而不是复制粘贴旧代码</h2><p id="7799" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">天哪，这是最难熬的一次了。</p><p id="432d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您从本文中学到了什么，那就是:从以前的项目中复制粘贴代码是一种幼稚的解决方案，不仅扩展性差，而且还会产生许多问题。</p><p id="d6e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面的文章是如何避免这种情况的一个很好的例子！</p><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/better-developer-velocity-with-shared-javascript-utility-functions-8a528d8d1319"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">利用共享的JavaScript实用函数提高开发速度</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">保持代码干爽的实用指南，以及跨…正确重用JS helper函数的最佳实践</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="np l"><div class="nq l nr ns nt np nu km ng"/></div></div></a></div><p id="2047" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你会在不同的回复中有相同代码的多个版本，每个人都有自己的想法。</p><p id="8193" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可读性和代码维护的噩梦！</p><p id="91a7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，如何在企业项目中“正确地”分享它们呢？首先，你需要安全的访问控制。很少有企业项目实际上是开源的——即使它们使用了F/OSS工具——所以你不能通过NPM把它们作为一个模块发布。</p><p id="c79d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以在一个秘密的URL上传tarballs，共享链接，然后通过一个包管理器从那里安装，但是这样你就放弃了semver和自动更新的好处。</p><p id="ef6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">从我的研究来看，</strong> <a class="ae ks" href="https://bit.cloud/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">钻头</strong> </a> <strong class="kv io">是两全其美的。</strong>这是一个开源工具链，一个上传、共享和发现组件和Node.js模块的伟大平台，对丰富的<a class="ae ks" href="https://mdxjs.com/" rel="noopener ugc nofollow" target="_blank"> MDX </a>文档的完全支持，在团队中的任何人导入它们之前在模拟的真实场景中预览我们所有功能的TSX/JSX“组合”，具有深度依赖图的语义版本，以及确保每个实用函数<em class="lp">对任何导入它们的人都有效的捆绑单元测试</em>。</p><p id="18cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">至关重要的是，细粒度的访问控制意味着我可以制作真正私有的、未列出的模块，并在需要知道的基础上添加任何人作为合作者。</p><p id="d23a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我让它通过了我们的审批程序，很快就通过了，几天后我就开始使用它了。</p><blockquote class="nv nw nx"><p id="2440" class="kt ku lp kv b kw kx jo ky kz la jr lb ny ld le lf nz lh li lj oa ll lm ln lo ig bi translated"><em class="in">💡</em>不过，在这一点上，您的里程可能会有所不同。大公司通常需要法律部门来研究和签署第三方技术。在这一点上，这是一个完全的抛掷。\_(ツ)_/</p></blockquote><h2 id="2038" class="mr lr in bd ls ms mt dn lw mu mv dp ma lc mw mx mc lg my mz me lk na nb mg nc bi translated">3.有时，一个专用组件比三个实用功能要好。</h2><p id="ac5c" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">模块化和抽象是伟大的，但是当你一天工作八到十个小时的时候，<a class="ae ks" href="https://en.wikipedia.org/wiki/Computer_programming#Readability_of_source_code" rel="noopener ugc nofollow" target="_blank">代码<em class="lp">可读性</em> </a> <em class="lp"> </em>要重要得多。</p><p id="b6aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可读代码是编写良好的代码的一个功能，它的长期好处包括更容易测试和调试，更容易对现有代码进行迭代，从而提高可维护性。</p><p id="6fe9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这对于使用像React这样的非独立复合框架的团队来说尤其重要。</p><p id="8e0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这在实践中会是什么样子？这个项目有一堆不同的助手函数，它们基本上做同样的事情:导出数据。</p><p id="401c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我没有用<code class="fe mn mo mp mq b">export-CSV</code>、<code class="fe mn mo mp mq b">export-XLS</code>、<code class="fe mn mo mp mq b">export-PDF</code>等等来扩充我的utils目录，而是发现将这些功能整合到一个大约80行的<code class="fe mn mo mp mq b">ExportButton</code>组件中(使用一个定制的钩子来获取数据)更容易。</p><p id="f03a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可读性、直观性和可发现性都大大提高了，因为我不必保留一堆相同但略有不同的实用函数。</p><p id="45cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另外，由于我已经在使用Bit，我可以在Bit工作空间中逻辑地隔离我的“哑”表示组件(所有无状态的原子UI组件，除了UI库之外没有任何依赖关系)和我的“智能”容器组件(操纵数据的有状态组件，称为API、Redux和其他库)，并在我需要的地方挑选我需要的东西。</p><h2 id="ef0f" class="mr lr in bd ls ms mt dn lw mu mv dp ma lc mw mx mc lg my mz me lk na nb mg nc bi translated"><strong class="ak"> 4。使用Lodash。</strong></h2><p id="79f5" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">或者，更有说服力地说:“您不会错过您没有编写的JavaScript的测试”。</p><p id="78e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">保留您的特定领域的实用函数，但是对于一般用途的东西，如深度相等、克隆、数组操作和去抖动，请使用经过战斗测试的、有大量文档记录的、可读性更好的实用函数库，如<a class="ae ks" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>。</p><p id="3a4c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">决定很简单。我不想重新发明轮子。我不希望在我的代码库或版本控制中有数百个实用程序/助手方法。我想要模块化的、独立的、久经考验的、一劳永逸的。</p><p id="655c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再一次，这一切都回到了优先考虑可读性，而不是通过滚动自己的本机函数获得的性能提升。更重要的是，通过一些工作，你可以让洛达什<a class="ae ks" href="https://en.wikipedia.org/wiki/Tree_shaking" rel="noopener ugc nofollow" target="_blank">变得可树摇动</a>(使用<code class="fe mn mo mp mq b"><a class="ae ks" href="https://github.com/lodash/babel-plugin-lodash" rel="noopener ugc nofollow" target="_blank">babel-plugin-lodash</a></code>，或者仅仅是<code class="fe mn mo mp mq b"><a class="ae ks" href="https://www.npmjs.com/package/lodash-es" rel="noopener ugc nofollow" target="_blank">lodash-es</a> </code>代替)，所以我可以只使用我需要的函数，避免代码膨胀。</p><blockquote class="nv nw nx"><p id="a4db" class="kt ku lp kv b kw kx jo ky kz la jr lb ny ld le lf nz lh li lj oa ll lm ln lo ig bi translated"><em class="in">💡</em>如果你不想使用巴别塔插件或者管理<code class="fe mn mo mp mq b">lodash </code>和<code class="fe mn mo mp mq b">lodash-es</code>之间的依赖冲突，使用Bit代替。那里共享的任何东西都是现成的——您可以检查每个组件/模块的依赖关系图，选择要导入和安装的组件/模块，直到最小的原子，因为所有的组件/模块都是可组合的代码。</p></blockquote><h2 id="b3cb" class="mr lr in bd ls ms mt dn lw mu mv dp ma lc mw mx mc lg my mz me lk na nb mg nc bi translated"><strong class="ak"> 5。</strong>知道何时使用助手函数，以及何时使用反作用钩子。</h2><p id="f15b" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">有人告诉我，在React中使用助手函数最简单的方法是在任何地方使用定制钩子来代替。</p><p id="6774" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请不要这样做。</p><p id="f6e5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当你刚开始的时候，把定制钩子看作特殊的实用功能是有帮助的，是的，但是它们是<strong class="kv io">而不是</strong>相同的。有疑问时；运用<a class="ae ks" href="https://en.wikipedia.org/wiki/You_aren't_gonna_need_it" rel="noopener ugc nofollow" target="_blank"> YAGNI </a>原理。</p><p id="9015" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不要为未来设计；只有当您的助手函数需要跨组件重用有状态逻辑、用其他钩子重用逻辑或者组合/封装普通的反应钩子时，才编写钩子。</p><p id="44e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您有纯实用函数，比如这个:</p><pre class="kd ke kf kg gt ob mq oc od aw oe bi"><span id="6765" class="mr lr in mq b gy of og l oh oi">function sum(a, b) {</span><span id="2bd7" class="mr lr in mq b gy oj og l oh oi">return a + b;</span><span id="0633" class="mr lr in mq b gy oj og l oh oi">}</span></pre><p id="ef34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">别管他们了。</p><p id="6601" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">钩子必须始终遵守钩子的<a class="ae ks" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">规则</a>，限制了它们的使用方式，如果你过早地优化并试图将钩子融入到你的设计模式中，你会减慢开发速度并可能使代码中其他不相关的部分变得复杂。</p><p id="bcfd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个简单的助手函数可以在任何地方，任何时间，不受限制地使用。另外，现在您可以查看项目文件夹，并立即知道哪些不使用state(在utils目录中)，哪些使用state(在hooks目录中)。</p><blockquote class="nv nw nx"><p id="01b4" class="kt ku lp kv b kw kx jo ky kz la jr lb ny ld le lf nz lh li lj oa ll lm ln lo ig bi translated"><em class="in">💡</em>顺便说一下，如果你真的决定了bits，你可以将你的定制的react hooks食谱分享给bits . cloud(bits为React hooks提供了一个模板)，并且更容易进行分布式开发。</p></blockquote><h1 id="75d5" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><em class="ok">工作出问题；不要通过猜测让事情变得更糟。”</em></h1><p id="ddc1" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">很容易找到轶事证据说“Framework X对于企业或生产来说是有史以来最糟糕的！”。但是大多数时候，这不是框架的问题，而是对一个好的项目结构能为可维护的代码做些什么的不完美的理解。</p><p id="8ca8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，正确地执行效用函数可能只是冰山一角，但它<em class="lp">仍然是朝着正确方向迈出的</em>一步，因为我们都陷入了继承另一个团队的工作并将你的工作传递给下一个团队的恶性循环中。</p><p id="b68c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">忽视这一点是导致“现在这样做，我们以后再解决”变成<a class="ae ks" href="https://en.wikipedia.org/wiki/Technical_debt" rel="noopener ugc nofollow" target="_blank">技术债务</a>的原因，然后是六个月的有毒scrum来实际“解决”。</p><p id="2d30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">谁知道呢？即使在极其保守的企业代码环境中，也许通过这种方式，您会发现这些工具在不仅仅是助手功能的领域中也有一些用途？</p><h1 id="75fa" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">了解更多信息</h1><div class="nd ne gp gr nf ng"><a href="https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">我们如何构建微前端</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">构建微前端来加速和扩展我们的web开发过程。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">blog.bitsrc.io</p></div></div><div class="np l"><div class="ol l nr ns nt np nu km ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://blog.bitsrc.io/how-we-build-our-design-system-15713a1f1833" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">我们如何构建一个组件设计系统</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">用组件构建一个设计系统来标准化和扩展我们的UI开发过程。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">blog.bitsrc.io</p></div></div><div class="np l"><div class="om l nr ns nt np nu km ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l3bhezsg" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">如何在项目中重用React组件</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">最后，您完成了在应用程序中为时事通讯创建一个奇妙的输入字段的任务。你对…很满意</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">比特云</p></div></div><div class="np l"><div class="on l nr ns nt np nu km ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://bit.cloud/blog/painless-monorepo-dependency-management-with-bit-l4f9fzyw" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">使用Bit进行无痛monorepo依赖管理</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">简化monorepo中的依赖关系管理，以避免虚拟依赖关系和版本问题。了解…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">比特云</p></div></div><div class="np l"><div class="oo l nr ns nt np nu km ng"/></div></div></a></div></div></div>    
</body>
</html>