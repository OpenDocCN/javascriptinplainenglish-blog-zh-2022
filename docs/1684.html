<html>
<head>
<title>How Webpack Handles Dynamic Imports with Variable Paths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack如何处理带有可变路径的动态导入</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-webpack-handles-dynamic-imports-with-variable-paths-9c598a2aa4e3?source=collection_archive---------2-----------------------#2022-04-12">https://javascript.plainenglish.io/how-webpack-handles-dynamic-imports-with-variable-paths-9c598a2aa4e3?source=collection_archive---------2-----------------------#2022-04-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7079" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">探索Webpack如何处理带有可变路径的动态导入。</h2></div><p id="50d4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Webpack是最流行的JavaScript模块捆绑器，它是一个将模块捆绑到一个文件中的工具。</p><p id="ed68" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一直困扰我的一件事是它如何处理带有可变路径的动态导入，我的意思是，我知道这不是魔术，但我不知道它是如何工作的，我总是忘记研究它…直到现在。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/7598c216898151990522f581f5fe86e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1DGMY110xqagTj7q.png"/></div></div></figure><h1 id="ef88" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">文件导入的工作方式</h1><p id="01d9" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">每当您在代码中导入一个文件时，Webpack将在项目目录中查找该文件，并以新的名称将其复制到<code class="fe mh mi mj mk b">build</code>文件夹中，然后Webpack用新复制文件的路径替换绑定的JavaScript文件中的导入代码。</p><p id="54ee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有一个超级简化的例子:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="3531" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">什么是动态导入？</h1><p id="b61b" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">有时你不想让浏览器立即下载文件，你想只在需要的时候加载它，为此，你可以使用动态导入。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6658" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几乎任何类型的文件都可以使用动态导入，因此对于大型图像或音频文件非常有用。</p><p id="e859" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是当你想导入一个路径可变的文件时会发生什么呢？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="bd84" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Webpack如何知道将哪个文件复制到<code class="fe mh mi mj mk b">build</code>文件夹？嗯，有一种方法可以告诉Webpack忽略导入，让浏览器用注释<code class="fe mh mi mj mk b">/* webpackIgnore: true */</code>来处理它。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ea63" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很好，但不知何故也可以不这样做，让Webpack找出文件的路径。但是怎么做呢？</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/9ec5256bbb228d6e5377f2c62a790869.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/0*Erhnd-SCwKvNCvSx.gif"/></div></figure><h1 id="4a4c" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">魔术</h1><p id="b3a0" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">它真的没有那么复杂，但是有一些注意事项。例如，如果导入一个具有可变路径的文件，该路径中至少有一部分需要在字符串中显式显示，例如:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">get</figcaption></figure><p id="70e9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是为什么呢？Webpack的做法是在构建过程中分析插入的字符串路径，然后从字符串中获取显式路径部分，在本例中为<code class="fe mh mi mj mk b">assets/images/</code>，然后将该文件夹中的所有文件复制到<code class="fe mh mi mj mk b">build</code>文件夹中。</p><p id="41cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Webpack也以一种非常聪明的方式做到了这一点，如果<code class="fe mh mi mj mk b">import</code>语句包含文件扩展名，它将只复制具有该扩展名的文件，例如<code class="fe mh mi mj mk b">import(`./assets/images/${fileName}.png`)</code>将只复制<code class="fe mh mi mj mk b">PNG</code>文件。</p><p id="d4ca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为Webpack是通过分析<code class="fe mh mi mj mk b">import</code>语句中的字符串来完成的，所以当整个路径是一个没有显式字符串部分的变量时，它无法知道要复制哪些文件。</p><h1 id="d89e" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">结论</h1><p id="db9d" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">Webpack可能有一个繁琐的配置，有时它可能看起来像黑暗魔法，但它是一个非常强大的工具，具有许多功能，如果你深入研究，你会发现它的实现并不复杂。</p><p id="790f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想了解更多关于Webpack的内容，你可以查阅<a class="ae ms" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">官方Webpack文档</a>，你可以在这里阅读更多关于<a class="ae ms" href="https://webpack.js.org/api/module-methods/" rel="noopener ugc nofollow" target="_blank">模块方法</a>和<a class="ae ms" href="https://webpack.js.org/guides/code-splitting/#dynamic-imports" rel="noopener ugc nofollow" target="_blank">动态导入</a>。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="8170" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="na">最初发布于</em><a class="ae ms" href="https://pablo.gg/en/blog/coding/how-webpack-handles-dynamic-imports-with-variable-paths/" rel="noopener ugc nofollow" target="_blank"><em class="na">https://pablo . gg</em></a><em class="na">。</em></p><p id="b36b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="na">更多内容看</em> <a class="ae ms" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="na">说白了就是</em> </strong> </a> <em class="na">。报名参加我们的</em> <a class="ae ms" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="na">免费周报</em> </strong> </a> <em class="na">。关注我们</em> <a class="ae ms" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="na">推特</em> </strong> </a> <em class="na">和</em><a class="ae ms" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="na">LinkedIn</em></strong></a><em class="na">。加入我们的</em> <a class="ae ms" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="na">社区不和谐</em> </strong> </a> <em class="na">。</em></p></div></div>    
</body>
</html>