<html>
<head>
<title>TypeScript is Not JavaScript’s Ugly Cousin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript不是JavaScript丑陋的表亲</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-is-not-javascripts-ugly-cousin-41a7fe7dec1d?source=collection_archive---------7-----------------------#2022-01-20">https://javascript.plainenglish.io/typescript-is-not-javascripts-ugly-cousin-41a7fe7dec1d?source=collection_archive---------7-----------------------#2022-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="58e7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解TypeScript如何改善开发人员的体验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fd218e21626e5de6cb793a4e9936df1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QmvCAC_fvbXZ2R13"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@mael_balland?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mael BALLAND</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d3f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员体验是一个简单明了的概念，它让软件开发人员的日常工作变得更好、更容易。在本文中，我将更深入地探讨技术细节，并重点关注像TypeScript这样的编程语言如何改善开发人员的体验。</p><h1 id="a7d4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">JavaScript和开发人员体验</h1><p id="3606" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JavaScript是一种功能强大的编程语言，但是您可以轻松地开始使用它。例如，如今每台电脑都有一个内置开发工具的网络浏览器，让你可以立即体验JavaScript引擎。此外，你得到的即时(可见)反馈可能会鼓励你更深入。</p><p id="104f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但有一个问题，随着用户对应用程序的要求比以往任何时候都高，这些应用程序变得越来越复杂。JavaScript不再只是你网页上的装饰品；你可以用它来构建非常高级的应用程序。这也意味着这些应用程序可能有大量的可能状态，很难被测试完全覆盖。这就是JavaScript的动态特性破坏开发人员体验的地方，因为开发人员收到的即时反馈不再相同。一些运行时错误只出现在特定的应用程序状态组合中。</p><p id="a926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么会这样？JavaScript是一种非常宽容的语言。一旦JS代码语法正确，它就会运行。然而，这种“无压力的成长”并不能保护开发人员避免编写在运行时失败的代码。此外，代码行数越多，代码触发运行时错误的几率就越大。换句话说，当您查看JS的功能时，有更多的方法可以编写包含运行时错误的代码，而不是不包含运行时错误的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/41985041fb083dd26d7b2ef9095dff4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*n8HHRlXA4Beq_8RU.png"/></div></figure><p id="7c1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从长远来看，这显然破坏了JS开发人员的体验——制造bug比编写代码优雅地处理所有有问题的情况更容易。</p><h1 id="0dff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">榆树方法</h1><p id="2806" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Elm是一种特定于领域的利基编程语言。也就是说，它的目标是前端领域，几十年来JS一直是这个领域的主要选择。</p><p id="1630" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Elm实现了函数式编程范式。多年来，开发人员发现，从长远来看，像不变性(函数式编程世界中的一个常见特性)这样的东西使我们的代码更易于维护。</p><h1 id="8d1f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么还要为Elm这样的小众编程语言费心呢？</h1><p id="4ab1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你问Elm程序员他们用这种语言开发的体验如何，大多数人会向你保证这比用JavaScript好得多。那么Elm是如何实现的呢？如果您看一下它的功能，它们会受到更多的限制:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/73276bccca4ee2aba2d154ddf7e67137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*gtjdGdQ0XgsWeQgJ.png"/></div></figure><blockquote class="mq mr ms"><p id="7021" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">在Elm社区中有一个非常流行的短语:“如果它能编译，它就能工作”。</p></blockquote><p id="322c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Elm编译器不允许您编写运行时失败的代码。让Elm脱颖而出的特性之一是它对开发人员友好的编译器反馈。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/726986d3f9437e728d27e04a7871c7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*_NoqqVla6nGZwFB9.png"/></div></figure><p id="8786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会看到Elm编译器并没有对开发人员大喊大叫，说他们做错了什么。Elm可以让你自己解决这个问题。相反，它通过提供尽可能多的上下文和提示如何解决问题来提供帮助。换句话说，Elm编译器充当了开发人员的助手。</p><p id="4677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Elm如何在技术层面上实现伟大的DX？</p><blockquote class="mq mr ms"><p id="fd8f" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">函数式编程范式是在Elm中编写应用程序的唯一方法。但是有一个额外的好处值得一提——Elm也是一种静态类型的编程语言。</p></blockquote><p id="4bc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不想就动态和静态打字孰优孰劣展开一场激烈的争论。这两个世界各有利弊。话虽如此，我相信静态类型语言会降低软件开发人员的速度，这是有充分理由的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/96e9e2f04a2a1240530dbbd31c807026.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*EzveV7tW6q5ym67j.png"/></div></figure><h1 id="5028" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么打字稿？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/05321446fc187a8783f2926810a71245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*025szBSPj5YraEYy"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@gioele_fazzeri_89?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gioele Fazzeri</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fd62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么“Typescript改进的开发者体验”是怎么回事呢？如果您再看一下功能图，事情会变得非常有趣:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl mz"><img src="../Images/472a6c5adeb219ea6366ad0ef4efc429.png" data-original-src="https://miro.medium.com/v2/format:webp/0*YpTgoIyyu_0NVcuX.png"/></div></figure><p id="dfb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeScript是一种编程语言，是JavaScript的超集，所以当然，仍然有可能编写出在运行时正确的代码。然而，就运行时错误而言，JS和Elm之间有一些中间地带。</p><blockquote class="mq mr ms"><p id="682a" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">TypeScript允许您在不可预测的动态JS世界和静态类型代码之间取得平衡。</p></blockquote><p id="f656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个很好的妥协，因为它创造了一个机会来警告开发人员，如果编译器确定在运行时有什么东西坏了。与此同时，如果你不想要太多的严格性，比如说，已经存在的JS代码库，你想不用进一步的努力就可以使用，那么总有一个出口。这取决于作为开发人员的您，您愿意投入多少时间来告诉TypeScript编译器有关代码的信息。因此，作为奖励，你可以从编译器那里得到一些保护，它会在你运行应用程序之前告诉你什么可能出错。</p><p id="68f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果从库和框架创建者的角度来看，善用TypeScript特性是创建开发人员不会讨厌的API的机会。因此，在本文中，我将通过使用一些真实的例子和案例研究来证明TypeScript有可能将JavaScript带到优秀开发人员体验的高度。所以让我们深入研究代码吧！</p><h1 id="9b5d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">案例研究1。“平均”函数</h1><h1 id="4647" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题是</h1><p id="9afa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">考虑下面这个简单的函数，它计算一组数字的平均值:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="8acf" class="nf lt iq nb b gy ng nh l ni nj">function average(numbers: number[]) { <br/> const sum = numbers.reduce((a, b) =&gt; a + b, 0); <br/> return sum / numbers.length;<br/>}</span></pre><p id="45ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于像5、10、15这样的值，它按预期工作:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="6b59" class="nf lt iq nb b gy ng nh l ni nj">console.log(average([5, 10, 15])) // 10</span></pre><p id="0590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，假设您是一名“平均计算领域专家”，您知道一些边缘情况:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="b235" class="nf lt iq nb b gy ng nh l ni nj">console.log(average([])) // NaN</span></pre><p id="53e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为数组是空的，所以你要用零除零。</p><p id="16bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以很容易地想象，一些使用这个库函数的React应用程序在被渲染成“NaN”时会感到困惑。</p><h1 id="d21a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行时错误方法</h1><p id="fa16" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你脑海中首先想到的可能是解决这个问题。您可以使用错误抛出机制向开发人员传达边缘情况问题:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="5302" class="nf lt iq nb b gy ng nh l ni nj">class EmptyArrayError extends Error {  <br/>constructor() {    <br/>super("Cannot calculate the average of an empty array");  <br/>}} <br/>function average(numbers: number[]) {  <br/>if (numbers.length === 0) {    <br/>throw new EmptyArrayError();  <br/>}   <br/>const sum = numbers.reduce((a, b) =&gt; a + b, 0);   <br/>return sum / numbers.length;<br/>}</span></pre><p id="48dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这个解决方案有一个问题。TypeScript没有强制开发人员处理原生JavaScript错误的机制。更重要的是，TypeScript根本没有本机类型错误支持。例如，如果你看一个“Promise ”,成功的路径可以很容易地被键入，但是错误的路径被键入为“any”。这意味着上述解决方案可能会使事情变得更糟。</p><p id="3256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们暂停一会儿，考虑一下在React应用程序上下文中使用我们的函数。通过抛出一个异常来破坏程序员正在开发的应用程序，会是一种很好的开发体验吗？因为(在一些组件中，从一些表中总结一些数据)你错过了平均函数的数字？</p><p id="56f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图书馆中良好的开发者体验实践之一是“做一个好公民”。这意味着你的库代码不应该破坏使用它的上下文。抛出一个让你的React应用崩溃的错误显然就是一个打破这个规则的案例。因此，我们将不得不考虑替代方法。</p><h1 id="f525" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">函数式编程与错误</h1><p id="4397" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们考虑一下典型的JavaScript函数是如何工作的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c49cf3a33c33aabb69a562b3794de6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/0*XX170hj34TViU5EV.png"/></div></figure><p id="a781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript中的函数可以:</p><ul class=""><li id="5f20" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">接收和处理参数，</li><li id="4255" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">返回输出值，</li><li id="ac81" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">表演副作用。</li></ul><p id="8853" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个，副作用，很容易使你的代码失控。在上一节中，我们有一个很好的副作用的例子，可以破坏整个应用程序，也就是说，抛出错误是一个副作用，如果错误没有被捕获，它可以使整个应用程序崩溃。</p><p id="bf9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了比较，让我们看看一些函数式编程语言是如何处理错误的。在函数式编程语言中，我们倾向于使用更接近函数的数学定义的纯函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/7189c5f7b1429956a5b404a8c0e3f6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/0*t1z5V4qKg5aGLZl6.png"/></div></figure><p id="b1e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，一个纯粹的功能不可能有副作用。就像在数学中，你可以把它想成一个黑盒，把参数值映射到其他值，仅此而已。但是问题出现了:如果没有副作用，如何处理错误？</p><p id="2669" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你实现纯函数时，只有两种可能会出现错误。如果输出的唯一方式是输出值，那么为什么不简单地将错误作为输出值返回呢？当你重新审视你的代码时，你可以做一个简单而强大的改变:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="3869" class="nf lt iq nb b gy ng nh l ni nj">function average(numbers: number[]) {  <br/>if (numbers.length === 0) {    <br/>return new EmptyArrayError();  <br/>}   <br/>const sum = numbers.reduce((a, b) =&gt; a + b, 0);   <br/>return sum / numbers.length;<br/>}</span></pre><p id="f5f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您是否注意到“throw”关键字已经被替换为“return”关键字了？</p><p id="b21b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，TypeScript足够聪明地推断出函数可能不会在所有情况下都返回数值。此外，它还可以警告开发人员哪些地方可能会混淆数字和错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/37b13b1083feb4d5cabe5ccd157178f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*NPY6bkTaHFjj2kgr.png"/></div></figure><p id="d9fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在这种情况下，开发人员被迫以下列方式处理错误:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="c6ff" class="nf lt iq nb b gy ng nh l ni nj">const avgResult = average([1,2,3]);<br/>console.log(avgResult instanceof EmptyArrayError ? "N/A" : (avg + 1))</span></pre><p id="2d2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这个技巧不能保护你避免在用户界面中出现明显不是数字的东西的问题。因为React不会保护你渲染“EmptyArrayError”，所以，在那种情况下，你只要把“NaN”换成“[Object object]”。在这种情况下,“NaN”替换看起来更糟。</p><p id="abe4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要尝试一些别的东西…</p><h1 id="3fa3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">狭窄型方法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/cc374c86bfdc90c60f398f7f75f4882d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dXezLPSJyt-RwitI"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@liamsimpson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Liam Simpson</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一节中，您已经看到纯函数只有两种传递错误的方式。我们试了“产值”法，那还剩下什么？我们别无选择，只能从“论据”方面尝试。</p><p id="fea7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不想在运行时抛出或返回一个错误，定义你的函数，这样就不可能用引入错误的参数来调用。在数学中，你可以定义一个函数的定义域。这意味着一些函数对不属于定义域的值没有感觉。TypeScript也有机会利用这个概念。例如，您可以这样定义类型:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="abb9" class="nf lt iq nb b gy ng nh l ni nj">export type NonEmptyArray&lt;T&gt; = [T, ...T[]];</span></pre><p id="a478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这类似于内置的“数组<t>”类型。但是，不同之处在于，它确保T类型的数组至少有一个元素。您可以在函数定义中使用这样的类型:</t></p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="63ba" class="nf lt iq nb b gy ng nh l ni nj">function average(numbers: NonEmptyArray&lt;number&gt;) {  <br/>const sum = numbers.reduce((a, b) =&gt; a + b, 0);   <br/>return sum / numbers.length;<br/>}</span></pre><p id="eb5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你测试它时，快乐之路像以前一样工作:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="e82c" class="nf lt iq nb b gy ng nh l ni nj">console.log(average([5, 10, 15])) // 10</span></pre><p id="adaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，当您尝试边缘案例时:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="2a2e" class="nf lt iq nb b gy ng nh l ni nj">console.log(average([]));</span></pre><p id="6f99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…您可以清楚地看到，TypeScript防止您编写没有意义的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/445523e49d60b457e0a61f6ff43125e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*jCSQI-KbFok0R_wr.png"/></div></figure><p id="0d25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是仍然有一个问题，在实际项目中，这些数字可能来自应用程序的外部(用户输入、后端响应等)。).所以编译器无法预知你要使用的数组是否为空。但是解决这个问题的方法是为我们的“NonEmptyArray”类型定义一个构造函数:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="8f18" class="nf lt iq nb b gy ng nh l ni nj">export const nonEmptyArray = &lt;T&gt;(array: T[]): NonEmptyArray&lt;T&gt; | undefined =&gt; {  <br/>if (array.length === 0) {    <br/>return undefined;  <br/>}   <br/>return array as NonEmptyArray&lt;T&gt;;<br/>}</span></pre><p id="2f6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，空数组必须以某种方式处理。在这种情况下，您可以决定只返回“未定义”,但这只是您想为这种情况返回什么值的问题。</p><p id="1cf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们模拟这样一种状态，其中一组数字来自我们的TypeScript应用程序之外的世界:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="8b9d" class="nf lt iq nb b gy ng nh l ni nj">const someArrayFromJSON: number[] = JSON.parse(“[1,2,3]”);</span></pre><p id="f84e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您可以使用类型构造函数，如下所示:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="5b1e" class="nf lt iq nb b gy ng nh l ni nj">const someNonEmptyArray = nonEmptyArray(someArrayFromJSON);</span></pre><p id="6a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更酷的是，它警告开发者如果他们想这样做:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d9b97a2d4c251327e8b28724d3e84cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*PA-fDZwfCH5q4lx_.png"/></div></figure><p id="7fa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，您可以指导使用您的库的开发人员尽早实现错误处理:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="8d33" class="nf lt iq nb b gy ng nh l ni nj">console.log(someNonEmptyArray ? average(someNonEmptyArray) : "N/A");</span></pre><p id="8b01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，这种模式可能看起来很奇怪。但是从长远来看，您保护了使用您的库的开发人员免于在产品上进行不方便的调试会话，因为您对他们坦诚了您的库需要什么才能正常工作。随着时间的推移，你的库的用户会自信地认为它不会破坏他们的应用程序，因为他们从一开始就在他们的IDE级别上覆盖了边缘情况。</p><h1 id="7283" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">开发人员在TypeScript方面的经验</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/cc803b1b715168ef953f69502ae41e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UKtKv9M5pcunLJrj"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@attentieattentie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Attentie Attentie</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d154" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><blockquote class="mq mr ms"><p id="1867" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">优秀的开发人员最需要的特征之一就是良好的文档。但是，更好的是交互式的文档和指导开发者正确使用(API/库/代码)的设计。</em> </strong></p></blockquote><p id="eb51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与大量教授如何使用你的产品的降价书相比，你可以做一些额外的事情，为开发者提供一个指导者，自动指导他们完成用例。</p><p id="21bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeScript是一个可以实现这种方法的强大工具，这要归功于我在本文中介绍的一些好的技术。我希望您已经受到启发，认识到TypeScript不仅仅是JavaScript的类型系统，并且您将喜欢使用它作为一种工具，可以填补一些开发人员的经验空白。</p><p id="d935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mt">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mt">plain English . io</em></strong></a><em class="mt">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mt">免费周报</em> </strong> </a> <em class="mt">。在我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mt">社区</em> </strong> </a> <em class="mt">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>