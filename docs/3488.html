<html>
<head>
<title>An Introduction to Blob API &amp; Its Use Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Blob API及其用例介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-dont-know-blob-api-f2c5e9754f29?source=collection_archive---------1-----------------------#2022-09-01">https://javascript.plainenglish.io/you-dont-know-blob-api-f2c5e9754f29?source=collection_archive---------1-----------------------#2022-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f99" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用例:1。分块上传，请按2。从互联网下载数据，3。图像压缩，4。创建Blob URL，5。Blob到数据URL的转换。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a935aca2123f7c276c8d1c47711fdaa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wwtIlV9NKqB5C_KI"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@cg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cristi Goia</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="83f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许你用过一些基于Canvas的在线图像设计器，当你编辑完图像选择下载时，你会发现它非常快。事实上，<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Blob </strong> </a> API最有可能在这个下载特性背后使用。</p><p id="9049" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了上述场景，<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Blob </strong> </a> API还可以应用于以下场景:大文件上传、大文件下载、本地图片预览、图片压缩上传。接下来，我将向您介绍Blob API及其常见的使用场景。</p><h1 id="7f7e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是Blob</h1><p id="0966" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">【Blob(二进制大对象)</strong> </a> <strong class="ky ir"> </strong>代表二进制类型的大对象。在数据库管理系统中，二进制数据存储为单个实体的集合。Blobs通常是图像、声音或多媒体文件。JavaScript中Blob类型的对象表示不可变的、类似文件的原始数据。</p><p id="624e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更直观的理解<code class="fe mp mq mr ms b">Blob</code>对象，我们先用<code class="fe mp mq mr ms b">Blob</code>构造函数创建一个<strong class="ky ir"> myBlob </strong>对象，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/2da4546b1b11f5a4a969bf591dcbbfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8K20_6t3tlfWC6ZVSgQ_Q.jpeg"/></div></div></figure><p id="77cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所示，<strong class="ky ir"> myBlob </strong>对象有两个属性:大小和类型。其中，size属性用于表示数据的大小(以字节为单位)，type是MIME类型。一个Blob对象由一个<strong class="ky ir">可选类型</strong>和<strong class="ky ir"> blobParts </strong>组成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/ffc0942694487cbc14b5e69b5afe8b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeuKtP3fQH9lt65apLIsEg.jpeg"/></div></div></figure><p id="2cf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，Blobs不一定以JavaScript的原生格式表示数据。例如，文件接口基于Blob，继承了Blob的功能，并对其进行了扩展，以支持用户系统上的文件。</p><p id="c95a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在介绍完<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Blob </strong> </a> API之后，我将介绍Blob API在工作中的5大使用场景。</p><h1 id="1553" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Blob API使用场景</h1><h2 id="0626" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">1.分块上传</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nh"><img src="../Images/feb82160411898be6af706873a8c8c07.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EUQYOFD_ZpDeKfKRHNGlSQ.jpeg"/></div></figure><p id="6e2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文件对象是一种特殊类型的Blob，可以在任何Blob类型的上下文中使用。所以对于大文件传输的场景，我们可以使用切片的方法来切割大文件，然后分块上传。具体例子如下:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="ab9d" class="mv lt iq ms b gy nm nn l no np">const file = new File(["a".repeat(1000000)], "bytefer.txt");</span><span id="9875" class="mv lt iq ms b gy nq nn l no np">const chunkSize = 40000;<br/>const url = "<a class="ae kv" href="https://httpbin.org/post" rel="noopener ugc nofollow" target="_blank">https://httpbin.org/post</a>";</span><span id="1e0d" class="mv lt iq ms b gy nq nn l no np">async function chunkedUpload() {<br/>  for (let start = 0; start &lt; file.size; start += chunkSize) {<br/>    const chunk = file.slice(start, start + chunkSize + 1);<br/>    const fd = new FormData();<br/>    fd.append("data", chunk);</span><span id="1373" class="mv lt iq ms b gy nq nn l no np">    await fetch(url, { method: "post", body: fd })<br/>      .then((res) =&gt; res.text());<br/>  }<br/>}</span></pre><p id="e4b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多关于如何实现大文件的并发上传，你可以阅读这篇文章:</p><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/implement-concurrent-upload-of-large-files-in-javascript-53519a0d2eee"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">用JavaScript实现大文件的并发上传</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">用动画演示，实现基于JavaScript的并发控制，从而实现…的并发上传</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><h2 id="2f9a" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">2.从互联网下载数据</h2><p id="da8d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可以从互联网下载数据，并使用下面的<code class="fe mp mq mr ms b">downloadBlob</code>函数将其存储在Blob对象中:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="cc22" class="mv lt iq ms b gy nm nn l no np">const downloadBlob = (url, callback) =&gt; {<br/>  const xhr = new XMLHttpRequest()<br/>  xhr.open('GET', url)<br/>  xhr.responseType = 'blob'<br/>  xhr.onload = () =&gt; {<br/>    callback(xhr.response)<br/>  }<br/>  xhr.send(null)<br/>}</span></pre><p id="10f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，除了使用<code class="fe mp mq mr ms b">XMLHttpRequest</code> API，我们还可以使用<code class="fe mp mq mr ms b">fetch</code> API来获取流中的二进制数据。在这里，我们来看看如何使用<code class="fe mp mq mr ms b">fetch</code> API获取在线图片并在本地显示。具体实现如下:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="67d7" class="mv lt iq ms b gy nm nn l no np">const myImage = document.querySelector('img');<br/>const myRequest = new Request('flowers.jpg');</span><span id="78d9" class="mv lt iq ms b gy nq nn l no np">fetch(myRequest)<br/>  .then(function(response) {<br/>    return response.blob();<br/>  })<br/> .then(function(myBlob) {<br/>   let objectURL = URL.createObjectURL(myBlob);<br/>   myImage.src = objectURL;<br/>});</span></pre><p id="727c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当fetch请求成功后，我们调用response对象的blob()方法，从response对象中读取一个Blob对象，然后使用<code class="fe mp mq mr ms b">createObjectURL()</code>方法创建一个objectURL，然后赋给img元素的src属性来显示这张图片。</p><p id="8faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上传文件时，可以实现并发上传。同样，在下载文件时，也可以实现并发下载。详细实现，可以参考这篇文章:</p><div class="nr ns gp gr nt nu"><a href="https://blog.bitsrc.io/implement-concurrent-download-of-large-files-in-javascript-4e94202c5373" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">用JavaScript实现大文件的并发下载</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">如何用JavaScript从零开始一步步实现多线程下载器来提高下载…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">blog.bitsrc.io</p></div></div><div class="od l"><div class="oj l of og oh od oi kp nu"/></div></div></a></div><h2 id="1081" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">3.图像压缩</h2><p id="a940" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在某些场合，我们希望在上传本地图像时，先将图像压缩到一定程度，再提交给服务器，从而减少传输的数据量。要在前端实现图像压缩，可以使用Canvas对象提供的toDataURL()方法，该方法接收两个可选参数:<code class="fe mp mq mr ms b">type</code>和<code class="fe mp mq mr ms b">encoderOptions</code>。</p><p id="70b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中type表示图像格式，默认为“image/png”。<code class="fe mp mq mr ms b">encoderOptions</code>用于指示画面质量。当指定的图片格式为“image/jpeg”或“image/webp”时，图片的质量可以从0到1中选择。如果超出该值范围，将使用默认值0.92，其他参数将被忽略。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于返回的数据URL格式的图像数据，为了进一步减少传输的数据量，我们可以将其转换为Blob对象:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="2975" class="mv lt iq ms b gy nm nn l no np">function dataUrlToBlob(base64, mimeType) {<br/>  let bytes = window.atob(base64.split(",")[1]);<br/>  let ab = new ArrayBuffer(bytes.length);<br/>  let ia = new Uint8Array(ab);<br/>  for (let i = 0; i &lt; bytes.length; i++) {<br/>    ia[i] = bytes.charCodeAt(i);<br/>  }<br/>  return new Blob([ab], { type: mimeType });<br/>}</span></pre><p id="18ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其实除了Canvas对象提供的<code class="fe mp mq mr ms b">toDataURL()</code>方法，它还提供了一个<code class="fe mp mq mr ms b">toBlob()</code>方法，其签名如下:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="ed0f" class="mv lt iq ms b gy nm nn l no np">canvas.toBlob(callback, mimeType, qualityArgument)</span></pre><p id="cc0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe mp mq mr ms b">toDataURL()</code>方法相比，<code class="fe mp mq mr ms b">toBlob()</code>方法是异步的，所以多了一个回调参数。这个回调函数的默认第一个参数是转换后的blob文件信息。</p><h2 id="32aa" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">4.创建Blob URL</h2><p id="aa1f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Blob URL/Object URL是一个伪协议，它允许Blob和文件对象用作图像的URL源、下载二进制数据的链接等等。在浏览器中，我们使用<code class="fe mp mq mr ms b">URL.createObjectURL</code>方法创建一个Blob URL，它接受一个Blob对象，并以Blob:&lt;origin&gt;/&lt;uuid&gt;的形式为其创建一个唯一的URL，对应的示例如下:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="4b5e" class="mv lt iq ms b gy nm nn l no np">blob:<a class="ae kv" href="https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641" rel="noopener ugc nofollow" target="_blank">https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</a></span></pre><p id="4f60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器在内部为通过URL.createObjectURL生成的每个URL存储一个URL → Blob映射。但是Blob本身仍然驻留在内存中，浏览器无法释放它。当文档被卸载时，映射被自动清除，因此Blob对象被释放。然而，如果应用程序是长期存在的，那么这种情况不会很快发生。因此，如果我们创建一个blob URL，即使不再需要这个blob，它也会存在于内存中。</p><p id="f543" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个问题，我们可以调用<code class="fe mp mq mr ms b">URL.revokeObjectURL</code>方法从内部映射中移除引用，从而移除blob并释放内存。接下来，让我们看一个使用Blob URLs下载客户端文件的例子。</p><p id="c8df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">index.html</strong></p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="7457" class="mv lt iq ms b gy nm nn l no np">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;title&gt;Blob URL Demo&lt;/title&gt;<br/>  &lt;/head&gt;</span><span id="59d5" class="mv lt iq ms b gy nq nn l no np">&lt;body&gt;<br/>    &lt;button id="downloadBtn"&gt;Download&lt;/button&gt;<br/>    &lt;script src="index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> index.js </strong></p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="01e4" class="mv lt iq ms b gy nm nn l no np">const download = (fileName, blob) =&gt; {<br/>  const link = document.createElement("a");<br/>  link.href = URL.createObjectURL(blob);<br/>  link.download = fileName;<br/>  link.click();<br/>  link.remove();<br/>  URL.revokeObjectURL(link.href);<br/>};</span><span id="a209" class="mv lt iq ms b gy nq nn l no np">const downloadBtn = document.querySelector("#downloadBtn");<br/>downloadBtn.addEventListener("click", (event) =&gt; {<br/>  const fileName = "blob.txt";<br/>  const myBlob = new Blob(["You Don’t Know Blob API"], <br/>   { type: "text/plain" });<br/>  download(fileName, myBlob);<br/>});</span></pre><p id="cf2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们通过调用Blob的构造函数来创建一个类型为<strong class="ky ir">“text/plain”</strong>的Blob对象，然后通过动态创建a元素来下载文件。</p><h2 id="1926" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">5.Blob到数据URL的转换</h2><p id="9b65" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在编写HTML网页时，对于一些小图片，我们通常会选择将图片内容直接嵌入到网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，如何嵌入呢？大多数现代浏览器都支持一种称为数据URL的功能，该功能允许使用base64编码图像或其他文件的二进制数据，并将其作为文本字符串嵌入到网页中。</p><p id="fdc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据URL由四部分组成:前缀(数据: )、指示数据类型的MIME类型、可选的base64标记(如果是非文本的话)以及数据本身:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="6e36" class="mv lt iq ms b gy nm nn l no np">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span></pre><p id="c284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">mediatype</code>是一个MIME类型的字符串，例如“image/jpeg”为jpeg图像文件。如果省略，默认为<strong class="ky ir">“text/plain；charset=US-ASCII" </strong>。如果数据是文本类型，可以直接嵌入文本。如果是二进制数据，可以在嵌入前对数据进行base64编码。例如，要嵌入图像:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="6730" class="mv lt iq ms b gy nm nn l no np">&lt;img alt="logo" <br/>  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUg..."&gt;</span></pre><p id="18ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是需要注意的是，如果图像比较大，图像的色彩层次比较丰富，就不适合使用这种方法，因为图像经过base64编码后的字符串非常大，会显著增加HTML页面的大小，从而影响加载速度。另外，使用FileReader API，我们还可以方便地实现图片的本地预览功能，具体代码如下。</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="7b1e" class="mv lt iq ms b gy nm nn l no np">&lt;input type="file" accept="image/*" onchange="loadFile(event)"&gt;<br/>&lt;img id="output"/&gt;</span><span id="2a60" class="mv lt iq ms b gy nq nn l no np">&lt;script&gt;<br/>  const loadFile = function(event) {<br/>    const reader = new FileReader();<br/>    reader.onload = function(){<br/>      const output = document.querySelector('output');<br/>      output.src = reader.result;<br/>    };<br/>    reader.readAsDataURL(event.target.files[0]);<br/>  };<br/>&lt;/script&gt;</span></pre><p id="70d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们为文件类型输入框绑定了<code class="fe mp mq mr ms b">onchange</code>事件处理程序loadFile。在这个函数中，我们创建一个FileReader对象，并为该对象绑定<code class="fe mp mq mr ms b">onload</code>对应的事件处理程序，然后调用FileReader对象的<code class="fe mp mq mr ms b">readAsDataURL()</code>方法，将本地图像对应的File对象转换为数据URL。</p><p id="7ad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成本地图片预览后，我们可以直接将图片对应的数据URL数据提交给服务器。针对这种情况，服务器需要做一些相关的处理，才能正常保存上传的图片。这里以快递为例，具体处理代码如下:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="27a9" class="mv lt iq ms b gy nm nn l no np">const app = require('express')();</span><span id="68cc" class="mv lt iq ms b gy nq nn l no np">app.post('/upload', function(req, res){<br/>    let imgData = req.body.imgData;<br/>    let base64Data = imgData.replace(/^data:image\/\w+;base64,/, "");<br/>    let dataBuffer = Buffer.from(base64Data, 'base64');<br/>    fs.writeFile("image.png", dataBuffer, function(err) {<br/>        if(err){<br/>          res.send(err);<br/>        }else{<br/>          res.send("Image upload successfully!");<br/>        }<br/>    });<br/>});</span></pre><p id="277c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于FileReader对象，除了支持Blob/File对象到数据URL的转换外，还提供了将Blob/File对象转换为其他数据格式的<code class="fe mp mq mr ms b">readAsArrayBuffer()</code>和<code class="fe mp mq mr ms b">readAsText()</code>方法。这里我们来看一个使用<code class="fe mp mq mr ms b">readAsArrayBuffer()</code>的例子:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="a798" class="mv lt iq ms b gy nm nn l no np">let fileReader = new FileReader();</span><span id="94da" class="mv lt iq ms b gy nq nn l no np">fileReader.onload = function(event) {<br/>  let arrayBuffer = fileReader.result;<br/>};</span><span id="ecad" class="mv lt iq ms b gy nq nn l no np">fileReader.readAsArrayBuffer(blob);</span></pre><p id="4beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该注意，Blob和ArrayBuffer对象可以相互转换:</p><ul class=""><li id="a672" class="om on iq ky b kz la lc ld lf oo lj op ln oq lr or os ot ou bi translated">使用FileReader的<code class="fe mp mq mr ms b">readAsArrayBuffer()</code>方法将Blob对象转换为ArrayBuffer对象；</li><li id="c79b" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated">使用Blob构造函数，如<code class="fe mp mq mr ms b">new Blob([new Uint8Array(data)])</code>，将ArrayBuffer对象转换为Blob对象。</li></ul><p id="1c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看完这篇文章，相信你已经对<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Blob </strong> </a> API及其应用场景有了一定的了解。如果你在工作中使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Blob </strong> </a> API实现其他功能，请给我留言。</p></div><div class="ab cl pa pb hu pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="ij ik il im in"><p id="06be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想学习打字，那么就不要错过<strong class="ky ir">掌握打字</strong>系列。</p><ul class=""><li id="1df0" class="om on iq ky b kz la lc ld lf oo lj op ln oq lr or os ot ou bi translated"><a class="ae kv" href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener"><strong class="ky ir">TypeScript泛型中的K、T、V是什么？</strong> </a></li><li id="257c" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-mapped-types-like-a-pro-be10aef5511a"> <strong class="ky ir">使用TypeScript像Pro一样映射类型</strong> </a></li><li id="3b5a" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-conditional-types-like-a-pro-7baea0ad05c5"> <strong class="ky ir">使用TypeScript条件类型像亲</strong> </a></li><li id="5fd2" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7"> <strong class="ky ir">使用TypeScript交集类型像亲</strong> </a></li><li id="5d29" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" href="https://levelup.gitconnected.com/using-typescript-infer-like-a-pro-f30ab8ab41c7" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">使用打字稿推断像亲</strong> </a></li><li id="d056" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac" rel="noopener"> <strong class="ky ir">使用TypeScript模板文字类型像亲</strong> </a></li><li id="f23a" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/15-utility-types-that-every-typescript-developer-should-know-6cf121d4047c"> <strong class="ky ir">可视化打字稿:15种最常用的实用类型</strong> </a></li><li id="847f" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" href="https://levelup.gitconnected.com/10-things-you-need-to-know-about-typescript-classes-f58c57869266" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">关于类型脚本类你需要知道的10件事</strong> </a></li><li id="54ed" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/purpose-of-declare-keyword-in-typescript-8431d9db2b10"><strong class="ky ir"/></a>中‘声明’关键字的用途</li><li id="d2cc" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/no-more-confusion-about-typescripts-any-and-unknown-98c4b53f8924"> <strong class="ky ir">不再混淆打字稿的“任何”和“未知”</strong> </a></li></ul><div class="nr ns gp gr nt"><div role="button" tabindex="0" class="ab bv gv cb fp ph pi bn pj kp ex"><div class="pk l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw pl pm fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l pl pm fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----f2c5e9754f29--------------------------------" rel="noopener follow" target="_top"> Bytefer </a></p></div></div><div class="pp pq gw l"><h2 class="bd ir ut om fp uu fr fs oa fu fw ip bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi uv au uw ux uy rk uz an eh ei va vb vc el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----f2c5e9754f29--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="vd l fo"><span class="bd b dl z dk">47 stories</span></div></div></div><div class="qc dh qd fp ab qe fo di"><div class="di pu bv pv pw"><div class="dh l"><img alt="" class="dh" src="../Images/8fba4cad7ae795f6abed5234e33e0356.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*l87u8lL_MzD5n4z_"/></div></div><div class="di pu bv px py pz"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di bv qa qb pz"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div></div></div></div><p id="479f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@bytefer" rel="noopener">中</a>或<a class="ae kv" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，阅读更多关于TS和JS的内容！</p><h1 id="b4c9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><div class="nr ns gp gr nt nu"><a href="https://blog.bitsrc.io/implement-concurrent-download-of-large-files-in-javascript-4e94202c5373" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">用JavaScript实现大文件的并发下载</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">如何用JavaScript从零开始一步步实现多线程下载器来提高下载…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">blog.bitsrc.io</p></div></div><div class="od l"><div class="oj l of og oh od oi kp nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/implement-concurrent-upload-of-large-files-in-javascript-53519a0d2eee"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">用JavaScript实现大文件的并发上传</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">用动画演示，实现基于JavaScript的并发控制，从而实现…的并发上传</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-implement-concurrency-control-in-javascript-df4da29f81c4"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">如何用JavaScript实现并发控制？</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">以有限的并发性运行多个承诺返回&amp;异步函数。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="od l"><div class="qi l of og oh od oi kp nu"/></div></div></a></div></div><div class="ab cl pa pb hu pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="ij ik il im in"><p id="c009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="qj">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="qj">plain English . io</em></strong></a><em class="qj">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="qj">免费周报</em> </strong> </a> <em class="qj">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="qj">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="qj">LinkedIn</em></strong></a><em class="qj"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="qj">YouTube</em></strong></a><em class="qj"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="qj">不和</em> </strong> </a> <em class="qj">。</em></p></div></div>    
</body>
</html>