<html>
<head>
<title>How to build a bot to sign up for gym classes with Node.js &amp; Puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Node.js &amp; Puppeteer构建一个机器人来报名体育课</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-an-automated-bot-to-sign-up-for-gym-classes-with-node-puppeteer-b812ea4a859b?source=collection_archive---------6-----------------------#2022-03-10">https://javascript.plainenglish.io/building-an-automated-bot-to-sign-up-for-gym-classes-with-node-puppeteer-b812ea4a859b?source=collection_archive---------6-----------------------#2022-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b1b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用Express和Puppeteer构建节点应用程序和自动化繁琐任务的初学者指南。</p><p id="bcbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章展示了Puppeteer的能力，并指导如何在节点应用程序中快速实现它。这是基于我前几天在当地健身房报名时遇到的一个问题。TL；博士，<a class="ae ki" href="https://github.com/samihamed/class-bot" rel="noopener ugc nofollow" target="_blank">这是Github上的模板</a>。</p><p id="ab00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用<a class="ae ki" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>、<a class="ae ki" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> Express </a>、<a class="ae ki" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank"> Nodemon </a>和<a class="ae ki" href="https://www.npmjs.com/package/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>构建一个简单的脚本，自动报名24小时前的体育课；就在注册解锁的那一刻。这将保证我们在有限的参与者名单中占有一席之地…并且相对于其他人有一点不公平的优势。本指南要求在您的机器上有效安装<a class="ae ki" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>和<a class="ae ki" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>。</p><p id="db53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题陈述:</strong>自从新冠肺炎去了健身房，我最喜欢的课程的名额就减少到了有限的人数。我健身房的网络应用程序允许会员提前24小时报名上课。有些课程是如此受人喜爱；注册解锁后仅仅几秒钟，他们就已经满员了。</p><p id="c760" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注册信息隐藏在登录墙后面，然后列在一个巨大的表格里。不幸的是，我们无法提取API调用和身份验证令牌，并且每个单独的类都没有特定的URL。这就是为什么我们会通过<a class="ae ki" href="https://pptr.dev/" rel="noopener ugc nofollow" target="_blank">木偶师</a>假装是一个普通的Chrome用户。</p><p id="e4fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">什么是木偶师？</strong>木偶师是一个节点库，它提供了一个高级API来控制Chrome或通过<a class="ae ki" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>的Chrome。默认情况下，木偶师运行无头的，但是可以配置为运行全(无头)铬或铬。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/056dbbb114948507433f08ed154a9d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x8Ja3sl0AvHUMsHa"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@trollinho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Trollinho</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="edda" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤1:设置一个节点应用程序，安装所需的依赖项，并创建运行应用程序所需的所有文件。</h1><p id="ef00" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">让我们首先打开我们的<strong class="jm io">终端</strong>并输入以下命令。这将为我们的应用程序<code class="fe md me mf mg b">class-bot</code>创建一个目录，并直接导航到其中</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="5598" class="ml lb in mg b gy mm mn l mo mp">mkdir class-bot &amp;&amp; cd $_</span></pre><p id="43b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们初始化项目来创建一个<code class="fe md me mf mg b">package.json</code>文件。NPM会问我们一些问题。我们可以回答这些问题，或者只需按几次“回车”键...</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="9d04" class="ml lb in mg b gy mm mn l mo mp">npm init</span></pre><p id="c686" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<code class="fe md me mf mg b">package.json</code>刚刚出现在我们的应用目录中。接下来，我们安装前面提到的所有依赖项。这可能需要一点时间。回到您的<strong class="jm io">终端</strong>并运行:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="9b28" class="ml lb in mg b gy mm mn l mo mp">npm i express puppeteer nodemon</span></pre><p id="2ded" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装完所有依赖项后，我们的<code class="fe md me mf mg b">package.json</code>文件应该如下所示:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="3651" class="ml lb in mg b gy mm mn l mo mp">{<br/>  "name": "class-bot",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "express": "^4.17.3",<br/>    "nodemon": "^2.0.15",<br/>    "puppeteer": "^13.5.1"<br/>  }<br/>}</span></pre><p id="128e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的应用程序需要一个Javascript文件作为它的主入口——你可以在你的<code class="fe md me mf mg b">package.json</code>文件的第五行或者上面的代码块中看到它被引用为<code class="fe md me mf mg b">index.js</code>。</p><p id="c8fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在主入口文件中，我们将编写脚本的其余部分。返回到<strong class="jm io">终端</strong>并键入以下命令来创建它:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="77a6" class="ml lb in mg b gy mm mn l mo mp">touch index.js</span></pre><p id="b362" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建主入口文件后，我们需要向<code class="fe md me mf mg b">package.json</code>添加一行代码，以添加一个命令，告诉node运行脚本并注意代码更改——这将使我们不必在做出更改时刷新并重启应用程序。</p><p id="487c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转到您的<code class="fe md me mf mg b">package.json</code>文件，将下面一行添加到<code class="fe md me mf mg b">scripts</code>对象中:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="2300" class="ml lb in mg b gy mm mn l mo mp">"start": "nodemon index"</span></pre><p id="35c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将这一行添加到脚本后，我们可以开始构建服务器，同时nodemon监视文件中的更改。</p><p id="5620" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们回到我们的<strong class="jm io">终端</strong>并运行下面的代码行:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="8604" class="ml lb in mg b gy mm mn l mo mp">npm run start</span></pre><p id="330e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Nodemon现在正在运行并观察<code class="fe md me mf mg b">index.js</code>文件。</p><h1 id="0576" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.填充服务器文件，为木偶脚本创建一个主目录</h1><p id="3d2c" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">接下来，让我们进入我们的<code class="fe md me mf mg b">index.js</code>文件，并在我们的代码编辑器中打开它——此时文件应该是空的。我们将添加以下几行来创建服务器:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="dccd" class="ml lb in mg b gy mm mn l mo mp">const express = require('express')<br/>const puppeteer = require('puppeteer')</span><span id="1072" class="ml lb in mg b gy mq mn l mo mp">const app = express()<br/>const port = 3000</span><span id="0282" class="ml lb in mg b gy mq mn l mo mp">app.get('/', (req, res) =&gt; {<br/>    res.send('Hello World!')<br/>})<br/>  <br/>app.listen(port, () =&gt; {<br/>    return console.log(`Express is listening at <a class="ae ki" href="http://localhost:${port}`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`</a>)<br/>})</span></pre><p id="adff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！此时，我们的应用程序正在运行，并自动观察<code class="fe md me mf mg b">index.js</code>的变化。在您的浏览器中，您已经可以导航到<code class="fe md me mf mg b">http://localhost:3000</code>并看到一条<code class="fe md me mf mg b">Hello World!</code>欢迎消息。检查您的<strong class="jm io">终端</strong>以查看应用程序运行。</p><h1 id="87a6" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.将木偶脚本添加到服务器文件中</h1><p id="f45f" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">为了开始使用木偶师，我们将在我们的<code class="fe md me mf mg b">index.js</code>文件的底部添加以下几行:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="945b" class="ml lb in mg b gy mm mn l mo mp">// the URL we would like to visit with Puppeteer<br/>const STUDIO_URL = <strong class="mg io"><em class="kj">'gym_url_goes_here'</em></strong></span><span id="b372" class="ml lb in mg b gy mq mn l mo mp">const initialisePuppeteer = async () =&gt; {<br/>    const browser = await puppeteer.launch({<br/>      headless: false<br/>    })<br/>  <br/>    const page = await browser.newPage()<br/>  <br/>    await page.viewport({<br/>      width: 1920,<br/>      height: 1080<br/>    })</span><span id="a2b5" class="ml lb in mg b gy mq mn l mo mp">    await page.goto(STUDIO_URL)<br/>}</span></pre><p id="9805" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加上述功能将不会激活木偶师。为此，我们需要将代码块<strong class="jm io">上方的下面一行添加到我们的<code class="fe md me mf mg b">index.js</code>文件的</strong><code class="fe md me mf mg b"><strong class="jm io">app.listen</strong></code><strong class="jm io">-方法</strong>中:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="1817" class="ml lb in mg b gy mm mn l mo mp">...</span><span id="a215" class="ml lb in mg b gy mq mn l mo mp">app.listen(port, () =&gt; {<br/>    // Start the Puppeteer script whenever the app launches or changes are detected<br/><strong class="mg io">    initialisePuppeteer()</strong></span><span id="dbdc" class="ml lb in mg b gy mq mn l mo mp">    return console.log(`Express is listening at <a class="ae ki" href="http://localhost:${port}`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`</a>)<br/>})</span><span id="0e97" class="ml lb in mg b gy mq mn l mo mp">...</span></pre><p id="ab3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在保存文件。如果我们检查终端和Nodemon仍在运行，那么我们的应用程序应该自动初始化木偶脚本，并打开我们之前定义的URL。</p><p id="fdfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">厉害！我们现在已经成功地建立并发布了一个服务器，定义了一个<code class="fe md me mf mg b">STUDIO_URL</code>，并让木偶师在Chromium中打开了我们健身房的网站。</p><h1 id="cf8f" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.定义所需的方法，让木偶师导航web应用程序</h1><p id="1e08" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">当木偶师打开健身房的网络应用程序时，我们首先看到的是一个cookie横幅覆盖图。让我们想想如何让木偶师自动点击<strong class="jm io">接受</strong>按钮。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mr"><img src="../Images/b69b38130930f50bf365eb57e9426d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1T_q6p3ZeI20H8BtrXUww.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Example of a cookie banner.</figcaption></figure><p id="5615" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的Chromium浏览器中，让我们右键单击<strong class="jm io">接受</strong>按钮来<code class="fe md me mf mg b">inspect</code>浏览器的DevTools中的html元素。对我来说是这样的:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="b886" class="ml lb in mg b gy mm mn l mo mp">&lt;a class="cookie-accept-blue" data-cookie-accept="save" id="cookie-accept"&gt;Accept&lt;/a&gt;</span></pre><p id="5446" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从你的角度看，事情可能会有所不同。让我们探索一些让木偶师选择并点击元素的方法。上面的<code class="fe md me mf mg b">&lt;a&gt;</code>元素有三个属性:</p><ul class=""><li id="b915" class="ms mt in jm b jn jo jr js jv mu jz mv kd mw kh mx my mz na bi translated"><code class="fe md me mf mg b">class="cookie-accept-blue"</code></li><li id="8a66" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated"><code class="fe md me mf mg b">data-cookie-accept="save"</code></li><li id="028f" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated"><code class="fe md me mf mg b">id="cookie-accept"</code></li></ul><p id="bbd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，我们可以右键单击元素，导航到<code class="fe md me mf mg b">Copy</code>并选择<code class="fe md me mf mg b">Copy selector</code>。剪贴板中的粘贴结果如下所示:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="b91b" class="ml lb in mg b gy mm mn l mo mp">#CookieBox &gt; div &gt; div &gt; div &gt; div.cookie-box &gt; div &gt; div &gt; div &gt; p:nth-child(5) &gt; a</span></pre><p id="5f7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Puppeteer提供了选择和点击HTML元素的简单方法。根据上面的属性，四种可能的方法如下所示:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="e1f3" class="ml lb in mg b gy mm mn l mo mp">await page.click('a[<!-- -->class='cookie-accept-blue<!-- -->]')</span><span id="49e8" class="ml lb in mg b gy mq mn l mo mp">await page.click('a[<!-- -->data-cookie-accept="save"<!-- -->]')</span><span id="33bf" class="ml lb in mg b gy mq mn l mo mp">await page.click('a[id="<!-- -->cookie-accept"<!-- -->]')</span><span id="7900" class="ml lb in mg b gy mq mn l mo mp">await page.click('#CookieBox &gt; div &gt; div &gt; div &gt; div.cookie-box &gt; div &gt; div &gt; div &gt; p:nth-child(5) &gt; a')</span></pre><p id="7892" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们使用CSS id选择器<code class="fe md me mf mg b">await page.click('a[id="cookie-accept"]')</code>选择第三个选项，并将其添加到我们的<code class="fe md me mf mg b">initialisePuppeteer</code>函数体中:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="b8dd" class="ml lb in mg b gy mm mn l mo mp">...<br/>    await page.viewport({<br/>      width: 1920,<br/>      height: 1080<br/>    })</span><span id="472b" class="ml lb in mg b gy mq mn l mo mp">    await page.goto(STUDIO_URL)</span><span id="247c" class="ml lb in mg b gy mq mn l mo mp">    <strong class="mg io">await page.click('a[id="cookie-accept"]')</strong><br/>}</span></pre><p id="9196" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我有点担心这里的比赛情况。如果cookie横幅和按钮元素没有及时加载会怎样？如果不能及时找到选择器，我们的应用程序可能会崩溃。让我们探索另一种等待选择器加载的木偶操纵方法:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="f54a" class="ml lb in mg b gy mm mn l mo mp">await page.<strong class="mg io">waitForSelector</strong>('a[id="cookie-accept"]')</span></pre><p id="561c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个方法将让Puppeteer空闲，直到DOM中出现一个带有已定义选择器的元素。让我们将这个方法<strong class="jm io">添加到</strong>方法<code class="fe md me mf mg b">click</code>之上。</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="0cf5" class="ml lb in mg b gy mm mn l mo mp">...<br/>    await page.viewport({<br/>      width: 1920,<br/>      height: 1080<br/>    })</span><span id="5372" class="ml lb in mg b gy mq mn l mo mp">    await page.goto(STUDIO_URL)</span><span id="e2d2" class="ml lb in mg b gy mq mn l mo mp"><strong class="mg io">    await page.waitForSelector('a[id="cookie-accept"]')<br/>    </strong>await page.click('a[id="cookie-accept"]')<br/>}</span></pre><p id="f5dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们观察(或者重启——记住:<code class="fe md me mf mg b">npm run start</code>运行脚本)应用程序在我们的终端中重新加载并打开Chromium。添加了上述方法后，Puppeteer应该会自动打开网站，等待cookie button元素出现，然后单击它。</p><h1 id="33f7" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.自动填写用户名和密码输入以登录web应用程序</h1><p id="5ab6" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我们成功启动了web应用程序，并关闭了cookie横幅。让我们操作所需的登录元素，然后登录。获取您的登录凭证，并将其保存到您的应用程序中。请注意:我绝不会建议将这样的凭证直接存储在应用程序中。相反，您应该使用环境变量或从配置文件中动态加载这些数据。</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="9bc1" class="ml lb in mg b gy mm mn l mo mp">...<br/>    await page.viewport({<br/>      width: 1920,<br/>      height: 1080<br/>    })</span><span id="d636" class="ml lb in mg b gy mq mn l mo mp">    await page.goto(STUDIO_URL)</span><span id="4811" class="ml lb in mg b gy mq mn l mo mp">    await page.waitForSelector('a[id="cookie-accept"t]')<br/>    await page.click('a[id="cookie-accept"]')</span><span id="27b3" class="ml lb in mg b gy mq mn l mo mp">    <strong class="mg io">const USERNAME = 'your_email_address'<br/>    const PASSWORD = 'your_password'<br/></strong>}</span></pre><p id="dbca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和以前一样，现在让我们找到并检查用户名<strong class="jm io">和密码<strong class="jm io">输入的选择器:</strong></strong></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8eb87e09112f88fcacac2f297abd2709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*CWflIOGtq_ExAMXwo8HqLQ.png"/></div></figure><p id="bebc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的例子中，选择器是这样的:<code class="fe md me mf mg b">id="inputEmail"</code>和<code class="fe md me mf mg b">id="inputPassword"</code>用于两个元素。</p><p id="d60e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了键入输入元素，Puppeteer提供了以下方法:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="bc6d" class="ml lb in mg b gy mm mn l mo mp">await page.type('input[id="inputEmail"]', USERNAME)<br/>await page.type('input[id="inputPassword"]', PASSWORD)</span></pre><p id="43b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将它们添加到函数体中:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="85bb" class="ml lb in mg b gy mm mn l mo mp">...<br/>    await page.viewport({<br/>      width: 1920,<br/>      height: 1080<br/>    })</span><span id="6346" class="ml lb in mg b gy mq mn l mo mp">    await page.goto(STUDIO_URL)</span><span id="b0a5" class="ml lb in mg b gy mq mn l mo mp">    await page.waitForSelector('a[id="cookie-accept"]')<br/>    await page.click('a[id="cookie-accept"]')</span><span id="6073" class="ml lb in mg b gy mq mn l mo mp">    const CREDENTIALS_EMAIL = 'your_email_address'<br/>    const CREDENTIALS_PASSWORD = 'your_password'<br/><strong class="mg io">    await page.type('input[id="inputEmail"]', USERNAME)<br/>    await page.type('input[id="inputPassword"]', PASSWORD)</strong><br/>}</span></pre><p id="1eff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">观看脚本运行，观察其中的神奇之处。木偶师正在用您的登录凭证填充输入元素！</p><h1 id="d451" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">6.签到</h1><p id="dd80" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">对于这一步，我们有多种方法可以告诉木偶师基于各种选择器或键盘事件激活登录事件:</p><ol class=""><li id="2815" class="ms mt in jm b jn jo jr js jv mu jz mv kd mw kh nh my mz na bi translated"><code class="fe md me mf mg b">await page.click('button[type="submit"]')</code>找到并选择提交按钮并<em class="kj">点击</em>它。</li><li id="204a" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh nh my mz na bi translated"><code class="fe md me mf mg b">await page.keyboard.press('Enter')</code>模拟键盘事件(请注意:这并不适用于所有的web表单)</li><li id="1082" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh nh my mz na bi translated"><code class="fe md me mf mg b">await page.select('input[id="inputPassword"]').press('Enter')</code>模拟选择密码输入域并触发<em class="kj">输入</em>事件。</li></ol><p id="6303" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了简单起见，我们将使用选项#1，并在函数体中添加以下内容:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="bf9b" class="ml lb in mg b gy mm mn l mo mp">...<br/>    await page.viewport({<br/>      width: 1920,<br/>      height: 1080<br/>    })</span><span id="4668" class="ml lb in mg b gy mq mn l mo mp">    await page.goto(STUDIO_URL)</span><span id="c485" class="ml lb in mg b gy mq mn l mo mp">    await page.waitForSelector('a[id="cookie-accept"]')<br/>    await page.click('a[id="cookie-accept"]')</span><span id="51f8" class="ml lb in mg b gy mq mn l mo mp">    const CREDENTIALS_EMAIL = 'your_email_address'<br/>    const CREDENTIALS_PASSWORD = 'your_password'<br/>    await page.type('input[id="inputEmail"]', USERNAME)<br/>    await page.type('input[id="inputPassword"]', PASSWORD)<br/><strong class="mg io">    </strong><strong class="mg io">await page.click('button[type="submit"]')<br/></strong>}</span></pre><p id="4671" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保存文件，瞧！看完我们的脚本运行后，我们登录了。</p><h1 id="9ac9" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">7.实现一个定时器来等待我们的类解锁</h1><p id="aece" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我们几乎得到了它。现在，我们所需要的就是让我们的机器人等待，直到我们想要的类的注册被解锁。请记住:注册按钮在上课前24小时是禁用的。</p><p id="497c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">幸运的是，一些元素检查告诉我们激活是基于UNIX时间戳的；即自1970年1月1日以来经过的秒数。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ni"><img src="../Images/045dc2746ee127b3ee5b55ce4ce34850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DnYqb3Rx0yQ5vkapE1hGQ.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">The HTML element tells us a lot about the inner workings of the app</figcaption></figure><p id="ca30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看上面屏幕截图中按钮元素的属性。我们将使用<code class="fe md me mf mg b">data-tstart</code>属性的值在UNIX time中设置一个计时器，并使用相同的属性作为惟一的选择器来稍后单击。</p><p id="a615" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我用一个<code class="fe md me mf mg b">while</code>循环拼凑的一个快速计时器:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="a72a" class="ml lb in mg b gy mm mn l mo mp">// Specify the time at which the button is supposed to be enabled<br/>// The value '1647084600' equals Saturday, March 12th, 2022 at 12:30:00 GMT+0100<br/>// Mind your timezones!<br/><strong class="mg io">const UNLOCK_TIME_IN_UNIX = 1647084600</strong></span><span id="9dc3" class="ml lb in mg b gy mq mn l mo mp">// Define the current time to compare with UNLOCK_TIME_IN_UNIX later<br/><strong class="mg io">const time = Math.round(Date.now() / 1000)</strong></span><span id="c4e8" class="ml lb in mg b gy mq mn l mo mp">// While the current time is before the moment of unlocking, the loop keeps running<br/><strong class="mg io">while (time &lt; UNLOCK_TIME_IN_UNIX) {<br/>    time = Math.round(Date.now() / 1000)</strong></span><span id="8cc7" class="ml lb in mg b gy mq mn l mo mp">   // This log will be fired 1000 times per second unless we add a delay<br/>    <strong class="mg io">console.log('Waiting for registration')</strong></span><span id="2e77" class="ml lb in mg b gy mq mn l mo mp">    // That's why we add a little 1000ms (1 second) delay<br/>    <strong class="mg io">await delay(1000)</strong></span><span id="ff48" class="ml lb in mg b gy mq mn l mo mp"><strong class="mg io">    if (time &gt; UNLOCK_TIME_IN_UNIX) {<br/>      console.log('Lets go!')<br/>      break<br/>    }<br/>}</strong></span><span id="b12e" class="ml lb in mg b gy mq mn l mo mp">// This optional function provides the time delay promise<br/><strong class="mg io">function delay(time) {<br/>  return new Promise(function(resolve) { <br/>      setTimeout(resolve, time)<br/>  })<br/>}</strong></span></pre><p id="1620" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将<code class="fe md me mf mg b">while</code>循环添加到我们的函数体之后，我们只需要多一个逻辑。不幸的是，健身房的网页不会在计时器到达时自动启用注册按钮。这就是为什么我们需要等待while循环中断；然后我们重新加载页面，最后，我们选择并单击注册按钮。</p><h1 id="9e9f" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">8.重新加载页面并注册一门课程</h1><p id="0754" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">Puppeteer还提供了完全重新加载页面的方法。我们将使用以下方法在<code class="fe md me mf mg b">while</code>循环中断后立即刷新:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="2375" class="ml lb in mg b gy mm mn l mo mp">await page.evaluate(() =&gt; {<br/>    location.reload()<br/>})</span></pre><p id="f23d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">页面重新加载后，我们需要等待注册按钮重新出现，因此我们实现了一个我们已经知道的方法:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="0fef" class="ml lb in mg b gy mm mn l mo mp">await page.waitForSelector('button[data-tstart="1647084600"]')</span></pre><p id="d3ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加这一行后，我们可以确保木偶师等待按钮再次出现。让我们添加最后一行来注册该类:</p><pre class="kl km kn ko gt mh mg mi mj aw mk bi"><span id="50c3" class="ml lb in mg b gy mm mn l mo mp">await page.click('button[data-tstart="1647111600"]')</span></pre><p id="99b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保存后，我们可以让应用程序再次运行。该应用程序现在应该会自动登录我们，并等到预期的时间。然后，它会立即重新加载页面，并在页面出现时点击注册按钮。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ab19885abd8b32e0d6c7c6452863115b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*AcUfXlEB7HZLPN2USKgbOQ.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">A screenshot from a live test for which I added some additional logging.</figcaption></figure><p id="7e0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的截图是我的高分。就在UNIX时间戳被点击8秒钟后，我报名参加了我最喜欢的瑜伽课程。它可能会快得多，但受到网页刷新速度的限制。</p><h1 id="89ea" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">9.享受锻炼</h1><p id="a867" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">离我们上课还有24小时。</p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><h1 id="01a1" class="la lb in bd lc ld nr lf lg lh ns lj lk ll nt ln lo lp nu lr ls lt nv lv lw lx bi translated">摘要</h1><p id="3704" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我希望你喜欢这个与木偶师的小冒险，并对如何用这个强大的工具构建一个简单的应用程序有所了解。当然，有很多事情我们可以做得更优雅。然而，这是一个有趣的为期一天的练习，它自动化了一个乏味的过程，解决了一个真正的日常问题，同时学习了几个木偶师的方法。</p><p id="f2bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我可能会在<a class="ae ki" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>上部署应用程序，并找出一种方法来激活应用程序，即使我无法访问我的终端。</p><p id="513f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我在评论中知道你想用木偶师自动化哪些任务。</p><p id="ab61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">更多内容尽在</em> <a class="ae ki" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">说白了. io </em> </strong> </a> <em class="kj">。报名参加我们的</em> <a class="ae ki" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">免费周报</em> </strong> </a> <em class="kj">。关注我们关于</em> <a class="ae ki" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">推特</em> </strong> </a> <em class="kj">和</em><a class="ae ki" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kj">LinkedIn</em></strong></a><em class="kj">。加入我们的</em> <a class="ae ki" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">社区</em> </strong> </a> <em class="kj">。</em></p></div></div>    
</body>
</html>