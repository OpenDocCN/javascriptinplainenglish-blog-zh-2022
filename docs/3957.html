<html>
<head>
<title>How to Build a Multiplayer Chatroom With WebSocket in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在10分钟内用WebSocket建立一个多人聊天室</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-multiplayer-chatroom-with-websocket-in-10-minutes-6694f2a6f971?source=collection_archive---------3-----------------------#2022-10-13">https://javascript.plainenglish.io/how-to-build-a-multiplayer-chatroom-with-websocket-in-10-minutes-6694f2a6f971?source=collection_archive---------3-----------------------#2022-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d894" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用WebSocket建立多人聊天室的快速指南。</h2></div><h1 id="75fd" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">演示</h1><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/3a31674cbfceea27c9cd1e2d0ed2e747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*96MBIuJoZXK7TsmqD0zetg.gif"/></div></div></figure><p id="ffb7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae mf" href="https://github.com/ReeceLeaf/websocket-chatroom" rel="noopener ugc nofollow" target="_blank">去GitHub查看完整源代码</a></p><p id="0334" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae mf" href="http://qianlongo-1300947007.cos.ap-nanjing.myqcloud.com/websocket-chatroom/index.html" rel="noopener ugc nofollow" target="_blank">点击此处体验完整服务</a></p><h1 id="648f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">概述</h1><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mg"><img src="../Images/473f3a2b3dcffc2ede52e21f3235787f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21HRNWPYaGhqmi4M4T1gUg.png"/></div></div></figure><h1 id="43ea" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">前言</h1><p id="1658" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">我们通常看到的聊天室似乎很神秘。实际上，它们通常是用<code class="fe mm mn mo mp b">Websocket</code>构建的。本文总结了<code class="fe mm mn mo mp b">Websocket</code>的基础知识，并实现了一个简单的多人聊天室演示。看完之后，你可以用<code class="fe mm mn mo mp b">Websocket</code>建立一个聊天室。</p><h1 id="34a6" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">了解Websocket</h1><h2 id="587d" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated"><code class="fe mm mn mo mp b">Websocket</code>的背景</h2><p id="25de" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">在很多场景下，用户需要实时消息，比如聊天、医疗设备读数等。旧的解决方案是基于轮询来获取最新数据，但它并不完全同步实时消息。在大多数情况下，请求是不必要的，会浪费大量流量和服务器资源。基于这样的背景，<code class="fe mm mn mo mp b">WebSocket</code>诞生了。</p><h2 id="983c" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">Websocket的基本概念</h2><p id="0e18" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated"><code class="fe mm mn mo mp b">WebSocket</code>是HTML5提供的单一TCP连接上的全双工通信协议。<code class="fe mm mn mo mp b">WebSocket</code>通信协议诞生于2008年，2011年成为国际标准<code class="fe mm mn mo mp b">WebSocket</code>使得客户端和服务器之间的数据交换更加容易，允许服务器主动向客户端推送数据。在<code class="fe mm mn mo mp b">WebSocket</code> API中，浏览器和服务器只需要完成一次握手，然后就可以直接创建持久连接，进行双向数据传输。</p><p id="6c60" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">兼容性问题(主流浏览器支持)</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nc"><img src="../Images/f3b7ee9c73f0b5c85578640fa3d90c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*010Zk8OoWqa4Oi9c.png"/></div></div></figure><h2 id="3f3a" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">Websocket的特性</h2><ul class=""><li id="4201" class="nd ne iq ll b lm mh lp mi ls nf lw ng ma nh me ni nj nk nl bi translated">控制开销。建立连接后，当服务器和客户端之间交换数据时，用于协议控制的数据包报头相对较小。在没有扩展的情况下，对于从服务器到客户端的内容，报头大小仅为2到10个字节(与数据包长度相关)；对于客户端到服务器的内容，该报头需要用额外的4个字节来屏蔽。与HTTP请求每次需要携带完整的头相比，这种开销大大降低。</li><li id="0e64" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">实时通信。由于协议是全双工的，服务器可以随时主动向客户端发送数据。与HTTP请求相比，服务器需要等待客户端发起请求后才能响应，延迟明显更少；即使与Comet这样的长轮询相比，也能在短时间内交付更多次数据。</li><li id="b338" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">保持联系。与HTTP不同，Web套接字需要首先创建一个连接，这使它成为一个有状态协议。后来交流的时候可以省略一些状态信息。</li><li id="400d" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">支持二进制传输。您可以发送文本或二进制数据。<code class="fe mm mn mo mp b">Websocket</code>定义二进制框架，比HTTP更容易处理二进制内容。</li><li id="f4b6" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">协议标识符是<code class="fe mm mn mo mp b">ws</code>(或者<code class="fe mm mn mo mp b">wss</code>，如果加密的话)，服务器URL是URL。</li><li id="0b18" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">实现很简单。基于TCP协议，服务器端的实现相对容易，没有源码限制。客户端可以与任何服务器通信。</li><li id="2fd0" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">它对HTTP协议有很好的兼容性。默认端口也是80和443，握手阶段使用HTTP协议。所以不容易阻塞握手，可以通过各种HTTP代理服务器。</li><li id="8d47" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">支持扩展。<code class="fe mm mn mo mp b">Websocket</code>定义扩展。用户可以扩展协议，实现一些用户自定义的子协议。例如，一些浏览器支持压缩。</li></ul><h2 id="4b85" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">Websocketde的初始握手</h2><p id="2169" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">每个Web socket连接都从一个HTTP请求开始，这个请求类似于其他请求，但是包含一个特殊的头— <code class="fe mm mn mo mp b">Upgrade</code>。<code class="fe mm mn mo mp b">Upgrade</code>表示客户端将连接升级到<code class="fe mm mn mo mp b">Websocket</code>协议。</p><p id="a612" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">握手之前，<code class="fe mm mn mo mp b">Websocket</code>遵循HTTP/1.1协议。<br/> <br/>客户端发送的升级到Web socket的请求也叫初始握手。客户端发送HTTP升级请求后，直到服务器响应101状态码、<code class="fe mm mn mo mp b">Upgrade</code>和Sec <code class="fe mm mn mo mp b">WebSocket</code> Accept头，连接才成功。否则，连接无法成功。以下是复制的<code class="fe mm mn mo mp b">WebSocket</code>握手的请求头和对应的头:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="4daa" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">WebSocket和HTTP的异同</h2><ol class=""><li id="1d83" class="nd ne iq ll b lm mh lp mi ls nf lw ng ma nh me nt nj nk nl bi translated">相同点</li></ol><ul class=""><li id="971b" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated">都是基于<code class="fe mm mn mo mp b">TCP</code>的应用层协议。</li><li id="3b7a" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">两者都使用<code class="fe mm mn mo mp b">Request/Response</code>模型来建立连接。</li><li id="464c" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">在连接建立期间，错误处理方法是相同的。在此阶段，<code class="fe mm mn mo mp b">WebSocket</code>可能会返回与<code class="fe mm mn mo mp b">HTTP</code>相同的返回码。</li></ul><p id="0a99" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">2.差异</p><ul class=""><li id="a198" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">HTTP</code>协议基于请求/响应。只能进行单向传输，是半双工通信，而<code class="fe mm mn mo mp b">WebSocket</code>是全双工通信。</li></ul><p id="d069" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe mm mn mo mp b">Half duplex communication</code>:单向流，服务器不主动向客户端推送数据。<br/> <code class="fe mm mn mo mp b">Full duplex communication</code>:服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息。是真正的双向平等对话，属于服务器推送技术。</p><ul class=""><li id="d7a3" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">HTTP</code>是无状态的，因此请求在收到响应后被关闭。无状态的好处是服务器不需要存储相关的会话信息。缺点是每个<code class="fe mm mn mo mp b">HTTP</code>请求和响应都会发送关于请求的冗余信息；而<code class="fe mm mn mo mp b">WebSocket</code>只需要建立一次<code class="fe mm mn mo mp b">Request/Response</code>消息对，之后再建立一次<code class="fe mm mn mo mp b">TCP</code>连接，避免了多个<code class="fe mm mn mo mp b">Request/Response</code>消息对产生的冗余头信息。节省了大量的流量和服务器资源。</li></ul><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c4f048e58dff418801a48280c482c760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*zQEOIN9pU1-etssOKpT-6w.png"/></div></figure><ul class=""><li id="1be8" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated">当<code class="fe mm mn mo mp b">WebSocket</code>建立握手连接时，数据通过<code class="fe mm mn mo mp b">HTTP</code>协议传输，但连接建立后，实际的数据传输阶段不需要<code class="fe mm mn mo mp b">HTTP</code>协议参与。<code class="fe mm mn mo mp b">HTTP</code>需要三次握手。</li></ul><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6e740db36f25d650eae1a025108eab04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*PmfvPnVClfjRdFdGapxsgQ.png"/></div></figure><ul class=""><li id="1f6e" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">WebSocket</code>传输的数据是二进制流，基于帧。<code class="fe mm mn mo mp b">HTTP</code>传输是明文传输，是字符串传输。</li></ul><h1 id="b36a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Websocket的API</h1><p id="0c84" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated"><code class="fe mm mn mo mp b">WebSocket</code>在客户端与服务器第一次握手时，将<code class="fe mm mn mo mp b">HTTP</code>协议升级为<code class="fe mm mn mo mp b">WebSocket</code>协议。连接建立后，下面的消息直接在<code class="fe mm mn mo mp b">WebSocket</code>接口定义的方法上来回传递。</p><h2 id="1495" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">WebSocket的实例</h2><p id="b224" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated"><code class="fe mm mn mo mp b">WebSocket</code>协议本质上是基于<code class="fe mm mn mo mp b">TCP</code>的协议。调用<code class="fe mm mn mo mp b">WebSocket</code>构造函数创建一个<code class="fe mm mn mo mp b">WebSocket</code>连接并返回<code class="fe mm mn mo mp b">WebSocket</code>的对象实例。</p><p id="829f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe mm mn mo mp b">WebSocket</code>协议定义了两种URL方案:</p><ul class=""><li id="6637" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated">ws:未加密</li><li id="c103" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">wss:加密(使用HTTPS采用的安全机制来确保HTTP连接的安全性)。</li></ul><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7786" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了建立一个<code class="fe mm mn mo mp b">WebSocket</code>连接，客户端浏览器必须首先向服务器发送一个<code class="fe mm mn mo mp b">HTTP</code>请求。这个请求不同于通常的<code class="fe mm mn mo mp b">HTTP</code>请求，它包含一些额外的报头信息。附加报头信息“Upgrade: WebSocket”表明这是一个<code class="fe mm mn mo mp b">HTTP</code>协议升级请求。服务器解析附加的头信息，然后生成响应信息返回给客户端，客户端和服务器之间的<code class="fe mm mn mo mp b">WebSocket</code>连接就建立了。双方可以通过这个连接通道自由地传递信息，连接会一直持续，直到其中一方客户端或服务器主动关闭连接。</p><h2 id="ebcc" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">Websocket事件</h2><p id="ecd9" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated"><code class="fe mm mn mo mp b">WebSocket</code>纯粹是事件驱动。您可以通过监听<code class="fe mm mn mo mp b">WebSocket</code>对象上的事件来处理数据输入和连接状态变化。下面是<code class="fe mm mn mo mp b">WebSocket</code>对象的四个事件。</p><ul class=""><li id="b09e" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">onopen</code>:客户端与服务器建立连接后触发。它被称为客户端和服务器之间的初始握手。如果收到open，则连接成功，通信准备就绪。</li><li id="4e82" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">onmessage</code>:收到消息时触发。服务器发送给客户端的消息可以包括纯文本消息和二进制数据(blob消息或ArrayBuffer消息)。</li><li id="f057" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">onerror</code>:响应意外故障时触发。出错后，连接总是被终止。</li><li id="fd38" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">onclose</code>:连接关闭时触发。一旦连接关闭，客户端和服务器将不会发送和接收消息。还可以主动调用close()方法来关闭连接。</li></ul><h2 id="627e" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">Websocket方法</h2><ul class=""><li id="13ca" class="nd ne iq ll b lm mh lp mi ls nf lw ng ma nh me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">send()</code>:连接成功后关闭前发送消息(消息只能在打开后关闭前发送)。</li><li id="ebc9" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">close()</code>:关闭连接。</li></ul><h2 id="f7cc" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">Websocket的对象属性</h2><ul class=""><li id="ba90" class="nd ne iq ll b lm mh lp mi ls nf lw ng ma nh me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">readyState</code>:只读属性，表示Web socket的连接状态。这些值如下所示:</li></ul><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="ba52" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">bufferedAmount</code>:只读属性。由<code class="fe mm mn mo mp b">send()</code>放入队列等待传输但尚未发布的UTF-8文本字节数。</li><li id="7af5" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated"><code class="fe mm mn mo mp b">Protocol</code>:开放握手过程中使用的协议。</li></ul><h1 id="d3de" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">用Websocket构建一个简单的聊天室</h1><p id="f24e" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated"><code class="fe mm mn mo mp b">WebSocket</code>的基础学习结束了。现在让我们用我们所学的知识来手动实现一个聊天室演示。</p><h2 id="e12c" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">创建连接</h2><p id="e7ae" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">在这里，我们使用<code class="fe mm mn mo mp b">nodejs</code>来实现服务器端逻辑，并使用第三方<code class="fe mm mn mo mp b">WebSocket</code>通信模块<code class="fe mm mn mo mp b">ws</code>来建立一个简单的<code class="fe mm mn mo mp b">WebSocket</code>连接。</p><ol class=""><li id="f1c9" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me nt nj nk nl bi translated">你需要先安装<code class="fe mm mn mo mp b">ws</code>。</li></ol><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f65e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">2.服务器:创建一个<code class="fe mm mn mo mp b">server.js</code>文件，建立一个<code class="fe mm mn mo mp b">WebSocket</code>连接，启动服务(这里用的是端口3000)。使用<code class="fe mm mn mo mp b">ws</code>第三方插件创建一个新的<code class="fe mm mn mo mp b">WebSocket</code>实例。连接成功后，监听<code class="fe mm mn mo mp b">onmessage</code>事件获取收到的消息，监听<code class="fe mm mn mo mp b">onclose</code>事件处理连接断开逻辑，使用send方法向客户端发送消息。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="15c0" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">3.客户端:这里，<code class="fe mm mn mo mp b">Vue</code>用于构建一个基本项目，并在<code class="fe mm mn mo mp b">home.vue</code>页面上创建一个连接。首先使用原生的<code class="fe mm mn mo mp b">WebSocket</code>创建一个<code class="fe mm mn mo mp b">ws</code>实例，通过<code class="fe mm mn mo mp b">onopen</code>方法监控<code class="fe mm mn mo mp b">WebSocket</code>连接是否成功，即当readyState为“1”时，连接成功。然后在open中处理用户登录聊天室逻辑，用<code class="fe mm mn mo mp b">onmessage</code>接收服务器消息，用<code class="fe mm mn mo mp b">onclose</code>监听断线并进行相应处理，当用户离开聊天室时手动使用close方法。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="b368" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">统计多个聊天室和用户的在线状态</h2><p id="a1ce" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">创建多个聊天室的逻辑是在服务器上执行的。这里我们根据<code class="fe mm mn mo mp b">roomId</code>区分多个聊天室。首先，创建一个数组来存储<code class="fe mm mn mo mp b">roomId</code>。每当创建一个新的聊天室，就在数组中添加一个<code class="fe mm mn mo mp b">roomId</code>。如果进入一个现有房间，在现有房间的在线人数上加“1”。前端负责向服务器发送用户登录和注销通知以及相应的用户信息，并根据服务器发送的消息渲染页面所需的信息。代码如下:</p><p id="cd0f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">home.vue</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="58b3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">serve.js</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="1d5d" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">保持心跳活跃</h2><p id="c0fc" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">在长连接场景中，客户端和服务器并不总是通信。如果双方长时间没有沟通，不清楚对方是否还在联系。所以需要发一条小消息告诉对方“我还活着”才能保证正常连接。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c8855e004ddf15e13d05d503ad5668a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*3qYcJlIF4WZbd-GQ-MbsiA.png"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk">Keep heartbeat alive</figcaption></figure><p id="d0a7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如上图所示，在应用层，客户端通常会向服务器发送一个心跳包“ping”，服务器收到后回复一个“pong”，表示双方都活着。</p><p id="edb9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">除了确保正常连接，心跳还有以下功能:</p><ul class=""><li id="6f25" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated">当服务器检测到客户端没有心跳时，它可以主动关闭通道并让其离线。</li><li id="89c2" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">如果客户端检测到服务器没有响应心跳，它可以重新连接以获得新的连接。</li></ul><p id="ba21" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">例如，当PC用户使用TCP/IP通过Telnet向主机注册时。如果在一天结束时，他们只是关闭电源而没有注销，他们会留下一个半开放的连接。如果客户端已经消失，在服务器上留下一个半开的连接，并且服务器正在等待来自客户端的数据，那么服务器将永远等待。活保持功能试图在服务器端检测这种半开连接。</p><p id="a2bf" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于服务器来说，及时了解连接可用性也是非常重要的:一方面，服务器需要及时清理无效连接，以减轻负载；另一方面，这也是业务需求。比如游戏副本中，服务器需要及时处理玩家断线带来的问题。</p><p id="a323" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">以下是保持心跳活跃的代码:</p><p id="0107" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">home.vue</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4b4b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在<code class="fe mm mn mo mp b">home.vue</code>中，我们创建了一个定时器<code class="fe mm mn mo mp b">heartbeatTimer</code>，在监听<code class="fe mm mn mo mp b">onopen</code>之后，每隔一段时间向服务器发送一次实时“ping”消息。同时，在<code class="fe mm mn mo mp b">heartBeatTimer</code>中创建一个定时器<code class="fe mm mn mo mp b">heartBeatTimeoutJob</code>来检查服务器是否响应了“pong”消息。如果在<code class="fe mm mn mo mp b">heartBeatTimeoutJob</code>设定的时间内没有收到来自服务器的pong消息，将被视为心跳超时。听到心跳超时后，您可以断开连接并重新连接。</p><p id="0313" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">注意<code class="fe mm mn mo mp b">heartbeatTimer</code>的持续时间应该比<code class="fe mm mn mo mp b">heartBeatTimeoutJob</code>长。否则，<code class="fe mm mn mo mp b">heartBeatTimeoutJob</code>不会超时。具体时长可以根据你的业务需求来确定。</p><p id="76c1" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当您在<code class="fe mm mn mo mp b">onmessage</code>回调中收到来自服务器的“pong”消息时，您需要清除并重置心跳超时定时器<code class="fe mm mn mo mp b">heartBeatTimeoutJob</code>。还需要注意的是，在每一个新的定时器创建之前，都需要确定当前环境中是否存在同名的定时器，并将其清除，避免定时器多次运行时出现bug。此外，每次关闭<code class="fe mm mn mo mp b">WebSocket</code>连接时，定时器必须及时清零。否则，即使用户已经离开房间，后台计时器也不会停止运行，这可能会导致内存泄漏和其他未知问题。</p><p id="f536" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">server.js</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8538" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在<code class="fe mm mn mo mp b">server.js</code>中，服务器还应该有一个定时器，检查心跳是否超时。如果超时，它将断开连接并重新计算在线人数。</p><h2 id="aa07" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">必须传达这一信息</h2><p id="361f" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">为什么我们需要获取新闻？</p><p id="d01d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Message Bida用于处理长连接过程中的一些重要消息。由于网络、服务器等原因，用户收不到消息。</p><p id="d7ff" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">消息丢失的几种情况:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi oe"><img src="../Images/6f8aa1c2cc2fc9407cea2916bd915dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9QE-8cIKUlAbbww8.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk">(1) (2) (3)</figcaption></figure><p id="a4dd" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在上图(1)中，当客户端向服务器发送消息时，消息丢失。这种情况无法处理。</p><p id="9f88" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在上图(2) (3)中，如果你已经成功向服务器发送了消息，但在服务器通知用户或其他用户时，由于断网、切换等原因发送失败，则用户无法收到消息。在这种情况下，用户可以通过ack接收重要消息，提高消息到达率。</p><h2 id="d623" class="mq kg iq bd kh mr ms dn kl mt mu dp kp ls mv mw kr lw mx my kt ma mz na kv nb bi translated">使用ack机制处理消息Bida</h2><p id="9d89" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">ack机制用于处理必须到达的消息，即客户端收到消息时，需要发送ack回执告诉服务器消息已收到。如果服务器没有从客户端接收到ack消息，则认为客户端没有接收到该消息，并将重新发送该消息以确保用户能够接收到该消息。当客户端需要接收消息时，使用ack处理消息可能会出现以下情况:</p><ol class=""><li id="9232" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me nt nj nk nl bi translated">正常条件</li></ol><ul class=""><li id="83f8" class="nd ne iq ll b lm ln lp lq ls nu lw nv ma nw me ni nj nk nl bi translated">收到消息后，用户向服务器发送ack。当服务器知道客户端收到消息后，服务器不会推送消息(如下左图所示)。</li><li id="e56c" class="nd ne iq ll b lm nm lp nn ls no lw np ma nq me ni nj nk nl bi translated">用户没有收到消息，所以他没有发送<code class="fe mm mn mo mp b">ack</code>到服务器。服务器没有收到<code class="fe mm mn mo mp b">ack</code>然后重新发送消息。当用户收到消息时，该消息必须完成(见右图)。</li></ul><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi of"><img src="../Images/fe3a12276fa309c7ca5723e1937f2a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/0*4EPNRjXFGUXzFV5x.png"/></div></figure><p id="d156" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">2.故障条件</p><p id="4aac" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">收到消息后，用户向服务器发送ack。在发送过程中，网络中断。结果服务器误以为客户端没有收到消息，重传消息，客户端显示多条重复消息。(这是由ack处理消息绑定流量引起的问题。客户端需要在消息去重复方面进行合作)。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi og"><img src="../Images/119ace311c808a5bf4716cdea1eceea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*WR_EPfW2D0PtehMVqp0u6w.png"/></div></figure><h1 id="0baf" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">收场白</h1><p id="b6f1" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated"><code class="fe mm mn mo mp b">Websocket</code>还需要房间认证、离线消息同步、漫游消息等。开发完善的聊天室和即时通讯功能。有兴趣可以多了解一下。</p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="9d1a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><em class="oo">更多内容尽在</em> <a class="ae mf" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="oo">说白了. io </em> </strong> </a> <em class="oo">。报名参加我们的</em> <a class="ae mf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="oo">免费周报</em> </strong> </a> <em class="oo">。关注我们关于</em> <a class="ae mf" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="oo">推特</em> </strong> </a>，<a class="ae mf" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="oo">LinkedIn</em></strong></a><em class="oo">，</em><a class="ae mf" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="oo">YouTube</em></strong></a><em class="oo">，</em> <a class="ae mf" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="oo">不和</em> </strong> </a> <em class="oo">。对增长黑客感兴趣？检查</em> <a class="ae mf" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="oo">电路</em> </strong> </a> <em class="oo">。</em></p></div></div>    
</body>
</html>