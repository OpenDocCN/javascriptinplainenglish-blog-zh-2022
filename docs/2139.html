<html>
<head>
<title>React 18: What You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应18:你需要知道的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-18-what-you-need-to-know-d7bed3216e2e?source=collection_archive---------7-----------------------#2022-05-17">https://javascript.plainenglish.io/react-18-what-you-need-to-know-d7bed3216e2e?source=collection_archive---------7-----------------------#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="519c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你应该升级你的代码吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3312ee47101b9836de5fdccc8f2936d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-TebwsnSySykwhgbbXUQQ.jpeg"/></div></div></figure><p id="f2c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React 18终于出来了。这个新版本有什么新特点？你应该现在更新你的代码吗？应该怎么做，可能会遇到哪些问题？</p><p id="dd65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">先说最后一个问题……</p><h1 id="a518" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">在实践中升级到React 18</h1><p id="edb7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">让我们先把手弄脏。我有一个旧的存储库，是我第一次做React教程时建立的。这个库可以追溯到React 16的Hooks之前的版本。这感觉像是最坏的情况。这将允许我们看到当我们将React从版本16更新到版本18时会发生什么。</p><p id="1e17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">剧透提醒:很快而且无痛。这就是React 17“无特色更新”的全部内容。</p><p id="5987" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看实践中会发生什么。首先，如果我们在NPM下面，我们会运行:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="d411" class="mq lo iq mm b gy mr ms l mt mu">npm install react@18.0.0 react-dom@18.0.0</span></pre><p id="cae6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们使用纱线，我们将运行:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="fdc3" class="mq lo iq mm b gy mr ms l mt mu">yarn add react@18.0.0 react-dom@18.0.0</span></pre><p id="fe76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我启动这个项目时，一切似乎都很好。但是，如果我们打开控制台，我们会看到以下消息:</p><blockquote class="mv mw mx"><p id="20f5" class="kr ks mk kt b ku kv jr kw kx ky ju kz my lb lc ld mz lf lg lh na lj lk ll lm ij bi translated">React 18中不再支持ReactDOM.render。请改用createRoot。在您切换到新的API之前，您的应用程序将表现得像运行React 17一样”</p></blockquote><p id="48a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是什么意思？这意味着两件事。</p><p id="face" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一件事是React团队已经弃用了初始化React的代码。如果你想利用React的新特性，代码不再是正确的做事方式。</p><p id="e30d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二件事是React很好地处理了反对<em class="mk">的问题。</em></p><p id="ea94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，我的初始化并不理想。但是反应不会给我带来任何痛苦。如你所见，我的代码仍然工作正常，没有任何问题。那么，我该如何解决这个问题呢？如果我查看我的代码，导入和初始化部分显示:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="d850" class="mq lo iq mm b gy mr ms l mt mu">import ReactDOM from “react-dom”;<br/>//…. and then <br/>const root = document.getElementById(“root”);<br/>ReactDOM.render(&lt;App /&gt;, root);<br/></span></pre><p id="a075" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">初始化方法已更改，导入也已更改。现在，在React 18中，我们需要导入客户端版本的React-dom，方法是:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="fc78" class="mq lo iq mm b gy mr ms l mt mu">import ReactDOM from “react-dom/client”;</span></pre><p id="b9fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是因为存在该代码的服务器端版本。现在初始化分两步完成:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="1ca6" class="mq lo iq mm b gy mr ms l mt mu">// first <br/>const root = ReactDOM.createRoot(rootElement);<br/>root.render(&lt;App/&gt;);</span></pre><p id="5994" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">设置现在分为两步，以区分客户端和服务器端的操作，或者允许我们在根上做水合物，而不是渲染。现在，如果只做这两处修改，我的编辑器会抛出一个打字错误。如果您正在使用typescript，您还需要通过执行以下操作来更新类型:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="469e" class="mq lo iq mm b gy mr ms l mt mu">yarn add <a class="ae nb" href="http://twitter.com/types/react" rel="noopener ugc nofollow" target="_blank">@types/react</a>@18.0.0 <a class="ae nb" href="http://twitter.com/types/react-dom" rel="noopener ugc nofollow" target="_blank">@types/react-dom</a>@18.0.0</span></pre><p id="afda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦这些小的修复完成，一切都运行…没有任何问题。因此，您可以将React更新到版本18，而无需特别担心。但是这样做有意义吗？让我们来谈谈React 18带来了什么。</p><h1 id="f573" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">React 18的新特性</h1><p id="2e50" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">而现实是几乎没有什么看得见的变化。比React 17的“无特色更新”更是如此。但还是。在这里，在版本18中，我们看到React团队正在与下一个JS团队携手工作。以及在较小程度上的混音。因为说实话，你和我不会在我们的代码中使用大部分新特性。相反，我们将使用调用它们的第三方库或框架。但是，让我们来谈谈可能会产生重大影响的改进。首先，有一个概念…</p><h2 id="dd47" class="mq lo iq bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md nm bi translated">自动渲染批处理</h2><p id="b3b0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在，让我们想象我们正在管理两个状态。例如，一个表示分数，第二个表示可用的操作。采取行动的用户将增加分数并减少可用的行动。因此，在我们的代码中，我们应该这样写:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="946e" class="mq lo iq mm b gy mr ms l mt mu">setScore(score +1);<br/>setActions(actions — 1);</span></pre><p id="36d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">换句话说，我们正在更新状态两次。到目前为止，React将检测两个独立的状态更新并触发两个渲染。但是React 18引入了自动“批处理”的概念，即渲染任务的分组。尽管有两个独立的状态更新，应用程序将重新呈现一次。</p><p id="b94d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它值得充分利用。虽然我不知道你们中有多少人遇到过性能问题。从理论上来说，这种缺乏有用性的情况对于其他新特性来说更是如此。</p><p id="282d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们快速浏览一下。首先，我们有…</p><h2 id="1340" class="mq lo iq bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md nm bi translated">并发模式</h2><p id="e6c4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">用简单的话来说，就是打破渲染的单一性。</p><p id="fbb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是说:“看看这个计算，对于UI的那一部分。我们可以把它推迟到我们有计算能力的时候。那块UI在等待的时候可以用一个旧值。”为此，有一个“过渡”的概念，它体现了一种非紧急的变化。</p><p id="6546" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们以过滤列表为例。用户开始在过滤器中键入文本。他们希望界面能立即显示输入的文本。以及显示正在进行过滤的列表。</p><p id="46f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果显示过滤后的结果需要几秒钟，用户会理解的。所以对于同一个动作，我们有两种截然不同的反应。一个紧急反应和一个非紧急反应。这种非紧急反应就是React团队所说的“过渡”。</p><p id="9165" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我们现在可以使用一个钩子(称为<em class="mk"> useTransition </em>)和函数(称为<em class="mk"> startTransition </em>)来实现它。</p><p id="927d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是正如宣布React发布的博文所说:</p><blockquote class="mv mw mx"><p id="c2fe" class="kr ks mk kt b ku kv jr kw kx ky ju kz my lb lc ld mz lf lg lh na lj lk ll lm ij bi translated">“我们预计，向应用添加并发性的主要方式是使用支持并发的库或框架。在大多数情况下，您不会直接与并发API交互。例如，不再是开发人员每次导航到新屏幕时都调用startTransition，路由器库将自动在startTransition中包装导航</p></blockquote><p id="496a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我们的下一个话题来说更是如此…</p><h2 id="beab" class="mq lo iq bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md nm bi translated">服务器端渲染</h2><p id="f0a3" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">服务器端渲染和流(仍在开发中)是为NextJS或Remix这样的框架设计的。您可能不会直接使用这个特性。当然，除非您正在构建自己的服务器端框架。</p><p id="4588" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是这个特性给NextJS或Remix带来了很大的希望。</p><p id="c75c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就引出了我的下一点</p><h1 id="6da1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">最后</h1><p id="0a71" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">是否应该升级到React 18？答案是肯定的。不是因为它会彻底改变我们的代码。而是因为没有好的理由不这样做，因为它是如此的无痛。</p><p id="d7f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的应用程序是计算密集型的，这些新特性将会非常有用。即使简单的应用程序也能从优化中获益。</p><p id="d060" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">真正好处是通过像React Router这样的库和像NextJS或Remix这样的框架。他们将利用React 18的新功能。通过这样做，他们将提供用户和开发人员体验的改进，错过这些将是一种耻辱！</p><p id="5806" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，为了利用React 18，我建议您使用NextJS或Remix框架。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="7c98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mk">更多内容请看</em><a class="ae nb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">plain English . io</em></strong></a><em class="mk">。报名参加我们的</em> <a class="ae nb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">免费周报</em> </strong> </a> <em class="mk">。关注我们关于</em><a class="ae nb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">Twitter</em></strong></a><em class="mk">和</em><a class="ae nb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">LinkedIn</em></strong></a><em class="mk">。查看我们的</em> <a class="ae nb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">社区不和谐</em> </strong> </a> <em class="mk">加入我们的</em> <a class="ae nb" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">人才集体</em> </strong> </a> <em class="mk">。</em></p></div></div>    
</body>
</html>