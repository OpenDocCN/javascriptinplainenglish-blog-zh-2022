<html>
<head>
<title>How to Encapsulate Axios Elegantly, You Can Do This</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优雅地封装Axios，可以这样做</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-encapsulate-axios-elegantly-you-can-do-this-a81da0b0bf1c?source=collection_archive---------3-----------------------#2022-12-15">https://javascript.plainenglish.io/how-to-encapsulate-axios-elegantly-you-can-do-this-a81da0b0bf1c?source=collection_archive---------3-----------------------#2022-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e2f21688a2b3f0ffa8a9ad9951a5d8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w3uaUxypsyNKDa9O"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@grakozy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Greg Rakozy</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bbce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看过很多类似的文章，但是付诸实践的时候总是有疑问:<strong class="kf ir">这些看似高级的二次封装会不会让Axios的调用方法变得更加复杂</strong>？</p><p id="e276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为优秀的二次包装具有以下特点:</p><ul class=""><li id="ac86" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">可以改善原生框架的不足</strong>:明确原生框架的不足，在二次打包后可以消除这些不足，同时不会引入新的不足。</li><li id="0385" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">保留原函数</strong>:新框架的API在进行二次封装时，可能会改变原生框架的API的调用方法(比如传递参数的方法)，但我们必须保证原生API上的所有函数都可以通过新API调用。</li><li id="b7d9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">理解成本低</strong>:有使用原生框架经验的开发者，面对重新封装的框架和API时，可以快速理解并上手。</li></ul><p id="c050" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面我将首先描述底层封装，然后描述如何优雅地封装。</p><h1 id="bce2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">1.低级包装</h1><h2 id="5102" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated">1.1将一个特定的方法封装到一个新的API中，但是只暴露很少的参数</h2><p id="0b2f" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">例如下面的代码:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="2a0b" class="nn lq iq nj b be no np l nq nr">export const post = (url, data, params) =&gt; {<br/>  return new Promise((resolve) =&gt; {<br/>    axios<br/>      .post(url, data, { params })<br/>      .then((result) =&gt; {<br/>        resolve([null, result.data]);<br/>      })<br/>      .catch((err) =&gt; {<br/>        resolve([err, undefined]);<br/>      });<br/>  });<br/>};</span></pre><p id="bc75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码中封装了<code class="fe ns nt nu nj b">method</code>为<code class="fe ns nt nu nj b">post</code>的请求方法，用来解决原生API中处理错误时需要使用<code class="fe ns nt nu nj b">try~catch</code>的问题。但是这种封装有一个缺点:整个<code class="fe ns nt nu nj b">post</code>方法只公开了三个参数<code class="fe ns nt nu nj b">URL</code>、<code class="fe ns nt nu nj b">data</code>和<code class="fe ns nt nu nj b">params</code>，通常这三个参数可以满足大多数简单的请求。但是如果我们遇到一个特殊的<code class="fe ns nt nu nj b">post</code>接口，响应时间很慢，需要设置一个很长的超时，上面的<code class="fe ns nt nu nj b">post</code>方法就会立刻打嗝。</p><p id="887f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nj b">axios.post</code>上述特殊场景可以通过原生方法轻松处理，如下所示:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="3740" class="nn lq iq nj b be no np l nq nr">axios.post("/submit", form, { timeout: 15000 });</span></pre><p id="c467" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似的特殊场景还有很多，比如:</p><ul class=""><li id="2ca2" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">需要上传一个表单。表单不仅包含数据，还包含文件。只能设置<code class="fe ns nt nu nj b">headers["Content-Type"]</code>到<code class="fe ns nt nu nj b">"multipart/form-data"</code>进行请求。如果要显示上传文件的进度条，还必须设置<code class="fe ns nt nu nj b">onUploadProgress</code>属性。</li><li id="3c8e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">有一个接口需要防止数据竞争，只能设置<code class="fe ns nt nu nj b">cancelToken</code>或<code class="fe ns nt nu nj b">signal</code>。有人说拦截器可以用来避免种族并发<code class="fe ns nt nu nj b">interceptors</code>。我举一个场景来反对这个:如果同一个页面上有两个或更多的下拉框，两个下拉框都会调用同一个接口来获取下拉选项，那么你的避免拦截器实现的数据竞争的机制就会有问题，因为这些下拉框中只有一个请求不会被中断。</li></ul><p id="435f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有的开发者会说这种接口不会出现，约定好的<code class="fe ns nt nu nj b">post</code>接口都只需要这三个参数。对此我想反驳一下:有潜力的项目总会增加更多的要求，如果你觉得你的项目没有潜力，那我没说。但是如果你不确定将来是否会有更多的特性添加到你的项目中，或者你是否会遇到这样的特殊场景，那么请在第二个包中尽可能地保持与原来的<code class="fe ns nt nu nj b">API</code>一致，并确保<strong class="kf ir">原来的</strong> <code class="fe ns nt nu nj b"><strong class="kf ir">API</strong></code> <strong class="kf ir">能做到的一切，第二个包</strong> <code class="fe ns nt nu nj b"><strong class="kf ir">API</strong></code> <strong class="kf ir">后的新包也能做到</strong>。为了避免遇到以上特殊情况<code class="fe ns nt nu nj b">API</code>时的尴尬修改，为了兼容，会有特别难看的写法。</p><h2 id="3071" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated">1.2封装<code class="fe ns nt nu nj b">Axios is </code>创建一个实例的方法，或者封装一个自定义的<code class="fe ns nt nu nj b">Axios </code>类</h2><p id="9646" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">例如下面的代码:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="e088" class="nn lq iq nj b be no np l nq nr">const createAxiosByinterceptors = (config) =&gt; {<br/>  const instance = axios.create({<br/>    timeout: 1000,<br/>    withCredentials: true,<br/>    ...config,<br/>  });<br/>  instance.interceptors.request.use(xxx, xxx);<br/>  instance.interceptors.response.use(xxx, xxx);<br/>  return instance;<br/>};<br/><br/><br/>class Request {<br/>  instance: AxiosInstance<br/>  interceptorsObj?: RequestInterceptors<br/>  constructor(config: RequestConfig) {<br/>    this.instance = axios.create(config)<br/>    this.interceptorsObj = config.interceptors<br/>    this.instance.interceptors.request.use(<br/>      this.interceptorsObj?.requestInterceptors,<br/>      this.interceptorsObj?.requestInterceptorsCatch,<br/>    )<br/>    this.instance.interceptors.response.use(<br/>      this.interceptorsObj?.responseInterceptors,<br/>      this.interceptorsObj?.responseInterceptorsCatch,<br/>    )<br/>  }<br/>}</span></pre><p id="5ffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上两种编写方法用于创建不同配置和不同拦截器的多个<code class="fe ns nt nu nj b">Axios</code>实例，以应对多种场景。对此我想表达一下我的观点:<strong class="kf ir">一个前端项目中只能存在一个</strong> <code class="fe ns nt nu nj b"><strong class="kf ir">Axios</strong></code> <strong class="kf ir">实例</strong>。多个<code class="fe ns nt nu nj b">Axios</code>实例会增加代码理解的成本，让参与或接手项目的开发者花更多的时间去思考和接受每个实例的<code class="fe ns nt nu nj b">Axios</code>用途和场景，就像拥有多个<code class="fe ns nt nu nj b">Vuex</code>或<code class="fe ns nt nu nj b">Redux</code>同样无用的项目一样。</p><p id="5e1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么有些开发者会问，如果有相当数量的接口需要使用不同的配置和拦截器怎么办？我来分析两种场景:<strong class="kf ir">多配置</strong>和<strong class="kf ir">多拦截器:</strong></p><h2 id="a5ff" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated">1.3多种配置下的处理方式</h2><p id="9bbe" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">如果有两个或更多不同的配置，这些配置中的每一个都由接口的一部分使用。然后你要声明不同配置对应的常数，然后<code class="fe ns nt nu nj b">Axios</code>调用时传入对应的配置常数，如下:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="bf5b" class="nn lq iq nj b be no np l nq nr">const configA = {<br/>  // ....<br/>};<br/>const configB = {<br/>  // ....<br/>};<br/>axios.get("api1", configA);<br/>axios.get("api2", configB);</span></pre><p id="c2c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相比不同配置的多个<code class="fe ns nt nu nj b">Axios</code>例子，上述写法更直观，让看代码的人直接看出区别。</p><h2 id="19d7" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated">1.4多拦截器下的处理方法</h2><p id="01a9" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">如果有两个或更多不同的拦截器，这些拦截器中的每一个都被一些接口使用。然后，<strong class="kf ir">我们可以将这些拦截器挂载到一个全局唯一的</strong> <code class="fe ns nt nu nj b"><strong class="kf ir">Axios</strong></code> <strong class="kf ir">实例</strong>上，然后允许拦截器通过以下两种方式被选择性地执行:</p><p id="13ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">推荐</strong> : <code class="fe ns nt nu nj b">config</code>增加一个自定义属性来决定拦截器是否被执行。代码如下:</p><p id="00a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用请求时，书写方法如下:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="33b9" class="nn lq iq nj b be no np l nq nr">instance.get("/api", {<br/>  enableIcp: true,<br/>});</span></pre><p id="1027" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在拦截器中，我们这样编写逻辑</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="e81a" class="nn lq iq nj b be no np l nq nr">instance.interceptors.request.use(<br/>  (config: RequestConfig) =&gt; {<br/>    const { enableIcp } = config;<br/>    if (enableIcp) {<br/>      //...<br/>    }<br/>    return config;<br/>  },<br/>  (error) =&gt; {<br/>    const { config } = error;<br/>    const { enableIcp } = config;<br/>    if (enableIcp) {<br/>      //...<br/>    }<br/>    return error;<br/>  }<br/>);<br/><br/>instance.interceptors.response.use(<br/>  (response) =&gt; {<br/>    const { config } = response;<br/>    const { enableIcp } = config;<br/>    if (enableIcp) {<br/>      //...<br/>    }<br/>    return response;<br/>  },<br/><br/>  (error) =&gt; {<br/>    const { config } = error;<br/>    const { enableIcp } = config;<br/>    if (enableIcp) {<br/>      //...<br/>    }<br/>    return error;<br/>  }<br/>);</span></pre><p id="cf2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过上面的编写，我们可以<code class="fe ns nt nu nj b">config.enableIcp</code>来判断注册的拦截器是否被执行了。以此类推，我们<code class="fe ns nt nu nj b">config</code>在编写拦截器时，通过插入自定义属性和协作，可以完美地控制单个或多个拦截器的执行。</p><p id="981d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">二级推荐</strong>:使用<code class="fe ns nt nu nj b">Axios</code>官方<code class="fe ns nt nu nj b">runWhen</code>属性来决定是否执行拦截器。<strong class="kf ir">注意该属性只能决定请求拦截器是否执行，不能决定响应拦截器是否执行</strong>。用法如下:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="2cff" class="nn lq iq nj b be no np l nq nr">function onGetCall(config) {<br/>  return config.method === "get";<br/>}<br/>axios.interceptors.request.use(<br/>  function (config) {<br/>    config.headers.test = "special get headers";<br/>    return config;<br/>  },<br/>  null,<br/>  { runWhen: onGetCall }<br/>);</span></pre><h1 id="f992" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.优雅的包装</h1><p id="4e44" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">使用方法如下:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="e3ad" class="nn lq iq nj b be no np l nq nr">apis[method][url](config);</span></pre><p id="4944" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对应接口的<code class="fe ns nt nu nj b">method</code>请求方法是<code class="fe ns nt nu nj b">url</code>接口路径，<code class="fe ns nt nu nj b">config</code>是<code class="fe ns nt nu nj b">AxiosConfig</code>，即配置。</p><p id="475d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回结果的数据类型是:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="67e3" class="nn lq iq nj b be no np l nq nr">{<br/>  data: null | T;<br/>  err: AxiosError | null;<br/>  response: AxiosResponse&lt;T&gt; | null;<br/>}</span></pre><p id="7865" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来展示一下使用效果:</p><h2 id="d815" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated"><strong class="ak"> 2.1 </strong>支持url智能推导，根据输入的url推导出所需的参数和数据。当请求参数丢失或写入错误时，将出现ts错误消息</h2><p id="c50b" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">以两个接口为例:</p><ul class=""><li id="01ba" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">路径是<code class="fe ns nt nu nj b">/register</code>，方法是<code class="fe ns nt nu nj b">post</code>，<code class="fe ns nt nu nj b">data</code>类型是<code class="fe ns nt nu nj b">{ username: string; password: string }</code></li><li id="796c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">路径是<code class="fe ns nt nu nj b">/password</code>，方法是<code class="fe ns nt nu nj b">put</code>，<code class="fe ns nt nu nj b">data</code>类型是<code class="fe ns nt nu nj b">{ password: string }</code>，<code class="fe ns nt nu nj b">params</code>数据类型是<code class="fe ns nt nu nj b">{ username: string }</code></li></ul><p id="c2e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就不再需要通过一个函数来执行请求接口逻辑，而是可以直接<code class="fe ns nt nu nj b">API</code>通过调用来执行请求接口逻辑。如下所示:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="aed8" class="nn lq iq nj b be no np l nq nr">function register(<br/>  data: { username: string; password: string },<br/>  config: AxiosConfig<br/>) {<br/>  return instance.post("/register", data, config);<br/>}<br/><br/>const App = () =&gt; {<br/>  const registerAccount = async (username, password) =&gt; {<br/>    const response = await register({ username, password });<br/>    //...<br/>  };<br/><br/>  return &lt;button onClick={registerAccount}&gt;sign&lt;/button&gt;;<br/>};<br/><br/>const App = () =&gt; {<br/>  const registerAccount = async (username, password) =&gt; {<br/>    const response = await apis.post["/register"]({ username, password });<br/>    //... <br/>  };<br/><br/>  return &lt;button onClick={registerAccount}&gt;sign&lt;/button&gt;;<br/>};</span></pre><p id="0caa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以前我们要在一个组件中调用前端代码写的接口，需要先知道接口<code class="fe ns nt nu nj b">url</code>(如上<code class="fe ns nt nu nj b">/register</code>)，然后<code class="fe ns nt nu nj b">url</code>在前端代码<code class="fe ns nt nu nj b">register</code>中找到接口(如上)对应的请求函数。而如果在本文中使用这种方法，我们只需要知道<code class="fe ns nt nu nj b">url</code>。</p><p id="036b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做的另一个好处是防止接口的重复记录。</p><h2 id="231d" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated">2.2支持返回结果的智能推导</h2><p id="2043" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">以一个接口为例:</p><ul class=""><li id="3e4a" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">路径为<code class="fe ns nt nu nj b">/admin</code>，方法为<code class="fe ns nt nu nj b">get</code>，返回结果的数据类型为<code class="fe ns nt nu nj b">{admins: string[]}</code></li></ul><h2 id="cbec" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated">2.3支持错误捕获，无需编写<code class="fe ns nt nu nj b">try~catch</code>包处理</h2><p id="8859" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">调用时的书写方法如下:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="866e" class="nn lq iq nj b be no np l nq nr">const getAdmins = async () =&gt; {<br/> const { err, data } = await apis.get['/admins']();<br/> if (err) {<br/>   //.. <br/><br/>   return<br/> };<br/> setAdmins(data!.admins);<br/>};</span></pre><h2 id="34bb" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated">2.4支持路径参数，也将智能导出路径参数</h2><p id="e43f" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">以一个接口为例:</p><ul class=""><li id="b19a" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">路径为<code class="fe ns nt nu nj b">/account/{username}</code>，方法为<code class="fe ns nt nu nj b">get</code>，需要<code class="fe ns nt nu nj b">username</code>路径参数</li></ul><p id="7a33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">书写方法如下:</p><pre class="ne nf ng nh gt ni nj nk bn nl nm bi"><span id="17d4" class="nn lq iq nj b be no np l nq nr">const getAccount = async () =&gt; {<br/>  const { err, data } = await apis.get["/account/{username}"]({<br/>    args: {<br/>      username: "123",<br/>    },<br/>  });<br/>  if (err) return;<br/>  setAccount(data);<br/>};</span></pre><h1 id="5808" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">最后</h1><p id="2a34" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated"><strong class="kf ir">感谢阅读</strong>。期待您的关注，阅读更多高质量的文章。</p><div class="nv nw gp gr nx"><div role="button" tabindex="0" class="ab bv gv cb fp ny nz bn oa jw ex"><div class="ob l"><div class="ab q"><div class="l di"><img alt="omgzui" class="l de bw oc od fe" src="../Images/113db82933227743d0067a68e250ac93.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*AmBIV4haXTWPO--EhE0Q1A.jpeg"/><div class="fb bw l oc od fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@omgzui?source=post_page-----a81da0b0bf1c--------------------------------" rel="noopener follow" target="_top"> omgzui </a></p></div></div><div class="og oh gw l"><h2 class="bd ir tn lb fp to fr fs tp fu fw ip bi translated">更好的编程</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tq au tr ts tt qc tu an eh ei tv tw tx el em eo de bk ep" href="https://medium.com/@omgzui/list/better-programing-9b4c9bb174aa?source=post_page-----a81da0b0bf1c--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="ty l fo"><span class="bd b dl z dk">109 stories</span></div></div></div><div class="ot dh ou fp ab ov fo di"><div class="di ol bv om on"><div class="dh l"><img alt="" class="dh" src="../Images/64fcf15e27c514ec49d62966b68dbc15.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*DbDdSUf5SchniJuq"/></div></div><div class="di ol bv oo op oq"><div class="dh l"><img alt="" class="dh" src="../Images/3e6ce891363c151131c5993ca0dcc526.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*7cAp-WibSblfO7hT"/></div></div><div class="di bv or os oq"><div class="dh l"><img alt="" class="dh" src="../Images/a7dd413de22f319a3c4729c9e737feb8.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*FcmHdVfoUOhlJlsG"/></div></div></div></div></div><div class="nv nw gp gr nx"><div role="button" tabindex="0" class="ab bv gv cb fp ny nz bn oa jw ex"><div class="ob l"><div class="ab q"><div class="l di"><img alt="omgzui" class="l de bw oc od fe" src="../Images/113db82933227743d0067a68e250ac93.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*AmBIV4haXTWPO--EhE0Q1A.jpeg"/><div class="fb bw l oc od fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@omgzui?source=post_page-----a81da0b0bf1c--------------------------------" rel="noopener follow" target="_top"> omgzui </a></p></div></div><div class="og oh gw l"><h2 class="bd ir tn lb fp to fr fs tp fu fw ip bi translated">Java Script语言</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tq au tr ts tt qc tu an eh ei tv tw tx el em eo de bk ep" href="https://medium.com/@omgzui/list/javascript-48bfc7b5f93c?source=post_page-----a81da0b0bf1c--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="ty l fo"><span class="bd b dl z dk">57 stories</span></div></div></div><div class="ot dh ou fp ab ov fo di"><div class="di ol bv om on"><div class="dh l"><img alt="" class="dh" src="../Images/64fcf15e27c514ec49d62966b68dbc15.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*DbDdSUf5SchniJuq"/></div></div><div class="di ol bv oo op oq"><div class="dh l"><img alt="" class="dh" src="../Images/3e6ce891363c151131c5993ca0dcc526.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*7cAp-WibSblfO7hT"/></div></div><div class="di bv or os oq"><div class="dh l"><img alt="" class="dh" src="../Images/a7dd413de22f319a3c4729c9e737feb8.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*FcmHdVfoUOhlJlsG"/></div></div></div></div></div><div class="nv nw gp gr nx"><div role="button" tabindex="0" class="ab bv gv cb fp ny nz bn oa jw ex"><div class="ob l"><div class="ab q"><div class="l di"><img alt="omgzui" class="l de bw oc od fe" src="../Images/113db82933227743d0067a68e250ac93.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*AmBIV4haXTWPO--EhE0Q1A.jpeg"/><div class="fb bw l oc od fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@omgzui?source=post_page-----a81da0b0bf1c--------------------------------" rel="noopener follow" target="_top"> omgzui </a></p></div></div><div class="og oh gw l"><h2 class="bd ir tn lb fp to fr fs tp fu fw ip bi translated">新闻</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tq au tr ts tt qc tu an eh ei tv tw tx el em eo de bk ep" href="https://medium.com/@omgzui/list/news-67ec0a972660?source=post_page-----a81da0b0bf1c--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="ty l fo"><span class="bd b dl z dk">23 stories</span></div></div></div><div class="ot dh ou fp ab ov fo di"><div class="di ol bv om on"><div class="dh l"><img alt="" class="dh" src="../Images/c3f36b36bf050f98fd5a8e3c89103cad.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*LISEmTdz19k7BAHY"/></div></div><div class="di ol bv oo op oq"><div class="dh l"><img alt="" class="dh" src="../Images/8459df5aae62dc00f04377e09544be88.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*RvBGLw3V9JZfn_HO"/></div></div><div class="di bv or os oq"><div class="dh l"><img alt="" class="dh" src="../Images/2864058bcedc8c1cd6492624ba9671c6.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*IUWVb3zTn1_HKV9P"/></div></div></div></div></div><p id="7d57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="pa">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pa">说白了就是</em> </strong> </a> <em class="pa">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pa">免费周报</em> </strong> </a> <em class="pa">。关注我们关于</em> <a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pa">推特</em> </strong> </a>，<a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="pa">LinkedIn</em></strong></a><em class="pa">，</em><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="pa">YouTube</em></strong></a><em class="pa">，以及</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pa">不和</em> </strong> </a> <strong class="kf ir"> <em class="pa">。</em>T53】</strong></p><p id="7ef2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="pa">对缩放您的软件启动感兴趣</em> </strong> <em class="pa">？检查出</em> <a class="ae kc" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pa">电路</em> </strong> </a> <em class="pa">。</em></p></div></div>    
</body>
</html>