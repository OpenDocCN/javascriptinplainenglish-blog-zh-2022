<html>
<head>
<title>How to Efficiently Merge Arrays in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中有效地合并数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/efficiently-merging-arrays-in-javascript-32993788a8b2?source=collection_archive---------1-----------------------#2022-02-17">https://javascript.plainenglish.io/efficiently-merging-arrays-in-javascript-32993788a8b2?source=collection_archive---------1-----------------------#2022-02-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/457eaef797f90e6d82e34fa0c43da149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9pqgJullkeeFi6jr"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@6heinz3r?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gabriel Heinzer</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8940" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，我需要在JavaScript中组合两个数组对象。我想要一种简单易懂的方法，运行速度快。这让我比较了JavaScript中各种可用的数组函数<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"/>。我决定创建一些性能基准来比较几种方法。我对我所看到的感到非常惊讶。在这篇文章中，我将分享我所学到的。如果你想快速外卖:</p><h1 id="8416" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">外卖(或TL；博士)</h1><blockquote class="lx ly lz"><p id="7227" class="ka kb ky kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">最安全的方法是使用Array对象的concat方法来合并两个数组。如果速度至关重要，您可以考虑对较小的数组使用JavaScript的spread语法和数组对象的push方法。您应该使用最大数量的元素来测试合并数组，以避免意想不到的后果。</p></blockquote><p id="9707" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://medium.com/@chad.campbell" rel="noopener">如果你觉得这份外卖有帮助，请跟我来</a>。用于得出上述结论的回购可以在<a class="ae jz" href="https://github.com/ecofic/article-efficiently-merging-arrays-in-javascript" rel="noopener ugc nofollow" target="_blank">这里</a>找到。该报告还包括本文中使用的在JavaScript中合并数组的示例。本文还将包括一个性能分析，比较组合数组的方式。</p><h1 id="b53e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JavaScript中组合数组的编码方式</h1><p id="6486" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">就我个人而言，当我写代码时，我的目标是写出a)有效b)易于下一个人阅读(即维护)和c)在运行时有性能的代码。这三个目标有时会发生冲突。不过，一个好的起点是尽可能使用标准的内置特性。因此，本节将<em class="ky">而不是</em>展示定制实现。</p><p id="fae7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一节中，我将向您展示如何用concat方法合并数组。然后，我将向您展示一种将数组与push函数结合起来的方法。最后，我将把spread语法与push函数集成起来，作为融合数组的最终方式。这三个实现将作为下一节中性能分析的基础。我们开始吧。</p><h2 id="d802" class="mi la in bd lb mj mk dn lf ml mm dp lj kl mn mo ln kp mp mq lr kt mr ms lv mt bi translated">用Concat方法合并数组</h2><p id="864a" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">concat函数是JavaScript中合并数组的事实上的标准。事实上，<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>特别声明了这种“用于合并两个或更多数组的方法”。读到这里，实现如下示例所示的代码是有意义的:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/7b6e3736490ba3730400a1af403cb2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vx_onvYwqTjH0eBPMQWwiQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">sample 1</figcaption></figure><p id="c6c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例1将数组2的元素追加到数组1的末尾。值得注意的是，数组1和数组2是由concat函数<em class="ky">而不是</em>改变的。相反，会创建一个新的<em class="ky">数组。下图显示了concat函数的行为。</em></p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/afe9570ce243b60da3ea943f7a8e402e.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/0*3gJkRcgKL7-a_Nx-"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">image 1</figcaption></figure><p id="bdf4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图1强化了示例1中的代码。示例1展示了简洁易读的代码。因为concat函数从ES1开始就出现在JavaScript中，所以可以肯定它是健壮的。这个OG数组函数似乎是正确的选择。尽管如此，我还是想知道如果使用推送功能会发生什么。</p><h2 id="d9dc" class="mi la in bd lb mj mk dn lf ml mm dp lj kl mn mo ln kp mp mq lr kt mr ms lv mt bi translated">用Push函数组合数组</h2><p id="8614" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">push函数将元素添加到现有数组<em class="ky">的末尾。这种行为与concat函数略有不同，因为一个现有的<em class="ky">数组被改变了。下面的示例显示array2被推到array1的末尾。</em></em></p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ad237665bc4f6f868a1ae6bed1e180ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*W6ob5dVqYalWqlGK"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">image 2</figcaption></figure><p id="6e26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图2中使用了push函数来更新array1，以包含array2的内容。当数组1改变时，数组2是<em class="ky">而不是</em>。如果您可以接受更改现有阵列，推送功能可能会满足您的需求。下面的示例显示了代码反射图像2。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/6b5b466a12e7f24669fcc0fd05c86355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiEcSPKIsZp39ahzlW0fYQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">sample 2</figcaption></figure><p id="b7fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与concat函数一样，push函数从ES1开始就是数组类型的函数。示例2中的代码仍然易于阅读。然而，它不如示例1中的代码简洁。要将这段代码浓缩成一行，可以使用JavaScript语言中最近添加的代码。这种添加是扩展语法。</p><h2 id="8664" class="mi la in bd lb mj mk dn lf ml mm dp lj kl mn mo ln kp mp mq lr kt mr ms lv mt bi translated">用扩展语法融合数组</h2><p id="63cf" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">spread语法可用于将数组扩展为单个元素。然后，这些元素可以被视为原始元素的独立浅表副本。由于push函数接受一个<em class="ky">或多个</em>参数，因此spread语法可用于push函数，如下所示:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/a3ebb2a61c210e4990c2c1ff073958a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*FQwDpESR1sHm4Uwml5b_sg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">sample 3</figcaption></figure><p id="32d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例3将示例2浓缩为一行代码。它更简洁一点。如果您不熟悉spread语法，那么这一行的可读性不如前两个示例。尽管如此，下面的图片可能有助于你形象化的行为。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/c9d7780141421c4a14d861826ad0be32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cW7Yo51DC44OwT7s"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">image 3</figcaption></figure><p id="49e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图片3看起来比前面的图片更复杂。知道有两个更简单、可读性更强的选项后，人们可能会想，spread语法是否值得考虑。至少我很好奇。我在比较以不同方式合并数组的性能时看到的结果让我大吃一惊。</p><h1 id="eb52" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">比较合并阵列的性能</h1><p id="6b4f" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">为了比较合并数组的性能，我创建了一个工具来测试性能。该工具可以在<a class="ae jz" href="https://github.com/ecofic/article-efficiently-merging-arrays-in-javascript" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到。如果您克隆了存储库，您可以自己运行这个工具。运行时，您会看到类似这样的内容:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/517333e8463d9d78c2164da489785087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*krqfRdFi4GSmPdI6"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">image 4</figcaption></figure><p id="f38f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图4所示的工具允许您a)设置两个数组b)指定合并数组的次数c)指定合并数组时使用的方法。我使用这个工具测试了三个不同的场景:</p><ol class=""><li id="08fa" class="nf ng in kc b kd ke kh ki kl nh kp ni kt nj kx nk nl nm nn bi translated">原始值数组</li><li id="5363" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">对象数组</li><li id="4777" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">具有对象数组的原始值数组(即混合数组)</li></ol><p id="e5b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于每一个场景，我都使用包含1、10、100、1，000、10，000、100，000和1，000，000个元素的数组运行了100次测试。比较这些的适当方法是使用大ω(即大O)符号。然而，为了简单起见，我只是在2020年的13英寸MacBook Air上运行谷歌Chrome 96.0.4664.55的macOS版本12.0.1进行了测试。您可以自己运行它们，看看是否能得到其他结果。如果你想学习大O记数法，可以看看下面这个关于教育性的附属<a class="ae jz" href="https://www.educative.io/courses/big-o-notation-for-interviews-and-beyond?aff=x4mY" rel="noopener ugc nofollow" target="_blank">大O记数法课程。下面三张图是我亲自观察的结果。</a></p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/9ceac0ac09417a21e80b6e8924d8a3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AyG3lvCyJfwyoV-y"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">image 5: results merging arrays of primitive values</figcaption></figure><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/867995a06f0fc4b21663f2c43962b375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mVYx4tiZgO9_f_ik"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">image 6: results merging arrays of objects</figcaption></figure><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/8ae152eeaae7518e35d1bd2c859c37f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UiWY1y5GDdjDDnCL"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">image 7: results of a hybrid scenario</figcaption></figure><p id="3290" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图5-7显示了我观察到的结果。绿色单元格显示了用于测试场景的最快方法。橙色单元格显示了用于测试场景的最慢方法。乍一看，当综合考虑这三种情况时，spread语法似乎通常是最快的方法。也就是说，直到你得到更大的数组。事实上，如“N/A”所示，spread语法甚至不能用于更大的数组！😲</p><p id="e843" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">spread语法不适用于较大的数组。当使用100，000个元素进行测试时，spread语法生成了一个RangeError，并显示消息:<em class="ky">最大调用堆栈大小超过了</em>。我手动调整了工具中的数字，以确定导致该错误的元素的实际数量。我发现元素的数量是63，653。我现在还不清楚为什么这个数量的元素会导致这个错误。不知道是我的具体环境，具体代码，还是别的什么原因。但是我认为这超出了本文的范围。</p><p id="a538" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为spread语法已经嵌入到JavaScript中，所以我没有想到会遇到RangeError。发生这种情况的原因是因为spread语法将整个源数组(即array2)加载到堆栈上。这意味着较大的数组可能会导致类似RangeError这样的错误。我说<em class="ky">可能</em>是因为，实际后果取决于使用的浏览器引擎(<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply#using_apply_and_built-in_functions" rel="noopener ugc nofollow" target="_blank">来源</a>)。</p><p id="9348" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您需要合并较小的数组，spread语法可以帮助您有效地做到这一点。对于包含更多元素的大型数组，请使用concat函数。不管您的场景如何，都要用您期望的最大数量的元素来测试您的代码。目标是创建有效、易读的代码。</p><p id="1174" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，您看到了在JavaScript中合并两个数组的三种方法。如果你找到了更有效的方法，我希望你能在下面的评论中分享。如果你觉得这篇文章有帮助，请鼓掌👏，或者拍手，在下面。这会让我和其他人知道你觉得它很有用。如果您想了解类似的内容，我鼓励您现在就<a class="ae jz" href="https://medium.com/@chad.campbell" rel="noopener">关注我</a>。感谢阅读。</p><p id="1e85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">说白了。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">免费周报</em> </strong> </a> <em class="ky">。在我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="ky">。</em></strong></a></p></div></div>    
</body>
</html>