<html>
<head>
<title>Android Guide to TurboModules in React Native for Early Adopters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向早期采用者的React Native涡轮模块Android指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/android-guide-to-turbomodules-in-react-native-for-early-adopters-b07f3e23fd1c?source=collection_archive---------2-----------------------#2022-06-20">https://javascript.plainenglish.io/android-guide-to-turbomodules-in-react-native-for-early-adopters-b07f3e23fd1c?source=collection_archive---------2-----------------------#2022-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a5e3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在React Native中提前了解TurboModules和Codegen。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/27b4f15e2968ba6c1eb2be380cee1be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cC9PQ00bv1_1CePwcttLhg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="https://www.pexels.com/photo/love-people-woman-heart-11035471/" rel="noopener ugc nofollow" target="_blank">Photo by RealToughCandy.com</a></figcaption></figure><p id="9777" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以前使用React Native时，我们会使用JavaScript桥在应用程序的“本机”层和“JavaScript”层之间进行通信。尽管这座桥达到了它的目的，但它有几个主要问题。</p><p id="f3f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，桥是异步的，这意味着它批量调用本地层，并在设定的时间间隔调用它们。如果这还不够，在本机端，您必须序列化和反序列化进出桥的数据。这两个操作一起使事情变得非常缓慢。</p><p id="e826" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二，桥不是类型安全的。您几乎可以在桥上传递您想要的任何东西，这取决于本机层来处理这些数据。最后，在应用程序启动时，所有本机模块都需要加载到内存中。这对用户来说意味着缓慢的启动时间。</p><p id="e769" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React Native的创建者引入了Codegen和TurboModules来解决这些问题。TurboModules解决了异步和加载问题，因为它们在JavaScript中以同步方式运行，并延迟加载到内存中，从而使应用程序启动更快。</p><p id="979b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Codegen解决了类型安全的问题，因为它允许我们生成接口来确保我们的本机代码与我们从JavaScript层传入的数据保持同步。</p><p id="63e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本指南将向您展示如何在Android中使用Codegen和TurboModules以及React Native。本系列的第二篇文章将讲述在iOS中做同样的事情。请注意，这是React Native 0.68.2到0.69.0的早期采用者指南。新的React本机架构仍在不断变化，可能会随着时间的推移而改变。如果您遇到困难，可以在这里随意看看我的示例项目<a class="ae ks" href="https://github.com/friyiajr/TurboModuleSample" rel="noopener ugc nofollow" target="_blank">。如果你对我关于这个主题的视频教程感兴趣，请点击这里查看我的</a><a class="ae ks" href="https://www.youtube.com/watch?v=T1-mqNw6LLY&amp;t=932s" rel="noopener ugc nofollow" target="_blank">视频。</a></p><p id="ccb7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">编辑:</strong>React-Native 0 . 69 . 0的用户会在Android Studio中看到虚假错误，声明无法找到导入。我在这里抱怨过这个问题，Meta似乎也意识到了。如果您按照这些说明，并在需要时从我的示例项目中导入，该应用程序仍然可以很好地编译。Android Studio的错误来自于IDE中的一个错误，而不是这段代码。在Visual Studio代码中完成本教程可能是有意义的，这样可以避免Android Studio错误噪音。</p><h2 id="4f0a" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">我们在建造什么？</h2><p id="90f8" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在本文中，我们将构建一个简单的应用程序，它调用输出消息的TurboModule。我知道这很简单，但是在阅读完这篇博客后，你可以用Codegen创建任意复杂的函数。它看起来会像这样:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/10f5c44e7f2c181b1708c1c3f8488e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*W_UAk-dvgAb4xX6Sgoqs0g.gif"/></div></figure><h2 id="b77e" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">React本机设置</h2><p id="b5b2" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">首先，使用以下命令生成一个TypeScript项目:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="a5bb" class="lp lq in mp b gy mt mu l mv mw">npx react-native init TurboModuleSampleProject --template react-native-template-typescript</span></pre><p id="b979" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用TypeScript很重要，因为Codegen要求我们使用类型。普通的JS项目在这里是不行的。</p><p id="d013" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，让我们在项目的根目录下创建一个名为<code class="fe mx my mz mp b">js</code>的文件夹。在<code class="fe mx my mz mp b">js</code>中，我们将创建一个名为<code class="fe mx my mz mp b">NativeSampleModule.ts</code>的文件。请务必在文件名和模块名前加上单词Native。如果你不这样做，Codegen将无法找到你的代码，也不会生成任何东西。这里它不会给你任何错误，并且会无声地失败。最后，将这段代码复制并粘贴到您文件中。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="d827" class="lp lq in mp b gy mt mu l mv mw">import type {TurboModule} from 'react-native';<br/>import {TurboModuleRegistry} from 'react-native';</span><span id="836c" class="lp lq in mp b gy na mu l mv mw">export interface Spec extends TurboModule {<br/>  getHelloWorld(first: string, second: string): string;<br/>}</span><span id="ca68" class="lp lq in mp b gy na mu l mv mw">export default TurboModuleRegistry.getEnforcing&lt;Spec&gt;('NativeSampleModule');</span></pre><h2 id="0bb1" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">Android梯度设置</h2><p id="c695" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在Android中，我们从应用程序层<code class="fe mx my mz mp b">build.gradle</code>开始，将这一行添加到文件的顶部</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="6530" class="lp lq in mp b gy mt mu l mv mw">apply plugin: "com.facebook.react"</span></pre><p id="f8c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">之后，我们需要告诉Android我们的Codegen文件在哪里。我们将这段代码添加到第88行</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="df53" class="lp lq in mp b gy mt mu l mv mw">react {<br/>  jsRootDir = rootProject.file("../js/")<br/>}</span></pre><p id="6570" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，找到属性<code class="fe mx my mz mp b">enableHermes</code>，设置为<code class="fe mx my mz mp b">true</code>。React-Native的新架构不会运行，除非你使用Hermes。之后，取消对该行的注释:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="3305" class="lp lq in mp b gy mt mu l mv mw">preBuild.dependsOn("generateCodegenArtifactsFromSchema")</span></pre><p id="40b0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，转到<code class="fe mx my mz mp b">gradle.properties</code>并设置<code class="fe mx my mz mp b">newArchEnabled=true</code></p><p id="7713" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">运行<code class="fe mx my mz mp b">yarn android</code>来生成我们需要的文件</p><h2 id="5e42" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">编写我们的Java代码</h2><p id="1796" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">现在我们已经配置好了我们的构建，并且生成了JavaScript函数的绑定，让我们打开Android Studio中的<code class="fe mx my mz mp b">android</code>文件夹，编写一些本地代码。</p><p id="c8bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从定位<code class="fe mx my mz mp b">com.turbomodulessampleproject</code>包装开始</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/68b4beb255e511a000e9368fc0662176.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*HKkuPdU5Aqarkf8Lvp7qpg.png"/></div></figure><p id="1355" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个包下创建一个名为<code class="fe mx my mz mp b">NativeSampleModuleImpl.java</code>的新文件。在这个文件中，我们将扩展由Codegen创建的接口。它看起来会像这样。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="fe0e" class="lp lq in mp b gy mt mu l mv mw">package com.turbomodulesampleproject;<br/><br/>import androidx.annotation.NonNull;<br/><br/>import com.facebook.fbreact.specs.NativeSampleModuleSpec;<br/>import com.facebook.react.bridge.ReactApplicationContext;<br/><br/>public class NativeSampleModuleImpl extends NativeSampleModuleSpec {<br/><br/>    public static String <em class="nc">NAME </em>= "NativeSampleModule";<br/><br/>    public NativeSampleModuleImpl(ReactApplicationContext reactContext) {<br/>        super(reactContext);<br/>    }<br/><br/>    @Override<br/>    public String getHelloWorld(String first, String second) {<br/>        return "HelloWorld: " + first + " " + second;<br/>    }<br/><br/>    @NonNull<br/>    @Override<br/>    public String getName() {<br/>        return <em class="nc">NAME</em>;<br/>    }<br/>}</span></pre><p id="8aeb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们想要将我们的包添加到应用程序主机。为此，从上面的涡轮模块包中找到<code class="fe mx my mz mp b">newarchitecture</code>目录，并查找<code class="fe mx my mz mp b">MainApplicationReactNativeHost.java</code>文件。如下覆盖<code class="fe mx my mz mp b">getPackages</code>方法。使用alt + enter导入您需要的任何类</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="d12a" class="lp lq in mp b gy mt mu l mv mw">@Override<br/>protected List&lt;ReactPackage&gt; getPackages() {<br/>  List&lt;ReactPackage&gt; packages = new PackageList(this).getPackages();<br/><br/>  packages.add(new TurboReactPackage() {<br/>    @Nullable<br/>    @Override<br/>    public NativeModule getModule(String name, ReactApplicationContext reactContext) {<br/>      if (name.equals(NativeSampleModuleImpl.<em class="nc">NAME</em>)) {<br/>        return new NativeSampleModuleImpl(reactContext);<br/>      } else {<br/>        return null;<br/>      }<br/>    }<br/><br/>    @Override<br/>    public ReactModuleInfoProvider getReactModuleInfoProvider() {<br/>      return () -&gt; {<br/>        final Map&lt;String, ReactModuleInfo&gt; moduleInfos = new HashMap&lt;&gt;();<br/>        moduleInfos.put(<br/>                NativeSampleModuleImpl.<em class="nc">NAME</em>,<br/>                new ReactModuleInfo(<br/>                        NativeSampleModuleImpl.<em class="nc">NAME</em>,<br/>                        NativeSampleModuleImpl.<em class="nc">NAME</em>,<br/>                        false, // canOverrideExistingModule<br/>                        false, // needsEagerInit<br/>                        true, // hasConstants<br/>                        false, // isCxxModule<br/>                        true // isTurboModule<br/>                )<br/>        );<br/>        return moduleInfos;<br/>      };<br/>    }<br/>  });<br/><br/><br/>  return packages;<br/>}</span></pre><h2 id="57c1" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">编写C++代码</h2><p id="0953" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这里我们需要采取的最后一步是配置C++方面的东西。首先在该路径找到<code class="fe mx my mz mp b">Android.mk</code>文件。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="7f71" class="lp lq in mp b gy mt mu l mv mw">TurboModuleSample/android/app/src/main/jni/Android.mk</span></pre><p id="18cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后取消对Codegen路径的注释，如下所示:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="5d06" class="lp lq in mp b gy mt mu l mv mw">include $(GENERATED_SRC_DIR)/codegen/jni/Android.mk</span></pre><p id="48cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="4340" class="lp lq in mp b gy mt mu l mv mw">LOCAL_C_INCLUDES += $(GENERATED_SRC_DIR)/codegen/jni<br/>LOCAL_SRC_FILES += $(wildcard $(GENERATED_SRC_DIR)/codegen/jni/<em class="nc">*</em>.cpp)<br/>LOCAL_EXPORT_C_INCLUDES += $(GENERATED_SRC_DIR)/codegen/jni</span></pre><p id="d4d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在底部添加您的库。它应该被命名为<code class="fe mx my mz mp b">react_codegen_AppSpec</code>它看起来像这样:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="a904" class="lp lq in mp b gy mt mu l mv mw">LOCAL_SHARED_LIBRARIES := <em class="nc">\<br/></em>  react_codegen_AppSpec <em class="nc">\</em><br/>  libfabricjni <em class="nc">\<br/></em>  libfbjni <em class="nc">\<br/></em>  libfolly_futures <em class="nc">\<br/></em>  libfolly_json <em class="nc">\<br/></em>  libglog <em class="nc">\<br/></em>  libjsi <em class="nc">\<br/></em>  libreact_codegen_rncore <em class="nc">\<br/></em>  libreact_debug <em class="nc">\<br/></em>  libreact_nativemodule_core <em class="nc">\<br/></em>  libreact_render_componentregistry <em class="nc">\<br/></em>  libreact_render_core <em class="nc">\<br/></em>  libreact_render_debug <em class="nc">\<br/></em>  libreact_render_graphics <em class="nc">\<br/></em>  librrc_view <em class="nc">\<br/></em>  libruntimeexecutor <em class="nc">\<br/></em>  libturbomodulejsijni <em class="nc">\<br/></em>  libyoga <em class="nc">\</em></span></pre><p id="08bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后在<code class="fe mx my mz mp b">android/app/src/main/jni/MainApplicationModuleProvider.cpp</code>文件中添加<code class="fe mx my mz mp b">#include &lt;AppSpec.h&gt; </code>，取消注释并替换以下行:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="8424" class="lp lq in mp b gy mt mu l mv mw">#include &lt;AppSpec.h&gt;</span><span id="f4ad" class="lp lq in mp b gy na mu l mv mw">....</span><span id="2854" class="lp lq in mp b gy na mu l mv mw">auto module = AppSpec_ModuleProvider(moduleName, params);<br/>if (module != nullptr) {<br/>    return module;<br/>}</span></pre><p id="619b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这一点上，让我们运行<code class="fe mx my mz mp b">yarn android</code>来确保应用程序编译。</p><h2 id="5d59" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">胜利回归本土</h2><p id="58a4" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">让我们最后测试一下所有的东西。在你的<code class="fe mx my mz mp b">App.tsx</code>文件的任何地方添加下面的代码。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="d019" class="lp lq in mp b gy mt mu l mv mw">import NativeSampleModule from './js/NativeSampleModule';</span><span id="fbd7" class="lp lq in mp b gy na mu l mv mw">...<br/>const showMessage = () =&gt; {<br/>  const message = NativeSampleModule.getHelloWorld('Daniel', 'Friyia');<br/>  alert(message);<br/>};</span><span id="a022" class="lp lq in mp b gy na mu l mv mw">...<br/>&lt;Button title="Click here" onPress={showMessage} /&gt;</span></pre><p id="267b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当您单击该按钮时，您应该会看到一个带有我们在本地层创建的消息的警告弹出。</p><h2 id="315a" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">结论</h2><p id="13a5" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">希望您喜欢React Native for Android中对TurboModules的介绍。很快他们就会拆除这座旧桥，所以对我们来说，及时了解涡轮模块的最新进展是很重要的。请查看第二部分，我将向您展示如何让TurboModules和Codegen在iOS上工作。</p><p id="033c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nc">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">Twitter</em></strong></a><em class="nc">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">LinkedIn</em></strong></a><em class="nc">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">社区不和谐</em> </strong> </a> <em class="nc">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">人才集体</em> </strong> </a> <em class="nc">。</em></strong></a></p></div></div>    
</body>
</html>