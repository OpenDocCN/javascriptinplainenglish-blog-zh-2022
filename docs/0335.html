<html>
<head>
<title>Communicate Across Browser Tabs Using postMessage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用postMessage跨浏览器选项卡进行通信</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/communicate-across-browser-tabs-using-postmessage-fd1e37169952?source=collection_archive---------1-----------------------#2022-01-20">https://javascript.plainenglish.io/communicate-across-browser-tabs-using-postmessage-fd1e37169952?source=collection_archive---------1-----------------------#2022-01-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="144c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在JavaScript中实现一个简单而强大的特性，该特性源自浏览器的窗口对象，称为postMessage。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ab598948aafa9d6cc0ae98acfb6ffbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*npIm-C853eDBL_ND.jpg"/></div></div></figure><p id="2cb1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">嗨伙计们！在这篇文章中，我们将学习并实现JavaScript中一个最简单但功能强大的特性，它来自于浏览器的窗口对象postMessage。在进一步探讨这个问题之前，让我展示一个用例，在这个用例中，这个漂亮的特性非常有用。</p><h1 id="42e5" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">使用案例</h1><p id="e261" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">让我们假设一旦用户登录到你的应用程序(例如:example.com)并保持空闲(为了简单起见，让我们认为用户在没有API调用时是空闲的)持续10分钟，我们希望用户强制注销，否则我们可以照常继续会话。</p><p id="a5bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在另一个场景中，用户登录应用程序，通过点击当前标签上的某个链接导航到新标签(这可以是不同的域，例如:random.com ),并继续在新打开的标签上工作。(由于两个选项卡共享同一个会话，用户无需重新登录新选项卡)。</p><p id="0dbd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，在新选项卡上持续处于活动状态(API调用被触发)后，用户在10分钟后从原始选项卡注销，因此会话在其他打开的选项卡上也过期。</p><p id="760a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">简而言之，新打开的选项卡上的活动不会被视为原始选项卡/应用程序上的活动。然而，由于某种原因，原来的选项卡没有被通知新选项卡中正在执行的活动。</p><p id="34f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这正是我们想要解决的问题，这可以通过两个标签之间的沟通渠道来实现。让我们试着解决这个问题，看看window的postMessage如何成为我们的救星。</p><blockquote class="mh mi mj"><p id="6df8" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated"><code class="fe mo mp mq mr b"><strong class="kq io">window.postMessage()</strong></code>方法安全地启用了<code class="fe mo mp mq mr b">Window</code>对象之间的跨原点通信；<em class="in">例如，</em>在页面和它产生的弹出窗口之间，或者在页面和嵌入其中的iframe之间。</p><p id="f2cd" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated"><em class="in">语法:</em> <br/> postMessage(消息，目标来源)</p></blockquote><h1 id="5825" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">活动发送者:新打开的选项卡</h1><p id="c0ae" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们将利用<code class="fe mo mp mq mr b"><strong class="kq io">window.opener</strong></code>派生<code class="fe mo mp mq mr b">postMessage</code>方法。所以我们可以定义如下:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="bfe4" class="mw ll in mr b gy mx my l mz na">const winRef = window.opener;</span><span id="c1fc" class="mw ll in mr b gy nb my l mz na">// NOTE: if you want to communicate from an iframe and winRef is coming as undefined, try below-<br/>// const winRef = top.window.opener;</span></pre><p id="3b48" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们有了窗口引用对象，我们可以利用postMessage函数来发送数据:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="11fc" class="mw ll in mr b gy mx my l mz na">winRef.postMessage("hello from nTab!", "http://example.com");</span><span id="8234" class="mw ll in mr b gy nb my l mz na">// where, <a class="ae nc" href="http://example.com," rel="noopener ugc nofollow" target="_blank">http://example.com</a> is targetOrigin where the message will be sent, our original tab (lets call it oTab)</span></pre><blockquote class="mh mi mj"><p id="6547" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated">请注意，出于安全原因，提供特定的targetOrigin非常重要，因为postMessage会将消息发送到浏览器中所有打开的标签，因此任何人都可以监听发送的数据(不太安全！).</p></blockquote><p id="1f94" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的例子中，我们已经从oTab窗口中打开了nTab，所以我们也可以从<code class="fe mo mp mq mr b">document</code>对象中获得targetOrigin值:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="014a" class="mw ll in mr b gy mx my l mz na">const targetOrigin  = document.referrer;</span><span id="b4e2" class="mw ll in mr b gy nb my l mz na">winRef.postMessage("hello from nTab!", <!-- -->targetOrigin<!-- -->);</span></pre><p id="938c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们的目标是知道新选项卡上发生了一个活动(让我们用domain random.com称之为nTab)。因为我们认为用户只有在API被触发时才是活动的，所以我们需要拦截nTab上发生的任何API调用。我们可以通过使用XMLHttpRequest实现这一点，如下所示:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="9c0b" class="mw ll in mr b gy mx my l mz na">XMLHttpRequest.prototype.send = function() { <br/>// intercept the request here <br/>}</span></pre><p id="d980" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们现在可以创建一个计数器，每当触发API时重置它，然后我们可以检查setInterval，如果计数器值重置，则每隔30秒向oTab发送一次活动报告，然后递增计数器。代码如下:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="687e" class="mw ll in mr b gy mx my l mz na">const winRef = window.opener;</span><span id="a7f6" class="mw ll in mr b gy nb my l mz na">const targetOrigin  = document.referrer;<br/>const counter = 0;</span><span id="78a5" class="mw ll in mr b gy nb my l mz na">setInterval(function() {<br/>    <!-- -->winRef.postMessage({tab: "nTab", isActive: <!-- -->counter === 0<!-- -->}, targetOrigin);<br/>   couter++;<br/>  <!-- -->}, 30000);</span><span id="990d" class="mw ll in mr b gy nb my l mz na">XMLHttpRequest.prototype.send = function() { <br/>   counter = 0; <br/>}</span></pre><h1 id="2356" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">活动接收者:原始页签</h1><p id="c0ef" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">现在，在我们原来的选项卡oTab上，我们可以连续监听来自nTab的事件，并采取必要的措施:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="d453" class="mw ll in mr b gy mx my l mz na">window.addEventListener("message", (event) =&gt; {<br/>  if (event.origin === "http://random.com") {<br/>      if (event.data.isActive) {<br/>         // activity happened in nTab<br/>  }<br/> }    <br/>}, false);</span></pre><p id="c753" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后我们也可以在这里维护一个计数器来跟踪oTab上发生的活动。</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="4d7e" class="mw ll in mr b gy mx my l mz na">const winRef = window.opener;<br/>const counter = 0;</span><span id="99e4" class="mw ll in mr b gy nb my l mz na">setInterval(function() {<br/>  <!-- -->window.addEventListener("message", (event) =&gt; {<br/>      if (event.origin === "http://random.com" &amp;&amp; event.data.isActive) {<br/>         counter = 0;<br/>   } else {<br/>      couter++;<br/>     }   <br/>}, false);<br/>  <!-- -->}, 60000);</span><span id="0617" class="mw ll in mr b gy nb my l mz na">XMLHttpRequest.prototype.send = function() { <br/>   counter = 0;<br/>}</span></pre><p id="90b3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，基于计数器值，我们可以注销用户，或者更新/继续会话。</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="1e8e" class="mw ll in mr b gy mx my l mz na">if(counter &gt; 9) { // 10min <br/>   window.location.href = '/logout'; <br/>   // we can also ask the user to re-login via a popup<br/>  } else { <br/>      // session continues <br/>  }</span></pre><p id="ce63" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在有解决问题的方法了！</p><h1 id="c35e" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">附加部分:通过<code class="fe mo mp mq mr b">window.open</code>引用识别新打开的标签</h1><p id="849b" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">当我们从oTab打开一个链接时，我们最有可能使用的是<code class="fe mo mp mq mr b">window.open</code>方法。因此，我们可以将该引用与接收到的<code class="fe mo mp mq mr b">event</code>源进行比较，并识别新打开的标签。现在，我们的接收器代码看起来像这样:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="2c2c" class="mw ll in mr b gy mx my l mz na">document.getElementsByClassName('goto-nTab').onclick = function () {<br/>        const ref = window.open('http://random.com');<br/>    }</span></pre><p id="2f64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们可以比较<code class="fe mo mp mq mr b">ref</code>和<code class="fe mo mp mq mr b">event.source</code>来识别它是nTab。这里:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="4dfc" class="mw ll in mr b gy mx my l mz na">const winRef = window.opener;<br/>const counter = 0;<br/>let ref = null;</span><span id="85fe" class="mw ll in mr b gy nb my l mz na">document.getElementsByClassName('goto-nTab').onclick = function () {<br/>        ref = window.open('http://random.com');<br/>    }</span><span id="64e4" class="mw ll in mr b gy nb my l mz na">setInterval(function() {<br/>  <!-- -->window.addEventListener("message", (event) =&gt; {<br/>      if (ref == event.source &amp;&amp; event.data.isActive) {<br/>         counter = 0;<br/>   } else {<br/>      couter++;<br/>     }   <br/>}, false);<br/>  <!-- -->}, 60000);</span><span id="1776" class="mw ll in mr b gy nb my l mz na">XMLHttpRequest.prototype.send = function() { <br/>   counter = 0;<br/>}</span></pre><p id="b18d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您还可以进一步探索<code class="fe mo mp mq mr b">window</code>对象，深入了解并展示它所包含的内容(使用调试器帮助！).</p><p id="96b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读！如果你有任何问题/建议，请写在评论里。</p><p id="8442" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mk">更多内容看</em> <a class="ae nc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mk">说白了。报名参加我们的</em> <a class="ae nc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mk">免费周报</em> </strong> </a> <em class="mk">。在我们的</em> <a class="ae nc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mk">社区不和谐</em> </strong> </a> <em class="mk">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>