<html>
<head>
<title>Memoization in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的记忆化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/memoization-in-javascript-99cf00b43019?source=collection_archive---------10-----------------------#2022-11-08">https://javascript.plainenglish.io/memoization-in-javascript-99cf00b43019?source=collection_archive---------10-----------------------#2022-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac14" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是记忆，什么时候你应该使用它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1419b1af05e03b55dd63a20fe674ab61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PC98LkP6l6UGRtUR6RVrg.jpeg"/></div></div></figure><h1 id="a446" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">什么是记忆化</h1><p id="613d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">记忆化的概念是由Donald Michie和K.B. Bennett在1965年提出的，他们将其描述为“存储先前计算的值的艺术，以便以后可以快速查找。”</p><p id="651d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">JavaScript中的Memoization </strong>实际上是一种优化应用程序性能的技术，它存储昂贵的函数调用的结果，并在再次使用相同的输入时返回缓存的结果。这样可以节省时间，因为函数不必在每次调用时都执行:而是返回上次执行的结果。</p><p id="bde4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了更好地理解它是如何工作的，让我们来看一个代码示例。</p><h1 id="bef5" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">代码示例</h1><p id="f586" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">假设我们有一个非常低效的函数来计算一个数的平方。<br/>该功能是故意低效的，以展示记忆的力量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b95b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果我们尝试使用这个函数来计算15000的平方，几秒钟后它就会给出结果。</p><p id="5540" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果我们重复这个操作，并且连续5次调用这个函数，每次都需要几秒钟来计算结果。</p><p id="082f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了提高效率，我们可以使用memoization:主要思想是存储以前的结果，所以如果我们用相同的输入连续几次调用这个函数，第一次仍然需要几秒钟才能给出结果，但是所有其他时间结果都会立即显示。这样，我们可以根据输入“缓存”值。</p><p id="f357" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们看看如何实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7946" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们添加了一个变量<code class="fe mn mo mp mq b">const previousValues = []</code>，它最初是一个空数组。<br/>函数计算出结果后，我们将结果存储在这个<code class="fe mn mo mp mq b">previousValues</code>数组的<code class="fe mn mo mp mq b">number</code>位置，如下:<code class="fe mn mo mp mq b">previousValues[number] = result</code></p><p id="11b4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在我们可以添加一个if语句，说明如果<code class="fe mn mo mp mq b">number</code>的值已经在<code class="fe mn mo mp mq b">previousValues</code>数组中，那么只返回该值，否则计算它。</p><p id="88fe" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">因此，如果我们再次尝试运行该函数，第一次仍然会很慢，但所有其他时间都是用相同的输入调用该函数，结果会很快返回。</p><p id="9df7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是记忆的一个完美的例子:你有一个需要很长时间执行的函数，你想反复得到相同的值。</p><h1 id="777b" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">何时何地使用记忆。</h1><p id="4cfa" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在让我们来看看记忆化的一些实际应用。</p><ul class=""><li id="8ebd" class="mr ms iq ll b lm mg lp mh ls mt lw mu ma mv me mw mx my mz bi translated"><strong class="ll ir">动态规划:</strong>在动态规划中，你要解决很多子问题，然后把它们的结果组合起来。例如，著名的斐波那契数列就是一个动态程序的例子，其中每个结果都依赖于之前的结果(之前的数字)。这意味着，如果您需要多次进行这种计算，您不希望每次都重新计算所有这些中间值-您希望存储它们，以便它们只需要在输入发生变化时进行更新。记忆使我们能够做到这一点！</li><li id="0f61" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated"><strong class="ll ir"> Web应用:</strong>内存缓存在Web应用中被广泛使用，因为它可以显著提高性能，并通过减少不必要的计算来降低服务器负载。诸如V8或SpiderMonkey的JIT编译器(即时编译)之类的JavaScript引擎的能力在这里很有帮助，因为大多数现代浏览器在运行JavaScript代码时都在内部使用内存缓存，所以它们可以重用已经计算过的值，而不是在代码块/函数调用链的每次迭代中重新计算它们，这将是非常低效的，特别是对于大型数组或嵌套循环。</li></ul><h1 id="8460" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论</h1><p id="a321" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我希望这篇文章已经帮助你理解了记忆化的概念以及如何在你自己的代码中使用它。内存化易于实现，并且在某些情况下可以极大地提高性能。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="7af1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="mf">考虑</em> <a class="ae nm" href="https://ebelinggianmarco.medium.com/membership" rel="noopener"> <strong class="ll ir"> <em class="mf">成为中等成员</em></strong></a><strong class="ll ir"><em class="mf"/></strong><em class="mf">如果你喜欢看这样的故事，并且想帮助我这个作家。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae nm" href="https://ebelinggianmarco.medium.com/membership" rel="noopener"> <strong class="ll ir"> <em class="mf">我的链接注册，我会得到一点佣金。</em> </strong> </a></p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="c436" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="mf">更多内容请看</em><a class="ae nm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="mf">plain English . io</em></strong></a><em class="mf">。报名参加我们的</em> <a class="ae nm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="mf">免费周报</em> </strong> </a> <em class="mf">。关注我们上</em><a class="ae nm" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="mf">Twitter</em></strong></a><a class="ae nm" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="mf">LinkedIn</em></strong></a><strong class="ll ir"><em class="mf"/></strong><a class="ae nm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="mf">YouTube</em></strong></a><strong class="ll ir"><em class="mf"/></strong><em class="mf">和</em> <a class="ae nm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="mf">不和</em> </strong> </a>  <em class="mf">对成长黑客感兴趣？检查</em> <a class="ae nm" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="mf">电路</em> </strong> </a> <strong class="ll ir"> <em class="mf">。</em> </strong></p></div></div>    
</body>
</html>