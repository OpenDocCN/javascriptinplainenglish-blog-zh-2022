<html>
<head>
<title>JavaScript Algorithms: Solve Fibonacci Sequence(LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:求解斐波那契数列(LeetCode)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithms-solve-fibonacci-sequence-leetcode-e854842bfd50?source=collection_archive---------2-----------------------#2022-11-24">https://javascript.plainenglish.io/javascript-algorithms-solve-fibonacci-sequence-leetcode-e854842bfd50?source=collection_archive---------2-----------------------#2022-11-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/16d5855feb125c323f9bdf084def2032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSvJM4HBG0PgnwfPO-7Vlw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@luddelorentz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ludde Lorentz</a> on <a class="ae jz" href="https://unsplash.com/s/photos/fibonacci?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6070" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常表示为<code class="fe ky kz la lb b">F(n)</code>的<strong class="kc io">斐波纳契数列</strong>形成了一个序列，称为<strong class="kc io">斐波纳契数列</strong>，这样，从<code class="fe ky kz la lb b">0</code>和<code class="fe ky kz la lb b">1</code>开始，每个数字都是前两个数字的和。以下整数序列中的数字0，1，1，2，3，5，8，13，21，34，55，89，…..</p><p id="24d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="ab10" class="lk ll in lb b be lm ln l lo lp">F(0) = 0, F(1) = 1<br/>F(n) = F(n - 1) + F(n - 2), for n &gt; 1.</span></pre><p id="b65d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定<code class="fe ky kz la lb b">n</code>，计算<code class="fe ky kz la lb b">F(n)</code>。</p><p id="b58b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例1: </strong></p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="6d3a" class="lk ll in lb b be lm ln l lo lp">Input: n = 2<br/>Output: 1<br/>Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span></pre><p id="79ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例2: </strong></p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="54fb" class="lk ll in lb b be lm ln l lo lp">Input: n = 3<br/>Output: 2<br/>Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</span></pre><p id="3663" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例3: </strong></p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="900a" class="lk ll in lb b be lm ln l lo lp">Input: n = 4<br/>Output: 3<br/>Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</span></pre><p id="2858" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">约束:</strong></p><ul class=""><li id="003a" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated"><code class="fe ky kz la lb b">0 &lt;= n &lt;= 30</code></li></ul><h2 id="0e79" class="lz ll in bd ma mb mc dn md me mf dp mg kl mh mi mj kp mk ml mm kt mn mo mp mq bi translated">解决办法</h2><p id="ffd7" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">解决这个问题有几种选择:<em class="mw">递归方法、优化递归方法、迭代方法、优化迭代方法、矩阵求幂方法、数学方法</em>。</p><h2 id="e210" class="lz ll in bd ma mb mc dn md me mf dp mg kl mh mi mj kp mk ml mm kt mn mo mp mq bi translated"><strong class="ak">递归方法</strong></h2><p id="9f93" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">一种简单的方法是直接递归实现数学递推关系。解决这个问题最慢的方法因为需要指数级的<em class="mw">时间复杂度</em>:<strong class="kc io"><em class="mw">o(2^n)</em></strong><em class="mw">空间复杂度</em> : <strong class="kc io"> <em class="mw"> O(N) </em> </strong>。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="0207" class="lz ll in bd ma mb mc dn md me mf dp mg kl mh mi mj kp mk ml mm kt mn mo mp mq bi translated">递归<strong class="ak">使用记忆(自顶向下方法)</strong></h2><p id="a888" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们可以通过存储到目前为止计算的斐波那契数来避免递归中的重复工作。我们只需要将所有的值存储在一个地图中。<em class="mw">时间复杂度</em> : <strong class="kc io"> <em class="mw"> O(N) </em> </strong>和<em class="mw">空间复杂度</em> : <strong class="kc io"> <em class="mw"> O(N) </em> </strong>。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="4994" class="lz ll in bd ma mb mc dn md me mf dp mg kl mh mi mj kp mk ml mm kt mn mo mp mq bi translated">迭代<strong class="ak">方法</strong></h2><p id="3b5c" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">迭代，使用已经计算的斐波纳契值，求解所有子问题并返回N元素的答案。<em class="mw">时间复杂度</em> : <strong class="kc io"> <em class="mw"> O(N) </em> </strong>和<em class="mw">空间复杂度</em> : <strong class="kc io"> <em class="mw"> O(N) </em> </strong>。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="8338" class="lz ll in bd ma mb mc dn md me mf dp mg kl mh mi mj kp mk ml mm kt mn mo mp mq bi translated">迭代方法(<strong class="ak">空间优化)</strong></h2><p id="b867" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们可以优化存储前两个数字的迭代方法，因为这是我们得到序列中下一个斐波纳契数所需要的。<em class="mw">时间复杂度</em> : <strong class="kc io"> <em class="mw"> O(N) </em> </strong>和<em class="mw">空间复杂度</em> : <strong class="kc io"> <em class="mw"> O(1) </em> </strong>。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="a766" class="lz ll in bd ma mb mc dn md me mf dp mg kl mh mi mj kp mk ml mm kt mn mo mp mq bi translated">矩阵求幂方法</h2><p id="bac7" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">使用矩阵求幂从结果矩阵中的<em class="mw"> (0，0) </em>处的元素中得到斐波那契数。为了做到这一点，我们可以依靠斐波那契数列的矩阵方程，找到第N个斐波那契数:</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/4d67381da9b5c9c79baef5a2a6677166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hopTUbvI6AZj7Y2hnzEjQg.png"/></div></div></figure><p id="c2e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个公式是如何工作的你可以看看<a class="ae jz" href="https://en.wikipedia.org/wiki/Fibonacci_number#Matrix_form" rel="noopener ugc nofollow" target="_blank">维基</a></p><p id="915b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个解有:<em class="mw">时间复杂度</em> : <strong class="kc io"> <em class="mw"> O(logN) </em> </strong>和<em class="mw">空间复杂度</em>:<strong class="kc io"><em class="mw">O(logN)</em></strong>。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="4d1e" class="lz ll in bd ma mb mc dn md me mf dp mg kl mh mi mj kp mk ml mm kt mn mo mp mq bi translated">数学方法</h2><p id="88c0" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们可以使用<code class="fe ky kz la lb b">golden ratio forumula</code>:</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/10084983bf21d60e40778b645c0856ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwViOzTyX5pjviqMpI2YxA.png"/></div></div></figure><p id="463a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有一个<a class="ae jz" href="http://demonstrations.wolfram.com/GeneralizedFibonacciSequenceAndTheGoldenRatio/" rel="noopener ugc nofollow" target="_blank">链接</a>来了解更多关于斐波那契数列和黄金分割率的工作原理。</p><p id="8cfb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个解有:<em class="mw">时间复杂度</em>:<strong class="kc io"><em class="mw">O(logN)</em></strong>和<em class="mw">空间复杂度</em> : <strong class="kc io"> <em class="mw"> O(1) </em> </strong>。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><blockquote class="ni nj nk"><p id="d52c" class="ka kb mw kc b kd ke kf kg kh ki kj kk nl km kn ko nm kq kr ks nn ku kv kw kx ig bi translated">此外，有时需要返回的不是给定N的值，而是给定N之前的Fibonacci元素数组。</p></blockquote><p id="5b13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例如:</strong></p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="6cf1" class="lk ll in lb b be lm ln l lo lp">Input: n = 7<br/>Output: [0, 1, 1, 2, 3, 5, 8, 13]</span></pre><p id="92c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，最合适的解决方案是<strong class="kc io"> <em class="mw">迭代方法</em> </strong> <br/>但是返回数组本身:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="413b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和<strong class="kc io"> <em class="mw">递归</em> </strong> <strong class="kc io"> <em class="mw">使用记忆化</em> </strong>变化不大:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="798c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经考虑了解决斐波纳契问题的不同选择，最难理解的是矩阵求幂，但通常了解前面的4种方法就足够面试了。</p><p id="064d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望对你有用！</p><p id="c169" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！回头见。😊</p><p id="d305" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mw">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mw">plain English . io</em></strong></a><em class="mw">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mw">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mw">LinkedIn</em></strong></a><em class="mw"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mw">YouTube</em></strong></a><em class="mw"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mw">不和</em> </strong> </a> <em class="mw">。对增长黑客感兴趣？检查</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mw">电路</em> </strong> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>