<html>
<head>
<title>3 Things You Should Know about Memoization in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React中的记忆，你应该知道的3件事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-things-you-should-know-about-memoization-in-react-b2f09570bb53?source=collection_archive---------19-----------------------#2022-02-28">https://javascript.plainenglish.io/3-things-you-should-know-about-memoization-in-react-b2f09570bb53?source=collection_archive---------19-----------------------#2022-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e13e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在React项目中使用记忆方法之前，每个开发人员都应该知道的三件事。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cebedcb801ea27f2cb12ba3fe30bdf03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*A1FHOYfRbkuiOquS4U69hg.jpeg"/></div></div></figure><p id="4d9d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">记忆是一种缓存计算量很大的函数的结果的技术。在React中，我们可以使用这种技术来避免不必要的重新渲染和昂贵的重新计算。React为此提供了三种方法:</p><ul class=""><li id="9d64" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><strong class="kq io"> memo </strong>:用于记忆组件的高阶组件。</li><li id="3329" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq io"> useMemo </strong>:用于记忆一个计算代价很高的值的钩子</li><li id="3cab" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq io"> useCallback </strong>:类似于useMemo，用于记忆一个回调函数。</li></ul><p id="f466" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">尽管内存化对于提高性能很有帮助，但是如果使用不当，它可能会产生相反的效果。让我们看看在React项目中使用这些方法之前应该注意的三件事。</p><h1 id="2c7e" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">1.内存化意味着性能优化</h1><p id="b6c0" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">除非在应用程序中遇到性能问题，否则使用任何记忆方法都不是一个好主意。你的代码应该在没有记忆的情况下工作(不管它有多慢)。根据经验，您应该在实现组件后考虑优化。</p><p id="0957" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您注意到性能问题，React DevTools可以帮助您找到性能瓶颈。但是也要记住，记忆化并不能解决所有的性能问题。因此，最好总是检查是否从中获得了任何改进。</p><p id="0648" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，要警惕过早的优化，这样你就不会在没有必要的情况下浪费时间进行优化。JavaScript中的大多数操作都经过了优化，总体而言，React框架的性能非常好。因此，在大多数情况下，可能不需要进一步的优化。</p><h1 id="440a" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">2.内存化有性能开销</h1><p id="550c" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">性能优化通常伴随着一些权衡。记忆化尤其如此。通过缓存以前的结果，我们使用更多的内存来提高速度。所以，你应该经常考虑记忆的成本是否值得。这取决于用例，但值得注意的是，如果性能改善不明显，使用它会有额外的开销。</p><h1 id="fad6" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">3.反应并不总是保证记忆</h1><p id="e6c6" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">在React文档上，如果您看到<a class="ae mv" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">使用备忘录</a>上的部分，内容如下:</p><p id="5459" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以依赖useMemo作为性能优化，而不是作为语义保证。</p><p id="6985" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你也看看文档中的<a class="ae mv" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> React.memo </a>，你会发现:</p><p id="abf7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种方法仅作为性能优化而存在。不要依赖它来“阻止”渲染，因为这会导致错误。</p><p id="622a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React将尽可能长时间地缓存结果，但在某些情况下，它也可能选择使缓存无效。因此，不能保证记忆的值没有被丢弃。这意味着你不能依赖React总是为你记忆价值观。为了避免在应用程序中引入错误，请始终使用内存化方法来优化性能，仅此而已。</p><h1 id="587c" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">结论</h1><p id="0a42" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">我希望你现在已经掌握了在负责任的反应中使用记忆所需要的所有信息。请分享您的意见和建议，感谢您的阅读。</p><p id="565c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mw">更多内容请看</em><a class="ae mv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mw">plain English . io</em></strong></a><em class="mw">。报名参加我们的</em> <a class="ae mv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae mv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mw">Twitter</em></strong></a><em class="mw">和</em><a class="ae mv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mw">LinkedIn</em></strong></a><em class="mw">。加入我们的</em> <a class="ae mv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">社区不和谐</em> </strong> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>