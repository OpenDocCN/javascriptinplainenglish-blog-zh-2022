<html>
<head>
<title>The Only Guide You Need to Master Intersection Observer in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript中的交叉点观察器所需的唯一指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intersection-observer-a-comprehensive-guide-for-web-developers-dd05aa6a3c62?source=collection_archive---------16-----------------------#2022-12-27">https://javascript.plainenglish.io/intersection-observer-a-comprehensive-guide-for-web-developers-dd05aa6a3c62?source=collection_archive---------16-----------------------#2022-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/85bc2b98c909859a5e3121e4d00fc83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RxsYV9MpPZTMgrlz"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jsycra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Siyuan</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="97eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名web开发人员，您经常需要实现依赖于在视口中可见的元素的特性，比如延迟加载图像或无限滚动。然而，使用像<code class="fe ky kz la lb b"><strong class="kc io">getBoundingClientRect</strong></code>这样的传统方法来检查元素的交集可能会很慢并且需要大量资源，特别是如果您有大量的元素要监控的话。</p><p id="3fda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是交叉点观察器的用武之地。Intersection Observer是一个JavaScript API，它允许您有效地监视元素与其祖先元素或视口之间的交集的变化。它被设计成高性能的，可以用来监控大量的元素，而不会导致性能问题。</p><p id="40e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将深入研究交叉点观察器，并了解它是如何工作的。您将学习如何创建一个交叉点观察器实例，观察元素，并使用API来实现像延迟加载和无限滚动这样的特性。到本文结束时，您将对Intersection Observer如何帮助您提高web应用程序的性能和功能有一个坚实的理解。</p><p id="068a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">创建交叉点观察点实例</strong></p><p id="4dc4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要创建交叉点观察点实例，可以使用以下代码:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="44bd" class="lk ll in lb b be lm ln l lo lp">const observer = new IntersectionObserver(callback, options);</span></pre><p id="383d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当一个元素的交集改变时，调用<code class="fe ky kz la lb b"><strong class="kc io">callback</strong></code>函数。它接收一个由<code class="fe ky kz la lb b"><strong class="kc io">IntersectionObserverEntry</strong></code>对象组成的数组作为参数，其中包含元素交集的信息。</p><p id="aaad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b"><strong class="kc io">options</strong></code>对象允许您为交叉点观察器指定额外的设置，比如用于交叉点计算的根元素和调用回调函数的阈值。</p><p id="9f0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，您可以使用<code class="fe ky kz la lb b"><strong class="kc io">root</strong></code>选项来指定应该根据特定的祖先元素而不是视口来计算交集:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="badc" class="lk ll in lb b be lm ln l lo lp">const observer = new IntersectionObserver(callback, { root: document.querySelector('#scrollable-area') });</span></pre><p id="e481" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您还可以使用<code class="fe ky kz la lb b"><strong class="kc io">threshold</strong></code>选项来指定元素在回调函数被调用之前应该可见的百分比。<code class="fe ky kz la lb b"><strong class="kc io">threshold</strong></code>选项可以是单个值或一组值。如果它是一个数组，回调函数将为每个被越过的阈值被调用。</p><p id="9c98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，当元素的50%可见时，下面的代码将调用回调函数:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="b500" class="lk ll in lb b be lm ln l lo lp">const observer = new IntersectionObserver(callback, { threshold: 0.5 });</span></pre><p id="4362" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">观察元素</strong></p><p id="6841" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦创建了交叉点观察器实例，就可以通过调用<code class="fe ky kz la lb b"><strong class="kc io">observe</strong></code>方法开始观察元素:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="b709" class="lk ll in lb b be lm ln l lo lp">observer.observe(element);</span></pre><p id="42c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b"><strong class="kc io">observe</strong></code>方法将一个元素作为参数，并开始监视它与viewport或根元素的交集。每当交集改变时，回调函数将被调用。</p><p id="afee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你也可以通过调用<code class="fe ky kz la lb b"><strong class="kc io">unobserve</strong></code>方法来停止观察一个元素:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="ef62" class="lk ll in lb b be lm ln l lo lp">observer.unobserve(element);</span></pre><p id="b6dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不再需要监视元素的交集，例如，如果您已经使用Intersection Observer加载了延迟加载的资源，这将非常有用。</p><p id="3e06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">断开交叉点观察器</strong></p><p id="ed8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，您可以通过调用<code class="fe ky kz la lb b"><strong class="kc io">disconnect</strong></code>方法来阻止交叉点观察器监视任何元素:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="5dae" class="lk ll in lb b be lm ln l lo lp">observer.disconnect();</span></pre><p id="a44e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不再需要交叉点观察器并希望释放资源，这将非常有用。</p><p id="abcb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">延迟加载图像</strong></p><p id="0a57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然现在您可以仅使用HTML来延迟加载您的图像，但是在IntersectionObserver之前，通常使用它来解决这个问题。在这个例子中，您将看到如何在React组件中实现延迟加载。</p><p id="9f3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们创建一个交叉点观察器实例，并传递给它一个回调函数，当图像元素在视口中可见时，该函数设置图像元素的<code class="fe ky kz la lb b"><strong class="kc io">src</strong></code>属性。我们还使用<code class="fe ky kz la lb b"><strong class="kc io">useEffect</strong></code>钩子在组件安装时开始观察图像元素。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="59cb" class="lk ll in lb b be lm ln l lo lp">import React, { useRef, useEffect } from 'react';<br/><br/>function LazyImage({ src, alt }) {<br/>  const imageRef = useRef();<br/><br/>  useEffect(() =&gt; {<br/>    const observer = new IntersectionObserver((entries) =&gt; {<br/>      entries.forEach((entry) =&gt; {<br/>        if (entry.isIntersecting) {<br/>          const img = entry.target;<br/>          img.src = src;<br/>          observer.unobserve(img);<br/>        }<br/>      });<br/>    });<br/>    observer.observe(imageRef.current);<br/>  }, [src]);<br/><br/>  return &lt;img ref={imageRef} alt={alt} /&gt;;<br/>}</span></pre><p id="93cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">无限卷轴</strong></p><p id="d62a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当你浏览一个网站时，如果你不点击任何按钮，内容就会不知从哪里冒出来，这种机制就会被使用。</p><p id="c63b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从创建一个交叉点观察器实例开始，并向它传递一个回调函数，当列表的底部在视口中可见时，该函数调用<code class="fe ky kz la lb b"><strong class="kc io">loadMore</strong></code>函数。我们还使用<code class="fe ky kz la lb b"><strong class="kc io">useEffect</strong></code>钩子在组件挂载时开始观察列表元素。</p><p id="541c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当调用<code class="fe ky kz la lb b"><strong class="kc io">loadMore</strong></code>函数时，它可以从服务器或数据库获取更多的条目，并将它们添加到列表中。这允许列表在用户向下滚动时加载额外的项目，创造出无限滚动的假象。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="9314" class="lk ll in lb b be lm ln l lo lp">import React, { useRef, useEffect } from 'react';<br/><br/>function InfiniteScrollList({ items, loadMore }) {<br/>  const listRef = useRef();<br/><br/>  useEffect(() =&gt; {<br/>    const observer = new IntersectionObserver((entries) =&gt; {<br/>      entries.forEach((entry) =&gt; {<br/>        if (entry.isIntersecting) {<br/>          loadMore();<br/>        }<br/>      });<br/>    });<br/>    observer.observe(listRef.current);<br/>  }, [loadMore]);<br/><br/>  return (<br/>    &lt;ul ref={listRef}&gt;<br/>      {items.map((item) =&gt; (<br/>        &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;<br/>      ))}<br/>    &lt;/ul&gt;<br/>  );<br/>}</span></pre><p id="5305" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章能够帮助您理解Intersection Observer是如何工作的，以及如何在web应用程序中使用它。如果你有任何问题或需要进一步澄清，不要犹豫，请提出来！</p><h2 id="0174" class="lq ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">更多内容请访问<a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> PlainEnglish.io </a>。</h2><p id="e8a0" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated"><em class="mn">报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mn">免费周报</em> </strong> </a> <em class="mn">。关注我们上</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mn">推特</em> </strong> </a>，<a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mn">领英</em> </strong> </a> <strong class="kc io"> <em class="mn">，</em></strong><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><em class="mn">YouTube</em><strong class="kc io"><em class="mn">，以及</em></strong><em class="mn"/></a><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mn">不和</em> </strong> </a>T49】</p><h2 id="9278" class="lq ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">想扩大你的软件创业规模吗？检查<a class="ae jz" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank">电路</a>。</h2></div></div>    
</body>
</html>