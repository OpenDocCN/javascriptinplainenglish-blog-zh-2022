<html>
<head>
<title>Advanced React Native: How useEffect Cleanup Function Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级React Native:use effect清理功能如何工作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-useeffect-cleanup-function-works-advanced-react-native-7b38c8b0efa1?source=collection_archive---------3-----------------------#2022-08-13">https://javascript.plainenglish.io/how-useeffect-cleanup-function-works-advanced-react-native-7b38c8b0efa1?source=collection_archive---------3-----------------------#2022-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d5d9" class="pw-subtitle-paragraph jo ip iq bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">用一个真实的例子解释useEffect清理函数是如何工作的。</h2></div><p id="54e8" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这个主题对于React Native或React开发人员来说非常重要，但最近我看到相当多的React开发人员没有使用<code class="fe lc ld le lf b">useEffect</code> hook中称为cleanup function的奇妙功能，所以我决定写一篇关于这个的帖子，并向我的朋友们展示一个真实的例子。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/048eafe2eeadae969b6ef139fdbd4d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ap-vxLCObjwDgfcZLuPA9A.png"/></div></div></figure><h2 id="dc7b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">介绍</h2><p id="de83" class="pw-post-body-paragraph kg kh iq ki b kj ml js kl km mm jv ko kp mn kr ks kt mo kv kw kx mp kz la lb ij bi translated">本文面向对<code class="fe lc ld le lf b">useEffect</code>钩子函数有基本了解的开发人员。</p><p id="8bb8" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">React允许我们在组件挂载时或者在组件更新时通过使用带有依赖关系数组的<code class="fe lc ld le lf b">useEffect</code>钩子来创建动作。</p><p id="7ae1" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">它需要两个参数。第一个参数是一个函数。第二个参数是依赖项数组。如果任何依赖关系改变，那么效果将再次运行。</p><pre class="lh li lj lk gt mq lf mr ms aw mt bi"><span id="6581" class="ls lt iq lf b gy mu mv l mw mx">//Run after component mounted/first rendered.<br/>useEffect(()=&gt;{</span><span id="1897" class="ls lt iq lf b gy my mv l mw mx">},[])</span><span id="2b6d" class="ls lt iq lf b gy my mv l mw mx">//Run after dep1 or dep2 change/updated.<br/>useEffect(()=&gt;{</span><span id="a9f6" class="ls lt iq lf b gy my mv l mw mx">},[dep1, dep2])</span></pre><p id="9dbe" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe lc ld le lf b">useEffect</code>函数还有一个职责，这是在组件被卸载后运行的清理函数。</p><pre class="lh li lj lk gt mq lf mr ms aw mt bi"><span id="8ae4" class="ls lt iq lf b gy mu mv l mw mx">//Run after component is unmounted/removed<br/>useEffect(()=&gt;{<br/>  return ()=&gt;{}<br/>},[])</span></pre><h2 id="c5b2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">为什么要使用清理功能</h2><p id="a8de" class="pw-post-body-paragraph kg kh iq ki b kj ml js kl km mm jv ko kp mn kr ks kt mo kv kw kx mp kz la lb ij bi translated">这是我们在使用它之前需要问自己的主要问题，因为我们需要知道它的确切目的。</p><p id="7e07" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe lc ld le lf b">useEffect</code>为我们提供的这个清理功能是为了让我们清理或删除当组件被卸载或不再显示时不相关的任何进程或动作。</p><p id="cf17" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">卸载组件后运行的操作示例。</p><pre class="lh li lj lk gt mq lf mr ms aw mt bi"><span id="22e0" class="ls lt iq lf b gy mu mv l mw mx">//When the component will unmounted,<br/>//The console will print "Component unmounted"</span><span id="4cdc" class="ls lt iq lf b gy my mv l mw mx">useEffect(()=&gt; {<br/>  <strong class="lf ir">return</strong> ()=&gt; {<br/>    console.log("Component unmounted");<br/>  }<br/>},[])</span></pre><p id="b2cf" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">真实世界的例子</strong></p><p id="bbf9" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我将用一个真实的例子来说明清理功能的重要性，它可以防止内存泄漏和性能下降。</p><p id="e001" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">假设我们有一个应用程序，我们想向其中添加一个新组件，该组件用3个点显示加载文本，一个接一个地构建这些点，直到我们收到来自服务器的响应。</p><p id="261f" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">例如:</p><p id="b09e" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">加载</strong>1秒后-&gt;<strong class="ki ir">加载。</strong>" 1秒后- &gt; " <strong class="ki ir">加载..</strong>" 1秒后- &gt; " <strong class="ki ir">加载...</strong>"等等，直到我们收到API请求的响应。</p><h2 id="7334" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">加载组件</h2><p id="2b65" class="pw-post-body-paragraph kg kh iq ki b kj ml js kl km mm jv ko kp mn kr ks kt mo kv kw kx mp kz la lb ij bi translated">这个组件将包含带有清理功能的<code class="fe lc ld le lf b">useEffect</code>钩子，让我们来构建这个组件。</p><pre class="lh li lj lk gt mq lf mr ms aw mt bi"><span id="a560" class="ls lt iq lf b gy mu mv l mw mx">const Loading = ()=&gt; {<br/>  const [dots, setDots] = useState&lt;string&gt;(".");<br/>  const dotsLoading = () =&gt; {<br/>    setDots((state)=&gt;(state.length === 3 ? '' : `${state}.`));<br/>  };</span><span id="75c1" class="ls lt iq lf b gy my mv l mw mx">useEffect(() =&gt; {<br/>    //1000 ms = 1 sec<br/>    const 1Sec = 1000;<br/>    const <strong class="lf ir">intervalId</strong> = setInterval(dotsLoading, 1Sec);<br/>    return () =&gt; <strong class="lf ir">clearInterval(intervalId)</strong>;<br/>  }, []);</span><span id="2716" class="ls lt iq lf b gy my mv l mw mx">return (<br/>    &lt;View style={Styles.modal}&gt;<br/>      &lt;Text&gt;Loading{dots}&lt;/Text&gt;<br/>    &lt;/View&gt;<br/>  )<br/>}</span></pre><p id="46ce" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这个<code class="fe lc ld le lf b">Loading</code>组件现在可以包含在任何发出API请求的屏幕组件中，并在它从/向服务器获取/发送数据时显示这个<code class="fe lc ld le lf b">Loading</code>组件。</p><h2 id="5075" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">屏幕组件</h2><p id="388b" class="pw-post-body-paragraph kg kh iq ki b kj ml js kl km mm jv ko kp mn kr ks kt mo kv kw kx mp kz la lb ij bi translated">这个<code class="fe lc ld le lf b">Screen</code>组件将包含一个API请求，用于在我们等待从服务器接收数据时显示加载组件。</p><p id="a8ad" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们来构建组件。</p><pre class="lh li lj lk gt mq lf mr ms aw mt bi"><span id="5b4f" class="ls lt iq lf b gy mu mv l mw mx">import Loading from "./components/Loading;<br/>import { fetchData } from "./API;</span><span id="ce5e" class="ls lt iq lf b gy my mv l mw mx">const Screen = ()=&gt; {<br/>  const [isLoading, setIsLoading] = useState&lt;boolean&gt;(false);</span><span id="94b2" class="ls lt iq lf b gy my mv l mw mx">  useEffect(()=&gt;{<br/>    <strong class="lf ir">setIsLoading</strong>(true);<br/>    (<br/>      async ()=&gt;{<br/>        const result = await fetchData();<br/>        <strong class="lf ir">setIsLoading</strong>(false);<br/>      }<br/>    )();<br/>  },[])</span><span id="0bf8" class="ls lt iq lf b gy my mv l mw mx">return (<br/>    &lt;View&gt;<br/>      {<strong class="lf ir">isLoading</strong> &amp;&amp; &lt;Loading /&gt;}<br/>    &lt;/View&gt;<br/>  )<br/>}</span></pre><p id="4be5" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如你所见，我们有<code class="fe lc ld le lf b">Screen</code>组件，它在挂载时用<code class="fe lc ld le lf b">useEffect</code>中的<code class="fe lc ld le lf b">fetchData</code>函数创建一个API请求。</p><p id="2bd8" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一开始，我们使<code class="fe lc ld le lf b">Loading</code>组件可见，现在<code class="fe lc ld le lf b">Loading</code>组件显示，直到我们从服务器接收数据，此外，<strong class="ki ir">异步</strong>函数是<strong class="ki ir">以等待</strong>对<code class="fe lc ld le lf b">fetchData</code>函数的响应。</p><p id="0f8b" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当<code class="fe lc ld le lf b">isLoading</code>参数为假时，运行<code class="fe lc ld le lf b">Loading</code>组件内的清除功能，清除间隔并停止循环。通过这样做，即使我们不再使用<code class="fe lc ld le lf b">Loading</code>组件(当我们收到来自API请求的数据时),我们也能保护我们的应用程序不运行<code class="fe lc ld le lf b">dotsLoading</code>函数。</p><h2 id="d7d4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">最后</h2><p id="33f5" class="pw-post-body-paragraph kg kh iq ki b kj ml js kl km mm jv ko kp mn kr ks kt mo kv kw kx mp kz la lb ij bi translated"><code class="fe lc ld le lf b">useEffect</code>的清理功能非常强大，如果我们很好地理解了它，我们就可以将我们的应用程序从糟糕的性能和内存泄漏中拯救出来。</p><p id="ee5d" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">感谢您到目前为止的阅读，如果您喜欢这样的内容，并且您想支持我作为一名程序员和作家来撰写更多这样的文章，<a class="ae mz" href="https://medium.com/membership/@nissimzarur" rel="noopener"> <strong class="ki ir"> <em class="na">请使用我的链接注册Medium成为会员(每月订阅5美元)，您将可以无限制地访问Medium上的所有内容。</em> </strong> </a></p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="7f85" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="na">更多内容请看</em> <a class="ae mz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> <em class="na">说白了就是</em> </strong> </a> <em class="na">。报名参加我们的</em><strong class="ki ir"><em class="na"/></strong><a class="ae mz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ki ir"><em class="na">免费每周简讯</em> </strong> </a> <em class="na">。关注我们关于</em> <a class="ae mz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> <em class="na">推特</em> </strong> </a>，<a class="ae mz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> <em class="na">领英</em> </strong> </a> <em class="na">，以及</em> <a class="ae mz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> <em class="na">不和</em> </strong> </a> <em class="na">。</em></p></div></div>    
</body>
</html>