<html>
<head>
<title>5 Ways to Judge if an Object has a Property</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">判断一个物体是否有属性的5种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-ways-to-judge-if-an-object-has-a-property-ec6aa24187af?source=collection_archive---------22-----------------------#2022-01-24">https://javascript.plainenglish.io/5-ways-to-judge-if-an-object-has-a-property-ec6aa24187af?source=collection_archive---------22-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="88f1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">ES2022有一个新的建议来做这件事。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d9eb387950c39773d513ad06b1ebf3c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wvAxoRNkqrqLQ4X5"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@markuswinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Winkler</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0ac7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程时，我们经常需要确定一个对象是否具有某种属性。这里我们将列出5种方法。</p><h1 id="f9bf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.in运算符</h1><p id="bb85" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果指定的属性在指定的对象或其原型链中，<code class="fe mp mq mr ms b"><strong class="ky ir">in</strong></code> <strong class="ky ir">操作符</strong>返回<code class="fe mp mq mr ms b">true</code>。</p><p id="7dba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/d7e796eb9c700e4bb918bd7ce7097803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FO0AVtnoqOAWjuZD46eIog.png"/></div></div></figure><p id="52f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<code class="fe mp mq mr ms b">in</code>运算符有一个缺点，那就是:如果属性来自对象的原型，它仍然会返回<code class="fe mp mq mr ms b">true</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6c218081df38f67671009df24d593b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*P5EjaQGuXy88BetMIzadrQ.png"/></div></figure><h1 id="176a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.Reflect.has()方法</h1><p id="522d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">Reflect.has</code>方法允许你检查一个属性是否在一个对象中。作为一个函数，它像<code class="fe mp mq mr ms b">in</code>操作符一样工作。</p><p id="2f23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/9db352216df5e7851de71302720451d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_F5PvK2jKWsqGRIO3W58eA.png"/></div></div></figure><h1 id="cdbc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.hasOwnProperty()方法</h1><p id="20fc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mp mq mr ms b"><strong class="ky ir">hasOwnProperty()</strong></code>方法返回一个布尔值，表明对象是否将指定的属性作为自己的属性(相对于继承它)。</p><p id="0884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可以正确区分对象本身的属性和其原型的属性。</p><p id="d05f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/edcc1b46eb5be4dbdbc8aed999fbdfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQuM030pmLK9Q7lYc9QWqw.png"/></div></div></figure><p id="0a7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这种写法有一个缺点，那就是如果对象是由<code class="fe mp mq mr ms b">Object.create(null)</code>创建的，那么就不能使用这种方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/4cf42d56f0ec608ca514c42b321f98ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LCUXj3pKTB4wO6LLCCw_7w.png"/></div></div></figure><h1 id="922f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.object . prototype . hasownproperty()方法</h1><p id="01d3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">解决前面的问题很简单，我们只需要使用<code class="fe mp mq mr ms b">Object.prototype.hasOwnProperty</code>。这种方法是直接调用内置的实用函数，跳过原型链。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/073e65a0d4836dbae64822edc3738a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnt6khUGHdhSFbPYTgOYpQ.png"/></div></div></figure><h1 id="5c93" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.Object.hasOwn()方法</h1><p id="5371" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于之前的几种方式都不优雅，<a class="ae kv" href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noopener ugc nofollow" target="_blank"> ES2022有了新的提议</a> : <code class="fe mp mq mr ms b">Object.hasOwn</code></p><p id="e506" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果指定对象将指示的属性作为其<em class="mz">自己的</em>属性，则<code class="fe mp mq mr ms b"><strong class="ky ir">Object.hasOwn()</strong></code>静态方法返回<code class="fe mp mq mr ms b">true</code>。如果该属性是继承的或者不存在，则该方法返回<code class="fe mp mq mr ms b">false</code>。</p><p id="ef6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/dfb5d88bd92d78045711061c1ee683d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80Bjx_ci-Uqs_W9AEKm_1g.png"/></div></div></figure><p id="d086" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你知道了。感谢您的阅读。</p></div></div>    
</body>
</html>