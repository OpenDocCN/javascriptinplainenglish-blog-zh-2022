<html>
<head>
<title>LeetCode Problem: Binary Tree Tilt (JavaScript)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode问题:二叉树倾斜(JavaScript)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-tree-tilt-ae2650f73ea?source=collection_archive---------18-----------------------#2022-03-04">https://javascript.plainenglish.io/binary-tree-tilt-ae2650f73ea?source=collection_archive---------18-----------------------#2022-03-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b264" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">LeetCode #563 (JavaScript)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aacca43310468dbed53a5f5490b04062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfOdu1wyfe8EF5pd4iy8dg.jpeg"/></div></div></figure><p id="cad9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管我很喜欢使用递归进行二叉树遍历，但这个问题对我来说非常困惑。倾斜是一个新概念，虽然简单，但Leetcode描述中的措辞似乎有点尴尬。</p><p id="7e46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我会尽量简化。</p><p id="3593" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以一棵二叉树为例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ku"><img src="../Images/d01a42b3c037feedb649b5b04725f6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQ1muyk-xySX7-QE01K5Ng.jpeg"/></div></div></figure><p id="706d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在计算每个节点的倾斜度。这是</p><p id="e44d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">|节点左子树值的总和减去节点右子树值的总和|</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kv"><img src="../Images/316fb593c7e05153b4b6240e5c04006e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-luw9P4MFJqxygiHXkDYtw.jpeg"/></div></div></figure><p id="3389" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，对于所有倾斜的总和(问题所要求的)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ku"><img src="../Images/64f374b17b8e4d5affbec536bc214d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrXK1vz4WbbV7iq80Dh3yA.jpeg"/></div></div></figure><p id="0917" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">似乎LeetCode的描述有时故意含糊不清，如果是这样的话，我可以理解。它帮助我学会了如何在涉及细节时更透彻地理解问题，并避免假设。</p><h2 id="3202" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated"><strong class="ak"> <em class="lp">想通了</em> </strong></h2><p id="3967" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">我的第一印象是这似乎是一个后序遍历。对于每个节点，首先我希望执行所有左子树操作，然后执行所有右子树操作。然后，计算当前节点的倾斜度很简单。</p><h2 id="d5fb" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated"><strong class="ak"> <em class="lp">翻译成递归</em> </strong></h2><p id="0cfd" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">我们需要一个递归过程，可以遍历树，计算每个节点的倾斜度，然后增加总倾斜度的计数器。不仅如此，我们还需要一种方法，使我们能够在前进的过程中向上传递节点值。</p><p id="a1d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，为什么不-</p><ol class=""><li id="9110" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh ma mb mc md bi translated">在递归爬虫之外有一个计数器用于增量</li><li id="1ef3" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">使递归crawler的返回值成为其下节点值的当前总和</li></ol><h2 id="ced6" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated"><strong class="ak"> <em class="lp">上至代码:</em> </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7d65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我已经建立了基本结构。外部tilt函数将接受树的根，totalTilt准备随着我们的爬行而递增，sum是递归函数，将返回其下节点值的运行总数。</p><p id="3ec7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这一切看起来令人困惑，那是因为它是。我不得不画了很多次图来理解它，但是，一如既往，这是值得的。啊哈时刻是巨大的。</p><p id="cfdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先是代码，然后我将把递归映射到图中</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="19f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我只添加了四行代码，这就是工作所需的全部内容+帮助者在根上调用tilt(第24行)</p><p id="960c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在绘制图表之前，我想大声说出第7行到第16行:</p><p id="e977" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第7行有条件</strong>(基本情况)——“我们是在树的末端吗？用一个零结束这个函数—我们现在可以返回上一级了”</p><p id="8bc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第11行和第12行</strong> →“先下行左子树。对于每个级别，打开一个新的递归函数调用。当它停止(返回0)时，我们将从上一层开始探索右边的子树。”</p><p id="9320" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第13行和第14行</strong> →“现在我们有了当前级别的左值和右值，计算该节点的倾斜度，然后增加totalTilt。”</p><p id="41ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第16行</strong>(可能也是最令人困惑的)→“现在返回这个节点值，加上从较低层次上来的任何节点值。”</p><h2 id="2604" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated"><strong class="ak"> <em class="lp">映射递归到树</em> </strong></h2><p id="e9da" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">让我们看看我是否能做一些有意义的可视化来阐明这一点。我将关注根的左子树。同样的原则也适用于右侧。</p><p id="df20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">*EC =执行上下文(由新的“sum”函数调用创建的环境)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/ec77f8fce05e05d88f0cbc7597ad3c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoIC-jfZjBbU8A4jVhQI4Q.jpeg"/></div></div></figure><p id="36e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们立即一路下降到leaves，在每一层打开新的递归函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/47b79ef5db3166315e96ea36612cd6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-XZVaOmvx4Ugtp1M7ELyA.jpeg"/></div></div></figure><p id="4195" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经发现1没有子节点，所以total tilt什么也没有得到，我们将把节点值和它的子树值向上返回到在节点2打开的上下文中。现在我们可以继续下一行代码为‘右’</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/8b0d9d66bf079594455df567a8844961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bR2EPaaohZmX_8A41xRWHA.jpeg"/></div></div></figure><p id="cfa5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打开一个新的EC3，两个子树都被评估为0(满足基本情况)，tilt保持为零，totalTilt也是如此。于是EC3返回EC2并关闭。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/8a3b766deb07ab3e956a86c342e65885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwtXeB9D4csdxrHvwAGG_A.jpeg"/></div></div></figure><p id="3ff4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在EC2已经完成了左右两边的递归调用，啊哈时刻到了。从节点2的子节点向上返回的值中最终找到节点2的倾斜，totalTilt反映了这种增加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/5d90c6466bcd9d07e75edc946d9480bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_WwQ6-2uYLQYlYJs7I8GQ.jpeg"/></div></div></figure><p id="3f42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">EC2现在将关闭，将左子树的所有值返回给EC1。由于代码现在可以继续，并且在EC1中定义了“right”——右边的子树将以类似的过程进行探索。</p><p id="5ded" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当遍历右边的子树时，总倾斜度将会一路递增。完成后，EC1将具有左值和右值，以结束根节点的倾斜。</p><h2 id="4540" class="kw kx in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated"><strong class="ak"> <em class="lp">总结</em> </strong></h2><p id="21bc" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">我不能说足够的图解递归。它真的帮助我想象这样简单、简洁的代码如何在数据结构中有效地工作。</p><p id="4bc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">非常，<em class="mm">非常</em>酷。</p><p id="6546" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mm">更多内容看</em> <a class="ae mn" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">说白了。报名参加我们的</em> <a class="ae mn" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">免费周报</em> </strong> </a> <em class="mm">。关注我们关于</em><a class="ae mn" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mm">Twitter</em></strong></a><em class="mm">和</em><a class="ae mn" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mm">LinkedIn</em></strong></a><em class="mm">。加入我们的</em> <a class="ae mn" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">社区不和谐</em> </strong> </a> <em class="mm">。</em></strong></a></p></div></div>    
</body>
</html>