<html>
<head>
<title>5 Unusual JavaScript Tips that Make Your Life Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个不同寻常的JavaScript技巧，让您的生活更轻松</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-unusual-javascript-tips-that-make-your-life-easier-81f272b2184e?source=collection_archive---------5-----------------------#2022-06-20">https://javascript.plainenglish.io/5-unusual-javascript-tips-that-make-your-life-easier-81f272b2184e?source=collection_archive---------5-----------------------#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e462" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用这五个简单却不寻常的JavaScript技巧，写出更好的代码。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/abd9026b88cbb8ea89b3b971afa20437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zgGkLF3Z1KrF_Mzt"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@davidnicolai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Nicolai</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e9f8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">太多关于JavaScript技巧的文章只涉及数组函数的基础知识或对代码的明显改进。这篇文章将会更深入，帮助你改进你每天写的代码。</p><h2 id="1ccc" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">1.等待…任何事</h2><p id="19b2" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">有时候，你想等待一些事情发生。虽然这项任务可能会变得复杂(例如，使用非阻塞循环)，但对于大多数等待问题，有一个简单的解决方案:承诺。</p><p id="b878" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">承诺可以在给定的超时后解决:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="441b" class="lt lu iq ms b gy mw mx l my mz">new Promise((resolve) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    // DO Something<br/>    resolve();<br/>  }, 1000);<br/>});</span></pre><p id="475b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此承诺将在大约1秒后解决。您还可以将它存储在一个变量中，并使用await来阻塞一秒钟(注意潜在的UX问题)。虽然您可以找到上面片段的一个用例，但它暗示了一个更有用的技巧。</p><p id="5e0e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以使用承诺作为信号量:有时，您希望执行一个异步的、长时间运行的流程。但是用户可以一次又一次地触发这个过程。因此，您希望确保正在运行的进程必须在用户可以再次启动它之前完成。方法如下:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="3d29" class="lt lu iq ms b gy mw mx l my mz">let processStatus = null;<br/>function myProcess() {<br/>  if (processStatus) {<br/>    return;<br/>  }</span><span id="170b" class="lt lu iq ms b gy na mx l my mz">  processStatus = new Promise(resolve =&gt; {<br/>    // Do some heavy lifting, for example<br/>    setTimeout(() =&gt; {<br/>      // pretending a long running action<br/>      resolve();<br/>    }, 5000);<br/>  })<br/>    .then(() =&gt; {<br/>      processStatus = null;<br/>    });<br/>}</span></pre><p id="bb20" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">只有在没有活动进程时，用户才能单击此按钮。这有助于避免多次获取相同的数据。</p><h2 id="7631" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">2.使用异步优化JavaScript中的循环</h2><p id="58e0" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">我看到许多人在JavaScript数组上使用<code class="fe nb nc nd ms b">forEach</code>函数，但是他们中的大多数人并不知道它的真正威力:异步循环。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="07ca" class="lt lu iq ms b gy mw mx l my mz">const asyncArr = [<br/>  new Promise(resolve =&gt; setTimeout(resolve.bind(this, 1), 2000)),<br/>  new Promise(resolve =&gt; setTimeout(resolve.bind(this, 2), 500)),<br/>  new Promise(resolve =&gt; setTimeout(resolve.bind(this, 3), 5000)),<br/>  new Promise(resolve =&gt; setTimeout(resolve.bind(this, 4), 1000)),<br/>];</span><span id="5cc2" class="lt lu iq ms b gy na mx l my mz">asyncArr.forEach(async (el) =&gt; {<br/>  const i = await el;<br/>  console.log(i);<br/>});</span><span id="5ebd" class="lt lu iq ms b gy na mx l my mz">// logs: 2, 4, 1, 3</span></pre><p id="05ad" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然使用for-of-loop也可以做到这一点，但使用await读起来要优雅得多。下面是使用for-of-loop的相同示例。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="d534" class="lt lu iq ms b gy mw mx l my mz">for (const el of asyncArr) {<br/>  el.then(console.log);<br/>}</span></pre><p id="db2c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不要让for-of-loop更简洁的事实欺骗了你。在这个例子中，我们不用<code class="fe nb nc nd ms b">i</code>做任何计算。然而，想象一下在for-const-loop使用的<code class="fe nb nc nd ms b">then</code>函数体中做更多的计算。</p><p id="e628" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这里，使用<code class="fe nb nc nd ms b">forEach</code>接口可能会遇到两个问题:</p><p id="2006" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，它没有返回值。这意味着你改变你的原始数组，或者你根本不改变数组。如果您决定修改数组，您将产生副作用，如果您根本不改变它，这些副作用可能很难调试——好吧。</p><p id="ece7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">第二，不稳定。如果不同步遍历所有元素，我无法按照原始数组的顺序记录结果。后一种选择意味着循环会运行得更慢。为了避免这种情况，我们可以结合使用<code class="fe nb nc nd ms b">Promise.all</code>和<code class="fe nb nc nd ms b">map</code>。这将产生一个新数组，其中包含我们的异步调用接收到的值，其顺序与原始数组相同。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="f629" class="lt lu iq ms b gy mw mx l my mz">const asyncArr = [<br/>  new Promise(resolve =&gt; setTimeout(resolve.bind(this, 1), 2000)),<br/>  new Promise(resolve =&gt; setTimeout(resolve.bind(this, 2), 500)),<br/>  new Promise(resolve =&gt; setTimeout(resolve.bind(this, 3), 5000)),<br/>  new Promise(resolve =&gt; setTimeout(resolve.bind(this, 4), 1000)),<br/>]<br/> <br/>Promise.all(asyncArr)<br/> .then(console.log);</span><span id="6c84" class="lt lu iq ms b gy na mx l my mz">// logs: [1,2,3,4] after 5 seconds</span></pre><p id="39ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">太棒了。它不会产生副作用，因为它返回一个新的数组(除非<code class="fe nb nc nd ms b">asyncArr</code>中的函数产生副作用——那你就输了),并且它会返回稳定的结果！</p><h2 id="a007" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">3.尽可能避免使用else</h2><p id="6c1b" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">这个技巧简单而有力。在很多情况下，你会看到自己写了一个else块，而这可以用两秒钟的思考来避免。所以我给你介绍一些不需要的情况。</p><p id="4889" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 3.1提前归还</strong></p><p id="f5e7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">利用早期返回语句可以帮助您消除第一组不必要的else块。请参见下面的示例:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="7d12" class="lt lu iq ms b gy mw mx l my mz">function myFun() {<br/>  if (x &gt; 10) {<br/>    // do something<br/>  } else {<br/>    // do something else<br/>  }</span><span id="3879" class="lt lu iq ms b gy na mx l my mz">  return someVar;<br/>}</span></pre><p id="ecbe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这可以被重构为</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="1718" class="lt lu iq ms b gy mw mx l my mz">function myFun() {<br/>  if (x &gt; 10) {<br/>    // do something<br/>    return someVar;<br/>  }</span><span id="ed2c" class="lt lu iq ms b gy na mx l my mz">  // do something else<br/>  return someVar;<br/>}</span></pre><p id="0f57" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可能会反对:这两个例子在大小上没有太大区别——何必呢？这不是大小的问题，而是可读性和降低复杂性的问题。</p><p id="5a54" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">任何if和else语句都会增加函数的复杂性。遇到else块的时候，有多长？if-block有多长？你还记得你读书时身在何处吗？</p><p id="1695" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里有一个经验法则:用if语句处理错误并尽快返回。然后，函数应该做任何if/else之外应该做的事情。</p><p id="7a07" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 3.2违反了单一责任原则</strong></p><p id="7d58" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">遇到最佳实践的初级开发人员总是问我:我什么时候知道我违反了单一责任原则？我什么时候意识到我的功能不止做一件事？If-else可以做指标！</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="40d8" class="lt lu iq ms b gy mw mx l my mz">function myFun() {<br/>  if (x &gt; 10) {<br/>    // do something<br/>  } else {<br/>    // do something else<br/>  }<br/><br/>  if (y &lt; 100) {<br/>    // do something<br/>  } else {<br/>    // do something else<br/>  }</span><span id="b45e" class="lt lu iq ms b gy na mx l my mz">  return someVar;<br/>}</span></pre><p id="ea7e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">特别是当一个函数中有多个if-"else if"-else块时，很可能会违反这个函数的SRP。上面的例子可以重构为</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="4f62" class="lt lu iq ms b gy mw mx l my mz">function myFunc() {<br/>  const xValid = checkX(x);<br/>  const yValid = checkY(y);<br/>  return xValid &amp;&amp; yValid;<br/>}</span></pre><p id="0d75" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当然，重构高度依赖于代码的语义。然而，这可能是将上面的例子重写为一个更清晰、可读性更好的函数的一种方法。</p><p id="bd7b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 3.3默认值</strong></p><p id="e3a2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你觉得这个眼熟吗？</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="dfa1" class="lt lu iq ms b gy mw mx l my mz">let x;<br/>if (someVar === "something") {<br/>  x = 1;<br/>} else {<br/>  x = somethingElse;<br/>}</span></pre><p id="601c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">考虑一下这个重构:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="64d5" class="lt lu iq ms b gy mw mx l my mz">let x = 1;<br/>if (someVar !== "something") {<br/>  x = somethingElse;<br/>}</span></pre><p id="7579" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">甚至是这个:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="c053" class="lt lu iq ms b gy mw mx l my mz">const x = someVar !== "something"<br/>  ? somethingElse <br/>  : 1;</span></pre><p id="67c4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好了，最后一个例子是用else(种)。然而，我们避免使用<code class="fe nb nc nd ms b">let</code>,因为它可能是错误的来源。</p><h2 id="754d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">4.使用<code class="fe nb nc nd ms b">Array.from</code>进行迭代</h2><p id="f409" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">好吧，这可能是你们大多数人都熟悉的一个(也许除了<code class="fe nb nc nd ms b">Promise.all</code>的事情)，但是我遇到了这么多没有意识到这一点的开发者，所以我决定把它放在列表上。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="4ac1" class="lt lu iq ms b gy mw mx l my mz">const as = document.querySelectorAll("a");</span></pre><p id="f3a7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nb nc nd ms b">as</code>的<em class="ne">具体是什么</em>类型。</p><p id="bf2a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，你可能认为它是一个数组，但它不是。证明？</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="953a" class="lt lu iq ms b gy mw mx l my mz">Array.isArray(as);<br/>// -&gt; false</span></pre><p id="1058" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，<code class="fe nb nc nd ms b">as.map(...)</code>行不通。真扫兴。</p><p id="9a78" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">其次，Chrome将它显示为一个数组，这可能会让许多人感到困惑。但是，请注意“节点列表(3)”</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nf"><img src="../Images/fef42ea7629d0c620a7721b8623d161d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zF5MV8lA1H_oYP-7TNVdbA.png"/></div></div></figure><p id="848f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这意味着它是所谓的“类数组对象”(或可迭代对象)。所以无论什么时候遇到这种对象，都可以从中创建一个数组。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="1e2f" class="lt lu iq ms b gy mw mx l my mz">const asArray = Array.from(as);</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ng"><img src="../Images/ae496efa02749a8782784417cb22abd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSGIsIUhFFt4pESulPYA6Q.png"/></div></div></figure><p id="d886" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这确实是一个数组。现在，你可以在上面使用<code class="fe nb nc nd ms b">map</code>、<code class="fe nb nc nd ms b">filter</code>或任何其他数组函数。</p><h2 id="5731" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">5.摆脱引用</h2><p id="3e60" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">引用会在代码中引起各种副作用。意识到什么时候你在处理一个引用，什么时候你只是在处理一个值，这是编写无错误软件的关键。但是，我不会详细讨论什么是引用。您将主要在处理对象和数组时体验到这种行为。</p><p id="3c09" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">问题是这样的:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="4ddc" class="lt lu iq ms b gy mw mx l my mz">const a = { key: "value" };<br/>const b = a;<br/>b.key = "something else";</span><span id="11b9" class="lt lu iq ms b gy na mx l my mz">console.log(a.key);</span></pre><p id="c71b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">将记录什么？正确，“别的东西。”</p><p id="5fce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nb nc nd ms b">b</code>只是对<code class="fe nb nc nd ms b">a</code>的引用，因此每当<code class="fe nb nc nd ms b">b</code>改变一个被引用的对象键，那么它也会反映在<code class="fe nb nc nd ms b">a</code>上。我们可以使用几种技术创建一个新的对象<code class="fe nb nc nd ms b">b</code>，而不引用<code class="fe nb nc nd ms b">a</code>。</p><p id="3726" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 5.1解构</strong></p><p id="517b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个已经流行了一段时间了。析构移除所有引用。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="79d4" class="lt lu iq ms b gy mw mx l my mz">const a = { key: "value" };<br/>const b = {...a};<br/>b.key = "something else";</span><span id="104a" class="lt lu iq ms b gy na mx l my mz">console.log(a.key); // logs: value<br/>console.log(b.key); // logs: something else</span></pre><p id="d60a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 5.2 Object.assign </strong></p><p id="60ed" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">析构是<code class="fe nb nc nd ms b">Object.assign</code>的语法糖，因此引用也可以用这种技术移除:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="e916" class="lt lu iq ms b gy mw mx l my mz">const b = Object.assign({}, a);</span></pre><p id="e0e6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">结果将和析构化一样。</p><p id="c9a9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 5.3 Array.from </strong></p><p id="17cb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你正在处理数组，那么你可以使用<code class="fe nb nc nd ms b">Array.from</code>来去除引用。问题是这样的:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="149a" class="lt lu iq ms b gy mw mx l my mz">const arr1 = [1,2,3,4];<br/>const arr2 = arr1;<br/>arr2[0] = 5;</span><span id="7e10" class="lt lu iq ms b gy na mx l my mz">console.log(arr1); // -&gt; [5, 2, 3, 4]</span></pre><p id="33ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它可以像这样使用<code class="fe nb nc nd ms b">Array.from</code>来解决</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="075b" class="lt lu iq ms b gy mw mx l my mz">const arr1 = [1,2,3,4];<br/>const arr2 = Array.from(arr1);<br/>arr2[0] = 5;</span><span id="f4cd" class="lt lu iq ms b gy na mx l my mz">console.log(arr1); // -&gt; [1, 2, 3, 4]<br/>console.log(arr2); // -&gt; [5, 2, 3, 4]</span></pre><p id="286f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当然，析构也适用于数组。另一件要注意的事情是:<code class="fe nb nc nd ms b">Array.from</code>不仅适用于“类数组对象”，也适用于数组。</p><p id="4125" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 5.4最后一招:JSON.stringify </strong></p><p id="a873" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">作为最后的手段，您可以将一个对象字符串化并再次解析它。所有引用都将被清除。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="5896" class="lt lu iq ms b gy mw mx l my mz">const a = { key: "value" };<br/>const b = JSON.parse(JSON.stringify(a));<br/>b.key = "something else";</span><span id="5962" class="lt lu iq ms b gy na mx l my mz">console.log(a.key); // logs: value<br/>console.log(b.key); // logs: something else</span></pre><p id="6c9c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，请注意JSON.stringify也会清除任何类型信息。这可能会给你的日期和其他对象带来一些麻烦。</p><p id="169d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就这些了，伙计们！</p><p id="4a10" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你喜欢这篇文章，请鼓掌并跟我来，告诉我你会喜欢更多的东西。非常感谢你的阅读和支持！</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="8f96" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="ne">更多内容请看</em><a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="ne">plain English . io</em></strong></a><em class="ne">。报名参加我们的</em> <a class="ae kw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="ne">免费周报</em> </strong> </a> <em class="ne">。关注我们关于</em><a class="ae kw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="ne">Twitter</em></strong></a><em class="ne">和</em><a class="ae kw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="ne">LinkedIn</em></strong></a><em class="ne">。查看我们的</em> <a class="ae kw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="ne">社区不和谐</em> </strong> </a> <em class="ne">加入我们的</em> <a class="ae kw" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="ne">人才集体</em> </strong> </a> <em class="ne">。</em></p></div></div>    
</body>
</html>