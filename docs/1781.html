<html>
<head>
<title>How You Can Access All Host Component Details Inside the Directive in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中访问指令内的所有主机组件详细信息</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-how-you-can-access-all-host-component-details-inside-the-directive-f728a5fb1182?source=collection_archive---------2-----------------------#2022-04-19">https://javascript.plainenglish.io/angular-how-you-can-access-all-host-component-details-inside-the-directive-f728a5fb1182?source=collection_archive---------2-----------------------#2022-04-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2f74" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何使用DI访问子/孙组件中的父/祖组件详细信息以及在Angular中访问父/祖组件中的子/孙组件详细信息的指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5fe732b00ca734e2e99586a739592bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gf2Zl34iikO4AVVq"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0bc6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我最近在我的工作项目中遇到了一个场景，我想在组件之间重用<strong class="kv io">“点击链接时滚动到文本”</strong>功能，而不管组件是什么。这个场景要求访问指令中的主机组件。我花了很多时间试图使这个可重复使用，并愿意分享我用来解决这个问题的方法。</p><p id="6eac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是Angular应用程序的样子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/f3401df9d934ea51175d7b9349dc273f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hc-XmoUEBB1sc39mc8sY3g.png"/></div></div></figure><p id="7779" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个例子中，我使用了两个组件<strong class="kv io"> TestComponent </strong>和<strong class="kv io"> SecondTestComponent </strong>。这两个组件执行相似的功能。它们显示4个选项的列表，后跟4段文本。点击列表选项会让用户滚动到相应的段落。</p><p id="3378" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">拥有两个组件的目的是为了表明不管组件是什么，解决方案都是可重用的。</p><p id="5fc7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> AppComponent模板:</strong>这是托管<strong class="kv io"> TestComponent </strong>和<strong class="kv io"> SecondTestComponent </strong>的引导组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7048" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在讨论这两个组件之前，我想展示一下这两个组件中使用的数据结构。我们对2个组件使用了2组不同的数据，但这2组数据的结构保持不变。这是一个由4个对象组成的数组。每个对象包含两个属性:<strong class="kv io">标题</strong>和<strong class="kv io">文本。</strong></p><p id="500b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面我展示了用于<strong class="kv io">测试组件</strong>的数据集。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="9599" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们转到<strong class="kv io"> TestComponent类。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="6909" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">列表</strong>属性包含从firstList.ts导出的<strong class="kv io"> firstList </strong>数组</p><p id="99e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> listOptionReference </strong>只是一个字符串，我们将使用它来唯一地标识4个段落中的每一个。</p><p id="0e10" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了访问子指令中的父<strong class="kv io"> TestComponent </strong>(我们还没有讨论过)，我们需要一个<strong class="kv io">类接口</strong>。TestComponent以类接口令牌的名义给自己提供了一个<strong class="kv io">别名</strong>。</p><p id="1ad9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为什么我们不能直接将测试组件注入到指令的构造函数中？如果我们确定<strong class="kv io">测试组件</strong>是该指令的唯一父组件，这是可能的。但是在我们的例子中，该指令将在多个组件中重用，并且<strong class="kv io">我们事先不知道组件名</strong>。</p><p id="4b65" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们添加了一个别名提供者，如下所示。提供者对象由一个通用的帮助器函数<strong class="kv io"> returnProvider()返回。</strong>我们将组件的名称作为参数传递。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="459c" class="lx ly in lt b gy lz ma l mb mc">providers: [<strong class="lt io">returnProvider(TestComponent)</strong>],</span></pre><p id="c0af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">基类和returnProvider()在<strong class="kv io"> utility.ts. </strong>中定义，非常简单，如下所示:</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="a788" class="lx ly in lt b gy lz ma l mb mc"><strong class="lt io">export abstract class Base {}</strong></span><span id="43d4" class="lx ly in lt b gy md ma l mb mc">export function <strong class="lt io">returnProvider</strong>(component: any) {<br/>return <strong class="lt io">{ provide: Base, useExisting: forwardRef(() =&gt; component) };</strong><br/>}</span></pre><p id="75f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Base </strong>是抽象类，是TestComponent类的接口令牌。TestComponent实现基类。</p><p id="34d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> forwardRef </strong>打破了我们通过让TestComponent引用自身而创建的循环引用。</p><p id="effa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您一定想知道，为什么我们将<strong class="kv io"> ElementRef </strong>实例注入到TestComponent的构造函数中。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="80e0" class="lx ly in lt b gy lz ma l mb mc">constructor(<strong class="lt io">private hostElement: ElementRef</strong>) { }</span></pre><p id="ef2f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">原因是为了实现滚动功能，我们需要访问指令中的TestComponent <app-test>元素。我们将很快看到这是如何实现的。</app-test></p><p id="583d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">SecondTestComponent类是TestComponent类的副本，但具有不同的数据和不同的listOptionReference。</p><p id="c2b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> TestComponent模板:</strong>在模板中，我们首先遍历<strong class="kv io">列表数组属性</strong>来显示列表选项。每个列表选项都是一个&lt; li &gt;标签，标签上附有带有选择器<strong class="kv io">跳转</strong>的<strong class="kv io">跳转指令</strong>。</p><p id="9871" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当用户点击列表选项时，用户将被滚动到相应的段落。滚动操作由指令执行。</p><p id="5e71" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，这个指令接受用户需要滚动到的段落的<strong class="kv io"> ID作为@Input。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="5880" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了显示段落，我们再次遍历了相同的<strong class="kv io">列表</strong>数组属性，并显示了<strong class="kv io">标题和文本属性</strong>。</p><p id="e031" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该段落的id将是<strong class="kv io">容器0、容器1、容器2和容器3 </strong>。</p><p id="d5a9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">“容器”</strong>是<strong class="kv io"> listOptionReference </strong>属性的字符串值。为了使它唯一，我们将列表数组的<strong class="kv io">迭代索引附加到它上面。</strong></p><p id="5720" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们转到<strong class="kv io">跳转指令</strong>。</p><p id="1a97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">@Input <strong class="kv io"> jumpTo </strong>包含用户需要滚动到的段落的ID。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="9759" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们在构造函数中注入了一个<strong class="kv io">基类</strong>的引用来访问主机组件。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="6856" class="lx ly in lt b gy lz ma l mb mc">constructor(<strong class="lt io">private host: Base</strong>) {}</span></pre><p id="a680" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们点击一个列表选项时，下面的<strong class="kv io"> onClick() </strong>执行。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="e2ec" class="lx ly in lt b gy lz ma l mb mc"><strong class="lt io">@HostListener(‘click’) onClick() { </strong><br/>console.log(<strong class="lt io">‘Component Name:’, this.host.constructor.name</strong>); </span><span id="f766" class="lx ly in lt b gy md ma l mb mc">console.log(<strong class="lt io">‘Component Selector:’, this.host[‘hostElement’].nativeElement.tagName</strong> ); </span><span id="81af" class="lx ly in lt b gy md ma l mb mc">console.log(<strong class="lt io">‘Component properties &amp; Methods:’, this.host</strong>); </span><span id="c9c8" class="lx ly in lt b gy md ma l mb mc"><strong class="lt io">this.host[‘hostElement’].nativeElement .querySelector(`#${this.jumpTo}`) .scrollIntoView(); </strong></span><span id="8320" class="lx ly in lt b gy md ma l mb mc">}</span></pre><p id="0ddb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们首先记录3条信息:</p><ol class=""><li id="4bd6" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated">主机组件类名</li><li id="4fcc" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">主机组件选择器</li><li id="6906" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">宿主组件方法和属性</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/e1e13090683fa89039e548f372116ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9k624N3uL84nrxiWSSnsoA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Logging the TestComponent Details in the JumpDirective</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mt"><img src="../Images/94f40e0f08db83bceae8b8b2090c3bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4AeNF9b0Ok_ua4qaUa8zEw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Logging the SecondTestComponent Details in the JumpDirective</figcaption></figure><p id="94ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还可以访问之前注入到主机组件类中的<strong class="kv io"> hostElement引用</strong>。(TestComponent或SecondTestComponent)。</p><p id="4d39" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将使用这个引用来访问主机组件中的任何DOM元素。我们用它来滚动到与点击的列表选项相对应的段落。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="4d58" class="lx ly in lt b gy lz ma l mb mc">this.host[‘hostElement’].nativeElement .querySelector(`#${this.jumpTo}`) .scrollIntoView();</span></pre><p id="8f24" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过这种方式，我们能够实现滚动功能，而不用考虑组件，并且只需向指令传递最少的数据。</p><p id="2281" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以查看下面的完整工作示例。</p><div class="mu mv gp gr mw mx"><a href="https://stackblitz.com/edit/angular-m7z9wj?file=src/app/test/test.component.html" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd io gy z fp nc fr fs nd fu fw im bi translated">角形(叉形)堆叠</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">stackblitz.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl km mx"/></div></div></a></div><p id="8150" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我有一个简单的例子，说明如何使用已经解释过的<strong class="kv io">依赖注入(DI)技术<strong class="kv io">访问子/孙组件</strong>中的父/祖父母组件。</strong></p><p id="b6b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用<strong class="kv io"> DI和@ViewChild /@ViewChildren </strong>访问父/祖父组件中的子/孙详细信息。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mt"><img src="../Images/d4fd35cdbbf2c55021f5e992eaceade3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyljwMulpkKvIuaMiNwLyw.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mt"><img src="../Images/b1069058f0a17660b9f4e68e4f9942e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ybMd8psGIv3HDlMGGSqy5g.png"/></div></div></figure><p id="c1d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们有5个组件:<strong class="kv io"> AppComponent、ParentComponent、ChildComponent、SecondChildComponent和GrandChildComponent </strong>。</p><p id="0134" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的目标是让每个组件都可以被所有其他组件访问。下面是我们如何实现这一目标的工作示例。</p><div class="mu mv gp gr mw mx"><a href="https://stackblitz.com/edit/angular-vyam6h?file=src/parent/parent.component.css" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd io gy z fp nc fr fs nd fu fw im bi translated">角形(叉形)堆叠</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">stackblitz.com</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl km mx"/></div></div></a></div><p id="a705" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请评论任何改进和建议。</p><p id="86d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nn">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nn">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nn">免费周报</em> </strong> </a> <em class="nn">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nn">Twitter</em></strong></a><em class="nn">和</em><strong class="kv io"><em class="nn"/></strong><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nn">LinkedIn</em></strong></a><em class="nn">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nn">社区</em> </strong> </a> <em class="nn">。</em></strong></a></p></div></div>    
</body>
</html>