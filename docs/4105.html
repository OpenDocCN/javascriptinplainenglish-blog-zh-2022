<html>
<head>
<title>Advanced JavaScript: Summary of Judgment Methods &amp; Conversion Methods of Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级JavaScript:数据类型的判断方法和转换方法综述</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-javascript-summary-of-judgment-methods-conversion-methods-of-data-types-896c5b496f81?source=collection_archive---------9-----------------------#2022-10-25">https://javascript.plainenglish.io/advanced-javascript-summary-of-judgment-methods-conversion-methods-of-data-types-896c5b496f81?source=collection_archive---------9-----------------------#2022-10-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4b79219dbd77243f27877f7358605b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLH5Ss7io8UaY7BxeHr5yQ.png"/></div></div></figure><h1 id="2c02" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">内容</h1><p id="7963" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">介绍了几种常用的数据类型判断方法，并手写了一个通用的判断方法<br/>常见的强制和隐式类型转换的方法和规则，以及常见的面试问题</p><h1 id="3ce6" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">数据类型检查</h1><h2 id="900c" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">方法1:类型</h2><ul class=""><li id="8ede" class="md me in kv b kw kx la lb le mf li mg lm mh lq mi mj mk ml bi translated">typeof通常用于确定基础数据类型，但引用类型可能会有问题</li><li id="9e17" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">typeof null打印对象，但这只是一个长期存在的JS Bug。这并不意味着空值是引用数据类型，空值本身不是对象</li><li id="2926" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">无法确定引用数据类型。如果使用typeof，则除了function之外，它将是“object ”,这是正确的</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="105a" class="lr jw in mw b gy na nb l nc nd">typeof 1 // 'number'<br/>typeof '1' // 'string'<br/>typeof undefined // 'undefined'<br/>typeof true // 'boolean'<br/>typeof Symbol() // 'symbol'<br/>typeof null // 'object'<br/>typeof [] // 'object'<br/>typeof {} // 'object'<br/>typeof console // 'object'<br/>typeof console.log // 'function'</span></pre><h2 id="3b6e" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">方法2:实例</h2><ul class=""><li id="5f6b" class="md me in kv b kw kx la lb le mf li mg lm mh lq mi mj mk ml bi translated">instanceof用于确定引用数据类型</li><li id="e4b2" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">instanceof运算符用于检查构造函数的prototype属性是否出现在实例对象的原型链上。</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5437" class="lr jw in mw b gy na nb l nc nd">let Car = function() {}<br/>let benz = new Car()<br/>benz instanceof Car // true</span><span id="3156" class="lr jw in mw b gy ne nb l nc nd">let car = new String('Mercedes Benz')<br/>car instanceof String // true<br/>let str = 'Covid-19'<br/>str instanceof String // false</span></pre><h2 id="b2be" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">手写实例</h2><p id="9f93" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">typeof用于确定基础数据类型。如果是，则返回false</p><p id="58be" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">获取参数的原型对象，并向下循环，直到找到相同的原型对象</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d752" class="lr jw in mw b gy na nb l nc nd">function myInstanceof(left, right) {<br/>  // typeof is used to determine the underlying data type. If so, return false<br/>  if(typeof left !== 'object' || left === null) return false;<br/>  // getProtypeOf is the API that comes with the Object object and can get the prototype object for the parameters<br/>  let proto = Object.getPrototypeOf(left);<br/>  while(true) {                  //Loop down until you find the same prototype object<br/>    if(proto === null) return false;<br/>    if(proto === right.prototype) return true;//Find the same prototype object and return true<br/>    proto = Object.getPrototypeof(proto);<br/>    }<br/>}<br/>//Verify that your implementation of myInstanceof is OK<br/>console.log(myInstanceof(new Number(123), Number));    // true<br/>console.log(myInstanceof(123, Number));                // false</span></pre><ul class=""><li id="8f67" class="md me in kv b kw nf la ng le nk li nl lm nm lq mi mj mk ml bi translated">可以准确确定复杂引用数据类型，但不能正确确定基础数据类型的instanceof。</li><li id="4589" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">typeof还有一个缺点，就是虽然可以确定底层数据类型(null除外)，但是除了函数类型之外，不能确定任何被引用的数据类型。</li></ul><h2 id="c4f6" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">方法三:对象。原型。ToString</h2><ul class=""><li id="6469" class="md me in kv b kw kx la lb le mf li mg lm mh lq mi mj mk ml bi translated">toString()是prototype Object方法，它返回格式为“[object Xxx]”的字符串，其中Xxx是对象的类型。</li><li id="8cca" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">对于Object对象，调用toString()直接返回[Object Object]；对于其他对象，您需要调用它们</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="21e4" class="lr jw in mw b gy na nb l nc nd">Object.prototype.toString({})       // "[object Object]"<br/>Object.prototype.toString.call({})  // Same result as above, plus call also ok<br/>Object.prototype.toString.call(1)    // "[object Number]"<br/>Object.prototype.toString.call('1')  // "[object String]"<br/>Object.prototype.toString.call(true)  // "[object Boolean]"<br/>Object.prototype.toString.call(function(){})  // "[object Function]"<br/>Object.prototype.toString.call(null)   //"[object Null]"<br/>Object.prototype.toString.call(undefined) //"[object Undefined]"<br/>Object.prototype.toString.call(/123/g)    //"[object RegExp]"<br/>Object.prototype.toString.call(new Date()) //"[object Date]"<br/>Object.prototype.toString.call([])       //"[object Array]"<br/>Object.prototype.toString.call(document)  //"[object HTMLDocument]"<br/>Object.prototype.toString.call(window)   //"[object Window]"</span></pre><h2 id="f128" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">最优解:写一个全局通用的判断方法</h2><p id="6f0d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">原则:</p><p id="e502" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">如果是基类型，则返回该类型</p><p id="90f0" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">如果是对象类型，则使用对象。原型。ToString判断方式，常规匹配</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a757" class="lr jw in mw b gy na nb l nc nd">function getType(obj){<br/>  let type  = typeof obj;<br/>  if (type !== "object") {    // typeof is performed first, and if it is an underlying data type, it is returned directly<br/>    return type;<br/>  }<br/>  // For typeof return result is object, perform the following judgment, the regular return result<br/>  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');  // Notice the space between the RE<br/>}<br/>/* Code validation, case sensitive, which are typeof judgments and which are toString judgments? Think about */<br/>getType([])     // "Array" typeof [] is object, so toString returns<br/>getType('123')  // "string" typeof returns directly<br/>getType(window) //"The Window" toString returns<br/>getType(null)   // The first letter of "Null" is uppercase. typeof null is an object and must be determined by toString<br/>getType(undefined)   // "undefined" typeof returns directly<br/>getType()            // "undefined" typeof returns directly<br/>getType(function(){}) //"function" typeof can be determined, so the first letter is lowercase<br/>getType(/123/g)      //"The RegExp" toString returns</span></pre><h1 id="d327" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">类型转换</h1><h2 id="1434" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">先从一个小问题来体验一下吧</h2><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="593f" class="lr jw in mw b gy na nb l nc nd">'123' == 123   // false or true?    <br/>'' == null    // false or true?     <br/>'' == 0        // false or true?   <br/>[] == 0        // false or true?   <br/>[] == ''       // false or true?    <br/>[] == ![]      // false or true?    <br/>null == undefined //  false or true?  <br/>Number(null)     // What does it return?         <br/>Number('')      // What does it return?          <br/>parseInt('');    // What does it return?         <br/>{}+10           // What does it return?          <br/>let obj = {<br/>    [Symbol.toPrimitive]() {<br/>        return 200;<br/>    },<br/>    valueOf() {<br/>        return 300;<br/>    },<br/>    toString() {<br/>        return 'Hello';<br/>    }<br/>}<br/>console.log(obj + 200); // What does it print out here?</span></pre><p id="06c2" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated"><strong class="kv io">答案在底部。看看你能答对多少题</strong></p><h1 id="7759" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">强制类型转换</h1><p id="7faa" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">强制转换方法包括Number()、parseInt()、parseFloat()、toString()、String()、Boolean()</p><h2 id="09a9" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">隐式类型转换</h2><p id="4139" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">由逻辑运算符&amp;&amp;，| |，！运算符+、-、*、/、关系运算符&gt;、 =、相等运算符==、或if/while条件都是隐式转换</p><h1 id="0cb6" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">==和+的几个隐式类型转换规则</h1><h2 id="1651" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">==的隐式类型转换规则</h2><p id="afce" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">1如果类型相同，则不需要转换。</p><p id="5152" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">2如果其中一个运算符为空或未定义，那么另一个运算符必须为空或未定义才能返回true，否则两者都返回false</p><p id="e4b8" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">3如果其中一个是符号类型，则返回false</p><p id="6209" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">4如果两个运算值都是string和number类型，那么string转换为number；</p><p id="17ef" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">5如果一个运算值是一个布尔值，就把它转换成一个数字；</p><p id="4ae6" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">6如果一个操作的另一端有一个对象值和一个字符串、数字或符号，则该对象被转换为其原始类型(调用该对象的valueOf/toString方法进行转换)。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d7b2" class="lr jw in mw b gy na nb l nc nd">null == undefined       // true  Rule 2<br/>null == 0               // false Rule 2<br/>'' == null              // false Rule 2<br/>'' == 0                 // true  Rule 4 The string transfer is implicitly converted to Number and then compared<br/>'123' == 123            // true  Rule 4 The string transfer is implicitly converted to Number and then compared<br/>0 == false              // true  Rule 5 The Boolean type is implicitly converted to Number and then compared<br/>1 == true               // true  Rule 5 The Boolean type is implicitly converted to Number and then compared<br/>var a = {<br/>  value: 0,<br/>  valueOf: function() {<br/>    this.value++;<br/>    return this.value;<br/>  }<br/>};<br/>// Notice here a could be 1, 2, 3 again<br/>console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true Rule 6 Object implicit conversion<br/>// Note: However, after 3 times, reexecuting a==3 or the number before is false, because the value has been added, which should be noted here</span></pre><h2 id="ea0f" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">+的隐式类型转换规则</h2><p id="ea2c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">“+”运算符不仅可以用作数字加法，还可以用作字符串连接。只有当“+”号两边都有数字时，你在做加法；如果两端都是字符串，则在不进行隐式类型转换的情况下执行串联。</p><p id="c24b" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">除了上述更常规的情况外，还有一些特殊的规则，如下所示。</p><ul class=""><li id="a153" class="md me in kv b kw nf la ng le nk li nl lm nm lq mi mj mk ml bi translated">如果其中一个是字符串，另一个是未定义的、null或Boolean，那么调用toString()方法字符串串联；在纯对象、数组、正则表达式等情况下。，默认情况下调用该对象的转换方法将被优先考虑(在下一讲中讨论)，然后被连接。</li><li id="12cc" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">如果其中一个是数字，而另一个是未定义的、null、Boolean或number，它将被转换为数字，用于加法运算、对象或引用最后一个规则。</li><li id="b530" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">如果一个是字符串，另一个是数字，则根据字符串规则执行连接。</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="965e" class="lr jw in mw b gy na nb l nc nd">The following is a combination of code to understand the above rules, as shown below.<br/>  1 + 2        // 3  normal situation<br/>  '1' + '2'    // '12' normal situation<br/>  // Let's look at special cases<br/>  '1' + undefined   // "1undefined" rule 1, undefined conversion string<br/>  '1' + null        // "1null"  rule 1, null conversion string<br/>  '1' + true        // "1true"  rule 1, true convert string<br/>  '1' + 1n          //'11'      compares special strings and adds BigInt, BigInt is converted to string<br/>  1 + undefined     // NaN      rule 2, undefined conversion numbers add NaN<br/>  1 + null          // 1        Rule 2, null is converted to 0<br/>  1 + true          // 2        Rule 2, true is converted to 1, and the sum of the two is 2<br/>  1 + 1n            // Error    Cannot directly mix and add BigInt and Number types<br/>  '1' + 3           // '13'     Rule 3, string concatenation</span></pre><h2 id="b8ae" class="lr jw in bd jx ls lt dn kb lu lv dp kf le lw lx kj li ly lz kn lm ma mb kr mc bi translated">回答</h2><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="660a" class="lr jw in mw b gy na nb l nc nd">'123' == 123   // false or true?    true<br/>'' == null    // false or true?     false<br/>'' == 0        // false or true?    true<br/>[] == 0        // false or true?    true<br/>[] == ''       // false or true?    true<br/>[] == ![]      // false or true?    true<br/>null == undefined //  false or true?  true<br/>Number(null)     // What does it return?         0<br/>Number('')      // What does it return?          0<br/>parseInt('');    // What does it return?         NaN<br/>{}+10           // What does it return?          10<br/>let obj = {<br/>    [Symbol.toPrimitive]() {<br/>        return 200;<br/>    },<br/>    valueOf() {<br/>        return 300;<br/>    },<br/>    toString() {<br/>        return 'Hello';<br/>    }<br/>}<br/>console.log(obj + 200); // What does it print out here?  400</span></pre><p id="da80" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">最后，如果以上文章有什么不清楚的地方，请指出来，希望能在一定程度上帮助到大家，也期待您的关注，谢谢支持~</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/12-common-javascript-functions-you-need-to-know-3d3a3ab712fc"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">你需要知道的12个常见JavaScript函数</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">本文收集了日常开发中非常常用的12个函数。其中一些可能很复杂…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe jt nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-es6-in-20-minutes-8ab8f958e379"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">在20分钟内了解ES6</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">不要让任何人告诉你:“你不知道ES6怎么敢说你知道JS！”</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nz l"><div class="of l ob oc od nz oe jt nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-better-use-conditional-judgment-in-javascript-5aa1d2981e08"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">如何在JavaScript中更好地使用条件判断</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">本文花很短的时间介绍如何用JavaScript编写更简单的条件判断，帮助您…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nz l"><div class="og l ob oc od nz oe jt nq"/></div></div></a></div><p id="3837" class="pw-post-body-paragraph kt ku in kv b kw nf ky kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated"><em class="oh">更多内容请看</em><a class="ae oi" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oh">plain English . io</em></strong></a><em class="oh">。报名参加我们的</em> <a class="ae oi" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oh">免费周报</em> </strong> </a> <em class="oh">。关注我们关于</em><a class="ae oi" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oh">Twitter</em></strong></a><a class="ae oi" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oh">LinkedIn</em></strong></a><strong class="kv io"><em class="oh"/></strong><a class="ae oi" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oh">YouTube</em></strong></a><strong class="kv io"><em class="oh">，以及</em></strong><em class="oh"/><a class="ae oi" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oh">不和</em> </strong> </a>  <em class="oh">对成长黑客感兴趣？检查</em> <a class="ae oi" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oh">电路</em> </strong> </a> <strong class="kv io"> <em class="oh">。</em> </strong></p></div></div>    
</body>
</html>