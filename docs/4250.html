<html>
<head>
<title>File Upload, Mastering These 8 Scenarios Is Enough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文件上传，掌握这8个场景就够了</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/file-upload-mastering-these-8-scenarios-is-enough-ef392eda7e68?source=collection_archive---------6-----------------------#2022-11-14">https://javascript.plainenglish.io/file-upload-mastering-these-8-scenarios-is-enough-ef392eda7e68?source=collection_archive---------6-----------------------#2022-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7d65" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">令人惊讶的是，有8种上传文件到服务器的方式，每种方式背后都有不同的技术，其中很多值得我们关注。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/13c8ae02be4e3de25aa83687bfd79cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JuRqJ9n1D_l6vQak"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/es/@comparefibre?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Compare Fibre</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e8dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">web项目开发过程中，文件上传主要有<strong class="ky ir"> 8 </strong>种场景，每种场景使用的技术不同，有很多细节需要我们额外注意。</p><p id="025f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将带您总结这些<strong class="ky ir"> 8 </strong>场景。阅读本文后，您将掌握单文件上传、多文件上传、<strong class="ky ir">目录上传、</strong>、<strong class="ky ir">压缩目录上传、</strong>、拖拽上传、<strong class="ky ir">剪贴板上传、</strong>、<strong class="ky ir">大文件并发上传、</strong>以及服务器端上传的相关内容。</p><h1 id="b051" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.单个文件上传</h1><p id="4980" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于单个文件上传场景，最常见的就是图片上传场景，那么我们就以图片上传为例，先介绍一下单个文件上传的基本流程。</p><h2 id="3dc5" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 1.1 Html代码</strong></h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="5123" class="ng lt iq nc b be nh ni l nj nk">&lt;input id="uploadFile" type="file" accept="image/*" /&gt;<br/>&lt;button id="submit" onclick="uploadFile()"&gt;Upload&lt;/button&gt;h</span></pre><p id="352e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们通过input元素的<code class="fe nl nm nn nc b">accept</code>属性来限制上传文件的类型。使用此处的<code class="fe nl nm nn nc b">image/*</code>限制仅选择图像文件。当然也可以设置具体的类型，比如<code class="fe nl nm nn nc b">image/png</code> image/png或者<code class="fe nl nm nn nc b">image/png,image/jpeg</code>。</p><p id="7887" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，虽然我们将输入元素的<code class="fe nl nm nn nc b">accept</code>属性设置为<code class="fe nl nm nn nc b">image/png</code>，但是如果用户将<code class="fe nl nm nn nc b">jpg/jpeg</code>格式图像后缀更改为<code class="fe nl nm nn nc b">.png</code>，就可以成功绕过这一限制。为了解决这个问题，我们可以通过读取文件中的二进制数据来识别正确的文件类型。如果你想知道更多关于它是如何实现的，你可以阅读下面的文章:</p><div class="no np gp gr nq nr"><a href="https://medium.com/frontend-canteen/how-to-detect-file-type-using-javascript-251f67679035" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">如何用JavaScript检测文件类型？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">不要被文件后缀所迷惑！这篇文章向您展示了如何使用JavaScript获得文件的真实类型！</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kp nr"/></div></div></a></div><h2 id="6c3d" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 1.2 JS代码</strong></h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="8593" class="ng lt iq nc b be nh ni l nj nk">const uploadFileEle = document.querySelector("#uploadFile");<br/><br/>const request = axios.create({<br/>  baseURL: "http://localhost:3000/upload",<br/>  timeout: 60000, <br/>});<br/><br/>async function uploadFile() {<br/>  if (!uploadFileEle.files.length) return;<br/>  const file = uploadFileEle.files[0];<br/>  // Ignore the file verification process, such as file type, size verification<br/>  upload({<br/>    url: "/single",<br/>    file,<br/>  });<br/>}<br/><br/>function upload({ url, file, fieldName = "file" }) {<br/>  let formData = new FormData();<br/>  formData.set(fieldName, file);<br/>  request.post(url, formData, {<br/>    // Monitor upload progress<br/>    onUploadProgress: function (progressEvent) {<br/>      const percentCompleted = Math.round(<br/>        (progressEvent.loaded * 100) / progressEvent.total<br/>      );<br/>      console.log(percentCompleted);<br/>     },<br/>  });<br/>}</span></pre><p id="7581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们首先将read <code class="fe nl nm nn nc b">File</code>对象封装成一个<code class="fe nl nm nn nc b">FormData</code>对象，然后使用Axios实例的<code class="fe nl nm nn nc b">post</code>方法实现文件上传功能。在上传之前，我们可以通过设置请求配置对象的<code class="fe nl nm nn nc b">onUploadProgress</code>属性来获取文件上传的进度。</p><p id="ed8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们有了客户端上传文件的代码后，我们将使用<a class="ae kv" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Koa </strong> </a>构建一个文件服务，并使用以下中间件实现相应的功能:</p><ul class=""><li id="d02e" class="og oh iq ky b kz la lc ld lf oi lj oj ln ok lr ol om on oo bi translated">koa-static:处理静态资源的中间件；</li><li id="86dc" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated">@koa/cors:处理跨域请求的中间件；</li><li id="c39a" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated">@koa/multer:处理<code class="fe nl nm nn nc b">multipart/form-data</code>的中间件；</li><li id="aee2" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated">@koa/router:处理路由的中间件。</li></ul><h2 id="67de" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 1.3服务器端代码</strong></h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="9535" class="ng lt iq nc b be nh ni l nj nk">const path = require("path");<br/>const Koa = require("koa");<br/>const serve = require("koa-static");<br/>const cors = require("@koa/cors");<br/>const multer = require("@koa/multer");<br/>const Router = require("@koa/router");<br/><br/>const app = new Koa();<br/>const router = new Router();<br/>const PORT = 3000;<br/><br/>// The URL address of the uploaded resource<br/>const RESOURCE_URL = `http://localhost:${PORT}`;<br/><br/>// Directory to store uploaded files<br/>const UPLOAD_DIR = path.join(__dirname, "/public/upload");<br/><br/>const storage = multer.diskStorage({<br/>  destination: async function (req, file, cb) {<br/>    // Set file storage directory<br/>    cb(null, UPLOAD_DIR);<br/>  },<br/>  filename: function (req, file, cb) {<br/>    // Set file name<br/>    cb(null, `${file.originalname}`);<br/>  },<br/>});<br/><br/>const multerUpload = multer({ storage });<br/><br/>router.get("/", async (ctx) =&gt; {<br/>  ctx.body = "Welcome to File Services（by Bytefer）";<br/>});<br/><br/>router.post(<br/>  "/upload/single",<br/>  async (ctx, next) =&gt; {<br/>    try {<br/>      await next();<br/>      ctx.body = {<br/>        code: 1,<br/>        msg: "File upload successfully",<br/>        url: `${RESOURCE_URL}/${ctx.file.originalname}`,<br/>      };<br/>    } catch (error) {<br/>      ctx.body = {<br/>        code: 0,<br/>        msg: "File upload failed"<br/>      };<br/>    }<br/>  },<br/>  multerUpload.single("file")<br/>);<br/><br/>// Register middlewares<br/>app.use(cors());<br/>app.use(serve(UPLOAD_DIR));<br/>app.use(router.routes()).use(router.allowedMethods());<br/><br/>app.listen(PORT, () =&gt; {<br/>  console.log(`app starting at port ${PORT}`);<br/>});</span></pre><p id="d69f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码比较简单，<a class="ae kv" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Koa </strong> </a>内核很简单，扩展的功能通过中间件实现。例如，示例中使用的路由、CORS、静态资源处理和其他功能都是通过中间件实现的。因此，要掌握<a class="ae kv" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Koa </strong> </a>框架，核心就是要掌握它的中间件机制。其实除了单个文件上传，在文件上传场景中，我们也可以同时上传多个文件。</p><h1 id="17dc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.多文件上传</h1><p id="737b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要上传多个文件，首先我们需要允许用户同时选择多个文件。为此，我们可以使用input元素的<code class="fe nl nm nn nc b">multiple</code>属性。</p><h2 id="42de" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 2.1 Html代码</strong></h2><p id="8aaf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与单文件上传的代码相比，多文件上传场景中的input元素增加了一个<code class="fe nl nm nn nc b">multiple</code>属性:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="659c" class="ng lt iq nc b be nh ni l nj nk">&lt;input id="uploadFile" type="file" accept="image/*" multiple /&gt;<br/>&lt;button id="submit" onclick="uploadFile()"&gt;Upload&lt;/button&gt;</span></pre><h2 id="8289" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 2.2 JS代码</strong></h2><p id="ac64" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在单个文件上传的代码中，我们通过<code class="fe nl nm nn nc b">uploadFileEle.files[0]</code>获取单个文件，多文件上传需要获取选中文件的列表，也就是通过<code class="fe nl nm nn nc b">uploadFileEle.files</code>，返回一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/FileList" rel="noopener ugc nofollow" target="_blank"> FileList </a>对象。</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="53c7" class="ng lt iq nc b be nh ni l nj nk">async function uploadFile() {<br/>  if (!uploadFileEle.files.length) return;<br/>  const files = Array.from(uploadFileEle.files);<br/>  upload({<br/>    url: "/multiple",<br/>    files,<br/>  });<br/>}</span></pre><p id="1d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们希望支持上传多个文件，所以需要更新上传功能。对应的处理逻辑是遍历文件列表，然后使用<code class="fe nl nm nn nc b">FormData</code>对象的<code class="fe nl nm nn nc b">append</code>方法添加多个文件。具体代码如下:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="2831" class="ng lt iq nc b be nh ni l nj nk">function upload({ url, files, fieldName = "file" }) {<br/>  let formData = new FormData();<br/>  files.forEach((file) =&gt; {<br/>    formData.append(fieldName, file);<br/>  });<br/>  request.post(url, formData, {<br/>    // Monitor upload progress<br/>    onUploadProgress: function (progressEvent) {<br/>      const percentCompleted = Math.round(<br/>        (progressEvent.loaded * 100) / progressEvent.total<br/>      );<br/>      console.log(percentCompleted);<br/>    },<br/>  });<br/>}</span></pre><h2 id="8d10" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">2.3服务器端代码</h2><p id="6d12" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在下面的代码中，我们定义了一个新的路由— <code class="fe nl nm nn nc b">/upload/multiple</code>来处理多个文件上传的功能。当所有文件成功上传后，它将返回已上传文件的url列表:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="f937" class="ng lt iq nc b be nh ni l nj nk">router.post(<br/>  "/upload/multiple",<br/>  async (ctx, next) =&gt; {<br/>    try {<br/>      await next();<br/>      urls = ctx.files.file.map(file =&gt; `${RESOURCE_URL}/${file.originalname}`);<br/>      ctx.body = {<br/>        code: 1,<br/>        msg: "File upload successfully",<br/>        urls<br/>      };<br/>    } catch (error) {<br/>      ctx.body = {<br/>        code: 0,<br/>        msg: "File upload failed",<br/>      };<br/>    }<br/>  },<br/>  multerUpload.fields([<br/>    {<br/>      name: "file", // Corresponds to the fieldName of the FormData form item<br/>    },<br/>  ])<br/>);</span></pre><p id="86f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">介绍完单文件和多文件上传的功能后，再来介绍目录上传的功能。</p><h1 id="730e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.D <strong class="ak">目录上传</strong></h1><p id="3afc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您不知道，input元素上有一个<code class="fe nl nm nn nc b">webkitdirectory</code>属性。一旦设置了<code class="fe nl nm nn nc b">webkitdirectory</code>属性，我们就可以选择目录了。</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="e7c8" class="ng lt iq nc b be nh ni l nj nk">&lt;input id="uploadFile" type="file" accept="image/*" webkitdirectory /&gt;</span></pre><p id="8d3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们选择指定的目录时，比如我的电脑桌面上的<code class="fe nl nm nn nc b">cover</code>目录，会显示如下确认框:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/27e72d5487237d4d492f8100de8c98d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZdYbIHskiB7cvGh-6CXig.png"/></div></div></figure><p id="8a9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击上传按钮后，我们可以得到文件列表。列表中的file对象包含一个代表当前文件相对路径的<code class="fe nl nm nn nc b">webkitRelativePath</code>属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/9fa173e89f84616c1a52c9e8d23c5bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6c_722LGIXvuykxPps5-w.png"/></div></div></figure><p id="7ed0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然通过<code class="fe nl nm nn nc b">webkitdirectory</code>属性可以轻松实现选择目录的功能，但是在实际项目中我们还需要考虑它的<a class="ae kv" href="https://caniuse.com/?search=webkitdirectory" rel="noopener ugc nofollow" target="_blank">兼容性</a>。比如IE 11以下的版本就不支持这个属性。</p><h2 id="db5c" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">3.1 JS代码</h2><p id="8b3c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了让服务器根据实际的目录结构存储相应的文件，我们需要在添加表单项时向服务器提交当前文件的路径。此外，为了确保<code class="fe nl nm nn nc b">@koa/multer</code>正确处理文件的路径，我们需要对路径进行特殊处理。也就是说，用<code class="fe nl nm nn nc b">@</code>符号替换<code class="fe nl nm nn nc b">/</code>斜线。</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="8fb6" class="ng lt iq nc b be nh ni l nj nk">function upload({ url, files, fieldName = "file" }) {<br/>  let formData = new FormData();<br/>  files.forEach((file, i) =&gt; {<br/>    formData.append(<br/>      fieldName, <br/>      files[i],<br/>      files[i].webkitRelativePath.replace(/\//g, "@");<br/>    );<br/>  });<br/>  request.post(url, formData); <br/>}</span></pre><h2 id="3cde" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">3.2服务器端代码</h2><p id="5fd2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">目录上传和多文件上传的主要区别在于<code class="fe nl nm nn nc b">@koa/multer</code>中间件的配置对象不同。在destination属性对应的函数中，我们需要将文件名中的<code class="fe nl nm nn nc b">@</code>恢复为<code class="fe nl nm nn nc b">/</code>，然后根据文件的实际路径生成目录。</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="a8f0" class="ng lt iq nc b be nh ni l nj nk">const fse = require("fs-extra");<br/>const storage = multer.diskStorage({<br/>  destination: async function (req, file, cb) {<br/>    // images@image-1.jpeg =&gt; images/image-1.jpeg<br/>    let relativePath = file.originalname.replace(/@/g, path.sep);<br/>    let index = relativePath.lastIndexOf(path.sep);<br/>    let fileDir = path.join(UPLOAD_DIR, relativePath.substr(0, index));<br/>    // Make sure the file directory exists, if not, it will be created automatically<br/>    await fse.ensureDir(fileDir); <br/>    cb(null, fileDir);<br/>  },<br/>  filename: function (req, file, cb) {<br/>    let parts = file.originalname.split("@");<br/>    cb(null, `${parts[parts.length - 1]}`); <br/>  },<br/>});</span></pre><p id="ac18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在已经实现了目录上传的功能，是否可以将目录中的文件压缩成压缩包再上传？答案是肯定的，那么我们就来介绍一下如何实现上传压缩目录的功能。</p><h1 id="fafa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak"> 4。压缩目录上传</strong></h1><p id="b236" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">利用<a class="ae kv" href="https://stuk.github.io/jszip/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> JSZip </strong> </a>库提供的API，我们可以将目录中的所有文件压缩成一个Zip文件，然后将生成的ZIP文件上传到服务器。</p><h2 id="1e5a" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">4.1 JS代码</h2><p id="b6c9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JSZip实例上的<code class="fe nl nm nn nc b">file(name, data[,options])</code>方法可以将文件添加到Zip文件中。基于这个方法，我们可以封装一个<code class="fe nl nm nn nc b">generateZipFile</code>函数，将目录中的文件列表压缩成一个ZIP文件。下面是<code class="fe nl nm nn nc b">generateZipFile</code>功能的具体实现:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="6124" class="ng lt iq nc b be nh ni l nj nk">function generateZipFile(<br/>  zipName, files,<br/>  options = { type: "blob", compression: "DEFLATE" }<br/>) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    const zip = new JSZip();<br/>    for (let i = 0; i &lt; files.length; i++) {<br/>      zip.file(files[i].webkitRelativePath, files[i]);<br/>    }<br/>    zip.generateAsync(options).then(function (blob) {<br/>      zipName = zipName || Date.now() + ".zip";<br/>      const zipFile = new File([blob], zipName, {<br/>        type: "application/zip",<br/>      });<br/>      resolve(zipFile);<br/>    });<br/>  });<br/>}</span></pre><p id="1ca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建了<code class="fe nl nm nn nc b">generateZipFile</code>函数后，我们需要更新之前介绍的<code class="fe nl nm nn nc b">uploadFile</code>函数:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="1e6d" class="ng lt iq nc b be nh ni l nj nk">async function uploadFile() {<br/>  let fileList = uploadFileEle.files;<br/>  if (!fileList.length) return;<br/>  let webkitRelativePath = fileList[0].webkitRelativePath;<br/>  let zipFileName = webkitRelativePath.split("/")[0] + ".zip";<br/>  let zipFile = await generateZipFile(zipFileName, fileList);<br/>  upload({<br/>    url: "/single",<br/>    file: zipFile,<br/>    fileName: zipFileName<br/>  });<br/>}</span></pre><p id="099c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的<code class="fe nl nm nn nc b">uploadFile</code>函数中，我们将处理返回的FileList对象，即调用<code class="fe nl nm nn nc b">generateZipFile</code>函数生成ZIP文件。另外，为了在服务器接收压缩文件时获取文件名，我们在upload函数中增加了一个<code class="fe nl nm nn nc b">fileName</code>参数，用于在调用<code class="fe nl nm nn nc b">formData.append</code>方法时设置上传文件的文件名:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="42ac" class="ng lt iq nc b be nh ni l nj nk">function upload({ url, file, fileName, fieldName = "file" }) {<br/>  if (!url || !file) return;<br/>  let formData = new FormData();<br/>  formData.append(<br/>    fieldName, file, fileName<br/>  );<br/>  request.post(url, formData);<br/>}</span></pre><p id="2ef9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上是压缩目录上传，客户端部分的JS代码，服务端的代码可以参考上面单个文件上传的相关代码。</p><h1 id="d2e0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.拖放上传</h1><p id="e24b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要实现拖放上传的功能，首先需要了解与拖放相关的事件。如<code class="fe nl nm nn nc b">drag</code>、<code class="fe nl nm nn nc b">dragend</code>、<code class="fe nl nm nn nc b">dragenter</code>、<code class="fe nl nm nn nc b">dragover</code>或<code class="fe nl nm nn nc b">drop</code>事件等。这里我们只介绍接下来要用到的拖动事件:</p><ul class=""><li id="4aa2" class="og oh iq ky b kz la lc ld lf oi lj oj ln ok lr ol om on oo bi translated"><code class="fe nl nm nn nc b">dragenter</code>:当一个元素或选中的文本被拖动到一个可释放的目标时触发；</li><li id="de40" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated"><code class="fe nl nm nn nc b">dragover</code>:当一个元素或者选中的文本被拖到一个可释放的目标上时触发(每100ms)；</li><li id="aab4" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated"><code class="fe nl nm nn nc b">dragleave</code>:当拖动的元素或选择的文本离开一个可释放的目标时触发；</li><li id="b76d" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated"><code class="fe nl nm nn nc b">drop</code>:在可释放目标上释放元素或选定文本时触发。</li></ul><p id="b7ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以基于上述事件来改善用户的拖放体验。<strong class="ky ir">例如，当用户拖动的元素进入目标区域时，目标区域高亮显示。当用户拖动的元素离开目标区域时，取消突出显示。</strong>显然，当drop事件被触发时，被拖动的元素已经被放置在目标区域，这时我们需要获取相应的数据。</p><p id="9426" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么如何获取拖拽对应的数据呢？此时我们需要使用<code class="fe nl nm nn nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer" rel="noopener ugc nofollow" target="_blank">DataTransfer</a></code>对象，它用于在拖放过程中保存数据。它可以保存一个或多个数据项，这些数据项可以是一种或多种数据类型。如果拖动操作包括拖动文件，我们可以通过<code class="fe nl nm nn nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer" rel="noopener ugc nofollow" target="_blank">DataTransfer</a></code>对象的files属性获得文件列表。</p><p id="558c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">介绍完拖拽上传的相关知识，我们再来看看如何实现拖拽上传的功能。</p><h2 id="4773" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">5.1 Html代码</h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="64da" class="ng lt iq nc b be nh ni l nj nk">&lt;div id="dropArea"&gt;<br/>   &lt;p&gt;Drag and drop to upload file&lt;/p&gt;<br/>   &lt;div id="imagePreview"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h2 id="f338" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">5.2 CSS代码</h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="530c" class="ng lt iq nc b be nh ni l nj nk">#dropArea {<br/>  width: 300px;<br/>  height: 300px;<br/>  border: 1px dashed gray;<br/>  margin-bottom: 20px;<br/>}<br/><br/>#dropArea p {<br/>  text-align: center;<br/>  color: #999;<br/>}<br/><br/>#dropArea.highlighted {<br/>  background-color: #ddd;<br/>}<br/><br/>#imagePreview {<br/>  max-height: 250px;<br/>  overflow-y: scroll;<br/>}<br/><br/>#imagePreview img {<br/>  width: 100%;<br/>  display: block;<br/>  margin: auto;<br/>}</span></pre><h2 id="4839" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">5.3 JS代码</h2><p id="40a2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了让大家更好的阅读拖放上传的相关代码，我们将代码拆分成4部分来讲解:</p><p id="2a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。防止默认拖放行为</strong></p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="bb68" class="ng lt iq nc b be nh ni l nj nk">const dropAreaEle = document.querySelector("#dropArea");<br/>const imgPreviewEle = document.querySelector("#imagePreview");<br/>const IMAGE_MIME_REGEX = /^image\/(jpe?g|gif|png)$/i;<br/><br/>["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) =&gt; {<br/>   dropAreaEle.addEventListener(eventName, preventDefaults, false);<br/>   document.body.addEventListener(eventName, preventDefaults, false);<br/>});<br/><br/>function preventDefaults(e) {<br/>  e.preventDefault();<br/>  e.stopPropagation();<br/>}</span></pre><p id="a34c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。切换目标区域的高亮状态</strong></p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="9715" class="ng lt iq nc b be nh ni l nj nk">["dragenter", "dragover"].forEach((eventName) =&gt; {<br/>    dropAreaEle.addEventListener(eventName, highlight, false);<br/>});<br/>["dragleave", "drop"].forEach((eventName) =&gt; {<br/>    dropAreaEle.addEventListener(eventName, unhighlight, false);<br/>});<br/><br/>// Add highlight style<br/>function highlight(e) {<br/>  dropAreaEle.classList.add("highlighted");<br/>}<br/><br/>// Remove highlight style<br/>function unhighlight(e) {<br/>  dropAreaEle.classList.remove("highlighted");<br/>}</span></pre><p id="547f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。过程图像预览</strong></p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="8408" class="ng lt iq nc b be nh ni l nj nk">dropAreaEle.addEventListener("drop", handleDrop, false);<br/><br/>function handleDrop(e) {<br/>  const dt = e.dataTransfer;<br/>  const files = [...dt.files];<br/>  files.forEach((file) =&gt; {<br/>    previewImage(file, imgPreviewEle);<br/>  });<br/>}<br/><br/>function previewImage(file, container) {<br/>  if (IMAGE_MIME_REGEX.test(file.type)) {<br/>    const reader = new FileReader();<br/>    reader.onload = function (e) {<br/>      let img = document.createElement("img");<br/>      img.src = e.target.result;<br/>      container.append(img);<br/>    };<br/>    reader.readAsDataURL(file);<br/>  }<br/>}</span></pre><p id="ac68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。上传文件</strong></p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="b81b" class="ng lt iq nc b be nh ni l nj nk">function handleDrop(e) {<br/>  const dt = e.dataTransfer;<br/>  const files = [...dt.files];<br/>  // Omit image preview code<br/>  files.forEach((file) =&gt; {<br/>    upload({<br/>      url: "/single",<br/>      file,<br/>    });<br/>  });<br/>}<br/><br/>const request = axios.create({<br/>  baseURL: "http://localhost:3000/upload",<br/>  timeout: 60000,<br/>});<br/><br/>function upload({ url, file, fieldName = "file" }) {<br/>  let formData = new FormData();<br/>  formData.set(fieldName, file);<br/>  request.post(url, formData, {<br/>    // Monitor upload progress<br/>    onUploadProgress: function (progressEvent) {<br/>      const percentCompleted = Math.round(<br/>        (progressEvent.loaded * 100) / progressEvent.total<br/>      );<br/>      console.log(percentCompleted);<br/>    },<br/>  });<br/>}</span></pre><p id="aabf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拖拽上传是比较常见的场景，很多成熟的上传组件都支持这个功能。其实除了拖拽上传，还可以使用<strong class="ky ir">剪贴板</strong>来实现复制上传的功能。</p><h1 id="92be" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.C <strong class="ak">立牌上传</strong></h1><p id="5d18" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在介绍如何实现剪贴板上传功能之前，我们需要了解一下<code class="fe nl nm nn nc b">Clipboard</code> API。如果用户授予适当的权限，<code class="fe nl nm nn nc b">Clipboard</code>接口实现了<code class="fe nl nm nn nc b">Clipboard</code> API，提供了对系统剪贴板的读写访问。在web应用程序中，<code class="fe nl nm nn nc b">Clipboard</code> API可以用来实现剪切、复制和粘贴功能。该API用于通过<code class="fe nl nm nn nc b">document.execCommand</code> API替换剪贴板操作。</p><p id="d0b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实际项目中，我们不需要手动创建剪贴板对象，而是通过<code class="fe nl nm nn nc b">navigator.clipboard</code>获取<code class="fe nl nm nn nc b">Clipboard</code>对象:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/8011e74f8ff710d02b5803a44663c685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSxzKxXLjt4v16T68m6Ong.png"/></div></div></figure><p id="0e19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">得到<code class="fe nl nm nn nc b">Clipboard</code>对象后，我们可以使用对象提供的API来访问剪贴板，比如:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="c6a6" class="ng lt iq nc b be nh ni l nj nk">navigator.clipboard.readText().then(<br/>  clipText =&gt; document.querySelector(".editor").innerText = clipText<br/>);</span></pre><p id="20d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码用剪贴板的内容替换了HTML中第一个元素的内容。如果剪贴板是空的，或者不包含任何文本，元素的内容将被清空。这是因为当剪贴板为空或者不包含文本时，<code class="fe nl nm nn nc b">readText</code>方法返回一个空字符串。</p><p id="19d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nl nm nn nc b">Clipboard</code> API，我们可以轻松操作剪贴板，但是在实际项目使用过程中还必须考虑其<a class="ae kv" href="https://caniuse.com/async-clipboard" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">兼容性</strong> </a>。</p><p id="e9b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要实现剪贴板上传功能，可以分为以下3个步骤:</p><ul class=""><li id="994c" class="og oh iq ky b kz la lc ld lf oi lj oj ln ok lr ol om on oo bi translated">侦听容器的粘贴事件；</li><li id="93d1" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated">读取并解析剪贴板的内容；</li><li id="9ee2" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated">动态构建FormData对象并上传它。</li></ul><p id="a58c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">了解以上步骤后，我们来分析一下具体的实现代码。</p><h2 id="5d33" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">6.1 Html代码</h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="e43e" class="ng lt iq nc b be nh ni l nj nk">&lt;div id="uploadArea"&gt;<br/>   &lt;p&gt;Please copy the image before you paste it&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><h2 id="fadd" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">6.2 CSS代码</h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="29d6" class="ng lt iq nc b be nh ni l nj nk">#uploadArea {<br/>   width: 400px;<br/>   height: 400px;<br/>   border: 1px dashed gray;<br/>   display: table-cell;<br/>   vertical-align: middle;<br/>}<br/>#uploadArea p {<br/>   text-align: center;<br/>   color: #999;<br/>}<br/>#uploadArea img {<br/>   max-width: 100%;<br/>   max-height: 100%;<br/>   display: block;<br/>   margin: auto;<br/>}</span></pre><h2 id="9885" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">6.3 JS代码</h2><p id="3119" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在下面的代码中，我们使用<code class="fe nl nm nn nc b">addEventListener</code>方法向uploadArea容器添加一个粘贴事件。在相应的事件处理程序中，我们首先会判断当前浏览器是否支持异步<code class="fe nl nm nn nc b">Clipboard</code> API。如果支持，剪贴板的内容将通过<code class="fe nl nm nn nc b">navigator.clipboard.read</code>方法读取。在读取内容后，我们会通过正则性来判断剪贴板项是否包含图片资源，如果是，我们会调用<code class="fe nl nm nn nc b">previewImage</code>方法来执行图片预览操作，并保存返回的blob对象，以供后续上传操作使用。</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="cd26" class="ng lt iq nc b be nh ni l nj nk">const IMAGE_MIME_REGEX = /^image\/(jpe?g|gif|png)$/i;<br/>const uploadAreaEle = document.querySelector("#uploadArea");<br/><br/>uploadAreaEle.addEventListener("paste", async (e) =&gt; {<br/>  e.preventDefault();<br/>  const files = [];<br/>  if (navigator.clipboard) {<br/>    let clipboardItems = await navigator.clipboard.read();<br/>    for (const clipboardItem of clipboardItems) {<br/>      for (const type of clipboardItem.types) {<br/>        if (IMAGE_MIME_REGEX.test(type)) {<br/>           const blob = await clipboardItem.getType(type);<br/>           insertImage(blob, uploadAreaEle);<br/>           files.push(blob);<br/>         }<br/>       }<br/>     }<br/>  } else {<br/>      const items = e.clipboardData.items;<br/>      for (let i = 0; i &lt; items.length; i++) {<br/>        if (IMAGE_MIME_REGEX.test(items[i].type)) {<br/>          let file = items[i].getAsFile();<br/>          insertImage(file, uploadAreaEle);<br/>          files.push(file);<br/>        }<br/>      }<br/>  }<br/>  if (files.length &gt; 0) {<br/>    confirm("The clipboard detects the image file, whether to perform the upload operation?") <br/>      &amp;&amp; upload({<br/>           url: "/multiple",<br/>           files,<br/>         });<br/>   }<br/>});</span></pre><p id="409f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果当前浏览器不支持异步<code class="fe nl nm nn nc b">Clipboard</code> API，我们将尝试通过<code class="fe nl nm nn nc b">e.clipboardData.items</code>访问剪贴板内容。需要注意的是，在遍历剪贴板内容项时，我们通过<code class="fe nl nm nn nc b">getAsFile</code>方法获取剪贴板的内容。当然，这种方法也有<a class="ae kv" href="https://caniuse.com/mdn-api_datatransferitem_getasfile" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">兼容性</strong> </a>的问题。</p><p id="cd22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，当从剪贴板解析到图像资源时，用户将能够预览它。该功能基于<code class="fe nl nm nn nc b">FileReader</code> API实现。对应的代码如下:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="7a27" class="ng lt iq nc b be nh ni l nj nk">function previewImage(file, container) {<br/>  const reader = new FileReader();<br/>  reader.onload = function (e) {<br/>    let img = document.createElement("img");<br/>    img.src = e.target.result;<br/>    container.append(img);<br/>  };<br/>  reader.readAsDataURL(file);<br/>}</span></pre><p id="3a05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户预览完成后，如果上传被确认，我们将执行文件上传操作。由于文件是从剪贴板中读取的，<strong class="ky ir">在上传之前，我们会根据文件的类型</strong>自动为其生成一个文件名，文件名的形式为时间戳和文件后缀:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="3668" class="ng lt iq nc b be nh ni l nj nk">function upload({ url, files, fieldName = "file" }) {<br/>  let formData = new FormData();<br/>  files.forEach((file) =&gt; {<br/>    let fileName = +new Date() + "." + IMAGE_MIME_REGEX.exec(file.type)[1];<br/>    formData.append(fieldName, file, fileName);<br/>  });<br/>  request.post(url, formData);<br/>}</span></pre><p id="9b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经介绍了文件上传的各种不同场景，现在让我们介绍一个“特殊”场景—大文件上传。</p><h1 id="e634" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.大文件的并发上传</h1><p id="60d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">也许你也知道上传大文件的解决方案。为了提高上传的效率，我们一般使用<code class="fe nl nm nn nc b">Blob.slice</code>的方法，将大文件按照指定的大小进行切片，然后并发上传文件块。<strong class="ky ir">所有组块上传成功后，通知服务器合并组块。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/5386d39e05626cfe349286f96856c285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_rKablzlm9nHsDPElviHIw.gif"/></div></div></figure><p id="70b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具体处理方案如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/97237e90a58d140c2ce692d0721b7baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFaRfA2FzfmUQq8Kq4gojw.jpeg"/></div></div></figure><p id="1653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">了解核心流程后，具体实现可以看我之前写的文章:</p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/implement-concurrent-upload-of-large-files-in-javascript-53519a0d2eee"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">用JavaScript实现大文件的并发上传</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">用动画演示，实现基于JavaScript的并发控制，从而实现…的并发上传</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="oz l oc od oe oa of kp nr"/></div></div></a></div><p id="4eac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们之前介绍过客户端的文件上传场景，但是也有服务器端的文件上传场景。比如在服务器上动态生成海报后，上传到另一台服务器或者云厂商的OSS(对象存储服务)。下面以Node.js为例，介绍一下如何在服务器上上传文件。</p><h1 id="2d44" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">8.服务器端上传</h1><p id="a532" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">服务器上传是将文件从一台服务器上传到另一台服务器。借助Github上<code class="fe nl nm nn nc b"><a class="ae kv" href="https://github.com/form-data/form-data" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">form-data</strong></a></code>库提供的函数，我们可以轻松实现服务器上传功能。下面简单介绍一下单文件和多文件上传的功能:</p><h2 id="8b58" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">8.1单个文件上传</h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="4864" class="ng lt iq nc b be nh ni l nj nk">const fs = require("fs");<br/>const path = require("path");<br/>const FormData = require("form-data");<br/><br/>const form1 = new FormData();<br/>form1.append("file", fs.createReadStream(path.join(__dirname, "images/image-1.jpeg")));<br/>form1.submit("http://localhost:3000/upload/single", (error, response) =&gt; {<br/>  if(error) {<br/>    console.log("Single image upload failed");<br/>    return;<br/>  }<br/>  console.log("Single image uploaded successfully");<br/>});</span></pre><h2 id="3eaa" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">8.2多文件上传</h2><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="8e92" class="ng lt iq nc b be nh ni l nj nk">const form2 = new FormData();<br/>form2.append("file", fs.createReadStream(path.join(__dirname, "images/image-2.jpeg")));<br/>form2.append("file", fs.createReadStream(path.join(__dirname, "images/image-3.jpeg")));<br/>form2.submit("http://localhost:3000/upload/multiple", (error, response) =&gt; {<br/>  if(error) {<br/>    console.log("Failed to upload multiple images");<br/>    return;<br/>  }<br/>  console.log("Multiple images uploaded successfully");<br/>});</span></pre><p id="9b84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的代码可以看出，创建了<code class="fe nl nm nn nc b">FormData</code>对象后，我们只需要通过<code class="fe nl nm nn nc b">fs.createReadStream</code> API创建一个可读的流，然后调用FormData对象的append方法添加表单项，最后调用submit方法执行提交操作。</p><p id="d29e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，除了<code class="fe nl nm nn nc b">ReadableStream</code>，<code class="fe nl nm nn nc b">FormData</code>对象的<code class="fe nl nm nn nc b">append</code>方法还支持以下类型:</p><pre class="kg kh ki kj gt nb nc nd bn ne nf bi"><span id="4394" class="ng lt iq nc b be nh ni l nj nk">const FormData = require('form-data');<br/>const http = require('http');<br/><br/>const form = new FormData();<br/>http.request('http://nodejs.org/images/logo.png', function(response) {<br/>  form.append('my_field', 'my value');<br/>  form.append('my_buffer', new Buffer(10));<br/>  form.append('my_logo', response);<br/>});</span></pre><p id="51b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里介绍服务器端文件上传的内容。对于<code class="fe nl nm nn nc b">form-data</code>库的其他用途，如果有兴趣可以阅读相应的使用文档。其实除了上面介绍的8种场景，在你的日常工作中，你可能还会用到一些同步工具，比如<a class="ae kv" href="https://github.com/syncthing/syncthing" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Syncthing </strong> </a>文件同步工具来实现文件传输。好了，这篇文章的内容都介绍完了，最后来做个总结。</p><blockquote class="pa pb pc"><p id="f38b" class="kw kx pd ky b kz la jr lb lc ld ju le pe lg lh li pf lk ll lm pg lo lp lq lr ij bi translated">完整代码:<a class="ae kv" href="https://github.com/semlinker/file-upload-demos" rel="noopener ugc nofollow" target="_blank">文件-上传-演示</a></p></blockquote><h1 id="72c1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="a1c4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这篇文章中，我详细介绍了文件上传的8个场景。希望看完这篇文章，你对8个场景背后的技术有一定的了解。由于篇幅有限，我就不介绍与<code class="fe nl nm nn nc b">multipart/form-data</code>类型相关的内容了，大家可以看看相关的文章。</p><p id="294e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，在实际项目中，可以考虑直接使用成熟的第三方组件，比如Github上13K+星的<a class="ae kv" href="https://github.com/pqina/filepond" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">【file pond</strong></a>。该组件采用插件架构，以插件的形式提供许多功能，如<strong class="ky ir">文件编码、文件重命名、文件海报、图像预览和图像裁剪</strong>。</p><p id="072a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想学习打字稿，那么就不要错过<strong class="ky ir">掌握打字稿</strong>系列。</p><div class="no np gp gr nq nr"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">有了30+篇文章，学习TypeScript就不会迷茫了</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ph l oc od oe oa of kp nr"/></div></div></a></div><p id="479f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或<a class="ae kv" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，阅读更多关于TS和JS的内容！</p><p id="e366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pd">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pd">plain English . io</em></strong></a><em class="pd">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pd">免费周报</em> </strong> </a> <em class="pd">。关注我们上</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pd">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pd">LinkedIn</em></strong></a><strong class="ky ir"><em class="pd"/></strong><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pd">YouTube</em></strong></a><strong class="ky ir"><em class="pd"/></strong><em class="pd">和</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pd">不和</em> </strong> </a>  <em class="pd">对成长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pd">电路</em> </strong> </a> <strong class="ky ir"> <em class="pd">。</em> </strong></p></div></div>    
</body>
</html>