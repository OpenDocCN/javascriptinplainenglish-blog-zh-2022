<html>
<head>
<title>Smooth Animations for Interactive HTML Canvas Simulations with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React实现交互式HTML画布模拟的平滑动画</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/smooth-animations-for-interactive-html-canvas-simulations-with-react-b6fc1109ecd7?source=collection_archive---------5-----------------------#2022-02-05">https://javascript.plainenglish.io/smooth-animations-for-interactive-html-canvas-simulations-with-react-b6fc1109ecd7?source=collection_archive---------5-----------------------#2022-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a4f3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用React + TypeScript设置画布并避免低帧速率</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/0fe03e59de81c86ec0f7a90b4989fd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3lJ6gfzBL6Zwz0Bu"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@johnschno?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">John Schnobrich</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4858" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">HTML画布是一种在任何网页上创建令人惊叹的2D图形和动画的非常有趣和简单的方式。当结合像React这样的UI框架的好处时，它可以成为一个真正强大的工具来创建酷的效果、交互式模拟、自定义可视化，甚至完整的游戏。然而，为了持续地实现流畅的动画，有一些注意事项需要考虑，尤其是当你的应用变得更加复杂的时候。本指南将介绍设置React + TypeScript + canvas的基础知识，然后更深入地研究如何在具有大量UI组件和渲染更新的大型应用程序中实现流畅的动画。</p><h1 id="37ba" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">基本设置—反应+画布</h1><p id="4b5c" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">本节将介绍如何让canvas组件在React with TypeScript中工作。如果你已经知道基础知识和/或只是想学习如何优化平滑动画，请随意跳到下一节。</p><p id="2985" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了方便起见，我创建了一个简单的演示，所有代码都可以在GitHub 上查看。</p><h2 id="f74e" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">1.创建React项目</h2><p id="2368" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">创建一个新的React项目，如果您还没有:<code class="fe my mz na nb b">npx create-react-app interactive-canvas-demo --template typescript</code>。从一个全新的项目开始，尝试不同的想法和实现是有益的。</p><h2 id="19fe" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">2.添加画布组件</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">This is a fully-functioning React component that will draw a 720 x 480 black rectangle on the screen.</figcaption></figure><p id="3828" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">目前，它只在屏幕上画了一个黑色的矩形。但是下面是正在发生的事情的分类:</p><ul class=""><li id="102a" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated"><code class="fe my mz na nb b">const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null);</code>允许我们在画布组件呈现在网页上之后引用它。我们需要这个来获取用于渲染每一帧的2D上下文。</li><li id="3e0a" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><code class="fe my mz na nb b">useEffect</code>等待直到组件和画布被完全加载，以调用<code class="fe my mz na nb b">clearBackground</code>。</li><li id="ef92" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">最后，<code class="fe my mz na nb b">clearBackground</code>函数只是在画布的整个宽度和高度上画一个黑色的矩形，清除掉之前存在的任何东西。</li></ul><h2 id="3e55" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">3.画点什么</h2><p id="8775" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">接下来，让我们在屏幕中间画一个圆。定义一个<code class="fe my mz na nb b">drawCircle</code>函数，在我们调用<code class="fe my mz na nb b">clearBackground(context)</code>之后立即调用<code class="fe my mz na nb b">drawCircle(context, 360, 240)</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The new drawCircle function just draws a red circle at the given (x, y) position on the canvas.</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">We can call drawCircle from the useEffect right after calling clearBackground.</figcaption></figure><h2 id="964b" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">4.添加交互性</h2><p id="e98a" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">现在让红色的圆圈跟随用户的鼠标位置。我们可以用画布的<code class="fe my mz na nb b">onMouseMove</code>回调来捕获鼠标位置，并将其保存到一个状态变量中。然后，我们可以修改<code class="fe my mz na nb b">useEffect</code>以在鼠标位置改变时重新渲染。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">This is a fully-functioning React component that will render a red circle on the canvas following the user’s mouse movement.</figcaption></figure><p id="82da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以下是新增部件的明细:</p><ul class=""><li id="4fda" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated"><code class="fe my mz na nb b">interface Point2D</code>只是让打字更简单。</li><li id="5d8a" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><code class="fe my mz na nb b">const [cursorPosition, setCursorPosition] = useState&lt;Point2D&gt;({ x: 0, y: 0 })</code>跟踪光标的位置，初始化为(0，0)。</li><li id="0f85" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><code class="fe my mz na nb b">useEffect</code>现在有了<code class="fe my mz na nb b">cursorPosition</code>作为依赖项，所以它会在每次<code class="fe my mz na nb b">cursorPosition</code>改变时运行<code class="fe my mz na nb b">renderFrame</code>。对<code class="fe my mz na nb b">renderFrame</code>的调用可以包装在<code class="fe my mz na nb b">requestAnimationFrame</code>中，后面会用到。</li><li id="874c" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">最后，画布组件的<code class="fe my mz na nb b">onMouseMove</code> prop运行<code class="fe my mz na nb b">handleMouseMoved</code>函数，该函数计算出光标在画布上的(x，y)位置，并相应地用<code class="fe my mz na nb b">setCursorPosition</code>更新状态。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/d314edd879e5cf89678653ce64ed9bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*K-q2VGUHrgfprRpFFOsAyQ.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The red circle follows the user’s mouse position.</figcaption></figure><h2 id="5be4" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">5.添加动画</h2><p id="1dbd" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了让演示更有趣，让我们在红圈周围添加一些额外的动画。我们还可以将画布移动到它自己的组件中，将动画逻辑从应用程序的其余部分中分离出来。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The code for the AnimatedCanvas component. It still draws a red circle following the cursor’s position, but now it also animates smaller circles revolving around the main circle.</figcaption></figure><p id="3784" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里最大的变化是画布现在是一致的动画，而不是只对用户的鼠标移动做出反应。</p><ul class=""><li id="4e14" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated"><code class="fe my mz na nb b">cursorPositionRef</code>、<code class="fe my mz na nb b">lastRenderTimeRef</code>和<code class="fe my mz na nb b">revolvingCircleRotationRef</code>捕捉用于绘制每一帧的值(见下文)，以便我们可以在动画循环的范围内访问它们。</li><li id="f1dc" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">第一个<code class="fe my mz na nb b">useEffect</code>开始动画循环。每个请求的动画帧的ID存储在<code class="fe my mz na nb b">animationFrameRequestRef</code>中。如果<code class="fe my mz na nb b">AnimatedCanvas</code>组件被卸载，它将触发从这个<code class="fe my mz na nb b">useEffect</code>返回的回调来取消动画循环。</li><li id="f5a0" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">一旦系统准备好重画并允许可变帧速率，<code class="fe my mz na nb b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame</a></code>将调用<code class="fe my mz na nb b">renderFrame</code>函数。</li><li id="3dfc" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">第二个<code class="fe my mz na nb b">useEffect</code>监听<code class="fe my mz na nb b">cursorPosition</code>中的变化并更新<code class="fe my mz na nb b">cursorPositionRef</code>，这样动画循环可以在下一帧渲染中访问最新的坐标。我们需要设置ref，以便可以从动画循环的范围内访问该值。</li><li id="8263" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">我们使用<code class="fe my mz na nb b">lastRenderTimeRef</code>来计算<code class="fe my mz na nb b">deltaTime</code>,这样在不同的帧率下动画速度是一致的。</li><li id="f9fc" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">最后，<code class="fe my mz na nb b">drawRevolvingCircle</code>只是用一些简单的三角学来计算一个蓝色小圆绕着红色大圆旋转的位置。在每一帧，存储在<code class="fe my mz na nb b">revolvingCircleRotationRef</code>中的角度增加(由<code class="fe my mz na nb b">deltaTime</code>缩放)并画出小圆。</li></ul><p id="8e03" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以相应地简化<code class="fe my mz na nb b">App.tsx</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">We can get rid of most of the logic in App.tsx and only keep track of the cursor position here. You could track the cursor position directly in AnimatedCanvas.tsx too, if it is only used for animation purposes.</figcaption></figure><p id="707f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">结果如下:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/be5246beca253152a1b850b1e2d6bb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*S93_gnSZsTwrDCfXnXJdUg.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The red circle and its smaller revolving blue circle follow the user’s mouse position.</figcaption></figure><h2 id="f13c" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">6.发挥创造力</h2><p id="4e29" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">这只是你能做的事情的一个非常基本的例子。有无限的动画可能性。以下是一些想法:</p><ul class=""><li id="6f39" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">高级图表、图形或其他可视化。</li><li id="0c02" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">文本效果。</li><li id="07a1" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">图片(或者视频！)处理和操作，包括基于网络的图像编辑器。</li><li id="93bf" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">自定义UI组件。</li><li id="5f24" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">背景效果。</li><li id="df25" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">粒子效果。</li><li id="7119" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">做一个互动游戏！</li><li id="64f3" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">任何你能想到的与2D动画相关的东西。</li></ul><h1 id="1d78" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">平滑动画</h1><p id="40d0" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">到目前为止，这是一个很好的起点，如果你的应用相当轻量级，这可能是一个非常合适的解决方案。尝试添加按钮、样式和其他UI组件，并确保您仍然有流畅的动画。</p><p id="cb7b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您的应用程序变得非常大，并且有许多复杂的React组件，这些组件以频繁变化的状态重新呈现(例如，当用户键入或如果您需要跟踪光标的移动时)，您可能会开始看到断断续续的动画问题。</p><h2 id="436d" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">低帧速率示例</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/67de531d413a85816517f7278b655583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uyhDdtFC06cQ9pBpdjfYiA.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Low frame rate example: As the mouse move events trigger re-renders of the input matrices below, the whole app becomes extremely slow.</figcaption></figure><p id="3442" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我使用React + canvas开发一个<a class="ae ks" href="https://teammcode.com/projects/kalman-filter/" rel="noopener ugc nofollow" target="_blank">卡尔曼滤波器模拟</a>(一种线性状态预测算法)时，我需要代码的三个主要部分来顺利运行:</p><ol class=""><li id="fbb1" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nt nk nl nm bi translated">React UI具有滑块和96个用于6个4x4矩阵的单独文本输入字段，以及一个存储所有这些值的状态。我使用<a class="ae ks" href="https://mui.com/" rel="noopener ugc nofollow" target="_blank"> MUI </a>来简化样式和快速构建UI组件。</li><li id="5c91" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nt nk nl nm bi translated">卡尔曼滤波算法的更新逻辑以每秒60个间隔运行，访问状态值和用户的实时鼠标位置来计算其预测。</li><li id="10e5" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nt nk nl nm bi translated">画布动画代码，其中还引用了状态来绘制模拟结果。</li></ol><p id="35af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">结果如何？几乎不起作用的不稳定的模拟。</p><h2 id="48f6" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">反应重新渲染</h2><p id="2bf8" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在我的卡尔曼滤波器示例中，整个状态(滑块值、矩阵输入和光标位置)作为单个对象存储在根<code class="fe my mz na nb b">App</code>组件中，并传递给<code class="fe my mz na nb b">AnimatedCanvas</code>组件、单个UI子组件和卡尔曼滤波器的逻辑代码(使用<code class="fe my mz na nb b">setInterval</code>以恒定的间隔运行)。每当用户开始输入或移动鼠标时，所有的UI组件都将被重新呈现，新的状态被传递下来。由于React疯狂地不断重新渲染，浏览器根本跟不上，因此动画帧被延迟，导致帧速率骤降。</p><p id="eb02" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">解决方案是稍微优化一下代码，避免以如此高的频率重新呈现那么多组件。有几种方法可以实现这一点。</p><h2 id="a30c" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">解决方案1:记忆组件</h2><p id="00c8" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">使用记忆组件。这样，一个组件只有在其特定的依赖关系被改变时才会被重新渲染，而不是当状态中的任何其他东西改变时。这可以用组件周围的<code class="fe my mz na nb b">React.memo</code>包装器来完成，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React.memo takes two parameters: the component to memoize, and a function that compares the previous and next props to determine if the component should skip the re-render.</figcaption></figure><p id="0f67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这类似于将组件包装在父组件的<code class="fe my mz na nb b">useMemo</code>钩子中，这也是一个选项。</p><h2 id="0ea1" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">解决方案2:去抖</h2><p id="047e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果你的大部分重新渲染是由文本输入事件触发的，去抖动状态更新回调可能会起作用(例如，使用<a class="ae ks" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank"> lodash去抖动函数</a>)。然而，对于实时输入(如鼠标移动)来说，这不是一个好的解决方案，因为它会等待用户完全停止移动后再更新状态。</p><h2 id="21c1" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">解决方案3:采样</h2><p id="bf95" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">这个解决方案有点奇怪，但我试过了，觉得提一下会很有趣。您可以将所有用户输入值存储在<code class="fe my mz na nb b">useRef</code>钩子中，然后使用<code class="fe my mz na nb b">setInterval</code>定期对这些值进行采样并调用状态更新函数，而不是对每个事件都调用重新呈现。但是如果你的应用程序是空闲的，这是非常低效的，并且仍然需要以相当高的(但是更可预测和可管理的)频率重新渲染一切。</p><h2 id="6474" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">结论—根据需要进行优化</h2><p id="c10b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">React应用程序可能会变得非常复杂，充满了数千个需要重新渲染的子组件。即使你没有试图用canvas实现60 FPS的动画，你也可能会遇到用户输入事件过于频繁的问题，以至于应用程序无法如此频繁地有效地重新渲染一切。输入的记忆或去抖动可以帮助大大减少应用程序的工作量，为用户带来更流畅的整体体验。</p><p id="1b10" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nu">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nu">plain English . io</em></strong></a><em class="nu">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nu">免费周报</em> </strong> </a> <em class="nu">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nu">Twitter</em></strong></a><em class="nu">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nu">LinkedIn</em></strong></a><em class="nu">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nu">社区不和谐</em> </strong> </a> <em class="nu">。</em></p></div></div>    
</body>
</html>