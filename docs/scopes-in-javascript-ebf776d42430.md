# 通过示例了解 JavaScript 作用域

> 原文：<https://javascript.plainenglish.io/scopes-in-javascript-ebf776d42430?source=collection_archive---------18----------------------->

## 用实际例子理解 JavaScript 最容易混淆的部分之一。

![](img/c43b64cd419cd9eb7d77f0877e45f600.png)

让我们从简单的任务开始。查看下面的代码，告诉我我们会在控制台中看到什么:

接下来的差不多了，我们唯一需要的就是把 ***var*** 改成 ***let*** 。你认为我们现在会看到什么？

如果您认为在第一种情况下，输出将是:

```
*(wait 0sec) 3 (wait 1sec) 3 (wait 1sec ) 3*
```

其次是:

```
*(wait 0sec) 0 (wait 1sec) 1 (wait 1sec ) 2*
```

那么你是正确的。但是为什么呢？我们只改变了一个词，但得到了不同的结果。这是因为 JavaScript 作用域，这是该语言中最棘手的部分之一。如果你不理解上面的例子，不要担心，几乎没有人理解:)

# 什么是范围？

作用域是你可以**访问**变量(或函数)的地方，在所有其他没有定义变量的地方。而且比较棘手的是，JavaScript 有**两种类型的**作用域:**功能**和**块**。

当你用 **var** 或 **function** 关键字定义你的变量(或函数)时，就创建了函数作用域。将为用 **let** 或 **const** 关键字定义的变量创建块范围。

在处理功能范围时要考虑的一件重要事情是可变提升。这意味着变量的声明将放在离函数最近的**之上。**

让我们看看功能范围和提升在示例中是如何工作的:

我们可以稍微重写一下上面的代码，以便更好地理解提升是如何工作的:

# 块范围

所以功能定义了功能范围。而且毫不奇怪，代码块( ***{}*** )就是块作用域的定义。

# 回到我们开始的地方

正如你可能已经理解的，我们在第一个例子中使用了不同类型的作用域。这就是为什么我们得到了两个完全不同的结果。但是为了让它更明显，让我们重写它们来看看。

第一个:

或者我们可以使用 while 循环重写相同的代码(这将有助于我们理解第二个示例):

下面是上面的代码是如何一步一步地工作的(不管什么类型的
循环在*上对*和*使用相同的逻辑工作，而*):

1.  在第一次迭代**时，i = 0** ，因此超时延迟为 i*1000 = 0
2.  setTimeout 函数将超时回调的执行延迟 0 秒
3.  因此超时回调不会立即运行，而是只在**事件循环的下一阶段**运行
4.  循环继续运行，现在 **i = 1** ，所以现在延迟 1 秒，然后 **i = 2**
5.  并且在最后一步 **i = 3** (但是循环没有运行，因为我们有一个条件 i < 3)
6.  在我们的周期中，我们注册了 3 个 0、1、2 秒延迟的超时回调
7.  我们的循环结束了，甚至循环继续，现在超时回调代码开始运行
8.  所以现在，就像此刻一样， **i = 3** ，所有 3 个回调都将打印 **3** 作为输出。

当我们用 ***var*** 关键字声明变量时，我们让它在所有超时回调中共享，由于这些回调只在循环结束后运行**，它们将看到相同的值。**

为了突出第二个示例中的块范围，我使用了一个 while 循环:

代码的工作方式与第一个例子相同，唯一的区别是 **i** 没有在超时回调中共享，所以每个回调都有自己的值。

这两个简单的例子向我们展示了 JavaScript 语言隐藏的复杂性，现在我们明白它们是如何工作的了。

*更多内容看* [***说白了。报名参加我们的***](http://plainenglish.io/) **[***免费周报***](http://newsletter.plainenglish.io/) *。在我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *获得独家获取写作机会和建议。***