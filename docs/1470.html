<html>
<head>
<title>How to Build A Scalable Scrawler Service With Puppeteer?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用木偶师搭建一个可扩展的Scrawler服务？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-scalable-scrawler-service-with-puppeteer-8e08905ed7e3?source=collection_archive---------3-----------------------#2022-03-26">https://javascript.plainenglish.io/how-to-build-a-scalable-scrawler-service-with-puppeteer-8e08905ed7e3?source=collection_archive---------3-----------------------#2022-03-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e985" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:使它变得可伸缩</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f47b81b0f07ab43f223fa56632598180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pE8EklwrYcVXn8cq8CtuUQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Scalable system</figcaption></figure><p id="daee" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个故事是“<a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-scaleable-scrawler-service-with-puppeteer-80f928f43950">如何用木偶师构建一个可扩展的涂鸦服务”的第2部分？</a>”。在第1部分中，我们已经有了一个简单的爬虫系统。在该系统中，所有查询请求都由一台服务器处理。如果查询的数量太多，服务器可能会崩溃，并且不会有更多的请求被处理。</p><p id="610b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个故事中，我们将尝试解决这个问题。通过使爬虫进程变得异步来处理成千上万的请求。</p><h1 id="9df4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">安装RabbitMQ和Redis服务</h1><p id="5be9" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">更新<code class="fe mm mn mo mp b">docker-compose.yml</code>以定义RabbitMQ和Redis容器:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4943" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们在系统中添加了<code class="fe mm mn mo mp b">rabbitmq</code>和<code class="fe mm mn mo mp b">redis</code>服务。这些服务使用最新的官方形象。</p><p id="954b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在<code class="fe mm mn mo mp b">api</code>服务将使用<code class="fe mm mn mo mp b">node:latest</code>图像代替docker自定义图像。因为<code class="fe mm mn mo mp b">api</code>服务不会使用chrome应用。它将连接到<code class="fe mm mn mo mp b">rabbitmq</code>和<code class="fe mm mn mo mp b">redis</code>，然后我们必须更新<code class="fe mm mn mo mp b">environtment</code>块和<code class="fe mm mn mo mp b">depent_on</code>块。</p><p id="d66d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">consumer</code>是一个新服务，这个服务将处理爬虫进程。</p><p id="5856" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">.env</code>的例子:</p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="e376" class="mw lq in mp b gy mx my l mz na">API_PORT=3000</span><span id="923b" class="mw lq in mp b gy nb my l mz na">RABBITMQ_ADMIN_WEB_PORT=15672<br/>RABBITMQ_HOST=rabbitmq<br/>RABBITMQ_PORT=5672<br/>RABBITMQ_USERNAME=rabbitmq<br/>RABBITMQ_PASSWORD=r@bb1tmq<br/>RABBITMQ_QUEUE=google_scraper_queue</span><span id="f7f2" class="mw lq in mp b gy nb my l mz na">REDIS_URL=redis://redis:6379</span></pre><h1 id="7201" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">RabbitMQ和Redis与Typescript</h1><p id="2ceb" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">我们创建until文件来与RabbitMQ和Redis一起工作:</p><p id="5ca5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">src/utils/environments.ts</code></p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="c540" class="mw lq in mp b gy mx my l mz na">const apiPort = Number(process.env.API_PORT || 3000);</span><span id="7d64" class="mw lq in mp b gy nb my l mz na">const rabbitMQHostname = process.env.RABBITMQ_HOST;<br/>const rabbitMQPort = Number(process.env.RABBITMQ_PORT || 5672);<br/>const rabbitMQUsername = process.env.RABBITMQ_USERNAME;<br/>const rabbitMQPassword = process.env.RABBITMQ_PASSWORD;<br/>const rabbitMQScraperQueue = process.env.RABBITMQ_QUEUE || 'google_scraper_queue';</span><span id="9393" class="mw lq in mp b gy nb my l mz na">const redisUrl = process.env.REDIS_URL || 'redis://redis:6379';</span><span id="e82e" class="mw lq in mp b gy nb my l mz na">export default {<br/>  apiPort,<br/>  rabbitMQHostname,<br/>  rabbitMQPort,<br/>  rabbitMQUsername,<br/>  rabbitMQPassword,<br/>  rabbitMQScraperQueue,<br/>  redisUrl,<br/>};</span></pre><p id="d862" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">src/utils/interfaces.ts</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="f63e" class="mw lq in bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">RabbitMQ客户端</h2><p id="db97" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated"><code class="fe mm mn mo mp b">src/utils/scraper-queue.ts</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4ccc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">sendQueryToQueue</code>函数只是向队列发送一条消息。</p><p id="e9b8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">consume</code>函数将回调函数作为参数。当队列有新消息时，回调函数将随消息一起被调用。消费者逻辑将调用这个函数来注册回调函数。</p><p id="c34b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">src/utils/rabbitmq.ts</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7a3f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们必须安装<code class="fe mm mn mo mp b">amqplib</code>包及其类型:</p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="391e" class="mw lq in mp b gy mx my l mz na">$ npm install amqplib<br/>$ npm install @types/amqplib -D</span></pre><p id="d40c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个文件导出<code class="fe mm mn mo mp b">getChannel</code>函数，它返回一个rabbitmq通道实例。通道实例将被缓存在内存中，我们可以通过队列名获得相同的实例。<code class="fe mm mn mo mp b">prefetch(1)</code>设置确保消费者只处理一条消息，直到该过程完成。</p><h2 id="d90d" class="mw lq in bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">Redis客户端</h2><p id="5782" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated"><code class="fe mm mn mo mp b">src/utils/scraper-transaction.ts</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cb19" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">导出的函数:</p><ul class=""><li id="11ee" class="nn no in ku b kv kw ky kz lb np lf nq lj nr ln ns nt nu nv bi translated"><code class="fe mm mn mo mp b">addTransaction</code>创建一个状态为<code class="fe mm mn mo mp b">ON_QUEUE</code>的新交易项目。物品的过期时间是15分钟。</li><li id="ead8" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated"><code class="fe mm mn mo mp b">updateTransactionToProcessing</code>将交易状态更改为<code class="fe mm mn mo mp b">PROCESSING</code>。</li><li id="8ca9" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated"><code class="fe mm mn mo mp b">updateTransactionToDone</code>将交易状态改为<code class="fe mm mn mo mp b">DONE</code>，并将查询结果保存到该交易中。</li><li id="4e2e" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated"><code class="fe mm mn mo mp b">getTransactionResult</code>按交易id返回交易。</li></ul><p id="ed3b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">交易生命周期:<code class="fe mm mn mo mp b">ON_QUEUE</code>-&gt;-<code class="fe mm mn mo mp b">PROCESSING</code>-&gt;-<code class="fe mm mn mo mp b">DONE</code></p></div><div class="ab cl ob oc hr od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ig ih ii ij ik"><p id="ccf0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">src/utils/redis.ts</code></p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="e9f5" class="mw lq in mp b gy mx my l mz na">import { createClient, RedisClientType } from 'redis';<br/>import environments from './environments';</span><span id="8f02" class="mw lq in mp b gy nb my l mz na">let client: RedisClientType;</span><span id="ce64" class="mw lq in mp b gy nb my l mz na">export default async function getRedisClient():       Promise&lt;RedisClientType&gt; {<br/>  if (!client) {<br/>    client = createClient({ url: environments.redisUrl });<br/>    await client.connect();<br/>  }</span><span id="4d70" class="mw lq in mp b gy nb my l mz na">  return client;<br/>}</span></pre><p id="f89c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">getRedisClient</code>返回一个Redis客户端实例。</p><h1 id="d369" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">RabbitMQ生产者和新的api端点</h1><p id="9fae" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">我们必须更新<code class="fe mm mn mo mp b">GET /search?query=</code> api并添加一个新的api — <code class="fe mm mn mo mp b">GET /transactions/:id</code>。<code class="fe mm mn mo mp b">src/index.ts</code>会是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3962" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">GET /search</code> handler只向队列发送一个查询项，并向Redis添加一个新事务。这个api将立即响应，而不是等待爬虫程序的结果。</p><p id="5f49" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">新的api处理程序— <code class="fe mm mn mo mp b">GET /transactions/:id</code>只需通过id获取事务的当前状态。此api的响应可能包括查询结果(如果爬虫进程完成)。客户端将多次调用这个api，直到它返回查询结果。</p><h1 id="f725" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">RabbitMQ消费者</h1><p id="34e5" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">消费者进程将监听队列。</p><p id="e940" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">src/consumer.ts</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="28a9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">它从队列中获取一条消息，将事务状态更改为<code class="fe mm mn mo mp b">PROCESSING</code>，通过查询字符串查询链接，然后用查询结果将状态更新为<code class="fe mm mn mo mp b">DONE</code>。</p><p id="66b2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们必须像独立流程一样启动消费者流程，然后让我们向<code class="fe mm mn mo mp b">package.json</code>添加一个新的npm脚本</p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="cbbe" class="mw lq in mp b gy mx my l mz na">"dev:consumer": "nodemon ./dist/consumer.js",</span></pre><p id="67ea" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们在<code class="fe mm mn mo mp b">docker-compose.yml</code>文件中使用这个脚本。</p></div><div class="ab cl ob oc hr od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ig ih ii ij ik"><p id="79ca" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，让我们开始我们的系统</p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="485b" class="mw lq in mp b gy mx my l mz na">$ docker-compose up</span></pre><p id="571d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">并等到所有服务都已启动</p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="8f8b" class="mw lq in mp b gy mx my l mz na">$ docker-compose ps<br/># all service are running</span></pre><p id="0413" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">调用查询API:</p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="904e" class="mw lq in mp b gy mx my l mz na">$ curl --request GET \<br/>  --url '<a class="ae lo" href="http://localhost:3000/search?query=Oauth%20nodejs16'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/search?query=Oauth%20nodejs16'</a><br/># {"transactionId":1648304965114,"message":"The query is already in the queue"}</span></pre><p id="00f6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">检查交易状态:</p><pre class="kd ke kf kg gt ms mp mt mu aw mv bi"><span id="24e5" class="mw lq in mp b gy mx my l mz na">$ curl --request GET \<br/>  --url <a class="ae lo" href="http://localhost:3000/transactions/1648304901954" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/transactions/</a>1648304965114<br/># {"status": "ON_QUEUE"}</span><span id="952c" class="mw lq in mp b gy nb my l mz na">$ curl --request GET \<br/>  --url <a class="ae lo" href="http://localhost:3000/transactions/1648304901954" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/transactions/</a>1648304965114<br/># {"status": "PROCESSING"}</span><span id="a4aa" class="mw lq in mp b gy nb my l mz na">$ curl --request GET \<br/>  --url <a class="ae lo" href="http://localhost:3000/transactions/1648304965114" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/transactions/1648304965114</a><br/># {"status": "DONE", "data": {"links": [...]}}</span></pre></div><div class="ab cl ob oc hr od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ig ih ii ij ik"><h1 id="e505" class="lp lq in bd lr ls oi lu lv lw oj ly lz jt ok ju mb jw ol jx md jz om ka mf mg bi translated">结论</h1><p id="5f3e" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">现在，服务器资源足以处理大量查询。但是，在这种情况下，我们将花费更多的时间来获得最后一个查询的结果。因为我们只有一个消费者(<code class="fe mm mn mo mp b">docker-compose.yml</code>中的<code class="fe mm mn mo mp b">scale</code>设置)，所以会逐个处理查询。直到消费者服务器资源，我们可以增加消费者的数量来同时处理多个查询。</p><p id="3e04" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">crawler系统是一个简单的系统，它实现了异步处理，使其具有可伸缩性。希望这个故事能帮助您更好地构建您的应用程序。</p><p id="f687" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">本文使用的源代码发表在<a class="ae lo" href="https://github.com/hoangsetup/scraper-service" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><p id="4019" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢阅读！</p><p id="5e90" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="on">更多内容看</em> <a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="on">说白了。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="on">免费周报</em> </strong> </a> <em class="on">。关注我们关于</em><a class="ae lo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="on">Twitter</em></strong></a><em class="on">和</em><a class="ae lo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="on">LinkedIn</em></strong></a><em class="on">。加入我们的</em> <a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="on">社区</em> </strong> </a> <em class="on">。</em></strong></a></p></div></div>    
</body>
</html>