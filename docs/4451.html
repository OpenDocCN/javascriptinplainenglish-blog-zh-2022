<html>
<head>
<title>JavaScript Design Patterns: Builder Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式:构建器模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-design-patterns-builder-pattern-608dbb2020a?source=collection_archive---------4-----------------------#2022-12-05">https://javascript.plainenglish.io/javascript-design-patterns-builder-pattern-608dbb2020a?source=collection_archive---------4-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="74cb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从ES6重新连接JavaScript设计模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/146fae02395cebb612b2a9f113939b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDgB9tjNeDMmirtJhVwWFw.jpeg"/></div></div></figure><h2 id="fc17" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.什么是构建器模式？</h2><p id="9210" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">构建器模式将复杂对象的构造层与其表示层分离开来，以便同一构造过程可以使用不同的表示。</p><p id="c04e" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">构建器模式的特点是一步一步地构建一个复杂的对象，该对象可以用不同的组合或具有不同含义的序列来构建。通常用户不需要知道构造的细节，通常使用链调用来执行构造过程，最后调用build方法来生成最终的对象。</p><p id="0dd6" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">工厂模式也用于创建对象，但如何创建并不重要。工厂模式关注的是创建的结果，而构建器模式不仅得到结果，还参与创建的具体过程，适合创建复杂的复合对象。</p><h2 id="4cd3" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.ES6中的构建器模式</h2><p id="82c3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">让我们假设一个出版商的图书后端输入系统的业务场景。书籍有四个必需的信息:标题、作者、价格和类别；我们想要创建一个book对象来返回到后端。让我们结合使用ES6语法和构建器模式，一步一步地创建对象。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="e319" class="mq ks iq mm b be mr ms l mt mu"><br/>class BookBuilder {<br/>  constructor() {<br/>    this.name = '';<br/>    this.author = '';<br/>    this.price = 0;<br/>    this.category = '';<br/>  }<br/>  <br/>  withName(name) {<br/>    this.name = name;<br/>    return this;<br/>  }<br/><br/>  withAuthor(author) {<br/>    this.author = author;<br/>    return this;<br/>  }<br/><br/>  withPrice(price) {<br/>    this.price = price;<br/>    return this;<br/>  }<br/><br/>  withCategory(category) {<br/>    this.category = category;<br/>    return  this;<br/>  }<br/><br/>  build() {<br/>    return {<br/>      name: this.name,<br/>      author: this.author,<br/>      prices: this.price,<br/>      category: this.category<br/>    }<br/>  }<br/>}<br/><br/>//Calling the builder class<br/>const book = new BookBuilder()<br/>  .withName("The Reckonings")<br/>  .withAuthor('Lacy Johnson')<br/>  .withPrice(31)<br/>  .withCategory('Literature')<br/>  .build();</span></pre><p id="a859" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">以上讲述了如何编写和调用my <code class="fe mv mw mx mm b">BookBuilder</code>的creator类，但仅仅是一个有4个属性的对象，我们就用了这么多代码来创建，远比直接在构造函数中传递参数来创建对象复杂。这是因为我们在创建过程中有太多的<code class="fe mv mw mx mm b">withxxxx </code>方法。我们实际上可以自动创建这样的<code class="fe mv mw mx mm b">withxxxx </code>方法来简化代码。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="4de8" class="mq ks iq mm b be mr ms l mt mu"><br/>class BookBuilder {<br/>  constructor() {<br/>    this.name = '';<br/>    this.author = '';<br/>    this.price = 0;<br/>    this.category = '';<br/>  <br/>    Object.keys(this).forEach(key =&gt; {<br/>      const withName = `with${key.substring(0, 1).toUpperCase()}${key.substring(1)}`;<br/>      this[withName] = value =&gt; {<br/>        this[key] = value;<br/>        return this;<br/>      }<br/>    })<br/>  }<br/>  <br/>  //Calling the builder<br/>  build() {<br/>    const keysNoWithers = Object.keys(this).filter(key =&gt; typeof this[key] !== 'function');<br/><br/>    return keysNoWithers.reduce((returnValue, key) =&gt; {<br/>      return {<br/>        ...returnValue,<br/>        [key]: this[key]<br/>      }<br/>    }, {})<br/>  }<br/>}<br/><br/>const book = new BookBuilder()<br/> .withName("The Reckonings")<br/>  .withAuthor('Lacy Johnson')<br/>  .withPrice(31)<br/>  .withCategory('Literature')<br/>  .build();</span></pre><p id="1b02" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">上面的BookBuilder类具有与第一个示例相同的效果，但是要短得多，并且当属性越多时，代码的减少就越明显。当调用构造函数时，我们已经用xxxx自动创建了所有的构建方法，这里我们使用了一些来自ES6的新语法:Object.keys来获得对象属性的数组，…合并对象的语法。</p><p id="74c9" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">虽然比第一种方法更难读懂，但是这样做的真正好处是，当我们需要很多构建器类的时候，可以提取上面用xxx自动创建的代码，作为父类进行构建。这使得在创建其他构建器类时，很容易创建多个构建器类。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="de35" class="mq ks iq mm b be mr ms l mt mu">//Parent Class<br/>class BaseBuilder {<br/>  init() {<br/>    Object.keys(this).forEach(key =&gt; {<br/>      const withName = `with${key.substring(0, 1).toUpperCase()}${key.substring(1)}`;<br/>      this[withName] = value =&gt; {<br/>        this[key] = value;<br/>        return this;<br/>      }<br/>    })<br/>  }<br/><br/>  build() {<br/>    const keysNoWithers = Object.keys(this).filter(key =&gt; typeof this[key] !== 'function');<br/><br/>    return keysNoWithers.reduce((returnValue, key) =&gt; {<br/>      return {<br/>        ...returnValue,<br/>        [key]: this[key]<br/>      }<br/>    }, {})<br/>  }<br/>}<br/><br/>//Subclass 1: BookBuilder<br/>class BookBuilder extends BaseBuilder {<br/>  constructor() {<br/>    super();<br/><br/>    this.name = '';<br/>    this.author = '';<br/>    this.price = 0;<br/>    this.category = '';<br/>    <br/>    super.init();<br/>  }<br/>}<br/><br/>//Subclass 2<br/>class printHouseBuilder extends BaseBuilder {<br/>  constructor() {<br/>    super();<br/><br/>    this.name = '';<br/>    this.location = '';<br/>    this.quality = '';<br/><br/>    super.init();<br/>  }<br/>}<br/><br/>const book = new BookBuilder()<br/> .withName("The Reckonings")<br/>  .withAuthor('Lacy Johnson')<br/>  .withPrice(31)<br/>  .withCategory('Literature')<br/>  .build();<br/><br/>const printHouse = new printHouseBuilder()<br/>  .withName('Printers')<br/>  .withLocation('New York')<br/>  .withQuality('A')<br/>  .build();</span></pre><h2 id="76b2" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h2><p id="667b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在前面提到的工厂模式中，它们都有一个共同的特征，即对象创建过程是未知的，我们在调用一个函数后返回最终的结果对象。但是在creator模式中我们关心对象创建过程，我们通常将创建复杂对象的各种类模块化，而在ES6中，我们使用导入和导出的语法来灵活地引用和导出这些模块，以便我们的构造模式最终生成结果对象。</p><p id="71b5" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">正如您所看到的，构建器模式的使用已经并且只适合于创建极其复杂的对象。在实际的前端业务中，当没有这种极其复杂的对象需要创建时，还是应该直接使用对象字面量或者工厂模式等来创建对象。</p><p id="8cd5" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><em class="my">更多内容请看</em><a class="ae mz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae mz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="my">免费周报</em> </strong> </a> <em class="my">。关注我们关于</em><a class="ae mz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">Twitter</em></strong></a><a class="ae mz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">LinkedIn</em></strong></a><em class="my"/><a class="ae mz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">YouTube</em></strong></a><em class="my"/><a class="ae mz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">不和</em> </strong> </a> <em class="my">。对增长黑客感兴趣？检查</em> <a class="ae mz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="my">电路</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>