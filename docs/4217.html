<html>
<head>
<title>How to Implement Linked List in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中实现链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-linkedlist-in-js-64bdc855215c?source=collection_archive---------7-----------------------#2022-11-09">https://javascript.plainenglish.io/how-to-implement-linkedlist-in-js-64bdc855215c?source=collection_archive---------7-----------------------#2022-11-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f48d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript链表实用指南</h2></div><p id="32d6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我们将会看到如何在javascript中实现链表及其各种操作。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/9d8ce9385ef72de2be7ab539d916ff3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPYXZlPrC7BzDtCgw3h4Fg.png"/></div></div></figure><p id="741c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lk">注:</em>我选择了Javascript语言(我的最爱)来实现，语言在这里只是一个媒介，我们可以用任何编程语言来实现。关键思想是底层算法将始终保持不变。</p><p id="471b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们深入到编码部分之前，让我们从链表的定义开始。</p><h1 id="d3ff" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">什么是链表？</h1><p id="4984" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">Def 1 —</p><p id="3ae2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">链表是一种线性数据结构，其中元素被视为存储数据的节点和指向下一个节点(即元素)的指针。</p><p id="3927" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Def 2 —</p><p id="7f95" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">链表是一种线性数据结构，其中的元素不存储在连续的内存位置。</p><p id="9376" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">连续内存分配提供随机访问，即直接访问。由于数组元素是以这种方式存储的，所以访问任何元素都要花费恒定的时间，即O(1)，而对于链表来说，要访问任何元素，我们必须跟随指针，所以这是一个顺序访问，需要O(n)时间。</p><h2 id="5caa" class="mi lm in bd ln mj mk dn lr ml mm dp lv kl mn mo lx kp mp mq lz kt mr ms mb mt bi translated">数组与链表</h2><ol class=""><li id="d3f8" class="mu mv in ke b kf md ki me kl mw kp mx kt my kx mz na nb nc bi translated">访问第I个元素→数组O(1) |链表O(n)</li><li id="e2db" class="mu mv in ke b kf nd ki ne kl nf kp ng kt nh kx mz na nb nc bi translated">插入和删除→数组O(n) |链表O(1) —对于双向链表</li><li id="94ac" class="mu mv in ke b kf nd ki ne kl nf kp ng kt nh kx mz na nb nc bi translated">大小→数组—固定|链接列表—动态</li></ol><h1 id="fd3a" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">链表操作</h1><ol class=""><li id="e464" class="mu mv in ke b kf md ki me kl mw kp mx kt my kx mz na nb nc bi translated">横越</li><li id="03b9" class="mu mv in ke b kf nd ki ne kl nf kp ng kt nh kx mz na nb nc bi translated">链表的大小</li><li id="555d" class="mu mv in ke b kf nd ki ne kl nf kp ng kt nh kx mz na nb nc bi translated">插入</li><li id="8ffe" class="mu mv in ke b kf nd ki ne kl nf kp ng kt nh kx mz na nb nc bi translated">删除</li><li id="c296" class="mu mv in ke b kf nd ki ne kl nf kp ng kt nh kx mz na nb nc bi translated">搜索</li></ol><h1 id="ef3e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">用Javascript实现链表</h1><p id="5522" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">让我们为节点定义构造函数，也就是链表的元素</p><pre class="kz la lb lc gt ni nj nk nl aw nm bi"><span id="dc88" class="mi lm in nj b gy nn no l np nq">function Node(data) {<br/>    this.data = data;<br/>    this.next = null;<br/>}</span></pre><p id="267d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以定义LinkedList构造函数—</p><pre class="kz la lb lc gt ni nj nk nl aw nm bi"><span id="4b8b" class="mi lm in nj b gy nn no l np nq">function LinkedList() {}</span></pre><p id="b963" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在链表的原型中添加一个<strong class="ke io"> create </strong>函数，它将接受一个元素数组并创建链表。</p><pre class="kz la lb lc gt ni nj nk nl aw nm bi"><span id="1c93" class="mi lm in nj b gy nn no l np nq">LinkedList.prototype.create = function (arr) {<br/>    let head = new Node(arr[0]);<br/>    let temp = head;</span><span id="438a" class="mi lm in nj b gy nr no l np nq">    for (let i = 1; i &lt; arr.length; i++) {<br/>        temp.next = new Node(arr[i]);<br/>        temp = temp.next;<br/>    }</span><span id="e8a2" class="mi lm in nj b gy nr no l np nq">    // returning head of the linked list<br/>    return head;<br/>}</span></pre><p id="52b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就这样，LinkedList创建完毕😊</p><p id="c97a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们实现每个基本操作。</p><h2 id="98ad" class="mi lm in bd ln mj mk dn lr ml mm dp lv kl mn mo lx kp mp mq lz kt mr ms mb mt bi translated">遍历链表</h2><p id="50c8" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">从头节点开始，遍历到列表的末尾。</p><pre class="kz la lb lc gt ni nj nk nl aw nm bi"><span id="81b4" class="mi lm in nj b gy nn no l np nq">LinkedList.prototype.traverse = function (head) {<br/>    let temp = head;</span><span id="d74d" class="mi lm in nj b gy nr no l np nq">    while (temp != null) {<br/>        console.log(temp.data);<br/>        temp = temp.next;<br/>    }<br/>}</span></pre><p id="ed43" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">TC: O(n)</p><h2 id="4f90" class="mi lm in bd ln mj mk dn lr ml mm dp lv kl mn mo lx kp mp mq lz kt mr ms mb mt bi translated">链表的大小</h2><p id="7309" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">返回链表中所有元素的计数。</p><pre class="kz la lb lc gt ni nj nk nl aw nm bi"><span id="51b2" class="mi lm in nj b gy nn no l np nq">LinkedList.prototype.size = function (head) {<br/>    let temp = head;<br/>    let count = 0;</span><span id="3a6b" class="mi lm in nj b gy nr no l np nq">    while (temp != null) {<br/>        count++;<br/>        temp = temp.next;<br/>    }<br/>    <br/>    return count;<br/>}</span></pre><p id="1ba8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">TC: O(n)</p><h2 id="07ff" class="mi lm in bd ln mj mk dn lr ml mm dp lv kl mn mo lx kp mp mq lz kt mr ms mb mt bi translated">在链表中插入</h2><p id="96b1" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在链表中第k个索引处插入元素，并返回更新后的头</p><pre class="kz la lb lc gt ni nj nk nl aw nm bi"><span id="6e01" class="mi lm in nj b gy nn no l np nq">LinkedList.prototype.insert = function (head, k, elem) {<br/>    <br/>    let size = this.size(head);    <br/>   <br/>    // case 1. if index k is not valid<br/>    if (k &lt; 0 || k &gt; size) {<br/>        return head;<br/>    }</span><span id="b2f7" class="mi lm in nj b gy nr no l np nq">    let newNode = new Node(elem);</span><span id="b6e3" class="mi lm in nj b gy nr no l np nq">    // case 2. insert at beginning<br/>    if (k === 0) {<br/>        newNode.next = head;<br/>        return newNode;<br/>    }</span><span id="fa59" class="mi lm in nj b gy nr no l np nq">    // case 3. insert at kth node<br/>    let temp = head;<br/>  <br/>    for (let i = 0; i &lt; k; i++) {<br/>        temp = temp.next;<br/>    }<br/>  <br/>    newNode.next = temp.next;<br/>    temp.next = newNode;<br/>  <br/>    return head;<br/>}</span></pre><p id="6dec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">TC: O(n)</p><h2 id="d3da" class="mi lm in bd ln mj mk dn lr ml mm dp lv kl mn mo lx kp mp mq lz kt mr ms mb mt bi translated">链表中的删除</h2><p id="a466" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">从链表中删除第k个索引元素，并返回更新后的头</p><pre class="kz la lb lc gt ni nj nk nl aw nm bi"><span id="6e67" class="mi lm in nj b gy nn no l np nq">LinkedList.prototype.delete = function (head, k) {<br/>    <br/>    let size = this.size(head);    <br/>   <br/>    // case 1. if index k is not valid<br/>    if (k &lt; 0 || k &gt; size) {<br/>        return head;<br/>    }</span><span id="ecaf" class="mi lm in nj b gy nr no l np nq">    // case 2. deletion at the beginning<br/>    let temp = head;</span><span id="9c46" class="mi lm in nj b gy nr no l np nq">    if (k === 0) {<br/>        temp = head.next;<br/>        head.next = null;</span><span id="e0c6" class="mi lm in nj b gy nr no l np nq">        return temp;<br/>    }</span><span id="a57a" class="mi lm in nj b gy nr no l np nq">    // case 3. delete kth node<br/>    temp = head;<br/>  <br/>    for (let i = 0; i &lt; k; i++) {<br/>        temp = temp.next;<br/>    }</span><span id="f36c" class="mi lm in nj b gy nr no l np nq">    let cur = temp.next; // this element would be deleted<br/>    temp.next = temp.next.next; // or cur.next (both are fine)<br/>    cur.next = null;<br/>  <br/>    return head;<br/>}</span></pre><p id="b825" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">TC: O(n)</p><h2 id="d589" class="mi lm in bd ln mj mk dn lr ml mm dp lv kl mn mo lx kp mp mq lz kt mr ms mb mt bi translated">在链接列表中搜索</h2><p id="9365" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">给定链表的头和一个元素，在列表中搜索该元素。</p><pre class="kz la lb lc gt ni nj nk nl aw nm bi"><span id="9ad7" class="mi lm in nj b gy nn no l np nq">LinkedList.prototype.search = function (head, elem) {<br/>    let temp = head;<br/>    let isFound = false;</span><span id="7ce6" class="mi lm in nj b gy nr no l np nq">    while (temp != null) {<br/>        <br/>        if (temp.data === elem) {<br/>            isFound = true;<br/>            break;<br/>        }<br/>        <br/>        temp = temp.next;<br/>    }<br/>    <br/>    return isFound;<br/>}</span></pre><p id="8f76" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">TC: O(n)</p><h1 id="8516" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">结论</h1><p id="cb93" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">现在，您应该尝试自己创建LinkedList并实现每个操作。</p><p id="f8e8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，请尝试以下问题-</p><ol class=""><li id="3b28" class="mu mv in ke b kf kg ki kj kl ns kp nt kt nu kx mz na nb nc bi translated">反转链表</li><li id="3d3c" class="mu mv in ke b kf nd ki ne kl nf kp ng kt nh kx mz na nb nc bi translated">找到链表的中间</li><li id="f4b5" class="mu mv in ke b kf nd ki ne kl nf kp ng kt nh kx mz na nb nc bi translated">查找循环是否出现在链表中</li></ol><p id="0450" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你喜欢这篇文章，请分享给你的朋友。并访问weekendtutorial.com获得更多这样的文章。</p><p id="2c8e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lk">更多内容请看</em><a class="ae nv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lk">plain English . io</em></strong></a><em class="lk">。报名参加我们的</em> <a class="ae nv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。关注我们关于</em><a class="ae nv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lk">Twitter</em></strong></a><a class="ae nv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lk">LinkedIn</em></strong></a><em class="lk"/><a class="ae nv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lk">YouTube</em></strong></a><em class="lk"/><a class="ae nv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lk">不和</em> </strong> </a> <em class="lk">。对增长黑客感兴趣？检查</em> <a class="ae nv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lk">电路</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>