<html>
<head>
<title>Instance vs Raw Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实例与原始对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/instance-vs-raw-object-c9f23b17748d?source=collection_archive---------3-----------------------#2022-10-29">https://javascript.plainenglish.io/instance-vs-raw-object-c9f23b17748d?source=collection_archive---------3-----------------------#2022-10-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/82c33f0a3ec656590b3df929aa171d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ojuuxbPNFtGu3b9W"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@wacalke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mateusz Wacławek</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="02de" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">对象实例与原始对象</h1><p id="d4d0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">软件项目是另一种由排列好的组件组成的复杂结构。即使是简单的软件也要使用很多组件，如服务器、数据库、代理等。另一方面，软件可能会变得复杂，并且会集成大量不同的组件并一起工作，但核心和最重要的部分之一是任何项目的代码库/源代码，因为每个结构都取决于我们如何构建代码。</p><p id="0517" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">今天，我们将讨论在进行代码开发时，当我们进行数百次API调用时，我们是否需要将数据转换为某种形式的实例，或者我们可以直接使用原始形式的数据</p><h2 id="3720" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">什么是实例和原始对象？</h2><p id="b12a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">实例是从某个实体派生出来的抽象对象。例如，如果我们用任何语言创建一个类或函数，当我们用一个新的关键字创建它们的对象时，就叫做实例</p><p id="04ca" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面是一个典型的类的例子，我们定义了一些属性，并向有效负载添加了一些包装方法</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/36f4404ef910779e7aff001a092f34ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*UkeHHL5Jahiko1p2G0DlGQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Class instance example</figcaption></figure><p id="b320" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">另一方面，原始对象看起来像这样。原始对象可以在应用程序中定义，也可以从一些外部资源中获取。我将JSON用于原始响应，但是您也可以将其与XML进行比较</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/7e4fc7346af1ca184a3dad95364b9f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*nUTmGSReaB5wEmvJF6DMYA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of raw object</figcaption></figure><h2 id="e66c" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">如何从原始对象创建实例？</h2><p id="844c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">假设您有一个外部API，您需要调用它来获取最新的用户信息，但是现在您有两个选择，要么将它存储在用户类实例中，要么直接将其作为原始数据使用。现在，我们将了解如何将响应转换为某个实例</p><p id="b5fe" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">为了证明这一点，</p><ul class=""><li id="7893" class="mt mu in la b lb lw lf lx lj mv ln mw lr mx lv my mz na nb bi translated">首先，从任何现有的API获取用户信息，并从该函数返回原始对象</li><li id="e405" class="mt mu in la b lb nc lf nd lj ne ln nf lr ng lv my mz na nb bi translated">创建一个具有一些属性和方法的用户类，我们将在其中更新从API返回的原始用户的字段[可以在此之前添加验证]</li><li id="efe5" class="mt mu in la b lb nc lf nd lj ne ln nf lr ng lv my mz na nb bi translated">从类中创建一个实例，并使用原始JSON来更新属性和使用helper方法</li></ul><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a2cdc7cafec890287fad8b225208276a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*V4m-A_zuRQSTctv3XxvTKQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of converting instance from JSON</figcaption></figure><h2 id="c0e2" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">什么时候应该使用实例和原始对象？</h2><p id="2ca6" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在，我们知道了在将原始对象转换为实例时可以采用什么方法，但是主要的问题是我们什么时候应该使用这种方法，什么时候使用原始对象会更好</p><p id="4ae5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">再举两个用例，我们可以理解为什么这个概念非常重要</p><h2 id="87b6" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">使用ORM / ODM</h2><p id="2cac" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">当你使用任何ORM或ODM时，我们拥有类和实例的力量。例如</p><pre class="mo mp mq mr gt ni nj nk nl aw nm bi"><span id="3f71" class="mb kb in nj b gy nn no l np nq">User.find() // return all user instances of defined class</span></pre><p id="4fc4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">但是ORM并不返回原始值，而是返回实例，在这个实例中，它只有很少的助手方法和虚拟的getters和setters，可以在执行的后期使用</p><p id="f6cc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，在这个例子中，我们强调，每当我们必须进行任何需要属性相关更新或操作的处理时，将原始值转换成实例将是一个更好的主意</p><pre class="mo mp mq mr gt ni nj nk nl aw nm bi"><span id="4124" class="mb kb in nj b gy nn no l np nq">const users = User.find() // return User instnaces<br/>for (user of users) {<br/>  user.name = "test"<br/>  user.save() // update database with new values<br/>}</span></pre><p id="8250" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在原始对象的帮助下完成上述操作将是一项艰巨的任务，因此在这样的例子中实例是更好的选择</p><h2 id="4b8a" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">组块处理</h2><p id="babc" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们再举一个例子，我们有大量的数据，但目标不是存储和以后使用它们，而是获取一些统计数据，在这种情况下，原始对象将是更好的选择</p><pre class="mo mp mq mr gt ni nj nk nl aw nm bi"><span id="f87c" class="mb kb in nj b gy nn no l np nq">let count = 0<br/>api.on('data', function(chunk){<br/>  count += chunk.length // assuming chunk is array of object<br/>})</span></pre><p id="1a3b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在一些例子中，我们不用担心响应中的单个条目的属性，而是用一些公共属性来处理其他实体，那么直接使用原始对象将是一个好的选择</p><h2 id="91c0" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">还有其他选择吗？</h2><p id="4460" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你可能会想，我们是只有两个选择，还是有更多的选择，所以为了回答这个问题，我举了一个例子:React hooks，hooks为自定义数据提供了hood解决方案，它们的处理程序在内部有raw对象，但在返回时也附加了helper属性</p><p id="bd7f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在每一种语言、框架或库中，都有一些您应该尽可能看到并应用的好的实践</p><h2 id="0a03" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">结论</h2><p id="a1a9" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">使用实例和原始对象都符合它们的目的，但是数据传输只发生在原始对象上，而不是实例上，所以我们需要将对象转换为实例，这需要一些额外的处理。对于系统繁重的应用程序，哪种方法更好是有争议的，因为少量的计算也将占用大量的处理能力</p><p id="e161" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">希望你今天学到好东西，快乐编码！</p><p id="b215" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="nr">更多内容看</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="nr">说白了。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="nr">免费周报</em> </strong> </a> <em class="nr">。关注我们关于</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="nr">推特</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nr">LinkedIn</em></strong></a><em class="nr"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nr">YouTube</em></strong></a><em class="nr"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nr">不和</em> </strong> </a> <em class="nr">。对增长黑客感兴趣？检查</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="nr">电路</em> </strong> </a> <em class="nr">。</em></strong></a></p></div></div>    
</body>
</html>