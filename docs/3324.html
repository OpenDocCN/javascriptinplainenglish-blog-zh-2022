<html>
<head>
<title>The 12-Factor Tips I Follow for Building a Good SaaS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我遵循的建设好SaaS的12个因素</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-12-factor-tips-i-follow-for-building-a-good-saas-36afc3868edb?source=collection_archive---------9-----------------------#2022-08-18">https://javascript.plainenglish.io/the-12-factor-tips-i-follow-for-building-a-good-saas-36afc3868edb?source=collection_archive---------9-----------------------#2022-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ca6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及我对每个因素的一些看法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/04bc25ee3a170639560d4b2fffb470d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rZlhvYknCyNNvTQo"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@wonderlane?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Wonderlane</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6335" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2010年，我第一次着手建造SaaS。作为程序员，我的第一份也是最重要的工作之一。从那以后，这成了我最喜欢的项目类型。我为客户做过SaaS的项目，甚至在其他不完全是SaaS的项目中也做过，它们是网络应用，和SaaS有很多相似之处。</p><p id="da42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你刚进入这个web编程的世界，却不知道一个合适的方法可以遵循，那你就要倒霉了。</p><h2 id="a68e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 1。代码库</strong></h2><p id="f9de" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">代码库必须是独一无二的，并且可以从中执行许多部署。因此，这里的规则是明确的:如果你有一个以上的代码库，你没有一个web应用程序，而是一个分布式系统，每个库都必须遵循12个因素。</p><h2 id="51d0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="6221" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Node.js项目中，我认为这是Git上每个web应用程序的单一存储库。目前，有很多关于mono repo的讨论，我们在同一个存储库中有几个web应用程序。不过，同样的规则也适用于分布式系统，因为在实践中，您必须独立地部署每个monorepo项目。所以，它们是独立的网络应用。</p><h2 id="7e47" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 2。依赖性</strong></h2><p id="5403" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个因素意味着应用程序拥有的所有依赖项必须配置为与应用程序本身一起安装。永远不要相信您将要部署它的环境已经全局安装了任何库。</p><h2 id="f2ff" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="fb79" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Node.js项目中，所有开发和生产依赖项都必须在package.json中正确引用，即使是那些最终可能会全局安装在服务器上的依赖项，如TypeScript。</p><h2 id="7a2e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 3。设置</strong></h2><p id="8abd" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个因素表明，您的所有应用程序设置可能因环境而异(开发、HTML、测试、生产等。)必须在环境级别进行配置，并且不应该在代码中进行硬编码。</p><h2 id="e3af" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="88e4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Node.js中，我们通过使用通过dotenv或dotenv-safe等模块加载的环境变量来实现这一点。</p><h2 id="ab43" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 4。支持服务</strong></h2><p id="7a20" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个因素表明，您的应用程序需要的所有支持服务，从MySQL等数据库到RabbitMQ中的队列，通过SMTP Gateway和您自己公司的web API，都应该被视为web应用程序外部的资源。</p><h2 id="6923" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="17d3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如上所述，这通常包括在每个服务的环境变量中配置凭证和URL，即使所讨论的服务是由您创作或管理的。让你的web应用程序与它们保持松散耦合，这样将来做改变就容易多了。</p><h2 id="12e3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 5。编译、交付、执行</strong></h2><p id="6af8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">“构建、发布和运行”因素指的是极限编程中经常引用的持续集成、持续交付和持续部署的概念。</p><h2 id="d2d3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="5a22" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我看到许多公司通过配置和使用DevOps工具(如Jenkins、CircleCI、Bamboo和BitRise)来实现这一点，这些工具插入到他们的Git存储库中，当开发人员努力掌握测试、构建时，新版本就会生成，新版本会运行许多次新测试，并投入生产。</p><p id="9f7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组装这种完全自动化的CI/CD流水线，并且仍然有信心在生产中不会出现任何问题，这不是一项简单的任务，但我在我经历过的一些公司中看到了这种情况。</p><h2 id="1dc5" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 6。流程</strong></h2><p id="5c8c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">12因素应用程序在一个或多个彼此不共享数据的无状态进程中运行。当有多个进程时，每个进程都是独立的，不知道其他进程的存在，任何需要持久化的数据都存储在数据库中。</p><h2 id="738a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="9233" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果你的web应用有一个RESTful后端，你将遵循这个规则，因为这个架构也是无状态的。同样，假设您正在使用节点集群或PM2上传应用程序中的几个流程。在这种情况下，您也将满足这个要求，因为事件循环将被分叉，并且您将拥有并行运行的进程，即使在Node.js的情况下也是如此。</p><h2 id="3e39" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 7。端口绑定</strong></h2><p id="4a35" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个因素意味着你的web应用必须是独立的。也就是说，它不依赖于像Apache或IIS这样的web服务器来运行，并且可以通过本地端口来访问它以响应HTTP请求。你能使用一个shell命令来上传你的应用程序，而不把它托管在web服务器上吗？然后注意这个因素！</p><p id="3e12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Node.js中，这非常简单，因为这是该技术最基本的原则之一，对吗？</p><h2 id="5d2b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 8。竞赛</strong></h2><p id="d33e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个因素是对因素6的加强，因为在web应用程序中处理并发性的最佳方式是拥有隔离的、独立的进程，这些进程既可以纵向扩展(将更多资源放在同一服务器上)，也可以横向扩展。我在因素6中给出的技巧同样适用于这里。</p><h2 id="6fed" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 9。一次性</strong></h2><p id="b585" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">12因素应用程序可以随时关闭和重新启动，不会给用户体验带来重大负担和损失。</p><p id="b4b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，您应该关注快速启动和关闭，这允许任何挂起的进程在应用程序关闭之前完成处理。即使在崩溃导致你的网络应用程序意外关闭的情况下，它也应该在再次启动后从停止的地方恢复。</p><h2 id="d648" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="7f42" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">例如，可以通过RabbitMQ和AWS SQS这样的队列在Node.js中获得这种行为。您从队列中取出一条消息，只在处理完成后提交它。所以，如果不是因为某些原因，重启应用程序会从队列中再次拾起。</p><h2 id="9898" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">10。开发和生产之间的奇偶校验</h2><p id="059e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">简而言之，尽可能保持所有环境的平等。我见过的一些最灾难性的部署都是不同背景的错，所以我们在部署前做的所有测试都是无用的，因为最终的环境是不一样的。</p><h2 id="42dd" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="dc21" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">目前，解决这一问题的一种普遍技术是通过使用Docker容器，我们在本地和其他环境中运行将在生产中使用的相同映像，只是配置不同。另一种常见的技术是使用类似Sequelize的ORM进行迁移，这将很容易保证数据库的奇偶校验。</p><h2 id="1307" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 11。日志</strong></h2><p id="186c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个因素通常不适用，但应该适用。它说您的日志应该是应用程序中有序事件的流，并且这个流应该被定向到stdout(标准输出，通常是控制台屏幕)。您想要的任何其他格式必须由环境管理，在您的流中插入一些文件、日志收集器等。</p><h2 id="e9bb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">在实践中</strong></h2><p id="cd31" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">因此，在Node.js应用程序中，您不应该明确地告诉您的日志要保存到一个文件中，甚至不应该有代码来管理这个日志文件，而是应该允许这个标准的日志输出被一些将处理它们的外部服务捕获。</p><h2 id="f6d9" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 12。管理流程</strong></h2><p id="cd96" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最终，您将需要创建管理脚本来调整数据库、将数据导入应用程序、将旧数据处理成新格式，等等。</p><p id="7e28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些管理脚本，即使只使用一次，也必须遵循12个因素中的几个，如#1、#2、#3、#4、#10和#11。</p><p id="813d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node.js等技术受益于REPL工具，无需上传应用程序即可运行管理脚本。不过，在必要的时候，遵循第7个因素，这样脚本就是一个自包含的应用程序，不需要特定于web的服务器来运行它。</p><p id="cf69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">plain English . io</em></strong></a><em class="mq">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">免费周报</em> </strong> </a> <em class="mq">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">LinkedIn</em></strong></a><em class="mq"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">YouTube</em></strong></a><em class="mq"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">不和</em> </strong> </a> <em class="mq">。</em></p></div></div>    
</body>
</html>