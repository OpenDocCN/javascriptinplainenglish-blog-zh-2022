<html>
<head>
<title>6 Must-Know Generic Methods in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中6个必须知道的泛型方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/6-must-know-generic-methods-in-typescript-6954802c544f?source=collection_archive---------4-----------------------#2022-11-30">https://javascript.plainenglish.io/6-must-know-generic-methods-in-typescript-6954802c544f?source=collection_archive---------4-----------------------#2022-11-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9e7b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">TypeScript本身提供了几个有用的实用工具类型来帮助我们执行一些常见的类型转换。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cd29d4ee8c80881ccd7f1551dee1d813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XoTR5PS5hiIQLtt6DxNHrw.jpeg"/></div></div></figure><p id="d281" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript中的类型系统非常强大。它为我们提供了类型安全。虽然类型系统很受欢迎，但如果我们不计划和设计类型和接口，它也会使我们的代码混乱和难以阅读。</p><p id="8c7c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript本身提供了几个有用的实用工具类型来帮助我们执行一些常见的类型转换。这些实用程序类型是全球可用的，它们都使用泛型，在我们开始之前，让我们简单介绍一下泛型。</p><h2 id="c629" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">一般的</h2><p id="7250" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">避免代码重复和创建可重用类型是编写干净代码的重要部分。泛型是TypeScript的一个特性，它允许我们编写可重用的类型。看下面这个例子。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="3816" class="mn ll in mj b be mo mp l mq mr">type Add&lt;T&gt; = (a: T, b: T) =&gt; T<br/><br/>const addNumbers: Add&lt;number&gt; = (a, b) =&gt; {<br/>  return a + b<br/>}<br/><br/>const addStrings: Add&lt;string&gt; = (a, b) =&gt; {<br/>  return a + b<br/>}</span></pre><p id="69ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将正确的类型放入Add的泛型类型中，它可用于描述两个数字的相加或两个字符串的串联。我们不需要为每个函数编写一个类型，只需要用一个泛型类型做一次。这不仅节省了我们的努力，而且使我们的代码更干净，更不容易出错。</p><p id="0196" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有关TypeScript泛型的更多信息，可以阅读本文:</p><div class="ms mt gp gr mu mv"><a href="https://levelup.gitconnected.com/easy-to-master-the-generics-in-typescript-c288e2995bc6" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd io gy z fp na fr fs nb fu fw im bi translated">容易掌握TypeScript中的泛型</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">为什么我需要一个泛型？</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj km mv"/></div></div></a></div><p id="45dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">以下7种实用类型是我们经常使用的。</strong></p><h2 id="83a1" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">1.<code class="fe nk nl nm mj b">Partial&lt;Type&gt;</code></h2><p id="e679" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">Partial构造一个所有类型属性都设置为可选的类型。当我们为一个对象编写更新逻辑时，这非常有用。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="953b" class="mn ll in mj b be mo mp l mq mr">type User = {<br/>  name: string<br/>  age: number<br/>  address: string<br/>  occupation: string<br/>}<br/><br/>type PartialUser = Partial&lt;User&gt;<br/><br/>// type PartialUser = {<br/>//   name?: string;<br/>//   age?: number;<br/>//   address?: string;<br/>//   occupation?: string;<br/>// }</span></pre><h2 id="2c81" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">2.<code class="fe nk nl nm mj b">Required&lt;Type&gt;</code></h2><p id="2f01" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">Required是Partial的反义词。它构造一个类型，该类型的所有属性都是必需的。它可用于确保类型中不出现可选属性。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="435d" class="mn ll in mj b be mo mp l mq mr">type PartialUser = {<br/>  name: string<br/>  age: number<br/>  address?: string<br/>  occupation?: string<br/>}<br/><br/>type User = Required&lt;PartialUser&gt;<br/><br/>// type User = {<br/>//   name: string;<br/>//   age: number;<br/>//   address: string;<br/>//   occupation: string;<br/>// }</span></pre><h2 id="ba9a" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">3.<code class="fe nk nl nm mj b">Pick&lt;Type, Keys&gt;</code></h2><p id="9af5" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">选择将从类型中选择属性集键来创建一个新类型。键可以是字符串或字符串的并集。Keys的值必须是类型的键，否则TypeScript编译器会报错。当您希望通过从具有许多属性的对象中拾取某些属性来创建较轻的对象时，该工具类型特别有用。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="0fe9" class="mn ll in mj b be mo mp l mq mr">type User = {<br/>  name: string<br/>  age: number<br/>  address: string<br/>  occupation: string<br/>}<br/><br/>type BasicUser = Pick&lt;User, "name" | "age"&gt;<br/><br/>// type BasicUser = {<br/>//   name: string;<br/>//   age: number;<br/>// }</span></pre><h2 id="35f6" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">4.省略<type keys=""/></h2><p id="a1ce" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><code class="fe nk nl nm mj b">Omit </code>与<code class="fe nk nl nm mj b">Pick</code>相反。键不是关于保留哪些属性，而是要省略的属性键集。当我们只想从对象中删除某些属性而保留其他属性时，这就更有用了。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="8be6" class="mn ll in mj b be mo mp l mq mr">type User = {<br/>  name: string<br/>  age: number<br/>  address: string<br/>  occupation: string<br/>}<br/><br/>type BasicUser = Omit&lt;User, "address" | "occupation"&gt;<br/><br/>// type BasicUser = {<br/>//   name: string;<br/>//   age: number;<br/>// }</span></pre><h2 id="dd17" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">5.<code class="fe nk nl nm mj b">Readonly&lt;Type&gt;</code></h2><p id="7658" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">Readonly构造一个类型，该类型的所有属性都设置为只读。向TS重新分配一个新值将会报告一个错误。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="8998" class="mn ll in mj b be mo mp l mq mr">type User = {<br/>  name: string<br/>  age: number<br/>  address: string<br/>  occupation: string<br/>}<br/><br/>type ReadOnlyUser = Readonly&lt;User&gt;<br/><br/>const user: ReadOnlyUser = {<br/>  name: "Mark",<br/>  age: 34,<br/>  address: "Chicago",<br/>  occupation: "IT Engineer"<br/>}<br/><br/>user.name = "Maxwell"<br/>// Cannot assign to 'name' because it is a read-only property.</span></pre><h2 id="b372" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">6.<code class="fe nk nl nm mj b">ReturnType&lt;Type&gt;</code></h2><p id="0008" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">ReturnType从函数类型的返回类型构造类型。当我们处理来自外部库的函数类型并希望基于它们构建自定义类型时，这是非常有用的。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="e8e6" class="mn ll in mj b be mo mp l mq mr">import axios from 'axios'<br/><br/>type Response = ReturnType&lt;typeof axios&gt;<br/><br/>function callAPI(): Response{<br/>  return axios("url")<br/>}</span></pre><p id="794e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">除了上面提到的，还有其他类型的工具可以帮助我们编写更简洁的代码。可以在这里找到关于实用工具类型的TypeScript文档的链接。</p><div class="ms mt gp gr mu mv"><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd io gy z fp na fr fs nb fu fw im bi translated">文档-实用程序类型</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">TypeScript提供了几种实用工具类型来促进常见的类型转换。这些实用程序可用…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">www.typescriptlang.org</p></div></div><div class="ne l"><div class="nn l ng nh ni ne nj km mv"/></div></div></a></div><p id="8d0a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">实用工具类型是TypeScript提供的一个非常有用的功能。开发人员应该使用它们来避免硬编码类型。想表现的比别人多？这些是你需要知道的。如果你对我的文章感兴趣，可以关注我的<a class="ae no" href="https://hyhwell.medium.com/" rel="noopener">媒</a>。</p><p id="29a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="np">更多内容看</em> <a class="ae no" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="np">说白了。报名参加我们的</em> <a class="ae no" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="np">免费周报</em> </strong> </a> <em class="np">。关注我们关于</em> <a class="ae no" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="np">推特</em></strong></a><a class="ae no" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="np">LinkedIn</em></strong></a><em class="np"/><a class="ae no" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="np">YouTube</em></strong></a><em class="np"/><a class="ae no" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="np">不和</em> </strong> </a> <em class="np">。对增长黑客感兴趣？检查</em> <a class="ae no" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="np">电路</em> </strong> </a> <em class="np">。</em></strong></a></p></div></div>    
</body>
</html>