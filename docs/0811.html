<html>
<head>
<title>How to Use and Implement TypeScript Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用和实现TypeScript装饰器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43?source=collection_archive---------11-----------------------#2022-02-15">https://javascript.plainenglish.io/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43?source=collection_archive---------11-----------------------#2022-02-15</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="d0ad" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Decorators要编写脚本，就像注释对于Java一样——附加到类和方法上的额外信息和功能。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/a2af1c08afea3d77c6b474ad96bb6d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fXYlHZeTSsGb_E24.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Image by Author with logo’s of corresponding projects</figcaption></figure><p id="c595" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><strong class="ky is">decorator允许我们向TypeScript中的类或方法添加额外的信息。它们类似于Java中的注释。有了decorators，我们可以用非常简洁的符号添加各种各样的功能。按照计划，decorators将成为JavaScript的标准部分，因此了解它们的工作方式非常重要。</strong></p><p id="5b78" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">装饰器是可以附加到类或方法上的标记。有了它们，我们可以在JavaScript中将信息或功能附加到类、方法、参数、属性或访问器上。它们很容易实现，但是有很多细节，并且文档有时很弱。</p><p id="1812" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">TypeScript文档这样描述Decorators:</p><p id="8619" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">……Decorators提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的第二阶段提案，是TypeScript的一个实验性特性。</em></p><p id="1399" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">装饰器是一种特殊的声明，可以附加到</em>类声明<em class="ls">、</em>方法<em class="ls">、</em>访问器<em class="ls">、</em>属性<em class="ls">或</em>参数<em class="ls">上。装饰者使用</em> <code class="fe lt lu lv lw b"><em class="ls">@expression</em></code> <em class="ls">的形式，其中</em> <code class="fe lt lu lv lw b"><em class="ls">expression</em></code> <em class="ls">必须计算出一个函数，该函数将在运行时使用关于被装饰声明的信息来调用。</em></p><p id="1cdb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">虽然decorators是第2阶段的提议，但似乎TypeScript实现早于这一阶段。换句话说，在适当的时候，这个特性应该成为JavaScript的一部分，到那时TypeScript应该进行相应的修改。因此，TypeScript中的decorators是一个必须显式启用的实验性功能。</p><p id="e2b8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">有关详细描述，请参见:</p><ul class=""><li id="7d0a" class="lx ly ir ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">https://github.com/tc39/proposal-decorators——在适当的时候，装饰器有望成为ECMAScript语言的标准部分。ECMAScript委员会正致力于实现这一目标。</li></ul><p id="694b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">TypeScript实现远远落后于正在进行的提议。这意味着，如果/当ECMAScript委员会完成它的工作时，我们应该期待TypeScript实现进行相应的更改。</p><p id="73e7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">有一个相关的特性，反射元数据API，它意味着与decorators协同工作。它将是对反射API的补充，增强了使用反射来操作描述对象的数据的能力。这个API也在开发过程中。</p><p id="84e8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">因为装饰者正在成为JavaScript的标准部分，所以很值得我们花时间去了解他们做什么，甚至如何实现他们。它们看起来可能很神奇，但是每个装饰器都是由一个函数实现的，只要对装饰器和反射API有足够的了解，我们也可以开始实现它们。</p><p id="fc7b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于我们这些花时间编写Java或C#代码的人来说，我们可能有过注释的经历。这些装饰器看起来非常类似于注释，并且服务于大致相同的目的。</p><p id="e294" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文是系列文章的一部分:</p><ul class=""><li id="d9e9" class="lx ly ir ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated"><strong class="ky is">装修工介绍</strong>T5】本文</li><li id="6e67" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装修工</a></li><li id="f56d" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">物业装修工</a></li><li id="ae89" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">访问器装饰器</a></li><li id="71b3" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-parameter-decorators-in-typescript-b0042b5474ed">参数装饰器</a></li><li id="d54b" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">方法装饰者</a></li><li id="b9c9" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0">混合装修工</a></li><li id="4be4" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7">带装饰器的反射和反射API</a></li><li id="34c0" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5">使用装饰器和反射元数据在TypeScript中进行运行时数据验证</a></li></ul><h1 id="55a8" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">为TypeScript decorators设置Node.js项目</h1><p id="3c2e" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">建立一个项目目录只需要安装TypeScript编译器，并添加一个包含编译器配置指令的<code class="fe lt lu lv lw b">tsconfig.json</code>文件。</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="841d" class="nn mn ir lw b gz no np l nq nr">$ npm init -y<br/>$ npm install typescript @types/node --save-dev<br/>$ npm install reflect-metadata --save</span></pre><p id="f6f9" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这用一个<code class="fe lt lu lv lw b">package.json</code>初始化目录，并安装最少需要的文件。大多数装饰者都需要<code class="fe lt lu lv lw b">reflect-metadata</code>包，它包含一个实现反射元数据API的polyfill。</p><p id="98bf" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">似乎有一个用于编译包含decorators的JavaScript代码的Babel插件。见:<a class="ae mg" href="https://www.npmjs.com/package/@babel/plugin-proposal-decorators" rel="noopener ugc nofollow" target="_blank">https://www . npmjs . com/package/@ babel/plugin-proposal-decorators</a></p><h1 id="2090" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">为装饰者启用TypeScript中的实验特性</h1><p id="3b49" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">正如我们所说的，decorators是一个实验性的特性，因为人们认为如果/当这个特性成为JavaScript的标准部分时，实现将会改变。</p><p id="4038" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在您的<code class="fe lt lu lv lw b">tsconfig.json</code>文件中进行这些设置:</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="15c3" class="nn mn ir lw b gz no np l nq nr">{<br/>    "compilerOptions": {<br/>        ...<br/>        "experimentalDecorators": true,<br/>        "emitDecoratorMetadata": true,<br/>        ...<br/>    }<br/>}</span></pre><p id="d41f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">第一个是<code class="fe lt lu lv lw b">experimentalDecorators</code>，打开装饰器支持。</p><p id="89a1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">第二个是<code class="fe lt lu lv lw b">emitDecoratorMetadata</code>，发出<code class="fe lt lu lv lw b">reflect-metadata</code>包所需的数据。这个包通过记录关于类、属性、方法和参数的元数据，使我们能够在decorators中做强大的事情。</p><h1 id="4d60" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">GitHub上的配套资源库</h1><p id="4ab9" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">本文展示的代码也可以在GitHub上找到:<a class="ae mg" href="https://github.com/robogeek/typescript-decorators-examples" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/typescript-decorators-examples</a></p><p id="47e1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在这个库中有一个包，<code class="fe lt lu lv lw b"><a class="ae mg" href="https://www.npmjs.com/package/decorator-inspectors" rel="noopener ugc nofollow" target="_blank">decorator-inspectors</a></code>。它的装饰器对于调查或检查你正在装饰的东西很有用。</p><p id="3edd" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在撰写本系列文章期间，已经开发了另一个用于自动运行时数据验证的包。GitHub库是:<a class="ae mg" href="https://github.com/robogeek/runtime-data-validation-typescript" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/robogeek/runtime-data-validation-typescript</a></p><p id="5f06" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">国家防范机制储存库中的清单是:<a class="ae mg" href="https://www.npmjs.com/package/runtime-data-validation" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/runtime-data-validation</a></p><h1 id="503a" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">打字稿中的五种装饰者</h1><p id="112a" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">有五种装饰类型:</p><ul class=""><li id="5218" class="lx ly ir ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated"><em class="ls">类装饰者</em>被附加到类上</li><li id="86ae" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><em class="ls">属性装饰器</em>被附加到属性定义上</li><li id="6785" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><em class="ls">访问器装饰器</em>被附加到与属性相关联的<code class="fe lt lu lv lw b">get</code>或<code class="fe lt lu lv lw b">set</code>方法</li><li id="2d1e" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><em class="ls">方法装饰者</em>依附于方法</li><li id="efa2" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><em class="ls">参数装饰器</em>被附加到方法参数上</li></ul><p id="c657" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">它们看起来像这样:</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="648e" class="nn mn ir lw b gz no np l nq nr">@ClassDecorator()<br/>class A {<br/><br/>    @PropertyDecorator()<br/>    name: string;<br/><br/>    @MethodDecorator()<br/>    fly(<br/>        @ParameterDecorator()<br/>        meters: number<br/>    ) {<br/>        // code<br/>    }<br/><br/>    @AccessorDecorator()<br/>    get egg() {<br/>        // code<br/>    }<br/>    set egg(e) {<br/>        // code<br/>    }<br/>}</span></pre><p id="630f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">换句话说，就是<code class="fe lt lu lv lw b">@</code>符号，后面跟一个函数名，有时候还有函数的参数。不是装饰器名看起来像函数名，是函数名。括号是可选的，取决于装饰器的类型及其功能。装饰者可以接收参数，在这种情况下括号是必需的。</p><p id="885c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">每个装饰器都是由同名的函数实现的。</p><h1 id="3e98" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">为TypeScript寻找装饰包/库</h1><p id="6f76" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">虽然我们可以实现自己的decorator，但是如果有人已经创建了一个涵盖您需求的decorator包，那就简单多了。</p><p id="3d47" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">有用的npm搜索:</p><ul class=""><li id="173a" class="lx ly ir ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/search?q=decorator" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/search?q=decorator</a></li><li id="77bc" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/search?q=typescript%20decorator" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/search?q=typescript装潢师</a></li></ul><p id="02d6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">选定的装饰包:</p><ul class=""><li id="3653" class="lx ly ir ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/class-logger" rel="noopener ugc nofollow" target="_blank">类记录器</a> —记录类创建和方法调用</li><li id="5fe2" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器</a> —数据验证装饰器</li><li id="cb2f" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/typescript-memoize" rel="noopener ugc nofollow" target="_blank"> typescript-memoize </a> —记录方法或访问器调用的值，以避免重新计算昂贵的值</li><li id="ba41" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/class-transformer" rel="noopener ugc nofollow" target="_blank">类转换器</a> —普通数据和类实例之间的转换</li><li id="34b3" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/fastify-decorators" rel="noopener ugc nofollow" target="_blank">装饰者</a>——装饰</li><li id="05a5" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/catch-finally-decorator" rel="noopener ugc nofollow" target="_blank">Catch-finally-decorator</a>—从方法中捕捉异常</li><li id="2471" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/lynx-framework" rel="noopener ugc nofollow" target="_blank"> lynx-framework </a> —应用程序框架由几个现有组件构建而成，广泛使用装饰器</li><li id="77df" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated">核心装饰者(core-decorator)——几个广泛有用的装饰者——以及装饰者标准化的实际状态的讨论</li><li id="0cae" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/@loopback/metadata" rel="noopener ugc nofollow" target="_blank">@ loopback/metadata</a>—<code class="fe lt lu lv lw b">@Loopback</code>的一部分，一个帮助构建装饰者的装饰者库</li><li id="6cd2" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://github.com/typestack/routing-controllers" rel="noopener ugc nofollow" target="_blank">路由控制器</a>——“结构化的、声明性的、组织良好的基于类的控制器，在Express / Koa中使用大量的装饰器，使用类型脚本和路由控制器框架。”</li><li id="f28e" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/validatorjs-decorator" rel="noopener ugc nofollow" target="_blank">validator js-decorator</a>—validator js作为装饰者</li><li id="04ec" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://github.com/seanpmaxwell/overnight" rel="noopener ugc nofollow" target="_blank">通宵</a> —快递的打字装璜工</li><li id="3046" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated"><a class="ae mg" href="https://www.npmjs.com/package/@reflet/express" rel="noopener ugc nofollow" target="_blank">@ reflet/Express</a>—Express的打字稿装饰者</li></ul><p id="bf36" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">结构</p><ul class=""><li id="77ea" class="lx ly ir ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated"><a class="ae mg" href="https://tsed.io/" rel="noopener ugc nofollow" target="_blank"> TS。ED</a>——宣称是一个成熟的应用框架，广泛使用装饰器</li><li id="3796" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr mc md me mf bi translated">type ORM——用于TypeScript/JavaScript的全功能ORM，广泛使用了装饰器</li></ul><h1 id="ee14" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">开发你自己的装饰器和使用现有的装饰器包</h1><p id="8a29" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">在上一节中，我们注意到npm/yarn存储库中的许多包提供了用于各种用途的预开发包。通常我们会选择已经开发好的包，这样我们就可以继续做我们需要做的事情。希望包的作者已经测试了他们的代码，花了一些时间仔细地设计它，等等，然后我们可以回到我们的应用程序开发。</p><p id="5462" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">但是当然，情况并不总是这样。您的需求可能不同，或者可能没有满足您需求的软件包。</p><p id="04b0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本系列的文章着重于理解如何开发在TypeScript应用程序中使用的decorators。</p><h1 id="5221" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">定义和使用装饰者的一般模式</h1><p id="a72b" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">虽然每个装饰器都是由一个函数实现的，但是每个装饰器类型都需要一个具有特定签名的函数。也就是说，对于每个decorator类型，decorator函数接收一组不同的参数，TypeScript仔细地将decorator函数与所需的签名进行匹配。</p><p id="e73b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">紧跟在<code class="fe lt lu lv lw b">@</code>字符之后的必须是一个<em class="ls">表达式</em>，它计算出一个函数，具有正确的签名，将在运行时被调用。被调用的函数将被赋予参数，这些参数给出关于被修饰的事物的信息。</p><p id="06ba" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">典型用途是:</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="3e18" class="nn mn ir lw b gz no np l nq nr">function DecoratorName(parameters) {<br/>    // decorator code<br/>}<br/><br/>class ClassName {<br/>    @DecoratorName<br/>    methodName(methodParameters) {<br/>        // method code<br/>    }<br/>}</span></pre><p id="bf3e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">也就是说，您定义一个函数，并在装饰器中使用函数名。在这种情况下，<em class="ls">表达式</em>就是函数名。只要这个函数有正确的签名，它就能很好地工作。</p><p id="5072" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">另一个典型的模式是装饰工厂:</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="c207" class="nn mn ir lw b gz no np l nq nr">function OtherDecorator(parametersForDecorator) {<br/>    // preprocessing of parameters<br/>    return (decorator function parameters) =&gt; {   // actual decorator function<br/>        // decorator code<br/>    }<br/>}<br/><br/>class OtherClass {<br/><br/>    @OtherDecorator(param1, param2)<br/>    methodName(methodParameters) {<br/>        // method code<br/>    }<br/>}</span></pre><p id="b1b6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在这种情况下，<code class="fe lt lu lv lw b">OtherDecorator</code>函数返回一个带有正确签名的函数作为装饰器。本例中的<em class="ls">表达式</em>是调用<code class="fe lt lu lv lw b">OtherDecorator(param1, param2)</code>，该表达式的结果是内部函数。为此，内部函数必须实现正确的签名。这种模式用于需要额外数据的情况。</p><p id="d174" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">所发生的是，外部函数<em class="ls"> OtherDirector(param1，param2) </em>的调用是一个表达式，它返回一个具有正确签名的函数作为类装饰器。这使得内部函数成为装饰函数，外部函数成为生成装饰函数的工厂。</p><p id="bdfd" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">装饰器什么时候需要括号？这与每个装饰定义的性质有关。对于具有正确签名的装饰函数，不能使用括号。对于遵循工厂模型的每个decorator，括号是必需的，并且必须使用，以便对函数调用进行求值，从而返回内部函数。</p><p id="13f9" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">同样，decorator是<code class="fe lt lu lv lw b">@</code>，后跟一个<em class="ls">表达式</em>，用正确的签名计算一个函数。为了更清楚地说明这一点，可以考虑在被修饰的代码中定义一个内嵌的装饰器:</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="386a" class="nn mn ir lw b gz no np l nq nr">@((constructor: Function) =&gt; {<br/>    console.log(`Inline constructor decorator `, constructor);<br/>})<br/>class InlineDecoratorExample {<br/>    // properties and methods<br/>}</span></pre><p id="c7aa" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是一个<code class="fe lt lu lv lw b">@</code>字符，后跟一个<em class="ls">表达式</em>，即一个内嵌箭头函数，它计算出一个具有正确签名的函数。这个例子包含了一个类装饰器的正确签名。</p><p id="2e6d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">很难找到使用内嵌装饰器的理由。decorators的一个目的是代码共享，并使用简洁的符号实现功能。没有任何关于内联装饰器的内容支持这两个目标，但是TypeScript编译器允许这样做。</p><h1 id="d8b8" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">有多个装饰者时的评估顺序</h1><p id="1150" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">允许使用多个装饰器:</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="6d40" class="nn mn ir lw b gz no np l nq nr">@decorator1 @decorator2 @decorator4<br/>@decorator3(param1, param2)<br/>class MultiDecoratorClass {<br/>    // methods and properties<br/>}</span></pre><p id="b4af" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">每行文本可以有多个装饰器，并且在计算机的内存或计算限制范围内，可以有任意多个装饰器。</p><p id="c77c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">评估多个decorators的规则(执行顺序)是:</p><ol class=""><li id="972f" class="lx ly ir ky b kz la lc ld lf lz lj ma ln mb lr ns md me mf bi translated">每个装饰器的表达式都是自顶向下计算的。</li><li id="b66c" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr ns md me mf bi translated">然后从下到上将结果作为函数调用。</li></ol><p id="388b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">表达式“<em class="ls">每个装饰器的表达式</em>”指的是跟在<code class="fe lt lu lv lw b">@</code>字符后面的是一个计算为装饰器函数的表达式。对于不需要括号的装饰器，装饰器名直接映射到装饰器函数，因此<em class="ls">表达式</em>就是函数名。对于装饰工厂，<em class="ls">表达式</em>意味着评估外部函数的调用，它返回内部函数。</p><p id="0d8a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是按照它们在文本中出现的顺序从上到下发生的。</p><p id="9e14" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">实际的装饰函数是从下到上执行的。</p><h1 id="5877" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">每种装修工的评估顺序</h1><p id="8cba" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">评估附加到一个类的decorators按照规定的顺序进行:</p><ol class=""><li id="1eee" class="lx ly ir ky b kz la lc ld lf lz lj ma ln mb lr ns md me mf bi translated"><em class="ls">参数修饰器</em>，后面跟着<em class="ls">方法</em>、<em class="ls">访问器</em>，或者<em class="ls">属性修饰器</em>被应用于每个实例成员——也就是通常的方法。</li><li id="af4f" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr ns md me mf bi translated"><em class="ls">参数修饰器</em>，接着是<em class="ls">方法</em>、<em class="ls">访问器</em>，或者<em class="ls">属性修饰器</em>被应用于每个静态成员——也就是静态方法。</li><li id="3663" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr ns md me mf bi translated"><em class="ls">参数修饰器</em>应用于构造函数。</li><li id="d3ea" class="lx ly ir ky b kz mh lc mi lf mj lj mk ln ml lr ns md me mf bi translated"><em class="ls">班级装修工</em>申请班级。</li></ol><h1 id="d01f" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">TypeScript decorators可以用在独立的函数、类型或接口上吗？</h1><p id="497d" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated">装饰器只能在类中使用。每种装饰类型要么应用于一个类，要么应用于一个类的成员。为了验证这一点，让我们做一个小实验，用类外声明的东西来尝试decorators。让我们从装饰一个简单的函数开始:</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="4c2e" class="nn mn ir lw b gz no np l nq nr">function Decorator() {<br/>    console.log('In Decorator');<br/>}<br/><br/>@Decorator<br/>function decorated() {<br/>    console.log('in decorated');<br/>}</span></pre><p id="aacb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在Visual Studio代码中，您将得到答案——<code class="fe lt lu lv lw b">@</code>下面的红线和decorators在那里无效的消息。并且，使用编译器:</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="41da" class="nn mn ir lw b gz no np l nq nr">$ npx tsc function.ts <br/>function.ts:6:1 - error TS1206: Decorators are not valid here.<br/><br/>6 @Decorator<br/>  ~<br/><br/>Found 1 error.</span></pre><p id="466d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">很明显，装饰器不能用在裸函数上。错误不是装饰者的签名无效，而是装饰者在这个位置无效。即使您为方法装饰器使用了正确的签名，编译器也会给出相同的错误消息。</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="380d" class="nn mn ir lw b gz no np l nq nr">function foo(@logParameter x:number) {<br/>    // function<br/>}</span></pre><p id="02f0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是试图在独立函数的参数上使用参数装饰器。并且，我们再次得到同样的错误，装饰器在这里无效。</p><pre class="kh ki kj kk gu nj lw nk nl aw nm bi"><span id="13ef" class="nn mn ir lw b gz no np l nq nr">@Decorator<br/>interface XyzzyInterface {<br/>    x: number;<br/>    y: number;<br/>    zzy: number;<br/>}<br/><br/>@Decorator<br/>type XyzzyType = {<br/>    x: number;<br/>    y: number;<br/>    zzy: number;<br/>};</span></pre><p id="ca1f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">您将会看到同样的错误消息，当将decorator附加到<code class="fe lt lu lv lw b">interface</code>或<code class="fe lt lu lv lw b">type</code>定义时，这里不允许decorator。</p><h1 id="cedf" class="mm mn ir bd mo mp mq mr ms mt mu mv mw jx mx jy my ka mz kb na kd nb ke nc nd bi translated">关于作者</h1><p id="73c6" class="pw-post-body-paragraph kw kx ir ky b kz ne js lb lc nf jv le lf ng lh li lj nh ll lm ln ni lp lq lr ik bi translated"><a class="ae mg" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">大卫·赫伦</em> </strong> </a> <em class="ls">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl nt nu hv nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ik il im in io"><p id="f5b0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">原载于</em><a class="ae mg" href="https://techsparx.com/nodejs/typescript/decorators/introduction.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://techsparx.com</em></a><em class="ls">。</em></p><p id="9364" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">更多内容请看</em> <a class="ae mg" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">说白了就是</em> </strong> </a> <em class="ls">。报名参加我们的</em> <a class="ae mg" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">免费每周简讯</em> </strong> </a> <em class="ls">。在我们的</em> <a class="ae mg" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">社区不和谐</em> </strong> </a> <em class="ls">获取独家写作机会和建议。</em></p></div></div>    
</body>
</html>