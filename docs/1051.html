<html>
<head>
<title>Have React Hooks Made Higher-Order Components Obsolete?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React钩子使得高阶组件过时了吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/have-react-hooks-made-higher-order-components-obsolete-8284a9577243?source=collection_archive---------6-----------------------#2022-03-01">https://javascript.plainenglish.io/have-react-hooks-made-higher-order-components-obsolete-8284a9577243?source=collection_archive---------6-----------------------#2022-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3dfb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React Hooks时代的高阶元件</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/291ed7f8644655f834e1cd51620ef5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7ApLkRPedWzSInu_YujjA.png"/></div></div></figure><p id="01e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React钩子真的让高阶组件过时了吗？这些唯一的用例是成为我们应用程序中一些现存遗留角落的过去的残余？什么是高阶分量呢？为什么我们首先需要它们？</p><p id="f678" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回答这些问题并建立一个案例，即使在现代应用程序中，高阶组件对于某些类型的任务仍然有用。</p><p id="6858" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是让我们从头开始。</p><h1 id="5382" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">什么是高阶分量？</h1><p id="0c23" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">根据<a class="ae mh" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> React docs </a>的说法，这是一种重用用于横切关注点的组件逻辑的高级技术，如果这个描述对你有任何意义的话(对我来说没那么重要🙂).</p><p id="c6ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在英语中，它只是一个函数，接受一个组件作为它的参数之一，处理它，然后返回它的修改版本。最简单的变体是这样的，它什么也不做:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="161e" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">// accept a Component as an argument<br/>const withSomeLogic = (Component) =&gt; {<br/>  // do something<br/><br/>  // return a component that renders the component from the argument<br/>  return (props) =&gt; &lt;Component {...props} /&gt;;<br/>};</em></span></pre><p id="7ad6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里的关键是函数的返回部分——它只是一个组件，就像任何其他组件一样。而且类似于<a class="ae mh" href="https://www.developerway.com/posts/react-component-as-prop-the-right-way" rel="noopener ugc nofollow" target="_blank">渲染道具模式</a>，我们需要将道具传递给返回的组件，否则就会被吞掉。</p><p id="af4c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，到了使用它的时候，它会变成这样:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="105d" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Button = ({ onClick }) =&gt; &lt;button onClick={func}&gt;Button&lt;/button&gt;;<br/>const ButtonWithSomeLogic = withSomeLogic(Button);</em></span></pre><p id="abfe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您将您的<code class="fe mt mu mv mj b">Button</code>组件传递给函数，它返回新的<code class="fe mt mu mv mj b">Button</code>，它包括在高阶组件中定义的任何逻辑。然后这个按钮可以作为任何其他按钮使用:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="b584" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const SomePage = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Button /&gt;<br/>      &lt;ButtonWithSomeLogic /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="1984" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们想要创建一个什么去哪里的心理地图，它可能看起来像这样:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/db8df460e39de0142c932c05ff635691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y2DncgfylhiS__tJ.png"/></div></div></figure><p id="9a53" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在codesandbox中试验这些例子<a class="ae mh" href="https://codesandbox.io/s/hocs-intro-6jqmju?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="351f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在引入钩子之前，高阶组件被广泛用于访问上下文和任何外部数据订阅。<a class="ae mh" href="https://react-redux.js.org/api/connect" rel="noopener ugc nofollow" target="_blank"> Redux connect </a>或<a class="ae mh" href="https://v5.reactrouter.com/web/api/withRouter" rel="noopener ugc nofollow" target="_blank"> react-router的</a> <code class="fe mt mu mv mj b">withRouter</code>函数是高阶组件:它们接受一个组件，向其中注入一些道具，然后返回。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="2cd2" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">// location is injected by the withRouter higher-order component<br/>// would you guessed that by the look at this component alone?<br/>const SomeComponent = ({ location }) =&gt; {<br/>  return &lt;&gt;{location}&lt;/&gt;;<br/>};<br/><br/>const ComponentWithRouter = withRouter(SomeComponent);</em></span></pre><p id="3353" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如您所看到的，高阶组件编写和理解起来非常复杂。所以当挂钩<a class="ae mh" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">推出的时候，难怪每个人都转而使用它们。</a></p><p id="5e25" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们不需要创建复杂的心理地图来说明哪一个道具去了哪里，也不需要试图弄清楚<code class="fe mt mu mv mj b">location</code>是如何出现在道具中的，我们只需要写下:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="53dd" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const SomeComponent = () =&gt; {<br/>  // we see immediately where location is coming from<br/>  const { location } = useRouter();<br/><br/>  return &lt;&gt;{location}&lt;/&gt;;<br/>};</em></span></pre><p id="8ae3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">组件中发生的一切都可以从上到下阅读，所有数据的来源都很明显，这大大简化了调试和开发。</p><p id="9c55" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然钩子可能取代了90%的共享逻辑问题和100%的访问上下文的用例，但仍然有至少三种类型的功能，其中高阶组件可能是有用的。</p><p id="f840" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看那些。</p><h1 id="923f" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">第一:增强回调并对生命周期事件做出反应</h1><p id="1417" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">假设您需要在一些回调中发送某种高级日志。例如，当您单击一个按钮时，您希望发送一些带有数据的日志事件。你会怎么用钩子？您可能有一个带有<code class="fe mt mu mv mj b">onClick</code>回调的<code class="fe mt mu mv mj b">Button</code>组件:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="c99e" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">type ButtonProps = {<br/>  onClick: () =&gt; void;<br/>  children: ReactNode;<br/>}<br/><br/>const Button = ({ onClick }: { onClick }: ButtonProps) =&gt; {<br/>  return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;<br/>}</em></span></pre><p id="98f0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后在消费者端，您将挂钩到回调并在那里发送日志记录事件:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="ee28" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const SomePage = () =&gt; {<br/>  const log = useLoggingSystem();<br/><br/>  const onClick = () =&gt; {<br/>    log('Button was clicked');<br/>  };<br/><br/>  return &lt;Button onClick={() =&gt; onClick}&gt;Click here&lt;/Button&gt;;<br/>};</em></span></pre><p id="33cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你想发起一两个事件，这是没问题的。但是，如果您希望每当按钮被点击时，您的日志事件在整个应用程序中一致地被触发，该怎么办呢？我们大概可以把它烘焙成<code class="fe mt mu mv mj b">Button</code>组件本身。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="d56c" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Button = ({ onClick }: { onClick }: ButtonProps) =&gt; {<br/>  const log = useLoggingSystem();<br/><br/>  const onButtonClick = () =&gt; {<br/>    log('Button was clicked')<br/>    onClick();<br/>  }<br/><br/>  return &lt;button onClick={() =&gt; onClick()}&gt;{children}&lt;/button&gt;<br/>}</em></span></pre><p id="d747" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是然后呢？对于正确的日志，您还必须发送某种数据。我们当然可以用一些<code class="fe mt mu mv mj b">loggingData</code>道具来扩展<code class="fe mt mu mv mj b">Button</code>组件，并把它传递下去:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="4221" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Button = ({ onClick, loggingData }: { onClick, loggingData }: ButtonProps) =&gt; {<br/>  const onButtonClick = () =&gt; {<br/>    log('Button was clicked', loggingData)<br/>    onClick();<br/>  }<br/>  return &lt;button onClick={() =&gt; onButtonClick()}&gt;{children}&lt;/button&gt;<br/>}</em></span></pre><p id="e5ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，如果您希望在其他组件上发生单击时触发相同的事件，该怎么办呢？在我们的应用程序中，通常不是人们唯一可以点击的东西。如果我想向一个<code class="fe mt mu mv mj b">ListItem</code>组件添加相同的日志记录，该怎么办？复制粘贴完全相同的逻辑吗？</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="0a68" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const ListItem = ({ onClick, loggingData }: { onClick, loggingData }: ListItemProps) =&gt; {<br/>  const onListItemClick = () =&gt; {<br/>    log('List item was clicked', loggingData)<br/>    onClick();<br/>  }<br/>  return &lt;Item onClick={() =&gt; onListItemClick()}&gt;{children}&lt;/Item&gt;<br/>}</em></span></pre><p id="e180" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">太多的复制面食，容易出错，有人忘记改变我的口味。</p><p id="d87b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本质上，我想要的是在某个地方封装“某些触发的<code class="fe mt mu mv mj b">onClick</code>回调-发送一些日志事件”的逻辑，然后在我想要的任何组件中重用它，而不用以任何方式改变那些组件的代码。</p><p id="3ee5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是第一个不用钩子的用例，但高阶元件可能会派上用场。</p><h1 id="d2d0" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">增强onClick回调的高阶组件</h1><p id="cb13" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">不用到处复制粘贴“点击发生→记录数据”逻辑，我只需创建一个<code class="fe mt mu mv mj b">withLoggingOnClick</code>函数，即:</p><ul class=""><li id="0ec5" class="mx my in kq b kr ks ku kv kx mz lb na lf nb lj nc nd ne nf bi translated">接受组件作为参数</li><li id="e56a" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated">截获它的onClick回调</li><li id="69e4" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated">将我需要的数据发送到用于日志记录的任何外部框架</li><li id="1cca" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated">完整地返回带有onClick回调的组件以备将来使用</li></ul><p id="3896" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它看起来会像这样:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="57b1" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">type Base = { onClick: () =&gt; void };<br/><br/>// just a function that accepts Component as an argument<br/>export const withLoggingOnClick = &lt;TProps extends Base&gt;(Component: ComponentType&lt;TProps&gt;) =&gt; {<br/>  return (props: TProps) =&gt; {<br/>    const onClick = () =&gt; {<br/>      console.log('Log on click something');<br/>      // don't forget to call onClick that is coming from props!<br/>      // we're overriding it below<br/>      props.onClick();<br/>    };<br/><br/>    // return original component with all the props<br/>    // and overriding onClick with our own callback<br/>    return &lt;Component {...props} onClick={onClick} /&gt;;<br/>  };<br/>};</em></span></pre><p id="c873" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我可以把它添加到我想要的任何组件中。我可以在<code class="fe mt mu mv mj b">Button</code>中加入日志:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="5caa" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">export const ButtonWithLoggingOnClick = withLoggingOnClick(SimpleButton);</em></span></pre><p id="e5de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者在列表项中使用它:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="6a3f" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">export const ListItemWithLoggingOnClick = withLoggingOnClick(ListItem);</em></span></pre><p id="c9ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者任何其他我想跟踪的有<code class="fe mt mu mv mj b">onClick</code>回调的组件。在<code class="fe mt mu mv mj b">Button</code>或<code class="fe mt mu mv mj b">ListItem</code>组件中没有一行代码被修改！</p><h1 id="a77d" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">向高阶分量添加数据</h1><p id="09df" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">现在，剩下要做的就是从外部向日志记录函数添加一些数据。考虑到高阶分量只不过是一个函数，我们可以很容易地做到这一点。只需要给函数添加一些其他参数，就这样:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="65ac" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">type Base = { onClick: () =&gt; void };<br/>export const withLoggingOnClickWithParams = &lt;TProps extends Base&gt;(<br/>  Component: ComponentType&lt;TProps&gt;,<br/>  // adding some params as a second argument to the function<br/>  params: { text: string },<br/>) =&gt; {<br/>  return (props: TProps) =&gt; {<br/>    const onClick = () =&gt; {<br/>      // accessing params that we passed as an argument here<br/>      // everything else stays the same<br/>      console.log('Log on click: ', params.text);<br/>      props.onClick();<br/>    };<br/><br/>    return &lt;Component {...props} onClick={onClick} /&gt;;<br/>  };<br/>};</em></span></pre><p id="c357" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当我们用高阶组件包装按钮时，我们可以传递我们想要记录的文本:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="fb8c" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const ButtonWithLoggingOnClickWithParams = withLoggingOnClickWithParams(SimpleButton, { text: 'button component' });</em></span></pre><p id="ae58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在消费者方面，我们只是将这个按钮作为一个普通的按钮组件使用，而不用担心日志文本:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="d365" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Page = () =&gt; {<br/>  return &lt;ButtonWithLoggingOnClickWithParams onClick={onClickCallback}&gt;Click me&lt;/ButtonWithLoggingOnClickWithParams&gt;;<br/>};</em></span></pre><p id="c73d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是如果我们真的想让T8担心这段文字呢？如果我们想在使用按钮的不同上下文中发送不同的文本，该怎么办？我们不想为每个用例创建一百万个包装好的按钮。</p><p id="6105" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也很容易解决:我们可以将文本作为一个道具注入到结果按钮中，而不是将文本作为函数的参数传递。代码应该是这样的:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="fba3" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">type Base = { onClick: () =&gt; void };<br/>export const withLoggingOnClickWithProps = &lt;TProps extends Base&gt;(Component: ComponentType&lt;TProps&gt;) =&gt; {<br/>  // our returned component will now have additional logText prop<br/>  return (props: TProps &amp; { logText: string }) =&gt; {<br/>    const onClick = () =&gt; {<br/>      // accessing it here, as any other props<br/>      console.log('Log on click: ', props.logText);<br/>      props.onClick();<br/>    };<br/><br/>    return &lt;Component {...props} onClick={onClick} /&gt;;<br/>  };<br/>};</em></span></pre><p id="5b51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后像这样使用它:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="0d58" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Page = () =&gt; {<br/>  return (<br/>    &lt;ButtonWithLoggingOnClickWithProps onClick={onClickCallback} logText="this is Page button"&gt;<br/>      Click me<br/>    &lt;/ButtonWithLoggingOnClickWithProps&gt;<br/>  );<br/>};</em></span></pre><p id="79e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">参见<a class="ae mh" href="https://codesandbox.io/s/hocs-buttons-m45hm4?file=/src/hocs/with-logging-on-click.tsx" rel="noopener ugc nofollow" target="_blank"> codesandbox中的所有示例</a>。</p><h1 id="4a9b" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">在装载时而不是点击时发送数据</h1><p id="0337" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们这里不局限于点击和回调。请记住，这些只是组件，我们可以做我们想要和需要的任何事情🙂我们可以利用React提供的一切。例如，我们可以在安装组件时发送这些日志事件:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="7341" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">export const withLoggingOnMount = &lt;TProps extends unknown&gt;(Component: ComponentType&lt;TProps&gt;) =&gt; {<br/>  return (props: TProps) =&gt; {<br/>    // no more overriding onClick, just adding normal useEffect<br/>    useEffect(() =&gt; {<br/>      console.log('log on mount');<br/>    }, []);<br/><br/>    // just passing props intact<br/>    return &lt;Component {...props} /&gt;;<br/>  };<br/>};</em></span></pre><p id="686b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">和<code class="fe mt mu mv mj b">onClick</code>通过参数或道具添加数据的故事完全一样。这里不打算复制粘贴，在<a class="ae mh" href="https://codesandbox.io/s/hocs-buttons-m45hm4?file=/src/hocs/with-logging-on-mount.tsx:58-305" rel="noopener ugc nofollow" target="_blank">code sandbox</a>中看到。</p><p id="ee99" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们甚至可以大胆地组合所有这些高阶组件:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="e320" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">export const SuperButton = withLoggingOnClick(<br/>  withLoggingOnClickWithParams(<br/>    withLoggingOnClickWithProps(<br/>      withLoggingOnMount(withLoggingOnMountWithParams(withLoggingOnMountWithProps(SimpleButton), { text: 'button component' })),<br/>    ),<br/>    { text: 'button component' },<br/>  ),<br/>);</em></span></pre><p id="3cba" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，我们不应该这样做😅如果某件事是可能的，它并不总是意味着它是一个好主意。想象一下，当调试时间到来时，试图跟踪哪些道具来自哪里。如果我们真的需要将几个高阶元件合并成一个，我们至少可以更具体一点:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="f6e6" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const ButtonWithLoggingOnClick = withLoggingOnClick(SimpleButton);<br/>const ButtonWithLoggingOnClickAndMount = withLoggingOnMount(ButtonWithLoggingOnClick);<br/>// etc</em></span></pre><h1 id="a05c" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">第二:拦截DOM事件</h1><p id="5e7e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">高阶组件的另一个非常有用的应用是拦截各种DOM事件。例如，假设您在页面上实现了某种键盘快捷键功能。当特定的键被按下时，你想做各种事情，像打开对话框，创建问题，等等。您可能会在窗口中添加一个事件监听器，如下所示:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="fa99" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">useEffect(() =&gt; {<br/>  const keyPressListener = (event) =&gt; {<br/>    // do stuff<br/>  };<br/><br/>  window.addEventListener('keypress', keyPressListener);<br/><br/>  return () =&gt; window.removeEventListener('keypress', keyPressListener);<br/>}, []);</em></span></pre><p id="7b8b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，你有你的应用程序的不同部分，像模态对话框，下拉菜单，抽屉，等等，当对话框打开时，你想在那里阻止全局监听器。如果只有一个对话框，你可以手动将<code class="fe mt mu mv mj b">onKeyPress</code>添加到对话框中，这里有<code class="fe mt mu mv mj b">event.stopPropagation()</code>用于:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="6c11" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">export const Modal = ({ onClose }: ModalProps) =&gt; {<br/>  const onKeyPress = (event) =&gt; event.stopPropagation();<br/><br/>  return &lt;div onKeyPress={onKeyPress}&gt;...// dialog code&lt;/div&gt;;<br/>};</em></span></pre><p id="4cd9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是与<code class="fe mt mu mv mj b">onClick</code>日志记录相同的故事——如果你有多个组件，而你想看到这个逻辑，该怎么办？</p><p id="7e6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们在这里可以做的是，再次实现一个高阶组件。这一次，它将接受一个组件，将其包装在一个附带onKeyPress回调的div中，并返回未更改的组件。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="da2d" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">export const withSupressKeyPress = &lt;TProps extends unknown&gt;(Component: ComponentType&lt;TProps&gt;) =&gt; {<br/>  return (props: TProps) =&gt; {<br/>    const onKeyPress = (event) =&gt; {<br/>      event.stopPropagation();<br/>    };<br/><br/>    return (<br/>      &lt;div onKeyPress={onKeyPress}&gt;<br/>        &lt;Component {...props} /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  };<br/>};</em></span></pre><p id="68e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就是这样！现在我们可以在任何地方使用它:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="2b21" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const ModalWithSupressedKeyPress = withSupressKeyPress(Modal);<br/>const DropdownWithSupressedKeyPress = withSupressKeyPress(Dropdown);</em></span></pre><p id="63cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里要注意一件重要的事情:焦点管理。为了让上面的代码实际工作，您需要确保您的对话框类型组件在打开时将焦点移动到打开的部分。但这是一个关于焦点管理的完全不同的对话，也许下次吧。</p><p id="b07a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">出于示例的目的，我们可以在模式本身中手动包含自动聚焦:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="c3a5" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Modal = () =&gt; {<br/>  const ref = useRef&lt;HTMLDivElement&gt;();<br/><br/>  useEffect(() =&gt; {<br/>    // when modal is mounted, focus the element to which the ref is attached<br/>    if (ref.current) ref.current.focus();<br/>  }, []);<br/><br/>  // adding tabIndex and ref to the div, so now it's focusable<br/>  return &lt;div tabIndex={1} ref={ref}&gt;<br/>    &lt;!-- modal code --&gt;<br/>  &lt;/div&gt;<br/>}</em></span></pre><p id="6be7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在代码沙箱中使用它。</p><h1 id="1680" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">第三:上下文选择器</h1><p id="f8c5" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">高阶组件的最后一个非常有趣的用例:React上下文的类似选择器的功能。正如我们所知，当上下文值改变时，它将导致所有上下文消费者的重新呈现，而不管他们的状态的特定部分是否被改变。(如果你不知道，这里有一篇文章给你:<a class="ae mh" href="https://www.developerway.com/posts/how-to-write-performant-react-apps-with-context" rel="noopener ugc nofollow" target="_blank">如何用上下文写performant React应用</a>)。</p><p id="a5da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在进入高阶组件之前，让我们先实现一些上下文和表单。</p><p id="5c1d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将通过<code class="fe mt mu mv mj b">id</code>和<code class="fe mt mu mv mj b">name</code>以及API来改变这些:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="4824" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">type Context = {<br/>  id: string;<br/>  name: string;<br/>  setId: (val: string) =&gt; void;<br/>  setName: (val: string) =&gt; void;<br/>};<br/><br/>const defaultValue = {<br/>  id: 'FormId',<br/>  name: '',<br/>  setId: () =&gt; undefined,<br/>  setName: () =&gt; undefined,<br/>};<br/><br/>const FormContext = createContext&lt;Context&gt;(defaultValue);<br/><br/>export const useFormContext = () =&gt; useContext(FormContext);<br/><br/>export const FormProvider = ({ children }: { children: ReactNode }) =&gt; {<br/>  const [state, setState] = useState(defaultValue);<br/><br/>  const value = useMemo(() =&gt; {<br/>    return {<br/>      id: state.id,<br/>      name: state.name,<br/>      setId: (id: string) =&gt; setState({ ...state, id }),<br/>      setName: (name: string) =&gt; setState({ ...state, name }),<br/>    };<br/>  }, [state]);<br/><br/>  return &lt;FormContext.Provider value={value}&gt;{children}&lt;/FormContext.Provider&gt;;<br/>};</em></span></pre><p id="7905" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后是一些带有<code class="fe mt mu mv mj b">Name</code>和<code class="fe mt mu mv mj b">Countries</code>组件的表单</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="e46f" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Form = () =&gt; {<br/>  return (<br/>    &lt;form css={pageCss}&gt;<br/>      &lt;Name /&gt;<br/>      &lt;Countries /&gt;<br/>    &lt;/form&gt;<br/>  );<br/>};<br/><br/>export const Page = () =&gt; {<br/>  return (<br/>    &lt;FormProvider&gt;<br/>      &lt;Form /&gt;<br/>    &lt;/FormProvider&gt;<br/>  );<br/>};</em></span></pre><p id="5780" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe mt mu mv mj b">Name</code>组件中，我们将有一个输入来改变<code class="fe mt mu mv mj b">Context</code>的值，而<code class="fe mt mu mv mj b">Countries</code>只需使用表单的<code class="fe mt mu mv mj b">id</code>来获取国家列表(不会实现实际的获取，这对本例并不重要:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="9cb2" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Countries = () =&gt; {<br/>  // using only id from context here<br/>  const { id } = useFormContext();<br/><br/>  console.log("Countries re-render");<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;List on countries for form: {id}&lt;/h3&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;Australia&lt;/li&gt;<br/>        &lt;li&gt;USA&lt;/li&gt;<br/>        &lt;!-- etc --&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span><span id="6c71" class="mn ll in mj b gy nl mp l mq mr"><em class="ms">const Name = () =&gt; {<br/>  // using name and changing it here<br/>  const { name, setName } = useFormContext();<br/><br/>  return &lt;input onChange={(event) =&gt; setName(event.target.value)} value={name} /&gt;;<br/>};</em></span></pre><p id="487b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，每当我们在名称输入字段中键入内容时，我们将更新上下文值，这将导致重新呈现所有使用上下文的组件，包括国家。这不能通过将这个值提取到一个钩子中并对其进行内存化来解决:钩子总是会重新呈现(<a class="ae mh" href="https://www.developerway.com/posts/why-custom-react-hooks-could-destroy-your-app-performance" rel="noopener ugc nofollow" target="_blank">为什么自定义的react钩子会破坏你的应用性能</a>)。</p><p id="b468" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，如果这种行为引起了性能问题，还有其他方法来处理它，比如将渲染树的某些部分记忆化或者将上下文分成不同的提供者(参见描述这些技术的文章:<a class="ae mh" href="https://www.developerway.com/posts/how-to-write-performant-react-apps-with-context" rel="noopener ugc nofollow" target="_blank">如何使用上下文编写performant React应用程序</a>和<a class="ae mh" href="https://www.developerway.com/posts/how-to-write-performant-react-code" rel="noopener ugc nofollow" target="_blank">如何编写performant React代码:规则、模式、该做什么和不该做什么</a>)。</p><p id="e64e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是上述所有技术的一个大缺点是，它们不可共享，并且需要在个案的基础上实现。如果我们有一些类似select的功能，可以用来在任何组件中安全地提取这个<code class="fe mt mu mv mj b">id</code>值，而不需要在整个应用程序中进行重大的重构和<code class="fe mt mu mv mj b">useMemo</code>，这不是很好吗？</p><p id="e39a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有趣的是，我们可以用高阶组件实现这样的东西。这是因为组件有一个钩子没有给我们的东西:它们可以改变事物，阻止子组件的重复渲染。基本上，这会给我们想要的:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="93e9" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">export const withFormIdSelector = &lt;TProps extends unknown&gt;(<br/>  Component: ComponentType&lt;TProps &amp; { formId: string }&gt;<br/>) =&gt; {<br/>  const MemoisedComponent = React.memo(Component) as ComponentType&lt;<br/>    TProps &amp; { formId: string }<br/>  &gt;;<br/><br/>  return (props: TProps) =&gt; {<br/>    const { id } = useFormContext();<br/><br/>    return &lt;MemoisedComponent {...props} formId={id} /&gt;;<br/>  };<br/>};</em></span></pre><p id="da58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后我们就可以创建<code class="fe mt mu mv mj b">CountriesWithFormIdSelector</code>组件了:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="8dea" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">// formId prop here is injected by the higher-order component below<br/>const CountriesWithFormId = ({ formId }: { formId: string }) =&gt; {<br/>  console.log("Countries with selector re-render");<br/>  return (<br/>     &lt;-- code is the same as before --&gt;<br/>  );<br/>};<br/><br/>const CountriesWithFormIdSelector = withFormIdSelector(CountriesWithFormId);</em></span></pre><p id="f52e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">并在我们的表单中使用它:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="7861" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">const Form = () =&gt; {<br/>  return (<br/>    &lt;form css={pageCss}&gt;<br/>      &lt;Name /&gt;<br/>      &lt;CountriesWithFormIdSelector /&gt;<br/>    &lt;/form&gt;<br/>  );<br/>};</em></span></pre><p id="a50e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae mh" href="https://codesandbox.io/s/hocs-context-lwudbb?file=/src/page.tsx" rel="noopener ugc nofollow" target="_blank">在codesandbox </a>中查看。在输入时要特别注意控制台输出——CountriesWithFormIdSelector组件不会重新呈现！</p><h1 id="a7a6" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">通用反应上下文选择器</h1><p id="d11e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><code class="fe mt mu mv mj b">withFormIdSelector</code>很有趣，适用于基于上下文的小型应用程序。但是把它作为通用的东西不是很好吗？这样我们就不必为每个状态属性实现一个自定义选择器。</p><p id="5239" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当涉及到一些创造性的黑客技术时，没有问题！看看吧，选择器本身:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="fff3" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">export const withContextSelector = &lt;TProps extends unknown, TValue extends unknown&gt;(<br/>  Component: ComponentType&lt;TProps &amp; Record&lt;string, TValue&gt;&gt;,<br/>  selectors: Record&lt;string, (data: Context) =&gt; TValue&gt;,<br/>): ComponentType&lt;Record&lt;string, TValue&gt;&gt; =&gt; {<br/>  // memoising component generally for every prop<br/>  const MemoisedComponent = React.memo(Component) as ComponentType&lt;Record&lt;string, TValue&gt;&gt;;<br/><br/>  return (props: TProps &amp; Record&lt;string, TValue&gt;) =&gt; {<br/>    // extracting everything from context<br/>    const data = useFormContext();<br/><br/>    // mapping keys that are coming from "selectors" argument<br/>    // to data from context<br/>    const contextProps = Object.keys(selectors).reduce((acc, key) =&gt; {<br/>      acc[key] = selectors[key](data);<br/><br/>      return acc;<br/>    }, {});<br/><br/>    // spreading all props to the memoised component<br/>    return &lt;MemoisedComponent {...props} {...contextProps} /&gt;;<br/>  };<br/>};</em></span></pre><p id="b7bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后将它与组件一起使用:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="2613" class="mn ll in mj b gy mo mp l mq mr"><em class="ms">// props are injected by the higher order component below<br/>const CountriesWithFormId = ({ formId, countryName }: { formId: string; countryName: string }) =&gt; {<br/>  console.log('Countries with selector re-render');<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;List of countries for form: {formId}&lt;/h3&gt;<br/>      Selected country: {countryName}<br/>      &lt;ul&gt;<br/>        &lt;li&gt;Australia&lt;/li&gt;<br/>        &lt;li&gt;USA&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>// mapping props to selector functions<br/>const CountriesWithFormIdSelector = withContextSelector(CountriesWithFormId, {<br/>  formId: (data) =&gt; data.id,<br/>  countryName: (data) =&gt; data.country,<br/>});</em></span></pre><p id="32c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就是这样！我们基本上在上下文上实现了mini-Redux，即使有适当的<code class="fe mt mu mv mj b">mapStateToProps</code>功能🙂在<a class="ae mh" href="https://codesandbox.io/s/hocs-context-generic-selector-wdijzp?file=/src/page.tsx" rel="noopener ugc nofollow" target="_blank">的代码沙箱</a>中检查一下。</p><p id="b0a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天到此为止！希望高阶组件现在不是一些可怕的传统小妖精，而是一些你甚至可以在现代应用中很好利用的东西。让我们重新定义这些使用情形:</p><ul class=""><li id="89ef" class="mx my in kq b kr ks ku kv kx mz lb na lf nb lj nc nd ne nf bi translated">用附加功能增强回调和反应生命周期事件，如发送日志或分析事件</li><li id="3a5f" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated">拦截DOM事件，比如在模式对话框打开时阻止全局快捷键</li><li id="21ac" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated">提取一段上下文而不导致组件中不必要的重新呈现</li></ul><p id="0f17" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">愿和平与爱与你同在，✌🏼</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="cf4e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ms">最初发表于</em><a class="ae mh" href="https://www.developerway.com/posts/higher-order-components-in-react-hooks-era" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">。网站上有更多这样的文章</em>😉</p><p id="27d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae mh" href="https://www.developerway.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">订阅简讯</em> </a>，<em class="ms"> </em> <a class="ae mh" href="https://www.linkedin.com/in/adevnadia/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">在LinkedIn </em> </a> <em class="ms">或</em> <a class="ae mh" href="https://twitter.com/adevnadia" rel="noopener ugc nofollow" target="_blank"> <em class="ms">上关注Twitter </em> </a> <em class="ms">以便在下一篇文章出来时立即获得通知。</em></p><p id="7ee8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ms">更多内容请看</em><a class="ae mh" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ms">plain English . io</em></strong></a><em class="ms">。报名参加我们的</em> <a class="ae mh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ms">免费每周简讯</em> </strong> </a> <em class="ms">。关注我们</em><a class="ae mh" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ms">Twitter</em></strong></a><em class="ms">和</em><a class="ae mh" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ms">LinkedIn</em></strong></a><em class="ms">。加入我们的</em> <a class="ae mh" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ms">社区不和谐</em> </strong> </a> <em class="ms">。</em></p></div></div>    
</body>
</html>