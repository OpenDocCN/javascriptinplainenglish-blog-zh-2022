# 何时使用 React.memo() —何时不使用

> 原文：<https://javascript.plainenglish.io/when-and-when-not-to-use-react-memo-e050d3cb1ffc?source=collection_archive---------5----------------------->

![](img/db4a902b8d1ad6452b1e7a5b2ec5953c.png)

在计算中，记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。

*React . memo()*—React 16 . 8 . 0 中引入，类似于类组件的 *PureComponent* ，提供了一种帮助我们控制组件何时重新渲染的方法。通过限制 React 组件的重新呈现，UI 性能得到了提高。因此，通过快速响应的 UI、平滑导航和无缝加载，增强了用户体验和与系统的交互。

由于 *React.memo()* 是一个高阶组件，它可以围绕常规 React 功能组件包装自己。当 React 组件用 *React.memo()* 包装时，React 呈现组件并记忆结果。如果组件的属性在下一次渲染之前是相同的，那么 React 将重用已记忆的结果。通过这样做，可以跳过重新渲染，React 不会更新 DOM，从而实现性能提升。通过 *PureComponent 可以在类组件中实现相同的功能。*

那么，在哪些情况下我们应该使用，或者避免使用 React.memo()？

## 何时使用:

1.  当我们期望一个功能组件经常会在第一次渲染之后进行渲染，通常使用相同的道具。发生这种情况的情况是，父组件强制子组件进行呈现。在这种情况下，在组件上应用记忆是合适的。
2.  当我们拥有**纯功能组件**时。给定相同的道具，这样的组件将保持不变—总是呈现相同的输出。
3.  当我们的组件很大，并且包含大量的 UI 元素，以至于重新呈现会导致用户可察觉的响应延迟时。

## 何时不使用:

1.  我们应该避免使用 *React.memo()* 的第一个也是最明显的情况是当我们无法量化从中获得的性能收益时。如果我们的组件重新渲染的计算时间——有和没有这个高阶组件——可以忽略或不存在，那么使用 *React.memo()* 将是无用的。
2.  在某些情况下，我们希望一个组件用不同的道具重新渲染。默认情况下，React.memo() 执行属性相等检查，以确定组件的渲染属性是否相等。只有前一个属性等于后一个属性，等式才会返回 true。如果我们的组件使用不同的道具重新渲染，那么这个等式检查将返回 false，强制 React 执行上一个和下一个道具的差异。由于这种无用的道具比较，以及 React 将总是在每个渲染上执行 2 个任务的事实，这样一个“易变”组件不应该被包装在 *React.memo()* 中。这样不仅没有性能增益，还会损害性能！
3.  尽管在 *React.memo()* 中包装类组件是可能的，但它被认为是(也确实如此)不好的实践，并且是非常不鼓励的。相反，在处理类组件时，扩展一个 PureComponent 类更可取，也是一种更干净的处理内存化的方式。

*React.memo()* 的用例及回避情况包括但不限于上述实例。

严格使用 *React.memo()* 作为具有经常重新渲染的组件的应用程序的性能提升。但是，请记住，如果状态改变，React 组件将总是重新呈现——不管组件是否被包装在 *React.memo()* 中。

*更多内容看* [***说白了就是***](http://plainenglish.io/) *。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。在我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *获得独家获取写作机会和建议。*