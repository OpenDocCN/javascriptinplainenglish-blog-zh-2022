<html>
<head>
<title>Stop using JavaScript Timers for that!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要再用JavaScript定时器了！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-using-javascript-timers-for-that-2e5ce83cb99c?source=collection_archive---------5-----------------------#2022-08-22">https://javascript.plainenglish.io/stop-using-javascript-timers-for-that-2e5ce83cb99c?source=collection_archive---------5-----------------------#2022-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a675" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这里有JavaScript中定时器的五种反模式以及如何正确使用。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/c1f6179a06e70319304629f07b938757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a2Pvqs1g3ZOSdQsT"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5330" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现代web开发面临许多来自异步方面的挑战。在JavaScript中，我们倾向于使用定时器来处理其中一些。我说的计时器是指setTimeout和setInterval。然而，大多数时候，这并不是一个好主意，因为定时器不是高性能的，可能不会按照我们希望的方式运行。在本文中，我将解释一些定时器的行为，并描述定时器是反模式的场景以及应该首选哪些解决方案。</p><p id="ace5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一般来说，我们可以说定时器是用来轮询信息的。轮询是获取新数据的两个编程概念之一。使用轮询，我们不断地询问数据源是否有特定值的更新。另一方面，推送概念会在我们关心的事情发生变化时通知我们，然后我们可以对其做出反应。如果您不熟悉这些技术，您可能会认为推送是一个我们可以监听的事件，而轮询是一个循环，只有当数据源发生变化时才会返回值。推送通常优于轮询。</p><h2 id="f11a" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">链式计时器</h2><p id="d760" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">在JavaScript中链接计时器是可能的。使用定时器时，理解链接的概念是很重要的。看一下下面的例子:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="434d" class="lt lu iq ms b gy mw mx l my mz">let i = 0;<br/>setInterval(() =&gt; console.log(++i), 100);</span></pre><p id="145d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将记录1 2 3 4 5 …等等。输出将<em class="na">保持在顺序</em>中，因为在我们的定时器中声明的函数的执行是以正确的顺序链接的，并且我们可以依赖于被一个接一个执行的链。虽然，我们不知道两次处决之间的时间。我们只知道至少是100ms。但是正如我们将要学习的，上面的例子甚至可以花五分钟(！)直到它被执行——即使我们没有在代码中做任何其他事情(例如，即使我们没有将一个长时间运行的操作链接到计时器)。</p><p id="35bd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">setTimeout也是如此:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="4ac7" class="lt lu iq ms b gy mw mx l my mz">let i = 0;<br/>const myTimer = () =&gt; {<br/>  setTimeout(() =&gt; {<br/>    console.log(++i);<br/>    myTimer(); // &lt;- chain another timer<br/>  }, 100)<br/>}</span><span id="da74" class="lt lu iq ms b gy nb mx l my mz">myTimer();</span></pre><p id="5a85" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将产生相同的输出。</p><h2 id="ccdc" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">JavaScript计时器和性能</h2><p id="08d2" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">计时器会在每次运行时唤醒CPU。setTimeout和setInterval本质上不是CPU密集型的，但是它们运行的函数可能是CPU密集型的。因此，使用计时器可能是个坏主意，这取决于你希望计时器运行的频率。根据经验，每秒多次运行你的定时器可能不是一个好主意，尤其是在低端移动设备上。此外，不要依赖你的计时器被及时执行。特别是当你的用户离开时，你不能依赖你的定时器在给定的时间间隔内执行。浏览器会调节计时器以节省能量。</p><h2 id="02a5" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">JavaScript计时器和节流</h2><p id="18d0" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">对于不同的浏览器，以下内容可能会有不同的处理方式。然而，在这一章中，我们将只关注Chrome。差异应该很小，可能主要适用于“可见页面”的定义通常，隐藏页面是最小化的或者不在活动标签中的页面。但是浏览器可能决定当一个页面的内容完全不可见时，它也是隐藏的。您可以使用页面可见性API来检查何时触发了可见性更改(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Page _ Visibility _ API</a>)。</p><p id="580a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Chrome决定何时以及如何在不同阶段调节计时器:</p><p id="c35d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">第一阶段:最小节流</strong></p><p id="2cfa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当满足以下条件之一时，将应用最小限制:</p><ul class=""><li id="f5fb" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">页面可见。</li><li id="36ab" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">页面在过去30秒内“发出噪音”。在Chrome中，当这种情况发生时，你的标签会在标题旁边显示音频图标。静音音频不算。</li></ul><p id="11e0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">除非超时少于4毫秒，并且100个或更多计时器被链接，否则计时器不会被限制。在这种情况下，超时设置为4毫秒。</p><p id="a9f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意:Chrome中100个链式计时器的限制是新的。以前，只有五个计时器。</p><p id="f347" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">第二步:介质节流</strong></p><p id="bf6d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当最小限制不适用并且满足以下任一条件时，浏览器会这样做:</p><ul class=""><li id="7cad" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">链计数小于100。</li><li id="3563" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">页面隐藏了不到五分钟。</li><li id="ebb0" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">页面使用WebRTC。这意味着存在打开的RTCPeerConnection或实时MediaStreamTrack。</li></ul><p id="8784" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">链中的计时器将每秒检查一次。因此，不同链中可能会有重叠的计时器。这些函数将被批处理，然后执行。</p><p id="2747" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">第三步:密集节流</strong></p><p id="9003" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果最小或中等限制都不适用，并且以下所有<strong class="kz ir"><em class="na"/></strong>条件均为真，则密集限制将到位:</p><ul class=""><li id="cfd2" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">页面已隐藏超过5分钟。</li><li id="dd51" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">链计数大于100。</li><li id="fd39" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">该页面至少有30秒没有播放音频。</li><li id="1ac2" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">没有使用WebRTC。</li></ul><p id="2c46" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这种情况下，浏览器将每分钟检查一次计时器。不同组的重叠计时器将被批量执行。</p><h2 id="593e" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">JavaScript中带有计时器的常见反模式</h2><p id="1c3d" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">既然我们已经弄清楚了一些关于计时器的事情以及它们可能如何被抑制，那么让我们来看看一些反模式以及如何避免它们。</p><p id="f90d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">检查一个元素是否在视窗中</strong></p><p id="2103" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以使用IntersectionObserver来检测当前视口中的元素(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Intersection _ Observer _ API</a>)。这将是一个触发的事件，而不是轮询，您可以对其做出反应。</p><p id="8673" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">跨计时器的交叉观测器的常见用例有:</p><ul class=""><li id="b1b1" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">页面滚动时延迟加载内容(还要考虑图像的loading属性)。</li><li id="ff7e" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">当元素进入视图时运行任务(例如，应用样式)</li></ul><p id="6957" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在上面的文章中提到了更多的用例，但是你以前可能不会使用定时器来解决这些问题。</p><p id="f3c6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">检查一个元素是否改变了它的大小</strong></p><p id="9a26" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">与前面的例子类似，我们可以利用ResizeObserver来检查元素是否改变了维度(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/resize observer</a>)。</p><p id="3d7b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">ResizeObservers的常见用例有:</p><ul class=""><li id="5642" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">实现每个元素的媒体查询来强制定义断点和样式。</li><li id="9ec2" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">保持滚动位置:当您不想混淆用户并保持他们在列表中的当前滚动位置时，即使项目样式正在改变(由于媒体查询)，您也可以利用ResizeObserver来调整滚动位置。</li></ul><p id="71ce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">检查DOM是否已更改(添加/删除元素)</strong></p><p id="2ff8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是我时常看到的一个反模式。应该避免使用计时器来检查DOM中是否存在某个元素。</p><p id="1f6d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">相反，您可以使用mutation observer(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/mutation observer</a>)作为推送替代。如果您正在处理的是一个定制元素，您可能能够使用定制元素的生命周期事件(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/Web _ Components/Using _ custom _ elements # Using _ the _ life cycle _ callbacks</a>)。</p><p id="e0eb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">变异观测器的常见用例有:</p><ul class=""><li id="198c" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">检查是否在DOM中添加或删除了元素。</li></ul><p id="32d2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，要小心！许多像React这样的库可以用他们的工具解决这个问题。因此，当您不使用普通JavaScript时，您可能不需要MutationObserver。</p><p id="76c4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">观察一般状态</strong></p><p id="3375" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不要使用setInterval或setTimeout来观察状态。例如，不要使用setInterval来检查变量的值是否已经更改。有更好的方法来解决这样的问题。例如:</p><ul class=""><li id="75d3" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">把你想观察的数据包装在一个代理中(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Proxy</a>)。</li><li id="5ec1" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">使用承诺。</li></ul><p id="4c99" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">一般动画</strong></p><p id="26b4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">动画不应该不必要地唤醒CPU。因此你不应该使用定时器来触发动画。更好地创建动画使用这些:</p><ul class=""><li id="7e78" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">CSS动画</li><li id="9ff7" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">网页动画API(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Web _ Animations _ API</a>)</li></ul><p id="af24" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">CSS动画和动画API将确保动画只在设备可以显示的帧上计算。使用JS中的定时器，你可能会在设备不能画出的中间帧中计算函数。</p><p id="cafe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">除此之外，使用API预先声明的动画可以由浏览器进一步优化。例如自动合成。</p><p id="340c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你的动画帧速率很低，你仍然可以使用定时器。为了确保您只在设备可以渲染的帧上绘制，您仍然应该将计时器解决方案与<code class="fe nq nr ns ms b">requestAnimationFrame</code>结合使用。</p><p id="d88e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">来自服务器的轮询信息</strong></p><p id="e3fb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">除了从服务器轮询信息(例如，获取setInterval以检查新数据)，您还可以使用以下方法之一(顺序是任意的):</p><ul class=""><li id="ac92" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">Web sockets<br/>T10】https://developer . Mozilla . org/en-US/docs/Web/API/Web sockets _ API</li><li id="d908" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">SSE<br/><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/event source</a></li><li id="2d31" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">推送消息<br/><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/Push_API</a></li><li id="d7bc" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">获取流<br/><a class="ae kw" href="https://developer.chrome.com/articles/fetch-streaming-requests/#previously-on-the-exciting-adventures-of-fetch-streams" rel="noopener ugc nofollow" target="_blank">https://developer . chrome . com/articles/fetch-streaming-requests/# previous-on-the-exciting-adventures-of-fetch-Streams</a></li><li id="024e" class="nc nd iq kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">https://grpc.io/ RPC<br/>T22</li></ul><p id="878b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最初的文章和想法来自杰克·阿奇博尔德，最初写在这里:<a class="ae kw" href="https://developer.chrome.com/blog/timer-throttling-in-chrome-88/" rel="noopener ugc nofollow" target="_blank">https://developer . chrome . com/blog/timer-throttling-in-chrome-88/</a></p><p id="432a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我更新了一些信息，因为这篇文章已经有点旧了。请注意，本文提到了触发节流的链限制为5。这不再适用于Chrome(自2022年8月2日起，Chrome v104)。</p><p id="a6f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就这些了，伙计们！</p><p id="8b68" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你喜欢阅读更多这样的文章，请随意留下评论或回复——这样，我就可以看到每篇文章获得了多少关注，以及我接下来应该写些什么。</p><p id="e0ae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">非常感谢！</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="5b4f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="na">更多内容请看</em><a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="na">plain English . io</em></strong></a><em class="na">。报名参加我们的</em> <a class="ae kw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="na">免费周报</em> </strong> </a> <em class="na">。关注我们关于</em><a class="ae kw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="na">Twitter</em></strong></a><a class="ae kw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="na">LinkedIn</em></strong></a><em class="na"/><a class="ae kw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="na">YouTube</em></strong></a><em class="na"/><a class="ae kw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="na">不和</em> </strong> </a> <em class="na">。</em></p></div></div>    
</body>
</html>