<html>
<head>
<title>Tagged Template Literals — How Tools Like Styled Components Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">标记的模板文字——像样式化组件这样的工具是如何工作的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tagged-template-literals-how-tools-like-styled-components-work-81b26647e5ab?source=collection_archive---------4-----------------------#2022-11-10">https://javascript.plainenglish.io/tagged-template-literals-how-tools-like-styled-components-work-81b26647e5ab?source=collection_archive---------4-----------------------#2022-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="de36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有没有想过像 <code class="fe km kn ko kp b"><em class="kl">styled</em></code> <em class="kl">这样的语法糖是如何神奇地工作的？让我们使用Javascript中的标记模板字符串重新创建这个功能。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/81306def0c3b7dad56993b4a03309854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbzvmUTd6oie6g6ZvycZ0g.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Styled Components and other libraries made template tags quite popular.</figcaption></figure><p id="c373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你使用了像<a class="ae lg" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式组件</a>或者<a class="ae lg" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> graphql </a>这样的工具，你很可能会遇到带标签的模板文字。ES6引入的新Javascript特性。</p><p id="c4d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在样式化组件中，模板字符串允许您像这样神奇地创建组件:</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="a9cc" class="ll lm iq kp b gy ln lo l lp lq">const Title = styled.h1`<br/>  font-size: ${props =&gt; props.theme.sizes.lg};<br/>  text-align: center;<br/>  color: palevioletred;<br/>`;</span></pre><p id="9ab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本例中，<code class="fe km kn ko kp b">styled.h1</code>是<em class="kl">模板函数</em>或<em class="kl">标签</em>。后面的字符串表示实际的模板。我们称之为<em class="kl">模板串</em>。结合这两部分，我们得到了神奇的🪄</p><p id="fcb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先来看看模板字符串。它使用支持字符串插值的反斜线语法。因此，我们可以写…</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="d8aa" class="ll lm iq kp b gy ln lo l lp lq">const output = `My name is ${name}.`;</span></pre><p id="03ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…并动态填充<code class="fe km kn ko kp b">name</code>值。</p><p id="40d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模板函数<code class="fe km kn ko kp b">styled.h1</code>用于标记字符串，因此命名为标记模板文字。它允许我们告诉引擎应该如何填充和构造带标签的字符串。</p><p id="1d74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给定打印<code class="fe km kn ko kp b">My name is ${name}</code>的简单例子，浏览器通常会将<code class="fe km kn ko kp b">name</code>的当前值插入字符串。</p><p id="262b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是也许我们想用绳子做些不同的事情？通过对字符串运行模板函数，我们可以做到这一点，并控制输出的外观。</p><p id="ab23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模板函数接收关于模板字符串(它的部分和变量)的所有信息，无论我们从函数返回什么都将是我们的<code class="fe km kn ko kp b">output</code>。</p><h1 id="bded" class="lr lm iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">了解模板功能</h1><p id="b3f1" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在我们尝试重新构建自己的<code class="fe km kn ko kp b">styled</code>模板函数之前，让我们先了解一下这些函数是如何工作的。</p><p id="9c91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面这个简单的例子中，我们使用<code class="fe km kn ko kp b">introduce</code>标签打印出一个简短的介绍。</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="c563" class="ll lm iq kp b gy ln lo l lp lq">function introduce(strings, name, food) {<br/>  // construct and return string<br/>}</span><span id="ff1b" class="ll lm iq kp b gy mt lo l lp lq">const name = 'Nina';<br/>const food = '🍕';<br/>const output = introduce`I am ${name}. I like ${food}.`;</span></pre><p id="006a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当对模板字符串运行函数时，我们通过参数接收所有需要的细节。</p><p id="5582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">strings</code>包含一个字符串数组，本质上是动态变量之间的所有静态部分。在我们的例子中，它是一个包含3项的数组:<code class="fe km kn ko kp b">I am</code>、<code class="fe km kn ko kp b">. I like</code>和<code class="fe km kn ko kp b">.</code>。</p><p id="b1cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有后续参数都是我们的插值变量，<code class="fe km kn ko kp b">name</code>和<code class="fe km kn ko kp b">food</code>的值。</p><p id="e87f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用ES6 rest操作符，我们可以像这样将这些后续参数批处理在一起:</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="b19f" class="ll lm iq kp b gy ln lo l lp lq">function introduce(strings, ...args) {<br/>  // construct and return string<br/>}</span></pre><p id="2b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以使用不仅限于两个值的模板。</p><h1 id="4af6" class="lr lm iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">构建我们自己的“风格化”标签</h1><p id="9002" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">知道了模板函数通常是如何工作的，让我们回到最初的例子:<code class="fe km kn ko kp b">styled</code>标签。</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="a29d" class="ll lm iq kp b gy ln lo l lp lq">const Title = styled.h1`<br/>  font-size: ${props =&gt; props.theme.sizes.lg};<br/>  text-align: center;<br/>  color: palevioletred;<br/>`;</span></pre><p id="c1de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在想要返回一个名为<code class="fe km kn ko kp b">Title</code>的React组件，而不是返回一个简单的字符串。该组件应该使用我们在模板字符串中提供的样式呈现一个HTML标题元素。</p><p id="3dc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于样式，我们使用了在模板字符串中访问的主题。因此，<code class="fe km kn ko kp b">Title</code>组件应该尊重我们通过主题注入的字体大小。</p><p id="802d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管这看起来很复杂，但实现起来相当简单！</p><p id="fe0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们考虑一些先决条件:</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="d3e8" class="ll lm iq kp b gy ln lo l lp lq">// This acts as our theme provider<br/>const props = {<br/>  theme: {<br/>    sizes: {<br/>      xl: '2rem',<br/>      lg: '1.5rem',<br/>      md: '1rem',<br/>      xs: '0.75rem',<br/>    },<br/>  },<br/>};</span><span id="6821" class="ll lm iq kp b gy mt lo l lp lq">// This will be our template function<br/>function h1(strings, ...args) {<br/>  // Do something<br/>}</span><span id="b26f" class="ll lm iq kp b gy mt lo l lp lq">const styled = { h1 };</span><span id="ee87" class="ll lm iq kp b gy mt lo l lp lq">// This will be our styled component<br/>const Title = styled.h1`<br/>  font-size: ${props =&gt; props.theme.sizes.lg};<br/>  text-align: center;<br/>  color: palevioletred;<br/>`;</span></pre><p id="30a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，我们假设我们可以访问一个全局的<code class="fe km kn ko kp b">props</code>对象，它就像是我们的主题提供者。</p><p id="2187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的<code class="fe km kn ko kp b">props</code>对象下面，我们定义了我们的<code class="fe km kn ko kp b">h1</code>模板函数。为了让它看起来更像样式化组件，我将函数包装在一个名为<code class="fe km kn ko kp b">styled</code>的对象中，然后我们用它来构建我们的<code class="fe km kn ko kp b">Title</code>组件。</p><p id="4a59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们仔细看看<code class="fe km kn ko kp b">h1</code>功能及其使用方式:</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="a3aa" class="ll lm iq kp b gy ln lo l lp lq">function h1(strings, ...args) {<br/>  // Do something<br/>}</span><span id="1d7f" class="ll lm iq kp b gy mt lo l lp lq">const Title = styled.h1`<br/>  font-size: ${props =&gt; props.theme.sizes.lg};<br/>  text-align: center;<br/>  color: palevioletred;<br/>`;</span></pre><p id="69c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回想一下我们之前所学的，<code class="fe km kn ko kp b">strings</code>参数包含了我们模板的所有静态字符串部分。在这种情况下，它只有两个项目:<code class="fe km kn ko kp b">font-size:</code>和<code class="fe km kn ko kp b">; text-align: center; …</code></p><p id="f9bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">args</code>包含插值。请注意，在这个例子中，我们实际上是在插值函数，而不只是像以前那样插值字符串。它的工作原理是一样的，但是提供了更多的可能性，我们马上就会看到！</p><p id="fe1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要创建输出这种样式化组件的标记模板文本，我们需要做两件事:</p><ol class=""><li id="b0c0" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">基于所提供的模板字符串生成基于主题的样式</li><li id="c66f" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">创建并返回具有这些样式的React组件</li></ol><p id="d714" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们就这么做，从第一步开始。</p><h1 id="bba6" class="lr lm iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">生成基于主题的样式</h1><p id="9760" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在第一步中，我们生成样式，稍后将应用于组件。现在，我们可以将样式输出为简单的CSS字符串，同样输出为模板字符串中的当前格式。</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="c533" class="ll lm iq kp b gy ln lo l lp lq">const props = {<br/>  theme: {<br/>    sizes: {<br/>      xl: '2rem',<br/>      lg: '1.5rem',<br/>      md: '1rem',<br/>      xs: '0.75rem',<br/>    },<br/>  },<br/>};</span><span id="e5fc" class="ll lm iq kp b gy mt lo l lp lq">function h1(strings, ...args) {<br/>  let str = '';</span><span id="4b8f" class="ll lm iq kp b gy mt lo l lp lq">  strings.forEach((string, i) =&gt; {<br/>    str += string + (args[i] ? args[i](props) : '');<br/>  });</span><span id="209d" class="ll lm iq kp b gy mt lo l lp lq">  return str;<br/>}</span><span id="06e2" class="ll lm iq kp b gy mt lo l lp lq">const styles = h1`<br/>  font-size: ${props =&gt; props.theme.sizes.lg};<br/>  text-align: center;<br/>  color: palevioletred;<br/>`;</span></pre><p id="fa03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的函数<code class="fe km kn ko kp b">h1</code>中，我们遍历模板的静态字符串部分，并递增地连接它们。通过使用索引<code class="fe km kn ko kp b">i</code>，我们可以检查每个部分是否有相关的插值。</p><p id="a7e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在将<code class="fe km kn ko kp b">font-size:</code>连接到初始空字符串之后，我们检查在索引0处是否存在插值。的确有！我们提供的函数定义了基于主题的字体大小。</p><p id="5501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe km kn ko kp b">args[i]</code>包含了我们注入的值<code class="fe km kn ko kp b">(props) =&gt; props.theme.sizes.lg</code>，我们可以用全局<code class="fe km kn ko kp b">props</code>对象调用这个函数并接收回字体大小。完美！</p><p id="7305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们从模板函数中返回<code class="fe km kn ko kp b">str</code>。它包含一个CSS字符串，如下所示:</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="015b" class="ll lm iq kp b gy ln lo l lp lq">font-size: 1.5rem;<br/>text-align: center;<br/>color: palevioletred;</span></pre><h1 id="053c" class="lr lm iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">返回样式化的React组件</h1><p id="54f2" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">为了完全模拟样式化的组件，我们现在想要返回一个样式化的React组件，而不是CSS字符串。</p><p id="c867" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过使用一个小的助手函数<code class="fe km kn ko kp b">css2obj</code>很容易地做到这一点，该函数将CSS字符串转换成可以应用于React组件的CSS对象。这并不完全是样式化组件的工作方式，但是目前它确实可以工作。有兴趣可以在这里查看实现<a class="ae lg" href="https://gist.github.com/konstantinmuenster/dd391a78b167972f03e198198fe6b5ae" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="252a" class="ll lm iq kp b gy ln lo l lp lq">function h1(strings, ...args) {<br/>  let str = '';</span><span id="f9ba" class="ll lm iq kp b gy mt lo l lp lq">  strings.forEach((string, i) =&gt; {<br/>    str += string + (args[i] ? args[i](props) : '');<br/>  });</span><span id="4e42" class="ll lm iq kp b gy mt lo l lp lq">  return React.createElement('h1', {<br/>    style: css2obj(str),<br/>  });<br/>}</span></pre><p id="c7bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们可以修改我们的<code class="fe km kn ko kp b">h1</code>实现，这样我们就不会返回CSS字符串，而是创建一个具有正确标题类型和生成的样式对象的React元素。</p><p id="8458" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我们现在可以使用这个带标签的模板文字来创建令人惊叹的标题，就像这样简单:</p><pre class="kr ks kt ku gt lh kp li lj aw lk bi"><span id="d704" class="ll lm iq kp b gy ln lo l lp lq">const Title = styled.h1`<br/>  font-size: ${props =&gt; props.theme.sizes.lg};<br/>  text-align: center;<br/>  color: palevioletred;<br/>`;</span><span id="9cdf" class="ll lm iq kp b gy mt lo l lp lq">export const MyComponent = () =&gt; {<br/>  return &lt;Title&gt;My Heading&lt;/Title&gt;;<br/>};</span></pre></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="d28a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，实际上，样式化组件比这个简单的例子隐藏了更多的复杂性。尽管如此，我希望我们揭示了一点标签模板文字提供的魔力。</p><p id="db56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，这一直是看起来(听起来)比实际复杂得多的事情之一。</p><p id="b9b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以你要记住:</p><p id="2dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">带标签的模板文字使您能够定义模板字符串应该如何构造和返回。</strong></p><p id="11ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">又一个很好的工具带技术！如果你感兴趣，你可以在这个<a class="ae lg" href="https://codesandbox.io/s/styled-components-tagged-template-literal-article-dbiyd9" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>中找到完整的例子。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="174e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章最初发表于<a class="ae lg" href="https://konstantin.digital/blog" rel="noopener ugc nofollow" target="_blank">konstantin.digital/blog</a>。我每月写一篇关于React的web和产品开发以及如何成为更好的开发人员的文章。</p><p id="fa79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">更多内容请看</em><a class="ae lg" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">plain English . io</em></strong></a><em class="kl">。报名参加我们的</em> <a class="ae lg" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kl">免费周报</em> </strong> </a> <em class="kl">。关注我们关于</em><a class="ae lg" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">Twitter</em></strong></a><a class="ae lg" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">LinkedIn</em></strong></a><em class="kl"/><a class="ae lg" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">YouTube</em></strong></a><em class="kl"/><a class="ae lg" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">不和</em> </strong> </a> <em class="kl">。对增长黑客感兴趣？检查</em> <a class="ae lg" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kl">电路</em> </strong> </a> <em class="kl">。</em></p></div></div>    
</body>
</html>