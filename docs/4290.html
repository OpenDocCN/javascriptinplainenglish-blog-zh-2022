<html>
<head>
<title>Subject RxJS — Angular Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主题RxJS —角度示例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/subject-rxjs-angular-example-b35332482cd?source=collection_archive---------4-----------------------#2022-11-17">https://javascript.plainenglish.io/subject-rxjs-angular-example-b35332482cd?source=collection_archive---------4-----------------------#2022-11-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="98ee" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/rxjs-39bc4f4110ec" rel="noopener"> RXJS </a>，<a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">角形</a></h2><div class=""/><div class=""><h2 id="978e" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">这个例子将展示如何在一个简单的角度应用程序中使用RxJS主题</h2></div><p id="6c2a" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">使用Angular的一个好处是它基于组件的UI构建方法。许多采用基于组件方法的框架和库都是如此。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="9f9e" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">然而，基于组件的方法并不是免费的，它也伴随着复杂性。例如，组件可能需要相互通信。</p><p id="c917" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">有几种情况下组件需要相互通信:</p><ul class=""><li id="f618" class="lo lp in kn b ko kp kr ks ku lq ky lr lc ls lg lt lu lv lw bi translated"><strong class="kn ix">父/子</strong> —孩子可能在DOM树的深处</li><li id="8947" class="lo lp in kn b ko lx kr ly ku lz ky ma lc mb lg lt lu lv lw bi translated"><strong class="kn ix">仪表盘</strong> —许多兄弟姐妹甚至不认识对方，但必须交流</li><li id="1ad9" class="lo lp in kn b ko lx kr ly ku lz ky ma lc mb lg lt lu lv lw bi translated"><strong class="kn ix">组件列表</strong> —组件被有条件地呈现，并且可能需要在不知道彼此的情况下相互通信</li></ul><p id="4197" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">如果场景是一个简单的父/子结构，我们可能会选择<code class="fe mc md me mf b">@<a class="ae mg" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">Input</a>()</code>和<code class="fe mc md me mf b">@<a class="ae mg" href="https://angular.io/api/core/Output" rel="noopener ugc nofollow" target="_blank">Output</a>()</code>装饰器。然而，这很快就会变得疯狂。尤其是当父组件和子组件之间有多个组件时。</p><p id="2fc1" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">当应用变得复杂时，状态管理才是真正的问题。在这种情况下，NgRx或者它的轻量级版本ComponentStore应该是维护单一事实来源和组件间通信的首选方式。</p><div class="mh mi gp gr mj mk"><a href="https://levelup.gitconnected.com/an-introduction-to-ngrx-2d849c0baac4" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ix gy z fp mp fr fs mq fu fw iw bi translated">NgRx简介</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">NgRx是一个使用Redux模式的状态管理库。通过构建应用程序，了解使用它的原因、时间和方法。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my mz mk"/></div></div></a></div><p id="eedf" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">然而，有时候，包括状态管理在内的解决方案有些矫枉过正。</p><p id="ba76" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">当你处于两者之间时，服务可能是一个不错的选择。在服务中使用主题是一种很好的模式</p><ul class=""><li id="a079" class="lo lp in kn b ko kp kr ks ku lq ky lr lc ls lg lt lu lv lw bi translated">向多个组件发送数据，</li><li id="7ed0" class="lo lp in kn b ko lx kr ly ku lz ky ma lc mb lg lt lu lv lw bi translated">从多个组件接收数据，</li><li id="8737" class="lo lp in kn b ko lx kr ly ku lz ky ma lc mb lg lt lu lv lw bi translated">相应地更新每个组件</li></ul><p id="2675" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">这就是受试者来拯救的地方。</p><p id="5980" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">一般来说，主题被放在一个服务中，当<code class="fe mc md me mf b">@<a class="ae mg" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">Input</a>()</code>和<code class="fe mc md me mf b">@<a class="ae mg" href="https://angular.io/api/core/Output" rel="noopener ugc nofollow" target="_blank">Output</a>()</code>装饰者不足，但是状态管理有点太多的时候可以使用。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/9005e433f177695f8de5f46e617eb879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxXv1JuCWI3mC1IiZIKEag.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Use the Subject in service pattern when the complexity is medium</figcaption></figure><h1 id="4d43" class="nk nl in bd nm nn no np nq nr ns nt nu kc nv kd nw kf nx kg ny ki nz kj oa ob bi translated">RxJS主题概述</h1><p id="30e3" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">主体是一种特殊类型的可观察对象。它是可观察的，同时也是观察者。</p><p id="6e1b" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">将多播值提交给许多观察者。这意味着，与普通的可观测物不同，它们向所有观测者发出相同的值。</p><p id="81fc" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">值得一提的是<a class="ae mg" href="https://rxjs.dev/guide/subject#subject" rel="noopener ugc nofollow" target="_blank"> RxJS提供多个【科目】</a>。下面是跳转到RxJS主题之前的概述。</p><h2 id="515e" class="oh nl in bd nm oi oj dn nq ok ol dp nu ku om on nw ky oo op ny lc oq or oa it bi translated">科目</h2><p id="c0fa" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">主题向所有订阅的观察者发送数据。</p><p id="2bb2" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">任何以前发出的数据都不会发送给新的观察者。您只有在订阅后才能获得数据。</p><h2 id="d46a" class="oh nl in bd nm oi oj dn nq ok ol dp nu ku om on nw ky oo op ny lc oq or oa it bi translated"><strong class="ak">行为主体</strong></h2><p id="75f4" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">BehaviorSubject将最后发出的数据发送给新的观察者。它还将发送任何未来的数据。像主题，但它也发送最后发出的项目。</p><h2 id="27d5" class="oh nl in bd nm oi oj dn nq ok ol dp nu ku om on nw ky oo op ny lc oq or oa it bi translated"><strong class="ak"> ReplaySubject </strong></h2><p id="7974" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">先前发送的数据可以“重放”给新的观察者。您可以决定向新的观察者重放所有内容，或者只重放一部分数据。</p><p id="8fe8" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">现在你可以把BehaviorSubject想象成一个只重放一次的ReplaySubject。</p><p id="a8f3" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">类似于Subject，但它发送最后N个发出的项目，其中N由您决定。</p><h2 id="84a0" class="oh nl in bd nm oi oj dn nq ok ol dp nu ku om on nw ky oo op ny lc oq or oa it bi translated"><strong class="ak">异步主题</strong></h2><p id="1ce7" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">AsyncSubject返回最后发出的项并完成。以前和将来的项目不重要。</p><p id="a250" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">下图概括了四种类型的RxJS主题。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/7adb00d9c296b0cf1715d2b97880dad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yo0v_yrDCsOSF23Z1QT89w.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Recap of the four types of RxJS Subjects.</figcaption></figure><h1 id="d8c4" class="nk nl in bd nm nn no np nq nr ns nt nu kc nv kd nw kf nx kg ny ki nz kj oa ob bi translated">主题RxJsS—角度示例</h1><p id="d1ee" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">下面的例子将在服务中使用一个主题，遵循一个常见的可观察服务模式。</p><p id="c03a" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">可观察服务模式的目的是创建一个系统，当服务中的数据发生变化时，所有使用该服务的组件都会得到通知和更新。</p><p id="ec22" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">我们将有一个AppComponent创建随机数并将其传递给服务的应用程序。该服务使用一个主题来通知所有订户。</p><h2 id="fcda" class="oh nl in bd nm oi oj dn nq ok ol dp nu ku om on nw ky oo op ny lc oq or oa it bi translated">服役中</h2><p id="828e" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">我们首先在服务中创建一个主题的新实例。类型是数字，因为<code class="fe mc md me mf b">bingoSubject</code>只会发出数字。</p><p id="a381" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">通过使用关键字<code class="fe mc md me mf b">private</code>,我们封装了<code class="fe mc md me mf b">bingoSubject</code>,这样就不能从服务外部访问它。</p><pre class="lh li lj lk gt os mf ot bn ou ov bi"><span id="dd43" class="ow nl in mf b be ox oy l oz pa">private bingoSubject = new Subject&lt;number&gt;();</span></pre><p id="d3f6" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">这是一个很好的实践，否则我们应用程序的其他部分可能会错误地使用主题并触发数据发射。</p><p id="1682" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">为了能够订阅<code class="fe mc md me mf b">bingoSubject</code>,我们定义了一个公开主题的只读可观察部分的公共变量。</p><pre class="lh li lj lk gt os mf ot bn ou ov bi"><span id="4b54" class="ow nl in mf b be ox oy l oz pa">randomNumber$ = this.bingoSubject.asObservable();</span></pre><p id="14bb" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">由于<code class="fe mc md me mf b">randomNumber$</code>是可观测的，我们给它加上一个<code class="fe mc md me mf b">$</code>符号。这是一个帮助我们发现代码中可观察到的地方的约定。</p><p id="8a34" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">发出新值时，<code class="fe mc md me mf b">randomNumber$</code>的所有订阅者将收到相同的值。</p><p id="10ab" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">最后，我们添加一个方法来改变这个数字。由于<code class="fe mc md me mf b">randomNumber$</code>是一个可观察值，我们可以使用<code class="fe mc md me mf b">next</code>方法来发出一个新值。</p><pre class="lh li lj lk gt os mf ot bn ou ov bi"><span id="f42d" class="ow nl in mf b be ox oy l oz pa">updateNumber(item: number) {<br/> this.bingoSubject.next(item);<br/>}</span></pre><h2 id="8991" class="oh nl in bd nm oi oj dn nq ok ol dp nu ku om on nw ky oo op ny lc oq or oa it bi translated">在AppComponent类中</h2><p id="9f31" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">在AppComponent类中，我们声明两个变量:<code class="fe mc md me mf b">receivedNumber</code>和<code class="fe mc md me mf b">subscription$</code>。分别是服务中主体发出的号码和服务中主体实例的订阅。</p><p id="1bde" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">然后，我们在构造函数中注入<code class="fe mc md me mf b">bingoService</code>，最后，我们访问服务中的主体实例<code class="fe mc md me mf b">randomNumber$</code>。</p><pre class="lh li lj lk gt os mf ot bn ou ov bi"><span id="b6f5" class="ow nl in mf b be ox oy l oz pa">receivedNumber: number;<br/>subscription$: Subscription;<br/><br/>constructor(private bingoService: BingoService) {}<br/><br/>ngOnInit() {<br/>  this.subscription$ = this.bingoService.randomNumber$.subscribe(<br/>    (x: number) =&gt; (this.receivedNumber = x)<br/>  );<br/>}</span></pre><p id="cd50" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">在同一个类中，我们添加了一个从模板触发的<code class="fe mc md me mf b">extractNumber</code>方法。该方法创建一个随机数，调用服务中的<code class="fe mc md me mf b">updateNumber</code>方法，并将新数传递给它。</p><pre class="lh li lj lk gt os mf ot bn ou ov bi"><span id="153c" class="ow nl in mf b be ox oy l oz pa">extractNumber() {<br/>  const randomNumber = Math.ceil(Math.random() * 100);<br/>  this.bingoService.updateNumber(randomNumber);<br/>}</span></pre><h2 id="a0cc" class="oh nl in bd nm oi oj dn nq ok ol dp nu ku om on nw ky oo op ny lc oq or oa it bi translated">在AppComponent模板中</h2><p id="86d4" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">该模板有一个触发<code class="fe mc md me mf b">extractNumber</code>方法的按钮。单击按钮后，会发生以下情况:</p><ol class=""><li id="be81" class="lo lp in kn b ko kp kr ks ku lq ky lr lc ls lg pb lu lv lw bi translated">按钮点击触发<code class="fe mc md me mf b">extractNumber</code></li><li id="5880" class="lo lp in kn b ko lx kr ly ku lz ky ma lc mb lg pb lu lv lw bi translated"><code class="fe mc md me mf b">extractNumber</code>方法生成一个新数字，并将其传递给服务的<code class="fe mc md me mf b">updateNumber</code>方法。</li><li id="24ca" class="lo lp in kn b ko lx kr ly ku lz ky ma lc mb lg pb lu lv lw bi translated">在服务中，<code class="fe mc md me mf b">updateNumber</code>接收数字，并使用主题实例的<code class="fe mc md me mf b">next</code>方法，例如<code class="fe mc md me mf b">bingoSubject</code>来发出值。</li><li id="6030" class="lo lp in kn b ko lx kr ly ku lz ky ma lc mb lg pb lu lv lw bi translated">由于<code class="fe mc md me mf b">bingoSubject</code>被分配给<code class="fe mc md me mf b">randomNumber$</code>，所有订阅它的观察者将被通知新的号码。</li><li id="fa34" class="lo lp in kn b ko lx kr ly ku lz ky ma lc mb lg pb lu lv lw bi translated">在AppComponent类中，我们订阅了<code class="fe mc md me mf b">randomNumber$</code>,并将值赋给了<code class="fe mc md me mf b">receivedNumber</code>,后者在模板中得到更新和呈现。</li></ol><pre class="lh li lj lk gt os mf ot bn ou ov bi"><span id="4f74" class="ow nl in mf b be ox oy l oz pa">&lt;button (click)="extractNumber()"&gt;New Number&lt;/button&gt;<br/>&lt;p&gt;The number in the Subject is: {{ receivedNumber }}&lt;/p&gt; </span></pre><p id="7438" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">这差不多就是这个主题了。</p><p id="6381" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">你可以在StackBlitz上找到一个例子。在这个例子中，我添加了三个订阅了<code class="fe mc md me mf b">randomNumber$</code>的子组件。</p><p id="7dd6" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">您会注意到，一旦<code class="fe mc md me mf b">randomNumber$</code>发出一个新值，它们就会得到更新。</p><div class="mh mi gp gr mj mk"><a href="https://stackblitz.com/edit/angular-ivy-o5s3fc?file=src/bingo.service.ts" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ix gy z fp mp fr fs mq fu fw iw bi translated">主题堆叠</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">RxJS主题示例</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">stackblitz.com</p></div></div><div class="mt l"><div class="pc l mv mw mx mt my mz mk"/></div></div></a></div><h1 id="adcf" class="nk nl in bd nm nn no np nq nr ns nt nu kc nv kd nw kf nx kg ny ki nz kj oa ob bi translated">最终意见</h1><p id="6737" class="pw-post-body-paragraph kl km in kn b ko oc jx kq kr od ka kt ku oe kw kx ky of la lb lc og le lf lg ig bi translated">我们上面说过，RxJS科目可以对你的角度应用产生积极的影响。然而，如果复杂性显著增加，您可能需要考虑像NgRx 这样的<a class="ae mg" href="https://medium.com/gitconnected/an-introduction-to-ngrx-2d849c0baac4" rel="noopener">状态管理解决方案。</a></p><p id="d936" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">在这个例子中，我们的代码不是反应式的，可以做一些改进。使用<a class="ae mg" href="https://medium.com/better-programming/go-reactive-with-angular-async-pipe-b290988f4000" rel="noopener">角异步管道</a>是朝着这个方向迈出的一步。</p><p id="77b1" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated"><em class="pd">更多内容请看</em><a class="ae mg" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="pd">plain English . io</em></strong></a><em class="pd">。报名参加我们的</em> <a class="ae mg" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ix"> <em class="pd">免费周报</em> </strong> </a> <em class="pd">。关注我们关于</em><a class="ae mg" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="pd">Twitter</em></strong></a><a class="ae mg" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="pd">LinkedIn</em></strong></a><em class="pd"/><a class="ae mg" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="pd">YouTube</em></strong></a><em class="pd"/><a class="ae mg" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="pd">不和</em> </strong> </a> <em class="pd">。对增长黑客感兴趣？检查</em> <a class="ae mg" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ix"> <em class="pd">电路</em> </strong> </a> <em class="pd">。</em></p></div></div>    
</body>
</html>