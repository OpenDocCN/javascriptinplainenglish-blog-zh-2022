<html>
<head>
<title>Make 3D CSS Flippable Cards with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript制作3D CSS翻转卡</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/make-3d-css-flippable-cards-with-javascript-620a11e57e02?source=collection_archive---------23-----------------------#2022-02-16">https://javascript.plainenglish.io/make-3d-css-flippable-cards-with-javascript-620a11e57e02?source=collection_archive---------23-----------------------#2022-02-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9289fec4a43dffbfad5e063a0891efbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4ck8hrkSMg1cM_7FmzNuA.png"/></div></div></figure><p id="c197" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不久前，<a class="ae kt" href="https://fjolt.com/article/css-3d-interactive-flippable-cards" rel="noopener ugc nofollow" target="_blank">我写了一篇关于3d交互CSS按钮的文章</a>。使用类似的技术，我决定设计一些3d交互式(可翻转的)CSS用户卡。这些对于许多不同的东西也很有用——例如，银行卡用户界面、扑克牌用户界面，或者只是一个团队页面。下面可以看到演示！</p><p id="9c3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://codepen.io/smpnjn/pen/qBVPvpZ" rel="noopener ugc nofollow" target="_blank">完整的代码一如既往地可以在CodePen上获得。</a></p><h1 id="5f57" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">带有CSS和JavaScript的3d翻转卡</h1><p id="78fb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">将鼠标悬停在下面的卡片上(或轻按移动设备上卡片上的任意位置),以全面查看效果。</p><p id="0180" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了达到这个效果，我们必须在JavaScript和CSS中结合一些不同的东西:</p><ol class=""><li id="08d4" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><strong class="jx io">首先</strong>，我们需要创建一个函数，让我们根据鼠标位置来操纵卡片的角度。</li><li id="2892" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">接下来</strong>，我们需要使用该函数计算出位置，以在卡片顶部添加一个“眩光”灯光效果。</li><li id="122d" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">然后</strong>，我们需要添加很多CSS来为卡片创建一个背面和一个正面。</li><li id="3f37" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jx io">最后</strong>，我们需要在我们的Javascript中添加一些函数来允许我们“翻转”卡片。</li></ol><h1 id="ab78" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建HTML</h1><p id="1466" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们从HTML开始。这是我们第一张卡的样子。每张卡有两个主要部分— <code class="fe ml mm mn mo b">inner-card</code>和<code class="fe ml mm mn mo b">inner-card-backface</code>。第一个包含卡的正面，第二个包含背面。</p><p id="dc75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还有两个按钮——翻转和不翻转，用来改变卡片的哪一面是可见的。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="f684" class="mx kv in mo b gy my mz l na nb">&lt;div class="card blastoise"&gt;<br/>        &lt;span class="inner-card-backface"&gt; &lt;!-- back of the card --&gt;<br/>            &lt;span class="image"&gt;<br/>                &lt;span class="unflip"&gt;Unflip&lt;/span&gt;<br/>            &lt;/span&gt;<br/>        &lt;/span&gt;<br/>        &lt;span class="inner-card"&gt; &lt;!-- front of the card --&gt;<br/>            &lt;span class="flip"&gt;Flip&lt;/span&gt; <br/>            &lt;span class="glare"&gt;&lt;/span&gt; &lt;!-- to store the glare effect --&gt;<br/>        &lt;/span&gt;<br/>    &lt;/div&gt;</span></pre><h1 id="094b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建JavaScript部件</h1><p id="e2c3" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们的JS做一件基本的事情——那就是找出用户在卡片上的位置，并将其转换成一个角度，然后传递给我们的CSS，以改变我们对卡片的看法。为此，我们需要了解用户离卡片中心有多远。我们只需要担心两个轴——当用户到达顶部或底部时，我们可以相对于中心旋转卡片，如下图所示。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/2c67125407f759014ed7de37aa76a8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*157PioqD2rr1f6Q3.png"/></div></div></figure><h1 id="55e9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">JavaScript如何为3d翻转CSS卡工作</h1><p id="7845" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">最后，为此我们编写了一个接受“card”元素的函数，并相应地更新它的CSS:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="1dc3" class="mx kv in mo b gy my mz l na nb">let calculateAngle = function(e, item, parent) {<br/>    let dropShadowColor = `rgba(0, 0, 0, 0.3)`<br/>    if(parent.getAttribute('data-filter-color') !== null) {<br/>        dropShadowColor = parent.getAttribute('data-filter-color');<br/>    }</span><span id="32ff" class="mx kv in mo b gy nd mz l na nb">    parent.classList.add('animated');<br/>    // Get the x position of the users mouse, relative to the button itself<br/>    let x = Math.abs(item.getBoundingClientRect().x - e.clientX);<br/>    // Get the y position relative to the button<br/>    let y = Math.abs(item.getBoundingClientRect().y - e.clientY);</span><span id="730a" class="mx kv in mo b gy nd mz l na nb">    // Calculate half the width and height<br/>    let halfWidth  = item.getBoundingClientRect().width / 2;<br/>    let halfHeight = item.getBoundingClientRect().height / 2;</span><span id="5017" class="mx kv in mo b gy nd mz l na nb">    // Use this to create an angle. I have divided by 6 and 4 respectively so the effect looks good.<br/>    // Changing these numbers will change the depth of the effect.<br/>    let calcAngleX = (x - halfWidth) / 6;<br/>    let calcAngleY = (y - halfHeight) / 14;</span><span id="8b42" class="mx kv in mo b gy nd mz l na nb">    let gX = (1 - (x / (halfWidth * 2))) * 100;<br/>    let gY = (1 - (y / (halfHeight * 2))) * 100;</span><span id="9043" class="mx kv in mo b gy nd mz l na nb">    // Add the glare at the reflection of where the user's mouse is hovering<br/>    item.querySelector('.glare').style.background = `radial-gradient(circle at ${gX}% ${gY}%, rgb(199 198 243), transparent)`;<br/>    // And set its container's perspective.<br/>    parent.style.perspective = `${halfWidth * 6}px`<br/>    item.style.perspective = `${halfWidth * 6}px`</span><span id="c9ca" class="mx kv in mo b gy nd mz l na nb">    // Set the items transform CSS property<br/>    item.style.transform = `rotateY(${calcAngleX}deg) rotateX(${-calcAngleY}deg) scale(1.04)`;<br/>    parent.querySelector('.inner-card-backface').style.transform = `rotateY(${calcAngleX}deg) rotateX(${-calcAngleY}deg) scale(1.04) translateZ(-4px)`;</span><span id="acaa" class="mx kv in mo b gy nd mz l na nb">    if(parent.getAttribute('data-custom-perspective') !== null) {<br/>        parent.style.perspective = `${parent.getAttribute('data-custom-perspective')}`<br/>    }</span><span id="abda" class="mx kv in mo b gy nd mz l na nb">    // Reapply this to the shadow, with different dividers<br/>    let calcShadowX = (x - halfWidth) / 3;<br/>    let calcShadowY = (y - halfHeight) / 6;</span><span id="de4d" class="mx kv in mo b gy nd mz l na nb">    // Add a filter shadow - this is more performant to animate than a regular box shadow.<br/>    item.style.filter = `drop-shadow(${-calcShadowX}px ${-calcShadowY}px 15px ${dropShadowColor})`;<br/>}</span></pre><p id="3583" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这个函数做4件事:</strong></p><ul class=""><li id="1d64" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks ne md me mf bi translated">计算元素的阴影，使其看起来像在三维空间中移动。</li><li id="5b14" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ne md me mf bi translated">根据鼠标位置计算卡片的角度。</li><li id="9068" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ne md me mf bi translated">计算背面的位置，使其与卡片正面同步移动。</li><li id="2820" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ne md me mf bi translated">计算眩光的位置，它是用户鼠标所在位置的反射。</li></ul><p id="db0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在所要做的，就是将这个函数添加到我们的每个鼠标移动事件中，然后当用户的鼠标离开元素时，重置一切。我们还将添加一些“翻转”和“取消翻转”卡片的功能:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="5f0a" class="mx kv in mo b gy my mz l na nb">document.querySelectorAll('.card').forEach(function(item) {<br/>    // For flipping the card backwards and forwards<br/>    if(item.querySelector('.flip') !== null) {<br/>      item.querySelector('.flip').addEventListener('click', function() {<br/>        item.classList.add('flipped');<br/>      });<br/>    }</span><span id="009f" class="mx kv in mo b gy nd mz l na nb">    // For 'unflipping' the card.<br/>    if(item.querySelector('.unflip') !== null) {<br/>      item.querySelector('.unflip').addEventListener('click', function() {<br/>        item.classList.remove('flipped');<br/>      });<br/>    }</span><span id="4f1f" class="mx kv in mo b gy nd mz l na nb">    // For when the user's mouse 'enters' the card<br/>    item.addEventListener('mouseenter', function(e) {<br/>        calculateAngle(e, this.querySelector('.inner-card'), this);<br/>    });</span><span id="0fde" class="mx kv in mo b gy nd mz l na nb">    // For when the users mouse moves on top of the card<br/>    item.addEventListener('mousemove', function(e) {<br/>        calculateAngle(e, this.querySelector('.inner-card'), this);<br/>    });</span><span id="f86d" class="mx kv in mo b gy nd mz l na nb">    // For when the user's mouse leaves the card.<br/>    item.addEventListener('mouseleave', function(e) {<br/>        let dropShadowColor = `rgba(0, 0, 0, 0.3)`<br/>        if(item.getAttribute('data-filter-color') !== null) {<br/>            dropShadowColor = item.getAttribute('data-filter-color')<br/>        }<br/>        item.classList.remove('animated');<br/>        item.querySelector('.inner-card').style.transform = `rotateY(0deg) rotateX(0deg) scale(1)`;<br/>        item.querySelector('.inner-card-backface').style.transform = `rotateY(0deg) rotateX(0deg) scale(1.01) translateZ(-4px)`;<br/>        item.querySelector('.inner-card').style.filter = `drop-shadow(0 10px 15px ${dropShadowColor})`;<br/>    });<br/>});</span></pre><p id="f99c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能会注意到鼠标事件是针对卡片的，但是转换主要发生在。内卡。那是因为如果角度。卡片改变时,“悬停框”也会改变。如果发生这种情况，用户可能会悬停在卡片上，但角度会发生很大变化，不会再发生变化，使效果看起来很糟糕。通过向卡片添加悬停效果，我们保持了一个恒定的悬停框，同时还允许我们转换。内卡在这个固定的盒子里。</p><h1 id="3fb9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">添加CSS</h1><p id="ca85" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">最后，我们可以添加CSS。这里最基本的是我们有一个卡片容器。包含我们要转换的卡片的卡片--。内卡。</p><p id="47da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做的另一个好处是，当用户点击“翻转”时，我们可以翻转<code class="fe ml mm mn mo b">.card</code>本身，因为我们维护一个父元素和子元素。这意味着我们可以继续转换<code class="fe ml mm mn mo b">.inner-card,</code>并翻转。卡的同时，产生更无缝的效果。</p><p id="8500" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ml mm mn mo b">.inner-card-backface</code>上，我们添加线条<code class="fe ml mm mn mo b">transform: rotateX(0) rotateY(0deg) scale(1) translateZ(-4px);</code>将其向后移动4个像素。这创造了一个很酷的3d深度效果，并确保用户悬停时正面和背面不会碰撞。我们也把<code class="fe ml mm mn mo b">backface-visibility: visible;</code>加到我们的。所以我们的正面和背面都可以互动。</p><p id="fe99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，由于我们使用。翻转类，我们需要将卡片背面的内容“翻转”。如果我们不这样做，背面的文字就会从后到前出现！所以我们有一个名为<code class="fe ml mm mn mo b">.flip-inner-card</code>的类，它只是让我们翻转卡片的背面，这样文字就不再是从后到前了。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="a281" class="mx kv in mo b gy my mz l na nb">.card {<br/>    box-shadow: none;<br/>    backface-visibility: visible;<br/>    background: transparent;<br/>    font-family: Inter,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;<br/>    transform-style: preserve-3d;<br/>    padding: 0;<br/>    height: auto;<br/>    margin: 0 2rem 0 0;<br/>    width: 18rem;<br/>    height: 25rem;<br/>    float: left;<br/>    transition: all 0.2s ease-out;<br/>    border: none;<br/>    letter-spacing: 1px;<br/>}<br/>.flip, .unflip {<br/>    background: rgba(0,0,0,0.1);<br/>    font-size: 1rem;<br/>    position: absolute;<br/>    top: 1rem;<br/>    right: 1rem;<br/>    padding: 0.5rem 0.75rem;<br/>    border-radius: 100px;<br/>    line-height: 1rem;<br/>    cursor: pointer;<br/>    transition: all 0.1s ease-out;<br/>}<br/>.unflip {<br/>    top: auto;<br/>    background: #2d2d62;<br/>    bottom: 1rem;<br/>}<br/>.flip:hover {<br/>  background: rgba(0,0,0,0.3);<br/>}<br/>.card .flip-inner-card {<br/>    transform: rotateY(180deg);<br/>    position: absolute;<br/>    top: 0;<br/>    padding: 2rem 1.5rem;<br/>    box-sizing: border-box;<br/>    left: 0;<br/>    width: 100%;<br/>    height: 100%;<br/>}<br/>.inner-card-backface {<br/>    transform: rotateX(0) rotateY(0deg) scale(1) translateZ(-4px);<br/>    border-radius: 14px;<br/>    background: linear-gradient(45deg, #0b0b2a, #0b0b2a);<br/>    position: absolute;<br/>    top: 0;<br/>    color: white;<br/>    padding: 2rem;<br/>    box-sizing: border-box;<br/>    transition: all 0.15s ease-out;<br/>    will-change: transform, filter;<br/>    left: 0;<br/>    width: 100%;<br/>    height: 100%;<br/>}<br/>.card.flipped {<br/>    transform: rotateY(180deg);<br/>}<br/>.card .flip-inner-card {<br/>    transform: rotateY(180deg);<br/>    position: absolute;<br/>    top: 0;<br/>    padding: 2rem 1.5rem;<br/>    box-sizing: border-box;<br/>    left: 0;<br/>    width: 100%;<br/>    height: 100%;<br/>}</span></pre><h1 id="6d52" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="4eda" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在本教程中，我们已经介绍了如何制作一个3d CSS翻转卡。我们已经讨论了当用户悬停在它上面时计算显示角度所需的函数，以及制作这样的3d卡片所需的CSS。我希望您喜欢——请随意在您的任何个人项目中使用，以下是一些有用的链接:</p><ul class=""><li id="91d5" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks ne md me mf bi translated">所有代码都可以在Codepen 上找到</li><li id="11bf" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ne md me mf bi translated"><a class="ae kt" href="https://fjolt.com/article/css-3d-interactive-flippable-cards" rel="noopener ugc nofollow" target="_blank">这里有一个类似的效果，用按钮代替卡片</a></li></ul><p id="3cad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nf">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nf">plain English . io</em></strong></a><em class="nf">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nf">免费周报</em> </strong> </a> <em class="nf">。在我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nf">社区</em> </strong> </a> <em class="nf">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>