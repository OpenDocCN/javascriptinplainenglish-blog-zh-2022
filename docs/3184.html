<html>
<head>
<title>Linear, Binary, And Hashing Search in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的线性、二进制和散列搜索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/linear-binary-and-hashing-search-in-javascript-908a54ca7658?source=collection_archive---------3-----------------------#2022-08-07">https://javascript.plainenglish.io/linear-binary-and-hashing-search-in-javascript-908a54ca7658?source=collection_archive---------3-----------------------#2022-08-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/33c516e4b158cbab07caed2b46c328aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a-KC2GHdwzAxsF_O"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@alisvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ali Hajian</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2a0b" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">JavaScript中的搜索算法</h1><p id="f354" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">当我们需要从任何数据存储中查找数据时，通常有三种类型的搜索算法。它们是线性搜索、二分搜索法和散列搜索。搜索意味着从数据集中找到一个数据记录，该数据可以是任何地图或项目列表。每种搜索算法都有一定的要求，然后才能使用它，甚至应用到您的程序中:</p><ul class=""><li id="9990" class="lw lx in la b lb ly lf lz lj ma ln mb lr mc lv md me mf mg bi translated">线性搜索—线性搜索需要应用于未排序的数组，查找是基于将每个元素与要搜索的目标进行比较来完成的</li><li id="195c" class="lw lx in la b lb mh lf mi lj mj ln mk lr ml lv md me mf mg bi translated">二分搜索法——如果数组从相同的键或相同的方向排序，二分搜索法是从数组中搜索元素的优化方法</li><li id="f51d" class="lw lx in la b lb mh lf mi lj mj ln mk lr ml lv md me mf mg bi translated">哈希——如果我们想在Hashmap上搜索，我们将使用哈希算法来存储哈希的键，并直接用值映射它，而不是在数组中搜索。这个算法的时间复杂度是O(1 ),因为程序已经知道具有相同密钥的值的散列或索引</li></ul><p id="e157" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">在这里阅读更多关于搜索算法的信息<a class="ae jz" href="https://en.wikipedia.org/wiki/Search_algorithm" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="255c" class="mp kb in bd kc mq mr dn kg ms mt dp kk lj mu mv ko ln mw mx ks lr my mz kw na bi translated">线性搜索</h2><p id="4296" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在JavaScript中，我们在数组原型<code class="fe nb nc nd ne b">find</code>中有一个方法，它使用线性搜索来查找元素。让我们创建find的定义来理解这里的线性算法是如何工作的</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/ad97179d6826744f60ca34050284f10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WAWaUrXqY228vSN3O_OcQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of linear search</figcaption></figure><p id="d4e2" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">下面是线性搜索的例子，我们首先在Array上创建了prototype方法，并在运行提供的回调方法时迭代所有元素，如果回调成功，则返回完整的对象</p><p id="ee0e" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">这种算法最坏的情况是目标元素在最后一个索引上，使它运行N次。所以时间复杂度是O(N ),其中N是数组中的项数</p><h2 id="47ad" class="mp kb in bd kc mq mr dn kg ms mt dp kk lj mu mv ko ln mw mx ks lr my mz kw na bi translated">二进位检索</h2><p id="00af" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">接下来是二分搜索法，但是请记住，二分搜索法将只对排序后的数组起作用，所以首先，我们需要确保数组是排序的</p><h2 id="819a" class="mp kb in bd kc mq mr dn kg ms mt dp kk lj mu mv ko ln mw mx ks lr my mz kw na bi translated"><strong class="ak">对象数组注释:</strong></h2><p id="bd32" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在JavaScript中处理对象数组时，应该使用要搜索的键对数组进行排序。例如，如果您想要在数组的对象中搜索名称作为属性之一，那么数组应该只根据名称字段进行格式化，而不使用对象数组中的任何其他字段</p><h2 id="cea6" class="mp kb in bd kc mq mr dn kg ms mt dp kk lj mu mv ko ln mw mx ks lr my mz kw na bi translated">算法</h2><p id="279d" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在二分搜索法中，由于数组是按照某种顺序排序的，我们可以使用这意味着我们知道应该走哪条路径来搜索目标元素。让我们举个例子来了解更多</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="096a" class="mp kb in ne b gy no np l nq nr">const arr = [1, 3, 5, 7, 9]</span></pre><p id="ef05" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">正如你所看到的，数组是按照奇数的ASC顺序排序的。因此，为了更加慷慨<strong class="la io">，我们首先取一个中间元素(你可以取任何数字，但是为了得到最准确的结果，你应该总是取中间元素)</strong></p><p id="49bb" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">下一步是比较目标元素和中间元素</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="4a52" class="mp kb in ne b gy no np l nq nr">let start = 0, end = arr.length - 1<br/>const mid = start + ( end - start) / 2<br/>arr[mid] == target</span></pre><blockquote class="ns nt nu"><p id="cea8" class="ky kz nv la b lb ly ld le lf lz lh li nw mm ll lm nx mn lp lq ny mo lt lu lv ig bi translated">我们也可以使用end + start / 2，但是如果数组很大，就会产生内存错误，所以最好使用上面的方法来计算中间的索引</p></blockquote><p id="2a94" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">如果我们找到了元素，我们将返回中间的元素，否则我们将检查是否</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="8967" class="mp kb in ne b gy no np l nq nr">target &gt; arr[mid] - go for mid + 1 indexes<br/>target &lt; arr[mid] - go for mid - 1 indexes</span></pre><p id="c01c" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">现在你将有一个基于上述条件的新数组，然后我们将需要重新执行相同的逻辑，直到数组大小变为1，我们找到元素</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="e0b4" class="mp kb in ne b gy no np l nq nr">0 .. mid<br/>OR<br/>mid .. last-index</span></pre><h2 id="3e96" class="mp kb in bd kc mq mr dn kg ms mt dp kk lj mu mv ko ln mw mx ks lr my mz kw na bi translated">程序</h2><p id="4049" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">讨论够了，让我们写一些代码来看看我们如何使它工作</p><p id="f07a" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">我们将使用这个集合来创建程序，并观察数组是否按score参数排序，我也想用相同的参数进行搜索</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="ff14" class="mp kb in ne b gy no np l nq nr">const arr = [{<br/>    id: 1,<br/>    score: 8,<br/>    name: 'test'<br/>}, {<br/>    id: 2,<br/>    score: 9,<br/>    name: 'test2'<br/>}, {<br/>    id: 3,<br/>    score: 12,<br/>    name: 'test2'<br/>}, {<br/>    id: 4,<br/>    score: 30,<br/>    name: 'test2'<br/>}, {<br/>    id: 5,<br/>    score: 60,<br/>    name: 'test2'<br/>}]</span></pre><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b41c41032b3202578fdc2219a2e865d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*NalgCkLt7dAGNxG0hYCp5g.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Binary search example</figcaption></figure><p id="cdca" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">这里，我们维护数组的开始和结束，我们操作开始和结束来创建一个替代数组，同时检查目标是否匹配。</p><p id="19ff" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">这将是它。你的二分搜索法已经准备好为你服务了。</p><p id="3b43" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">二分搜索法的时间复杂度为O(log n)。让我简单介绍一下如何计算它的时间复杂度</p><h2 id="9e7c" class="mp kb in bd kc mq mr dn kg ms mt dp kk lj mu mv ko ln mw mx ks lr my mz kw na bi translated">计算时间复杂度</h2><p id="a8ec" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在计算之前，让我们看看需要对变量运行多少次特定的语句</p><p id="ccb4" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">首先，在2^n部分，执行的语句数量正在减少</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="d65b" class="mp kb in ne b gy no np l nq nr">N = 16<br/>N = 8 // we divide array based on middle element<br/>N = 4 // we divide array based on middle element<br/>N = 2 // we divide array based on middle element<br/>N = 1 // we divide array based on middle element</span></pre><p id="5806" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">现在，让我们设计二分搜索法的公式，因为他们每个人都是2的乘数，我们可以很容易地说</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="1860" class="mp kb in ne b gy no np l nq nr">2^k = N, we would need to find the value of k</span></pre><p id="c839" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">让我们两边都用圆木</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="ee4f" class="mp kb in ne b gy no np l nq nr">Log(2^k) = log(N)</span></pre><p id="7d20" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">我们有一个对数公式</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="5d06" class="mp kb in ne b gy no np l nq nr">log(a^b) = blog(a)</span></pre><p id="955f" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">所以新的等式是</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="9e8b" class="mp kb in ne b gy no np l nq nr">klog(2) = log(N)<br/>k = log(N) // since log(2) is 1</span></pre><p id="85d1" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">这就是你计算二分搜索法时间复杂度的方法。计算时间复杂度本身是一个很大的讨论话题，但是我们用了很小的一部分来展示它是如何实现的</p><h2 id="c4ef" class="mp kb in bd kc mq mr dn kg ms mt dp kk lj mu mv ko ln mw mx ks lr my mz kw na bi translated">散列法</h2><p id="7f4f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">哈希算法非常简洁，只针对Hashmaps。因为hashmap存储数据的模式总是知道条目的键，所以从它开始搜索是一个单一的调用。一个简单的例子是</p><pre class="ng nh ni nj gt nk ne nl nm aw nn bi"><span id="c986" class="mp kb in ne b gy no np l nq nr">const obj = {<br/>  name: 'test'<br/>}</span><span id="e4b5" class="mp kb in ne b gy oa np l nq nr">obj.name == 'test' // true</span></pre><p id="44f9" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">哈希的时间复杂度是O(1 ),因为响应操作不受哈希包含的项数的影响</p><h2 id="7847" class="mp kb in bd kc mq mr dn kg ms mt dp kk lj mu mv ko ln mw mx ks lr my mz kw na bi translated">结论</h2><p id="b831" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这个主题对于开始算法练习并希望了解如何创建和计算方法的您来说非常具体。</p><p id="cf6b" class="pw-post-body-paragraph ky kz in la b lb ly ld le lf lz lh li lj mm ll lm ln mn lp lq lr mo lt lu lv ig bi translated">我希望你今天能学到一些好东西。编码快乐！</p></div></div>    
</body>
</html>