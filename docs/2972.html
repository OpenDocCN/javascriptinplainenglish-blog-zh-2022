<html>
<head>
<title>Multitasking in Node.js With Child Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中子进程的多任务处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/multitasking-in-node-js-with-child-process-d82841fd8d29?source=collection_archive---------5-----------------------#2022-07-19">https://javascript.plainenglish.io/multitasking-in-node-js-with-child-process-d82841fd8d29?source=collection_archive---------5-----------------------#2022-07-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e628" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于Node.js中子进程多任务处理的教程。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a89188eba488828034a6520739603a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gLcFdLvOq8m7iOm0RVtD0g.png"/></div></div></figure><p id="3677" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Node.js程序从上到下一次执行一行(<strong class="kq io">单线程</strong>)。现在，如果线程中有同步块或CPU密集型操作，如使用crypto的加密/解密，它将阻止进一步的执行。像这样的任务需要被卸载以保持主线程空闲。这可以通过子进程来实现，这也是我们将在这篇博文中看到的。</p><p id="0b0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.youtube.com/playlist?list=PL62km_yqC3ZEV0wKbLbd3CG-2zt3oDkes" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">你也可以在这里观看这个教程的视频版本。</em> </strong> </a></p><h1 id="32c4" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">首先，什么是过程？</h1><p id="32a3" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">“进程”不一定是特定于节点的概念。它是你在系统上运行的程序的一个实例。打开浏览器或打开Spotify会调用该程序的一个进程。类似地，在node JS中创建的应用程序在执行时也会有一个进程。您可以通过使用<code class="fe mj mk ml mm b"><strong class="kq io">process</strong></code>对象来访问这个进程信息。它是全球可用的，因此您不必在使用它之前手动<code class="fe mj mk ml mm b"><strong class="kq io">require</strong></code> <strong class="kq io"> </strong>。该对象包含与应用程序、操作系统、设备等相关的详细信息。</p><p id="11b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://nodejs.org/api/process.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">您可以查看流程对象中存在的所有属性。</em> </strong> </a></p><p id="52bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们知道了什么是进程，让我们跳到子进程。</p><h1 id="9b8d" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">子进程</h1><p id="69f9" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">因此，当一个进程被执行，并且有一个任务需要一些时间来运行时，最好将该任务从主线程移开，以避免任何阻塞。nodeJS中的子进程模块可以让您将这些繁重的任务卸载到子进程中，从而使您的主线程保持空闲。</p><p id="d065" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在子流程模块中有3个函数可以帮助我们创建子流程。<br/>-<strong class="kq io">Spawn<br/>-Exec&amp;Exec file<br/>-Fork</strong></p><h1 id="6e84" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">卵</h1><p id="7727" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">spawn函数将在一个进程中运行一个<strong class="kq io">命令</strong>。运行该命令后，为该命令返回的数据将以<strong class="kq io">流</strong>的形式出现。这意味着它纯粹是异步的，所以它不会阻塞事件循环。每当一条数据准备好作为响应发送回来时，它将被传递到<strong class="kq io">标准输出流</strong>，如果在运行命令时出现错误，它将被传递到<strong class="kq io">标准错误流</strong>。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="0e6f" class="mr ln in mm b gy ms mt l mu mv">const { spawn } = require('child_process');</span><span id="a0fd" class="mr ln in mm b gy mw mt l mu mv">let listFiles = <strong class="mm io">spawn("dir", { shell : true })</strong></span><span id="ba0b" class="mr ln in mm b gy mw mt l mu mv">listFiles.stderr.on("data", (error) =&gt; {<br/>    console.log(error.toString())<br/>})</span><span id="9cc7" class="mr ln in mm b gy mw mt l mu mv">listFiles.stdout.on("data", (data) =&gt; {<br/>    console.log(data.toString())<br/>})</span><span id="deb9" class="mr ln in mm b gy mw mt l mu mv">listFiles.on('error', (error) =&gt; {<br/>    console.error(`Some error occurred: ${error.message}`);<br/>});</span></pre><p id="3cd3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在这里的“<strong class="kq io">dir”</strong>命令列出了当前工作目录中的文件和文件夹。这是Linux中“<strong class="kq io"> ls </strong>的替代。对于Windows系统，在运行某些脚本/命令之前，您可能需要一个shell。这就是我在命令后传递一个shell选项的原因。如果您使用的是Linux系统，您可能不需要它。</p><p id="c0d1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，一旦我们将命令存储在变量中，我们就可以通过使用相应的流来监听任何响应或错误。标准错误(<strong class="kq io"> stderr </strong>):如果您试图执行的命令有问题，将会给出一个错误。标准输出(<strong class="kq io"> stdout </strong>):以流的形式给你一个有效的响应。<br/>这两个流都返回一个缓冲字符串，所以我使用<code class="fe mj mk ml mm b"><strong class="kq io">toString()</strong></code>将其转换成可读格式。</p><p id="850d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们还寻找一个<strong class="kq io">错误事件</strong>，当spawn命令本身出现问题时，就会发生这个错误事件。一个更常用的事件是<strong class="kq io">关闭事件</strong>。此事件在进程结束并且所有标准输入输出流都已关闭后发出。在<strong class="kq io">退出事件</strong>的情况下，流可能仍然是打开的，因为多个事件可以使用它们。</p><h1 id="2acc" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">高级管理人员</h1><p id="16b3" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">Exec有点类似于spawn函数。它也在一个进程中运行一个<strong class="kq io">命令</strong>,但是响应不是以流的形式。它被存储在一个<strong class="kq io">缓冲器</strong>中，然后作为一个整体被发送回去。所以在spawn的例子中，对响应的大小没有限制，因为它是分块发回的，所以在一段时间内您可能会得到大量的响应。在exec的情况下，它首先等待缓冲区被填满。一旦它被填充，它将返回整个响应。</p><p id="ef2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是如果响应的大小大于缓冲区呢？如果是这样的话，你的应用程序就会崩溃，所以如果你事先知道你的响应会很大，你应该选择spawn方法而不是exec。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="c954" class="mr ln in mm b gy ms mt l mu mv">const { exec } = require('child_process')</span><span id="09e0" class="mr ln in mm b gy mw mt l mu mv">exec("copy script.js newFile.js", (error, stdout, stderr) =&gt; {<br/>    if (error) { return console.log(error) }<br/>    if (stderr) { return console.log(stderr) }<br/>    console.log(stdout);<br/>});</span></pre><p id="acd2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在exec的情况下，我们不需要shell选项，因为它默认运行shell中的每个命令。这次我们没有处理流，而是使用了回调函数。在上面的例子中，我运行了一个复制命令，将第一个文件(script.js)的内容复制到第二个文件(newFile.js)中。这个命令的Linux替代选项是“<strong class="kq io"> cp </strong>”。一旦内容被复制，响应数据将被存储在一个缓冲区中，只有当整个数据被取出时，您才能得到响应。</p><p id="8901" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，在使用exec时，您可以直接在命令本身中传递参数。在产卵的情况下，你不能这样做。你必须在数组中传递参数。比如说，</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="6ef8" class="mr ln in mm b gy ms mt l mu mv">//Entire command is passed<br/>exec("<!-- -->copy script.js newFile.js<!-- -->", callback);</span><span id="d9e5" class="mr ln in mm b gy mw mt l mu mv">//Command and arguments are passed separately in an array<br/>spawn(“copy”, [“script.js”, “xyz.js”])</span></pre><p id="bfab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本教程的视频版本中，我比较了运行相同命令时spawn和exec返回的响应。你应该去看看！  </p><h1 id="020d" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">Execfile</h1><p id="5a42" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated"><strong class="kq io">“execFile”</strong>用于在单独的进程中运行可执行文件，不像exec那样运行命令。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="15ee" class="mr ln in mm b gy ms mt l mu mv">execFile("<strong class="mm io">node</strong>", ["--version"], (error, stdout, stderr) =&gt; {<br/>     if(error) { throw error }<br/>     console.log("Output: " + stdout)<br/>})</span></pre><p id="a860" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个脚本将返回您系统上nodeJS的当前版本。参数也需要在数组内部传递，就像spawn方法一样。因为我的环境路径变量中有节点可执行文件，所以我不必传递整个文件位置。这两种情况下我会得到相同的结果。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="76f8" class="mr ln in mm b gy ms mt l mu mv">//will give the same result<br/>execFile(<strong class="mm io">"C:/Program Files/nodejs/node"</strong>, ["--version"], (error, stdout, stderr) =&gt;{<br/>     if(error) { throw error }<br/>     console.log("Output: " + stdout)<br/>})</span></pre><p id="8688" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在Linux系统的情况下，通常<strong class="kq io"> bin </strong>和<strong class="kq io"> sbin </strong>目录会有可执行文件。Windows系统通常将默认的可执行文件存储在程序文件中。您还可以使用execFile运行shell脚本。</p><p id="ec2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与exec不同，execFile不会在shell中运行您的命令。相反，它将可执行文件生成为一个新的子进程，使其比exec稍微高效一些。如果在windows系统上运行execFile有问题，可以使用shell选项，就像我们在spawn方法中所做的那样。</p><h1 id="12e0" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">叉</h1><p id="92fc" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我们要研究的最后一个方法是fork方法。这个方法，就像前面的任何方法一样，产生了一个新的节点JS进程，但是这次它还调用了一个在子进程和父进程之间创建IPC通道的模块。IPC代表<strong class="kq io">进程间通信</strong>。它基本上是操作系统提供的一组机制，允许进程管理共享数据。你真的不需要担心IPC。你需要知道的是，它将在子进程和父进程之间打开一个通道，这样它们就可以在某个事件中互相发送消息。</p><p id="075d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个方法将文件的URL作为它的第一个参数。因此子流程逻辑现在将驻留在这个文件中。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="a64c" class="mr ln in mm b gy ms mt l mu mv">//scirpt.js - Parent<br/>const child = fork("./child.js");</span></pre><p id="b4d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们也创建子流程文件。在这个文件中，我们将简单地添加一个console.log语句。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="fa54" class="mr ln in mm b gy ms mt l mu mv">//child.js - Child<br/>console.log("Hello world")</span></pre><p id="165a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果我运行script.js文件，我应该马上得到控制台日志消息。因此，这基本上意味着，当我们在父流程中创建一个分支时，子流程文件中的代码就会被执行。</p><p id="aab5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您还可以向该方法传递第二个参数，该参数是作为子进程参数的字符串数组。在子进程内部，您可以通过使用"<strong class="kq io"> argv" </strong>属性来访问它，就像您通常在任何其他进程中所做的那样。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="f2d6" class="mr ln in mm b gy ms mt l mu mv">//script.js - Parent<br/>const child = fork("./child.js", ["hello", 1, "jumanji"]);</span><span id="0809" class="mr ln in mm b gy mw mt l mu mv"><br/>//child.js - Child<br/>console.log(process.argv)</span></pre><p id="53e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第三个参数是一组选项，可以传递给分叉的进程。对于这个例子，我们不需要担心这些选项，所以我们现在跳过它，但是你可以在以后阅读更多的内容。只有第一个参数是必需的，其余的都是可选的。</p><p id="74b3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，现在让我们试着向这个分叉的进程发送一个消息。我们可以使用<strong class="kq io">发送</strong>方法来实现。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="878d" class="mr ln in mm b gy ms mt l mu mv">//script.js - Parent</span><span id="3109" class="mr ln in mm b gy mw mt l mu mv">const child = fork("./child.js");<br/><strong class="mm io">child.send({ message: "Hello child" })</strong></span></pre><p id="deae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">子进程还需要知道是否有来自父进程的新消息。因为所有子进程都实现了事件发射器API，所以它们可以监听事件。这也是我们能够从父子流程发送事件的原因。所以让我们来听一下消息事件。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="aa8e" class="mr ln in mm b gy ms mt l mu mv">//child.js - Child</span><span id="f8e8" class="mr ln in mm b gy mw mt l mu mv">process.on("<strong class="mm io">message</strong>", (msg) =&gt; {<br/>    console.log("Message from parent", msg);<br/>})</span></pre><p id="055f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当我运行它时，子进程收到了消息，但是进程还没有结束。它仍在监听任何事件，这意味着它仍在运行。您可以通过对带有退出代码的进程使用exit方法来手动退出。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="8a94" class="mr ln in mm b gy ms mt l mu mv">//child.js - Child</span><span id="9679" class="mr ln in mm b gy mw mt l mu mv">process.on("message", (msg) =&gt; {<br/>    console.log("Message from parent", msg);<br/>    <strong class="mm io">process.exit(0)</strong><br/>})</span></pre><p id="6fb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果您想将消息从子节点发送到父节点，您可能已经猜到了，您需要使用相同的send方法，这一次，子节点不再是侦听器，而是父节点需要侦听消息。因此我们可以在父流程上使用相同的消息事件侦听器。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="6777" class="mr ln in mm b gy ms mt l mu mv">//child.js - Child</span><span id="a818" class="mr ln in mm b gy mw mt l mu mv"><strong class="mm io">process.send({ message: "Hello parent" })</strong></span><span id="7662" class="mr ln in mm b gy mw mt l mu mv">process.on("message", (msg) =&gt; {<br/>    console.log("Message from parent", msg);<br/>    process.exit(0)<br/>})</span><span id="911d" class="mr ln in mm b gy mw mt l mu mv">//script.js - Parent</span><span id="11a2" class="mr ln in mm b gy mw mt l mu mv">const child = fork("./child.js");</span><span id="a422" class="mr ln in mm b gy mw mt l mu mv">child.send({ message: "Hello child" })</span><span id="7f5e" class="mr ln in mm b gy mw mt l mu mv">child.on("<strong class="mm io">message</strong>", (msg) =&gt; {<br/>    console.log("Message from child", msg);<br/>})</span></pre><p id="550e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在您已经知道了fork方法的工作原理，让我们来看一个更实际的例子。</p><p id="ac4f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个接受请求的简单HTTP服务器。如果请求端点是“<strong class="kq io">/heavy”</strong>，那么它将执行大量计算，阻塞CPU资源。另一个请求URL端点是“<strong class="kq io"> /light </strong>”，它将立即返回一个响应。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="71de" class="mr ln in mm b gy ms mt l mu mv">const { fork } = require("child_process");<br/>const http = require('http');<br/>const server = http.createServer();</span><span id="23e1" class="mr ln in mm b gy mw mt l mu mv">server.on("request", (req, res) =&gt; {<br/>    <strong class="mm io">//heavy operation</strong><br/>    if (req.url == "<strong class="mm io">/heavy</strong>") {<br/>        let counter = 0;<br/>        while (counter &lt; 9000000000) {<br/>            counter++;<br/>        }<br/>        res.end(`${counter} iterations completed \\n`);<br/>        console.log("Heavy request");<br/>    }<br/>    <strong class="mm io">//light operation</strong> <br/>    else if (req.url == "<strong class="mm io">/light</strong>") {<br/>        res.end("Success! Operation complete! \\n")<br/>        console.log("Light request");<br/>    }<br/>})</span><span id="c658" class="mr ln in mm b gy mw mt l mu mv">server.listen(3000, () =&gt; console.log("Listening to port 3000"))</span></pre><p id="d35a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我运行make heavy request并试图同时运行light request时，您会看到只有在heavy request完成后，light request才会被执行。这是因为繁重的操作阻塞了事件循环，对服务器的任何后续请求都必须等待繁重的操作完成。</p><p id="8e4b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了解决这个问题，我们引入了fork方法。我们将简单地复制需要时间的代码块，并把它放在子进程文件中。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="1e81" class="mr ln in mm b gy ms mt l mu mv">//child.js - Child</span><span id="e375" class="mr ln in mm b gy mw mt l mu mv">process.on("message", msg =&gt; {<br/>    let counter = 0;<br/>    while (counter &lt; 9000000000) {<br/>        counter++;<br/>    }<br/>    process.send(`${counter} iterations completed \\n`)<br/>})</span></pre><p id="3f27" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在父文件中，我需要首先创建一个子进程。在此之后，我们可以向孩子发送一条消息，通知他需要开始繁重的操作，最后，一旦操作完成，我们会监听收到的任何消息。然后，该消息作为响应被发送回用户。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="0973" class="mr ln in mm b gy ms mt l mu mv">//script.js - Parent</span><span id="3c7d" class="mr ln in mm b gy mw mt l mu mv">...<br/>if(req.url == "/heavy"){<br/>    const child = <strong class="mm io">fork</strong>("./child.js");<br/>    child.<strong class="mm io">send</strong>("Start")<br/>    child.on("<strong class="mm io">message</strong>", msg =&gt; <strong class="mm io">res.end</strong>(msg))<br/>...</span></pre><p id="6267" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果您尝试向重端点发出请求，然后向轻端点发出请求，您会发现它不再阻塞了。即使繁重的请求正在后台运行，它也会发出较轻的请求。所以它基本上将繁重的操作卸载到一个单独的进程中，同时继续处理文件中的其余代码。这就是如何使用fork方法在nodeJs中执行多任务。</p><h2 id="62c4" class="mr ln in bd lo mx my dn ls mz na dp lw kx nb nc ly lb nd ne ma lf nf ng mc nh bi translated">结论</h2><p id="2197" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我相信关于这四种方法的信息已经足够了。很明显，你可以在互联网上找到更多关于这些方法的信息，但是这篇简短的帖子应该会给你一个基本的概念，告诉你事情是如何工作的，以及你如何在你的项目中实现它们。</p><p id="4647" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.youtube.com/playlist?list=PL62km_yqC3ZEV0wKbLbd3CG-2zt3oDkes" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">你可以在这里观看这个教程的视频版本。</em> </strong> </a></p><p id="14d6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何疑问或建议，你可以在评论中提出，或者通过我的任何一个社交网站与我联系。干杯！</p><p id="f412" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/><a class="ae lk" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae lk" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae lk" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">GitHub</a></p></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="555b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">更多内容看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">说白了就是</em> </strong> </a> <em class="ll">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">免费每周简讯</em> </strong> </a> <em class="ll">。关注我们</em> <a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">推特</em></strong></a><strong class="kq io"><em class="ll"/></strong><em class="ll">和</em><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">LinkedIn</em></strong></a><em class="ll">。查看我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">社区不和谐</em> </strong> </a> <em class="ll">加入我们的</em> <a class="ae lk" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">人才集体</em> </strong> </a> <em class="ll">。</em></p></div></div>    
</body>
</html>