<html>
<head>
<title>How To Send Ajax Requests When Closing a Page</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关闭页面时如何发送Ajax请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-send-ajax-requests-when-closing-a-page-8298ceeedf9?source=collection_archive---------2-----------------------#2022-12-15">https://javascript.plainenglish.io/how-to-send-ajax-requests-when-closing-a-page-8298ceeedf9?source=collection_archive---------2-----------------------#2022-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="72df" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关闭页面时发送Ajax请求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/868aa93676f20a66b4025b4dca535c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNFmtP1OvMXOieBiRgs6kQ.png"/></div></div></figure><p id="0382" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时我们需要做一些报告来记录用户离开页面时的行为。或者发送一个服务器ajax请求通知服务器用户已经离开，比如一个直播间的结账操作。</p><p id="ecbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文分为两个部分来解释如何完成退出行为报告。</p><h2 id="24f6" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">1.事件监听</h2><p id="71bd" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">浏览器有两个事件可以用来监听页面关闭，<code class="fe ml mm mn mo b">beforeunload </code>和<code class="fe ml mm mn mo b">unload</code>。<br/> <code class="fe ml mm mn mo b">beforeunload </code>是在文档和资源被调用时将被关闭，此时文档仍然可见，并且在发生这种关闭时仍然可以被取消。例如，下面的写法将允许用户在刷新或关闭页面时弹出一个窗口来提醒用户是否关闭。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="56b6" class="mt lo iq mo b be mu mv l mw mx">window.addEventListener("beforeunload", function (event) {<br/>  // Cancel the event as stated by the standard.<br/>  event.preventDefault();<br/>  // Chrome requires returnValue to be set.<br/>  event.returnValue = '';<br/>});</span></pre><p id="19ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ml mm mn mo b">unload </code>是在页面已经被卸载时，文档处于的状态:</p><ol class=""><li id="400d" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">所有资源仍然存在(图像、iframe等。);</li><li id="1a10" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">对于用户来说，所有的资源都是不可见的；</li><li id="513e" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">界面交互无效(window.open、alert、confirm等。);</li><li id="252d" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">该错误不会停止卸载文档的过程。</li></ol><p id="83b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于以上两种方法你可以实现监听关闭页面的事件，为了安全起见，你可以监听这两个事件。然后做监听器函数的处理，让关闭事件只调用一次。</p><h2 id="0d47" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">2.请求发送</h2><p id="fbee" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">有了上面的倾听者，事情只完成了一半。如果我们直接在监听器中发送ajax请求，我们会发现请求被浏览器中止，无法发送出去。当页面卸载时，浏览器不保证异步请求会成功发出。</p><p id="d89a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有几种方法可以解决这个问题。</p><p id="b5d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">选项1:发送同步ajax请求</strong></p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="8256" class="mt lo iq mo b be mu mv l mw mx">var oAjax = new XMLHttpRequest();<br/><br/>oAjax.open('POST', url + '/user/register', false);//false is synchronization request<br/><br/>oAjax.setRequestHeader("Content-type", "application/x-www-form-urlencoded");<br/><br/>oAjax.onreadystatechange = function() {<br/>    if (oAjax.readyState == 4 &amp;&amp; oAjax.status == 200) {<br/>        var data = JSON.parse(oAjax.responseText);<br/>    } else {<br/>        console.log(oAjax);<br/>    }<br/>};<br/><br/>oAjax.send('a=1&amp;b=2');</span></pre><p id="19ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法是有效的，但是用户需要在关闭页面之前等待请求完成。这对用户来说不是一个好的体验。</p><p id="c66c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">选项2:发送异步请求，忽略服务器端的ajax中止</strong></p><p id="02af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然异步请求会被浏览器中止，但是如果服务器可以忽略中止并仍然正常执行，这是可能的。比如PHP有ignore_user_abort函数来忽略abort，需要后端修改，一般不可行。</p><p id="5037" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">选项3:使用navigator.sendBeacon发送异步请求</strong></p><p id="5e13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">参考MDN:</p><div class="nm nn gp gr no np"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">navigator . send beacon()-Web API | MDN</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">当用户完成页面时，网站通常希望向服务器发送分析或诊断信息。最…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">developer.mozilla.org</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kp np"/></div></div></a></div><p id="6ba7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从介绍中可以看出，这个方法是用来在用户离开时发送请求的。非常适合这个场景。其使用方法如下。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="ec89" class="mt lo iq mo b be mu mv l mw mx">navigator.sendBeacon(url [, data]);</span></pre><p id="eddb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">sendBeacon支持发送的数据可以是<code class="fe ml mm mn mo b">ArrayBufferView</code>、<code class="fe ml mm mn mo b">Blob</code>、<code class="fe ml mm mn mo b">DOMString</code>或<code class="fe ml mm mn mo b">FormData </code>类型的数据。<br/>这里有几种使用sendBeacon发送请求的方式，你可以修改报头和内容的格式，因为一般与服务器的通信方式是固定的，如果你修改了报头或内容，服务器将无法正确识别。</p><p id="8b39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(1)使用blob发送使用Blob发送的好处是可以定义自己的内容格式和头，比如下面的方式将content-type设置为application/x-www-form-urlencoded。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="816c" class="mt lo iq mo b be mu mv l mw mx">blob = new Blob([`room_id=123`], {type : 'application/x-www-form-urlencoded'});<br/>navigator.sendBeacon("/cgi-bin/leave_room", blob);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d52bc0470c0985d3ae4f7ebf7f0ed731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*VoLmb1jPTKB6x3pytKJFGA.png"/></div></figure><p id="15a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(2)使用FormData对象，但这样content-type将被设置为“multipart/form-data”。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="e5a0" class="mt lo iq mo b be mu mv l mw mx">var fd = new FormData();<br/>fd.append('room_id', 123);<br/>navigator.sendBeacon("/cgi-bin/leave_room", fd);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/fab9f9cb6dc7a74b47eb3d16eaed522f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*VxeiJM6Qx6b_Je6rVAiaow.png"/></div></figure><p id="c3db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(3)数据也可以使用URLSearchParams对象，并将content-type设置为“text/plain；charset=UTF-8 "。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="a7c3" class="mt lo iq mo b be mu mv l mw mx">var params = new URLSearchParams({ room_id: 123 })<br/>navigator.sendBeacon("/cgi-bin/leave_room", params);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/823bcf7087ea374b72c9948d6555f529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uua20LvpZi7na-NX_qe17A.png"/></div></div></figure><p id="9e0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过尝试，可以发现使用blob发送更加方便，内容的设置也更加灵活。如果抢到包后发送的消息没有被后台识别，可以尝试修改内容的字符串或头，找到合适的方式发送请求。</p><p id="4346" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="oh">更多内容看</em> <a class="ae oi" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oh">说白了就是io </em> </strong> </a> <em class="oh">。报名参加我们的</em> <a class="ae oi" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oh">免费周报</em> </strong> </a> <em class="oh">。关注我们关于</em><a class="ae oi" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oh">Twitter</em></strong></a>，<a class="ae oi" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oh">LinkedIn</em></strong></a><em class="oh">，</em><a class="ae oi" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oh">YouTube</em></strong></a><em class="oh">，以及</em> <a class="ae oi" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oh">不和</em> </strong> </a> <strong class="kt ir"> <em class="oh">。</em> </strong></p><p id="d004" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="oh">对缩放您的软件启动感兴趣</em> </strong> <em class="oh">？检查出</em> <a class="ae oi" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oh">电路</em> </strong> </a> <em class="oh">。</em></p></div></div>    
</body>
</html>