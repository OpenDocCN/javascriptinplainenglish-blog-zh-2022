<html>
<head>
<title>Why JavaScript is called Prototype-based?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript为什么叫基于原型？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-javascript-is-called-prototype-based-e9326562bf43?source=collection_archive---------8-----------------------#2022-01-06">https://javascript.plainenglish.io/why-javascript-is-called-prototype-based-e9326562bf43?source=collection_archive---------8-----------------------#2022-01-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7cb5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是基于原型的编程？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d20e9fb7980c62ddcf0ed2573ccdf00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WvJGRMt-M9BzkB9ijDeQfA.png"/></div></div></figure><p id="0de8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">基于原型的编程</strong>是一种面向对象的编程风格，与显式使用基于类的继承相比，通过重用现有对象的属性和方法来实现逻辑或行为的重用。</p><p id="39ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">行为被重用的对象被称为<strong class="kq io">原型。逻辑的重用可以通过克隆基本对象或从原型创建新对象来实现，这同样适用于扩展或添加新行为。</strong></p><p id="d3b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript是一种支持基于原型的继承模型的编程语言。这种模型鼓励开发人员首先关注应用程序的行为，然后再考虑将这些对象分组到更正式的分类系统中，比如类。JavaScript也允许在运行时修改原型。</p><p id="f121" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如您所知，JavaScript中的一切都是对象&amp;当涉及到继承时，它使用Object作为唯一的构造。每个对象都有一个私有属性，叫做<strong class="kq io">原型</strong>，包含对其基本对象类型的引用。这个原型对象又可以有自己的原型对象&amp;等等，直到它到达原型为空的点，这是最后的链接。这在JavaScript中被称为<strong class="kq io">原型链</strong>。</p><p id="609d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据ES2015，读取对象原型的API如下:</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="88dc" class="lp lq in ll b gy lr ls l lt lu">Object.getPrototypeOf();<br/>Object.setPrototypeOf();</span></pre><p id="5bb4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一些例子:</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="81e9" class="lp lq in ll b gy lr ls l lt lu">const foo = {fooProp:true}<br/>const bar = {barProp: true}</span><span id="56cf" class="lp lq in ll b gy lv ls l lt lu">/* logs the prototype of 'foo' */<br/>console.log(foo.__proto__);<br/>console.log(Object.getPrototypeOf());</span><span id="b0ff" class="lp lq in ll b gy lv ls l lt lu">/* try to access 'foo.barProp'<br/> * returns 'undefined' <br/> * as 'barProp' is not a defined inside 'foo' <br/> */<br/>console.log(foo.barProp);</span><span id="122a" class="lp lq in ll b gy lv ls l lt lu">/* lets change the prototype of 'foo' */<br/>Object.setPrototypeOf(foo, bar);</span><span id="f0f8" class="lp lq in ll b gy lv ls l lt lu">/* Now, lets check again <br/> * it will return 'true'<br/> */<br/>console.log(foo.barProp);</span></pre><p id="576d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">上面的例子是如何打印出<code class="fe lw lx ly ll b">foo.barProp</code>的值的？当从对象中访问属性时，首先在对象中查找，如果在对象中没有找到，则在对象的原型及其原型中扩展查找，依此类推，直到原型为<code class="fe lw lx ly ll b">null</code>。甚至方法也可以以同样的方式重用和扩展，因为JavaScript中没有类方法原则，方法就像是对象的另一个属性。从而在没有基于类的继承的情况下实现行为或逻辑重用。</p><p id="23d7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当执行继承的函数时，<code class="fe lw lx ly ll b">this</code>值将指向继承的对象&amp;，而不是定义函数的原型对象。</p><p id="9b0c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">顺便提一下，ES2015还提供了一些类&amp;如果需要的话也可以使用。但只是语法糖&amp;依赖于基于原型的继承</p><p id="3152" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">希望它能帮助你理解JavaScript中基于原型的继承。请分享你的想法。</p><p id="a826" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要了解更多详细信息，推荐MDN文档。</p><p id="3850" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lz">关注我，获取更多关于JavaScript &amp; Web开发的有趣帖子。还有，请给个</em> <a class="ae ma" href="https://twitter.com/jsbasics_dev" rel="noopener ugc nofollow" target="_blank"> <em class="lz">跟着</em> </a> <em class="lz">上推特。</em></p><p id="b545" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lz">更多内容看</em> <a class="ae ma" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lz">说白了. io </em> </a> <em class="lz">。报名参加我们的</em> <a class="ae ma" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lz">免费每周简讯</em> </a> <em class="lz">。在我们的</em> <a class="ae ma" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="lz">社区</em> </a> <em class="lz">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>