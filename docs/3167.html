<html>
<head>
<title>Let’s Understand Chrome V8 — Chapter 16: What is Runtime? Why is it important?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来了解一下Chrome V8——第十六章:什么是运行时？为什么重要？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-understand-chrome-v8-chapter-16-what-is-runtime-why-is-it-important-8c808e58843d?source=collection_archive---------9-----------------------#2022-08-05">https://javascript.plainenglish.io/lets-understand-chrome-v8-chapter-16-what-is-runtime-why-is-it-important-8c808e58843d?source=collection_archive---------9-----------------------#2022-08-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7ce1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">运行时的初始化和调用教程。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2229cb027639f57877eb360bf75cd927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCFNVeb4ds9hl7WF-NP-kw.png"/></div></div></figure><p id="fd97" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">欢迎阅读</em> <a class="ae ll" href="https://medium.com/@huidou" rel="noopener"> <em class="lk">其他章节让我们来了解一下Chrome V8 </em> </a></p><p id="c913" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从实现的角度来看:内置是通过Runtime、Torque (CodeStubAssembler)、JavaScript、ASM实现的。以下是V8的官方描述:</p><p id="766d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk"> V8的内置功能可以用许多不同的方法来实现(每种方法都有不同的权衡):</em></p><p id="809e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">依赖于平台的汇编语言:可以很高效，但是需要手动移植到所有平台，并且很难维护。</em></p><p id="b175" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">C++:在风格上与运行时函数非常相似，可以使用V8强大的运行时功能，但通常不适合性能敏感的领域。</p><p id="4c42" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk"> JavaScript:简洁可读的代码，可以访问快速的内部函数，但频繁使用缓慢的运行时调用，由于类型污染而受到不可预测的性能影响，以及围绕(复杂且不明显的)JS语义的微妙问题。</em></p><p id="e281" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk"> CodeStubAssembler:提供高效的低级功能，非常接近汇编语言，同时保持平台无关性和可读性。</em></p><p id="487c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">什么是运行时？这是一种实现V8内置的方法。</p><p id="97aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为什么重要？如果你懂了，就意味着你知道了四分之一内置的设计和实现。</p><p id="e780" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这篇文章中，我将谈论运行时的初始化和调用。通过学习它们，我们将对运行时的工作流程有一个全面的了解。</p><h1 id="54d6" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated"><strong class="ak"> 1。初始化</strong></h1><p id="852b" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">运行时是V8的基础组件，它在V8启动期间初始化，并由ExternalReferenceTable管理，ExternalReferenceTable是一个用于保存外部资源的指针数组。下面的Init()负责ExternalReferenceTable的初始化。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2889" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的代码中，第10~20行包含了很多基础组件的初始化，比如解释器和compiler_dispatcher。第31行是保存运行时的ExternalReferenceTable，见下文。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6351" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的代码中，第7行是运行时AddRuntimeFunctions的初始化，下面是。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="43bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">AddRuntimeFunctions有一个参数索引。在我的V8中，有468个运行时函数，第一个函数在ExternalReferenceTable[index = 430]，最后一个在ExternalReferenceTable[430+468–1]。</p><p id="21c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如上所述，ExternalReferenceTable是一个指针数组，它不仅保存运行时，还保存其他内容。我们将在以后讨论这些东西。</p><p id="c98d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">图1将运行时函数添加到ExternalReferenceTable中，并让您有机会在局部变量窗口中观察runtime_functions。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ml"><img src="../Images/15d6f7f3009b2cb9bbdb5bfbcd15cb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*td4mxv56HshIRscTQLXc2g.png"/></div></div></figure><p id="354b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第11行Create()根据运行时ID创建一个条目，并最终将其存储到ExternalReferenceTable中，见下文。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="fb43" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Create()调用FunctionForId()返回kIntrinsicFunctions，该函数在下面的中定义。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d2a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">什么是kIntrinsicFunctions？实际上，它是一个数组，其中每个元素都是一个6元组。在下面的6元组中，第一个是唯一的枚举ID，第三个是帮助不大的助记符，第四个是函数地址，最后两个是参数计数器和返回计数器。如你所见，它正在添加运行时DebugPrint，即初始化。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="838a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看ExternalReferenceTable。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d491" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第7–17行定义了由ExternalReferenceTable管理的所有内置，即所有运行时。第25–35行定义了ExternalReferenceTable的所有私有方法。看一下第35行，它是保存运行时地址的数组。地址为“使用地址= uintptr_t”。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mm"><img src="../Images/c27ff27a0515f8bf1c1cb1fe108cb632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n5Sr6loxWDwm6glRoFQFAA.png"/></div></div></figure><p id="e988" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">图2给出了三个要点，首先是函数Add()；第二，帮助你观察变量ref _ addr _最后是调用栈，可以帮助你调试这段代码。</p><h1 id="be38" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated"><strong class="ak"> 2。调用运行时</strong></h1><p id="e63a" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">在上一篇文章中，我写了一个运行时函数—myruntimefunction，并描述了运行时的定义。</p><p id="1c2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里，我将讨论字节码中常见的CallRuntime，它可以帮助您理解字节码和运行时之间的交互。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c3f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第2行，第一个参数是FunctionID，它是上面提到的枚举ID；第二个是将来要解释的当前语境；最后一个是传递给特定运行时函数的参数列表。</p><p id="3957" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在CallRuntimeImpl中，第11行取出kIntrinsicFunctions中存储的结果大小；第14行调用CallRuntimeWithCEntryImpl。</p><p id="a118" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在CallRuntimeWithCEntryImpl中，第26行对参数进行计数；第28–31行将参数和上下文添加到输入数组中；第33行调用特定的运行时。</p><p id="94d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注:</strong>要想完全理解CallRuntimeImpl的原理，节点海是必备知识。</p><p id="b052" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">调试CallRuntimeImpl只能在汇编环境下完成，我有一些经验和技巧但是很枯燥和复杂，如果你想知道，请联系我。</p><p id="57a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">好了，这部分就到此为止了。下次再见，保重！</em></p><p id="1bb7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我的博客是cncyclops.com的。如果你有任何问题，请联系我。</p><p id="b60f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">微信</strong> : qq9123013 <strong class="kq io">邮箱</strong>:v8blink@outlook.com</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="27b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容请看</em><a class="ae ll" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a><em class="lk">。报名参加我们的</em> <a class="ae ll" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。关注我们关于</em><a class="ae ll" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">Twitter</em></strong></a><a class="ae ll" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">，以及</em> <a class="ae ll" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">不和</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>