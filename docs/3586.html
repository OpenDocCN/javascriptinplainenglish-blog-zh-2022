<html>
<head>
<title>Using Action Cable in a Rails/React App Part II: Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rails/React应用程序中使用Action Cable第二部分:实现</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-action-cable-in-a-rails-react-app-part-ii-implementation-db8b1762c794?source=collection_archive---------9-----------------------#2022-09-09">https://javascript.plainenglish.io/using-action-cable-in-a-rails-react-app-part-ii-implementation-db8b1762c794?source=collection_archive---------9-----------------------#2022-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jk jl jm jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/b0436eed017903664a5acf603a6d4879.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-rWGSpRH4T4LgU39RR099w.png"/></div></figure><p id="1b30" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这篇文章的第一部分讨论了如何配置一个使用Rails API后端和React前端来处理Action Cable的应用程序</p><p id="416b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">第二部分讨论在Rails/React应用程序中实际实现Action Cable</p><p id="e873" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关于Action Cable教程，我注意到的一件事是，不管是官方的还是其他的，他们中的许多人试图在某种示例应用程序的上下文中教授Action Cable，通常是某种聊天应用程序。虽然这对于教程来说是相当标准的做法，但在这种情况下，我觉得有时这只会让事情变得更加混乱。我经常觉得好像有人在教我如何创建一个聊天应用程序，而不是专门教我Action Cable。有时这意味着我不得不筛选代码行，这些代码不仅与我需要的东西大部分不相关，而且通常是以我不熟悉的方式编写的。将不使用钩子的React类组件翻译成使用钩子的函数组件可能是一项需要开发的有用技能，但是当我试图弄清楚Action Cable时，这几乎不是我想做的事情。这带来的另一个挑战是，由于所有东西都是作为一个大应用程序的一部分呈现的，所以有时很难将东西分解开来并孤立地识别特定的功能。</p><p id="3bea" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你喜欢用这种方式学习(我相信很多人都喜欢)，那太好了！有很多很棒的资源，我会在本文的最后将它们链接起来。每个人都是不同的，对一个人有效的方法对另一个人可能更难。如果你像我一样，喜欢把所有的东西都分成小的、独立的部分，那么希望你已经在行动电缆研究中找到了你想要的东西。我将尝试解释每一步，然后也许会为每一步举一个小例子来说明我的意思。我将有意避免过多地解释Action Cable到底是什么以及它使用的术语，因为<a class="ae kp" href="https://guides.rubyonrails.org/action_cable_overview.html" rel="noopener ugc nofollow" target="_blank"> Rails Guide </a>在不需要我的帮助的情况下做得相当好。如果你对术语不熟悉，我建议你先看看指南，完成后再回来。</p><h1 id="2c79" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">实施行动电缆:后端</h1><h2 id="344c" class="lo kr in bd ks lp lq dn kw lr ls dp la kc lt lu le kg lv lw li kk lx ly lm lz bi translated">建立连接</h2><p id="a205" class="pw-post-body-paragraph jr js in jt b ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko ig bi translated">为了使事情尽可能简单(参考Rails指南的<a class="ae kp" href="https://guides.rubyonrails.org/action_cable_overview.html#server-side-components-connections" rel="noopener ugc nofollow" target="_blank">这一节</a>以获得更深入的解释)，一个连接对象是所有频道订阅的父对象(我们将到达这些，不要惊慌！)用于特定WebSocket连接。这使我们能够识别所有订阅的当前消费者。这通常是您对消费者进行身份验证的地方。<code class="fe mf mg mh mi b">Connection</code>类位于<code class="fe mf mg mh mi b">/app/channels/application_cable/connection.rb</code>中，看起来像这样:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="f075" class="mr kr in mi b be ms mt l mu mv">module ApplicationCable<br/>  class Connection &lt; ActionCable::Connection::Base<br/>  end<br/>end</span></pre><p id="ce8e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">设置它以识别当前用户的最简单方法是这样做:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="4ebf" class="mr kr in mi b be ms mt l mu mv">module ApplicationCable<br/>  class Connection &lt; ActionCable::Connection::Base<br/>    identified_by :current_user<br/><br/>    def connect<br/>      # I personally used Rails' session hash to identify the current user.<br/>      # There are a number of other ways to do this<br/>      self.current_user = User.find(cookies.encrypted["_session_id"]["user_id"])<br/>    end<br/><br/>  end<br/>end</span></pre><p id="d934" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mf mg mh mi b">identified_by :current_user</code>让您的所有频道都可以访问<code class="fe mf mg mh mi b">:current_user</code>，这在<code class="fe mf mg mh mi b">connect</code>中定义。根据您处理auth的方式，您可能不需要这样做，所以不要太担心。同样，Rails指南更详细，请随意探索。</p><h2 id="6fcc" class="lo kr in bd ks lp lq dn kw lr ls dp la kc lt lu le kg lv lw li kk lx ly lm lz bi translated">频道</h2><p id="aefc" class="pw-post-body-paragraph jr js in jt b ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko ig bi translated">在我进入通道之前，快速解释一下什么是流可能是有益的。一个流由一个<code class="fe mf mg mh mi b">string</code>(或者一个数据库模型的实例，如果您使用的是<code class="fe mf mg mh mi b">stream_for</code>)表示，它决定了要从特定通道传输的数据。如果我订阅了一个频道，这通常意味着我正在从该频道“流式传输”,并将接收广播到我订阅的流的信息。我们稍后将更多地探索流，包括如何使用<code class="fe mf mg mh mi b">params</code>个性化流。</p><p id="324f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">不管出于什么原因，我见过的大多数教程都把通道说得比实际更复杂。信道基本上是一种组织你的流和处理它们的订阅者的方法。让一个通道处理多个不相关的流在技术上是可能的，但是这不是一个很好的关注点分离。如果您在一个通道中有一堆不同的流，您的代码将很快变得完全不可读。为了简单起见，我将具体分析一个频道应该包括什么，并让您决定您的应用程序需要多少频道。</p><p id="f9d7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">创建通道很简单，只需要一个简单的Rails生成器:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="78b5" class="mr kr in mi b be ms mt l mu mv">rails g channel example_channel</span></pre><p id="3fdb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这将在<code class="fe mf mg mh mi b">/app/channels</code>中创建一个名为<code class="fe mf mg mh mi b">example_channel.rb</code>的文件，您可能已经猜到了。(出于某种原因，至少对我来说，它还试图重新生成<code class="fe mf mg mh mi b">/app/channels/application_channel</code>中的默认文件。我不知道它为什么这样做，当提示我决定是否要覆盖原始文件时，我在终端上输入了一个强调的“N”(否)。)这也将在文件本身中生成一些启动代码。它应该是这样的:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="92c3" class="mr kr in mi b be ms mt l mu mv">class ExampleChannel &lt; ApplicationCable::Channel<br/>  def subscribed<br/>    # stream_from "some_channel"<br/>  end<br/><br/>  def unsubscribed<br/>    # Any cleanup needed when channel is unsubscribed<br/>  end<br/>end</span></pre><p id="21ef" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这些方法实际上做的非常简单。当消费者订阅该频道时，调用<code class="fe mf mg mh mi b">ExampleChannel#subscribed</code>方法。它应该包括发生这种情况时你想做的任何事情的逻辑。<code class="fe mf mg mh mi b">ExampleChannel#unsubscribed</code>当消费者退订时调用。就是这样。句号。<strong class="jt io">这些方法中没有任何东西初始化(或结束)订阅，也不会神奇地向订阅者发送任何信息</strong> <em class="mw">。你让他们做什么，他们就做什么。你可以在<code class="fe mf mg mh mi b">ExampleChannel#subscribed</code>中输入<code class="fe mf mg mh mi b">puts “Hello World”</code>，任何时候消费者订阅你的频道，“Hello World”就会被打印到控制台<em class="mw">上，其他什么也不会发生。</em></em></p><p id="7b6f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么这些方法通常包括什么呢？Rails在自动生成的注释中很好地解释了这一点。当消费者订阅时，您通常会希望通过向他们订阅与该频道相关联的流，来授予他们对将要广播给他们的任何信息的访问权限。这样做很简单:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="d176" class="mr kr in mi b be ms mt l mu mv">stream_from "example_channel"</span></pre><p id="937d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">快速提示:有两种方法可以做到这一点，用<code class="fe mf mg mh mi b">stream_from</code>和<code class="fe mf mg mh mi b">stream_for</code>。我将坚持使用<code class="fe mf mg mh mi b">stream_from</code>，因为我发现它更简单、更容易使用。你可以查看这篇文章来深入探究这种差异。</p><p id="b6d1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当用户取消订阅时，您通常想要停止流(通常通过将<code class="fe mf mg mh mi b">stop_all_streams</code>添加到<code class="fe mf mg mh mi b">ExampleChannel#unsubscribed</code>)。这是这些方法最基本也是最普遍的用法。根据用户订阅或取消订阅时您需要做的事情，您可能需要向这些方法中添加其他特定于您的应用程序的逻辑，但这取决于您。</p><p id="7624" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以在channel类中定义的另一个方法是名为<code class="fe mf mg mh mi b">received</code>的实例方法。每当从订户(前端)发送数据并被服务器接收时，就调用<code class="fe mf mg mh mi b">received</code>方法。它将该数据作为参数，在方法内部提供对接收数据的访问。让我们用一个例子来说明这一点。假设你有一个聊天应用。您的用户发送一条新消息，您的前端将该消息发送给<code class="fe mf mg mh mi b">ConversationChannel</code>。您需要将消息保存到数据库中，并在同一个对话中广播给其他人。(通过POST请求发送新消息并让您的控制器处理必要的逻辑可能更好(也更传统)，但出于本例的目的，我们将把它发送到通道)。<code class="fe mf mg mh mi b">ConversationChannel#received</code>最终会变成这样:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="127d" class="mr kr in mi b be ms mt l mu mv">def received data<br/>  # remember, the data parameter represents whatever is sent from the<br/>  # subscriber, in this case a message object<br/>  message = Message.create(data)<br/>  ActionCable.server.broadcast("conversation_channel", message)<br/>end</span></pre><p id="c440" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">不要担心最后一行在做什么，我们很快就会开始广播。记住，每次一个新的消息被发送到通道，这个<code class="fe mf mg mh mi b">received</code>方法将被调用，新的消息作为一个参数被传递。</p><h2 id="9c14" class="lo kr in bd ks lp lq dn kw lr ls dp la kc lt lu le kg lv lw li kk lx ly lm lz bi translated">流</h2><p id="0023" class="pw-post-body-paragraph jr js in jt b ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko ig bi translated">当消费者订阅一个频道时，他们从该频道“流式传输”,并将接收广播到该流而不是该频道的信息。这个区别很重要。<strong class="jt io">信道将订户与流匹配，然而，订户接收的数据取决于流，而不(仅仅)取决于信道。</strong>如果您有个性化的流(通常会有)，同一频道的多个订户可能会收到数据差异很大的广播。</p><p id="09ce" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以通过在流的名称中插入<code class="fe mf mg mh mi b">params</code>(从前端发送，我们稍后会讲到)来个性化流。这允许您为每个频道实例创建个性化的流。例如，在聊天应用程序中，一个用户可以与多个用户进行多次对话。所有这些对话都具有相同的基本结构(用户可以发送和接收消息)，因此它们都订阅了相同通道的实例，<code class="fe mf mg mh mi b">ConversationChannel</code>。然而，对话的实际内容因用户和对话而异。如果用户A和用户B聊天，用户C和用户D聊天，他们都会订阅<code class="fe mf mg mh mi b">ConversationChannel</code>，但是每个用户的流必须是不同的。(如果每个人都能收到其他人的消息，那么祝你好运，让任何人都能使用你的应用！).假设您有一种方法来识别特定的对话(比如有一个<code class="fe mf mg mh mi b">Conversation</code>模型来跟踪特定对话的实例并将其保存到数据库中)，您可以将其插入到流的名称中:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="2c81" class="mr kr in mi b be ms mt l mu mv">stream_from "conversation_#{params[:conversation_id}"</span></pre><p id="6b4c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">并且对于单个频道的每个实例，以唯一的流结束。这样，每个会话都有自己的流，正确的数据可以广播到正确的会话，从而进入下一步，</p><h2 id="5e73" class="lo kr in bd ks lp lq dn kw lr ls dp la kc lt lu le kg lv lw li kk lx ly lm lz bi translated">广播</h2><p id="10c5" class="pw-post-body-paragraph jr js in jt b ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko ig bi translated">广播实际上是向用户发送数据的过程。实现起来极其简单。基本代码如下所示:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="e4eb" class="mr kr in mi b be ms mt l mu mv">ActionCable.server.broadcast("&lt;name_of_stream&gt;", data)</span></pre><p id="d715" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mf mg mh mi b">:broadcast</code>方法的第一个参数是您要广播到的流的名称。第二个是正在广播的实际数据。在应用程序中的任何地方都可以调用这个函数，只要你能够访问你需要发送的信息，并且能够访问插入到流名称中的任何一个<code class="fe mf mg mh mi b">params</code>。所以，回到聊天应用的例子。让我们假设您在您的<code class="fe mf mg mh mi b">Message</code>模型和<code class="fe mf mg mh mi b">Conversation</code>模型之间建立了一个关系(正如您应该做的那样)。创建了新消息，现在需要将其广播给正确的订户。假设新的消息实例以<code class="fe mf mg mh mi b">message</code>的形式保存到一个变量中，那么您应该这样传播它:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="a75c" class="mr kr in mi b be ms mt l mu mv"><br/>ActionCable.server.broadcast("conversation_#{message.conversation.id}", message)</span></pre><p id="2848" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请注意我是如何将对话的id(使用活动记录关联)插入到流名称中的，以确保消息被广播到与正确的对话相关联的流中。</p><p id="1ab4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关于序列化程序的注意事项:广播数据库模型的实例将不会使用与该模型关联的序列化程序。如果您想要序列化您正在广播的数据，我建议为您的模型定义一个实例方法，该方法将手动序列化您将要广播的任何内容。根据消息示例，将以下代码添加到<code class="fe mf mg mh mi b">/app/models/message.rb</code>:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="5ae1" class="mr kr in mi b be ms mt l mu mv">def serialize<br/>  serialized_message = ActiveModelSerializers::Adapter::Json.new(<br/>  MessageSerializer.new(self)<br/>  ).serializable_hash<br/>  serialized_message[:message]<br/>end</span></pre><p id="d3b4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，在<code class="fe mf mg mh mi b">Message</code>的任何实例上调用<code class="fe mf mg mh mi b">Message#serialize</code>将返回一个带有序列化消息的散列。在上面的示例中，要发送序列化的消息，只需添加以下内容:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="2d66" class="mr kr in mi b be ms mt l mu mv">message = message.serialize<br/>ActionCable.server.broadcast(<br/>  "conversation_#{message.conversation.id}", message<br/>)</span></pre><p id="1d46" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好了，让我们用一个聊天应用程序的例子从头到尾快速演示一下这个过程。我们的模型和关联:</p><ul class=""><li id="32b4" class="mx my in jt b ju jv jy jz kc mz kg na kk nb ko nc nd ne nf bi translated"><code class="fe mf mg mh mi b">User</code>:有很多消息，通过消息有很多对话</li><li id="0c3f" class="mx my in jt b ju ng jy nh kc ni kg nj kk nk ko nc nd ne nf bi translated"><code class="fe mf mg mh mi b">Conversation</code>:有很多信息</li><li id="8e53" class="mx my in jt b ju ng jy nh kc ni kg nj kk nk ko nc nd ne nf bi translated"><code class="fe mf mg mh mi b">Message</code>:属于用户，属于对话。</li></ul><p id="558b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">用户通过在前端创建订阅来加入(预先存在的，让它变得简单)对话(这个过程我们还没有介绍)。这调用了<code class="fe mf mg mh mi b">ConversationChannel#subscribed</code>，正如我们已经说过的，看起来像这样:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="2aa9" class="mr kr in mi b be ms mt l mu mv">def subscribed<br/>    stream_from "conversation_#{params[:conversation_id]}"<br/>end</span></pre><p id="2980" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请记住，正确对话的<code class="fe mf mg mh mi b">id</code>是作为<code class="fe mf mg mh mi b">params</code>从消费者处发出的。让我们假设这个特定对话的<code class="fe mf mg mh mi b">id</code>是3。这意味着这个消费者订阅的流的名称实际上是<code class="fe mf mg mh mi b">"conversation_3"</code>。现在，任何广播给<code class="fe mf mg mh mi b">"conversation_3"</code>的东西都会被这个用户接收到。用户现在决定向该对话发送消息。我们将放弃之前向<code class="fe mf mg mh mi b">ConversationChannel#received</code>发送消息的例子，转而使用更传统的POST请求。处理这个POST请求的控制器动作必须保存消息，并将其广播给<code class="fe mf mg mh mi b">"conversation_3"</code>的所有其他订户。它看起来会像这样:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="061b" class="mr kr in mi b be ms mt l mu mv">def create<br/>  # We are assuming that the conversation_id foreign key is being sent in<br/>  # the params of the request and the user's id is saved to the session hash.<br/>  # There are other ways this can be done<br/>  user = User.find(session[:user_id])<br/>  message = user.messages.create(params)<br/>  # Using the Message#serialize instance method we defined before<br/>  serialized_message = message.serialize<br/>  ActionCable.server.broadcast("conversation_#{message.conversation.id}", serialized_message)<br/>end</span></pre><p id="a377" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这里，我们保存消息并将其广播给<code class="fe mf mg mh mi b">"conversation_3"</code>的所有订阅者，这将由前端在您认为合适的时候处理(大概是作为对话的一部分呈现在浏览器中)。</p><p id="a830" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这几乎涵盖了Action Cable的基本后端设置！还有更多的探索，但这应该足以让它工作。让我们把注意力转向前端，以及如何让我们的React应用程序连接到我们的WebSocket，以便接收和发送数据。</p><h1 id="80d0" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">实施行动电缆:反应前端</h1><p id="fadd" class="pw-post-body-paragraph jr js in jt b ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko ig bi translated">学习使用带有独立React前端的Action Cable(相对于全栈Rails应用程序)是一个令人望而生畏的前景。由于没有可用的官方文档，我不得不求助于其他开发人员的博客帖子。没有他们，我永远也不会走到今天，为此我心存感激。然而，在Action Cable教程中似乎是一个常见的主题，相对简单的概念经常以一种使它们看起来(至少对我来说)比实际更复杂的方式呈现。为了保持我的目标，使行动电缆容易，我会尽量简单地提出这一点。</p><p id="b968" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">以下内容将在假设您的消费者已经按照<a class="ae kp" href="https://medium.com/@nkulik/using-action-cable-in-a-rails-react-app-part-i-configuration-c87b14f765a9" rel="noopener">第一部分</a>中的说明使用上下文设置好的情况下呈现。</p><h2 id="3882" class="lo kr in bd ks lp lq dn kw lr ls dp la kc lt lu le kg lv lw li kk lx ly lm lz bi translated">订阅频道</h2><p id="b2cf" class="pw-post-body-paragraph jr js in jt b ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko ig bi translated">您可以在应用程序中随时订阅频道。一些典型的放置通道订阅的地方是在一个<code class="fe mf mg mh mi b">useEffect</code>钩子中，当一个组件被挂载时自动订阅，或者在一个由用户事件触发的回调函数中(比如提交一个表单，点击一个按钮，等等)。</p><p id="47bc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">订阅频道是通过在您的消费者上调用<code class="fe mf mg mh mi b">.subscriptions.create()</code>来完成的(不要担心，我一会儿会清楚地演示这一点)。<code class="fe mf mg mh mi b">create()</code>方法通常有两个参数。第一个是包含相关通道信息的<code class="fe mf mg mh mi b">object</code>。第一个键<code class="fe mf mg mh mi b">channel</code>，以字符串形式指向实际的通道名称。第二个可选键将包含需要作为<code class="fe mf mg mh mi b">params</code>发送到后端的任何内容。比如，通过这个<code class="fe mf mg mh mi b">object</code>:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="593f" class="mr kr in mi b be ms mt l mu mv">{<br/>  channel: "ConversationChannel",<br/>  conversation_id: 5<br/>}</span></pre><p id="ffd0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">to <code class="fe mf mg mh mi b">create()</code>将在后端实例化一个对<code class="fe mf mg mh mi b">ConversationChannel</code>的订阅，它将能够通过params访问对话id“5”。很有可能<code class="fe mf mg mh mi b">ConversationChannel#subscribed</code>会是这样的:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="c428" class="mr kr in mi b be ms mt l mu mv">def subscribed<br/>  # Remember, params[:conversation_id] returns the value of the<br/>  # conversation_id key sent from the frontend, in this case 5<br/>  stream_from "conversation_#{params[:conversation_id}"<br/>end</span></pre><p id="43f1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mf mg mh mi b">create()</code>的第二个参数也需要一个<code class="fe mf mg mh mi b">object</code>。它有一个键<code class="fe mf mg mh mi b">received</code>，指向一个回调函数，当通过通道接收到数据时调用这个函数。这个回调可以是你需要的任何东西。这一点很重要，因为这是处理从通道接收的数据的逻辑。此回调的典型用途是以某种方式更新状态，以便在浏览器中呈现实时信息。</p><p id="906e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">订阅频道的完整代码通常如下所示(编写导入时假设组件位于<code class="fe mf mg mh mi b">/src/components</code>中，CableContext位于<code class="fe mf mg mh mi b">/src/context/cable.js</code>):</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="5f79" class="mr kr in mi b be ms mt l mu mv">import React, { useContext } from 'react';<br/>import { CableContext } from '../context/cable';<br/><br/>const cableContext = useContext(CableContext)<br/>// If you're unfamiliar with using context, the above code<br/>// has nothing to do with Action Cable specifically, it's how we<br/>// grant access to our CableContext in the component that we're<br/>// working with<br/><br/>const newChannel = cableContext.cable.subscribers.create({<br/>  channel: "ConversationChannel",<br/>  conversation_id: 5<br/>},<br/>{<br/>  received: (data) =&gt; console.log(data)<br/>})</span></pre><p id="16d6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这种情况下，我接收到的回调所做的就是将接收到的数据传递给一个<code class="fe mf mg mh mi b">console.log</code>，这样我就可以在控制台中查看它，并庆祝我已经成功创建了一个频道订阅。</p><p id="cd93" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可能已经注意到，我已经将我的订阅保存到了一个变量中(<code class="fe mf mg mh mi b">newChannel</code>)。这将允许我们更容易地调用一些<code class="fe mf mg mh mi b">newChannel</code>自带的内置方法，比如<code class="fe mf mg mh mi b">send()</code>(我们将会谈到)。</p><p id="a016" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们用一个简单但完整的组件来演示订阅过程。假设在后端的某个地方，我们有以下代码:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="404a" class="mr kr in mi b be ms mt l mu mv">ActionCable.server.broadcast(<br/>  "greeting_#{user.id}", { message: "Greetings, #{user.name}!" }<br/>)</span></pre><p id="81b3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">据推测，相关通道的<code class="fe mf mg mh mi b">subscribed</code>实例方法有这样的代码来确保我们的用户订阅了正确的流:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="227f" class="mr kr in mi b be ms mt l mu mv">stream_from "greeting_#{params[:user_id]}"</span></pre><p id="a0f1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们前端的React组件负责订阅这个通道，我们称之为我们的<code class="fe mf mg mh mi b">GreetingChannel</code>，并将广播中接收到的任何消息呈现给DOM。该组件将类似于以下内容:</p><pre class="mj mk ml mm gt mn mi mo bn mp mq bi"><span id="85bb" class="mr kr in mi b be ms mt l mu mv">import React, { useContext, useState, useEffect } from 'react';<br/>import { CableContext } from '../context/cable';<br/><br/>function Greeting({ user }){<br/>  const [greeting, setGreeting] = useState('Hello world!')<br/>  const cableContext = useContext(CableContext)<br/>  <br/>  useEffect(() =&gt; {<br/>    const newChannel = cableContext.cable.subscriptions.create(<br/>    {<br/>      channel: "GreetingChannel",<br/>      user_id: user.id<br/>    },<br/>    {<br/>      // remember, the data being received and passed to the received<br/>      // callback is an object structured like this:<br/>      // { message: "some message" }<br/>      received: (data) =&gt; setGreeting(data.message)<br/>    })<br/>  }, [])<br/>  <br/>  return &lt;h1&gt;{greeting}&lt;/h1&gt;<br/>}<br/><br/>export default Greetingt6</span></pre><p id="5397" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">任何时候从<code class="fe mf mg mh mi b">GreetingChannel</code>广播一个新消息，<code class="fe mf mg mh mi b">received</code>回调将被触发，状态将被更新，自动重新呈现组件，从而在浏览器中显示新的<code class="fe mf mg mh mi b">greeting</code>。</p><p id="f86c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这应该包括订阅频道和处理接收到的数据的基础知识，最终将我们带到最后的演示，将数据从前端发送回服务器。</p><h2 id="38f1" class="lo kr in bd ks lp lq dn kw lr ls dp la kc lt lu le kg lv lw li kk lx ly lm lz bi translated">从前端向频道服务器发送数据</h2><p id="46c9" class="pw-post-body-paragraph jr js in jt b ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko ig bi translated">正如我前面提到的，创建订阅提供了对几个内置方法的访问。你最常用的两个是<code class="fe mf mg mh mi b">send()</code>和<code class="fe mf mg mh mi b">unsubscribe()</code>。我得说这两者都是不言自明的。当您希望您的消费者不再订阅该频道时，会调用<code class="fe mf mg mh mi b">unsubscribe()</code>。假设您的订阅保存到一个变量中作为<code class="fe mf mg mh mi b">newChannel</code>，取消订阅就像调用<code class="fe mf mg mh mi b">newChannel.unsubscribe()</code>一样简单。<code class="fe mf mg mh mi b">send()</code>接受一个参数，数据被发送到通道(通常以<code class="fe mf mg mh mi b">object</code>的形式，我认为是惯例)，并且，你猜对了，将数据发送到通道。这将在后端触发<code class="fe mf mg mh mi b">Channel#received</code>，数据将作为参数传递给它。</p><p id="7967" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以<code class="fe mf mg mh mi b">newChannel.send({message: "hello world"})</code>将调用<code class="fe mf mg mh mi b">Channel#received</code>，传递<code class="fe mf mg mh mi b">{message: "hello world"}</code>作为参数。做什么取决于你，因为你(开发者)将在<code class="fe mf mg mh mi b">Channel#received</code>方法中编写代码。</p><p id="7435" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关于<code class="fe mf mg mh mi b">objects</code>和<code class="fe mf mg mh mi b">hashes</code>的一个简单说明:JavaScript <code class="fe mf mg mh mi b">object</code>的键的默认数据类型是<code class="fe mf mg mh mi b">string</code>，Ruby <code class="fe mf mg mh mi b">hash</code>的键的默认数据类型是<code class="fe mf mg mh mi b">symbol</code>。因此，在JavaScript中，用键访问一个值通常看起来像是<code class="fe mf mg mh mi b">object['key']</code>，而在Ruby中是<code class="fe mf mg mh mi b">hash[:key]</code>。我现在提出这个是因为当你从前端发送数据作为一个<code class="fe mf mg mh mi b">object</code>时，密钥被保存为一个<code class="fe mf mg mh mi b">string</code>。当编写通道的<code class="fe mf mg mh mi b">received</code>方法的逻辑时，您可能会本能地尝试通过将键作为符号传递来访问数据的键。这样不行。当处理消费者发送的对象时，您需要将键作为字符串传递，就像在JavaScript中一样。</p><p id="b12e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我想就这样吧！我并没有涵盖关于Action Cable的所有内容，但是我相信我已经涵盖了您需要的所有内容。谢谢你坚持到最后！</p><h1 id="ee61" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">资源</h1><div class="nl nm gp gr nn no"><a href="https://guides.rubyonrails.org/action_cable_overview.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">Action Cable概述- Ruby on Rails导轨</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Action Cable概述在本指南中，您将了解Action Cable的工作原理以及如何使用WebSockets来整合…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">guides.rubyonrails.org</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jp no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://medium.com/nerd-for-tech/using-action-cable-in-your-rails-react-app-showing-online-status-7204c6553d02" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">在你的Rails/React应用中使用Action Cable:显示“在线”状态</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">我目前正在使用Action Cable来实现我的幻想相扑应用程序的现场草稿。有几个…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc jp no"/></div></div></a></div><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/integrating-actioncable-with-react-9f946b61556e"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">将ActionCable与React集成</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Action Cable是Ruby on Rails提供的一个框架，它允许开发人员在他们的…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc jp no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://medium.com/@dakota.lillie/using-action-cable-with-react-c37df065f296" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">使用带React的动作电缆</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">在最近的一个项目中，我用React前端和Rails API后端制作了一个聊天应用程序，目标是熟悉…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="of l nz oa ob nx oc jp no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="http://laithazer.com/blog/2017/03/25/rails-actioncable-stream-for-vs-stream-from/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">action cable-stream _ for vs stream _ from</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">ActionCable是Ruby on Rails 5+中新的WebSockets集成特性。它有几个很棒的特性，其中之一是…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">laithazer.com</p></div></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://medium.com/swlh/action-cable-react-hooks-redux-toolkit-yet-another-chat-app-with-unread-messages-feature-93f5f36d4489" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">Action Cable，React Hooks，Redux Toolkit:又一款聊天应用——带有未读消息功能</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Action Cable是集成WebSockets的Rails方式，允许以最小的开销进行双向通信…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="og l nz oa ob nx oc jp no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://blog.devgenius.io/integrate-action-cable-with-react-and-ruby-on-rails-to-build-a-one-to-one-chatting-app-4f0feb5479e6" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">将Action Cable与React和Ruby on Rails集成起来，构建一个一对一的聊天应用程序</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">最近，我正在开发一款带有一对一聊天功能的约会应用。一切都按计划进行，直到…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">blog.devgenius.io</p></div></div><div class="nx l"><div class="oh l nz oa ob nx oc jp no"/></div></div></a></div><p id="563b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="mw">更多内容看</em> <a class="ae kp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="mw">说白了。</em></strong></a></p><p id="79d3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="mw">报名参加我们的</em> <a class="ae kp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们上</em> <a class="ae kp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="mw">推特</em> </strong> </a>，<a class="ae kp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="mw">领英</em> </strong> </a> <strong class="jt io"> <em class="mw">，</em></strong><a class="ae kp" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="mw">YouTube</em></strong></a><strong class="jt io"><em class="mw">，以及</em></strong><em class="mw"/><a class="ae kp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="mw">不和</em> </strong> </a>T47】</p><p id="331c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="mw">用</em> </strong> <a class="ae kp" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="mw">电路</em> </strong> </a> <em class="mw">为你的科技创业建立认知和采用。</em></p></div></div>    
</body>
</html>