<html>
<head>
<title>Clean Up Your React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清理您的React代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/clean-up-your-react-js-code-fd6dc54dcde?source=collection_archive---------1-----------------------#2022-03-03">https://javascript.plainenglish.io/clean-up-your-react-js-code-fd6dc54dcde?source=collection_archive---------1-----------------------#2022-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/8001252506ad52ab5858e1ecba97826d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/1*ZYYIDFOLQ0IO_1eCFvFsDA.gif"/></div></figure><blockquote class="jr js jt"><p id="b879" class="ju jv jw jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“即使你只是为自己写代码，没有任何其他人以任何方式使用它的可能性，如果你写了清晰的代码，你未来的自己也会感谢你。”~在JavaScript中清理代码(詹姆斯·帕多尔西)</p></blockquote><h2 id="0c65" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">不变性</strong></h2><p id="6661" class="pw-post-body-paragraph ju jv in jx b jy lp ka kb kc lq ke kf lc lr ki kj lg ls km kn lk lt kq kr ks ig bi translated">React有一个声明式编程方法。因此，为了清理我们的代码，理解声明式编程的含义并遵循函数式编程风格是很重要的。</p><p id="78d6" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">不变性是什么意思？</p><p id="08e0" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">基本上，不可变值是不能改变的值。因此，我们需要创建一个新的副本并返回它，而不是改变原始数据的值。这种处理值的方式被称为不变性。</p><p id="5538" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">让我们看一个简单的例子:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lu"><img src="../Images/ac3c87d8aa254198de858c766f90781c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CamLwa4MG3akobzZDYqsQ.png"/></div></div></figure><p id="80d5" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">函数的作用是改变给定数组的值。</p><p id="391b" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">我们需要将函数更改如下:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi md"><img src="../Images/86275a242f806d84ed6fdfe077f6f5d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6qP7wGBgCEtaamSkeQXmA.png"/></div></div></figure><p id="133e" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">“addFruitPure”函数在不影响原始数组的情况下返回一个新数组。</p><p id="9d92" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">将输入值视为不可变的函数调用<strong class="jx io">纯函数</strong>。<br/>纯函数没有副作用，如果我们调用这个函数两次，我们会得到相同的结果。</p><p id="b379" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">这些概念经常被用到，尤其是当你使用像Redux这样的库的时候。</p><h2 id="a730" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">让你的代码保持干燥</strong></h2><blockquote class="jr js jt"><p id="985a" class="ju jv jw jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“不要重复你自己(DRY)是软件开发的一个原则，旨在减少软件模式的重复，用抽象代替它。”<br/> ~维基百科</p></blockquote><p id="4bf0" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">复制代码通常会导致问题和意想不到的结果，因为它会影响代码的可维护性，并使调试变得非常困难。</p><p id="1546" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">React可以帮助我们避免重复使用可重用组件的代码。<br/> <br/>我们来深入一个例子。假设我们有一个“创建用户”表单，要创建一个用户，我们必须从下拉框中选择一个国家，我们的应用程序中还有一个“用户列表”组件，我们可以按角色过滤用户。</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi me"><img src="../Images/8eaedd411e2600b8475b4f56a569fb87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*be8UyiJdd9v9t_u2fuHgXQ.png"/></div></div></figure><p id="ce2b" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">在render方法中，我们循环遍历各个国家，并将每个选项映射到一个<li>元素中。</li></p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mf"><img src="../Images/b22f4bc8dbdcb51eb1b0dbaf79f2aa22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ln9MOJ0uPX5JjkWIQTEFIg.png"/></div></div></figure><p id="3855" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">我们再次循环角色，为每个角色显示标题而不是名字。</p><p id="ad14" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">让我们更详细地看看这些组件:</p><p id="1c20" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">它们都有一个标题——国家和角色、所选选项的状态以及在onClick事件触发时触发的handleClick函数。</p><p id="b548" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">区别在于UsersList中的选项值是title(role.title)而不是name(country.name)。</p><p id="a1e3" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">所以我们组件的主要需求是显示下拉列表的标题，映射选项列表和处理onClick事件。</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mg"><img src="../Images/5fc63294320bc2f6119130410632213b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWsFcSSPsVonR_5FmPDIog.png"/></div></div></figure><p id="fa0b" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">“Dropdown”组件接收属性，显示标题，并遍历集合。</p><p id="dd68" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">我们现在可以重写我们的组件:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mh"><img src="../Images/f8e939a6475dfdbc1ecf955d9a024de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlIiKQXo405N2mTOZNlKFQ.png"/></div></div></figure><p id="b67c" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">太好了，现在我们可以在应用程序中多次使用“下拉”组件，只需传递正确的道具即可。也许有一个新的需求来改变下拉菜单的样式或实现额外的功能，我们可以在一个点上进行更改，所有使用它的组件都会知道修改。</p><h2 id="0257" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">不要忘记钥匙</strong></h2><p id="f692" class="pw-post-body-paragraph ju jv in jx b jy lp ka kb kc lq ke kf lc lr ki kj lg ls km kn lk lt kq kr ks ig bi translated">React有不同的技术来优化组件的呈现。</p><blockquote class="jr js jt"><p id="c39c" class="ju jv jw jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">"关键字帮助React识别哪些项目已被更改、添加或删除。应该给数组内部的元素赋予键，以给元素一个稳定的标识。~ reactjs.org</p></blockquote><p id="144f" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">因此，使用key属性有助于避免应用程序中不必要的重新呈现。</p><p id="ec4e" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">让我们深入研究代码:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mi"><img src="../Images/4ee49887e065ab7c289eebc376827525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jv-ErZR-wHL8jbCm18Yc0A.png"/></div></div></figure><p id="d481" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">上面的简单组件显示了一个用户列表和“添加用户”按钮，该按钮将新用户作为第一个元素插入到列表中，导致组件的新呈现。</p><p id="4705" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">如果我们运行代码，我们会看到(在浏览器DevTools中)React不仅添加新元素，还会改变以前用户的值，并在列表末尾添加一个新项目(因为React会计算出元素与第一次呈现时不同)。</p><p id="eeea" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">幸运的是，React为开发人员提供了一个提高组件渲染性能的工具。</p><p id="de38" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">现在，我们可以更改渲染方法并在每个元素上添加关键属性:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mj"><img src="../Images/3aa5b2e2eb288dacfccf3ca7dc596fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQfcXoYlfAzthCJSb45tFw.png"/></div></div></figure><p id="4fb2" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">如果我们再次运行代码，我们将看到组件的行为是相同的。然而，如果我们打开浏览器DevTools，我们会发现一些不同的东西——React不会改变以前元素的值，因为它知道哪个元素是新的，哪个元素必须更新。</p><p id="4fde" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">最后但同样重要的是，如果项目从未被重新排序，您可以将项目的索引作为键传递。</p><p id="4fcc" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">让我们再次创建“用户列表”组件，但以如下方式更改呈现方法:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mk"><img src="../Images/72926623b777c9db306cd92f65716d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1GD3I-tbcUZBgdtacl0eQ.png"/></div></div></figure><p id="d7e8" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">我们添加了一个输入框，为每个用户写一封电子邮件。</p><p id="1f27" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">运行代码，写完电子邮件后，让我们单击按钮，将新用户添加到列表的开头。</p><p id="e14c" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">我们将得到一个意外的行为，如下面的屏幕截图所示:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ml"><img src="../Images/26d6d6cc160b5afdafd07c3a4d260add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UY3USlr8rjBc6IBe7dLvHQ.png"/></div></div></figure><p id="ea29" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">用户的全名将下移，而输入字段的值不会改变。这是因为React认为我们更改了前两个用户的值(因为0和1键值)并添加了一个索引为2的新元素。</p><h2 id="3f92" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">诚信通</strong></h2><p id="494e" class="pw-post-body-paragraph ju jv in jx b jy lp ka kb kc lq ke kf lc lr ki kj lg ls km kn lk lt kq kr ks ig bi translated">ESLint是一个开源的JavaScript林挺实用程序。它可以帮助我们避免语法错误，在我们输入代码时检查代码的正确性，并最终实施通用的编码风格指南，这在有许多开发人员的大型团队中非常重要。</p><p id="5f8e" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">ESlint是高度可配置和可扩展的。</p><p id="f37c" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">首先，我们必须安装ESLint，如下所示:</p><pre class="lv lw lx ly gt mm mn mo mp aw mq bi"><span id="e4cf" class="kt ku in mn b gy mr ms l mt mu">npm i eslint</span></pre><p id="ea71" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">安装ESlint之后，我们可以使用。项目根文件夹中的eslintrc文件:</p><p id="c8e1" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">【https://github.com/MariamKochumian/eslintConfig T4】</p><p id="7c5f" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">我们使用“规则”键来添加一些规则。有三个级别的规则:</p><ul class=""><li id="e203" class="mw mx in jx b jy jz kc kd lc my lg mz lk na ks nb nc nd ne bi translated">关闭或0:规则被禁用</li><li id="5c73" class="mw mx in jx b jy nf kc ng lc nh lg ni lk nj ks nb nc nd ne bi translated">warn或1:该规则是一个警告。</li><li id="15bc" class="mw mx in jx b jy nf kc ng lc nh lg ni lk nj ks nb nc nd ne bi translated">错误或2:规则抛出一个错误。</li></ul><p id="0961" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated">在ESlint配置之后，我们可以添加带有<a class="ae mv" href="https://typicode.github.io/husky/#/" rel="noopener ugc nofollow" target="_blank"> <em class="jw"> Husky </em> </a>和<a class="ae mv" href="https://github.com/okonet/lint-staged#readme" rel="noopener ugc nofollow" target="_blank"> <em class="jw"> lint-staged </em> </a>的Git预提交钩子。</p><p id="dbdf" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated"><a class="ae mv" href="https://medium.com/javascript-in-plain-english/clean-up-your-react-code-63992a82d8e7" rel="noopener">清理React代码(第二部分)</a></p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="f6c8" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated"><em class="jw">作者Mariam Kochumian。</em></p><p id="2ba1" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf lc kh ki kj lg kl km kn lk kp kq kr ks ig bi translated"><em class="jw">更多内容看</em> <a class="ae mv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="jw">说白了。报名参加我们的</em> <a class="ae mv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="jw">免费周报</em> </strong> </a> <em class="jw">。关注我们</em><a class="ae mv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="jw">Twitter</em></strong></a><em class="jw">和</em><a class="ae mv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="jw">LinkedIn</em></strong></a><em class="jw">。加入我们的</em> <a class="ae mv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="jw">社区</em> </strong> </a> <em class="jw">。</em></strong></a></p></div></div>    
</body>
</html>