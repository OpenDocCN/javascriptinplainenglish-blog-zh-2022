<html>
<head>
<title>React Crash Course — Updating with the PUT method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React速成班-使用PUT方法更新</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-crash-course-updating-with-the-put-method-5414c67f5182?source=collection_archive---------3-----------------------#2022-03-01">https://javascript.plainenglish.io/react-crash-course-updating-with-the-put-method-5414c67f5182?source=collection_archive---------3-----------------------#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b7ca" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第9部分:在React应用程序中调用fetch来更新后端</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/661f5f91bf6df7a1cbea1c995e5df086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zZ4PYYg_FZpdc8LL"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Live dev笔记由</em><a class="ae kv" href="https://www.youtube.com/channel/UCTZRcDjjkVajGL6wd76UnGg" rel="noopener ugc nofollow" target="_blank"><em class="ls">Dennis Ivy</em></a><em class="ls">——</em><a class="ae kv" href="https://www.youtube.com/watch?v=6fM3ueN9nYM" rel="noopener ugc nofollow" target="_blank"><em class="ls">React JS速成班</em> </a></p><blockquote class="lt"><p id="0eff" class="lu lv iq bd lw lx ly lz ma mb mc lr dk translated">在第9部分中，我们将更新笔记的内容，将其保存回我们的模拟后端服务器，通过React路由器的历史属性重定向用户，以及解决我们的文本区域中的onChange错误(第5部分中提到的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/react-crash-course-styling-the-application-daf31a0ebb9d?sk=2ef5781ad6e7b4f907ec325fae65f77a"/></p></blockquote></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="e08f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以参考我的Github repo:</p><div class="mk ml gp gr mm mn"><a href="https://github.com/emilyyleung/notesapp/tree/Part-9/PUT-Method" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">GitHub-Emily leung/notes app at Part-9/PUT-Method</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">在GitHub上创建一个帐户，为Emily leung/notes app的开发做出贡献。</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb kp mn"/></div></div></a></div></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="e08b" class="nc nd iq bd ne nf ng nh ni nj nk nl nm jw nn jx no jz np ka nq kc nr kd ns nt bi translated">处理<code class="fe nu nv nw nx b">OnChange</code>错误</h1><p id="e604" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">首先，让我们回到在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/react-crash-course-styling-the-application-daf31a0ebb9d?sk=2ef5781ad6e7b4f907ec325fae65f77a">第5部分</a>中看到的<code class="fe nu nv nw nx b">onChange</code>错误(如下所示)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/fe819d3e83038f1ffd2c4f80bc6f0bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZRMBnZXJ1hXm91vk"/></div></div></figure><p id="2117" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在试图编辑文本区域时，每次按键都会触发<code class="fe nu nv nw nx b">onChange</code>事件——但是在我们的例子中，因为我们没有包含这个方法，所以它返回一个错误，阻止我们进行任何更改。</p><p id="98e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们将把它所需的<code class="fe nu nv nw nx b">onChange</code>属性分配给textarea，并设置它在发生变化时触发<code class="fe nu nv nw nx b">setNote</code>函数。为了查看实际发生了什么，让我们同时记录我们编辑过的note对象。</p><pre class="kg kh ki kj gt oe nx of og aw oh bi"><span id="c162" class="oi nd iq nx b gy oj ok l ol om">// notesapp &gt; src &gt; pages &gt; NotePage.js</span><span id="acef" class="oi nd iq nx b gy on ok l ol om">&lt;textarea<br/>    <strong class="nx ir">onChange={(e) =&gt; {<br/>     setNote({ ...note, body: e.target.value })</strong><strong class="nx ir">; console.log(note);</strong><strong class="nx ir"><br/>    }}</strong><br/>    value={note?.body}<br/>&gt;&lt;/textarea&gt;</span></pre><p id="9fde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将在上面的代码片段中看到，我们使用spread操作符来帮助我们在每次按键时更新音符对象的状态。具体来说，我们在textarea中输入的任何要更新的内容都会存储到<code class="fe nu nv nw nx b">body</code>属性中——同时保持现有的<code class="fe nu nv nw nx b">id</code>和<code class="fe nu nv nw nx b">updated</code>属性不变。使用我们的控制台时，这种变化最容易理解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/913205e00f1193f9daed680883d9af22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EhMkIskcqRfRKBGA"/></div></div></figure><blockquote class="op oq or"><p id="106b" class="kw kx ls ky b kz la jr lb lc ld ju le os lg lh li ot lk ll lm ou lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">注意:</em> </strong> <em class="iq">使用</em> <code class="fe nu nv nw nx b"><em class="iq">setNote</em></code> <em class="iq">函数意味着我们有效地覆盖和替换了原来存在的内容(整个Note对象)，而不是用更多的文本追加内容。因此，我们需要使用spread操作符来返回触发onChange事件之前的内容。</em></p></blockquote><h1 id="d30d" class="nc nd iq bd ne nf ov nh ni nj ow nl nm jw ox jx no jz oy ka nq kc oz kd ns nt bi translated">使用<code class="fe nu nv nw nx b">PUT</code>方法更新注释</h1><p id="a7fd" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">目前，我们在textarea中编辑的注释内容只存在于React组件中，还没有保存回我们的模拟后端服务器。这意味着，如果我们刷新页面，值将恢复到原来在我们后端的值，或者在本例中，恢复到我们的<code class="fe nu nv nw nx b">db.json</code>文件。</p><p id="3e4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过fetch更新使用<code class="fe nu nv nw nx b">PUT</code>方法所做的更改。应用程序的设计意图表明，只有当我们单击返回箭头按钮时，注释才应该被保存——而不是在文本区域之外单击。这样做也意味着我们可以实现一个点击时调用的<code class="fe nu nv nw nx b">handleSubmit</code>函数。</p><p id="f628" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从将<code class="fe nu nv nw nx b">onClick</code>属性添加到返回箭头开始，并传递我们将在组件创建之前创建的<code class="fe nu nv nw nx b">handleSubmit</code>函数。在它里面，我们将记录一个值来测试它是否工作。</p><pre class="kg kh ki kj gt oe nx of og aw oh bi"><span id="6f19" class="oi nd iq nx b gy oj ok l ol om">// notesapp &gt; src &gt; pages &gt; NotePage.js</span><span id="affa" class="oi nd iq nx b gy on ok l ol om">import { useState, useEffect } from 'react'<br/>import { Link } from 'react-router-dom'<br/>import { ReactComponent as ArrowLeft } from '../assets/arrow-left.svg'</span><span id="9d95" class="oi nd iq nx b gy on ok l ol om">const NotePage = ({match}) =&gt; {<br/>    let noteId = match.params.id<br/>    let [note, setNote] = useState(null)</span><span id="4a4b" class="oi nd iq nx b gy on ok l ol om">    useEffect(() =&gt; {<br/>        getNote()<br/>    }, [noteId])</span><span id="0b5c" class="oi nd iq nx b gy on ok l ol om">    let getNote = async () =&gt; {<br/>        let response = await fetch(`<a class="ae kv" href="http://localhost:8000/notes/${noteId}`" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/notes/${noteId}`</a>)<br/>        let data = await response.json()<br/>        setNote(data)<br/>    }</span><span id="ada8" class="oi nd iq nx b gy on ok l ol om">    <strong class="nx ir">let handleSubmit = () =&gt; {<br/>        console.log("click")<br/>    }</strong></span><span id="04f0" class="oi nd iq nx b gy on ok l ol om">    return (<br/>        &lt;div className='note'&gt;<br/>            &lt;div className='note-header'&gt;<br/>                &lt;h3&gt;<br/>                    &lt;Link to="/"&gt;<br/>                        <strong class="nx ir">&lt;ArrowLeft onClick={handleSubmit}/&gt;</strong><br/>                    &lt;/Link&gt;<br/>                &lt;/h3&gt;<br/>            &lt;/div&gt;<br/>            <br/>            &lt;textarea onChange={(e) =&gt; {setNote({...note, body:e.target.value})}} value={note?.body}&gt;&lt;/textarea&gt;</span><span id="a993" class="oi nd iq nx b gy on ok l ol om">        &lt;/div&gt;<br/>    )<br/>}</span><span id="c349" class="oi nd iq nx b gy on ok l ol om">export default NotePage</span></pre><p id="1968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，让我们进行一个fetch调用来更新一个名为<code class="fe nu nv nw nx b">updateNote</code>的异步函数的后端，并在我们的<code class="fe nu nv nw nx b">handleSubmit</code>处理程序中调用它。</p><pre class="kg kh ki kj gt oe nx of og aw oh bi"><span id="7f5b" class="oi nd iq nx b gy oj ok l ol om">// notesapp &gt; src &gt; pages &gt; NotePage.js</span><span id="6f1d" class="oi nd iq nx b gy on ok l ol om">let updateNote = async () =&gt; {<br/> await fetch(`<a class="ae kv" href="http://localhost:8000/notes/${noteId}`" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/notes/${noteId}`</a>, {<br/>  method: "PUT",<br/>  headers: {<br/>   "Content-Type": "application/json",<br/>  },<br/>  body: JSON.stringify({ ...note, updated: new Date() }),<br/> });<br/>};</span><span id="0e25" class="oi nd iq nx b gy on ok l ol om">let handleSubmit = () =&gt; {<br/> updateNote();<br/>};</span></pre><p id="1162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数内部发生的事情是，它基于<code class="fe nu nv nw nx b">noteId</code>定位特定的音符。一旦它获取了注释，就应该更新由<code class="fe nu nv nw nx b">PUT</code>方法声明的内容，其中注释的内容由最后一个<code class="fe nu nv nw nx b">onChange</code>值组成。此外，它还用当前日期更新了<code class="fe nu nv nw nx b">updated</code>属性。</p><p id="d2a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们对文本区域进行一些更改时，单击后退箭头将调用<code class="fe nu nv nw nx b">handleSubmit</code>，它运行<code class="fe nu nv nw nx b">updateNote</code>并将用户重定向到主页。当我们返回到同一个笔记时，我们将看到那些编辑过的更改出现——但是这次内容是从我们的后端获取和显示的。</p><h1 id="b4fd" class="nc nd iq bd ne nf ov nh ni nj ow nl nm jw ox jx no jz oy ka nq kc oz kd ns nt bi translated">访问<code class="fe nu nv nw nx b">history</code>属性</h1><p id="24b6" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">React Router自带<code class="fe nu nv nw nx b">history</code>属性，构建在HTML5历史API之上。我们特别想使用它的<code class="fe nu nv nw nx b">push</code>方法，在笔记保存到后端后，将用户重定向回<code class="fe nu nv nw nx b">NotesListPage</code>。</p><blockquote class="op oq or"><p id="7da4" class="kw kx ls ky b kz la jr lb lc ld ju le os lg lh li ot lk ll lm ou lo lp lq lr ij bi translated"><em class="iq">你可能会想为什么这是必要的，因为我们已经有了一个</em> <code class="fe nu nv nw nx b"><em class="iq">Link</em></code> <em class="iq">组件将我们重定向回主页。这将在文章的最后得到证明。</em></p></blockquote><p id="f26d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用history属性，我们需要通过析构在组件中访问它，因为它是props对象的一部分。</p><pre class="kg kh ki kj gt oe nx of og aw oh bi"><span id="248e" class="oi nd iq nx b gy oj ok l ol om">// notesapp &gt; src &gt; pages &gt; NotePage.js</span><span id="cd81" class="oi nd iq nx b gy on ok l ol om">const NotePage = ({ match, history }) =&gt; {...}</span></pre><p id="43aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在<code class="fe nu nv nw nx b">updateNote</code>运行之后，我们将调用<code class="fe nu nv nw nx b">handleSubmit</code>中的<code class="fe nu nv nw nx b">push</code>方法，并将它指定为重定向路径的根。</p><pre class="kg kh ki kj gt oe nx of og aw oh bi"><span id="9f75" class="oi nd iq nx b gy oj ok l ol om">// notesapp &gt; src &gt; pages &gt; NotePage.js</span><span id="3837" class="oi nd iq nx b gy on ok l ol om">let handleSubmit = () =&gt; {<br/> updateNote();<br/> <strong class="nx ir">history.push("/");</strong><br/>};</span></pre><p id="fa30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在跟随教程的过程中，我注意到因为我们使用了<code class="fe nu nv nw nx b">history</code>，这意味着我们不再需要通过<code class="fe nu nv nw nx b">to</code>属性重定向用户。但是，由于这个属性是<code class="fe nu nv nw nx b">Link</code>组件的一个需求，我们可以完全删除这个组件。</p><pre class="kg kh ki kj gt oe nx of og aw oh bi"><span id="ec35" class="oi nd iq nx b gy oj ok l ol om">// notesapp &gt; src &gt; pages &gt; NotePage.js</span><span id="ce04" class="oi nd iq nx b gy on ok l ol om">return (<br/> &lt;div className='note'&gt;<br/>  &lt;div className='note-header'&gt;<br/>   <strong class="nx ir">&lt;h3&gt;<br/>    &lt;ArrowLeft onClick={handleSubmit} /&gt;<br/>   &lt;/h3&gt;</strong><br/>  &lt;/div&gt;<br/>  &lt;textarea<br/>   onChange={(e) =&gt; {<br/>    setNote({ ...note, body: e.target.value });<br/>   }}<br/>   value={note?.body}<br/>  &gt;&lt;/textarea&gt;<br/> &lt;/div&gt;<br/>);</span></pre><p id="b795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当用户编辑一条注释并点击返回箭头按钮时，正文内容被保存到<code class="fe nu nv nw nx b">db.json</code>，然后它们将返回到<code class="fe nu nv nw nx b">NotesListPage</code></p><p id="baf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当他们点击返回笔记时，他们将看到已存储在<code class="fe nu nv nw nx b">db.json</code>中的更新笔记</p><h1 id="0f5f" class="nc nd iq bd ne nf ov nh ni nj ow nl nm jw ox jx no jz oy ka nq kc oz kd ns nt bi translated">修复实时更新问题</h1><p id="d30e" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">我发现的另一个问题是，当我使用箭头链接返回到<code class="fe nu nv nw nx b">NotesListPage</code>时，标题并没有立即更新。只有当我再次返回并退出以便注册更改时，更改才会出现。</p><p id="dd35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过一些研究，我发现通过将<code class="fe nu nv nw nx b">handleSubmit</code>转换为异步函数，将<code class="fe nu nv nw nx b">updateNote</code>转换为使用“await”(因为异步函数应该通过“await”调用)。这意味着当我点击返回箭头键时，我可以看到更改的注释出现在<code class="fe nu nv nw nx b">NotesListPage</code>中。</p><blockquote class="op oq or"><p id="e757" class="kw kx ls ky b kz la jr lb lc ld ju le os lg lh li ot lk ll lm ou lo lp lq lr ij bi translated"><em class="iq">回到使用历史属性的原因——通过在</em> <code class="fe nu nv nw nx b"><em class="iq">handleSubmit</em></code> <em class="iq">函数中实现，意味着我们可以控制操作的顺序。由此，笔记首先被保存到后端，然后当用户被重定向回主页时，返回的笔记列表保证是最新的。</em></p></blockquote><pre class="kg kh ki kj gt oe nx of og aw oh bi"><span id="d8bc" class="oi nd iq nx b gy oj ok l ol om">// notesapp &gt; src &gt; pages &gt; NotePage.js</span><span id="3134" class="oi nd iq nx b gy on ok l ol om">import { useState, useEffect } from "react";<br/>import { ReactComponent as ArrowLeft } from "../assets/arrow-left.svg";</span><span id="bbcc" class="oi nd iq nx b gy on ok l ol om">const NotePage = ({ match, history }) =&gt; {<br/> let noteId = match.params.id;<br/> let [note, setNote] = useState(null);</span><span id="5dc4" class="oi nd iq nx b gy on ok l ol om"> useEffect(() =&gt; {<br/>  getNote();<br/> }, [noteId]);</span><span id="d45e" class="oi nd iq nx b gy on ok l ol om"> let getNote = async () =&gt; {<br/>  let response = await fetch(`<a class="ae kv" href="http://localhost:8000/notes/${noteId}`" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/notes/${noteId}`</a>);<br/>  let data = await response.json();<br/>  setNote(data);<br/> };</span><span id="73e8" class="oi nd iq nx b gy on ok l ol om"> let updateNote = async () =&gt; {<br/>  await fetch(`<a class="ae kv" href="http://localhost:8000/notes/${noteId}`" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/notes/${noteId}`</a>, {<br/>   method: "PUT",<br/>   headers: {<br/>    "Content-Type": "application/json",<br/>   },<br/>   body: JSON.stringify({ ...note, updated: new Date() }),<br/>  });<br/> };</span><span id="f32f" class="oi nd iq nx b gy on ok l ol om"> <strong class="nx ir">let handleSubmit = async () =&gt; {<br/>  await updateNote();<br/>  history.push("/");<br/> };</strong></span><span id="cd72" class="oi nd iq nx b gy on ok l ol om"> return (<br/>  &lt;div className='note'&gt;<br/>   &lt;div className='note-header'&gt;<br/>    &lt;h3&gt;<br/>     &lt;ArrowLeft onClick={handleSubmit} /&gt;<br/>    &lt;/h3&gt;<br/>   &lt;/div&gt;<br/>   &lt;textarea<br/>    onChange={(e) =&gt; {<br/>     setNote({ ...note, body: e.target.value });<br/>    }}<br/>    value={note?.body}<br/>   &gt;&lt;/textarea&gt;<br/>  &lt;/div&gt;<br/> );<br/>};</span><span id="34c6" class="oi nd iq nx b gy on ok l ol om">export default NotePage;</span></pre><p id="26a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一篇文章将介绍如何创建和删除笔记。</p><p id="0e39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">plain English . io</em></strong></a><em class="ls">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">Twitter</em></strong></a><em class="ls">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">LinkedIn</em></strong></a><em class="ls">。加入我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">社区不和谐</em> </strong> </a> <em class="ls">。</em></p></div></div>    
</body>
</html>