<html>
<head>
<title>Using TypeScript Mapped Types Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专业人员一样使用TypeScript映射类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-typescript-mapped-types-like-a-pro-be10aef5511a?source=collection_archive---------0-----------------------#2022-07-29">https://javascript.plainenglish.io/using-typescript-mapped-types-like-a-pro-be10aef5511a?source=collection_archive---------0-----------------------#2022-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c285" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">映射类型—用动画解释。掌握TypeScript映射类型并理解TypeScript的内置实用工具类型是如何工作的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/915a829e1d00935f43b6df2f34d284c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMXS28oOxZLr-MtIjkU2mQ.jpeg"/></div></div></figure><p id="a7f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎来到<strong class="kt ir">掌握打字稿</strong>系列。本系列将以动画的形式介绍打字稿<strong class="kt ir">的核心知识和技巧。让我们一起学习吧！以前的文章如下:</strong></p><ul class=""><li id="ee50" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener"><strong class="kt ir">TypeScript泛型中的K，T，V是什么？</strong> </a></li><li id="257c" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-mapped-types-like-a-pro-be10aef5511a"> <strong class="kt ir">使用TypeScript像Pro一样映射类型</strong> </a></li><li id="3b5a" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-conditional-types-like-a-pro-7baea0ad05c5"> <strong class="kt ir">使用TypeScript条件类型像亲</strong> </a></li><li id="5fd2" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7"> <strong class="kt ir">使用TypeScript交集类型像亲</strong> </a></li><li id="5d29" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://levelup.gitconnected.com/using-typescript-infer-like-a-pro-f30ab8ab41c7" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">利用打字稿像专家一样推断</strong> </a></li><li id="d056" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/javascript-in-plain-english/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac" rel="noopener"> <strong class="kt ir">使用TypeScript模板字面类型像亲</strong> </a></li><li id="f23a" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/15-utility-types-that-every-typescript-developer-should-know-6cf121d4047c"> <strong class="kt ir">可视化打字稿:15种最常用的实用类型</strong> </a></li><li id="847f" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://levelup.gitconnected.com/10-things-you-need-to-know-about-typescript-classes-f58c57869266" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">关于类型脚本类你需要知道的10件事</strong> </a></li><li id="54ed" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/purpose-of-declare-keyword-in-typescript-8431d9db2b10"><strong class="kt ir"/></a>中‘declare’关键字的用途</li><li id="2df5" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/how-to-define-objects-type-with-unknown-structures-in-typescript-c35e7b8462b0"> <strong class="kt ir">如何在TypeScript </strong> </a>中定义未知结构的对象类型</li></ul><p id="cfda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您是否使用过Partial、Required、Readonly和Pick实用程序类型？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/989413270a4f8cc1b3a4b51820a3c299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8l8RKchv6s-IGa-bxYEY7w.jpeg"/></div></div></figure><p id="4af4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你知道他们内部是怎么运作的吗？如果您想彻底掌握它们并创建自己的实用程序类型，请不要错过本文涵盖的内容。</p><p id="8e61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户注册是日常工作中的一个普遍场景。这里我们可以使用TypeScript来定义一个用户类型，其中所有的键都是必需的。</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="9f7c" class="mh mi iq md b gy mj mk l ml mm">type User = {<br/>  name: string; <br/>  password: string; <br/>  address: string; <br/>  phone: string;<br/>};</span></pre><p id="f43f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常对于注册用户，我们只允许用户修改部分用户信息。此时，我们可以定义一个新的UserPartial类型，它表示要更新的用户对象的类型，其中所有键都是可选的。</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="c498" class="mh mi iq md b gy mj mk l ml mm">type UserPartial = {<br/>  name?: string; <br/>  password?: string; <br/>  address?: string; <br/>  phone?: string; <br/>};</span></pre><p id="d5bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于查看用户信息的场景，我们希望对应于用户对象的对象类型中的所有键都是只读的。对于这个需求，我们可以定义Readonly用户类型。</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="1533" class="mh mi iq md b gy mj mk l ml mm">type ReadonlyUser = {<br/>  readonly name: string;<br/>  readonly password: string;<br/>  readonly address: string;<br/>  readonly phone: string;<br/>};</span></pre><p id="460a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回顾已经定义的三个与用户相关的类型，您会发现它们包含大量重复的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/338a7e4b2781a1782fb4a59e30328b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kkDPP22K4ZNHpFbczoZWXQ.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8fb50c809803e5af4492ad4912ef45d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lh1alTlQV3j9jRpHMkstwg.jpeg"/></div></div></figure><p id="5f4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么如何才能减少以上类型中的重复代码呢？答案是您可以使用映射类型，映射类型是通用类型，可用于将原始对象类型映射到新的对象类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/67957ab11daf299cdc6fda0ad79509f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-kLV6wQGC2-ahfgSwHXlsA.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Map to optional properties</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/69c76251dcb94fe8bdcb198cc36b294c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqk7dDTzDUH3CGjM3Dmf3g.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/977d28618e4fbe2772b48c9cb32d0f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TtKLifeeVvG3Us9g_S8DEw.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Map to readonly property</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca92e060d2e2d72cbc4d4c138c2e4db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYlh6JmkEIY5xtpLyULo2Q.jpeg"/></div></div></figure><p id="574b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">映射类型的语法如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/76de5401a4d68791fe5efa8057d15833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iuvURZie0JxNSmuAQe94w.jpeg"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Mapped types syntax</figcaption></figure><p id="90d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中K中的P类似于。。。in语句，用于循环访问K类型中的所有类型，以及T类型变量，用于表示TypeScript中的任何类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/847b91ccf8a6812b306a9bd7f94bd0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YK9f_jV3ETabwSDqHUSCmQ.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Mapped types modifiers</figcaption></figure><p id="dd55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还可以使用附加修饰符只读和问号(？)在映射过程中。通过添加加号(+)和减号(-)前缀来添加和删除相应的修饰符。<strong class="kt ir">如果没有添加前缀，默认使用加号。</strong></p><p id="dff5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以总结常见映射类型的语法。</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="0cad" class="mh mi iq md b gy mj mk l ml mm">{ [ P in K ] : T }<br/>{ [ P in K ] ?: T }<br/>{ [ P in K ] -?: T }<br/>{ readonly [ P in K ] : T }<br/>{ readonly [ P in K ] ?: T }<br/>{ -readonly [ P in K ] ?: T }</span></pre><p id="cce5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在介绍了映射类型的语法之后，让我们看一些例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a6cc995820eec39e31d1569c7403c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rROkBeeWqSMyh0VJkj5GwQ.jpeg"/></div></div></figure><p id="46ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看如何使用映射类型重新定义UserPartial类型。</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="0650" class="mh mi iq md b gy mj mk l ml mm">type MyPartial&lt;T&gt; = {<br/>  [P in keyof T]?: T[P];<br/>};</span><span id="54de" class="mh mi iq md b gy ms mk l ml mm">type UserPartial = MyPartial&lt;User&gt;;</span></pre><p id="8263" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，我们定义了MyPartial映射类型，然后使用它将用户类型映射到UserPartial类型。keyof运算符用于获取一个类型的所有键，其返回类型是一个联合类型。类型变量P随着每次遍历而改变为不同的类型T[P]，这类似于属性访问的语法，并且用于获得对应于对象类型的属性的值的类型。</p><p id="e29e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面演示一下MyPartial mapped type的完整执行流程，如果不确定，可以多看几遍，加深对TypeScript mapped type的理解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/aa1e88fb1684d2e1c338e87c4b91be46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vWOMJV3WyfaS8C8fqpm33A.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">MyPartial execution flow</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/770f16fd765ebd28cc9adca75f30e789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYd92WiIGhbPnRWehDTVjA.jpeg"/></div></div></figure><p id="82a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript 4.1允许我们使用as子句重新映射映射类型中的键。其语法如下:</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="e2c6" class="mh mi iq md b gy mj mk l ml mm">type MappedTypeWithNewKeys&lt;T&gt; = {<br/>    [K in keyof T as NewKeyType]: T[K]<br/>    //            ^^^^^^^^^^^^^<br/>    //            New Syntax！<br/>}</span></pre><p id="0bbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中NewKeyType的类型必须是string | number | symbol联合类型的子类型。使用<code class="fe mt mu mv md b">as</code>子句，我们可以定义一个Getters实用程序类型，为对象类型生成相应的Getter类型。</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="8e3a" class="mh mi iq md b gy mj mk l ml mm">type Getters&lt;T&gt; = {<br/>  [K in keyof T as `get${Capitalize&lt;string &amp; K&gt;}`]: () =&gt; T[K]<br/>};</span><span id="ea11" class="mh mi iq md b gy ms mk l ml mm">interface Person {<br/>    name: string;<br/>    age: number;<br/>    location: string;<br/>}</span><span id="22e7" class="mh mi iq md b gy ms mk l ml mm">type LazyPerson = Getters&lt;Person&gt;;<br/>// {<br/>//   getName: () =&gt; string;<br/>//   getAge: () =&gt; number;<br/>//   getLocation: () =&gt; string;<br/>// }</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/a108786195d611778f1c018152ddc027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jc_axCACQuR7yZyr3FvfbQ.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ae96eea6934c12a6d158db9f9704da88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGfiVHAXgobHMVnKbjExBw.jpeg"/></div></div></figure><p id="8885" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，由于keyof T返回的类型可能包含符号类型，而Capitalize utility类型要求要处理的类型需要是string类型的子类型，因此需要使用<code class="fe mt mu mv md b">&amp;</code>操作符进行类型过滤。</p><p id="f815" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">另外，在重新映射键的过程中，我们可以通过返回never类型来过滤键。</strong></p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="c519" class="mh mi iq md b gy mj mk l ml mm">// Remove the 'kind' property<br/>type RemoveKindField&lt;T&gt; = {<br/>    [K in keyof T as Exclude&lt;K, "kind"&gt;]: T[K]<br/>};</span><span id="bc3c" class="mh mi iq md b gy ms mk l ml mm">interface Circle {<br/>    kind: "circle";<br/>    radius: number;<br/>}</span><span id="53c5" class="mh mi iq md b gy ms mk l ml mm">type KindlessCircle = RemoveKindField&lt;Circle&gt;;<br/>//   type KindlessCircle = {<br/>//       radius: number;<br/>//   };</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/48a3c20a243eb9ca55bdbe580432d34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*L4ygMaGCnXdNUk4ZVlJ9nA.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e63e663a8ee2c2a52c4ddd92d9ed0218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-OZUQ0oBDuqZH-sx8KxXg.jpeg"/></div></div></figure><p id="9587" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">阅读完本文后，我相信您已经理解了映射类型的作用以及TypeScript中的一些实用类型是如何实现的。</p><p id="6fe3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你喜欢学习动画形式的TypeScript，可以在<a class="ae lw" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或者<a class="ae lw" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，了解更多关于TS和JS的内容！</p><h1 id="73b3" class="mw mi iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">资源</h1><div class="nn no gp gr np nq"><a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">文档映射类型</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">当你不想重复自己的时候，有时候一种类型需要建立在另一种类型的基础上。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">www.typescriptlang.org</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kp nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">TypeScript泛型中的K，T，V是什么？</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">用动画讲解，让你轻松掌握TypeScript泛型类型参数。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="of l ob oc od nz oe kp nq"/></div></div></a></div></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="168a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="on">更多内容看</em> <a class="ae lw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="on">说白了就是</em> </strong> </a> <em class="on">。报名参加我们的</em> <a class="ae lw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="on">免费周报</em> </strong> </a> <em class="on">。关注我们关于</em> <a class="ae lw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="on">推特</em></strong></a><strong class="kt ir"><em class="on"/></strong><em class="on">和</em><a class="ae lw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="on">LinkedIn</em></strong></a><em class="on">。查看我们的</em> <a class="ae lw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="on">社区不和谐</em> </strong> </a> <em class="on">加入我们的</em> <a class="ae lw" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="on">人才集体</em> </strong> </a> <em class="on">。</em></p></div></div>    
</body>
</html>