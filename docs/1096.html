<html>
<head>
<title>Permutations in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的排列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/backtracking-iii-permutations-834bfb5bd9d0?source=collection_archive---------9-----------------------#2022-03-03">https://javascript.plainenglish.io/backtracking-iii-permutations-834bfb5bd9d0?source=collection_archive---------9-----------------------#2022-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bde0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">回溯III—JavaScript中的排列</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5a8727266185d7195dc662aef6b409ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4lhsqqzXYGSBLvQuK524Q.jpeg"/></div></div></figure><p id="22d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在来看回溯的另一个用例…</p><p id="3fe0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://leetcode.com/problems/permutations/" rel="noopener ugc nofollow" target="_blank"> Leetcode #46 —排列。</a></p><p id="fb62" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，组合与排列。我读过很多关于这种区别的解释，为了解决这些问题，我认为最直观的表达方式是这样的:</p><p id="b32a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果被要求给出长度为3的数字数组的所有组合，由数字1到3(包括1和3)组成，那么实际上只有一个解决方案— [1，2，3]。换句话说，所有其他的(没有重复，例如[3，2，1]或[2，1，3])都不会被认为是不同的——也就是说，<em class="ll">排序不会使它们成为唯一的</em>。</p><p id="afa5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一方面，对于排列，排序很重要。我们需要呈现这三个数字的每一种可能的<em class="ll">定位</em></p><p id="af2f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">考虑到Leetcode的限制，我们将接受一个最多包含6个整数的数组输入，但是对于这个例子，让我们保持简短，保持[1，2，3]。</p><p id="68fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们从以前的回溯工作中知道，这些类型的问题可以使用树形结构来可视化，所以让我们从这里开始:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lm"><img src="../Images/46f8ffba343b6562b01a034c99d63135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXZmzTK1EpdCbma0TCD1qA.jpeg"/></div></div></figure><p id="b7a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当我看到这个结构时，它看起来非常直观和简单。但我容易感到困惑的是如何将这与递归联系起来，并在递归调用期间可视化这棵树的移动。</p><p id="d3a1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们直接进入代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="eaf0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">很快你就会发现它与组合解决方案非常相似。我们在第3行设置了结果数组，在第5行设置了递归内部函数。</p><p id="53fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将传递每个递归调用的结果(从[ ])并检查其长度(第7行)。如果它符合我们的排列标准，我们将把它包含在结果数组中，并以返回结束当前的函数调用。</p><p id="6005" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，对输入的迭代从第12行开始。</p><p id="6ecd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么这种递归逻辑会是什么样子呢？每当我们进入这个循环时，我们需要:</p><ul class=""><li id="ea12" class="lp lq in kq b kr ks ku kv kx lr lb ls lf lt lj lu lv lw lx bi translated">给我们当前的排列加上一个数字(并且不能重复)</li><li id="170d" class="lp lq in kq b kr ly ku lz kx ma lb mb lf mc lj lu lv lw lx bi translated">在我们新修改的排列上再次调用递归函数</li><li id="33d0" class="lp lq in kq b kr ly ku lz kx ma lb mb lf mc lj lu lv lw lx bi translated">移除添加到排列中的最后一个值(回溯)</li></ul><p id="0d62" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">解决方案:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="cb5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在是有趣的部分——将一些递归过程叠加到树形结构上。我将关注最左边的子树。</p><p id="1ca9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">*在下图中，您会注意到‘EC’被重复使用——这代表‘执行上下文’。如果您对这个术语有点模糊，它指的是由函数调用(在我们的例子中，是递归函数)创建的新环境。当一个函数调用在另一个函数调用内部打开时，在内部函数调用返回之前，外部函数调用中的代码不会恢复。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi md"><img src="../Images/a84381486dfdfc277231776f4683b198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIi5z2BwlaZ4ZWuspnIg5A.jpeg"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi me"><img src="../Images/78f25c3597f3565039700d36652262c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2a3s3CruAW_G02OtyFbghQ.jpeg"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mf"><img src="../Images/7240a87b83f53a49a79bae157a757d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaYBNyF0cpZz9l4uoDf1hQ.jpeg"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mg"><img src="../Images/282eb8b4626d4046b9b425f7edfbd9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7nNhWk3hLi-7_JX4mRb5Q.jpeg"/></div></div></figure><p id="0830" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有很多东西需要遵循，但是每一个都让我对递归有了更好的理解和直觉。我的目标是达到一定的熟悉程度，让这些操作感觉像for循环一样熟悉。</p><p id="6290" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对大多数人来说，回溯的递归性使它看起来如此违反直觉。能够重写我们所知道的可行的递归解决方案是一回事，而查看一个解决方案并直观地掌握正在发生的事情则完全是另一回事。</p><p id="1cf2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">更多内容请看</em><a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">plain English . io</em></strong></a><em class="ll">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">免费周报</em> </strong> </a> <em class="ll">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">Twitter</em></strong></a><em class="ll">和</em><strong class="kq io"><em class="ll"/></strong><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">LinkedIn</em></strong></a><em class="ll">。加入我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">社区</em> </strong> </a> <em class="ll">。</em></p></div></div>    
</body>
</html>