<html>
<head>
<title>How To Get The Difference Between Two Arrays In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中得到两个数组的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-get-the-difference-between-two-arrays-in-javascript-f547268bd0ee?source=collection_archive---------12-----------------------#2022-12-14">https://javascript.plainenglish.io/how-to-get-the-difference-between-two-arrays-in-javascript-f547268bd0ee?source=collection_archive---------12-----------------------#2022-12-14</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><h2 id="fa56" class="ip iq ir bd b dl is it iu iv iw ix dk iy translated" aria-label="kicker paragraph">毁灭2022</h2><div class=""/><div class=""><h2 id="87f8" class="pw-subtitle-paragraph jx ja ir bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">或者说，如何用JavaScript做differe(A \ B)、交集(A ∩ B)、并集(A ∪ B)、对称差(AδB)和笛卡尔积(A × B)</h2></div><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/71675b7ff46a5b710d7eeb2d084994a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbF8_OSYBT-NaPLW-c7mgw.jpeg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Image from Lexica.Art</figcaption></figure><p id="f807" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">今天的《毁灭2022》是关于集合论的。给定两个元素数组，我如何找到它们的区别？有一个非常简单的方法可以做到这一点。还可以求两个数组的交集，并计算它们的几何差。</p><h1 id="5754" class="mb mc ir bd md me mf mg mh mi mj mk ml kg mm kh mn kj mo kk mp km mq kn mr ms bi translated">问题:Array.diff()</h1><p id="c020" class="pw-post-body-paragraph lf lg ir lh b li mt kb lk ll mu ke ln lo mv lq lr ls mw lu lv lw mx ly lz ma ik bi translated">链接到<a class="ae my" href="https://www.codewars.com/kata/523f5d21c841566fde000009" rel="noopener ugc nofollow" target="_blank">形</a></p><p id="3138" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">在这个形中，你的目标是实现一个差函数，从一个列表中减去另一个列表，并返回结果。</p><p id="1bf7" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">它应该从列表<code class="fe mz na nb nc b">a</code>中删除所有值，这些值出现在列表<code class="fe mz na nb nc b">b</code>中，并保持它们的顺序。</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="c0eb" class="nh mc ir nc b be ni nj l nk nl">array_diff({1, 2}, 2, {1}, 1, *z) == {2} (z == 1)</span></pre><p id="0ca3" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">如果一个值出现在b中，它的所有出现必须从另一个中删除:</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="6ae7" class="nh mc ir nc b be ni nj l nk nl">array_diff({1, 2, 2, 2, 3}, 5, {2}, 1, *z) == {1, 3} (z == 2)</span></pre><h1 id="e29e" class="mb mc ir bd md me mf mg mh mi mj mk ml kg mm kh mn kj mo kk mp km mq kn mr ms bi translated">Array.diff(): <code class="fe mz na nb nc b">A \ B</code>(也写作<code class="fe mz na nb nc b">A − B</code>)</h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nm"><img src="../Images/2a51762515a740d7c60f629e74e64124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zq6LLJSecdhbNDLuFRBzpw.jpeg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Image from Wikipedia</figcaption></figure><p id="4c64" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">不过还是先从基本问题说起吧。为了解决这个问题，我从<a class="ae my" href="https://en.wikipedia.org/wiki/Set_(mathematics)" rel="noopener ugc nofollow" target="_blank">维基百科对集合间差异的定义</a>开始:</p><p id="5aa7" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">给定任意两个集合<code class="fe mz na nb nc b">A</code>和<code class="fe mz na nb nc b">B</code>，集合差<code class="fe mz na nb nc b">A \ B (also written A − B)</code>是属于<code class="fe mz na nb nc b">A</code>而不属于<code class="fe mz na nb nc b">B</code>的所有事物的集合。特别是当<code class="fe mz na nb nc b">B</code>是<code class="fe mz na nb nc b">A</code>的子集时，在<code class="fe mz na nb nc b">A</code>中又称为<code class="fe mz na nb nc b">B</code>的相对补码。</p><p id="494a" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我可以把这个定义转化成一个算法:</p><ul class=""><li id="5b8b" class="nn no ir lh b li lj ll lm lo np ls nq lw nr ma ns nt nu nv bi translated">对于的每个元素</li><li id="a605" class="nn no ir lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated">检查它是否属于B</li><li id="91d2" class="nn no ir lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated">如果不属于B，就去下一个元素</li><li id="a4cb" class="nn no ir lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated">如果它属于B，我就把它从A中删除</li></ul><p id="6889" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我也可以改写成这样的形式:</p><ul class=""><li id="b45e" class="nn no ir lh b li lj ll lm lo np ls nq lw nr ma ns nt nu nv bi translated">过滤A中不属于B的每个元素</li></ul><p id="1619" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">在这一点上，我有我需要的一切。我可以使用<a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"> Array.filter() </a>方法来选择值。并决定根据<a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="noopener ugc nofollow" target="_blank"> Array.includes() </a>的结果过滤所有值方法:</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="2fc2" class="nh mc ir nc b be ni nj l nk nl">export const arrayDiff = (a: number[], b: number[]): number[] =&gt;<br/>  a.filter((x) =&gt; !b.includes(x));</span></pre><h1 id="2fb6" class="mb mc ir bd md me mf mg mh mi mj mk ml kg mm kh mn kj mo kk mp km mq kn mr ms bi translated">Array.intersect(): <code class="fe mz na nb nc b">A ∩ B</code></h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nm"><img src="../Images/ec342ae835640d006d5829456e2942ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PrhigyXC3KT4hNpNFqjDw.jpeg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Image from Wikipedia</figcaption></figure><p id="5523" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">解决了基本问题后，我可以尽情地尝试添加更多的数组和集合运算。通过集合的交叉点:</p><p id="df0e" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">给定任意两个集合<code class="fe mz na nb nc b">A</code>和<code class="fe mz na nb nc b">B</code>，它们的交集<code class="fe mz na nb nc b">A ∩ B</code>是同时为<code class="fe mz na nb nc b">A</code>和<code class="fe mz na nb nc b">B</code>成员的所有事物的集合。如果<code class="fe mz na nb nc b">A ∩ B = ∅</code>，则称A和B不相交。</p><p id="f635" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我可以把这个定义转化成一个算法:</p><ul class=""><li id="5c32" class="nn no ir lh b li lj ll lm lo np ls nq lw nr ma ns nt nu nv bi translated">对于的每个元素</li><li id="6169" class="nn no ir lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated">检查它是否属于B</li><li id="3fb6" class="nn no ir lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated">如果它不属于B，我就把它从A中删除</li><li id="a7f8" class="nn no ir lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated">如果它属于B，则转到下一个元素</li></ul><p id="d201" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我也可以改写成这样的形式:</p><ul class=""><li id="ec4f" class="nn no ir lh b li lj ll lm lo np ls nq lw nr ma ns nt nu nv bi translated">过滤A中所有属于B的元素</li></ul><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="3885" class="nh mc ir nc b be ni nj l nk nl">export const arrayIntersect = (a: number[], b: number[]): number[] =&gt;<br/>  a.filter((x) =&gt; b.includes(x));</span></pre><h1 id="4d3a" class="mb mc ir bd md me mf mg mh mi mj mk ml kg mm kh mn kj mo kk mp km mq kn mr ms bi translated">Array.union(): <code class="fe mz na nb nc b">A ∪ B</code></h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nm"><img src="../Images/5e77f2ac541070187aad0eeafa38c8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZlFwo7Dzshsn1GSNDlFJWw.jpeg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Image from Wikipedia</figcaption></figure><p id="a88d" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">在JavaScript中，连接两个集合是一个简单的问题。但是在解决之前，定义:</p><p id="7799" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">给定任意两个集合<code class="fe mz na nb nc b">A</code>和<code class="fe mz na nb nc b">B</code>，它们的并集<code class="fe mz na nb nc b">A ∪ B</code>是属于<code class="fe mz na nb nc b">A</code>或<code class="fe mz na nb nc b">B</code>或两者的所有事物的集合。</p><p id="2b1e" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">在这种情况下，有一个<a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" rel="noopener ugc nofollow" target="_blank"> Array.concat() </a>方法，它允许您连接两个数组:</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="a8b4" class="nh mc ir nc b be ni nj l nk nl">export const arrayUnion = (a: number[], b: number[]): number[] =&gt; a.concat(b);</span></pre><h1 id="c27b" class="mb mc ir bd md me mf mg mh mi mj mk ml kg mm kh mn kj mo kk mp km mq kn mr ms bi translated">Array.symDiff(): <code class="fe mz na nb nc b">A Δ B</code></h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nm"><img src="../Images/ec342ae835640d006d5829456e2942ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PrhigyXC3KT4hNpNFqjDw.jpeg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Image from Wikipedia</figcaption></figure><p id="d549" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">下一个操作是对称差。维基百科是这样定义的:</p><p id="ea3f" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">给定任意两个集合<code class="fe mz na nb nc b">A</code>和<code class="fe mz na nb nc b">B</code>，它们的对称差<code class="fe mz na nb nc b">A Δ B</code>是属于A或B但不属于两者的所有事物的集合。必须是A的成员而不是B的成员，或者是B的成员而不是A的成员:<code class="fe mz na nb nc b">A Δ B = (A \ B) ∪ (B \ A)</code>。</p><p id="3e71" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">事实上，它是由两个不同的操作组成的。我可以这样写:</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="dc86" class="nh mc ir nc b be ni nj l nk nl">export const arraySymDiff = (a: number[], b: number[]): number[] =&gt;<br/>  arrayUnion(arrayDiff(a, b), arrayDiff(b, a));</span></pre><p id="4040" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">或者如果我更喜欢使用扩展符号:</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="c5a6" class="nh mc ir nc b be ni nj l nk nl">export const arraySymDiff = (a: number[], b: number[]): number[] =&gt;<br/>  a.filter((x) =&gt; !b.includes(x)).concat(b.filter((x) =&gt; !a.includes(x)));</span></pre><h1 id="8bc8" class="mb mc ir bd md me mf mg mh mi mj mk ml kg mm kh mn kj mo kk mp km mq kn mr ms bi translated">Array.cartesian(): <code class="fe mz na nb nc b">A × B</code></h1><p id="4d29" class="pw-post-body-paragraph lf lg ir lh b li mt kb lk ll mu ke ln lo mv lq lr ls mw lu lv lw mx ly lz ma ik bi translated">最后要处理的操作是两个数组的笛卡尔积。维基百科是这样定义的:</p><p id="6e6d" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">给定任意两个集合<code class="fe mz na nb nc b">A</code>和<code class="fe mz na nb nc b">B</code>，它们的笛卡尔积<code class="fe mz na nb nc b">A × B</code>是所有有序偶<code class="fe mz na nb nc b">(a,b)</code>的集合，使得<code class="fe mz na nb nc b">a</code>是<code class="fe mz na nb nc b">A</code>的元素，<code class="fe mz na nb nc b">b</code>是<code class="fe mz na nb nc b">B</code>的元素。</p><p id="6717" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">换句话说，这是一种允许您生成两个数组的所有可能元素对的操作。</p><p id="9e89" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我可以用这样一个函数来解决这个问题:</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="fd8b" class="nh mc ir nc b be ni nj l nk nl">export const arrayCartesian = (a: number[], b: number[]): number[][] =&gt;<br/>  a.map((x) =&gt; b.map((y) =&gt; [x, y])).flat();</span></pre><p id="58df" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">或者用这个:</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="d02b" class="nh mc ir nc b be ni nj l nk nl">const arrayCartesian = (a: number[], b: number[]): number[][] =&gt;<br/>  a.reduce((p, x) =&gt; [...p, ...b.map((y) =&gt; [x, y])], []);</span></pre><h1 id="afcf" class="mb mc ir bd md me mf mg mh mi mj mk ml kg mm kh mn kj mo kk mp km mq kn mr ms bi translated">结论</h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/4332fe7c6ffbb0bb94edfefc50524ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xIP9RRG0hR4dp0skTgk7A.jpeg"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Image from Lexica.Art</figcaption></figure><p id="0f58" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">最后，我可以将这些功能添加到道具中。这样，我可以将它们直接用于每个阵列:</p><pre class="kq kr ks kt gu nd nc ne bn nf ng bi"><span id="8ad4" class="nh mc ir nc b be ni nj l nk nl">Array.prototype.diff = function (arr2) {<br/>  return this.filter((x) =&gt; !arr2.includes(x));<br/>};<br/>Array.prototype.intersect = function (arr2) {<br/>  return this.filter((x) =&gt; arr2.includes(x));<br/>};<br/>Array.prototype.union = function (arr2) {<br/>  return this.concat(arr2);<br/>};<br/>Array.prototype.symDiff = function (arr2) {<br/>  return this.diff(arr2).concat(arr2.diff(this));<br/>};<br/>Array.prototype.cartesian = function (arr2) {<br/>  return this.reduce((p, x) =&gt; [...p, ...arr2.map((y) =&gt; [x, y])], []);<br/>};<br/><br/>[1, 2, 3].diff([2, 3]);<br/>[1, 2, 3].intersect([2, 3]);<br/>[1, 2, 3].union([2, 3]);<br/>[1, 2, 3].symDiff([2, 3]);<br/>[1, 2, 3].cartesian([2, 3]);</span></pre><p id="a211" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">感谢阅读！敬请关注更多内容。</p></div><div class="ab cl ob oc hv od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ik il im in io"><p id="9ef0" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated"><strong class="lh jb"> <em class="oi">不要错过我的下一篇文章—报名参加我的</em> </strong> <a class="ae my" href="https://medium.com/subscribe/@el3um4s" rel="noopener"> <strong class="lh jb"> <em class="oi">中邮箱列表</em> </strong> </a></p><div class="oj ok gq gs ol om"><a href="https://el3um4s.medium.com/membership" rel="noopener follow" target="_blank"><div class="on ab fp"><div class="oo ab op cl cj oq"><h2 class="bd jb gz z fq or fs ft os fv fx ja bi translated">通过我的推荐链接加入Medium—Samuele</h2><div class="ot l"><h3 class="bd b gz z fq or fs ft os fv fx dk translated">阅读萨缪尔的每一个故事(以及媒体上成千上万的其他作家)。不是中等会员？在这里加入一块…</h3></div><div class="ou l"><p class="bd b dl z fq or fs ft os fv fx dk translated">el3um4s.medium.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kz om"/></div></div></a></div><p id="9f03" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated"><em class="oi">更多内容看</em> <a class="ae my" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jb"> <em class="oi">说白了。报名参加我们的</em> <a class="ae my" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jb"> <em class="oi">免费周报</em> </strong> </a> <em class="oi">。关注我们关于</em> <a class="ae my" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jb"> <em class="oi">推特</em> </strong> </a>，<a class="ae my" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lh jb"><em class="oi">LinkedIn</em></strong></a><em class="oi">，</em><a class="ae my" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lh jb"><em class="oi">YouTube</em></strong></a><em class="oi">，以及</em> <a class="ae my" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jb"> <em class="oi">不和</em> </strong> </a> <strong class="lh jb"> <em class="oi">。</em>T59】</strong></strong></a></p><p id="21dd" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated"><strong class="lh jb"> <em class="oi">有兴趣缩放你的软件启动</em> </strong> <em class="oi">？检查出</em> <a class="ae my" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jb"> <em class="oi">电路</em> </strong> </a> <em class="oi">。</em></p></div></div>    
</body>
</html>