<html>
<head>
<title>React Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应错误处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-error-handling-e64f9724dc15?source=collection_archive---------21-----------------------#2022-10-17">https://javascript.plainenglish.io/react-error-handling-e64f9724dc15?source=collection_archive---------21-----------------------#2022-10-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/a476f42523a567e5d0d1f9247e99dd08.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*yBcRY02DsnNEKMxXCtAofg.jpeg"/></div></figure><p id="14de" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当我们用任何技术创建应用程序时，正确处理错误是必不可少的。组件树中任何地方出现的错误都会导致整个应用程序瘫痪。当一个项目有一个大的组件树时，开发人员在调试代码和确定错误发生的位置时会遇到困难。</p><p id="ee2b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">React 16引入了错误边界的概念来解决这些问题。错误边界是React组件，它捕捉子组件树中任何位置的Javascript错误，并通过回退UI显示可感知的错误消息。</p><p id="23e4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这些错误边界只捕捉渲染、生命周期方法和内部钩子(如useEffect)以及它们下面整棵树的构造函数中的错误。根据React文档，错误边界不会捕捉以下错误:</p><ul class=""><li id="1b54" class="kp kq in jt b ju jv jy jz kc kr kg ks kk kt ko ku kv kw kx bi translated">事件处理程序</li><li id="1478" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko ku kv kw kx bi translated">异步代码(例如setTimeout或requestAnimationFrame回调)</li><li id="33b6" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko ku kv kw kx bi translated">服务器端渲染</li><li id="509f" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko ku kv kw kx bi translated">在错误边界本身(而不是其子代)中抛出的错误<br/>为了创建一个错误边界，我们必须创建一个类组件<br/>，它将拥有生命周期方法中的一个或两个。</li></ul><p id="1f34" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了创建一个错误边界，我们必须创建一个类组件<br/>,除了render()方法之外，它还将具有一个或两个生命周期方法。</p><ol class=""><li id="806b" class="kp kq in jt b ju jv jy jz kc kr kg ks kk kt ko ld kv kw kx bi translated"><strong class="jt io">getderivedstatefromrerror()</strong>—这是一个静态方法，在渲染过程中，当子进程中的任何地方发生错误时，都会调用该方法来更新错误边界的状态，并用于触发回退UI。</li><li id="09a3" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko ld kv kw kx bi translated"><strong class="jt io"> componentDidCatch() </strong> —这用于在我们的错误边界组件捕获到错误时执行日志记录之类的操作。</li></ol><blockquote class="le lf lg"><p id="855d" class="jr js lh jt b ju jv jw jx jy jz ka kb li kd ke kf lj kh ki kj lk kl km kn ko ig bi translated">根据React文档，React团队还没有为功能组件提供错误边界支持，然而也没有与<strong class="jt io">getderivedstatefromrerror</strong>和<strong class="jt io"> componentDidCatch </strong>生命周期等价的挂钩。</p></blockquote><h1 id="b99a" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">在哪里放置误差边界</strong></h1><p id="c213" class="pw-post-body-paragraph jr js in jt b ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko ig bi translated">我们可以把误差边界放在任何需要的地方。我们可以在应用程序的顶层使用错误边界，即在应用程序组件的顶部，或者将它包装在单个组件上以单独处理它。</p><p id="fa5c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">事件处理程序— React不需要错误边界来从事件处理程序中发生的错误中恢复。如果我们想捕捉事件处理程序中的错误，我们可以在事件处理函数中使用通常的try/catch博客。</p><p id="8e5e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">看看这个声明和使用错误边界的例子。</p><blockquote class="le lf lg"><p id="c1c7" class="jr js lh jt b ju jv jw jx jy jz ka kb li kd ke kf lj kh ki kj lk kl km kn ko ig bi translated">“错误边界捕捉组件树中位于下方的组件中出现的错误，并且错误边界不能捕捉其自身内部的错误。在未能呈现错误消息的情况下，尝试呈现错误消息失败，错误将传播到其上最近的错误边界”</p></blockquote><p id="55be" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="lh">更多内容请看</em><a class="ae mo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="lh">plain English . io</em></strong></a><em class="lh">。报名参加我们的</em> <a class="ae mo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="lh">免费周报</em> </strong> </a> <em class="lh">。关注我们关于</em><a class="ae mo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="lh">Twitter</em></strong></a><a class="ae mo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="lh">LinkedIn</em></strong></a><strong class="jt io"><em class="lh"/></strong><a class="ae mo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="lh">YouTube</em></strong></a><strong class="jt io"><em class="lh">，以及</em></strong><em class="lh"/><a class="ae mo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="lh">不和</em> </strong> </a>T55】</p></div></div>    
</body>
</html>