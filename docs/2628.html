<html>
<head>
<title>Create a React RSS Feed App for YouTube Feeds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为YouTube源创建一个React RSS源应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-react-rss-feed-app-for-youtube-feeds-69c8cd2dbd46?source=collection_archive---------3-----------------------#2022-06-22">https://javascript.plainenglish.io/create-a-react-rss-feed-app-for-youtube-feeds-69c8cd2dbd46?source=collection_archive---------3-----------------------#2022-06-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7626" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用create-react-app创建您自己的个人YouTube源。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3257d658b204fa8287476383959d8c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZPcMGjZK8chQSL8j"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@visualize?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rux Centea</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="cd39" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">问题是</h2><p id="9e55" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">拥有数百个YouTube频道订阅，很难在你的每日提要中找到新的更长的see，从而很难找到特定类别的新视频。</p><h2 id="24ba" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">解决方案</h2><p id="91cc" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">本文将介绍如何创建一个应用程序，该应用程序将有多组YouTube频道提要，这些提要按类别分开，这样您就可以利用YouTube RSS(真正简单的聚合)提要来查看每个类别中的最新视频。</p><h2 id="4ddc" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">先决条件</h2><p id="16dc" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">在本文的最后，会有一个到GitHub存储库的链接，其中包含完整的应用程序。如果你想自己创建应用程序，你需要在你的机器上安装一些应用程序。</p><p id="8705" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在你的机器上安装【git Git Bash很好。使用Git Bash，您可以为您的终端获得一个Linux shell。这篇文章是用以下版本的<code class="fe mn mo mp mq b">git</code>写的。</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="c749" class="kt ku in mq b gy mv mw l mx my">$ git --version ## 2.34.1.windows.1</span></pre><p id="34ab" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">我在撰写本文时使用的目标机器运行在Windows上，但是您应该能够在任何操作系统上安装这些应用程序。你可以在这里下载安装<code class="fe mn mo mp mq b">git</code>、<a class="ae ks" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ab64" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">对于JavaScript开发，您需要安装了<code class="fe mn mo mp mq b">npm</code>和<code class="fe mn mo mp mq b">npx</code>的Node.js。对于<code class="fe mn mo mp mq b">npm</code>和<code class="fe mn mo mp mq b">npx</code>，您将需要一个高于6.0.0主版本。可以安装最新版本的Node.js，它也会安装<code class="fe mn mo mp mq b">npm</code>和<code class="fe mn mo mp mq b">npx</code>，这里的<a class="ae ks" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">是</a>。本文有以下版本:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="cf57" class="kt ku in mq b gy mv mw l mx my">$ node --version ## v16.13.1<br/>$ npm --version  ## v8.1.2<br/>$ npx --version  ## v8.1.2</span></pre><p id="f900" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">一旦安装了<code class="fe mn mo mp mq b">npm</code>，您将希望使用全局安装命令安装<code class="fe mn mo mp mq b">create-react-app</code>:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="6990" class="kt ku in mq b gy mv mw l mx my">$ npm install -g create-react-app  ## allows you to use CRA cli<br/>$ create-react-app --version       ## v5.0.1</span></pre><p id="2df2" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">如果你想探索更多的<code class="fe mn mo mp mq b">create-react-app</code>功能，这个应用有很棒的文档，<a class="ae ks" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="6197" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">您应该使用的另一个工具是IDE。可视化代码很有用，并且有大量的插件，你可以为JavaScript和React开发安装这些插件。如果你对使用可视化代码感兴趣，你可以从<a class="ae ks" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank">这里</a>下载安装。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="6b56" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">入门指南</h1><p id="1ab7" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">创建我们的应用程序有五个步骤:首先，生成样板应用程序。其次，创建我们将用来显示数据的react组件。第三，我们将定位我们的数据源。第四，我们安装并设置我们的应用程序来解释数据。最后，我们在应用程序中设置调用来提取数据并在应用程序中显示。</p><h1 id="5f6c" class="ng ku in bd kv nh nr nj ky nk ns nm lb jt nt ju lf jw nu jx lj jz nv ka ln nq bi translated">生成应用程序</h1><p id="1cad" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">创建应用程序的第一步是生成锅炉板。进入您保存项目存储库的目录，在您的终端中，生成您的新CRA。</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="e285" class="kt ku in mq b gy mv mw l mx my">$ create-react-app rss-feed-medium-app<br/>$ cd rss-feed-medium-app<br/>$ npm start</span></pre><p id="a7f5" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">这将创建并安装所有默认依赖项，可能需要几分钟时间。因为所有的东西都是用这个命令安装的，所以你可以在这个命令运行完之后马上运行这个应用程序，并且看到CRA程序的默认内容。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/49bbb2ea3a44410f281676e933281246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*1LxviPlheKWCzuvW5ZrEMA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Boiler plate CRA app</figcaption></figure><h2 id="43cb" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">样板文件清理</h2><p id="db48" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">锅炉板是一个好的开始，但是我们不需要代码中的大部分内容。所以我们可以通过<code class="fe mn mo mp mq b">App.css</code>、<code class="fe mn mo mp mq b">App.js</code>和<code class="fe mn mo mp mq b">App.test.js</code>，清除一堆代码。由于这种编码几乎完全是删除代码，而不是编写代码片段，<code class="fe mn mo mp mq b">git</code> diff显示了所需的更新。</p><p id="e9ec" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在diff图像的左边，读取的代码是删除的代码，右边绿色部分是任何添加的代码(还不多)。首先，最大的变化是在<code class="fe mn mo mp mq b">App.css</code>文件中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/06f52f70def9b5f9b22683751bf89b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHGj2rrZbXyXjgBRAiOy6w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App.css cleanup diff.</figcaption></figure><p id="dcbb" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">然后，删除<code class="fe mn mo mp mq b">App.js</code>文件中<code class="fe mn mo mp mq b">App</code>组件的代码。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/1af4409e404627e1bc4cbdc3f516b24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9UZ3aG0PFvRM0w6gapDzA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App.js cleanup diff.</figcaption></figure><p id="34a5" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">最后，更新<code class="fe mn mo mp mq b">App.test.js</code>以便在运行时测试通过。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/48674d981eec89d4dc8d656d311ba0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bs8hdq2I83MLZRystvazIA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App.test.js cleanup diff.</figcaption></figure><p id="ad0e" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">您也可以删除<code class="fe mn mo mp mq b">src/logo.svg</code>，因为它已从应用程序中删除。</p><h1 id="a5d4" class="ng ku in bd kv nh nr nj ky nk ns nm lb jt nt ju lf jw nu jx lj jz nv ka ln nq bi translated">创建视图组件</h1><p id="dc81" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">现在我们可以为RSS提要创建显示组件了。这些组件将在我们已经知道提要的数据形状的情况下被创建(关于数据的更多细节将会出现)。</p><h2 id="961b" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">安装组件目录</h2><p id="69ad" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">我们将创建三个视图组件:一个用于提要的每个条目的<code class="fe mn mo mp mq b">Entry</code>组件，一个用于显示RSS提要列表的<code class="fe mn mo mp mq b">EntryList</code>组件，以及一个用于选择我们希望在RSS提要中显示的频道类型的<code class="fe mn mo mp mq b">CategorySelector</code>组件。</p><p id="b0b5" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">首先在现有的<code class="fe mn mo mp mq b">src</code>目录下创建一个<code class="fe mn mo mp mq b">components</code>目录。然后在<code class="fe mn mo mp mq b">components</code>下为每个组件添加一个目录:<code class="fe mn mo mp mq b">CategorySelector</code>、<code class="fe mn mo mp mq b">Entry</code>、<code class="fe mn mo mp mq b">EntryList</code>。现在在每个目录中，创建两个与目录名匹配的文件:扩展名<code class="fe mn mo mp mq b">.js</code>和<code class="fe mn mo mp mq b">.test.js</code>。对于<code class="fe mn mo mp mq b">Entry</code>和<code class="fe mn mo mp mq b">EntryList</code>组件，还要添加一个<code class="fe mn mo mp mq b">.css</code>文件。一旦完成，<code class="fe mn mo mp mq b">src</code>目录将如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a72c9f4655406428f8cf240fdb557f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*yonfoyAnDxjCks-etJpWtw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">New files for components</figcaption></figure><h2 id="f69e" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">类别选择器组件</h2><p id="be8b" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">我们将创建的第一个组件(经过一些测试)是<code class="fe mn mo mp mq b">CategorySelector</code>。下面是GitHub组件及其测试的要点。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">CategorySelector</figcaption></figure><p id="af3f" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">为了检查组件逻辑，它接收一个列表<code class="fe mn mo mp mq b">categories</code>，稍后我们将根据我们希望在提要中看到的频道类型创建这个列表。对于每个类别，它都会创建一个单选按钮。当按钮被选中时，它将该选择发送给一个<code class="fe mn mo mp mq b">onSelect</code>函数，让父组件知道应该在提要中显示一组新的类别。</p><p id="a966" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">CSS文件非常紧凑，只有几个属性:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="74e3" class="kt ku in mq b gy mv mw l mx my">/** CategorySelector.css */<br/>.CategorySelector-root input {<br/>    margin-bottom: 12px;<br/>    margin-right: 12px;<br/>}</span></pre><h2 id="b83a" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">RSS条目组件</h2><p id="9908" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">现在我们想要为单独的提要条目创建<code class="fe mn mo mp mq b">Entry</code>组件。该组件将有一些基本的数据点，有一个缩略图(由URL提供)、一个JSON日期字符串和一个在新的浏览器选项卡中打开视频的链接。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="cfec" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">Entry组件的样式表拥有应用程序中的大多数样式，因为它排列了数据点和图像。这是风格的要点。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7dd1" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">最终，每个RSS条目都会像这样出现(减去lorem ipsum文本，来自<a class="ae ks" href="https://hipsum.co/" rel="noopener ugc nofollow" target="_blank">hipsum.co</a>)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/cd5165abacf236e4c0e0d3857495b248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*KH98loN76gzPKlRQsyDuQA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">RSS Entry display.</figcaption></figure><h2 id="7fdd" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">EntryList组件</h2><p id="eb60" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">最后一个组件是显示所有RSS条目的<code class="fe mn mo mp mq b">EntryList</code>组件。它的全部目的是接受一个RSS条目列表，并迭代显示它们。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="48a0" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">因为<code class="fe mn mo mp mq b">EntryList</code>的目的是迭代RSS数据，所以它没有CSS文件。</p><h2 id="58e7" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">向应用程序添加组件</h2><p id="99a6" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">在开始提取和设置数据之前，我们做的最后一步是将组件添加到<code class="fe mn mo mp mq b">App</code>组件中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="27a1" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">您可以在要点中看到，我们添加了<code class="fe mn mo mp mq b">useState</code>来维护一个RSS条目对象列表和另一个类别字符串列表。</p><p id="0310" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">现在有一个带有空依赖数组的<code class="fe mn mo mp mq b">useEffect</code>设置。它将用于生成基于静态数据的类别列表，该列表将与RSS提要URL列表一起添加。类别列表将被传递到<code class="fe mn mo mp mq b">CategorySelector</code>组件<code class="fe mn mo mp mq b">categories</code>道具中。</p><p id="1b00" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">传递给<code class="fe mn mo mp mq b">CategorySelector</code>、<code class="fe mn mo mp mq b">onSelect</code>道具的处理函数被设置为最终为<code class="fe mn mo mp mq b">entries</code>道具加载数据，该道具为<code class="fe mn mo mp mq b">EntryList</code>提供数据。</p><h1 id="e3cc" class="ng ku in bd kv nh nr nj ky nk ns nm lb jt nt ju lf jw nu jx lj jz nv ka ln nq bi translated">设置数据源</h1><p id="8e61" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">接下来的几个步骤将是建立我们的数据源，设置一些静态数据，并探索如何处理数据。</p><h2 id="be9c" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">YouTube RSS源URL</h2><p id="8c74" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">最近，YouTube使得寻找频道RSS源变得有些混乱。为了找到频道源URL，您需要转到该频道的主页。然后，在Chrome浏览器中，右键单击并选择“查看页面源代码”(在Windows上，您也可以单击Ctrl + U)。</p><p id="8823" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">现在，一旦页面源代码打开，您就可以进行“查找”，并在页面中搜索RSS提要URL。为此，打开浏览器的控件(右上角的三个点)并单击“查找”，或者在windows上按Ctrl + F。搜索<code class="fe mn mo mp mq b">title="RSS"</code>，按回车键。您将被带到一个带有该频道RSS源元数据的<code class="fe mn mo mp mq b">link</code>标签。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/f67e35f60a216491924e240de1b45235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z17zdMLO2uctW2mjIeGl_A.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gathering YouTube RSS feed.</figcaption></figure><p id="652a" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">抓取<code class="fe mn mo mp mq b">href</code>属性值并复制。如果您将它粘贴到一个新的浏览器选项卡中，您可以看到将返回的XML有效负载。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/29bd1319f16abcb3337809cd788f128d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADA2Yg0OVtAM1WH31eQ8jA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">XML RSS Feed from YouTube</figcaption></figure><p id="3e93" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">查看浏览器中的有效负载，可以看到有很多元数据可以使用。总共有15个入口部分。这是将返回的最大数量，是来自该渠道的15个最新版本。</p><h2 id="ceb1" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">将提要加载到应用程序中</h2><p id="3869" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">现在我们可以在<code class="fe mn mo mp mq b">src</code>目录中创建一个<code class="fe mn mo mp mq b">lib.js</code>文件。在这个库中，将会有一个<code class="fe mn mo mp mq b">fetchFeed</code>函数，目前它没有参数，并且硬编码了频道RSS提要URL。</p><p id="384d" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">我们将使用<code class="fe mn mo mp mq b">fetch</code>函数进行API调用，因为这个请求是一个简单的GET。除了提要URL，我们还需要使用CORS代理。这是因为YouTube不允许来自<code class="fe mn mo mp mq b">localhost</code>的请求。</p><p id="d165" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">获取数据后，调用<code class="fe mn mo mp mq b">response</code>上的<code class="fe mn mo mp mq b">text()</code>来获取XML的字符串。目前，所有的回调都只是将内容记录到控制台，以检查浏览器中发生了什么。</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="bb05" class="kt ku in mq b gy mv mw l mx my">const corsProxy = "https://cors.eu.org/";<br/>const fetchFeed = () =&gt; {<br/>  const url = "https://www.rss-feed-url.com";<br/>  fetch(corsProxy + url)<br/>    .then((res) =&gt; res.text()<br/>      .then((data) =&gt; console.info("data", data))<br/>      .catch((err) =&gt; console.warn("data err", err))<br/>      .finally(() =&gt; console.info("data complete")))<br/>    .catch((err) =&gt; console.warn("res err", err))<br/>    .finally(() =&gt; console.info("res complete"));<br/>};</span><span id="7d5a" class="kt ku in mq b gy og mw l mx my">export { fetchFeed };</span></pre><p id="3b1c" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">为了测试这个函数，我们可以将它添加到<code class="fe mn mo mp mq b">App</code>组件的<code class="fe mn mo mp mq b">useEffect</code>中，而不在依赖数组中添加任何内容。这里是调用应用中的<code class="fe mn mo mp mq b">fetchFeed()</code>功能后的浏览器控制台。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/0ce2548a81da3f3aa475de16c3e2d096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozrQE84CtJdnCVqWPQBkTQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Console of printed XML payload</figcaption></figure><h1 id="8852" class="ng ku in bd kv nh nr nj ky nk ns nm lb jt nt ju lf jw nu jx lj jz nv ka ln nq bi translated">升级应用程序</h1><p id="28f2" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">为了处理来自提要的XML，我们需要配置项目来使用一些新的包。</p><h2 id="80df" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">安装新的依赖项</h2><p id="c08a" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">首先，我们将安装所需的依赖项，列表如下:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="5a64" class="kt ku in mq b gy mv mw l mx my">$ npm i xml2js             ## for processing the XML to JSON<br/>$ npm i buffer             ## xml2js dependency<br/>$ npm i process            ## xml2js dependency<br/>$ npm i stream-browserify  ## xml2js dependency<br/>$ npm i timers-browserify  ## xml2js dependency<br/>$ npm i react-app-rewired  ## for webpack configuration overriding</span></pre><p id="77df" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><code class="fe mn mo mp mq b">xml2js</code>包用于将XML转换成JSON，为了让<code class="fe mn mo mp mq b">xml2js</code>运行，需要下面四个包。最后一个依赖项<code class="fe mn mo mp mq b">react-app-rewired</code>用于配置<code class="fe mn mo mp mq b">webpack</code>，这个工具将我们的JavaScript编译成一个文件，放在<code class="fe mn mo mp mq b">create-react-app</code>中，而不弹出配置。</p><h2 id="02ef" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">重新连接应用程序</h2><p id="4d86" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">现在我们可以设置覆盖文件了。</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="7706" class="kt ku in mq b gy mv mw l mx my">// config-overrides.js<br/>const { ProvidePlugin } = require("webpack");</span><span id="281d" class="kt ku in mq b gy og mw l mx my">module.exports = function override(config) {<br/>  config.plugins.push(new ProvidePlugin({<br/>    Buffer: ["buffer", "Buffer"]<br/>  }));<br/>  config.plugins.push(new ProvidePlugin({<br/>    process: "process/browser"<br/>  }));<br/>  config.resolve.fallback = {<br/>    buffer: require.resolve("buffer/"),<br/>    stream: require.resolve("stream-browserify"),<br/>    timers: require.resolve("timers-browserify"),<br/>  };<br/>  return config;<br/>};</span></pre><p id="04b4" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">setup react-app-rewired with config-overrides . js<br/>我们还必须更新<code class="fe mn mo mp mq b">package.json</code>中的<code class="fe mn mo mp mq b">scripts</code>部分，以进行重新布线。这是变化的样子，原来的<code class="fe mn mo mp mq b">scripts</code>在左边是红色，新的<code class="fe mn mo mp mq b">scripts</code>在右边是绿色。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/83ec261c34332a7711adec15dd26c52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CC7S49Chb5IK1XkGV9wIMQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Rewired package diff.</figcaption></figure><h1 id="0eda" class="ng ku in bd kv nh nr nj ky nk ns nm lb jt nt ju lf jw nu jx lj jz nv ka ln nq bi translated">提取数据</h1><p id="1b0b" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">既然应用程序已经设置为将XML作为JSON使用，我们就可以更新<code class="fe mn mo mp mq b">fetchFeed</code>函数了。</p><h2 id="219b" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">解析XML</h2><p id="6ac4" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">首先将<code class="fe mn mo mp mq b">xml2js</code>包中的<code class="fe mn mo mp mq b">parseString</code>函数导入到<code class="fe mn mo mp mq b">lib.js</code>文件中。</p><p id="e4f4" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">设置XML到JSON的处理。该函数接受两个参数:一个XML字符串和一个回调函数。回调签名是<code class="fe mn mo mp mq b">function callback(error, result);</code>。</p><p id="718d" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">该错误仅在解析字符串时发生错误时定义，结果是XML的JSON转换。我们可以看到:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="7733" class="kt ku in mq b gy mv mw l mx my">import { parseString } from "xml2js"</span><span id="e07e" class="kt ku in mq b gy og mw l mx my">// original fetch() call<br/>  fetch(corsProxy + url)<br/>    .then((res) =&gt; res.text()<br/>      .then((data) =&gt; console.info("data", data))<br/>      .catch((err) =&gt; ...</span><span id="1f59" class="kt ku in mq b gy og mw l mx my">// updated fetch() call<br/>  fetch(corsProxy + url)<br/>    .then((res) =&gt; res.text()<br/>      .then((data) =&gt; parseString(data, (err, res) =&gt; {<br/>        console.warn("err", err);<br/>        console.info("res", res);<br/>      }))<br/>      .catch((err) =&gt; ...</span></pre><p id="7936" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">更新功能运行App后，我们可以在浏览器的控制台中看到<code class="fe mn mo mp mq b">result</code>物体是如何塑造的。探索一下，可以看到所有的RSS条目数据都存储在一个数组中，在键<code class="fe mn mo mp mq b">result.feed.entry</code>下。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/d9542c8e831393415f64c383ae4bbefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DgguIRZ0WHRCXDPMX4gSg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">RSS converted JSON feed.</figcaption></figure><p id="9156" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">我们只需要这个有效负载的一部分，所以我们可以在这里处理数据，并塑造我们希望应用程序如何使用它。该应用程序需要的唯一值是:作者、视频名称、视频链接、发布日期、缩略图链接和唯一Id。</p><p id="8f85" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">探索浏览器控制台中的形状以在条目中找到所有这些属性，将向我们展示如何从有效负载中提取数据。我们可以为<code class="fe mn mo mp mq b">parseString</code>编写一个回调函数来提取所有这些数据。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="270e" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">现在，我们不只是将清理后的数据记录到控制台，而是将这些数据放入应用程序中。我们可以用回调函数来实现。</p><h2 id="ddf1" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">将数据加载到应用程序</h2><p id="cf25" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">首先，我们将创建一个静态的<code class="fe mn mo mp mq b">feeds</code>对象，用于创建一个<code class="fe mn mo mp mq b">categoryList</code>，并存储频道提要的URL。为此，我们将在<code class="fe mn mo mp mq b">src</code>下创建一个新文件和目录，名为<code class="fe mn mo mp mq b">assets/feeds.js</code>。这个文件将包含一个对象，一个类别列表作为URL字符串数组的键，如下所示:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="81f7" class="kt ku in mq b gy mv mw l mx my">// src/assets/feeds.js<br/>const feeds = {<br/>  "comedy": [<br/>    // channel name here<br/>    "https://www.comedy-channel.com/rss/feed",<br/>  ],<br/>  "gaming": [<br/>    // channel name here<br/>    "https://www.gaming-channel.com/rss/feed",<br/>  ],<br/>  "techno": [<br/>    // channel name here<br/>    "https://www.techno-music-channel.com/rss/feed",<br/>  ],<br/>};</span><span id="5641" class="kt ku in mq b gy og mw l mx my">export default feeds;</span></pre><p id="2ead" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">然后，将<code class="fe mn mo mp mq b">feeds</code>对象导入到<code class="fe mn mo mp mq b">lib.js</code>文件中，并设置一个接受类别名和回调的新函数:<code class="fe mn mo mp mq b">fetchCategroyFeeds</code>。更新<code class="fe mn mo mp mq b">fetchFeed</code>函数以接受两个参数；<code class="fe mn mo mp mq b">category</code>和一个<code class="fe mn mo mp mq b">callback</code>。</p><p id="c2ff" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><code class="fe mn mo mp mq b">parseStringCallback</code>现在也接受一个<code class="fe mn mo mp mq b">callback</code>参数。此<code class="fe mn mo mp mq b">callback</code>用于将处理后的进给数据返回给组件。<code class="fe mn mo mp mq b">lib.js</code>文件将看起来像这个新版本。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="bcc4" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在<code class="fe mn mo mp mq b">App.js</code>文件中，将<code class="fe mn mo mp mq b">feeds</code>添加到组件中，并使用函数<code class="fe mn mo mp mq b">Object.keys(feeds)</code>使用if创建一个<code class="fe mn mo mp mq b">categoryList</code>。将类别状态设置为第一个<code class="fe mn mo mp mq b">useEffect</code>中的<code class="fe mn mo mp mq b">categoryList</code>。</p><p id="74c3" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">然后可以更新<code class="fe mn mo mp mq b">handleSelect</code>函数来使用<code class="fe mn mo mp mq b">fetchCategoryFeeds</code>，并传入<code class="fe mn mo mp mq b">selectedCategory</code>实参作为第一个参数，然后传入<code class="fe mn mo mp mq b">setEntries</code>状态调用作为回调。这将加载检索到的提要作为状态。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9254" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">此时，您应该根据您在顶部选择的单选按钮拉入数据并显示条目。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/1df2953c8419d617abc8ed3091016fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VitCvFiXZcohUrtENT8TsA.gif"/></div></div></figure><h2 id="5894" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">合并摘要数据</h2><p id="86e1" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">最后一步是在每个类别中设置多个提要。一旦您找到多个提要并提取它们的RSS提要，您的<code class="fe mn mo mp mq b">feeds.js</code>文件将如下所示:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="f65d" class="kt ku in mq b gy mv mw l mx my">// src/assets/feeds.js<br/>const feeds = {<br/>  "comedy": [<br/>    // channel one name here<br/>    "https://www.comedy-one-channel.com/rss/feed",<br/>    // channel two name here<br/>    "https://www.comedy-two-channel.com/rss/feed",<br/>  ],<br/>  "gaming": [<br/>    // channel one name here<br/>    "https://www.gaming-one-channel.com/rss/feed",<br/>    // channel two name here<br/>    "https://www.gaming-two-channel.com/rss/feed",<br/>    // channel three name here<br/>    "https://www.gaming-three-channel.com/rss/feed",<br/>  ],<br/>  "techno": [<br/>    // channel one name here<br/>    "https://www.techno-one-music-channel.com/rss/feed",<br/>    // channel two name here<br/>    "https://www.techno-two-music-channel.com/rss/feed",<br/>  ],<br/>};</span><span id="6c63" class="kt ku in mq b gy og mw l mx my">export default feeds;</span></pre><p id="c577" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">您可以在<code class="fe mn mo mp mq b">App.js</code>组件中创建一个合并函数，以便调用多个提要，然后按照发布日期对每个提要中的条目进行排序。您还将使用新的<code class="fe mn mo mp mq b">handleEntriesMerge</code>方法代替<code class="fe mn mo mp mq b">setEntries</code>来替换<code class="fe mn mo mp mq b">callback</code>参数。</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="6653" class="kt ku in mq b gy mv mw l mx my">const handleSelect = (selectedCategory) =&gt; {<br/>  setEntries([]);<br/>  fetchCategoryFeeds(selectedCategory, handleEntriesMerge);<br/>}</span><span id="c4d3" class="kt ku in mq b gy og mw l mx my">const handleEntriesMerge = (data) =&gt; {<br/>  setEntries((prev) =&gt; {<br/>    return prev.concat(data).sort((a, b) =&gt; {<br/>      const dateA = new Date(a.publishDate);<br/>      const dateB = new Date(b.publishDate);<br/>      return dateA &gt; dateB ? -1 : 1;<br/>    });<br/>  });<br/>}</span></pre><p id="2f4f" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">然后在<code class="fe mn mo mp mq b">lib.js</code>文件中，更新<code class="fe mn mo mp mq b">fetchCategoryFeeds</code>来遍历所有的提要URL。</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="0096" class="kt ku in mq b gy mv mw l mx my">const fetchCategoryFeeds = (category, callback) =&gt; {<br/>  const { length } = feeds[category];<br/>  for (let idx = 0; idx &lt; length; idx++) {<br/>    fetchFeed(feeds[category][idx], callback);<br/>  }<br/>};</span></pre><h2 id="1ac2" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">最终产品</h2><p id="c861" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">这是每个类别中有多个提要的成品的样子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/08f84297340b7acb051aa3b437da286e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YGsdpZYBS3Nz65aM7d81rA.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Finished Product</figcaption></figure><p id="7dfb" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">这里是GitHub 上的最终源代码，包含创建应用程序的所有更改。您可以在这里用命令检查确切的版本:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="eb3e" class="kt ku in mq b gy mv mw l mx my">$ git clone <a class="ae ks" href="https://github.com/cameronDz/homepage-ui.git" rel="noopener ugc nofollow" target="_blank">https://github.com/cameronDz/rss-feed-medium-app.git</a><br/>$ cd rss-feed-medium-app<br/>$ git checkout tags/v1.0.0<br/>$ npm install<br/>$ npm run start</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="c0ac" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">结论</h2><p id="d7d2" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">希望你学到了一些新的东西，这个应用程序作为一个实际的日常工具对你有用。祝你好运，并快乐编码！</p><p id="378e" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><em class="ok">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lr io"> <em class="ok">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lr io"> <em class="ok">免费周报</em> </strong> </a> <em class="ok">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lr io"><em class="ok">Twitter</em></strong></a><em class="ok">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lr io"><em class="ok">LinkedIn</em></strong></a><em class="ok">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lr io"> <em class="ok">社区不和谐</em> </strong> </a> <em class="ok">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="lr io"> <em class="ok">人才集体</em> </strong> </a> <em class="ok">。</em></strong></a></p></div></div>    
</body>
</html>