<html>
<head>
<title>Angular: Different ways and places you can provide Services and their impact on the Singleton Status of Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:可以提供服务的不同方式和位置，以及它们对服务的单体状态的影响</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-different-ways-and-places-you-can-provide-services-and-their-impact-on-the-singleton-81fc2fe538bf?source=collection_archive---------2-----------------------#2022-11-26">https://javascript.plainenglish.io/angular-different-ways-and-places-you-can-provide-services-and-their-impact-on-the-singleton-81fc2fe538bf?source=collection_archive---------2-----------------------#2022-11-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c8ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">缺省情况下，Angular中的服务是单例的。就这样结束了吗？不完全是。大多数情况下，我们只在以下两个地方提供服务:</p><ol class=""><li id="7dda" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">AppModule中的<strong class="jm io"> @NgModule({}) </strong>定义的Providers数组</li><li id="e118" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">@ injectible({ })decorator在服务类本身。</li></ol><p id="1408" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两种方法几乎一样，做同样的工作，除了第二种方法有<strong class="jm io">摇树优势</strong>而第一种方法没有。对于第二种方法，如果我不在应用程序的任何地方使用(即注入到一个类的构造函数中)该服务，该服务就不会包含在最终的包中。</p><p id="e3e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个故事的目标是<strong class="jm io">依赖注入系统在不同层级提供服务时如何反应</strong>。我不会急于/懒惰地加载功能模块。这将在下一个故事中涉及。为了保持简单和避免混乱，我们只对AppModule进行了限制。</p><p id="4048" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经创建了一个包含以下组件的项目:</p><p id="511d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ParentComponent </strong></p><p id="be2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">子组件</strong>-父组件的子组件</p><p id="8a70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">Sibling component</strong>-parent component的同级</p><p id="c207" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有两个服务:<strong class="jm io">数据服务</strong>和<strong class="jm io">测试服务</strong>。</p><p id="0fb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是<strong class="jm io"> AppModule </strong>定义的样子。</p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="f63f" class="lf lg in lb b be lh li l lj lk">@NgModule({<br/>imports: [BrowserModule, FormsModule],<br/>declarations: [<br/>AppComponent,<br/>ParentComponent,<br/>ChildComponent,<br/>SiblingComponent,<br/>],<br/>bootstrap: [AppComponent],<br/>providers: [DataService],<br/>})<br/><br/>export class AppModule {}</span></pre><p id="3e8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经将<strong class="jm io">数据服务</strong>添加到NgModule的<strong class="jm io">【提供者】</strong>中。提供服务不会创建服务的实例。只有当服务被注入到需要它的类的构造函数中时，才会创建实例。</p><p id="553c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着每当DataService被注入到应用程序中任何类的构造函数中时，DataService的同一个实例将对所有其他类可用。</p><p id="aa73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种说法很少有例外。让我们来演示这些异常。</p><p id="a7a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是DataService的样子。我们已经创建了一个属性<strong class="jm io"> randomNum </strong>来保存一个随机数。<strong class="jm io"> fetchNumber() </strong>返回这个随机生成的数字。</p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="cdb7" class="lf lg in lb b be lh li l lj lk">@Injectable()<br/>export class DataService {<br/>constructor() {}<br/><br/>public randomNum: number = Math.floor(Math.random() * 100);<br/><br/>fetchNumber() {<br/>return this.randomNum;<br/>}<br/>}</span></pre><p id="ab3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果DataService 的<strong class="jm io">相同实例被注入到所有类中，那么所有类都必须接收到<strong class="jm io">相同的随机数</strong>。</strong></p><p id="983e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> AppComponent类:</strong>我们已经调用了DataService的<strong class="jm io"> fetchNumber() </strong>来获取生成的随机数。</p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="ac32" class="lf lg in lb b be lh li l lj lk">@Component({<br/>selector: ‘my-app’,<br/>templateUrl: ‘./app.component.html’,<br/>styleUrls: [ ‘./app.component.css’ ]<br/>})<br/><br/>export class AppComponent {<br/>constructor(private service: DataService) {}<br/>public randomNumber: number;<br/><br/>ngOnInit() {<br/>this.randomNumber = this.service.fetchNumber();<br/>}<br/>}</span></pre><p id="b8bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> AppComponent模板:</strong>我们已经显示了随机数，并且还包含了对<strong class="jm io"> ParentComponent </strong>和<strong class="jm io"> SiblingComponent </strong>的引用。</p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="f852" class="lf lg in lb b be lh li l lj lk">&lt;p&gt;Value received in App :{{ randomNumber }}&lt;/p&gt;<br/>&lt;app-parent&gt;&lt;/app-parent&gt;<br/>&lt;app-sibling&gt;&lt;/app-sibling&gt;</span></pre><p id="b4fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ChildComponent和SiblingComponent </strong>是AppComponent的精确<strong class="jm io"> </strong>副本。正如所料，ChildComponent将被托管在<strong class="jm io"> ParentComponent </strong>中。</p><p id="f79d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，让我们看看ParentComponent。</p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="11fb" class="lf lg in lb b be lh li l lj lk">@Component({<br/>selector: ‘app-parent’,<br/>templateUrl: ‘./parent.component.html’,<br/>styleUrls: [‘./parent.component.css’],<br/>providers: [DataService]<br/>})<br/><br/>export class ParentComponent implements OnInit {<br/>constructor(private service: DataService){ }<br/><br/>public randomNumber: number;<br/><br/>ngOnInit() {<br/>this.randomNumber = this.service.fetchNumber();<br/>}<br/>}</span></pre><p id="dcf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ParentComponent看起来类似于AppComponent，但是请注意，我们已经在ParentComponent的[providers]中提供了DataService。</p><p id="8852" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ParentComponent模板:</strong></p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="4ffd" class="lf lg in lb b be lh li l lj lk">&lt;p&gt;Value received in Parent :{{ randomNumber }}&lt;/p&gt;<br/>&lt;app-child&gt;&lt;/app-child&gt;</span></pre><figure class="kw kx ky kz gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi ll"><img src="../Images/4bc9f7a915c1701d04f28491cb469b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jZ8F5GQkQXPmjasDBnZvQ.png"/></div></div></figure><p id="1562" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">AppComponent和SiblingComponent收到的随机数相同。</p><p id="1789" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ParentComponent和ChildComponent收到的随机数相同。</p><p id="d0df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么结果会有差异？让我们看看DI系统是如何工作的。</p><ol class=""><li id="9f3c" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">当我将DataService注入到AppComponent的构造函数中时，DI系统将检查服务实例对于与AppComponent关联的注入器是否可用。</li></ol><p id="5355" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于DataService不是在AppComponent级别提供的，并且由于AppComponent没有任何父级，DI系统将使用与<strong class="jm io"> AppModule </strong>相关联的<strong class="jm io"> RootModuleInjector </strong>来检查服务实例是否可用。</p><p id="60c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在AppModule 的【providers】中提供了<strong class="jm io">数据服务。因此，DI系统可以使用<strong class="jm io"> RootModuleInjector </strong>找到服务实例。</strong></p><p id="5e70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.当我将DataService注入到<strong class="jm io"> SiblingComponent </strong>的构造函数中时，DI系统将检查服务实例是否可以与SiblingComponent关联的注入器一起使用。</p><p id="8906" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要！<strong class="jm io">在SiblingComponent级别</strong>不提供数据服务。因此，DI系统向上移动一个级别，并且<strong class="jm io">检查与SiblingComponent(即AppComponent)的父组件相关联的注入器。</strong></p><p id="6298" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">在AppComponent级别</strong>不提供DataService，由于AppComponent没有任何父级，DI系统将使用与<strong class="jm io"> AppModule </strong>关联的<strong class="jm io"> RootModuleInjector </strong>检查服务实例是否可用。先前已经创建的实例将被SiblingComponent重用。</p><p id="c948" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，它是可用的！所以<strong class="jm io"> AppComponent和SiblingComponent共享数据服务</strong>的同一个实例。这解释了两个组件如何从数据服务接收相同的随机数。</p><p id="787b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.移动到<strong class="jm io">父组件</strong>。当我将DataService注入到<strong class="jm io"> ParentComponent </strong>的构造函数中时，DI系统将检查服务实例是否可以用与<strong class="jm io"> ParentComponent </strong>相关联的注入器获得。</p><p id="a861" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，它是可用的！正如我们前面看到的，<strong class="jm io"> DataService是通过ParentComponent </strong>中的【providers】提供的。因此，与ParentComponent关联的<strong class="jm io">注入器将创建一个新的DataService实例。</strong></p><p id="2a45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这解释了为什么ParentComponent收到的随机数不同于AppComponent和SiblingComponent。</p><p id="3e01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.移动到<strong class="jm io">子组件</strong>。当我将DataService注入到<strong class="jm io">子组件</strong>的构造函数中时，DI系统将检查服务实例是否可用于与<strong class="jm io">子组件</strong>相关联的注入器。</p><p id="76a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不，它不可用！因此，DI系统向上移动一级，并且<strong class="jm io">检查该实例是否可用于与ChildComponent的父组件(即ParentComponent)相关联的注入器。</strong></p><p id="a183" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，它是可用的！DataService通过ParentComponent中的[providers]提供。因为与ParentComponent关联的injector已经创建了一个DataService实例，所以它不会再创建另一个实例。DI系统为ChildComponent重用相同的DataService实例。</p><p id="f6ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这解释了为什么ParentComponent和ChildComponent从DataService接收到相同的随机数。</p><p id="b884" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在我们有了数据服务的<strong class="jm io"> 2个不同的实例。</strong></p><p id="9e15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想用<strong class="jm io">测试服务</strong>展示另一个场景。这就是TestService的样子。我们使用<strong class="jm io"> fetchString() </strong>返回一个字符串“Hello World”。</p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="ea15" class="lf lg in lb b be lh li l lj lk">@Injectable()<br/>export class TestService {<br/>constructor() { }<br/><br/>public someString:string=”Hello World”<br/><br/>fetchString() {<br/>return this.someString;<br/>}<br/>}</span></pre><p id="32a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，TestService不是在<strong class="jm io"> AppModule </strong>级别提供的，也不是在TestService类级别使用<strong class="jm io">@ injective()</strong>中的<strong class="jm io"> providedIn属性</strong>提供的。那么在哪里提供呢？</p><p id="3517" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我稍微修改了SiblingComponent以适应TestService。我刚刚将TestService注入到构造器中，并在<strong class="jm io"> ngOnInit() </strong>中调用了<strong class="jm io"> fetchString() </strong>。</p><p id="eed7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过SiblingComponent中的[providers]提供测试服务。</p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="d2d4" class="lf lg in lb b be lh li l lj lk">@Component({<br/>selector: ‘app-sibling’,<br/>templateUrl: ‘./sibling.component.html’,<br/>styleUrls: [‘./sibling.component.css’],<br/>providers:[TestService]<br/>})<br/><br/>export class SiblingComponent implements OnInit {<br/>constructor(private dataService:DataService,private service: TestService) {}<br/><br/>public randomNumber:number;<br/><br/>ngOnInit() {<br/>this.service.fetchString();<br/>this.randomNumber = this.dataService.fetchNumber();<br/>}<br/>}</span></pre><p id="444f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题是，<strong class="jm io">任何其他类都可以访问TestService吗？让我们检查一下。</strong></p><p id="8b2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我修改了ParentComponent，在它的构造函数中注入了TestService。</p><pre class="kw kx ky kz gt la lb lc bn ld le bi"><span id="cbc0" class="lf lg in lb b be lh li l lj lk">export class ParentComponent implements OnInit {<br/>constructor(private service: DataService,private testService:TestService)<br/>{ }</span></pre><p id="8e81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是您将得到的错误。</p><figure class="kw kx ky kz gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lt"><img src="../Images/7fb6ad4a13224257f81f428201d970ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTBdUQMXawN9T_PDKJZ07w.png"/></div></div></figure><p id="ecf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来看看为什么？</p><p id="9466" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我将<strong class="jm io"> TestService </strong>注入到<strong class="jm io"> ParentComponent </strong>的构造函数中时，DI系统将检查服务实例是否可以使用与ParentComponent关联的注入器。</p><p id="7de1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">数据服务通过ParentComponent中的[providers]提供。不是测试服务</strong>。因此，TestService的一个实例在ParentComponent级别的注入器中不可用。</p><p id="ad18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，DI系统向上移动一个级别，<strong class="jm io">检查实例是否可用于与ParentComponent(即AppComponent)的父组件相关联的注入器。</strong></p><p id="24f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不，它不可用！<strong class="jm io">在AppComponent级别</strong>不提供TestService，由于AppComponent没有任何父级，DI系统将使用与<strong class="jm io"> AppModule </strong>关联的<strong class="jm io"> RootModuleInjector </strong>检查服务实例是否可用。</p><p id="85a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要！<strong class="jm io">app module级别也不提供测试服务。</strong></p><p id="9d1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当DI系统没有在任何注入器上找到TestService的实例时，它会抛出一个错误。</p><p id="27d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在下面找到完整的工作示例。</p><div class="lu lv gp gr lw lx"><a href="https://stackblitz.com/edit/angular-ox1luk?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd io gy z fp mc fr fs md fu fw im bi translated">角形(叉形)堆叠</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">stackblitz.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml lr lx"/></div></div></a></div><p id="5503" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mm">更多内容看</em> <a class="ae mn" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">说白了。报名参加我们的</em> <a class="ae mn" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">免费周报</em> </strong> </a> <em class="mm">。关注我们上</em> <a class="ae mn" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">推特</em> </strong> </a>，<a class="ae mn" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mm">LinkedIn</em></strong></a><strong class="jm io"><em class="mm">，</em></strong><a class="ae mn" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mm">YouTube</em></strong></a><strong class="jm io"><em class="mm">，</em> </strong> <em class="mm">和<a class="ae mn" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">不和</em> </strong></a></em> </strong> <em class="mm">对成长黑客感兴趣？检查出</em> </a><a class="ae mn" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">电路</em> </strong> </a> <strong class="jm io"> <em class="mm">。</em>T77】</strong></p></div></div>    
</body>
</html>