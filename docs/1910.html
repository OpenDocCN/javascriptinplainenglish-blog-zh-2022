<html>
<head>
<title>How the TypeScript Parameters Type Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript参数类型如何工作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-the-typescript-parameters-type-works-4d55b8389907?source=collection_archive---------11-----------------------#2022-04-28">https://javascript.plainenglish.io/how-the-typescript-parameters-type-works-4d55b8389907?source=collection_archive---------11-----------------------#2022-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d909" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是参数类型？它是TypeScript中的一种实用类型，允许我们获取函数的参数，并将其转换为一种新的类型。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/39d25d004c749c65043c61f55055d2b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RPDHVaAVvqHi70ya9RA3lQ.png"/></div></div></figure><p id="a300" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript <code class="fe lk ll lm ln b">Parameters</code>类型用于获取函数的<strong class="kq io">参数</strong>或<strong class="kq io">自变量</strong>，并基于它们创建一个新类型。当我们知道一个<code class="fe lk ll lm ln b">Function</code>的输入符合某种类型，并且我们想要复制它时，这是非常有用的。在本指南中，让我们看看<code class="fe lk ll lm ln b">Parameters</code>实用程序类型是如何工作的。</p><h1 id="26bb" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">TypeScript自定义类型</h1><p id="7882" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">本指南涵盖了自定义类型。如果你不熟悉自定义类型，请在这里阅读我的自定义类型指南。</p><h1 id="a350" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">参数类型如何工作</h1><p id="dade" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">假设你有一个函数，有一定数量的参数。例如，下面是一个带有两个参数的TypeScript函数，<code class="fe lk ll lm ln b">a</code>和<code class="fe lk ll lm ln b">b</code>:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="39fb" class="mq lp in ln b gy mr ms l mt mu">const myFunction = (a: string, b: string) =&gt; {<br/>    return a + b;<br/>}</span></pre><p id="200d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我们想要运行这个函数。一种方法是在数组中传递一个<a class="ae ml" href="https://fjolt.com/article/typescript-tuples" rel="noopener ugc nofollow" target="_blank">元组类型</a>的<a class="ae ml" href="https://fjolt.com/article/javascript-three-dots-spread-operator" rel="noopener ugc nofollow" target="_blank">三点</a>操作符。例如:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="163b" class="mq lp in ln b gy mr ms l mt mu">const myFunction = (a: string, b: string) =&gt; {<br/>    return a + b;<br/>}</span><span id="8e16" class="mq lp in ln b gy mv ms l mt mu">let passArray:[string, string] = [ 'hello ', 'world' ]</span><span id="9f64" class="mq lp in ln b gy mv ms l mt mu">// Returns 'hello world'<br/>myFunction(...passArray);</span></pre><p id="7101" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们定义了一个tuple，简单来说就是<code class="fe lk ll lm ln b">[string, string]</code>，我们可以将它传递给myFunction，同时满足<code class="fe lk ll lm ln b">a</code>和<code class="fe lk ll lm ln b">b</code>参数。</p><p id="4ac0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这很好，但是如果<code class="fe lk ll lm ln b">myFunction</code>的论点改变了呢？如果<code class="fe lk ll lm ln b">myFunction</code>来自第三方脚本，这种情况尤其可能发生。然后，我们不仅要更新函数，还要记得更新传入的元组类型。我们还需要保持包<code class="fe lk ll lm ln b">myFunction</code>的最新状态，以防它发生变化。</p><p id="13f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相反，如果我们想确保它们总是匹配的，我们可以使用<code class="fe lk ll lm ln b">Parameters</code>来产生相同的类型。这将创建一个元组类型的参数，而不是我们必须手动定义它:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="db4e" class="mq lp in ln b gy mr ms l mt mu">type myType = Parameters&lt;typeof myFunction&gt;<br/>// Equivalent to a tuple type of:<br/>// type myType = [ a: string, b: string ]</span></pre><p id="71fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这让我们在定义自定义类型时省去了一些麻烦，因为我们现在可以将类型为<code class="fe lk ll lm ln b">myType</code>的任何东西传递给<code class="fe lk ll lm ln b">myFunction</code>而不用担心出错:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="8b94" class="mq lp in ln b gy mr ms l mt mu">const myFunction = (a: string, b: string) =&gt; {<br/>    return a + b;<br/>}</span><span id="80e6" class="mq lp in ln b gy mv ms l mt mu">type myType = Parameters&lt;typeof myFunction&gt;</span><span id="08c0" class="mq lp in ln b gy mv ms l mt mu">let myArray:myType = [ 'hello ', 'world' ];</span><span id="b81a" class="mq lp in ln b gy mv ms l mt mu">myFunction(...myArray)</span></pre><h1 id="f945" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">使用参数实用程序类型键入特定参数</h1><p id="4970" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">参数类型也非常灵活，允许我们定义更多的参数。例如，如果我们只想匹配函数<code class="fe lk ll lm ln b">myFunction</code>中第一个参数的类型，我们可以像引用一个简单的数组一样，添加<code class="fe lk ll lm ln b">[0]</code>。下面将匹配<code class="fe lk ll lm ln b">a</code>的类型，但是如果我们想要匹配<code class="fe lk ll lm ln b">b</code>的类型，我们可以使用<code class="fe lk ll lm ln b">[1]</code>:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="7a74" class="mq lp in ln b gy mr ms l mt mu">type myType = Parameters&lt;typeof myFunction&gt;[0]<br/>// Equivalent of 'string'</span></pre><p id="72a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这样，如果需要的话，我们可以在代码中为每个参数定义自定义类型。例如，这里我们为函数的第一个和第二个参数定义了两个自定义类型，并将它们都传递给我们的函数:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="94c3" class="mq lp in ln b gy mr ms l mt mu">const myFunction = (a: string, b: string) =&gt; {<br/>    return a + b;<br/>}</span><span id="fe1f" class="mq lp in ln b gy mv ms l mt mu">type aType = Parameters&lt;typeof myFunction&gt;[0]<br/>type bType = Parameters&lt;typeof myFunction&gt;[1]</span><span id="e9db" class="mq lp in ln b gy mv ms l mt mu">let a:aType = 'hello '<br/>let b:bType = 'world'</span><span id="7c10" class="mq lp in ln b gy mv ms l mt mu">myFunction(a, b)</span></pre><h1 id="7033" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">参数带来更多乐趣</h1><p id="6d3d" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">由于<code class="fe lk ll lm ln b">Parameters</code>将参数的类型转换为新的类型，我们也可以直接传递一个函数给它。下面将产生一个类型<code class="fe lk ll lm ln b">[ a: string, b: number ]</code>。这不如从特定函数中获取参数有用，但在某些情况下可以派上用场:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="6986" class="mq lp in ln b gy mr ms l mt mu">type anotherType = Parameters&lt;(a: string, b: number) =&gt; void&gt;</span></pre><p id="9c8b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个题目到此为止。感谢您的阅读。</p><p id="7573" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mw">更多内容看</em> <a class="ae ml" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">说白了。报名参加我们的</em> <a class="ae ml" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae ml" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mw">Twitter</em></strong></a><em class="mw">和</em><a class="ae ml" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mw">LinkedIn</em></strong></a><em class="mw">。加入我们的</em> <a class="ae ml" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">社区</em> </strong> </a> <em class="mw">。</em></strong></a></p></div></div>    
</body>
</html>