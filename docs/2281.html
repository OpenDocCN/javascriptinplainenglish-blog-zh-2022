<html>
<head>
<title>Binary Heaps &amp; How to Implement Them in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二进制堆&amp;如何用JavaScript实现它们</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-heaps-in-javascript-ee497d905df?source=collection_archive---------16-----------------------#2022-05-26">https://javascript.plainenglish.io/binary-heaps-in-javascript-ee497d905df?source=collection_archive---------16-----------------------#2022-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="add5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中二进制堆实现的详细演练。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/554e925ac40521fd13afd458cad40274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyHiTR2xCnC1At1OQYryBA.jpeg"/></div></div></figure><p id="8ade" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">又见面了！</p><p id="6b36" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天的主题是二进制堆以及如何用JavaScript实现它们。二进制堆有很多用途，但是今天(为了保持我对简洁的热爱),我们将直接进入一个基本的解释/实现。</p><p id="0829" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们走吧！</p><p id="033d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">二进制堆vs .二叉树</em> </strong></p><p id="584a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在结构上，它们非常相似。我们有父母/孩子的关系，每个父母可能只有两个孩子。关键的区别在于，我们有不同的规则来规定值在树上的位置。</p><p id="7ce8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，有两种堆——最小堆和最大堆。</p><p id="f2e6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将从max-heap开始(本文剩余部分给出的解决方案也将主要关注max-heaps)</p><p id="28d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">概念很简单。每个子节点值必须小于其父节点值。所以…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/abee58504314854b6c8f7e580e17477e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vgt7aGxDim3VPpoNVRO6Zg.jpeg"/></div></div></figure><p id="9c37" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">…这是有效的最大堆。</p><p id="9382" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可能会立即注意到，有了堆，我们不需要遵守一些我们通常的二叉树规则。例如，6小于它的兄弟8，但是它在它的父树的右边。</p><p id="b9af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们唯一关心的是所有子节点值都小于它们的父节点值。</p><p id="4e74" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在(您可能已经猜到了)，最小堆正好相反。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e026fedd7289e1fcdac56d66ec46806d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTumTg4MLHhAfu8H3Xam4Q.jpeg"/></div></div></figure><p id="8af0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的子节点值必须大于其父节点值。</p><p id="b9cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我将提到堆的另一个规则——除了最深的层次之外，树的所有层次都必须完全填充。并且当最深层没有被完全填满时，存在的节点必须尽可能地靠左。所以…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fc2be2d77480a20e4f9e36f6539e3b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Vco01cnX20RzGNLluj-yg.jpeg"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">?</figcaption></figure><p id="2839" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">简单吧？</p><p id="02b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">简化甚至<em class="lk">进一步……</em></strong></p><p id="1f80" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我最喜欢的堆特性是它们可以很容易地以数组的形式工作。因此，与其考虑使用递归爬虫遍历树并以空间方式处理数据结构，我可以同样容易地(或更容易地)只考虑数组。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/41cc2d2126ed22c78b0d6d0ac0e9b5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aiZiBmuRgMAqmC6TCPObFw.jpeg"/></div></div></figure><p id="c820" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">怎么会？嗯…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/8c98cb9e35cf73ac77ef5753d275e5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHcIthimDrnaB3_59zN7ww.jpeg"/></div></div></figure><p id="2557" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">…我们可以将这些值推入一个数组，从根开始，以广度优先的方式移动。</p><p id="bc14" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">并且，对于数组中的每个节点，(如果我们遵循了堆的两个规则)有一个简单的、公式化的方法来定位子节点和父节点。</p><p id="db36" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我现在将单步执行并定位堆中每个节点的子节点。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/cc958c8fb5cfbbaf6ce3957710176578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKwbV0dXfrDWEIUyYFeUfg.jpeg"/></div></div></figure><p id="9c0b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们的父节点在索引0处，它的子节点在索引1和2处。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/abaf11ac54774591e5d0f4ca22606e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WfPh03_Iwfg9ypmmqwlyNg.jpeg"/></div></div></figure><p id="661e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们的父节点位于索引1，它的子节点位于索引3和4。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/4dd5d56ae6d629399c3bd073ce38f5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_fZQo8K_w_lfPMovWYNkg.jpeg"/></div></div></figure><p id="49ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，当父节点为2时，其子节点位于索引5和6处。</p><p id="29e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以现在可以说，当给定堆(数组)中的父节点索引时，我们可以用这些表达式定位它的子节点(其中n是父节点的索引)</p><p id="78ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2n + 1(左子)</strong></p><p id="91ff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2n + 2(右子)</strong></p><p id="2970" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相反，我们可以从子节点中找到父节点</p><p id="0240" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">数学楼层((n - 1) / 2) </strong></p><p id="ce90" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">其中n =任一子节点的索引。</p><p id="070d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">实现</em> </strong></p><p id="baea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我知道了如何存储我的堆并定位父节点和子节点，我准备设置我的MaxBinaryHeap类</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="723b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我让我的构造函数将一个空数组设置为我的堆，并且我还添加了一个实例方法，该方法在被调用时会向堆中添加一个值。</p><p id="1a44" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是为了确保在我添加值时堆不会变得无序，我需要一些在值被添加到堆的末尾后立即发生的行为。通常，我听到最多的名字是“冒泡”。</p><p id="ee62" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下,“冒泡”的意思是，当我们在堆的末尾添加一个值时，(max heap)我们会给它一个机会向上冒泡到它在结构中的正确位置。</p><p id="233f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以之前的例子为例，假设我加了15。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lt"><img src="../Images/def8314e8313b4bdb2d6f3e0fdf1c4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGvDse2i_LFMyMws53QBpQ.jpeg"/></div></div></figure><p id="7dc2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">没有。现在我们违反了我们的一个规则，一个父节点有一个值更大的子节点。因此，让我们设计一个过程，让我们的最新价值找到它的适当位置。</p><p id="7745" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">嗯，我们知道我们可以找到它的父节点，如果我们能做到这一点，我们可以将其与该值进行比较，如果它更大，我们将交换它们。然后，我们将重复这一过程，直到我们新增加的价值不再被交换(它找到了自己的位置)。</p><p id="c29f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是我实现的冒泡方法:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="f257" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先我建立了一个新的索引，然后是一个循环，直到我返回。</p><p id="2597" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在循环中非常简单，我将建立父节点的索引，然后将父节点值与新添加的值进行比较。如果少于新增加的价值，那么我就交换它们。</p><p id="dbfe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，当不再进行交换时，我的新值将“冒泡”到它在堆中的正确位置！</p><p id="ffe6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">T5从堆里提取……</strong></p><p id="9243" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为堆经常被用作优先级队列，所以能够移除最顶端的值也同样重要。</p><p id="53cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们遇到了一个新问题，其基本思想与之前类似——如果我们只是从堆中移除根节点，可能会导致堆的结构不正确。</p><p id="a9b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们需要另一个过程来解决我们在获取最大价值时产生的任何问题。</p><p id="1b0d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">冒泡<em class="lk">下降</em>下降</strong></p><p id="c8e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我感觉有些奇怪或违反直觉时，我会很快承认，这绝对是其中之一。这是一个非常简单的过程，而且非常非常酷——只是不像以前的冒泡方法那么直观。</p><p id="59f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我将遵循以下步骤:</p><ol class=""><li id="f79c" class="lu lv in kq b kr ks ku kv kx lw lb lx lf ly lj lz ma mb mc bi translated">从堆中移除第一个值(我们从队列中取出它)</li><li id="9ec4" class="lu lv in kq b kr md ku me kx mf lb mg lf mh lj lz ma mb mc bi translated">移除堆中的最后一个<em class="lk">值，并将其移动到前面(根)</em></li><li id="5168" class="lu lv in kq b kr md ku me kx mf lb mg lf mh lj lz ma mb mc bi translated">现在找到它的子节点值</li><li id="6594" class="lu lv in kq b kr md ku me kx mf lb mg lf mh lj lz ma mb mc bi translated">确定两者中最大的子节点值</li><li id="df9e" class="lu lv in kq b kr md ku me kx mf lb mg lf mh lj lz ma mb mc bi translated">如果向下冒泡的值小于下面最大的子节点值，我们将交换这两个值</li><li id="d61b" class="lu lv in kq b kr md ku me kx mf lb mg lf mh lj lz ma mb mc bi translated">然后，我们将继续这样做，直到不再进行交换(并且已经找到它在堆中的位置)</li></ol><p id="87e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">既然我们已经概述了这种方法，让我们来直观地看一下</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/c35c28840c62e047a4ad6b6f7efe964c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2U0s3dPgfzp6Gqvbg_KAA.jpeg"/></div></div></figure><p id="98d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我有一个有效的最大堆，我想从中提取最高优先级的值(根)。所以我先把它从数组中移除。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/e3fa8fe21fc80cbed7589b141ebc54fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GaU3_uhENW9Nn_PbSez8Jw.jpeg"/></div></div></figure><p id="5449" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">只是现在，在基于新数组重画了堆之后，很明显我现在违反了我们的规则之一，因为父节点有一个更大值的子节点。</p><p id="07c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我的第一步是从数组中移除最后一个值，并把它放在前面…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/defa074b029049b1c46816b0c131165e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOmC7acLaWk84RzYiPLukw.jpeg"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/b402fd01bd36a93c829e65714182218c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCNXSwk8oDXdjRL1wLnpUw.jpeg"/></div></div></figure><p id="02fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是现在这一堆都是各种各样的错误…</p><p id="fc58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是向下冒泡发挥作用的地方。为此，我们将从新的根值开始，并定位它的子值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/6f9964a2720f34421fca91d9da5b39f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqjJ9GMu5kbxeOPSZh1MpA.jpeg"/></div></div></figure><p id="bdf7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的向下冒泡的节点(2)将向它向下遇到的每一对孩子提出一个问题——</p><p id="33ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“你们俩谁的价值更高？”</p><p id="0e67" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我对这个概念记得最清楚的方式是，在冒泡过程的第一步，这个问题实际上是</p><p id="6226" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“你们谁是新的<em class="lk">根</em>？”</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/3c9f8d5494821ec150e3fa25156ed851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6WA2tVc98_BczWWES-HUxw.jpeg"/></div></div></figure><p id="9dbc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">答案是30，所以我们用30换了2。现在，堆离有效性又近了一步。我们将再重复一次这个过程…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/b216cb9c74501905fa525eb2a3ddb053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D87rNPCyXpT7fdDxVbrqZg.jpeg"/></div></div></figure><p id="f8d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">20是两者中较大的一个，所以现在我们再交换一下</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/60a95dcec1a913336d2e8aa4114e914e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9cwhu3Mi5h8y_KrwSUVsng.jpeg"/></div></div></figure><p id="97d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就是这样！</p><p id="694b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们之前的最后一个值向下冒泡，这样做，重新排序堆。</p><p id="eda2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">都在一起……</strong></p><p id="45d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以对于我们的每一个基本堆方法(push和extractMax)，这个过程都相对简单—</p><p id="088d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">1st:对于push，我只是添加到堆数组的末尾，对于extractMax，我删除第一个值。</p><p id="a9d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二步:然后我将立即调用bubble或bubbleDown方法来重新调整堆的优先级。</p><p id="8cd9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">完整代码</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="754b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">*注意——第55行的目的是确保我没有超出数组索引。绝对有一种更吸引人的编码方式，但是为了覆盖更多的领域，我还是保持原样。</p><p id="26ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是我对二进制堆的介绍。我真的很惊讶地说，这些对我来说就像二分搜索法树一样有趣…这说明了很多！</p><p id="10ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容请看</em><a class="ae mj" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a><em class="lk">。报名参加我们的</em> <a class="ae mj" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。关注我们关于</em><a class="ae mj" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">Twitter</em></strong></a><em class="lk">和</em><a class="ae mj" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">。查看我们的</em> <a class="ae mj" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">社区不和谐</em> </strong> </a> <em class="lk">加入我们的</em> <a class="ae mj" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">人才集体</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>