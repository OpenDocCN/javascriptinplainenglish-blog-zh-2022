<html>
<head>
<title>Which is Better? Class Component Or Functional Component in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哪个更好？React中的类组件还是功能组件？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/which-is-better-class-components-or-functional-component-in-react-a417b4ef6c1a?source=collection_archive---------0-----------------------#2022-01-12">https://javascript.plainenglish.io/which-is-better-class-components-or-functional-component-in-react-a417b4ef6c1a?source=collection_archive---------0-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0b9f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中功能组件和类组件的区别。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1bd96e18349221683e3cb9f13d9aefe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zOJuC2-uMFOt_bmC"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Possessed Photography</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a0fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始我的React项目时，我的第一个问题是使用类组件还是功能组件。另一种选择是在项目中同时使用这两者。我希望每个人都在他们的项目中使用这两种组件。</p><blockquote class="ls lt lu"><p id="d75e" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq"> React允许您将组件定义为类或函数。</em></p></blockquote><p id="79b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在找到更好的选择之前，我们将创建类组件和功能组件。</p><blockquote class="ls lt lu"><p id="0bef" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">创建React组件时，组件名必须以大写字母开头。</p></blockquote><h2 id="95e8" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">类别组件</h2><p id="3097" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">要定义React组件类，您的类需要用<code class="fe mx my mz na b">React.Component</code>扩展。</p><p id="a328" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">必须在类组件中定义<code class="fe mx my mz na b">render()</code>方法。其他<code class="fe mx my mz na b">React.Component</code>方法可选，如<code class="fe mx my mz na b">constructor()</code> <code class="fe mx my mz na b">componentDidMount()</code>等。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="4f14" class="nf ma iq na b be ng nh l ni nj">class Hello extends React.Component {<br/>  render() {<br/>    return &lt;h1&gt;Hello World!&lt;/h1&gt;;<br/>  }<br/>}<br/>  <br/>const element = &lt;Hello /&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="a6a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/eYGrwdw" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="26da" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">功能成分</h2><p id="04d7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这里我们要把上面的类组件变成一个功能组件。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="9a8b" class="nf ma iq na b be ng nh l ni nj">function Hello() {<br/>  return &lt;h1&gt;Hello World!&lt;/h1&gt;;<br/>}<br/>  <br/>const element = &lt;Hello /&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="0db4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">功能组件易于编写，代码更少，更容易理解。因为它只是一个返回JSX的普通JavaScript函数。</p><p id="6780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/BawxgWr" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="8273" class="nr ma iq bd mb ns nt nu me nv nw nx mh jw ny jx mk jz nz ka mn kc oa kd mq ob bi translated">功能组件和类组件的区别</h1><p id="8b19" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们讨论了类组件和功能组件之间的每个区别。</p><ul class=""><li id="82b4" class="oc od iq ky b kz la lc ld lf oe lj of ln og lr oh oi oj ok bi translated">1.组件渲染</li><li id="5f32" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">2.搬运道具</li><li id="d938" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">3.处理状态</li><li id="0cf3" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">4.生命周期方法</li><li id="f090" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">5.访问组件子项</li><li id="c799" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">6.高阶组件</li><li id="e902" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">7.误差边界</li></ul><h2 id="0232" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">1.组件渲染</h2><p id="3b22" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在类组件中，<code class="fe mx my mz na b">render()</code>方法用于通过扩展<code class="fe mx my mz na b"> React.Component</code>来渲染JSX</p><p id="4bef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">功能组件只是一个返回JSX的普通JavaScript函数。</p><p id="a90d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前两个程序是组件呈现的完美例子。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="5605" class="nf ma iq na b be ng nh l ni nj">// Class component<br/>class Hello extends React.Component {<br/>  render() {<br/>    return &lt;h1&gt;Hello World!&lt;/h1&gt;;<br/>  }<br/>}<br/>  <br/>//Function component<br/>function Hello() {<br/>  return &lt;h1&gt;Hello World!&lt;/h1&gt;;<br/>}<br/>  <br/>//Function component with Arrow function<br/>Hello = () =&gt; {<br/>  return &lt;h1&gt;Hello World!&lt;/h1&gt;;<br/>}</span></pre><p id="5e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获胜者:功能组件</strong></p><p id="d419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用<a class="ae kv" href="https://medium.com/swlh/es6-arrow-functions-in-javascript-54f244f6c7cd" rel="noopener">箭头功能</a>，功能组件的创建更加简单。普通的JavaScript函数被用作功能组件。没有更多的渲染方法。</p><div class="oq or gp gr os ot"><a href="https://balajidharma.medium.com/difference-between-es6-arrow-functions-and-regular-functions-in-javascript-4ba4fcb5d352" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">ES6箭头函数和JavaScript中常规函数的区别</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">箭头函数与常规函数</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">balajidharma.medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kp ot"/></div></div></a></div></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="51f2" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">2.搬运道具</h2><p id="2b1d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mx my mz na b">props</code>代表属性，并被传递给React组件。它还用于将数据从一个组件传递到另一个组件。阅读更多官方<a class="ae kv" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>。</p><p id="6a4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">带道具的类组件</strong></p><p id="8d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">this.props</code>用于访问我们的<code class="fe mx my mz na b">name</code>道具。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="758c" class="nf ma iq na b be ng nh l ni nj">class Hello extends React.Component {<br/>  render() {<br/>    return &lt;h1&gt;Hello {this.props.name}!&lt;/h1&gt;;<br/>  }<br/>}<br/>  <br/>const element = &lt;Hello name="World"/&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="ef7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/poWZGJb" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="3713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">带道具的功能组件</strong></p><p id="ca10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有效的React函数组件应该有一个函数参数。<code class="fe mx my mz na b">props</code>参数将拥有像<code class="fe mx my mz na b">props.name</code>一样的所有组件道具。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="9582" class="nf ma iq na b be ng nh l ni nj">function Hello(props) {<br/>  return &lt;h1&gt;Hello {props.name}!&lt;/h1&gt;;<br/>}<br/>   <br/>const element = &lt;Hello name="World" /&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="1e99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/poWZjYB" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="15f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获胜者:功能组件</strong></p><p id="e657" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用担心<code class="fe mx my mz na b">this</code>关键字。语法简洁明了，它是赢家。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="3158" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">3.处理状态</h2><p id="c345" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mx my mz na b">state</code>是React组件的内置对象，用于控制组件行为。当<code class="fe mx my mz na b">state</code>对象改变时，组件将被重新渲染。</p><p id="2d7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">状态为</strong>的类组件</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="4aea" class="nf ma iq na b be ng nh l ni nj">class Timenow extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {date: new Date()};<br/>  }<br/>  <br/>  render() {<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Hello {this.props.name}!&lt;/h1&gt;<br/>        &lt;h2&gt;Time Now {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/>  <br/>const element = &lt;Timenow name="World"/&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="2810" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/QWqBoXZ" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="36d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">class components <code class="fe mx my mz na b">constructor</code>方法用于初始化状态值。</p><p id="8461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">状态为</strong>的功能组件</p><p id="33ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在功能组件中，使用<a class="ae kv" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> useState </a>钩子处理状态。</p><blockquote class="ls lt lu"><p id="d00e" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">钩子</em>是React 16.8新增的。它们允许您使用状态和其他React特性，而无需编写类。</p></blockquote><p id="a8f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">功能组件没有<code class="fe mx my mz na b">this</code>，所以我们不能赋值或读取<code class="fe mx my mz na b">this.state</code>。相反，我们在函数组件内部直接调用<code class="fe mx my mz na b">useState</code>钩子。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="c6c9" class="nf ma iq na b be ng nh l ni nj">function Timenow(props) {<br/>  const [date, setDate] = React.useState(new Date());<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Hello {props.name}!&lt;/h1&gt;<br/>      &lt;h2&gt;Time Now {date.toLocaleTimeString()}.&lt;/h2&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>  <br/>const element = &lt;Timenow name="World" /&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="711f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/WNZKWNa" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="9198" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获胜者:功能组件</strong></p><p id="bed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mx my mz na b">useState</code>挂钩完成<code class="fe mx my mz na b">state</code>初始化。不需要<code class="fe mx my mz na b">constructor</code>方法。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="e371" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">4.生命周期方法</h2><p id="16f4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在React中，每个组件都有几个<code class="fe mx my mz na b">lifecycle</code>方法，这个方法帮助你在进程中的特定时间运行代码。<a class="ae kv" href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" rel="noopener ugc nofollow" target="_blank">点击此处</a>查看React生命周期图。</p><p id="c39c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">具有生命周期方法的类组件</strong></p><p id="2ba2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">低于时钟类组件是实现生命周期方法的完美例子。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="4c7c" class="nf ma iq na b be ng nh l ni nj">class Clock extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {date: new Date()};<br/>  }<br/>  <br/>  componentDidMount() {<br/>    this.timerID = setInterval(<br/>      () =&gt; this.tick(),<br/>      1000<br/>    );<br/>  }<br/>  <br/>  componentWillUnmount() {<br/>    clearInterval(this.timerID);<br/>  }<br/>  <br/>  tick() {<br/>    this.setState({<br/>      date: new Date()<br/>    });<br/>  }<br/>  <br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Hello, world!&lt;/h1&gt;<br/>        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/>  <br/>ReactDOM.render(<br/>  &lt;Clock /&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="3c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/gaearon/pen/amqdNA" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="4562" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">具有生命周期挂钩方法的功能组件</strong></p><p id="d8e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe mx my mz na b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>钩子将上面的<code class="fe mx my mz na b">clock</code>类组件转换成一个功能组件。</p><p id="c4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">useEffect</code>返回方法用于清理。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="d498" class="nf ma iq na b be ng nh l ni nj">function Clock(props) {<br/>  const [date, setDate] = React.useState(new Date());<br/>  <br/>  React.useEffect(() =&gt; {<br/>    var timerID = setInterval(() =&gt; tick(), 1000);<br/>    <br/>    return function cleanup() {<br/>      clearInterval(timerID);<br/>    };<br/>  });<br/>    <br/>  function tick() {<br/>    setDate(new Date());<br/>  }<br/>  <br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Hello, world!&lt;/h1&gt;<br/>      &lt;h2&gt;It is {date.toLocaleTimeString()}.&lt;/h2&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>  <br/>ReactDOM.render(<br/>  &lt;Clock /&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="1868" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在CodePen上试试</p><p id="9204" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获胜者:类别组件</strong></p><p id="9abe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于对所有生命周期方法使用相同的钩子，功能组件<code class="fe mx my mz na b">useEffect</code>令人困惑。在类组件中，我们可以直接使用<code class="fe mx my mz na b">componentDidMount</code>、<code class="fe mx my mz na b">componentWillUnmount</code>等方法。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="851b" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">5.访问组件子项</h2><p id="7829" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">特殊的<code class="fe mx my mz na b">children</code>道具用于访问内容内部的组件或类似&lt;布局&gt;内容内部的组件&lt;/布局&gt;。</p><p id="fd36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">类组件</strong></p><p id="19ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">this.props.children</code>用于类组件。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="7327" class="nf ma iq na b be ng nh l ni nj">class Layout extends React.Component {<br/>  render() {<br/>   return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Hello {this.props.name}!&lt;/h1&gt;<br/>        &lt;div&gt;{this.props.children}&lt;/div&gt;<br/>      &lt;/div&gt;<br/>     );<br/>  }<br/>}<br/>  <br/>const element = &lt;Layout name="World"&gt;This is layout content&lt;/Layout&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="7368" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/XWexdmj" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="6b34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">功能组件</strong></p><p id="5ca0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只是在功能组件中使用了<code class="fe mx my mz na b">props.children</code>来访问孩子的内容。</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="46dd" class="nf ma iq na b be ng nh l ni nj">function Layout(props) {<br/>  return(<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Hello {props.name}!&lt;/h1&gt;<br/>      &lt;div&gt;{props.children}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>  <br/>const element = &lt;Layout name="World"&gt;This is layout content&lt;/Layout&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="c80d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/BawqKBv" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="48b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获胜者:类别&amp;功能组件</strong></p><p id="dda8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两者都使用相同的<code class="fe mx my mz na b">props.children</code>来访问组件的子组件。另外，我们需要使用<code class="fe mx my mz na b">this</code>关键字。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="d2d6" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">6.高阶组件</h2><p id="39e4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">高阶组件(HOC)是React中重用组件逻辑的一种高级技术。HOC是一个纯函数，所以它只返回一个新的组件。</p><blockquote class="ls lt lu"><p id="ecfc" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">高阶分量是接受一个分量并返回一个新分量的函数。</p></blockquote><p id="d33d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">具有类组件的特设</strong></p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="fe72" class="nf ma iq na b be ng nh l ni nj">function classHOC(WrappedComponent) {<br/>  return class extends React.Component{<br/>    render() {<br/>      return &lt;WrappedComponent {...this.props}/&gt;;<br/>    }<br/>  }<br/>}<br/>  <br/>const Hello = ({ name }) =&gt; &lt;h1&gt;Hello {name}!&lt;/h1&gt;;<br/>const NewComponent = classHOC(Hello);<br/>  <br/>const element = &lt;NewComponent name="World" /&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="e6e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/NWaOrNb" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="e17d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">带功能组件的特设</strong></p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="6a1d" class="nf ma iq na b be ng nh l ni nj">function functionalHOC(WrappedComponent) {<br/>  return (props) =&gt; {<br/>    return &lt;WrappedComponent {...props}/&gt;;<br/>  }<br/>}<br/>  <br/>const Hello = ({ name }) =&gt; &lt;h1&gt;Hello {name}!&lt;/h1&gt;;<br/>const NewComponent = functionalHOC(Hello);<br/>  <br/>const element = &lt;NewComponent name="World" /&gt;;<br/>ReactDOM.render(<br/>  element,<br/>  document.getElementById('root')<br/>);</span></pre><p id="3734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/dyVgXKy" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="c1d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获胜者:功能组件</strong></p><p id="a16f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建HOC，我们应该使用JavaScript函数(classHOC，functionalHOC)。<a class="ae kv" href="https://reactjs.org/docs/higher-order-components.html#dont-use-hocs-inside-the-render-method" rel="noopener ugc nofollow" target="_blank">不要在渲染方法</a>中使用HOCs。在函数内部，我们可以使用类或功能组件。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="e8ae" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">7.误差边界</h2><p id="51db" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><a class="ae kv" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">错误边界</a>是React组件，用于处理React组件中的JavaScript错误。因此，我们可以捕捉组件中的JavaScript运行时错误，并显示一个后备UI。</p><blockquote class="ls lt lu"><p id="e5f9" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">错误边界是React组件，<strong class="ky ir">捕捉子组件树中任何地方的JavaScript错误，记录这些错误，并显示一个回退UI </strong>而不是崩溃的组件树。</p></blockquote><p id="484c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用了<code class="fe mx my mz na b"><a class="ae kv" href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromerror" rel="noopener ugc nofollow" target="_blank">static getDerivedStateFromError()</a></code>或<code class="fe mx my mz na b"><a class="ae kv" href="https://reactjs.org/docs/react-component.html#componentdidcatch" rel="noopener ugc nofollow" target="_blank">componentDidCatch()</a></code>生命周期方法，就意味着类组件变成了一个错误边界。使用<code class="fe mx my mz na b">static getDerivedStateFromError()</code>在抛出错误后呈现一个回退用户界面。使用<code class="fe mx my mz na b">componentDidCatch()</code>记录错误信息。</p><p id="35ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错误边界作为一个JavaScript <code class="fe mx my mz na b">catch {}</code>块工作，但是对于组件。</p><p id="36c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有误差边界的简单例子</p><pre class="kg kh ki kj gt nb na nc bn nd ne bi"><span id="5fff" class="nf ma iq na b be ng nh l ni nj">class ErrorCounter extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {error: null, errorInfo: null};<br/>  }<br/>  <br/>  componentDidCatch(error, errorInfo) {<br/>    // Catch errors in any components below and re-render with error message<br/>    this.setState({<br/>      error: error,<br/>      errorInfo: errorInfo<br/>    })<br/>    // You can also log error messages to an error reporting service here<br/>  }<br/>  <br/>  refreshPage() {<br/>    history.go(-1)<br/>  }<br/>  <br/>  render() {<br/>    if (this.state.errorInfo) {<br/>      // Error path<br/>      return (<br/>        &lt;div&gt;<br/>          &lt;h2&gt;Something went wrong.&lt;/h2&gt;<br/>          &lt;details style={{ whiteSpace: 'pre-wrap' }}&gt;<br/>            {this.state.error &amp;&amp; this.state.error.toString()}<br/>            &lt;br /&gt;<br/>            {this.state.errorInfo.componentStack}<br/>          &lt;/details&gt;<br/>          &lt;hr /&gt;<br/>          &lt;button onClick={this.refreshPage}&gt;<br/>            Refresh Page<br/>          &lt;/button&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }<br/>    // Normally, just render children<br/>    return this.props.children;<br/>  }<br/>};<br/>class Counter extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { counter: 0 };<br/>    this.handleClick = this.handleClick.bind(this);<br/>  }<br/>  <br/>  handleClick() {<br/>    this.setState(({counter}) =&gt; ({<br/>      counter: counter + 1<br/>    }));<br/>  }<br/>  <br/>  render() {<br/>    if (this.state.counter === 3) {<br/>      // Simulate a JS error<br/>      throw new Error('I crashed!');<br/>    }<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;{this.state.counter}&lt;/h1&gt;<br/>        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/>  <br/>ReactDOM.render(<br/>  &lt;ErrorCounter&gt;<br/>    &lt;Counter /&gt;<br/>  &lt;/ErrorCounter&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="761a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://codepen.io/balajidharma/pen/eYGQxJY" rel="noopener ugc nofollow" target="_blank">在CodePen上试试</a></p><p id="4e36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获胜者:类组件</strong></p><p id="044a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，只有类组件可以是错误边界。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="0015" class="nr ma iq bd mb ns nt nu me nv nw nx mh jw ny jx mk jz nz ka mn kc oa kd mq ob bi translated">结论:哪个更好？</h1><p id="40aa" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如今，大多数应用程序都使用功能组件，因为它们简单、易用、易于理解。还有，在React <a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> v16.8 </a>中引入钩子之后，功能组件变得非常有名。</p><p id="70c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于钩子，功能组件中的生命周期方法易于使用。</p><p id="6711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于没有介绍类的ES6 JavaScript背景的新手来说，类组件很难理解。</p><p id="3df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与Java、PHP和C#等其他编程语言不同，JavaScript类是原型继承之上的语法糖。换句话说，ES6类只是特殊函数。所以我们不能在JavaScript类中使用类特性。</p><p id="cd71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类组件在错误处理中起着重要的作用。因为类组件只支持错误边界生命周期方法<code class="fe mx my mz na b"><a class="ae kv" href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromerror" rel="noopener ugc nofollow" target="_blank">static getDerivedStateFromError()</a></code>或<code class="fe mx my mz na b"><a class="ae kv" href="https://reactjs.org/docs/react-component.html#componentdidcatch" rel="noopener ugc nofollow" target="_blank">componentDidCatch()</a></code>。</p><p id="be57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有更好的了，因为两者都有利弊。但是类组件对于理解React流和生命周期方法很重要。</p><p id="a897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新学员应该使用课程组件练习React。一旦他们熟悉了类组件，他们就可以学习和使用功能组件。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="263c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！请随意评论您的反馈，并分享类组件和功能组件之间缺失的差异。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="0fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献</strong></p><pre class="kg kh ki kj gt nb na pi pj aw pk bi"><span id="c722" class="lz ma iq na b gy pl pm l pn nj"><a class="ae kv" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-component.html</a></span><span id="f3b1" class="lz ma iq na b gy po pm l pn nj"><a class="ae kv" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/components-and-props.html</a></span><span id="6773" class="lz ma iq na b gy po pm l pn nj"><a class="ae kv" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/state-and-lifecycle.html</a></span><span id="27ce" class="lz ma iq na b gy po pm l pn nj"><a class="ae kv" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/higher-order-components.html</a></span><span id="b54f" class="lz ma iq na b gy po pm l pn nj"><a class="ae kv" href="https://www.twilio.com/blog/react-choose-functional-components" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/blog/react-choose-functional-components</a></span><span id="116b" class="lz ma iq na b gy po pm l pn nj"><a class="ae kv" href="https://blog.logrocket.com/handling-javascript-errors-react-error-boundaries/" rel="noopener ugc nofollow" target="_blank">https://blog.logrocket.com/handling-javascript-errors-react-error-boundaries/</a></span></pre></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="a212" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">进一步阅读</h2><div class="oq or gp gr os ot"><a href="https://bit.cloud/blog/composable-link-component-that-works-in-any-react-meta-framework-l7i3qgmw" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">可在任何React元框架中工作的可组合链接组件</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">Bit的链接组件是一个与运行环境无关的组件。您可以将此链接用于…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">比特云</p></div></div><div class="pc l"><div class="pp l pe pf pg pc ph kp ot"/></div></div></a></div></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="e520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lv">说白了就是</em> </strong> </a> <em class="lv">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lv">免费周报</em> </strong> </a> <em class="lv">。关注我们关于</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lv">推特</em> </strong> </a>，<a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lv">领英</em> </strong> </a> <em class="lv">，</em><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="lv">YouTube</em></strong></a><em class="lv">，以及</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lv">不和</em> </strong> </a> <em class="lv">。对增长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lv">电路</em> </strong> </a> <em class="lv">。</em></p></div></div>    
</body>
</html>