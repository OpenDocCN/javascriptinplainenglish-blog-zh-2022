<html>
<head>
<title>Understand Scoping and Hoisting in JavaScript with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过示例理解JavaScript中的作用域和提升</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-scoping-and-hoisting-in-javascript-with-examples-c51e5612d52e?source=collection_archive---------13-----------------------#2022-01-18">https://javascript.plainenglish.io/understanding-scoping-and-hoisting-in-javascript-with-examples-c51e5612d52e?source=collection_archive---------13-----------------------#2022-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7c5d71f7d9c811ac4b685e26424d3b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tjdmu-HLub5mvJ_O"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pankaj Patel</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fea4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript很奇怪吧？很多时候，开发人员在他们的代码中看到一个意想不到的行为，他们就想大发雷霆。在这篇文章中，我将介绍两个概念，这两个概念将帮助您理解那些奇怪的行为。</p><h1 id="c0eb" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">什么是范围？</strong></h1><p id="21a6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">JavaScript中的作用域指的是运行时变量、函数和对象的可访问性。</p><p id="b9aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JavaScript中，有三种类型的范围:</p><ul class=""><li id="fd33" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">全球范围</li><li id="2a99" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">功能范围</li><li id="ab01" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">块范围</li></ul><h2 id="7257" class="mp kz in bd la mq mr dn le ms mt dp li kl mu mv lm kp mw mx lq kt my mz lu na bi translated"><strong class="ak">全局范围:</strong></h2><p id="5329" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">全局作用域是最外层的作用域，如果变量是在块外声明的，那么它就是全局作用域。</p><p id="3576" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">window</code>和<code class="fe nb nc nd ne b">document</code>是浏览器提供的全局变量。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/9580088b55cfb6e9f95ebb573a01c4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIazgVNQEoF1B5ktDbt-HA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Variable in Global Scope</figcaption></figure><p id="85ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">全局范围内的变量可以在任何其他范围内被访问和修改。</p><h2 id="18ef" class="mp kz in bd la mq mr dn le ms mt dp li kl mu mv lm kp mw mx lq kt my mz lu na bi translated"><strong class="ak">功能范围:</strong></h2><p id="f224" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在函数内部声明的任何变量或函数都有局部/函数范围，这意味着它们只能在函数内部访问，而不能在函数外部访问。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/3e21ab38f91a5f7eb8391ad35274decf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAeJ2EyQShpiXbkgSlxg7g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Variable/Functions in a local scope</figcaption></figure><h2 id="e446" class="mp kz in bd la mq mr dn le ms mt dp li kl mu mv lm kp mw mx lq kt my mz lu na bi translated"><strong class="ak">封锁范围:</strong></h2><p id="b20a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">块作用域告诉我们，在块<strong class="kc io"> {} </strong>内声明的任何变量，只能在块内访问，不能在块外访问。<br/>块范围只与使用<code class="fe nb nc nd ne b">let</code>和<code class="fe nb nc nd ne b">const</code>声明的变量有关，<code class="fe nb nc nd ne b">var</code>没有块范围。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/5f9eead494955fde7e06579394a967b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6eozH-8UXY-t9NXZd8uog.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Variables in Block scope</figcaption></figure><p id="32c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像<code class="fe nb nc nd ne b">if</code>和<code class="fe nb nc nd ne b">switch</code>条件或者<code class="fe nb nc nd ne b">for</code>和<code class="fe nb nc nd ne b">while</code>循环这样的块语句创建了一个块级作用域。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><h1 id="1a8e" class="ky kz in bd la lb nt ld le lf nu lh li lj nv ll lm ln nw lp lq lr nx lt lu lv bi translated">吊装:</h1><p id="7a62" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">当执行JavaScript代码时，JavaScript引擎经历两个阶段:</p><ul class=""><li id="c557" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated"><strong class="kc io">解析</strong> :-如果变量是全局的，JS引擎将所有变量声明移动到页面顶部，否则如果在函数中声明，则移动到函数顶部。</li><li id="4164" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc io">执行</strong> :- JS引擎给变量赋值并执行。</li></ul><p id="b0c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，提升是一种机制，JavaScript引擎在执行代码之前，将所有变量、函数<code class="fe nb nc nd ne b">declaration</code>移动到它们作用域的顶部。它允许在声明函数和变量之前在代码中使用它们。</p><p id="5c9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看下面的代码，猜猜当我们执行他的代码时会发生什么</p><pre class="ng nh ni nj gt ny ne nz oa aw ob bi"><span id="417e" class="mp kz in ne b gy oc od l oe of">console.log(data);<br/>var data = 'hoist';</span></pre><p id="5f04" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">来自任何编程语言的每个开发人员都会期望输出是:<code class="fe nb nc nd ne b">ReferenceError: data is not defined,</code>，但实际上，它会打印出<code class="fe nb nc nd ne b">undefined.</code></p><p id="6c0d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么会发生这种情况？</p><p id="0172" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再看一遍关于<strong class="kc io">提升</strong>的定义，JavaScript将变量声明提升到了作用域的顶部，这就是代码在解释器看来的样子。</p><pre class="ng nh ni nj gt ny ne nz oa aw ob bi"><span id="9a8b" class="mp kz in ne b gy oc od l oe of">var data;</span><span id="daea" class="mp kz in ne b gy og od l oe of">console.log(data); // logs undefined<br/>data = 'hoist';</span></pre><p id="c05e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为提升，我们可以在声明变量或函数之前使用它们。只要记住被提升的变量是用值<code class="fe nb nc nd ne b">undefined</code>初始化的。</p><p id="dc4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们更深入地了解一下<code class="fe nb nc nd ne b">variable</code>和<code class="fe nb nc nd ne b">functional</code>的吊装，以理解这是如何以及意味着什么。</p><h1 id="6b34" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">可变提升</h1><p id="b2d9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在JavaScript中，有三种不同的方法来声明变量— <code class="fe nb nc nd ne b"> var</code>、<code class="fe nb nc nd ne b">let</code>和<code class="fe nb nc nd ne b">const</code>。有两个步骤:变量<strong class="kc io">声明</strong>和<strong class="kc io">初始化。</strong> <br/> JavaScript解释器只把声明移到代码的顶端而不初始化。</p><p id="2555" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">变量提升根据变量的声明方式而有所不同。我们先来了解一下<code class="fe nb nc nd ne b">var</code>吊装。</p><h2 id="55ee" class="mp kz in bd la mq mr dn le ms mt dp li kl mu mv lm kp mw mx lq kt my mz lu na bi translated"><span class="l oh oi oj bm ok ol om on oo di"> V </span> ar吊装</h2><p id="0b27" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">当JS解释器提升一个用<code class="fe nb nc nd ne b">var</code>声明的变量时，它将其值初始化为<code class="fe nb nc nd ne b">undefined</code>。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/4946b842a1b7b050662b269dfd79a268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opGIbjc5d43HGmE5A_5_lQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example from <a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting#var_hoisting" rel="noopener ugc nofollow" target="_blank">MDN</a></figcaption></figure><p id="1581" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们忘记了声明，只初始化了值，变量就不会被提升。试图在变量被初始化和未被提升之前读取它将抛出一个<code class="fe nb nc nd ne b">ReferenceError</code>异常。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oq"><img src="../Images/6896f340f7c46d24f0ce617539d0e25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4OZClP5xpcGCYaf0PmHcCQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example from <a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting#var_hoisting" rel="noopener ugc nofollow" target="_blank">MDN</a></figcaption></figure><p id="000b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，初始化也会导致声明(如果尚未声明)。下面的代码将会工作，因为即使它没有被提升，一个变量在被使用之前会被初始化和有效地声明。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi or"><img src="../Images/1555d4624d1c20c7b81283638caa3e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thenFFfDEH9Mhl773ubHbA.png"/></div></div></figure><p id="3ab5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，你们可能都在想，JavaScript允许我们在声明变量之前访问它们，这有点奇怪。这在JS中是不常见的，会让我们更加困惑，导致错误。<br/>这也是ECMAScript 2015中引入<code class="fe nb nc nd ne b">let</code>和<code class="fe nb nc nd ne b">const </code>的原因。</p><h2 id="a78f" class="mp kz in bd la mq mr dn le ms mt dp li kl mu mv lm kp mw mx lq kt my mz lu na bi translated">出租和固定起重</h2><p id="4791" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">与<code class="fe nb nc nd ne b">var</code>不同，用<code class="fe nb nc nd ne b">let</code>和<code class="fe nb nc nd ne b">const</code>声明的变量被提升，但没有用默认值初始化。试图在声明变量之前读取它会抛出一个异常<code class="fe nb nc nd ne b">ReferenceError</code>。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi os"><img src="../Images/f1e6d86d15c3beec647d38fc6bf178d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gN72p2nXXiejFwRAlwUGZA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Same behavior for a variable declared with const</figcaption></figure><p id="472c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，解释器仍然会提升变量' data ':错误消息表明该变量在某处被初始化。</p><p id="5e63" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们在上面看到的，变量被提升到了它们作用域的顶部。接下来，让我们看看函数作用域的变量是如何提升的。</p><h2 id="eec4" class="mp kz in bd la mq mr dn le ms mt dp li kl mu mv lm kp mw mx lq kt my mz lu na bi translated">功能提升</h2><p id="a956" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">函数提升允许我们在定义函数之前调用它。让我们举个例子，试着猜测输出</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ot"><img src="../Images/c710042dba12ab74a59f6ead3ac2f064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7iYBYb-vfjPj7egrWni4A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Functional hoisting</figcaption></figure><p id="fbe4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下代码成功运行并输出:“我的猫的名字是老虎”。为什么？<br/>因为函数声明被吊起来了。</p><pre class="ng nh ni nj gt ny ne nz oa aw ob bi"><span id="2609" class="mp kz in ne b gy oc od l oe of">Note: Only function declarations are hoisted, not function expression</span></pre><p id="8b34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是有意义的，因为变量赋值没有被提升。如果我们试图调用函数表达式被赋给的变量，我们将得到一个<code class="fe nb nc nd ne b">TypeError</code>或<code class="fe nb nc nd ne b">ReferenceError</code>，这取决于变量的范围。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi os"><img src="../Images/fb15b7278d5a366cf27812346088ac6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5wvYd41s-a7Tb6UptEp2A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Function expressions aren’t hoisted</figcaption></figure><h1 id="0d7c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论:</h1><p id="b4c0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们总结一下这篇文章</p><ul class=""><li id="3d39" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">let和const是<strong class="kc io">块</strong>范围，而var是<strong class="kc io">全局</strong>范围</li><li id="4f85" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">var、let和const都被提升，但与var不同，其他两个没有用默认值初始化(<strong class="kc io">未定义</strong>)。</li><li id="4c90" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">函数声明被提升，但函数表达式不被提升</li></ul><p id="3e02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该养成使用<code class="fe nb nc nd ne b">let</code>和<code class="fe nb nc nd ne b">const</code>而不是<code class="fe nb nc nd ne b">var</code>的习惯，以避免不必要的错误。</p><blockquote class="ou ov ow"><p id="babb" class="ka kb ox kc b kd ke kf kg kh ki kj kk oy km kn ko oz kq kr ks pa ku kv kw kx ig bi translated">感谢您的阅读，我希望您了解JavaScript中的作用域和提升。请在评论区分享你的观点，欢迎反馈。<br/>查看我的其他关于<a class="ae jz" href="https://medium.com/@aayushtibra1997?p=f05dfe46dfc5" rel="noopener"> <strong class="kc io">如何高效加载脚本的文章</strong> </a> <strong class="kc io">。<br/></strong><strong class="kc io"/><a class="ae jz" href="https://medium.com/@aayushtibra1997/difference-between-map-and-foreach-bcaf8cdd5404" rel="noopener"><strong class="kc io">地图与forEach </strong> </a> <strong class="kc io">的区别。</strong></p></blockquote><p id="1a3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ox">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ox">plain English . io</em></strong></a><em class="ox">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ox">免费每周简讯</em> </strong> </a> <em class="ox">。在我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ox">社区</em> </strong> </a> <em class="ox">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>