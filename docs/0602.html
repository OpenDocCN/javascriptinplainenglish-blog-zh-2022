<html>
<head>
<title>React — Universal Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React —通用容器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-universal-container-acfc138ccfef?source=collection_archive---------7-----------------------#2022-02-02">https://javascript.plainenglish.io/react-universal-container-acfc138ccfef?source=collection_archive---------7-----------------------#2022-02-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b5e3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">创建一个可重用的容器来加载多个表示组件的数据</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6040d52d732979182aafc7e5543599c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m9Hho9QxRNyolInw"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e52d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你用React编码，你一定听说过容器组件，并以某种形式使用过它们。简而言之，容器组件:</p><ul class=""><li id="6dc4" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">都是关于功能性的。</li><li id="c50c" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">向它们的孩子提供数据和行为——通常是表示性组件——因此，通常是有状态的。</li><li id="468c" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">除了包装<code class="fe md me mf mg b">&lt;div&gt;</code>或反应片段<code class="fe md me mf mg b">&lt;&gt;</code>之外，很少有自己的标记。</li></ul><p id="b1f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正确使用时，容器组件实现了<a class="ae ks" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a> (SoC)设计模式。它们从组件中抽象出数据处理逻辑，从而将功能与外观分开。</p><p id="2b7a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然容器组件的常见用法——将数据传递给表示组件——对于大多数场景来说已经足够了，但我很高兴了解到如何创建一个可重用的容器来为多个表示组件加载数据。结果是减少了代码并简化了可维护性。</p><p id="4575" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们开始吧！</p><h1 id="355c" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">先决条件</h1><p id="c34e" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">请注意这篇文章:</p><ul class=""><li id="051e" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">要求中级精通React概念，特别是状态、钩子和子对象。如果你是初学者，这篇文章仍然是有价值的，但不解释上述主题。</li><li id="5650" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">不包括容器和表示组件，它们是什么，以及何时使用它们。同样参考<a class="ae ks" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">这篇</a>文章。</li><li id="0453" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">特性<a class="ae ks" href="https://docs.github.com/en/rest/reference/users" rel="noopener ugc nofollow" target="_blank"> GitHub的用户API </a>和gists中的<a class="ae ks" href="https://zoo-animal-api.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">动物园动物Api </a>。</li></ul></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="25b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们通过查看容器组件的常见用例来获得一些上下文。然后，我们将重构容器组件，直到我们达到期望的结果。</p><h1 id="c7b9" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">普通集装箱</h1><p id="9336" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">假设我们需要在应用程序中显示特定用户的详细信息，容器组件获取用户数据并将其传递给呈现该数据的组件。因此，我们需要创建以下内容:</p><ol class=""><li id="b59f" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo nl lv lw lx bi translated">表象成分:<code class="fe md me mf mg b">User</code></li><li id="051d" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo nl lv lw lx bi translated">集装箱组件:<code class="fe md me mf mg b">UserContainer</code></li></ol><h2 id="f18e" class="nm mi in bd mj nn no dn mn np nq dp mr lc nr ns mt lg nt nu mv lk nv nw mx nx bi translated">表象成分</h2><p id="8d17" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">首先，我们有表示组件<code class="fe md me mf mg b">User</code>，它呈现传递给它的细节。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">User.js</figcaption></figure><h2 id="217b" class="nm mi in bd mj nn no dn mn np nq dp mr lc nr ns mt lg nt nu mv lk nv nw mx nx bi translated">容器组件</h2><p id="b6e4" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">然后，我们创建容器组件<code class="fe md me mf mg b">UserContainer</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">UserContainer.js</figcaption></figure><p id="476c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，将以上所有内容放在一起的<code class="fe md me mf mg b">App.js</code>文件看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App.js</figcaption></figure><p id="68ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是容器组件模式的完美版本。然而，想象一下，我们也需要我们的应用程序来显示用户宠物的详细信息。我们如何着手做这件事？</p><p id="2004" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">基于上述实现，我们需要创建两个组件:</p><ol class=""><li id="d793" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo nl lv lw lx bi translated">表象成分:<code class="fe md me mf mg b">Pet</code></li><li id="8251" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo nl lv lw lx bi translated">容器组件:<code class="fe md me mf mg b">PetContainer</code></li></ol><p id="6c15" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，每个基于数据获取功能的新模块都需要两个组件。不用说，维护一段时间后就变得繁琐了。我们可以通过重构容器组件来获取数据并将所述数据传递给任何组件，从而缓解这个问题。在我们这样做之前，让我们修改<code class="fe md me mf mg b">UserContainer</code>使其更加动态。</p><h1 id="537c" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">改进的容器</h1><p id="269a" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">重构后的容器组件如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">UserContainer.js</figcaption></figure><p id="a30a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以看到，除了<code class="fe md me mf mg b">return</code>块(奇迹发生的地方)，我们的容器组件保持不变。在讨论重构带来了什么变化以及在<code class="fe md me mf mg b">return</code>块中发生了什么之前，我们先来看看存放改进后的容器的<code class="fe md me mf mg b">App.js</code>文件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App.js</figcaption></figure><p id="8509" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe md me mf mg b">App.js</code>中，我们将<code class="fe md me mf mg b">User</code>包装在<code class="fe md me mf mg b">UserContainer</code>中，而不是像以前那样只调用<code class="fe md me mf mg b">UserContainer</code>。为了理解为什么，让我们回到容器的<code class="fe md me mf mg b">return</code>块，并遍历它的步骤:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">UserContainer.js</figcaption></figure><ol class=""><li id="e5b2" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo nl lv lw lx bi translated"><code class="fe md me mf mg b"><a class="ae ks" href="https://reactjs.org/docs/react-api.html#reactchildrenmap" rel="noopener ugc nofollow" target="_blank">React.Children.map</a></code>对包含在<code class="fe md me mf mg b">props.children</code>中的每个直接子节点调用一个函数。</li><li id="54d4" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo nl lv lw lx bi translated"><code class="fe md me mf mg b"><a class="ae ks" href="https://reactjs.org/docs/react-api.html#isvalidelement" rel="noopener ugc nofollow" target="_blank">React.isValidElement</a></code>是一个布尔函数，用于验证对象是否为React元素。</li><li id="880f" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo nl lv lw lx bi translated"><code class="fe md me mf mg b"><a class="ae ks" href="https://reactjs.org/docs/react-api.html#cloneelement" rel="noopener ugc nofollow" target="_blank">React.cloneElement</a></code>克隆有效的React元素并返回新的元素。结果元素将原始元素的道具与新的道具进行了浅层合并。</li></ol><p id="f5d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将上述内容应用到我们的代码中:</p><ol class=""><li id="c2bd" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo nl lv lw lx bi translated"><code class="fe md me mf mg b">UserContainer</code>克隆<code class="fe md me mf mg b">User</code>组件并返回一个新的<code class="fe md me mf mg b">User</code>组件。</li><li id="92af" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo nl lv lw lx bi translated">新的<code class="fe md me mf mg b">User</code>组件包含与其现有道具浅合并的道具<code class="fe md me mf mg b">user</code>(在这种情况下没有现有道具)。</li></ol><p id="8efa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，在运行时，<code class="fe md me mf mg b">UserContainer</code>中的<code class="fe md me mf mg b">return</code>块产生:</p><pre class="kd ke kf kg gt oa mg ob oc aw od bi"><span id="6fb3" class="nm mi in mg b gy oe of l og oh">return &lt;User user={user} /&gt;</span></pre><p id="d3e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">总而言之，我们重构的容器将数据传递给表示组件，而不需要导入所述组件。</p><p id="530f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太好了！我们离最终解决方案又近了一步。</p><h1 id="27cf" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">通用集装箱</h1><p id="7fa7" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">为了使我们的容器可以被多个表示组件重用，我们需要:</p><ul class=""><li id="3e8a" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">将数据提取URL和属性名从容器中分离出来。我们可以通过将道具名称(<code class="fe md me mf mg b">resourceName</code>)和数据获取URL ( <code class="fe md me mf mg b">resourceUrl</code>)作为道具传递给容器来实现。</li><li id="4a9b" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">修改状态变量名称，使其通用。我要用<code class="fe md me mf mg b">data</code>，但是你可以用任何你认为合适的名字。</li><li id="0b0a" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">动态设置道具名称如下:<br/> <code class="fe md me mf mg b">{ [resourceName]: data }</code></li></ul><p id="9881" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为我们的容器的主要目的是获取数据，我们可以将其重命名为<code class="fe md me mf mg b">FetchData</code>。完成上述更改后，我们的通用容器将如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4a7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，<code class="fe md me mf mg b">App.js</code>文件看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App.js</figcaption></figure><p id="4223" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如上所述，我们可以将容器<code class="fe md me mf mg b">FetchData</code>用于多个表示组件(在本例中是<code class="fe md me mf mg b">User</code>和<code class="fe md me mf mg b">Pet</code>)。</p><p id="c301" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你有它！现在，您知道了如何为共享数据处理逻辑的组件最大化容器组件模式的功效。但是和所有的编码范例一样，根据需求和时间表来权衡你的选择，选出最好的一个。感谢阅读！</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="5033" class="mh mi in bd mj mk oi mm mn mo oj mq mr jt ok ju mt jw ol jx mv jz om ka mx my bi translated">来源</h1><ul class=""><li id="f564" class="lp lq in kv b kw mz kz na lc on lg oo lk op lo lu lv lw lx bi translated"><em class="oq">反应顶级API，</em><a class="ae ks" href="https://reactjs.org/docs/react-api.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-api.html</a></li><li id="5288" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><em class="oq">反应容器组件——Learn.co，</em><a class="ae ks" href="https://learn.co/lessons/react-container-components" rel="noopener ugc nofollow" target="_blank">https://learn.co/lessons/react-container-components</a></li></ul><p id="e123" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="oq">更多内容请看</em> <a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oq">说白了就是</em> </strong> </a> <em class="oq">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oq">免费每周简讯</em> </strong> </a> <em class="oq">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oq">社区</em> </strong> </a> <em class="oq">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>