<html>
<head>
<title>The ABCs of Code Splitting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码拆分的基础知识</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-abc-of-code-splitting-ebb7060ca704?source=collection_archive---------4-----------------------#2022-03-28">https://javascript.plainenglish.io/the-abc-of-code-splitting-ebb7060ca704?source=collection_archive---------4-----------------------#2022-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3c21e06e76fd7557f0aaf9b8955029b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoxciDT54DOlDoKBBk2Qaw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@tengyart?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tengyart</a> on <a class="ae jz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ca2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">找出修复web应用程序性能的最佳方法可能是一个棘手的问题。虽然这很大程度上取决于手头的项目，但我们可以相信一些通用技术，如<strong class="kc io">代码分割</strong>可以让我们走出困境。</p><h2 id="6753" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">A.<strong class="ak">为什么我们需要一个叫做<em class="lr">代码拆分</em>的东西？</strong></h2><p id="47cd" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">几乎每个JavaScript框架都将所有的代码+依赖项打包成一个大的JS文件。这有助于为最终客户提供一个真实的来源，并消除了多次网络调用来获取JS资源的需要。从理论上讲，这增强了应用程序的性能。</p><p id="704c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">直到它不存在。一旦包的大小超出比例，一次性解释和服务它的开销就会使这种方法变得有些无效。开发人员普遍认为包的大小不应该超过200kB (gzip)。</p><p id="827c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果浏览器需要4秒钟来加载JS包，那么您的web应用程序没有其他选择，只能显示一个白色的空白屏幕或某种加载程序。这通过像<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_paint" rel="noopener ugc nofollow" target="_blank">第一个令人满意的描绘</a>和<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/first_meaningful_paint" rel="noopener ugc nofollow" target="_blank">第一个有意义的描绘</a>这样的指标得到了负面的反映，更不用说最终用户的不满了。代码分割将帮助我们解决这个问题。</p><h2 id="9eca" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">B.<strong class="ak">什么是代码拆分？</strong></h2><p id="37a9" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">顾名思义，代码拆分是一种小心地将代码分成多个包的技术。</p><p id="273f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我创建了一个电子商务网站，销售五种不同的豪华手表。我知道我80%的到访顾客都会购买手表。如果我在第一次访问时就加载了<code class="fe ly lz ma mb b">htttps://buywatch.com/watch1</code>的JS包，那就太聪明了。如果用户访问任何其他手表的路线，我将按需加载相应的包。这将允许我更快地加载和呈现我的web应用程序。</p><blockquote class="mc"><p id="219a" class="md me in bd mf mg mh mi mj mk ml kx dk translated">代码分割:除非需要，否则不要加载JavaScript</p></blockquote><h2 id="e590" class="ky kz in bd la lb mm dn ld le mn dp lg kl mo li lj kp mp ll lm kt mq lo lp lq bi translated">C.<strong class="ak">如何拆分代码？</strong></h2><p id="2b51" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">有两种方法可以做到这一点。一、借助动态“导入”。第二，使用<code class="fe ly lz ma mb b"><a class="ae jz" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">React.lazy</a>.</code>我们将借助下面的例子讨论本文中的后一种方法。</p><p id="3e2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">甚至灯塔建议我们使用<code class="fe ly lz ma mb b">React.lazy</code>。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/1bd0bf24b561f24cf118e187d33ca8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJHLsGwr08g4arUa5ooN4g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 1. Lighthouse Chrome extension tool</figcaption></figure></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h2 id="c914" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">React应用程序的设置→</h2><p id="6e8a" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">让我们从一个非常简单的React应用程序<code class="fe ly lz ma mb b">code-split-app</code>开始。<code class="fe ly lz ma mb b">App.js</code>有以下路线</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/26ee139c5af45f37bbf3a8592e006745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTpFVIBKi01DaDSXjULyzA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 2. App.js</figcaption></figure><p id="53fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经下载了2个节点包到名为<a class="ae jz" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lx"> moment </em> </a>和<a class="ae jz" href="https://www.npmjs.com/package/lodash" rel="noopener ugc nofollow" target="_blank"> <em class="lx"> lodash </em> </a> <em class="lx">的应用程序中。请注意，我们还没有将这些模块导入到我们的应用程序中。<em class="lx"> </em>有了这个初始设置，让我们执行<code class="fe ly lz ma mb b">npm run build.</code></em></p><p id="6ad6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将为我们提供<em class="lx">优化的gzip生产版本</em>详情如下</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/dcb5cdbdb4e810aefcd64ae80d1288ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lb_yFXfy8fbqOsdXbhoXgQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 3. Original gzip</figcaption></figure><p id="cb2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，这意味着我们的应用程序的构建文件夹大小为<strong class="kc io"> 46.63kB </strong>，可以部署了。</p><p id="432c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们加载<code class="fe ly lz ma mb b">http://our-website/</code>，这就是此时<code class="fe ly lz ma mb b">bundle.js</code>的网络调用的样子(图4)。此外，现在如果您导航到任何路线，如<code class="fe ly lz ma mb b">/profile</code>或<code class="fe ly lz ma mb b">/home</code>，将不会触发新的包调用，因为我们所有的代码都已经加载。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/a4652fcad9c789317924dc1f407503c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVxefrAawrTsxWJgk4tb7g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 4. JS network requests</figcaption></figure><h2 id="d3fc" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">案例一。导入力矩和lodash。</h2><p id="10a6" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">让我们导入<code class="fe ly lz ma mb b">lodash</code>到<code class="fe ly lz ma mb b">Dashboard.js</code>和<code class="fe ly lz ma mb b">moment</code>到<code class="fe ly lz ma mb b">Profile.js.</code></p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/c0f581f2e808158346c3c1110902adec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmkNCcNihkrz7yfydFZpIQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 5. Case 1 gzip</figcaption></figure><p id="f988" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">突然，我们的文件大小增加了两倍！为什么会这样？如果你只是在应用程序中安装一个节点模块，它不会包含在最终的构建文件夹中，除非你在某个地方使用它。因此，当我们将这两个库导入到我们的项目文件中时,<code class="fe ly lz ma mb b">react-scripts</code>会选择它并将其放入最终的构建文件夹中。现在我们位于<strong class="kc io"> 89.76kB</strong></p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/5d73a6def9ae823de3735cc6a2d1b42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmpKxlvx81srwFTjNxIHeA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 6. JS network requests visiting <strong class="bd ng">our-website/ ; </strong>If you go to <code class="fe ly lz ma mb b">/profile</code> route, no additional JS files are loaded.</figcaption></figure></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="4508" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">优化的一个小方法是导入您真正想要使用的库的单个部分，而不是整个库。</p><h2 id="6690" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">好✅</h2><p id="82e4" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><code class="fe ly lz ma mb b">import lowerCase from ‘lodash/lowerCase’</code></p><h2 id="9239" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">巴特❎</h2><p id="7b0d" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><code class="fe ly lz ma mb b">import _ from ‘lodash’</code></p><p id="f301" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将创建一个大小为<strong class="kc io"> 71.72 kB </strong>的构建，而不是上面的<strong class="kc io"> 89.76kB </strong>。</p><h2 id="d003" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">案例二。延迟加载<code class="fe ly lz ma mb b">Profile.js</code></h2><p id="a71b" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">现在让我们在应用程序中实现一些<code class="fe ly lz ma mb b">React.lazy</code>。我们将首先在我们的<code class="fe ly lz ma mb b">Profile</code>模块中创建一个<code class="fe ly lz ma mb b">main.js</code>，并将我们的<code class="fe ly lz ma mb b">App.js</code>路由改为指向<code class="fe ly lz ma mb b">ProfileMain</code>而不是<code class="fe ly lz ma mb b">Profile</code>组件。代码如下所示:</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/79fdd155dacaf886a36d51b758c0747a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XXOGvTrISzGzyi89Ga3lQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 7. main.js</figcaption></figure><p id="f1f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ly lz ma mb b">React.lazy</code>允许您使用动态导入创建常规组件<code class="fe ly lz ma mb b">ProfileIndex</code>。当<code class="fe ly lz ma mb b">/profile</code>第一次被击中时，<code class="fe ly lz ma mb b">React.lazy</code>会自动加载与<code class="fe ly lz ma mb b">index.js.</code>关联的捆，请注意<code class="fe ly lz ma mb b">index.js</code>必须<code class="fe ly lz ma mb b">default</code>出口一个反作用组件。</p><p id="e38a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当React等待包加载时，它必须向最终用户显示一个类似“Loading”消息或动态<code class="fe ly lz ma mb b">Loading</code>组件的回退。这是通过<code class="fe ly lz ma mb b">Suspense.</code>实现的，因此惰性组件必须在<code class="fe ly lz ma mb b">Suspense</code>组件内部呈现。</p><p id="d14e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="lx">注</em></strong>→甚至可以用一个<code class="fe ly lz ma mb b"><em class="lx">Suspense</em></code> <em class="lx">组件包装多个惰性组件。</em></p><p id="adb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们现在构建应用程序。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/1a535d45842e040deaf3a7a748010552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xprrecYATwnTABPV3skXg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 8. Lazy load gzip</figcaption></figure><p id="9b9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的gzip中，我们可以看到<code class="fe ly lz ma mb b">main.[hashcode].js</code>现在被分成3个JS文件。顺便说一下，如果我们使用<code class="fe ly lz ma mb b">import lowerCase from ‘lodash/lowerCase’</code>，那么主束将下降到<strong class="kc io"> 49.6 kB。</strong></p><ol class=""><li id="4d84" class="nj nk in kc b kd ke kh ki kl nl kp nm kt nn kx no np nq nr bi translated"><code class="fe ly lz ma mb b">main.[hashcode].js</code>包含除以下文件之外的几乎所有应用程序代码。</li><li id="4d16" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated"><code class="fe ly lz ma mb b">426.[hashcode].chunk.js</code>包含力矩库。</li><li id="f821" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated"><code class="fe ly lz ma mb b">618.[hashcode].chunk.js</code>包含我们自己对应于<code class="fe ly lz ma mb b">Profile</code>模块的代码。</li></ol><blockquote class="nx ny nz"><p id="24cb" class="ka kb lx kc b kd ke kf kg kh ki kj kk oa km kn ko ob kq kr ks oc ku kv kw kx ig bi translated"><em class="in">但是请注意，如果</em>矩<em class="in">在项目中的其他任何地方使用，并且该文件或路径没有被直接或间接延迟加载，那么上面的第二个块文件将不会被创建，而是主捆绑包的一部分。</em></p></blockquote><p id="2077" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从图9和10中可以看出，捆绑文件和块文件是按需加载的</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/fe0382e53f7510016868b8f783b136ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15ZMWzeb1R2QXUZfi2RtZw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 9. JS network requests visiting <strong class="bd ng">our-website/</strong></figcaption></figure><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/dbfeb12f8ab55fa31ac8a40aef05494d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqIO2S-Kql-Jqsg63y1NCw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 10. JS network requests visiting <strong class="bd ng">our-website/profile</strong></figcaption></figure><p id="b039" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总结一下:</p><ol class=""><li id="9a97" class="nj nk in kc b kd ke kh ki kl nl kp nm kt nn kx no np nq nr bi translated">用React.lazy包装你的“基于路线的”组件。</li><li id="8d7e" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">创建一个包。反作用会将惰性加载的文件从主捆绑包中分离出来，并创建一个单独的块。</li><li id="884e" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">用户访问触发浏览器下载主捆绑包的web应用程序。</li><li id="3d72" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">用户访问惰性加载的路径，反应。惰性渲染<code class="fe ly lz ma mb b">Suspense</code>回退，同时我们等待惰性组件加载。</li><li id="8273" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">导致增强的性能和优雅的加载器处理。这就是所谓的<strong class="kc io">“基于路由的”</strong>代码拆分！</li></ol></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h2 id="d6d6" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">如何决定是否应该使用代码拆分？</h2><p id="5b16" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在我看来，你应该考虑以下规则来决定</p><ol class=""><li id="ebef" class="nj nk in kc b kd ke kh ki kl nl kp nm kt nn kx no np nq nr bi translated">如果只有不到30%的活跃用户访问过你的网站。<em class="lx">使用它！</em></li><li id="130b" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">如果它能帮助您减少超过10-15%的JS包大小。<em class="lx">用吧！</em></li><li id="05c3" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">如果您不习惯代码拆分的异步逻辑，或者您的代码需要进行重大更改来适应这种情况。<em class="lx">避免！</em></li><li id="3711" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">如果代码没有任何依赖项或本地导入。<em class="lx">避免！</em></li><li id="e85b" class="nj nk in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">最后，<code class="fe ly lz ma mb b">React.lazy</code>和<code class="fe ly lz ma mb b">Suspense</code>还不能用于服务器端渲染。相反，检查<a class="ae jz" href="https://loadable-components.com/docs/server-side-rendering/" rel="noopener ugc nofollow" target="_blank">可加载组件</a>。</li></ol></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h2 id="fa30" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">结论</h2><p id="971d" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">即使我们添加了2个重型节点模块，我们最终也只有<strong class="kc io"> 3 kB </strong>的额外负载，如果我们不使用这些智能技术，这可能会远远超过<strong class="kc io"> 43 kB </strong>。此外，在<strong class="kc io"> <em class="lx">覆盖率</em> </strong>下，我们可以看到我们的<code class="fe ly lz ma mb b">bundle.js</code>的未使用字节减少了将近<strong class="kc io"> 10% </strong>。如果您正在处理一个大型的应用程序，这种影响会更加显著。一定要记住过度杀戮！</p><p id="2d26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在这篇文章中跳过了一些概念，比如gzip、可加载组件、代码捆绑、捆绑包中的hashcode。如果你希望在接下来的文章中了解更多，那么请在评论中或<a class="ae jz" href="https://www.linkedin.com/in/abhayganjoo/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>中让我知道，并在Medium上关注我以获得相同的更新。😃我很乐意那样做。</p><p id="44bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这里了解另一个优化React应用的好方法<a class="ae jz" href="https://blog.bitsrc.io/how-to-make-your-react-application-even-faster-3efe9387cbb1" rel="noopener ugc nofollow" target="_blank">。😃非常感谢你的阅读！</a></p><p id="b140" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lx">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lx">plain English . io</em></strong></a><em class="lx">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lx">免费每周简讯</em> </strong> </a> <em class="lx">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lx">Twitter</em></strong></a><em class="lx">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lx">LinkedIn</em></strong></a><em class="lx">。加入我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lx">社区不和谐</em> </strong> </a> <em class="lx">。</em></p></div></div>    
</body>
</html>