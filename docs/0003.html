<html>
<head>
<title>Get Started with React Testing Library and Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React测试库和Jest入门</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-react-testing-library-and-jest-ccdc4d333b10?source=collection_archive---------2-----------------------#2022-01-01">https://javascript.plainenglish.io/getting-started-with-react-testing-library-and-jest-ccdc4d333b10?source=collection_archive---------2-----------------------#2022-01-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5dd0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">面向初学者的Jest和React测试库介绍。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ad60d11ddc5e18481ddeeaeb2035fc8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kldCKUiVz-wzg-DE"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ee6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React测试库已经成为为React应用程序编写测试用例的最流行的选择。这些测试案例类似于用户如何使用您的应用程序。如果您使用的是create-react-app工具的最新版本，那么您已经安装了Jest和测试库。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/083799f6c8faca5c7a4d0d8d516c3385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KsZa2WAcA16gHxlNuezzBQ.gif"/></div></div></figure><p id="5b0b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在深入研究代码之前，让我们快速回顾一下Jest的基础知识。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="bddf" class="lv lw in lr b gy lx ly l lz ma">const expected = true;<br/>const actual = false;<br/>describe("simple jest test", () =&gt; {<br/>  test("it works", () =&gt; {<br/>    expect(actual).toBe(expected);<br/>  });<br/>});</span></pre><p id="7cf2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的代码是一个简单的Jest测试的例子。它包含以下内容:</p><ol class=""><li id="fc75" class="mb mc in kv b kw kx kz la lc md lg me lk mf lo mg mh mi mj bi translated">将我们的测试套件分解成组件。</li></ol><p id="6b6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.<code class="fe mk ml mm lr b">test</code>功能是一个测试用例。</p><p id="1876" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.<code class="fe mk ml mm lr b">expect</code>功能是每次你想测试一个值时使用的。</p><p id="09b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们看看react代码。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/23e0635f1f150521a531fd0405e58532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Yd0d9zHOD2lKLnpDgDr5_Q.gif"/></div></figure><p id="2b66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">完整源代码:<a class="ae ks" href="https://github.com/ankitsaxena21/React-ts-RTL" rel="noopener ugc nofollow" target="_blank"> Github回购链接</a>。</p><p id="f5c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是一个用react和typescript构建的简单的todo应用程序。它所做的只是接受一些文本作为输入，并在按下enter时，将输入的文本添加到列表中。接下来，我们将为这个应用程序编写测试用例。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="75ee" class="lv lw in bd mq mr ms dn mt mu mv dp mw lc mx my mz lg na nb nc lk nd ne nf ng bi translated"><strong class="ak"> 1。基本测试</strong></h2><p id="9c01" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">首先，让我们测试react应用程序的基本渲染功能。例如，组件或元素是否正确地呈现在屏幕上。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="9815" class="lv lw in lr b gy lx ly l lz ma">import Todo from './Todo';</span><span id="59b5" class="lv lw in lr b gy nm ly l lz ma">it('Renders without crashing', () =&gt; {<br/>   render(&lt;Todo /&gt;);<br/>   const linkElement = screen.getByText(/Todo App/i);<br/>   expect(linkElement).toBeInTheDocument();<br/>});</span></pre><p id="cd5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们导入了我们的<Todo/>组件，并使用render()函数对其进行虚拟渲染。我们将使用查询来获得我们想要的DOM元素。查询用于查找页面上的元素(RTL文档<a class="ae ks" href="https://testing-library.com/docs/queries/about#types-of-queries" rel="noopener ugc nofollow" target="_blank">中关于查询的更多信息</a>)。</p><p id="e083" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用RTL提供的getByText()查询。它将为我们提供所有具有文本节点的元素，该文本节点的textContent与给定的TextMatch匹配(即“Todo App”)。</p><p id="6037" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Jest提供了。toBeInTheDocument()匹配器，可用于断言元素是否在文档的主体中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/b5ce247bf9606bfffdf064c5387766e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Msjo9Dzr6AntMsTBVVrvRw.gif"/></div></figure><p id="7486" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">提示</strong>:我们可以使用screen.debug()来查看组件当前的HTML输出。</p><h2 id="3551" class="lv lw in bd mq mr ms dn mt mu mv dp mw lc mx my mz lg na nb nc lk nd ne nf ng bi translated"><strong class="ak"> 2。测试事件</strong></h2><p id="f528" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">现在我们将检查如何测试事件。例如onChange、onClick等。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="9c9f" class="lv lw in lr b gy lx ly l lz ma">it("When the Enter button is pressed, it creates a new todo item", () =&gt; {<br/>    const { getByTestId, getByText } = render(&lt;Todo /&gt;);<br/>    const event = { target: { value: "test val" } };<br/>    fireEvent.change(getByTestId("todo-input"), event);<br/>    expect(getByTestId("todo-input")).toHaveValue("test val");<br/>    fireEvent.submit(getByTestId("add"));<br/>    expect(getByText("test val")).toBeInTheDocument();<br/>  });</span></pre><p id="bd0b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的代码中，首先，我们通过getByTestId()获取输入。这是从DOM树中获取具有特定data-testid属性的元素的另一种方式。(<a class="ae ks" href="https://testing-library.com/docs/queries/bytestid/" rel="noopener ugc nofollow" target="_blank">RTL文档中关于getByTestId的更多信息</a>)。</p><p id="6970" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用RTL提供的fireEvent属性来测试事件。传递给fireEvent的第二个参数(即eventProperties)是将分配给接收事件的节点的属性。换句话说，触发事件时元素应该具有的值。(<a class="ae ks" href="https://testing-library.com/docs/dom-testing-library/api-events/#fireevent" rel="noopener ugc nofollow" target="_blank">RTL文档中关于fireEvent的更多信息</a>)。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="ec1a" class="lv lw in lr b gy lx ly l lz ma">const { getByTestId, getByText } = render(&lt;Todo /&gt;);<br/> const event = { target: { value: "test val" } };<br/> fireEvent.change(getByTestId("todo-input"), event);</span></pre><p id="7e7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦事件被触发，我们就检查DOM，看看输入的值是否与传递给fireEvent的值相同(在第二个参数中)。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="c475" class="lv lw in lr b gy lx ly l lz ma">expect(getByTestId("todo-input")).toHaveValue("test val");</span></pre><p id="e32d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我们对表单提交事件做了同样的事情，然后检查输入框中输入的值是否呈现在列表中。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="e23e" class="lv lw in lr b gy lx ly l lz ma">fireEvent.submit(getByTestId("add"));<br/>expect(getByText("test val")).toBeInTheDocument();</span></pre><p id="2a7a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意</strong>:使用RTL测试事件的另一种方式是通过用户事件。(<a class="ae ks" href="https://testing-library.com/docs/ecosystem-user-event/" rel="noopener ugc nofollow" target="_blank">RTL文档中关于用户事件的更多信息</a>)</p><h2 id="480f" class="lv lw in bd mq mr ms dn mt mu mv dp mw lc mx my mz lg na nb nc lk nd ne nf ng bi translated"><strong class="ak"> 3。奖励:测试API的</strong></h2><p id="ee90" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">任何react应用程序的另一个重要部分是我们使用的API。为了测试这些API的工作情况，我们将模拟服务人员。这是在测试中嘲弄<code class="fe mk ml mm lr b">axios</code>和<code class="fe mk ml mm lr b">fetch</code>的一种简单而有效的方式。</p><p id="7fad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是一个简单的JavaScript函数，它将使用axios进行API调用(<a class="ae ks" href="https://animechan.vercel.app/guide" rel="noopener ugc nofollow" target="_blank"> Animechan API Link </a>)，并返回给我们一个随机的动画名称。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="8d4f" class="lv lw in lr b gy lx ly l lz ma">import axios from 'axios';</span><span id="3539" class="lv lw in lr b gy nm ly l lz ma">const fetchData = () =&gt; {<br/>    return axios.get('<a class="ae ks" href="https://animechan.vercel.app/api/random'" rel="noopener ugc nofollow" target="_blank">https://animechan.vercel.app/api/random'</a>)<br/>        .then(res =&gt; {<br/>            return res.data.anime<br/>        })<br/>        .catch(err =&gt; {<br/>            console.log(err)<br/>        })<br/>};</span><span id="d43a" class="lv lw in lr b gy nm ly l lz ma">export default fetchData;11</span></pre><p id="e1e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们不想发出实际的API请求，主要原因如下:</p><ol class=""><li id="af08" class="mb mc in kv b kw kx kz la lc md lg me lk mf lo mg mh mi mj bi translated">它很慢</li><li id="82c8" class="mb mc in kv b kw nn kz no lc np lg nq lk nr lo mg mh mi mj bi translated">这是不可预测的(从API返回的响应对于每个请求可能是不同的)</li></ol><p id="11f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我们实际做的是创建一个模拟服务器，如下面的代码所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b9e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">导入到这个测试文件中的前几个东西是<code class="fe mk ml mm lr b">{rest} from ‘msw’</code>和<code class="fe mk ml mm lr b">{setupServer} from ‘msw/node’</code>。然后我们创建一个<code class="fe mk ml mm lr b">server</code>变量，并将其设置为等于<code class="fe mk ml mm lr b">setupServer</code>函数。基本上<code class="fe mk ml mm lr b">setupServer</code>正在做的是:</p><ol class=""><li id="1e00" class="mb mc in kv b kw kx kz la lc md lg me lk mf lo mg mh mi mj bi translated">设置服务器，即监听对所提供的API的任何请求。</li><li id="cf2c" class="mb mc in kv b kw nn kz no lc np lg nq lk nr lo mg mh mi mj bi translated"><strong class="kv io">拦截</strong>它们，并且</li><li id="51dd" class="mb mc in kv b kw nn kz no lc np lg nq lk nr lo mg mh mi mj bi translated">处理应该做出的响应。</li></ol><p id="906d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，beforeAll()和afterAll()用于在每次测试运行之前和之后运行一些特定的代码(在本例中是启动和关闭服务器)。</p><p id="c3fa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们可以简单地使用“await fetchData()”来调用我们的API，并使用expect()来检查服务器是否返回预期的值。真正的API服务器可能会返回任何随机的动漫名称。然而，我们的模拟服务工作者拦截了请求并在响应中返回<code class="fe mk ml mm lr b">‘naruto’</code>，因此我们的测试将通过！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/6c33b4f3e337435be85ff4e9a33c9e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MKkSXZgXCrGBI9ihB3RMQg.gif"/></div></div></figure><p id="e0a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">完整源代码:<a class="ae ks" href="https://github.com/ankitsaxena21/React-ts-RTL" rel="noopener ugc nofollow" target="_blank"> Github回购链接</a>。</p><p id="2a5a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">视频解释:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt mp l"/></div></figure><p id="5fd8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nu">更多内容看</em> <a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nu">说白了。报名参加我们的</em> </a><a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nu">免费每周简讯</em> </a> <em class="nu">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nu">社区</em> </a> <em class="nu">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>