<html>
<head>
<title>An Overview of Decorators in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的装饰器概述</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/overview-of-decorators-in-typescript-1384ae222ce9?source=collection_archive---------11-----------------------#2022-11-21">https://javascript.plainenglish.io/overview-of-decorators-in-typescript-1384ae222ce9?source=collection_archive---------11-----------------------#2022-11-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6f1c8a63b9a77d8c47dad52ab16e553b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G8iydEkhENx6I10d"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6abc" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">打字稿中的装饰者</h1><p id="a4e6" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">装饰器是任何编程语言中非常有用和强大的特性。通过将任何方法、类或属性隔离到另一个父函数中，它允许您更改程序的功能，在这个父函数中，我们将拥有更改行为所需的一切</p><p id="e793" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">理解decorator的一个简单方法是求解这个表达式<code class="fe mb mc md me b">the decorator will run when either my programming begin to run or finished running</code>,其中decorator是你的对象的父对象，但不影响程序的执行，尽管你可以在数据被给定的函数处理后操纵它</p><h2 id="c1af" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">装饰者的用例</h2><p id="125c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在继续之前，让我们试着理解装饰者的一些用例。一个主要的用例是对一组给定的参数进行任何常规操作，</p><ul class=""><li id="ea73" class="mr ms in la b lb lw lf lx lj mt ln mu lr mv lv mw mx my mz bi translated">将字段设为只读</li><li id="bae7" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">使字段为事件监听和观察做好准备</li><li id="6d3c" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">制作字段枚举器</li></ul><p id="9878" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">一些功能使用案例如下</p><ul class=""><li id="421f" class="mr ms in la b lb lw lf lx lj mt ln mu lr mv lv mw mx my mz bi translated">字段上的常见验证</li><li id="174a" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">日志记录功能</li><li id="9c5b" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">存储错误信息</li><li id="f90e" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">格式化给定字段</li><li id="5531" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">对不推荐使用的字段或方法发出警告</li></ul><p id="038c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">不管怎样，你可以发现装饰器对任何类型的应用程序都非常有用。因为它们是编译时间过程，所以我们也可以在前端框架中使用它们</p><h2 id="c49e" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">实验装饰师</h2><p id="3430" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">目前，typescript中的decorators是实验性的特性，所以它可能会在未来的版本中出现，直到有一个稳定的版本</p><h1 id="d995" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Typescript中的装饰器类型</h1><p id="1e42" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">装饰类型是由不同类别对象的数量定义的，它们可以通过它们的功能附加到这些类别对象上。因为类、函数、s和属性在编程语言中都有不同的含义，所以我们可以有把握地说它们是所使用的装饰器的一般类别。另一方面，您也可以用以下方式定义装饰者</p><ul class=""><li id="ff7a" class="mr ms in la b lb lw lf lx lj mt ln mu lr mv lv mw mx my mz bi translated">工厂装饰者(Factory decorator)——当你想为函数或属性的行为向装饰者传递一些附加信息时。<code class="fe mb mc md me b">e.g logLevel('info')</code></li><li id="cf48" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="la io">类装饰器</strong> —每当构造函数方法调用时的装饰器。<code class="fe mb mc md me b">e.g lastActivity()</code></li><li id="471f" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="la io">属性装饰者</strong> —设置或获取属性时的装饰者。<code class="fe mb mc md me b">e.g formatDate('MM-YY-DDDD')</code></li><li id="fe71" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="la io">方法装饰者</strong> —处理方法及其调用，同时保持其执行顺序。</li></ul><p id="e856" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><code class="fe mb mc md me b">e.g requiredAttributes(['email', 'firstname'])</code></p><ul class=""><li id="d65e" class="mr ms in la b lb lw lf lx lj mt ln mu lr mv lv mw mx my mz bi translated"><strong class="la io">访问decorator</strong>—用decorator管理任何静态或隐藏的属性。<code class="fe mb mc md me b">e.g readonly()</code></li><li id="9487" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="la io">参数装饰器</strong> —将装饰器作为参数传递给任何函数或另一个装饰器。<code class="fe mb mc md me b">e.g func(@formbuilder builder)</code></li></ul><p id="cb6b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">你可以在乔纳森·卡多佐的这篇精彩文章中简单了解所有不同的类型及其例子</p><div class="nf ng gp gr nh ni"><a href="https://www.digitalocean.com/community/tutorials/how-to-use-decorators-in-typescript#creating-accessor-decorators" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">如何在TypeScript | DigitalOcean中使用Decorators</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">装饰器是用额外的功能来装饰类成员或类本身的一种方式。本教程涵盖了…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">www.digitalocean.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jt ni"/></div></div></a></div><h2 id="13ab" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">装饰者的几个例子</h2><p id="ec2c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们举几个例子来看看实际情况。我们将从日志示例开始。这里我们创建了一个简单的高阶函数，它将接受装饰者的一般参数</p><ul class=""><li id="aa5e" class="mr ms in la b lb lw lf lx lj mt ln mu lr mv lv mw mx my mz bi translated">目标——装饰器所针对的类、窗口或函数</li><li id="d5b7" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">memberName —装饰者所附加的对象的名称</li><li id="b691" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">描述符—对象的任何元数据。它也将包含对象的定义</li></ul><p id="f332" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">为了执行，我们使用<code class="fe mb mc md me b">call</code>来运行方法，同时维护参数，然后将其注销。同样方法的另一个扩展可以是<code class="fe mb mc md me b">logCatchError</code></p><pre class="nx ny nz oa gt ob me oc bn od oe bi"><span id="730e" class="of kb in me b be og oh l oi oj"><br/>const logCatchError = () =&gt; {<br/>    return (target: any, memberName: string, descriptor: PropertyDescriptor) =&gt; {<br/>        const original = descriptor.value;<br/><br/>        descriptor.value = function (...args: any) {<br/>            try {<br/>              const result = original.call(this, ...args);<br/>              return result;<br/>            } catch(error){<br/>              console.error(error)<br/>            }<br/>        }<br/>    }<br/>}<br/></span></pre><p id="852e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">另一个例子——我们可以说一个名为<code class="fe mb mc md me b">sendEmail</code>的方法需要用户的电子邮件和名字，但是假设电子邮件是一个可选字段，那么我们需要限制用户访问该方法</p><p id="755a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在方法<code class="fe mb mc md me b">requiredField</code>中，我们需要传递一个属性名列表，我们需要检查这些属性名的值，出于文章的目的，我们只能测试这些字段的假值，如果有任何字段不存在，我们就简单地向用户抛出一个错误</p><pre class="nx ny nz oa gt ob me oc bn od oe bi"><span id="90a8" class="of kb in me b be og oh l oi oj">function requiredField(names: string[]) {<br/>    return (target: any, memberName: string, descriptor: PropertyDescriptor) =&gt; {<br/>        const original = descriptor.value;<br/><br/>        descriptor.value = function (...args: any) {<br/>            if (names.some(key =&gt; !target[key])) {<br/>                throw new Error(`${names.join()} fields are required while calling ${memberName}`)<br/>            }<br/>            const result = original.call(this, ...args);<br/>            return result;<br/>        }<br/>    }<br/>}<br/><br/>class User {<br/>    firstName: string = "Jon"<br/>    email: string<br/><br/>    @dateFormat('toISOString')<br/>    dob?: Date<br/><br/>    @minLength(8)<br/>    bio: string;<br/><br/>    constructor(bio: string, email?: string, dob?: Date) {<br/>        this.bio = bio<br/>        this.email = email ?? ''<br/>        this.dob = dob<br/>    }<br/><br/>    @logEverything()<br/>    getFullName(prefix: string) {<br/>        return `${prefix} ${this.firstName} ${this.lastName}`;<br/>    }<br/><br/>    @requiredField(['email', 'firstName'])<br/>    sendMail() {<br/>        console.log('sending email to user')<br/>    }<br/>}</span></pre><p id="2112" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在同一个例子中，你还可以看到更多的装饰器，如<code class="fe mb mc md me b">minLength</code>和<code class="fe mb mc md me b">dateFormat</code>它们也可以通过使用属性装饰器如follow来实现</p><pre class="nx ny nz oa gt ob me oc bn od oe bi"><span id="05b6" class="of kb in me b be og oh l oi oj">function minLength(limit: number) {<br/>    return function (target: Object, propertyKey: string) {<br/>        let value: string;<br/>        const getter = function () {<br/>            return value;<br/>        };<br/>        const setter = function (newVal: string) {<br/>            if (newVal.length &lt; limit) {<br/>                throw new Error(`Your ${propertyKey} should be bigger than ${limit} characters`)<br/>            } else {<br/>                value = newVal;<br/>            }<br/>        };<br/>        Object.defineProperty(target, propertyKey, {<br/>            get: getter,<br/>            set: setter<br/>        });<br/>    }<br/>}</span></pre><p id="4d68" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">上述装饰者的观点是，我们没有使用getter和setter，因为我们现在使用的属性装饰者没有方法定义</p><p id="b63b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">对于格式，我们需要改变接口，因为我直接调用了日期类方法，但是你可以创建更多的属性</p><pre class="nx ny nz oa gt ob me oc bn od oe bi"><span id="194b" class="of kb in me b be og oh l oi oj"><br/>interface setterDate extends Date {<br/>    [key: string]: any<br/>}<br/><br/>function dateFormat(format: string) {<br/>    return function (target: Object, propertyKey: string) {<br/>        let value: setterDate;<br/>        const getter = function () {<br/>            if(!value) return <br/>            return value[format]();<br/>        };<br/>        const setter = function (newVal: Date) {<br/>            value = newVal<br/>        };<br/>        Object.defineProperty(target, propertyKey, {<br/>            get: getter,<br/>            set: setter<br/>        });<br/>    }<br/>}</span></pre><h2 id="c855" class="mf kb in bd kc mg mh dn kg mi mj dp kk lj mk ml ko ln mm mn ks lr mo mp kw mq bi translated">结论</h2><p id="a030" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">装饰器在任何编程语言中都是一个方便的工具。decorator有一种模式，允许您在decorator中创建公共代码，并在项目中彻底使用它们。</p><p id="0169" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">考虑到TypeScript仍处于试验阶段，我希望您对如何开始使用它的装饰器有一个简单的想法。</p><p id="2384" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="ok">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ok">plain English . io</em></strong></a><em class="ok">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ok">免费周报</em> </strong> </a> <em class="ok">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ok">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ok">LinkedIn</em></strong></a><em class="ok"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ok">YouTube</em></strong></a><em class="ok"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ok">不和</em> </strong> </a> <em class="ok">。对增长黑客感兴趣？检查</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ok">电路</em> </strong> </a> <em class="ok">。</em></p></div></div>    
</body>
</html>