<html>
<head>
<title>Angular: How to make a loading spinner work to solve the issue with parallel Http Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:如何使用加载微调器来解决并行Http请求的问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-how-to-make-a-loading-spinner-work-to-solve-the-issue-with-parallel-http-requests-cc55a3e25711?source=collection_archive---------2-----------------------#2022-12-23">https://javascript.plainenglish.io/angular-how-to-make-a-loading-spinner-work-to-solve-the-issue-with-parallel-http-requests-cc55a3e25711?source=collection_archive---------2-----------------------#2022-12-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7ca5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以在根组件和/或子组件级别添加加载微调器，以向用户指示任何请求的进度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d49343a306455e69b196e18215a62044.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/1*ax0N4KfTHQxXDY7G7HeeoA.gif"/></div></figure><p id="9bb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论您将它添加到哪里:</p><p id="3f6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;整个应用程序的根组件级别有一个通用微调器</p><p id="5859" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运筹学</p><p id="df70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;每个组件1个微调器</p><p id="d18d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一个常见问题。让我列出问题的步骤。</p><ol class=""><li id="f570" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated">我有许多并行运行的http请求。</li><li id="d4d0" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">在每个请求开始之前，微调器启动，在每个请求结束之后，微调器隐藏。</li><li id="d3c6" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">有可能请求A即将完成，而请求B开始。只要两者都在进行中，微调器就会一直运行。但是当请求A完成时，它将隐藏微调器，即使请求B仍在进行中。</li></ol><p id="1988" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们如何告诉Angular，<strong class="jm io">只要至少有一个http请求正在进行，就不要隐藏微调器</strong>？</p><p id="8611" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;一种可能性是在<strong class="jm io">拦截器级别</strong>处理。拦截器级别的处理也意味着整个应用程序只能有一个通用的spinner。</p><p id="05e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">模态/对话只不过是另一个组件，是打开它的组件的子组件。</p><p id="001b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能会问我如何将这种方法扩展到情态动词/对话？在这个场景中，<strong class="jm io">一旦模态被执行/提交，</strong>就让<strong class="jm io">将http请求执行从模态传递给它的父组件来处理它</strong>。</p><p id="c326" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;如果您不希望在拦截器级别处理它，下一个选项是使用<strong class="jm io"> RXJS mergeMap、merge、forkJoin </strong>操作符对要并行执行的API调用进行分组。这确保了当API调用开始执行时微调器开始显示，并且只有在所有调用都完成执行(成功/错误)后，加载微调器才会隐藏。</p><p id="aa1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个使用forkJoin和merge操作符并行执行4个API调用的例子。在第一个和第二个API调用开始执行之前，我引入了5秒和2秒的延迟。第三和第四个API调用立即开始执行。<strong class="jm io">延迟的目的是为了表明，直到所有的API调用没有成功/错误地完成，微调器不会隐藏。</strong></p><p id="92a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<strong class="jm io">叉连接</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi le"><img src="../Images/88b58a5ef3ea9504efe74f8b8e47ced3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/1*KLglXkCaAWRQQb3fUeTl3w.gif"/></div></figure><p id="efd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<strong class="jm io">合并</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/fd2baa7c060d6cdbc5a8c910e7d5724f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/1*35iE4EktBgTw6hrdX_oaig.gif"/></div></figure><div class="lg lh gp gr li lj"><a href="https://stackblitz.com/edit/angular-sbuqbb?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd io gy z fp lo fr fs lp fu fw im bi translated">角形(叉形)堆叠</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">基于@angular/animations、@angular/common、@angular/compiler、@angular/core、@angular/forms的angular-cli项目…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">stackblitz.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx ko lj"/></div></div></a></div><p id="0415" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以上是这种方法的工作示例。</p><p id="5737" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我没有详细介绍这一点，因为在这个故事中，我想更多地关注在拦截器级别处理它的第一种方法。</p><p id="4aa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们继续讨论拦截机的方法。</p><p id="5951" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个简单的项目，我将演示如何使用一个加载微调器来指示多个Http请求的进行中状态。</p><p id="2187" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从<strong class="jm io">拦截器</strong>和<strong class="jm io"> SpinnerService </strong>开始，来理解我们如何解决并行http请求的问题。</p><p id="0c00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">纺纱服务。</strong>该服务的目的主要是处理装载旋转器的隐藏/显示。它还处理Http请求失败时遇到的错误消息的显示。</p><pre class="kj kk kl km gt ly lz ma bn mb mc bi"><span id="7346" class="md me in lz b be mf mg l mh mi">@Injectable({ providedIn: ‘root’ })<br/>export class SpinnerService {<br/>constructor() {}<br/><br/>private spinnerSub$ = new BehaviorSubject&lt;boolean&gt;(false);<br/>private errSub$ = new Subject&lt;any&gt;();<br/>errObsv$ = this.errSub$.asObservable()<br/>.pipe(scan((acc, curr) =&gt; (acc = acc.concat(curr)), []));<br/><br/>spinnerObsv$ = this.spinnerSub$.asObservable();<br/><br/>toggleLoadingSpinner(status: boolean) {<br/>this.spinnerSub$.next(status);<br/>}<br/><br/>pushMessage(err: any) {<br/>this.errSub$.next(err);<br/>}<br/>}</span></pre><p id="dc75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个想法很简单。</p><p id="478f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;分别有一个<strong class="jm io">私有主题</strong>用于处理加载微调器和错误，即<strong class="jm io"> spinnerSub$和errrSub$ </strong>。</p><p id="4200" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;我们已经提供了<strong class="jm io">公共方法</strong>来允许组件/拦截器将数据传递给<strong class="jm io">主题</strong>，即<strong class="jm io"> toggleLoadingSpinner() </strong>和<strong class="jm io"> pushMessage()。</strong></p><p id="ac4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;我们还创建了一个对应于每个<strong class="jm io">私有主题</strong>的<strong class="jm io">公共可观察对象</strong>，即<strong class="jm io"> spinnerObsv$ </strong>和<strong class="jm io"> errObsv$。</strong>这使得<strong class="jm io"/><strong class="jm io">组件能够访问这个可观察的</strong>并决定是否显示/隐藏微调器和显示错误信息。</p><p id="ea95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向<strong class="jm io">拦截器</strong>移动。这可能看起来很大，但概念很简单:</p><p id="0bf3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">"只要至少有一个请求正在进行，就显示微调器。当所有请求完成执行(成功/失败)时隐藏微调器"</p><pre class="kj kk kl km gt ly lz ma bn mb mc bi"><span id="2847" class="md me in lz b be mf mg l mh mi">interface UniqueRequest {<br/>uniqueRequestIdentifier: number;<br/>req: HttpRequest&lt;any&gt;;<br/>}<br/><br/>@Injectable()<br/>export class SpinningInterceptorService implements HttpInterceptor {<br/>constructor(private service: SpinnerService) {}<br/><br/>inProgressRequests: UniqueRequest[] = [];<br/>uniqueRequestIdentifier: number = 0;<br/><br/>removeRequest(modifiedReq: UniqueRequest) {<br/>let areRequestsPending: boolean = false;<br/><br/>let reqIndex = this.inProgressRequests.findIndex((x) =&gt;<br/>x.req.url === modifiedReq.req.url &amp;&amp;<br/>x.req.method === modifiedReq.req.method &amp;&amp;<br/>x.uniqueRequestIdentifier === modifiedReq.uniqueRequestIdentifier<br/>);<br/><br/>if (reqIndex &gt; -1) {<br/>this.inProgressRequests.splice(reqIndex, 1);<br/>}<br/>areRequestsPending = this.inProgressRequests.length &gt; 0;<br/>this.service.toggleLoadingSpinner(areRequestsPending);<br/>}<br/><br/>addRequest(modifiedReq: UniqueRequest) {<br/>this.inProgressRequests.push(modifiedReq);<br/>this.service.toggleLoadingSpinner(true);<br/>}<br/><br/>intercept(req: HttpRequest&lt;any&gt;,next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {<br/>this.uniqueRequestIdentifier = this.uniqueRequestIdentifier + 1;<br/>let modifiedReq = {<br/>…{ uniqueRequestIdentifier: this.uniqueRequestIdentifier },<br/>…{ req: req },<br/>};<br/>this.addRequest(modifiedReq);<br/><br/>return next.handle(req).pipe(<br/>delay(2000),<br/>finalize(() =&gt; {<br/>//error or success : remove the request<br/>this.removeRequest(modifiedReq);<br/>})<br/>);<br/>}<br/>}</span></pre><ol class=""><li id="86df" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated"><strong class="jm io"> inProgressRequests </strong>属性是一个类型为<strong class="jm io"> UniqueRequest </strong>的对象数组。</li></ol><pre class="kj kk kl km gt ly lz ma bn mb mc bi"><span id="0fbd" class="md me in lz b be mf mg l mh mi">  inProgressRequests: UniqueRequest[] = [];<br/>  uniqueRequestIdentifier: number = 0;</span></pre><p id="182a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看接口，我们知道每个对象将包含一个<strong class="jm io"> req属性</strong>，它是实际的<strong class="jm io"> HttpRequest </strong>和一个<strong class="jm io">uniqueRequestIdentifier</strong>属性，它只是分配给每个请求的一个数字。编号的目的只是为了在多个HttpRequest的url和方法相同的情况下给对象增加一些唯一性。</p><pre class="kj kk kl km gt ly lz ma bn mb mc bi"><span id="48de" class="md me in lz b be mf mg l mh mi">interface UniqueRequest {<br/>uniqueRequestIdentifier: number;<br/>req: HttpRequest&lt;any&gt;;<br/>}</span></pre><p id="ed5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以<strong class="jm io">对象属性req </strong>只不过是HttpRequest，对象属性<strong class="jm io">uniqueRequestIdentifier</strong>从类属性<strong class="jm io"> uniqueRequestIdentifier获取其值。</strong></p><p id="4eba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.从<strong class="jm io">截距()</strong>开始，</p><pre class="kj kk kl km gt ly lz ma bn mb mc bi"><span id="1e8e" class="md me in lz b be mf mg l mh mi">intercept(req: HttpRequest&lt;any&gt;,next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {<br/>this.uniqueRequestIdentifier = this.uniqueRequestIdentifier + 1;<br/>let modifiedReq = {<br/>…{ uniqueRequestIdentifier: this.uniqueRequestIdentifier },<br/>…{ req: req },<br/>};<br/>this.addRequest(modifiedReq);<br/><br/>return next.handle(req).pipe(<br/>delay(2000),<br/>finalize(() =&gt; {<br/>//error or success : remove the request<br/>this.removeRequest(modifiedReq);<br/>})<br/>);<br/>}</span></pre><p id="a9fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个方法中，我们首先增加类属性<strong class="jm io">uniqueRequestIdentifier</strong>来为请求创建一个新的标识符。</p><p id="237f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将http req对象<strong class="jm io"> req </strong>和类属性<strong class="jm io">uniqueRequestIdentifier</strong>添加到新对象<strong class="jm io"> modifiedReq </strong>中。</p><p id="00e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是调用<strong class="jm io"> addRequest() </strong>，将对象<strong class="jm io"> modifiedReq </strong>作为参数传递。在这个方法中，我们将对象<strong class="jm io"> modifiedReq </strong>推入<strong class="jm io"> inProgressRequests </strong>数组，然后调用<strong class="jm io"> SpinnerService </strong>的<strong class="jm io"> toggleLoadingSpinner() </strong>来开始显示加载微调器。请注意，我们已经将<strong class="jm io"> true </strong>作为参数传递给了<strong class="jm io"> toggleLoadingSpinner() </strong>，以指示请求即将开始，微调器需要显示。</p><pre class="kj kk kl km gt ly lz ma bn mb mc bi"><span id="6585" class="md me in lz b be mf mg l mh mi">addRequest(modifiedReq: UniqueRequest) {<br/>this.inProgressRequests.push(modifiedReq);<br/>this.service.toggleLoadingSpinner(true);<br/>}</span></pre><p id="ec4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到intercept()，注意我们已经将<strong class="jm io"> delay() </strong>和<strong class="jm io"> finalize() </strong> rxjs操作符通过管道传递给HttpRequest返回的可观察对象。</p><pre class="kj kk kl km gt ly lz ma bn mb mc bi"><span id="10f8" class="md me in lz b be mf mg l mh mi">return next.handle(req).pipe(<br/>delay(2000),<br/>finalize(() =&gt; {<br/>//error or success : remove the request<br/>this.removeRequest(modifiedReq);<br/>})<br/>);</span></pre><p id="de83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">delay()操作符的目的只是添加一个2秒的延迟，以便可以清楚地看到微调器。</p><p id="353d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不管HttpRequest是成功还是失败，finalize() 操作符都会执行。在这两种情况下，我们都需要隐藏微调器。因此，此时调用<strong class="jm io"> removeRequest() </strong>，将<strong class="jm io"> modifiedReq对象</strong>作为参数传递。</p><pre class="kj kk kl km gt ly lz ma bn mb mc bi"><span id="e3e5" class="md me in lz b be mf mg l mh mi">removeRequest(modifiedReq: UniqueRequest) {<br/>let areRequestsPending: boolean = false;<br/><br/>let reqIndex = this.inProgressRequests.findIndex((x) =&gt;<br/>x.req.url === modifiedReq.req.url &amp;&amp;<br/>x.req.method === modifiedReq.req.method &amp;&amp;<br/>x.uniqueRequestIdentifier === modifiedReq.uniqueRequestIdentifier<br/>);<br/><br/>if (reqIndex &gt; -1) {<br/>this.inProgressRequests.splice(reqIndex, 1);<br/>}<br/>areRequestsPending = this.inProgressRequests.length &gt; 0;<br/>this.service.toggleLoadingSpinner(areRequestsPending);<br/>}</span></pre><p id="d69e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> removeRequest() </strong>中，我们首先根据请求的url、方法和uniqueRequestIdenfier值在<strong class="jm io"> inProgressRequests </strong>数组中定位请求。接下来，我们从数组中删除找到的请求。</p><p id="4006" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此时，如果<strong class="jm io"> inProgressRequests </strong>数组为空，则意味着当前<strong class="jm io">没有其他请求正在进行</strong>，我们可以调用SpinnerService的<strong class="jm io"> toggleLoadingSpinner() </strong>，传递<strong class="jm io"> false </strong>作为参数来隐藏微调器。</p><p id="652a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果i <strong class="jm io"> nProgressRequests </strong>数组不为空，这意味着还有其他请求正在进行中，我们必须通过将<strong class="jm io"> true </strong>作为参数传递给SpinnerService的<strong class="jm io"> toggleLoadingSpinner() </strong>来继续显示spinner。</p><p id="6bae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是工作示例。</p><div class="lg lh gp gr li lj"><a href="https://stackblitz.com/edit/angular-oc1fxl?file=src/app/spinning-interceptor.service.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd io gy z fp lo fr fs lp fu fw im bi translated">角形(叉形)堆叠</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">基于@angular/animations、@angular/common、@angular/compiler、@angular/core、@angular/forms的angular-cli项目…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">stackblitz.com</p></div></div><div class="ls l"><div class="mj l lu lv lw ls lx ko lj"/></div></div></a></div><p id="fe5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们在<strong class="jm io"> AppComponent </strong>中并行获取了假的<strong class="jm io">相册</strong>和<strong class="jm io">照片</strong>数据。您可以尝试更改Http请求的开始和结束时间，以检查spinner在不同场景中的工作方式。</p><p id="df02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你有兴趣知道我们如何使用同一个spinner来一起跟踪Http请求进度和组件导航，请查看下面的故事。</p><div class="lg lh gp gr li lj"><a href="https://ramya-bala221190.medium.com/showing-a-simple-spinner-when-loading-components-server-data-in-angular-fcc3a1c505ee" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd io gy z fp lo fr fs lp fu fw im bi translated">显示了在Angular中加载组件/服务器数据时的简单微调器</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">旋转器/加载器使用户体验更加流畅，因为他知道视图正在加载，并且有…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">ramya-bala221190.medium.com</p></div></div><div class="ls l"><div class="mk l lu lv lw ls lx ko lj"/></div></div></a></div><h2 id="07d4" class="ml me in bd mm mn mo dn mp mq mr dp ms jv mt mu mv jz mw mx my kd mz na nb nc bi translated">更多内容请访问<a class="ae nd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> PlainEnglish.io </a>。</h2><p id="e8a0" class="pw-post-body-paragraph jk jl in jm b jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated"><em class="nj">报名参加我们的</em> <a class="ae nd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="nj">免费周报</em> </strong> </a> <em class="nj">。关注我们关于</em><a class="ae nd" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="nj">Twitter</em></strong></a>，<a class="ae nd" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="nj">LinkedIn</em></strong></a><strong class="jm io"><em class="nj">，</em></strong><a class="ae nd" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><em class="nj">YouTube</em><strong class="jm io"><em class="nj">，以及</em></strong><em class="nj"/></a><a class="ae nd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="nj">不和</em> </strong> </a>T49】</p><h2 id="9278" class="ml me in bd mm mn mo dn mp mq mr dp ms jv mt mu mv jz mw mx my kd mz na nb nc bi translated">想扩大你的软件创业规模吗？检查<a class="ae nd" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank">电路</a>。</h2></div></div>    
</body>
</html>