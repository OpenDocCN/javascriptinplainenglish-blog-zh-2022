<html>
<head>
<title>An Alternative Approach to JavaScript Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript错误处理的另一种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-alternative-approach-to-js-error-handling-4004c1d7624d?source=collection_archive---------3-----------------------#2022-03-05">https://javascript.plainenglish.io/an-alternative-approach-to-js-error-handling-4004c1d7624d?source=collection_archive---------3-----------------------#2022-03-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="92aa" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">有没有可能在不使用“异常”的情况下实现干净的错误处理？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e0db240f6b97cd5abbf2b8d3f8b3b08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fI7SjizubJjrgmdUA5Sr-Q.jpeg"/></div></div></figure><p id="9fb6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">鲍勃叔叔是对的。处理错误最干净的方法是使用异常。当然，一个<code class="fe lk ll lm ln b">try-catch</code>块要比返回错误方便得多。但是这种便利是有代价的:当您<code class="fe lk ll lm ln b">throw</code>一个异常时，执行在性能方面变得昂贵。在Node.js的某些版本中，情况变得更糟，编译器甚至不会优化<code class="fe lk ll lm ln b">try-catch</code>块。</p><p id="600d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，让我们看看其他选项，并对它们进行改进，直到找到一个可接受的替代方案。</p><h2 id="a2d1" class="lo lp in bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">1.循着<code class="fe lk ll lm ln b">Golang</code>的方式</h2><p id="4fbc" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated"><code class="fe lk ll lm ln b">Go</code>编程语言有一个内置的<code class="fe lk ll lm ln b">error</code>类型，它可以和正常结果一起从函数返回:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="2070" class="lo lp in ln b gy mq mr l ms mt">normalResult, err := myFunc()<br/>if err != nil {<br/>  fmt.Println(err)<br/>}</span></pre><p id="8d75" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用javascript析构特性，我们可以模仿这种行为:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="1b7b" class="lo lp in ln b gy mq mr l ms mt">const {normalResult, error} = myFunc();<br/>if( error != null ) {<br/>  console.error(`Error occured: ${error}`);<br/>}</span></pre><p id="0715" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是等等！将几个返回错误的函数放在一起会导致<code class="fe lk ll lm ln b">if-chain</code>地狱:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="a8cc" class="lo lp in ln b gy mq mr l ms mt">const {normalResult1, error1} = myFunc1();<br/>if( error1 === null ) {<br/>  const {normalResult2, error2} = myFunc2();<br/>  if( error2 === null ) {<br/>    ...<br/>  } else {<br/>    // Handle error2<br/>  }<br/>} else {<br/>  // Handle error1<br/>}</span></pre><p id="393e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">加油！太可怕了！</p><h2 id="c38d" class="lo lp in bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">2.一次迭代循环</h2><p id="7cb0" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">这是过去<code class="fe lk ll lm ln b">C</code>编程的一个技巧，也可以应用于JS:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="e326" class="lo lp in ln b gy mq mr l ms mt">do {<br/>  const {normalResult1, error1} = myFunc1();<br/>  if( error1 ) {<br/>    // Handle error1<br/>    break;<br/>  }<br/>  const {normalResult2, error2} = myFunc2();<br/>  if( error2 ) {<br/>    // Handle error2<br/>    break;<br/>  }<br/>} while(false);</span></pre><p id="e072" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那好多了。</p><p id="d24c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是那些<code class="fe lk ll lm ln b">if</code>是令人生畏的。不是吗？声明几个不同的<code class="fe lk ll lm ln b">error</code>变量也让人不知所措。</p><p id="83a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果有一种方法可以在任何对<code class="fe lk ll lm ln b">myFuncN</code>的调用之后临时退出循环，检查调用方的结果是否有错误，然后在没有检测到错误的情况下返回到下面的语句，那就太好了。</p><p id="13b2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我说的是带有<strong class="kq io">多重</strong> <em class="mu">退出点</em>的特定类型的函数。此外，我希望能够重新进入该功能，但不是从其开始，而是从最后的<em class="mu">退出点</em>开始。</p><p id="311a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你猜到了吗？没错！</p><h2 id="cfde" class="lo lp in bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">3.满足发电机功能</h2><p id="0a8c" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">在JS中，使用关键字<code class="fe lk ll lm ln b">function*</code>定义了一个生成器函数。(注意那个小小的星号！)</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="dc83" class="lo lp in ln b gy mq mr l ms mt">function* myGeneratorFunc(inValue) {<br/>  <br/>  yield inValue;  // The first exit point<br/>  yield inValue + 1; // The second (and last) exit point<br/>}</span></pre><p id="ce8d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们第一次调用生成器函数时，它返回一个<code class="fe lk ll lm ln b">Generator</code>对象:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="61ac" class="lo lp in ln b gy mq mr l ms mt">const generator = myGeneratorFunc(5);</span></pre><p id="6811" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数体还没有执行。为此，我们在<code class="fe lk ll lm ln b">generator</code>对象上调用<code class="fe lk ll lm ln b">next()</code>:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="4651" class="lo lp in ln b gy mq mr l ms mt">console.log(generator.next().value);<br/>// expected output: 5</span></pre><p id="db60" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该语句使函数运行到第一个<code class="fe lk ll lm ln b">yield</code>语句。如果那个<code class="fe lk ll lm ln b">yield</code>包含一个值，我们可以通过<code class="fe lk ll lm ln b">next().value</code>访问它。</p><p id="bfac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果我们再次调用<code class="fe lk ll lm ln b">next()</code>方法呢？</p><p id="edaf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从上一个<code class="fe lk ll lm ln b">yield</code>到下一个<code class="fe lk ll lm ln b">yield</code>恢复功能执行:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="f971" class="lo lp in ln b gy mq mr l ms mt">console.log(generator.next().value);<br/>// expected output: 6</span></pre><p id="837e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可能会注意到这里的模式。我们需要循环调用<code class="fe lk ll lm ln b">next()</code>方法。但是有一种优雅的方式可以做到这一点:<code class="fe lk ll lm ln b">Generator</code>对象符合<code class="fe lk ll lm ln b">Iterator</code>协议，这意味着我们可以这样写:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="84ba" class="lo lp in ln b gy mq mr l ms mt">for( let myValue of myGeneratorFunc(5) ) {<br/>  console.log(myValue);<br/>}</span></pre><p id="7fe4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">酷！</p><h2 id="9d3a" class="lo lp in bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">4.通用错误处理循环</h2><p id="f4af" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">有了所有的工具，我们可以创建一个通用的错误处理循环:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="f015" class="lo lp in ln b gy mq mr l ms mt">async function <strong class="ln io">tryRun</strong>(<br/>{<br/>  <strong class="ln io">try</strong>: inTryGeneratorFunc,<br/>  <strong class="ln io">catch</strong>: inCatchFunc<br/>},<br/><strong class="ln io">inContext</strong><br/>) {<br/>  if( !inTryGeneratorFunc ) {<br/>    throw new Error('The `tryGeneratorFunc` is required!');<br/>  }<br/>  let resultError = null;<br/>  await (async () =&gt; {<br/>    const boundedTryGeneratorFunc =   <br/>           inTryGeneratorFunc.<strong class="ln io">bind</strong>(inContext);<br/>    for await (let {error} of boundedTryGeneratorFunc()) {<br/>      if( error ) {<br/>        resultError = error;<br/>        if( inCatchFunc ) {<br/>          inCatchFunc(error);<br/>        }<br/>        break;<br/>      }<br/>    }<br/>  })();<br/>  return resultError;<br/>}</span></pre><p id="5a86" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在深入研究代码之前，让我们看一个简单的用例。假设我们有两个函数返回一个包含<code class="fe lk ll lm ln b">error</code>字段的对象:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="8fb4" class="lo lp in ln b gy mq mr l ms mt">function successfulFunc() {<br/>  let result = {<br/>    <strong class="ln io">error</strong>: null,  // We should have an 'error' field<br/>    data: 'myData1'<br/>  }<br/>  return result;<br/>}<br/>function failingFunc() {<br/>  let result = {<br/>    <strong class="ln io">error</strong>: 'Something went wrong!',<br/>    data: 'myData2'<br/>  };<br/>  return result;<br/>}</span></pre><p id="9629" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们的<code class="fe lk ll lm ln b">tryRun</code>上场了:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="c9a7" class="lo lp in ln b gy mq mr l ms mt">await <strong class="ln io">tryRun</strong>({<br/>  <strong class="ln io">try</strong>: async <strong class="ln io">function*</strong> () { // Don't forget '*' !<br/>    <br/>    yield successfulFunc();<br/>    yield failingFunc();<br/>  },<br/>  <strong class="ln io">catch</strong>: (inError) =&gt; {<br/>    console.error(inError);<br/>    // Handle those two potential errors<br/>  }<br/>});</span></pre><p id="8c8e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不幸的是，JS还不支持生成器的箭头函数语法。因此，<code class="fe lk ll lm ln b">try</code>生成器函数不能访问父块中的上下文。这就是为什么我在<code class="fe lk ll lm ln b">tryRun</code>函数中包含了一个<code class="fe lk ll lm ln b">inContext</code>参数。这个参数可以通过可爱的<code class="fe lk ll lm ln b">this</code>对象在<code class="fe lk ll lm ln b">try</code>函数中访问。当在类方法中使用<code class="fe lk ll lm ln b">tryRun</code>函数时，这更明智。没有<code class="fe lk ll lm ln b">inContext</code>参数，<code class="fe lk ll lm ln b">try</code>生成器函数不会访问类实例变量或方法！幸运的是，将<code class="fe lk ll lm ln b">this</code>保存为<code class="fe lk ll lm ln b">that</code>让我们得到了保护:</p><pre class="kd ke kf kg gt mm ln mn mo aw mp bi"><span id="95f1" class="lo lp in ln b gy mq mr l ms mt">const <strong class="ln io">that</strong> = this;<br/>await tryRun({<br/>  try: function* () {<br/>    // Here we can access 'this' as the parent object<br/>  },<br/>  catch: (inError) =&gt; {<br/>    console.error( inError);<br/>  },<br/>  <strong class="ln io">that</strong>);</span></pre><p id="1a28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为什么我把函数声明为<code class="fe lk ll lm ln b">async</code>？它是更一般的。毕竟等一个<code class="fe lk ll lm ln b">sync</code>函数不吃亏！</p><p id="20cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我做了一个简单的<a class="ae mv" href="https://github.com/hayoola/try-run-showcase/tree/main" rel="noopener ugc nofollow" target="_blank">库</a>来演示这项技术的用法。看一看，不要忘记检查单元测试。</p><p id="8fb3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">脚注:</p><ol class=""><li id="ead2" class="mw mx in kq b kr ks ku kv kx my lb mz lf na lj nb nc nd ne bi translated">干净的代码:敏捷软件工艺手册，皮尔森，2018年</li></ol><p id="8d77" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mu">更多内容请看</em><a class="ae mv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mu">plain English . io</em></strong></a><em class="mu">。报名参加我们的</em> <a class="ae mv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mu">免费周报</em> </strong> </a> <em class="mu">。关注我们关于</em><a class="ae mv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mu">Twitter</em></strong></a><em class="mu">和</em><a class="ae mv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mu">LinkedIn</em></strong></a><em class="mu">。加入我们的</em> <a class="ae mv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mu">社区不和谐</em> </strong> </a> <em class="mu">。</em></p></div></div>    
</body>
</html>