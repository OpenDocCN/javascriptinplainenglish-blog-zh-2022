<html>
<head>
<title>JavaScript Generator Functions — a Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript生成器函数—完整指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-generator-functions-a-complete-guide-52c2ead5af23?source=collection_archive---------5-----------------------#2022-12-01">https://javascript.plainenglish.io/javascript-generator-functions-a-complete-guide-52c2ead5af23?source=collection_archive---------5-----------------------#2022-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d16a3ae7d5c2a7f9b25af62b18a04492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oq7OgkziWMSmaxJs"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6d9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript生成器是一种特殊类型的函数，它允许您暂停函数的执行，稍后再回来继续执行。</p><p id="546d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以用关键字<code class="fe ky kz la lb b">function</code>后跟一个星号(<code class="fe ky kz la lb b">function*</code>)定义一个生成器函数。目前，箭头函数没有这样的选项来创建生成器函数。</p><p id="991c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成器函数提供了一个名为<code class="fe ky kz la lb b">yield</code>的强大关键字，它暂停函数执行并返回<code class="fe ky kz la lb b">yield</code>表达式值。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="0310" class="lk ll in lb b be lm ln l lo lp">function* generatorFn() {<br/>    console.log('start');<br/>    yield 1;<br/>    console.log('After yield 1');<br/>    yield 2;<br/>    console.log('end');<br/>}</span></pre><p id="e961" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们调用生成器函数时，它不会立即执行。相反，它返回一个包含三个实用方法的<code class="fe ky kz la lb b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">Generator</a></code>对象。</p><ul class=""><li id="8231" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated">下一个()</li><li id="a5e5" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated">return()</li><li id="c8ab" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated">投掷()</li></ul><h1 id="a213" class="me ll in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">next()方法</h1><p id="d085" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated">当我们调用<code class="fe ky kz la lb b">next()</code>方法时，生成器函数一直执行到下一个<code class="fe ky kz la lb b">yield</code>表达式。该方法返回一个对象，该对象包含一个保存生成值的<code class="fe ky kz la lb b">value</code>属性和一个保存布尔值的<code class="fe ky kz la lb b">done</code>属性，该布尔值指示函数是否已完成执行。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="3552" class="lk ll in lb b be lm ln l lo lp">function* generatorFn() {<br/>    console.log('start');<br/>    yield 10;<br/>    console.log('After yield 10');<br/>    console.log('X', yield 20);<br/>    console.log('end');<br/>}<br/><br/>const gen = generatorFn();<br/>console.log(gen.next());<br/>console.log(gen.next());<br/>console.log(gen.next());</span></pre><p id="013c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="1ead" class="lk ll in lb b be lm ln l lo lp">start<br/>{ value: 10, done: false }<br/>After yield 10<br/>{ value: 20, done: false }<br/>X undefined<br/>end<br/>{ value: undefined, done: true }</span></pre><p id="567d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">代码解释:<br/> </strong>第一个<code class="fe ky kz la lb b">next()</code>调用——函数将执行到第一个<code class="fe ky kz la lb b">yield</code>表达式<code class="fe ky kz la lb b">yield 10</code>。因此，将打印“start ”,并且由包含属性<code class="fe ky kz la lb b">value</code>为“10”和属性<code class="fe ky kz la lb b">done</code>为<code class="fe ky kz la lb b">false</code>的<code class="fe ky kz la lb b">yield 10</code>返回一个对象。</p><p id="2f36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二次<code class="fe ky kz la lb b">next()</code>调用–函数将从第二行(无<code class="fe ky kz la lb b">yield</code>表达式)开始执行，直到下一个<code class="fe ky kz la lb b">yield</code>表达式<code class="fe ky kz la lb b">yield 20</code>。记住，当执行在一行上暂停时，它只执行<code class="fe ky kz la lb b">yield</code>表达式，语句的其余部分将在下一个<code class="fe ky kz la lb b">next()</code>调用中执行。因此，在第二个<code class="fe ky kz la lb b">next()</code>调用中，只有<code class="fe ky kz la lb b">yield 20</code>会执行并暂停，rest控制台语句将在下一次迭代中执行。</p><p id="3a13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第三个<code class="fe ky kz la lb b">next()</code>调用–函数将从第四行开始执行，执行控制台语句并用<code class="fe ky kz la lb b">undefined</code>替换<code class="fe ky kz la lb b">yield 20</code>(因为我们在<code class="fe ky kz la lb b">next()</code>中没有传递任何参数)。稍后我们会详细了解)。由于没有更多的<code class="fe ky kz la lb b">yield</code>表达式，执行将继续到最后，并返回包含<code class="fe ky kz la lb b">value</code>的对象作为<code class="fe ky kz la lb b">undefined</code>和包含<code class="fe ky kz la lb b">done</code>的对象作为<code class="fe ky kz la lb b">true</code>。</p><p id="945a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦执行完成，调用<code class="fe ky kz la lb b">next()</code>将总是返回属性<code class="fe ky kz la lb b">value</code>为<code class="fe ky kz la lb b">undefined</code>和<code class="fe ky kz la lb b">done</code>为<code class="fe ky kz la lb b">true</code>的对象。</p><h2 id="c3f6" class="ng ll in bd mf nh ni dn mj nj nk dp mn kl nl nm mr kp nn no mv kt np nq mz nr bi translated">在生成器函数中放置return语句</h2><p id="3de1" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated">如果我们在生成器函数中有一个<code class="fe ky kz la lb b">return</code>语句，那么<code class="fe ky kz la lb b">return</code>语句将完成执行，返回的对象将把<code class="fe ky kz la lb b">value</code>作为返回值，把<code class="fe ky kz la lb b">done</code>作为<code class="fe ky kz la lb b">true</code>。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="b175" class="lk ll in lb b be lm ln l lo lp">function* generator() {<br/>    yield 1;<br/>    return 5;<br/>}<br/><br/>const gen = generator();<br/>console.log(gen.next());<br/>// { value: 1, done: false }<br/>console.log(gen.next());<br/>// { value: 5, done: true }</span></pre><p id="d7e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们将<code class="fe ky kz la lb b">return</code>语句放在任何<code class="fe ky kz la lb b">yield</code>表达式之前，那么<code class="fe ky kz la lb b">return</code>语句将结束执行，而<code class="fe ky kz la lb b">yield</code>表达式将被忽略。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="286c" class="lk ll in lb b be lm ln l lo lp">function* generator() {<br/>    yield 1;<br/>    return 5;<br/>    yield 10;<br/>}<br/><br/>const gen = generator();<br/>console.log(gen.next()); <br/>// { value: 1, done: false }<br/>console.log(gen.next()); <br/>// { value: 5, done: true }<br/>console.log(gen.next()); <br/>// { value: undefined, done: true }</span></pre><h2 id="1793" class="ng ll in bd mf nh ni dn mj nj nk dp mn kl nl nm mr kp nn no mv kt np nq mz nr bi translated">在next()方法中传递值</h2><p id="9e88" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated">我们可以用一个参数调用<code class="fe ky kz la lb b">next()</code>方法，它将用参数值替换最后执行的<code class="fe ky kz la lb b">yield</code>表达式，在那里执行被暂停。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="d862" class="lk ll in lb b be lm ln l lo lp">function* generator() {<br/>    yield 10;<br/>    const third = yield 20;<br/>    yield third;<br/>}<br/><br/>const gen = generator();<br/>console.log(gen.next()); <br/>// { value: 10, done: false }<br/>console.log(gen.next(55)); <br/>// { value: 20, done: false }<br/>console.log(gen.next(99)); <br/>// { value: 99, done: false }<br/>console.log(gen.next()); <br/>// { value: undefined, done: true }</span></pre><p id="f705" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，当第一个<code class="fe ky kz la lb b">next()</code>被调用时，<code class="fe ky kz la lb b">yield 10</code>被执行，执行在那里被暂停。</p><p id="cc9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当调用<code class="fe ky kz la lb b">next(55)</code>时，它用“55”替换最后一个<code class="fe ky kz la lb b">yield</code>表达式，即<code class="fe ky kz la lb b">yield 10</code>(我们在这里不使用这个值，所以我们看不到区别)，然后执行<code class="fe ky kz la lb b">yield 20</code>，执行在那里暂停。</p><p id="8151" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当<code class="fe ky kz la lb b">next(99)</code>被调用时，它将最后一个<code class="fe ky kz la lb b">yield</code>表达式即<code class="fe ky kz la lb b">yield 20</code>替换为“99”，并将值“99”赋给变量“third”。然后<code class="fe ky kz la lb b">yield third</code>执行并返回属性<code class="fe ky kz la lb b">value</code>为“99”的对象，并在那里暂停执行。</p><p id="dc1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，当最后一个<code class="fe ky kz la lb b">next()</code>被调用时，最后一个<code class="fe ky kz la lb b">yield</code>之后的代码被执行，这里最后一个<code class="fe ky kz la lb b">yield</code>之后没有可用的代码，所以它简单地完成执行并返回带有<code class="fe ky kz la lb b">done</code>作为<code class="fe ky kz la lb b">true</code>的对象。</p><h1 id="2471" class="me ll in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">return()方法</h1><p id="0b2d" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated">当我们调用<code class="fe ky kz la lb b">return()</code>方法时，它将在执行暂停的地方完成函数的执行。它将返回一个属性为<code class="fe ky kz la lb b">undefined</code>和<code class="fe ky kz la lb b">done</code>的对象。我们还可以在<code class="fe ky kz la lb b">return()</code>方法中传递一个值，该值将替换返回对象中的<code class="fe ky kz la lb b">value</code>属性。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="53b1" class="lk ll in lb b be lm ln l lo lp">function* generator() {<br/>  console.log("start");<br/>  yield 10;<br/>  console.log("after yield 10");<br/>  yield 20;<br/>  console.log("end");<br/>}<br/><br/>const gen = generator();<br/>console.log(gen.next());<br/>console.log(gen.return(55));<br/>console.log(gen.next());</span></pre><p id="afed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="2e17" class="lk ll in lb b be lm ln l lo lp">start<br/>{ value: 10, done: false }<br/>{ value: 55, done: true }<br/>{ value: undefined, done: true }</span></pre><h1 id="9b08" class="me ll in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">throw()方法</h1><p id="a0be" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated">这个方法基本上在那里停止执行并抛出一个异常。这个方法不会像<code class="fe ky kz la lb b">next()</code>和<code class="fe ky kz la lb b">return()</code>那样返回任何对象。出于调试目的，我们可以将任何错误信息传递给该方法。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="8e72" class="lk ll in lb b be lm ln l lo lp">function* generator() {<br/>  console.log("start");<br/>  yield 10;<br/>  console.log("after yield 10");<br/>  yield 20;<br/>  console.log("end");<br/>}<br/><br/>const gen = generator();<br/>console.log(gen.next());<br/>console.log(gen.throw(new Error('Some error occured')));<br/>console.log(gen.next());</span></pre><p id="e145" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="c52d" class="lk ll in lb b be lm ln l lo lp">start<br/>{ value: 10, done: false }<br/>Uncaught Error: Some error occured</span></pre><h1 id="edef" class="me ll in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">作为迭代器的生成器对象</h1><p id="4588" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated">generator对象是<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol" rel="noopener ugc nofollow" target="_blank"> iterable </a>，所以我们可以很容易地遍历它并使用每个<code class="fe ky kz la lb b">yield</code>表达式返回的值。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="13b6" class="lk ll in lb b be lm ln l lo lp">function* generator() {<br/>  yield 25;<br/>  yield 45;<br/>  yield 65;<br/>}<br/><br/>// using for...of loop<br/>for (let value of generator()) {<br/>  console.log(value);<br/>}<br/>// 25<br/>// 45<br/>// 65<br/><br/>// Array.from()<br/>console.log(Array.from(generator())); <br/>// [25, 45, 65]<br/><br/>// spread operator<br/>console.log([...generator()]); <br/>// [25, 45, 65]</span></pre><h1 id="7534" class="me ll in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">对iterables使用yield*关键字</h1><p id="2163" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated"><code class="fe ky kz la lb b">yield*</code>关键字迭代<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol" rel="noopener ugc nofollow" target="_blank">可迭代</a>操作数，并产生它返回的每个值。该关键字只能用于iterables，否则会引发错误。</p><p id="ee70" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些内置的可迭代对象是数组、映射、字符串、生成器等。</p><h2 id="8c8f" class="ng ll in bd mf nh ni dn mj nj nk dp mn kl nl nm mr kp nn no mv kt np nq mz nr bi translated">字符串和数组示例</h2><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="9486" class="lk ll in lb b be lm ln l lo lp">function* generator() {<br/>  yield 10;<br/>  yield [20, 30];<br/>  yield* [40, 50];<br/>  yield 'html';<br/>  yield* 'js';<br/>}<br/><br/>const gen = generator();<br/><br/>console.log(gen.next().value); // 10<br/>console.log(gen.next().value); // [20, 30]<br/>console.log(gen.next().value); // 40<br/>console.log(gen.next().value); // 50<br/>console.log(gen.next().value); // html<br/>console.log(gen.next().value); // j<br/>console.log(gen.next().value); // s</span></pre><h2 id="9586" class="ng ll in bd mf nh ni dn mj nj nk dp mn kl nl nm mr kp nn no mv kt np nq mz nr bi translated">发电机示例</h2><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="c335" class="lk ll in lb b be lm ln l lo lp">// print a series of numbers like 1223334444...n(n times)<br/><br/>function* repeat(n) {<br/>  let count = 1;<br/>  while (count &lt;= n) {<br/>    yield n;<br/>    count++;<br/>  }<br/>}<br/><br/>function* generateSequence(n) {<br/>  let count = 1;<br/>  while (count &lt;= n) {<br/>    yield* repeat(count);<br/>    count++;<br/>  }<br/>}<br/><br/>const gen = generateSequence(3);<br/>console.log(gen.next().value); // 1<br/>console.log(gen.next().value); // 2<br/>console.log(gen.next().value); // 2<br/>console.log(gen.next().value); // 3<br/>console.log(gen.next().value); // 3<br/>console.log(gen.next().value); // 3<br/>console.log(gen.next().value); // undefined</span></pre><h1 id="7c50" class="me ll in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">生成器函数的多个实例</h1><p id="9c4f" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated">我们可以创建生成器的多个实例，它们不会干扰彼此的执行并独立工作。让我们看一个例子。</p><pre class="lc ld le lf gt lg lb lh bn li lj bi"><span id="b07c" class="lk ll in lb b be lm ln l lo lp">function* generator() {<br/>  yield 10;<br/>  yield 20;<br/>}<br/><br/>const gen1 = generator();<br/>const gen2 = generator();<br/><br/>console.log(gen1.next()); <br/>// { value: 10, done: false }<br/>console.log(gen1.next()); <br/>// { value: 20, done: false }<br/>console.log(gen2.next());<br/>// { value: 10, done: false }<br/>console.log(gen1.next()); <br/>// { value: undefined, done: true }<br/>console.log(gen2.next()); <br/>// { value: 20, done: false }<br/>console.log(gen2.next()); <br/>// { value: undefined, done: true }</span></pre></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h1 id="a9c7" class="me ll in bd mf mg nz mi mj mk oa mm mn mo ob mq mr ms oc mu mv mw od my mz na bi translated">你可能也喜欢</h1><ul class=""><li id="c139" class="lq lr in kc b kd nb kh nc kl oe kp of kt og kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/the-notification-api-in-javascript/" rel="noopener ugc nofollow" target="_blank">使用JavaScript中的通知API发送推送通知</a></li><li id="81f6" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/play-audio-with-htmlaudioelement-api-in-javascript/" rel="noopener ugc nofollow" target="_blank">用JavaScript中的HTMLAudioElement API播放音频</a></li><li id="51fa" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/map-in-javascript-and-how-it-is-better-than-object/" rel="noopener ugc nofollow" target="_blank">JavaScript中的地图，当它是比对象更好的选择时</a></li><li id="ed4b" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/different-ways-to-check-if-a-key-exists-in-an-object/" rel="noopener ugc nofollow" target="_blank">JavaScript中检查对象中是否存在键的不同方法</a></li><li id="788a" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/a-brief-guide-to-promises-in-javascript/" rel="noopener ugc nofollow" target="_blank">JavaScript中承诺的简要指南</a></li><li id="7fa4" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/the-vibration-api-in-javascript/" rel="noopener ugc nofollow" target="_blank">JavaScript中的震动API</a></li><li id="97a2" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/javascript-object-is-method/" rel="noopener ugc nofollow" target="_blank"> JavaScript Object.is()方法检查两个值是否相等</a></li><li id="04b8" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/the-css-is-and-where-pseudo-classes/" rel="noopener ugc nofollow" target="_blank">CSS:is()和:where()伪类</a></li><li id="5c8e" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/javascript-fetch-api-to-make-http-requests/" rel="noopener ugc nofollow" target="_blank"> JavaScript获取API以发出HTTP请求</a></li><li id="bb8f" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated"><a class="ae jz" href="https://jscurious.com/20-javascript-shorthand-techniques-that-will-save-your-time/" rel="noopener ugc nofollow" target="_blank"> 20+ JavaScript速记编码技巧和窍门</a></li></ul></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="3ee6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="oh">感谢您的时间:)</em> <br/> <strong class="kc io"> <em class="oh">阿米塔夫·米什拉</em> </strong></p><p id="1d6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="oh">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="oh">plain English . io</em></strong></a><em class="oh">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="oh">免费周报</em> </strong> </a> <em class="oh">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="oh">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="oh">LinkedIn</em></strong></a><em class="oh"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="oh">YouTube</em></strong></a><em class="oh"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="oh">不和</em> </strong> </a> <em class="oh">。对增长黑客感兴趣？检查</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="oh">电路</em> </strong> </a> <em class="oh">。</em></p></div></div>    
</body>
</html>