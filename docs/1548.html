<html>
<head>
<title>How to Detect a Cycle in a Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测链表中的循环</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/detecting-a-cycle-in-a-linked-list-b862b19bbbc7?source=collection_archive---------16-----------------------#2022-03-31">https://javascript.plainenglish.io/detecting-a-cycle-in-a-linked-list-b862b19bbbc7?source=collection_archive---------16-----------------------#2022-03-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0563" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">弗洛伊德循环寻找算法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4dc8fa9729114c673900f14045e235d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPKbQMNHwJgbUxmbSIcitA.jpeg"/></div></div></figure><p id="6924" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，另一个<a class="ae lk" href="https://leetcode.com/problems/linked-list-cycle/" rel="noopener ugc nofollow" target="_blank"> LeetCode问题</a>。已经太久了，用一个更简单的重新回到这些感觉很好。</p><p id="70e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以，事不宜迟，我要做的是检查一个链表是否包含一个循环(或者，换句话说，是否没有真正的尾部)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ll"><img src="../Images/648f6a5b1db0e8057b3c5aa2f92346cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZXtMX1Sm7Rvx1fL-pj4Ug.jpeg"/></div></div></figure><h2 id="5f5b" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated"><strong class="ak">最初的想法</strong></h2><p id="31c4" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">我马上想到了一个简单的遍历，在这个遍历中，我可能会标记出沿途访问过的节点，然后两件事情中的任何一件都会终止我的努力</p><ol class=""><li id="f522" class="mk ml in kq b kr ks ku kv kx mm lb mn lf mo lj mp mq mr ms bi translated">我会重新遇到以前访问过的节点，或者</li><li id="4729" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated">我将到达node.next === null</li></ol><p id="c17c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然这种方法是实用的，但是让我们将问题进一步发展，使它变得更有趣。</p><p id="2710" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我不能以任何方式改变节点，我还需要一个实现恒定空间复杂度的解决方案。</p><h2 id="5c7c" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated"><strong class="ak">二心</strong></h2><p id="2256" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">现在，简单地对过去访问过的对象进行编目(也许通过对象id)不是一个选项，因为这将表示线性空间。</p><p id="c4ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我不能标记我的踪迹来检查我是否正在重新遍历它，我也不能保存对每个被访问节点的引用的外部集合。</p><h2 id="35cb" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated"><strong class="ak">一个有用的类比</strong></h2><p id="59b5" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">比方说，我们有一个跟踪，我们不知道它是一个循环还是一个死胡同。</p><p id="11bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">场景#1 </strong></p><p id="39ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们让一个跑步者沿着这条跑道跑，我们可以预期两种结果中的一种:</p><ol class=""><li id="3112" class="mk ml in kq b kr ks ku kv kx mm lb mn lf mo lj mp mq mr ms bi translated">要么他们不会返回，因为轨道有一个死胡同，然后我们会<em class="my">知道</em>这不是一个循环。所以在这种情况下，单独的跑步者会告诉我们所有我们需要知道的。</li><li id="50c0" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated"><em class="my">或… </em>跑步者在循环中，遍历永不结束。跑步者永远不会给出跑道确实是一个环的真实指示。</li></ol><p id="1343" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">场景#2 </strong></p><p id="64c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">考虑到这个问题，现在我们给<em class="my">两名</em>跑步者，我们确保其中一名跑得比另一名快。潜在的结果是什么？</p><ol class=""><li id="4c64" class="mk ml in kq b kr ks ku kv kx mm lb mn lf mo lj mp mq mr ms bi translated">这条赛道是一个死胡同，跑得快的人最先到达那里，我们有了答案——这条赛道不是一个环。</li><li id="6ced" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated">跑得快的人会跑得慢的人一圈。除非轨道是一个环，否则这不可能发生。所以我们也有了明确的答案——赛道<em class="my">是</em>的一个环。</li></ol><p id="f781" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们把它编码出来。</p><p id="6a99" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我们将为空输入设置我们的边界情况，然后我们将在他们的起点创建我们的两个跑步者，慢的和快的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a916" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们将使用while循环让它们上路…</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d8d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，从第10行开始描述它:</p><ul class=""><li id="e7e1" class="mk ml in kq b kr ks ku kv kx mm lb mn lf mo lj nb mq mr ms bi translated">只要慢速和快速不在同一个节点上，就检查快速是否到达了尾节点。如果有，返回false(这不是一个循环)</li><li id="b57a" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj nb mq mr ms bi translated">如果fast还没有到达尾节点，则slow走一步，fast走两步。</li></ul><p id="9a1a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以最终，跑得快的人要么到达尾节点，要么跑得慢的人，我会得到我的答案。</p><p id="d33f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这被称为弗洛伊德的周期寻找算法，它很容易成为我的最爱。它对交错计时的简单使用非常强大，概念化起来也很有趣。</p><p id="ec15" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="my">更多内容请看</em><a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="my">免费周报</em> </strong> </a> <em class="my">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="my">Twitter</em></strong></a><em class="my">和</em><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="my">LinkedIn</em></strong></a><em class="my">。加入我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="my">社区不和谐</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>