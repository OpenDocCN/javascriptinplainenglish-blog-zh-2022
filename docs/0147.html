<html>
<head>
<title>3 Weird JavaScript Class Tricks That Could Be Useful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个奇怪的有用的JavaScript类技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-weird-javascript-class-tricks-that-could-be-useful-c5a78144d574?source=collection_archive---------6-----------------------#2022-01-10">https://javascript.plainenglish.io/3-weird-javascript-class-tricks-that-could-be-useful-c5a78144d574?source=collection_archive---------6-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c268adc9f675cba7392efdf0f0216b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JjpC-ghVl0vIDfqC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Fewings</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0bf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我喜欢尝试各种东西，JavaScript有很多奇怪和隐藏的宝石，学习起来总是很有趣。有些只是API中的漏洞，有些则是有意或愉快的意外。无论哪种方式，只要有正确的问题和正确的需求，这些都是非常有用的。</p><h2 id="66f4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">1 —从构造函数返回对象(单例)</h2><p id="4374" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对于一个构造函数来说，返回它所属的类的实例之外的东西是非常奇怪的。在JavaScript中，这是可以做到的。</p><p id="bc7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以一个简单的汽车类为例。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5611" class="lb lc iq me b gy mi mj l mk ml">class <strong class="me ir">Car</strong> {<br/>  make = '';<br/>  model = '';<br/>  doorsCount = 4;<br/>  wheelsCount = 4;<br/>  <br/>  <strong class="me ir">constructor(make, model) {<br/>    this.make = make;<br/>    this.model = model;<br/>  }</strong><br/>}</span></pre><p id="ecb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，<code class="fe mm mn mo me b">new Car(...)</code>将返回一个类的实例对象，我们可以用它来访问该类的属性和方法。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6f33" class="lb lc iq me b gy mi mj l mk ml">const jeepWrangler = new <strong class="me ir">Car</strong>('jeep', 'wrangler');</span><span id="7cbb" class="lb lc iq me b gy mp mj l mk ml">jeepWrangler.doorsCount = 2;<br/>jeepWrangler.model; <em class="mq">// wrangler</em></span></pre><p id="66a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们实际上可以从构造函数返回一些东西，例如，一个不同的对象。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="040c" class="lb lc iq me b gy mi mj l mk ml">class <strong class="me ir">Car</strong> {<br/>  make = '';<br/>  model = '';<br/>  doorsCount = 4;<br/>  wheelsCount = 4;<br/>  <br/>  <strong class="me ir">constructor</strong>(make, model) {<br/>    this.make = make;<br/>    this.model = model;<br/>    <br/>    <strong class="me ir">return {<br/>      different: true<br/>    }</strong><br/>  }<br/>}</span></pre><p id="b8aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这仅仅意味着当我们实例化类时，我们得到了返回的对象。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="38e1" class="lb lc iq me b gy mi mj l mk ml">const jeepWrangler = new <strong class="me ir">Car</strong>('jeep', 'wrangler');</span><span id="d02f" class="lb lc iq me b gy mp mj l mk ml">jeepWrangler.model; // undefined<br/>jeepWrangler.<strong class="me ir">different</strong>; // true</span></pre><p id="83af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这只有在你返回一个对象时才有效果。如果你返回一个原语，这个类正常工作。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b9c8" class="lb lc iq me b gy mi mj l mk ml">class <strong class="me ir">Car</strong> {<br/>  make = '';<br/>  model = '';<br/>  doorsCount = 4;<br/>  wheelsCount = 4;<br/>  <br/>  <strong class="me ir">constructor</strong>(make, model) {<br/>    this.make = make;<br/>    this.model = model;<br/>    <br/>    <strong class="me ir">return 12</strong><br/>  }<br/>}</span><span id="7542" class="lb lc iq me b gy mp mj l mk ml">const jeepWrangler = new Car('jeep', 'wrangler');</span><span id="e0fd" class="lb lc iq me b gy mp mj l mk ml">jeepWrangler.<strong class="me ir">model</strong>; <em class="mq">// wrangler</em></span></pre><p id="81bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，你能利用这种古怪做什么呢？</p><p id="fa53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，你可以创建<a class="ae kc" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例</a>:一个类，不管你实例化多少次，你总是得到相同的实例。angular<a class="ae kc" href="https://angular.io/guide/architecture-services#providing-services" rel="noopener ugc nofollow" target="_blank">root-provided service</a>是可以用单例模式完成的一个例子。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7fa9" class="lb lc iq me b gy mi mj l mk ml">const <strong class="me ir">LocalStore</strong> = (() =&gt; {<br/>  const data = new Map();<br/>  let <strong class="me ir">instance</strong> = null;<br/> <br/>  return class LocalStore {<br/>    <strong class="me ir">constructor</strong>() {<br/>      <strong class="me ir">if(instance === null) {<br/>        instance = this;<br/>      }</strong></span><span id="42cb" class="lb lc iq me b gy mp mj l mk ml">      <strong class="me ir">return instance;</strong><br/>    }<br/>  }<br/>})();</span><span id="2735" class="lb lc iq me b gy mp mj l mk ml">const store1 = new <strong class="me ir">LocalStore</strong>();<br/>const store2 = new <strong class="me ir">LocalStore</strong>();</span><span id="0c84" class="lb lc iq me b gy mp mj l mk ml">store1 === store2 // true</span></pre><p id="b45d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单例适用于日志、分析、数据库、存储的全局类，也是创建全局变量的替代方法。</p><p id="319f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以用这个技巧来控制类返回的内容。</p><blockquote class="mr ms mt"><p id="5a5a" class="kd ke mq kf b kg kh ki kj kk kl km kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated"><a class="ae kc" href="https://codepen.io/beforesemicolon/pen/bGoxxEM" rel="noopener ugc nofollow" target="_blank">探究本例的<strong class="kf ir">代码</strong> </a></p></blockquote><h2 id="622c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">2-防止类实例化(抽象类)</h2><p id="ba87" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">JavaScript本身不支持<a class="ae kc" href="https://en.wikipedia.org/wiki/Abstract_type" rel="noopener ugc nofollow" target="_blank">抽象类</a>的概念，抽象类是一个只能扩展不能实例化的类。然而，有一种不包括装饰者的简单方法可以实现这一点。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5527" class="lb lc iq me b gy mi mj l mk ml">class <strong class="me ir">Car</strong> {<br/>  make = '';<br/>  model = '';<br/>  doorsCount = 4;<br/>  wheelsCount = 4;<br/>  <br/>  constructor(make, model) {<br/>    this.make = make;<br/>    this.model = model;<br/>  }<br/>}</span><span id="b103" class="lb lc iq me b gy mp mj l mk ml">class <strong class="me ir">BMW</strong> extends <strong class="me ir">Car</strong> { <em class="mq">&lt;- extending Car</em><br/>  constructor(model) {<br/>    super('bmw', model);<br/>    this.model = model;<br/>  }<br/>}</span><span id="5aca" class="lb lc iq me b gy mp mj l mk ml">const bmwM3 = new <strong class="me ir">Car</strong>('bmw', 'm3'); &lt;- instantiate Car</span></pre><p id="4ee4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以利用这样一个事实，即我们可以从类构造函数内部访问类构造函数名称。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="cc9b" class="lb lc iq me b gy mi mj l mk ml">class <strong class="me ir">Car</strong> {<br/>  make = '';<br/>  model = '';<br/>  doorsCount = 4;<br/>  wheelsCount = 4;<br/>  <br/>  <strong class="me ir">constructor</strong>(make, model) {<br/>    this.make = make;<br/>    this.model = model;<br/>    <br/>    <strong class="me ir">console.log(this.constructor.name)</strong><br/>  }<br/>}</span><span id="2d9b" class="lb lc iq me b gy mp mj l mk ml">const bmwM3 = new <strong class="me ir">Car</strong>('bmw', 'm3');</span></pre><p id="65fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数的名字总是你用来实例化的类，这意味着我们可以用它来了解一个类是被扩展了还是被实例化了。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3e8e" class="lb lc iq me b gy mi mj l mk ml">class <strong class="me ir">Car</strong> {<br/>  make = '';<br/>  model = '';<br/>  doorsCount = 4;<br/>  wheelsCount = 4;<br/>  <br/>  <strong class="me ir">constructor</strong>(make, model) {<br/>    this.make = make;<br/>    this.model = model;<br/>    <br/>    <strong class="me ir">if(this.constructor.name === 'Car') {<br/>      throw new Error(<br/>        'Car class is abstract. It can only be extended'<br/>      )<br/>    }</strong><br/>  }<br/>}</span><span id="91b0" class="lb lc iq me b gy mp mj l mk ml">class BMW <strong class="me ir">extends Car</strong> {<br/>  constructor(model) {<br/>    super('bmw', model);<br/>    this.model = model;<br/>  }<br/>}</span><span id="ae18" class="lb lc iq me b gy mp mj l mk ml">const bmwM1 = <strong class="me ir">new BMW</strong>('m1'); <em class="mq">// works!!</em><br/>const bmwM3 = <strong class="me ir">new Car</strong>('bmw', 'm3'); <em class="mq">// Throws</em></span></pre><p id="5341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果构造函数名与检查它的类相匹配，那么该类将被直接实例化。否则，它将被扩展它的类实例化。</p><p id="05ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像那样，你可以创建只能被扩展的类，这对于创建基类来说是完美的。</p><blockquote class="mr ms mt"><p id="0f1b" class="kd ke mq kf b kg kh ki kj kk kl km kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated"><a class="ae kc" href="https://codepen.io/beforesemicolon/pen/rNGZZxX" rel="noopener ugc nofollow" target="_blank">探究本例的<strong class="kf ir">代码</strong> </a></p></blockquote><h2 id="2538" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">2 —运行时的多个类扩展(混合)</h2><p id="0e50" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在OOP中，你可以让一个类扩展另一个类，而且你必须在代码执行之前这么做。我在代码中为一些非常具体的问题探索的一件事是在运行时扩展类的想法。</p><p id="821f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了向你解释我的意思，我想让你想象你正在玩一个游戏，你有一个<code class="fe mm mn mo me b">Person</code>类来代表你的角色。让我们用这样简单的东西。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="dad1" class="lb lc iq me b gy mi mj l mk ml">class <strong class="me ir">Person</strong> {<br/>  #name;<br/>  #dob;<br/>  <br/>  constructor(name, dob) {<br/>    this.#name = name;<br/>    this.#dob = new Date(dob)<br/>  }<br/>  <br/>  get <strong class="me ir">name</strong>() {<br/>    return this.#name;<br/>  }<br/>  <br/>  get <strong class="me ir">age</strong>() {<br/>    return (new Date().getFullYear() - this.#dob.getFullYear())<br/>  }<br/>}</span><span id="dbb5" class="lb lc iq me b gy mp mj l mk ml">const johnDoe = new <strong class="me ir">Person</strong>('John Doe', '09/12/1990');</span><span id="96a1" class="lb lc iq me b gy mp mj l mk ml">johnDoe.<strong class="me ir">age</strong>; <em class="mq">// 32</em><br/>johnDoe.<strong class="me ir">name</strong>; <em class="mq">// 'John Doe'</em></span></pre><p id="f308" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设在整个游戏中，这个人被AWS聘为软件工程师。我们可以使用构造函数来创建一个新的能力。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="16fb" class="lb lc iq me b gy mi mj l mk ml">function <strong class="me ir">Employee</strong>(company, startingDate, title) {<br/>  this.<strong class="me ir">occupation</strong> = {<br/>    company,<br/>    startingDate: new Date(startingDate),<br/>    title,<br/>  }<br/>  this.<strong class="me ir">quit</strong> = () =&gt; {<br/>    delete this.occupation;<br/>    delete this.quit;<br/>  }<br/>}</span></pre><p id="abba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了给我们的用户这种能力，我们可以在运行时像这样扩展它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3a4a" class="lb lc iq me b gy mi mj l mk ml"><strong class="me ir">Employee</strong>.call(<strong class="me ir">johnDoe</strong>, 'AWS', '02/05/2020', 'software engineer');</span></pre><p id="0386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个，我们现在可以访问<code class="fe mm mn mo me b">occupation</code>财产，也可以<code class="fe mm mn mo me b">quit</code>工作。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c202" class="lb lc iq me b gy mi mj l mk ml">johnDoe.<strong class="me ir">occupation;</strong><br/><em class="mq">// {</em><strong class="me ir"><em class="mq">company</em></strong><em class="mq">: 'AWS', </em><strong class="me ir"><em class="mq">startingDate</em></strong><em class="mq">: Wed Feb 05 2020 00:00:00 GMT-0500 (Eastern Standard Time), </em><strong class="me ir"><em class="mq">title</em></strong><em class="mq">: 'software engineer'}</em></span><span id="7266" class="lb lc iq me b gy mp mj l mk ml">johnDoe<strong class="me ir">.quit();</strong></span><span id="03c9" class="lb lc iq me b gy mp mj l mk ml">johnDoe<strong class="me ir">.occupation;</strong> <em class="mq">// undefined</em><br/>johnDoe<strong class="me ir">.quit;</strong> <em class="mq">// undefined</em></span></pre><p id="bbc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这只是解决这类问题的一种方法，我们也可以尝试插件模式。我想说明的是用多个东西扩展一个类的能力。</p><p id="38bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也是实现mixins的一种方式，从一个基类开始，在运行时或之前继续扩展它。</p><p id="b412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中引入类之前，这实际上是我们用来扩展类的方式。这个类只是构造函数和原型工作的语法糖。下面也是可以的。类可以扩展构造函数。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="44e0" class="lb lc iq me b gy mi mj l mk ml">class <strong class="me ir">Person</strong> extends <strong class="me ir">Employee</strong> {<br/>  #name;<br/>  #dob;<br/>  <br/>  constructor(name, dob, <strong class="me ir">company, startingDate, title</strong>) {<br/>    <strong class="me ir">super(company, startingDate, title);</strong><br/>    this.#name = name;<br/>    this.#dob = new Date(dob)<br/>  }<br/>  <br/>  get name() {<br/>    return this.#name;<br/>  }<br/>  <br/>  get age() {<br/>    return (new Date().getFullYear() - this.#dob.getFullYear())<br/>  }<br/> <br/>}</span></pre><p id="62fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面是同样的事情，但是它必须在代码运行之前设置，并且需要<code class="fe mm mn mo me b">Person</code>类接受更多的参数。mixin方式允许您将代码分割成更小的构造函数，这些函数处理包括私有数据在内的所有逻辑。这允许您在代码运行时增加您的类实例。</p><blockquote class="mr ms mt"><p id="883d" class="kd ke mq kf b kg kh ki kj kk kl km kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated"><a class="ae kc" href="https://codepen.io/beforesemicolon/pen/KKXxWPr" rel="noopener ugc nofollow" target="_blank">探究本例的<strong class="kf ir">代码</strong> </a></p></blockquote><h2 id="3955" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="9881" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">探索JavaScript非常有趣，这意味着取决于你如何改变，你最终会发现一两个有用的技巧。</p><p id="8741" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我曾经认为利用这些东西不好，但是当我进入元编程的世界时，寻找漏洞成为了一种习惯。</p><p id="aaab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我把这些技巧留给你，希望它们有一天会对你有用。</p><div class="mx my gp gr mz na"><a href="https://medium.com/before-semicolon/10-things-to-master-about-javascript-before-you-call-yourself-a-pro-2a5fe237e6ac" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">在你称自己为专家之前，关于Javascript要掌握的10件事</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">多年来，Javascript发生了很大的变化，已经成为最流行的语言之一。它是我的，而且…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no jw na"/></div></div></a></div><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/79122679204c8ac0aa65ca22857737ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kKfpitAbaRbqRAXx0-YqTw.gif"/></div></div></figure><p id="5c90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="mq"> YouTube频道</em> </strong> <em class="mq"> : </em> <a class="ae kc" href="https://www.youtube.com/channel/UCrU33aw1k9BqTIq2yKXrmBw" rel="noopener ugc nofollow" target="_blank"> <em class="mq">前分号</em></a><em class="mq"><br/></em><strong class="kf ir"><em class="mq">网站</em></strong><em class="mq">:</em><a class="ae kc" href="https://beforesemicolon.com/" rel="noopener ugc nofollow" target="_blank"><em class="mq">beforesemicolon.com</em></a></p></div></div>    
</body>
</html>