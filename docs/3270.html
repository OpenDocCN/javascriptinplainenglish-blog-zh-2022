<html>
<head>
<title>TypeScript: Typing React useRef hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:键入React useRef钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-typing-react-useref-hook-37786eff09dc?source=collection_archive---------3-----------------------#2022-08-14">https://javascript.plainenglish.io/typescript-typing-react-useref-hook-37786eff09dc?source=collection_archive---------3-----------------------#2022-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/23670649b92d42b41c5118c0403edf3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Iz9WvcIlnXk3BEDm.jpg"/></div></div></figure><p id="d75d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些情况下，我们需要在通常的组件流之外强制性地修改React组件中的DOM元素。最常见的例子是在React应用程序中管理元素的焦点或使用第三方库(尤其是那些不是用React编写的库)。</p><p id="e720" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将通过一个控制输入元素焦点状态的例子来演示如何在TypeScript中键入<code class="fe kw kx ky kz b">useRef</code>钩子。</p><p id="5eca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个简单的用例，我们希望手动将输入集中在按钮点击上。组件的JS代码如下所示:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="1787" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们点击<code class="fe kw kx ky kz b">Focus input</code>按钮的时候，<code class="fe kw kx ky kz b">name</code>输入域就会被聚焦，到目前为止一切顺利。现在我们想为这个组件使用TypeScript。作为第一步，我们可以简单地将文件的扩展名从<code class="fe kw kx ky kz b">.js</code>改为<code class="fe kw kx ky kz b">.tsx</code>。我们将文件转换成TS后得到的错误是第<code class="fe kw kx ky kz b">inputRef.current.focus();</code>行的<code class="fe kw kx ky kz b">Object is possibly null</code>。这是有意义的，因为我们确实将<code class="fe kw kx ky kz b">null</code>设置为<code class="fe kw kx ky kz b">inputRef</code>的初始值。要修复这个错误，我们可以在对其调用<code class="fe kw kx ky kz b">focus</code>之前检查<code class="fe kw kx ky kz b">inputRef</code>的<code class="fe kw kx ky kz b">current</code>属性是否不为空:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="4632" class="lk ll iq kz b gy lm ln l lo lp">if (inputRef.current !== null) { <br/>    inputRef.current.focus(); <br/>}</span></pre><p id="9dd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以用<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接操作符</a> <code class="fe kw kx ky kz b">?.</code>简化:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="69ba" class="lk ll iq kz b gy lm ln l lo lp">inputRef.current?.focus();</span></pre><p id="d54c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<code class="fe kw kx ky kz b">inputRef.current</code>为nullish ( <code class="fe kw kx ky kz b">null</code>或<code class="fe kw kx ky kz b">undefined</code>)，则不调用表达式short-circuits和<code class="fe kw kx ky kz b">focus</code>方法(如果我们将调用的结果赋给一个变量，那么在这种情况下它将被设置为<code class="fe kw kx ky kz b">undefined</code>)。</p><p id="2bbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这修复了类型错误，但是，它创建了一个新的错误- <code class="fe kw kx ky kz b">Property 'focus' does not exist on type 'never'.</code>这起初看起来很奇怪，因为我们稍后会将ref分配给input元素。问题是TS从缺省值推断出<code class="fe kw kx ky kz b">inputRef</code>不能是除了<code class="fe kw kx ky kz b">null</code>之外的任何值，并将相应地键入它。但是我们知道ref稍后将包含一个input元素，所以要解决这个问题，我们需要明确地告诉编译器需要哪种类型的元素:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="2aab" class="lk ll iq kz b gy lm ln l lo lp">const inputRef = useRef&lt;HTMLInputElement&gt;(null);</span></pre><p id="6b22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这解决了问题，我们没有得到任何类型错误。最终代码如下所示:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><h1 id="3d5a" class="lr ll iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">useRef <htmlinputelement>(空)vs useRef <htmlinputelement null="">(空)</htmlinputelement></htmlinputelement></h1><p id="33e2" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">对于我们不需要重新分配其值的情况，<code class="fe kw kx ky kz b">inputRef</code>的当前类型工作得很好。让我们考虑这样一种情况，我们想要手动添加一个事件监听器到一个输入中(在使用第三方库时很有用)。代码看起来会像这样:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="76fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们需要将<code class="fe kw kx ky kz b">document.getElementById</code>的结果转换为<code class="fe kw kx ky kz b">HTMLInputElement</code>，因为TS在这种情况下无法推断出正确的元素类型，而是默认为更通用的<code class="fe kw kx ky kz b">HTMLElement</code>。但是我们知道这个例子中的元素是一个输入元素，所以对它进行相应的转换是安全的。虽然代码看起来不错，但是我们得到了一个TS错误- <code class="fe kw kx ky kz b">Cannot assign to 'current' because it is a read-only property.</code>。在检查<code class="fe kw kx ky kz b">current</code>属性时，我们看到它的类型被定义为<code class="fe kw kx ky kz b">React.RefObject&lt;HTMLInputElement&gt;.current:any</code>。深入到<code class="fe kw kx ky kz b">React.RefObject</code>的类型定义，它被定义为:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="6898" class="lk ll iq kz b gy lm ln l lo lp">interface RefObject&lt;T&gt; { readonly current: T | null; }</span></pre><p id="a5fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么如何才能让它变得可变呢？按照<code class="fe kw kx ky kz b">useRef</code>的类型定义，我们看到它实际上有一些重载，其中最重要的是:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="721f" class="lk ll iq kz b gy lm ln l lo lp">function useRef&lt;T&gt;(initialValue: T): MutableRefObject&lt;T&gt;; <br/>function useRef&lt;T&gt;(initialValue: T | null): RefObject&lt;T&gt;;</span></pre><p id="d710" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当将<code class="fe kw kx ky kz b">null</code>指定为默认参数，但不将其包含在type param中时，我们为<code class="fe kw kx ky kz b">useRef</code>匹配第二个重载，获得一个具有readonly <code class="fe kw kx ky kz b">current</code>属性的ref对象。要修复它，我们需要在类型参数中包含<code class="fe kw kx ky kz b">null</code>:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="177e" class="lk ll iq kz b gy lm ln l lo lp">const inputRef = useRef&lt;HTMLInputElement | null&gt;(null);</span></pre><p id="f649" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将匹配<code class="fe kw kx ky kz b">MutableRefObject</code>重载并修复类型问题。在钩子的类型定义中还有一个方便的注意事项:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="f774" class="lk ll iq kz b gy lm ln l lo lp">Usage note: if you need the result of useRef to be directly mutable, include | null in the type of the generic argument.</span></pre><p id="3644" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码的最终版本如下:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="424b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na">原载于</em><a class="ae lq" href="https://claritydev.net/blog/typescript-typing-react-useref-hook/" rel="noopener ugc nofollow" target="_blank"><em class="na">https://claritydev.net</em></a><em class="na">。</em></p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="35b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na">更多内容请看</em><a class="ae lq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="na">plain English . io</em></strong></a><em class="na">。报名参加我们的</em> <a class="ae lq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="na">免费周报</em> </strong> </a> <em class="na">。关注我们关于</em> <a class="ae lq" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="na">推特</em></strong></a><a class="ae lq" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="na">领英</em></strong></a><strong class="ka ir"><em class="na"/></strong><em class="na">和</em> <a class="ae lq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="na">不和</em> </strong> </a> <strong class="ka ir"> <em class="na">。</em>T45】</strong></p></div></div>    
</body>
</html>