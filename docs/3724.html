<html>
<head>
<title>Difference Between TypeScript Interfaces and Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript接口和类型之间的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-difference-between-typescript-interfaces-and-types-d93c8d023b37?source=collection_archive---------9-----------------------#2022-09-20">https://javascript.plainenglish.io/the-difference-between-typescript-interfaces-and-types-d93c8d023b37?source=collection_archive---------9-----------------------#2022-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="509d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">TypeScript有两种方法可以创建新的自定义类型—接口和类型。我们来看看两者的区别。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/68a01ed641df6b111cd658f843ac3011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tf8sBc1_r26veeAUG4ftbw.png"/></div></div></figure><p id="93de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在TypeScript中，您可能已经注意到可以用两种不同的方式声明自定义类型。一个是用<code class="fe ln lo lp lq b">interface</code>关键字，另一个是用<code class="fe ln lo lp lq b">type</code>关键字。因此，你可能会发现自己想知道为什么做一件事有两种方法——而且你并不孤单。我已经在我的指南<a class="ae lr" href="https://fjolt.com/article/typescript-creating-custom-types" rel="noopener ugc nofollow" target="_blank">中介绍了如何在TypeScript </a>中声明自定义类型，如何使用接口和类型——但是让我们更深入地了解一下它们之间的区别。</p><h1 id="ab10" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.接口扩展语法因类型而异</h1><p id="813d" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">如果我们在TypeScript中定义了一个类型，它在事实之后是不可扩展的。例如，考虑我刚刚创建的这个自定义类型:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="c3d1" class="mt lt iq lq b gy mu mv l mw mx">type user = {<br/>    name: string,<br/>    age: number<br/>}</span></pre><p id="e722" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果在定义了地址之后，我突然意识到我也想添加一个地址，我可以使用下面的语法:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="df2c" class="mt lt iq lq b gy mu mv l mw mx">type userWithAddress = user &amp; {<br/>    address: string<br/>}</span></pre><p id="ba52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用接口，我们可以做同样的事情，但是语法略有不同:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="4b45" class="mt lt iq lq b gy mu mv l mw mx">interface user {<br/>    name: string;<br/>    age: number;<br/>}<br/>interface userWithAddress extends user {<br/>    address: string<br/>}</span></pre><p id="bdbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在<code class="fe ln lo lp lq b">userWithAddress</code>包含了<code class="fe ln lo lp lq b">user</code>的所有属性，外加一个额外的属性——那就是<code class="fe ln lo lp lq b">address</code>。</p><p id="8781" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这两种扩展类型的方式之间唯一的区别是它们处理冲突的方式。例如，如果您扩展一个接口并提到一个已经定义的属性，将会引发一个错误。例如，<strong class="kt ir">这个不行</strong>:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="f43c" class="mt lt iq lq b gy mu mv l mw mx">interface user {<br/>    name: string;<br/>}<br/>interface newUser extends user {<br/>    name: number;<br/>}</span></pre><p id="9ade" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同时，使用<code class="fe ln lo lp lq b">type</code>，您可以这样做:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="a650" class="mt lt iq lq b gy mu mv l mw mx">type user = {<br/>    name: string<br/>}</span><span id="b44f" class="mt lt iq lq b gy my mv l mw mx">type newUser = user &amp; {<br/>    name: number<br/>}</span></pre><p id="36ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这不会引发错误，但可能会导致一些意想不到的结果——因此在必要时应该避免。例如，上面的<code class="fe ln lo lp lq b">name</code>属性被简化为类型<code class="fe ln lo lp lq b">never</code>——因为一个类型<code class="fe ln lo lp lq b">never</code>可以同时是<code class="fe ln lo lp lq b">string</code>和<code class="fe ln lo lp lq b">number</code>。:)</p><h1 id="6013" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.接口可以合并，类型不能</h1><p id="0e77" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">同样，<code class="fe ln lo lp lq b">types</code>不能被合并，而<code class="fe ln lo lp lq b">interfaces</code>可以，如果你多次声明它们。例如，如果我们有一个类型，我们不能这样做:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="c3cc" class="mt lt iq lq b gy mu mv l mw mx">type cat = {<br/>    name: string<br/>}<br/>type cat = {<br/>    color: string<br/>}</span></pre><p id="33fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实际上，<strong class="kt ir">上面的代码会抛出一个错误</strong>。同时，使用<code class="fe ln lo lp lq b">interface</code>，我们可以做到这一点——它将合并两个声明。所以下面的例子将创建一个名为<code class="fe ln lo lp lq b">cat</code>的类型，它同时具有<code class="fe ln lo lp lq b">name</code>和<code class="fe ln lo lp lq b">color</code>属性:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="ac22" class="mt lt iq lq b gy mu mv l mw mx">interface cat {<br/>    name: string;<br/>}<br/>interface cat {<br/>    color: string;<br/>}</span></pre><h1 id="0c5f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.接口不能扩展原语</h1><p id="5d7f" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">虽然我们可以创建一个类型，作为像<code class="fe ln lo lp lq b">string</code>，<code class="fe ln lo lp lq b">interface</code>这样的原始类型的别名，但是我们不能这样做。例如，如果你想创建一个名为<code class="fe ln lo lp lq b">myName</code>的类型，它总是字符串类型，我们可以这样做:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="6d5f" class="mt lt iq lq b gy mu mv l mw mx">type myName = string;</span></pre><p id="2568" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，<code class="fe ln lo lp lq b">myName</code>成为了<code class="fe ln lo lp lq b">string</code>的别名——所以我们可以在任何地方写<code class="fe ln lo lp lq b">myName</code>而不是<code class="fe ln lo lp lq b">string</code>。而<code class="fe ln lo lp lq b">interface</code>则没有这个能力。以下内容不能也不会起作用:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="a0e2" class="mt lt iq lq b gy mu mv l mw mx">interface myName extends string {</span><span id="70ed" class="mt lt iq lq b gy my mv l mw mx">}</span></pre><h1 id="7a27" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.类型可以创建联合，而接口不能</h1><p id="2e90" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们可以用关键字<code class="fe ln lo lp lq b">type</code>创建联合类型，但是不能用接口来实现。例如，在这里，<code class="fe ln lo lp lq b">userId</code>可以是<code class="fe ln lo lp lq b">string</code>或<code class="fe ln lo lp lq b">number</code>:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="0c7a" class="mt lt iq lq b gy mu mv l mw mx">type userId = string | number</span></pre><p id="cf87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同时，上述不能用<code class="fe ln lo lp lq b">interface</code>实现，因为接口定义了对象的形状或类型。</p><h1 id="ac73" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.类可以实现接口，但不能实现类型</h1><p id="fd5c" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">如果在TypeScript代码中使用类，它们可以实现接口，但不能实现类型。这意味着类必须符合接口本身。如果你定义了一个<code class="fe ln lo lp lq b">type</code>，你不能在一个类中使用它。例如:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="82e4" class="mt lt iq lq b gy mu mv l mw mx">interface user {<br/>    name: string;<br/>    age: number;<br/>}</span><span id="8953" class="mt lt iq lq b gy my mv l mw mx">class createUser implements user {<br/>  name = "John";<br/>  age = 143;<br/>}</span></pre><p id="10d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您决定在您的类型脚本代码中使用类，这使得<code class="fe ln lo lp lq b">interface</code>非常方便——但是正如我们所知，许多类型脚本代码倾向于函数式的，而不是基于代码的。所以这个好处将取决于你的代码库。</p><h1 id="b77f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="4a04" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">如你所见，<code class="fe ln lo lp lq b">type</code>和<code class="fe ln lo lp lq b">interface</code>的主要区别取决于你使用它们的环境。几乎<code class="fe ln lo lp lq b">interface</code>的所有特性在<code class="fe ln lo lp lq b">type</code>中都可以得到，这意味着你可能会发现自己更频繁地去<code class="fe ln lo lp lq b">type</code>。不过，一般来说，它倾向于基于你的偏好或者在你的代码库中什么工作得最好(例如，使用<code class="fe ln lo lp lq b">interface</code>的额外的<code class="fe ln lo lp lq b">implement</code>特性)。</p><p id="f17f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无论如何，请放心，这并不像你最初想的那样令人困惑——因为<code class="fe ln lo lp lq b">interface</code>和<code class="fe ln lo lp lq b">type</code>实际上是做同一件事的两种方式！</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="f29c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ng">更多内容请看</em><a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">plain English . io</em></strong></a><em class="ng">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们关于</em><a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">Twitter</em></strong></a><a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">LinkedIn</em></strong></a><em class="ng"/><a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">YouTube</em></strong></a><em class="ng"/><a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">不和</em> </strong> </a> <em class="ng">。对增长黑客感兴趣？检查</em> <a class="ae lr" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">电路</em> </strong> </a> <em class="ng">。</em></p></div></div>    
</body>
</html>