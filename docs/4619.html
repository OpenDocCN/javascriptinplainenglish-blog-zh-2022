<html>
<head>
<title>How to Use ChatGPT as an Educational Chatbot in a Next.js Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Next.js前端使用ChatGPT作为教育聊天机器人</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-chatgpt-as-an-educational-chatbot-in-a-next-js-frontend-6f9689ba85e9?source=collection_archive---------1-----------------------#2022-12-19">https://javascript.plainenglish.io/how-to-use-chatgpt-as-an-educational-chatbot-in-a-next-js-frontend-6f9689ba85e9?source=collection_archive---------1-----------------------#2022-12-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3a17" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">你可以在你的网站上使用OpenAI的GPT-3.5作为聊天助手吗？你打赌。以下是如何使用Express服务器、作为BFF的WunderGraph和GraphQL来完成的。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9b66fb547886021edfed19e66545d2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AYJD7v7T2mkRBjYO"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/es/@lunarts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Volodymyr Hryshchenko</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kt ku kv"><p id="4660" class="kw kx ky kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">三到八年内，我们将拥有一台具有普通人一般智力的机器……如果我们幸运的话，他们可能会决定把我们当宠物养。”——<strong class="kz io"><em class="in">马文·明斯基，1970年</em> </strong> <em class="in">。麻省理工学院人工智能实验室的创始人，图灵奖获得者，斯坦利·库布里克2001太空漫游的顾问。</em></p></blockquote><p id="14cd" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">从这句话开始，53年过去了，我要说我们在避免机器人起义方面做得很好。</p><p id="f09d" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">然而，我们<em class="ky">已经</em>到了可以教机器<em class="ky">学习</em>的地步，并根据它们所学生成文本和图像。当然，记忆统计模式不是智力，但是随着大型语言模型的出现，我们甚至可以使用人工智能来帮助人类理解语言概念。</p><p id="8d6b" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">想想聊天机器人/助手不需要告诉你"<em class="ky">如果你在连接到我们的服务器时遇到问题，请按3 "</em>，但是当你告诉它"<em class="ky">我的游戏在登录屏幕上死机时，<em class="ky">明白</em>你想要解决连接问题！请帮忙！！1" </em></p><p id="a7a9" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">接下来，我们可以使用这些LLM——以“问一个问题，得到一个答案”的能力——为学生提供个性化的、可访问的、按需的帮助，帮助他们按照自己的速度、根据自己的需要和能力进行学习。对于电子学习来说，这种即时反馈和支持不需要打断当前的讲座(事实上，甚至不需要只在常规课时内提问)，只需要补充一门课程，使其对学生来说更容易获得和更有吸引力。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/994b640c3a0f4a3e09dfd0f495e53895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*lW7Q7e6wkPjb84Zr7tnJIA.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Here’s the app in action. Love Jack, but his video is only being used as an example here. 😅 Not affiliated in any way.</figcaption></figure><p id="bd87" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">但是这些思想实验已经够了。让我们尝试构建这样一个前端集成——一个聊天助手，它可以使用OpenAI来回答潜在学生的问题，而无需他们退出课程！</p><h1 id="9d81" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">技术堆栈会是什么样的？</h1><p id="8587" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">类似这样的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/758be837c38b5cfde47ab32a7cc306e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ozDV4gkfWCBIxcjR"/></div></div></figure><ul class=""><li id="409a" class="mv mw in kz b la lb ld le lt mx lu my lv mz ls na nb nc nd bi translated">一个Next.js前端，模拟了一个电子学习平台，带有一个聊天助手/助手/聊天机器人/随便你想叫它什么的组件，学生可以在其中输入问题，并从那里接收答案。</li><li id="d2e7" class="mv mw in kz b la ne ld nf lt ng lu nh lv ni ls na nb nc nd bi translated">一个Node.js/Express API，它从前端接收问题，将它们代理到OpenAI ChatGPT服务器上，并在响应中提供答案。ChatGPT API还没有公开，但是我们可以使用非官方的<code class="fe nj nk nl nm b"><a class="ae ks" href="https://www.npmjs.com/package/chatgpt" rel="noopener ugc nofollow" target="_blank">chatgpt</a></code>包来实现我们的目的。</li><li id="8ef4" class="mv mw in kz b la ne ld nf lt ng lu nh lv ni ls na nb nc nd bi translated">使用<a class="ae ks" href="https://wundergraph.com/" rel="noopener ugc nofollow" target="_blank"> WunderGraph </a>的后端对前端(BFF)，这是一个免费的开源开发工具，仅在构建时使用GraphQL，通过安全的JSON-over-RPC提供数据。WunderGraph服务器将是一个服务层，或者API网关，不管你想叫它什么，它是你的前端可以看到的唯一的“后端”。</li></ul><h1 id="bf8f" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">为什么是WunderGraph？</h1><p id="7de8" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">为什么首先要使用BFF模式？为什么不直接从前端处理对API的GET/POST调用呢？好吧，让我们先假设一下。在这种情况下，您的架构可能是这样的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/1ab1d8e48c503b900d9d745bd6907057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IF_29cpK7yMCfOus"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">What’s wrong with this picture?</figcaption></figure><p id="cf0e" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">您的前端现在与后端紧密耦合。您将不得不提交数百行代码到您的前端repo，仅仅是为了协调您的前端和您的应用程序使用的许多微服务和API之间的双向通信。如果它们中的任何一个是新生的或不稳定的技术——chat GPT就是最好的例子——那么您将经常一头扎进您的前端代码，对底层线路进行必要的修改，以确保一切正常工作。不理想。</p><p id="a33f" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">使用WunderGraph作为后端对前端，将前端(对于任何一组客户端)从后端解耦，简化了维护以及两者之间的双向通信，方法是<strong class="kz io">仅在构建时使用graph QL</strong>将整个操作转变为简单的查询和变化，具有完全的端到端类型安全，并且来自所有数据源的数据整合到一个单一的、统一的虚拟图中，即JSON-over-RPC。</p><p id="18f8" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">通过这种方式，您可以并行化所有微服务/API调用，一次性获取每个客户端所需的准确数据，减少嵌套数据的瀑布，并自动完成所有数据获取…所有这些都没有GraphQL的典型痛点，即大型客户端捆绑包和缓存/安全问题。</p><p id="7df3" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">你的应用甚至不需要提供GraphQL端点；你只是利用它的力量来获得巨大的DX胜利。</p><h1 id="fa4c" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">代码</h1><blockquote class="kt ku kv"><p id="a204" class="kw kx ky kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><em class="in"> ⚠ </em>然而，OpenAI的ChatGPT和Travis Fischer的<a class="ae ks" href="https://www.npmjs.com/package/chatgpt" rel="noopener ugc nofollow" target="_blank"> chatgpt库</a>都在不断变化，突破性的变化将不可避免(但您的前端基本保持不变——使用BFF模型的额外好处！).如果您发现代码不再工作，请在这里勾选<a class="ae ks" href="https://github.com/transitive-bullshit/chatgpt-api" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><h1 id="8fd4" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">第1部分:Express和ChatGPT库</h1><h2 id="74e1" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">第0步:依赖项</h2><p id="9a44" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">在项目根目录中，为您的API()创建一个目录。/后端工作正常)，光盘到其中，然后键入这些。</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="1c59" class="oe ly in nm b be of og l oh oi">npm install express dotenv<br/>npm install chatgpt</span></pre><p id="8aaa" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">可选地…</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="2ca3" class="oe ly in nm b be of og l oh oi">npm install puppeteer</span></pre><p id="dc0b" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">我们对API使用<a class="ae ks" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> Express </a>、对环境变量使用<a class="ae ks" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>、对非官方的ChatGPT API使用(直到OpenAPI发布官方的公共API)。</p><p id="ed05" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">OpenAPI最近为ChatGPT增加了CloudFlare保护，使得使用非官方API变得更加困难。该库(可选)在引擎盖下使用<a class="ae ks" href="https://www.npmjs.com/package/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>自动绕过这些保护—您需要做的就是在一个。环境文件。</p><h2 id="ba3c" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">第1步:服务器</h2><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="32f2" class="oe ly in nm b be of og l oh oi">import { ChatGPTAPI, getOpenAIAuth } from "chatgpt";<br/>import * as dotenv from "dotenv";<br/>dotenv.config();<br/>import express from "express";<br/><br/>const app = express();<br/>app.use(express.json());<br/>const port = 3001;<br/><br/>async function getAnswer(question) {<br/>  // use puppeteer to bypass cloudflare (headful because of captchas)<br/>  const openAIAuth = await getOpenAIAuth({<br/>    email: process.env.OPENAI_EMAIL,<br/>    password: process.env.OPENAI_PASSWORD<br/>    // isGoogleLogin: true // uncomment this if using google auth<br/>  })<br/><br/>  const api = new ChatGPTAPI({ ...openAIAuth })<br/>  await api.initSession()<br/><br/>  // send a message and wait for the response<br/>  const response = await api.sendMessage(question);<br/><br/>  // response is a markdown-formatted string<br/>  return response; <br/>}<br/><br/>// GET<br/>app.get("/api", async (req, res) =&gt; {<br/>  res.send({<br/>    question: "What is the answer to life, the universe, and everything?",<br/>    answer: "42!",<br/>  });<br/>});<br/><br/>// POST<br/>app.post("/api", async (req, res) =&gt; {<br/>  // Get the body from the request<br/>  const { body } = req;<br/>  console.log(body.question); // debug<br/>  res.send({<br/>    question: body.question,<br/>    answer: await getAnswer(body.question),<br/>  });<br/>});<br/><br/>app.listen(port, () =&gt; {<br/>  console.log(`Example app listening on port ${port}`);<br/>});</span></pre><p id="6dea" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">应用编程接口服务器代码本身是非常自明的。它接收请求正文中的一个问题，使用ChatGPT将其发送到OpenAI服务器，等待答案，并以这种响应格式为两者提供服务:</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="f374" class="oe ly in nm b be of og l oh oi">{<br/>    "question": "what is the first letter of the alphabet?",<br/>    "answer": {<br/>        "conversationId": someId,<br/>        "messageId": someOtherId,<br/>        "response": "The first letter of the alphabet is \"A.\""<br/>    }<br/>}</span></pre><h2 id="e0d5" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">第2步:OpenAPI规范</h2><p id="9054" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">WunderGraph的工作方式是对数据源进行内省，并将它们整合到一个统一的虚拟图形中，然后您可以在该图形上定义操作，并通过JSON-over-RPC来提供结果。为了让这种内省在REST API上发挥作用，您将需要OpenAPI(您也可以称之为swag)规范。</p><p id="aeab" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">OpenAPI/swag规范是RESTful API的可读描述。这只是一个JSON或YAML文件，描述了API使用的服务器、它的身份验证方法、每个端点的功能、每个端点需要的参数/请求体的格式以及每个端点返回的响应模式。</p><p id="a027" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">幸运的是，一旦你知道该做什么，写这个并不太难，有几个库可以使它自动化。</p><p id="060a" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">这是我们API的OpenAPI V3规范，在JSON中。</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="c2ba" class="oe ly in nm b be of og l oh oi">{<br/>  "openapi": "3.0.0",<br/>  "info": {<br/>    "title": "express-api-for-chatgpt",<br/>    "version": "1.0.0",<br/>    "license": {<br/>      "name": "ISC"<br/>    },<br/>    "description": "Specification JSONs: [v2](/api-spec/v2), [v3](/api-spec/v3)."<br/>  },<br/>  "servers": [<br/>    {<br/>      "url": "http://localhost:3001"<br/>    }<br/>  ],<br/>  "paths": {<br/>    "/api": {<br/>      "get": {<br/>        "summary": "/api",<br/>        "responses": {<br/>          "200": {<br/>            "description": "OK",<br/>            "content": {<br/>              "application/json": {<br/>                "schema": {<br/>                  "type": "object",<br/>                  "properties": {<br/>                    "question": {<br/>                      "type": "string",<br/>                      "description": "The question to be asked",<br/>                      "example": "What is the answer to life, the universe, and everything?"<br/>                    },<br/>                    "answer": {<br/>                      "type": "string",<br/>                      "description": "The answer",<br/>                      "example": "42!"<br/>                    }<br/>                  }<br/>                }<br/>              }<br/>            }<br/>          }<br/>        },<br/>        "tags": []<br/>      },<br/>      "post": {<br/>        "summary": "/api",<br/>        "requestBody": {<br/>          "required": true,<br/>          "content": {<br/>            "application/json": {<br/>              "schema": {<br/>                "type": "object",<br/>                "properties": {<br/>                  "question": {<br/>                    "type": "string",<br/>                    "description": "The question to be asked",<br/>                    "example": "What is the answer to life, the universe, and everything?"<br/>                  }<br/>                }<br/>              }<br/>            }<br/>          }<br/>        },<br/>        "responses": {<br/>          "200": {<br/>            "description": "OK",<br/>            "content": {<br/>              "application/json": {<br/>                "schema": {<br/>                  "type": "object",<br/>                  "properties": {<br/>                    "question": {<br/>                      "type": "string",<br/>                      "example": "what is the first letter of the alphabet?"<br/>                    },<br/>                    "answer": {<br/>                      "type": "object",<br/>                      "properties": {<br/>                        "conversationId": {<br/>                          "type": "string",<br/>                          "example": "someId"<br/>                        },<br/>                        "messageId": {<br/>                          "type": "string",<br/>                          "example": "someOtherId"<br/>                        },<br/>                        "response": {<br/>                          "type": "string",<br/>                          "example": "The first letter of the alphabet is A."<br/>                        }<br/>                      }<br/>                    }<br/>                  }<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="85ab" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">第2部分:Next.js + WunderGraph</h1><h2 id="0ec5" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">第0步:快速入门</h2><p id="9e3a" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">我们可以使用<code class="fe nj nk nl nm b">create-wundergraph-app</code> CLI设置Next.js客户端和WunderGraph BFF。CD进入项目根目录(在您的Express后端目录下)，并键入:</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="94b7" class="oe ly in nm b be of og l oh oi">npx create-wundergraph-app frontend -E nextjs</span></pre><p id="2ade" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">然后，进入您刚才要求CLI创建的目录:</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="a007" class="oe ly in nm b be of og l oh oi">cd frontend</span></pre><p id="eaa5" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">安装依赖项，并启动:</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="091a" class="oe ly in nm b be of og l oh oi">npm i &amp;&amp; npm start</span></pre><p id="f487" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">这将启动WunderGraph和Next.js服务器(利用<code class="fe nj nk nl nm b">npm-run-all</code>包)，在<code class="fe nj nk nl nm b">localhost:3000</code>为您提供一个带有示例查询的Next.js启动页面。如果你看到了，一切都正常。</p><h2 id="df6d" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">步骤1:设置WunderGraph</h2><p id="e07d" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">WunderGraph可以将你能想到的几乎任何数据源——微服务、数据库、API——内省到一个安全的、类型安全的JSON-over-RPC API中；OpenAPI REST、GraphQL、PlanetScale、Fauna、MongoDB等等，以及任何Postgres/SQLite/MySQL数据库。</p><p id="824a" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">所以让我们开门见山。在<code class="fe nj nk nl nm b">.wundergraph</code>目录中打开<code class="fe nj nk nl nm b">wundergraph.config.ts</code>，添加我们的REST端点作为我们的应用程序所依赖的一个数据源，一个WunderGraph应该反省的数据源。</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="27fe" class="oe ly in nm b be of og l oh oi">const chatgpt = introspect.openApi({<br/> apiNamespace: 'chatgpt',<br/> source: {<br/>   kind: 'file',<br/>   filePath: './chatgpt-spec.json', // path to your openAPI spec file<br/> },<br/> requestTimeoutSeconds: 30, // optional<br/>  })ty<br/><br/>// add this data source to your config like a dependency<br/>configureWunderGraphApplication({<br/> apis: [chatgpt],<br/>});<br/>//...</span></pre><p id="1656" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">一个真实的应用程序当然会有不止一个REST端点，您可以像这样定义它们。在这里检查WunderGraph可以自省的不同类型的数据源，然后在您的配置中相应地定义它们。</p><p id="3dc4" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">一旦你运行了npm start，WunderGraph会自动监控你的项目目录中的必要文件，所以只要点击这里的save就会让代码生成器运行，它会生成一个你可以检查的模式(如果你想的话)——在<code class="fe nj nk nl nm b">/.wundergraph/generated</code>中的<code class="fe nj nk nl nm b">wundergraph.app.schema.graphql </code>文件。</p><h2 id="3f1e" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">步骤2:使用GraphQL定义操作</h2><p id="46d5" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">这是我们在GraphQL中编写查询/变异来操作WunderGraph生成的虚拟图形层，并获得我们想要的数据的部分。</p><p id="a4c5" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">所以转到<code class="fe nj nk nl nm b">./wundergraph/operations</code>并创建一个新的GraphQL文件。我们就叫它<code class="fe nj nk nl nm b">GetAnswer.graphql</code>。</p><p id="b880" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">所以这是我们的变种，向我们的Express API发送一个问题(作为一个字符串)，并接收一个回答(包括原始问题，用于您的UI，或者只是日志)。</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="e7f2" class="oe ly in nm b be of og l oh oi">mutation ($question: String!) {<br/>  chatgpt_postApi(postApiInput: { question: $question }) {<br/>    question<br/>    answer {<br/>      conversationId<br/>      messageId<br/>      response<br/>    }<br/>  }<br/>}</span></pre><p id="9799" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">注意名字间距！</p><p id="7dd6" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">中为其他数据源定义数据提取操作。graphql文件就像这个。</p><p id="6eeb" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">在整个过程中，每次点击save，WunderGraph的代码生成都在后台工作(只要它的服务器在运行，它就会在后台工作)，生成类型安全的、特定于客户端的数据获取React钩子(<code class="fe nj nk nl nm b">useQuery, useMutation</code>等等。)为你飞奔(使用维尔塞尔的《引擎盖下的SWR》)。这些是我们将在Next.js前端使用的。</p><h2 id="0e49" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">步骤3:构建用户界面</h2><p id="e498" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">对于一个最小可行的产品，我们的UI确实只需要两样东西。一个内容区，你可以在这里展示你的课程、教程或你提供的任何类型的内容，以及一个可折叠的聊天助手/聊天机器人界面——它使用了我们刚刚谈到的一个钩子，<code class="fe nj nk nl nm b">useMutation</code>。</p><h2 id="893e" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">。/pages/_app.tsx</h2><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="cfb9" class="oe ly in nm b be of og l oh oi">import Head from "next/head";<br/><br/>function MyApp({ Component, pageProps }) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Head&gt;<br/>        &lt;meta charSet="UTF-8" /&gt;<br/>        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>        &lt;script src="https://cdn.tailwindcss.com"&gt;&lt;/script&gt;<br/>      &lt;/Head&gt;<br/>      &lt;main&gt;<br/>        &lt;Component {...pageProps} /&gt;<br/>      &lt;/main&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/>export default MyApp;</span></pre><p id="b99f" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">请注意，我在这个应用程序中使用的是Tailwind。Tailwind是一个非常棒的实用至上的CSS，可以通过它的Play CDN轻松地集成到任何应用程序中(尽管你可能想切换到PostCSS实现进行生产)。</p><h2 id="28af" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">。/pages/index.tsx</h2><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="96c7" class="oe ly in nm b be of og l oh oi">import { NextPage } from "next";<br/>import { withWunderGraph } from "../components/generated/nextjs";<br/>// my components<br/>import ChatHelper from "../components/ChatHelper";<br/>import NavBar from "../components/Header";<br/><br/>const Home: NextPage = () =&gt; {<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;div className="dark:bg-gray-800 min-h-screen"&gt;<br/>        &lt;NavBar /&gt;<br/>        &lt;div className="container flex mx-auto mt-10 h-fit"&gt;<br/>          &lt;div className="bg-gray-300 p-4 rounded-md"&gt;<br/>            {/* page content */}<br/>            &lt;h2 className="font-bold text-xl"&gt; Page content goes here &lt;/h2&gt;<br/>            &lt;div&gt;<br/>{/* video/course content here */}<br/>              &lt;iframe<br/>                className="rounded-lg w-full h-80 mt-4 "<br/>                src="https://www.youtube.com/embed/njX2bu-_Vw4"<br/>                title="YouTube video player"<br/>                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"<br/>                allowFullScreen<br/>              &gt;&lt;/iframe&gt;<br/>            &lt;/div&gt;<br/>            &lt;p className="mt-4"&gt;<br/>              {/* some lipsum here */}            &lt;/p&gt;<br/>          &lt;/div&gt;<br/>          &lt;div className="absolute bottom-0 right-0 m-4"&gt;<br/>            &lt;ChatHelper /&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>};<br/><br/>export default withWunderGraph(Home); // for SSR with WunderGraph</span></pre><h2 id="023c" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">。/components/NavBar.tsx</h2><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="90a0" class="oe ly in nm b be of og l oh oi">const NavBar = () =&gt; {<br/>  return (<br/>    &lt;header className="bg-gray-400 p-4 shadow-md"&gt;<br/>      &lt;div className="container mx-auto flex items-center justify-between"&gt;<br/>        &lt;a href="#" className="font-bold text-xl"&gt;<br/>          My Website<br/>        &lt;/a&gt;<br/>        &lt;nav&gt;<br/>          &lt;a href="#" className="px-4 hover:underline"&gt;<br/>            Home<br/>          &lt;/a&gt;<br/>          &lt;a href="#" className="px-4 hover:underline"&gt;<br/>            FAQ<br/>          &lt;/a&gt;<br/>        &lt;/nav&gt;<br/>      &lt;/div&gt;<br/>    &lt;/header&gt;<br/>  );<br/>};<br/><br/>export default NavBar;</span></pre><p id="e16a" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">在这个例子中，导航条并不是必需的；这只是一个我在布局时放入我的所有项目中的一个常用组件，以使事情看起来更漂亮😅。</p><h2 id="5ad6" class="no ly in bd lz np nq dn md nr ns dp mh lt nt nu mj lu nv nw ml lv nx ny mn nz bi translated">。/components/ChatHelper.tsx</h2><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="630e" class="oe ly in nm b be of og l oh oi">import React, { useState } from "react";<br/>import { useMutation, useQuery } from "../components/generated/nextjs";<br/><br/>const ChatHelper = () =&gt; {<br/>  const placeholderAnswer = "Hi! What did you want to learn about today?";<br/><br/>  const [isExpanded, setIsExpanded] = useState(false);<br/>  const [input, setInput] = useState("");<br/><br/><br/>  const { data, isMutating, trigger } = useMutation({<br/>    operationName: "GetAnswer",<br/>  });<br/><br/>  return (<br/>    &lt;div<br/>      className={`relative rounded-lg bg-white shadow-md ${<br/>        isExpanded ? "expanded" : "collapsed"<br/>      }`}<br/>    &gt;<br/>      &lt;button<br/>        className="p-4 absolute top-0 right-0 mr-2"<br/>        onClick={() =&gt; setIsExpanded(!isExpanded)}<br/>      &gt;<br/>        &lt;span&gt;{isExpanded ? "❌" : "💬"}&lt;/span&gt;<br/>      &lt;/button&gt;<br/>      &lt;div className="max-w-lg max-h-lg p-4"&gt;<br/>        {isExpanded &amp;&amp; (<br/>          &lt;&gt;<br/>            &lt;h2 className="text-lg font-bold"&gt;Helper&lt;/h2&gt;<br/><br/>            &lt;p id="answer" className="text-blue-500 font-bold"&gt;<br/>              {data ? data.chatgpt_postApi?.answer?.response : placeholderAnswer}<br/>            &lt;/p&gt;<br/><br/>            &lt;p id="ifLoading" className="text-green-500 font-bold font-italics"&gt;<br/>              {isMutating ? "ChatGPT is thinking..." : ""}<br/>            &lt;/p&gt;<br/><br/>            &lt;form<br/>              onSubmit={(event) =&gt; {<br/>                event.preventDefault();<br/>                if (input) {<br/>                  trigger({<br/>                    question: input,<br/>                  });<br/>                }<br/>              }}ty<br/>            &gt;<br/>              &lt;input<br/>                className="border rounded-md p-2 w-full"<br/>                type="text"<br/>                placeholder="Your question here."<br/>                onChange={(event) =&gt; {<br/>                  const val = event.target.value;<br/>                  if (val) {<br/>                    // set question<br/>                    setInput(val);<br/>                  }<br/>                }}<br/>              /&gt;<br/>              &lt;button className="bg-blue-500 text-white rounded-md p-2 mt-2"&gt;<br/>                Help me, Obi-Wan Kenobi.<br/>              &lt;/button&gt;<br/>            &lt;/form&gt;<br/>          &lt;/&gt;<br/>        )}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default ChatHelper;</span></pre><p id="bf62" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">只有当您在表单提交上用输入(即问题)调用<code class="fe nj nk nl nm b">trigger </code>时，才会调用<code class="fe nj nk nl nm b">useMutation</code>钩子；其将在Express后端中作为请求主体结束)。这很直观，但是关于<code class="fe nj nk nl nm b">trigger</code>的更多问题，请查看SWR的文档<a class="ae ks" href="https://swr.vercel.app/docs/api" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="c9da" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">你完了！如果ChatGPT服务器的负载不是很重，您应该能够输入一个问题，点击按钮，然后在。</p><h1 id="10e2" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">从这里去哪里？</h1><p id="ca76" class="pw-post-body-paragraph kw kx in kz b la mp jo lc ld mq jr lf lt mr li lj lu ms lm ln lv mt lq lr ls ig bi translated">希望本教程能够让您了解如何将ChatGPT用于您自己的用例，编写API并为其生成OpenAPI文档，这样您就可以将它作为BFF与WunderGraph一起使用，使查询变得轻而易举。</p><p id="f9d2" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">接下来，您可能会想要添加一个<code class="fe nj nk nl nm b">&lt;ul&gt;</code>列表，列出固定/预先选择的问题(基于当前课程)，单击这些问题时，它们会作为问题传递给<code class="fe nj nk nl nm b">&lt;ChatHelper&gt;</code>组件，这样您的学生就有了一个建议列表，知道从哪里开始提问。</p><p id="f921" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">除此之外，您还可以在结果对象中使用<code class="fe nj nk nl nm b">conversationId </code>和<code class="fe nj nk nl nm b">messageId </code>，并将它们分别作为<code class="fe nj nk nl nm b">conversationId </code>和<code class="fe nj nk nl nm b">parentMessageId </code>传递给<code class="fe nj nk nl nm b">sendMessage </code>来跟踪与机器人的对话，并为其添加对之前所提问题的意识——这样您的学生就可以提出后续问题以获得更多相关信息，并使对话更加自然。</p><pre class="kd ke kf kg gt oa nm ob bn oc od bi"><span id="c1aa" class="oe ly in nm b be of og l oh oi"><br/>// send a follow-up<br/>res = await api.sendMessage('Can you expand on that?', {<br/>  conversationId: res.conversationId,<br/>  parentMessageId: res.messageId<br/>})<br/>console.log(res.response)<br/><br/>// send another follow-up<br/>res = await api.sendMessage('What were we talking about?', {<br/>  conversationId: res.conversationId,<br/>  parentMessageId: res.messageId<br/>})</span></pre><p id="b520" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">此外，请留意<code class="fe nj nk nl nm b">chatgpt</code>库本身，因为OpenAI经常改变ChatGPT的研究预览版的工作方式，所以您需要确保您的代码跟上非官方API的更新。</p><p id="17fe" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">最后，如果你想了解更多关于WunderGraph的众多用例，可以查看他们的Discord社区<a class="ae ks" href="https://wundergraph.com/discord" rel="noopener ugc nofollow" target="_blank"> <em class="ky">这里</em> </a>！</p></div></div>    
</body>
</html>