<html>
<head>
<title>Explore the New Features in React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索React 18中的新功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/explore-the-new-features-in-react-18-fb476b5bcc5c?source=collection_archive---------8-----------------------#2022-04-21">https://javascript.plainenglish.io/explore-the-new-features-in-react-18-fb476b5bcc5c?source=collection_archive---------8-----------------------#2022-04-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fb76fbda506fb045c49e27f4e14ad20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-m3qhmmddf9me7nheVzzmw.jpeg"/></div></div></figure><p id="46a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看来又到了一年中的这个时候了。React刚刚发布了其最新版本18，它包含了一系列为您的开发增添巨大推动力的功能。在本文中，我将带您了解这些特性。</p><p id="15fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是我们将在本文中涉及的内容。</p><h2 id="44aa" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">概述</strong>:</h2><ul class=""><li id="544a" class="lm ln in jx b jy lo kc lp kg lq kk lr ko ls ks lt lu lv lw bi translated"><strong class="jx io"> <em class="lx">反应18并发渲染</em> </strong></li><li id="111e" class="lm ln in jx b jy ly kc lz kg ma kk mb ko mc ks lt lu lv lw bi translated"><strong class="jx io"> <em class="lx">反应过渡</em> </strong></li><li id="5ab4" class="lm ln in jx b jy ly kc lz kg ma kk mb ko mc ks lt lu lv lw bi translated"><strong class="jx io"> <em class="lx">反应自动配料</em> </strong></li><li id="76a3" class="lm ln in jx b jy ly kc lz kg ma kk mb ko mc ks lt lu lv lw bi translated"><strong class="jx io"> <em class="lx">在服务器端反应悬念</em> </strong></li><li id="66c4" class="lm ln in jx b jy ly kc lz kg ma kk mb ko mc ks lt lu lv lw bi translated"><strong class="jx io"> <em class="lx">结论</em> </strong></li></ul><h1 id="0809" class="md ku in bd kv me mf mg ky mh mi mj lb mk ml mm le mn mo mp lh mq mr ms lk mt bi translated">环境设置:</h1><p id="5d5c" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">首先，让我们使用create-react-app来设置我们的开发环境并探索新特性。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="dc11" class="kt ku in nc b gy ng nh l ni nj">npx create-react-app react-18</span></pre><p id="6ce7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将自动安装最新的react18版本。现在运行<code class="fe nk nl nm nc b">npm start</code>，React应用应该开始运行。往下看<strong class="jx io"> index.js </strong>文件，一眼就能看到呈现语法的细微变化。</p><p id="f6e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">反应17: </strong></p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/23ee1bc076bd1e8f758acba133ad3f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHDuWyL4yP5GC05jvHpFTA.png"/></div></div></figure><p id="7c51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">反应18: </strong></p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/def9ffc3a84a8d289253e66979239a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EMnV_KhjMcrts4GO4pj0g.png"/></div></div></figure><p id="66ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在React18中，<strong class="jx io"><em class="lx">react DOM . render</em></strong>被替换为<strong class="jx io"><em class="lx">react DOM . create root</em></strong>用于创建你的app的根，然后调用render方法渲染根。这个<strong class="jx io"> <em class="lx"> createRoot </em> </strong>是并发渲染机制的一部分，用于主动并发渲染。</p><h1 id="12ad" class="md ku in bd kv me mf mg ky mh mi mj lb mk ml mm le mn mo mp lh mq mr ms lk mt bi translated"><strong class="ak"> <em class="np">反应18并发渲染</em> </strong></h1><p id="fd97" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">React 18的第一个更新是并发性。React的核心是并发算法，它是React生态系统的主要部分。React 18引入了一个特性，允许我们中断当前的并发任务，稍后再继续。</p><p id="cc99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在React 18之前，一旦并发渲染任务开始，就没有办法停止它，直到它完成执行。这实际上是一个单一的同步任务，正如我们已经知道的，同步任务一个接一个地进行。</p><p id="c185" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着React18的出现，并发机制得到了改进，现在允许React中断渲染。并发渲染带来了一些新功能，如悬念、流服务器渲染和由并发渲染驱动的过渡。这是React核心渲染模型的基础更新，但只需要对它有高层次的理解，因为它是在场景本身的背后处理的。并发模式仍然是一个实验性的特性，正在慢慢适应React API的其他部分。</p><h1 id="b00a" class="md ku in bd kv me mf mg ky mh mi mj lb mk ml mm le mn mo mp lh mq mr ms lk mt bi translated">新功能</h1><h2 id="5d20" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">1.反应转换</h2><p id="5b46" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">React中的更新有两种类型。DOM事件更新和转换更新。DOM事件更新在事件触发器上非常明显，而转换更新需要等待一段时间才能在视图中看到。</p><p id="52c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了React并发，我们现在可以将紧急更新优先于过渡更新，这样用户就不会有用户体验不佳的感觉。</p><p id="2d65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使用这个特性，React制作了一个<code class="fe nk nl nm nc b"><strong class="jx io">startTransition</strong></code> API来通知React哪些更新具有更高的优先级/紧急性，哪些是过渡。</p><p id="f003" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了访问这个，我们将使用<strong class="jx io"> <em class="lx"> useTransition </em> </strong>钩子。我们可以从钩子或者直接从基于类的组件中的React访问<code class="fe nk nl nm nc b"><strong class="jx io">startTransition</strong></code>。</p><h2 id="5ed5" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">使用过渡挂钩:</h2><p id="10fa" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated"><strong class="jx io"><em class="lx">use transition</em></strong>返回一个过渡状态，和一个函数。我们可以使用isPending来知道转换何时进行。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="d291" class="kt ku in nc b gy ng nh l ni nj">const [isPending, startTransition] = useTransition();</span></pre><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b1e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，有一个按钮需要紧急反映结果，还有一个transitionValue显示1k+数据的列表。我们希望在按钮点击时更新列表，并增加计数。</p><ul class=""><li id="effc" class="lm ln in jx b jy jz kc kd kg ns kk nt ko nu ks lt lu lv lw bi translated">点击按钮将增加<code class="fe nk nl nm nc b">urgentValue</code>，然后调用<code class="fe nk nl nm nc b">startTransition</code>方法让React知道<code class="fe nk nl nm nc b">transitionValue</code>不紧急，因此它将继续慢慢更新它，给<code class="fe nk nl nm nc b">urgentValue</code>更多的优先权。</li><li id="bed0" class="lm ln in jx b jy ly kc lz kg ma kk mb ko mc ks lt lu lv lw bi translated">在这个过程中，我们可以添加一个带有<code class="fe nk nl nm nc b">isPending</code>状态的加载效果，向用户显示列表处于挂起状态。</li><li id="0822" class="lm ln in jx b jy ly kc lz kg ma kk mb ko mc ks lt lu lv lw bi translated">如果我们从click事件中移除<code class="fe nk nl nm nc b">startTransition</code>方法，然后继续增加计数器，我们可以观察到屏幕上有轻微的延迟，这给人一种用户体验不佳的印象。</li></ul><p id="1d6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以在基于类的组件中使用startTransition API，如下所示。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="42ec" class="kt ku in nc b gy ng nh l ni nj">import {startTransition} from 'react';</span></pre><h2 id="2f57" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">2.自动配料</h2><p id="52e2" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">React在React18中引入了自动批处理。React中的批处理是什么，我们到底为什么需要它？好吧，无论何时，使用<code class="fe nk nl nm nc b">setState</code>在React中有一个状态改变，组件立即重新呈现。React 17已经为我们处理配料了。然而，它仅限于事件处理程序。请允许我解释。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="24a6" class="kt ku in nc b gy ng nh l ni nj">onHandleChange = (<em class="lx">event</em>) <em class="lx">=&gt;</em> {<br/> setLoader();<br/> setValue(); <br/> setCounter(); <br/>}<br/>// Render at the end of event once</span></pre><p id="0067" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当事件处理程序中有状态更改时，它们都被视为批处理，因此在事件完成执行后只呈现一次。但是事件之外的任何状态变化每次都会单独呈现。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="772f" class="kt ku in nc b gy ng nh l ni nj">onHandleChange = (<em class="lx">event</em>) <em class="lx">=&gt;</em> {<br/> this.apiCall().then(<em class="lx">res=&gt;</em>{<br/>  setLoader();  // 1 render<br/>  setValue();  // 2 render<br/>  setCounter(); // 3 render<br/> })<br/>}</span></pre><p id="454a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，这是很不恰当的。幸运的是，React 18在所有微任务(如承诺和<code class="fe nk nl nm nc b">setTimeout</code>函数)中都自动批处理。我们可以随时使用<code class="fe nk nl nm nc b">flushSync</code>退出该功能。</p><h2 id="9c5c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">3.在服务器上反应悬念</h2><p id="6a67" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">React 18在服务器端引入了悬念。在不涉及太多细节的情况下，让我简单概述一下什么是服务器端以及它是如何工作的。网页可以通过两种方式加载。在客户端称为客户端呈现(CSR ),或者在服务器端称为服务器端呈现(SSR)。CSR在加载时间上往往很慢，因为它严重依赖JavaScript，并且动态加载数据。</p><p id="1f2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决这个问题，使用服务器端呈现来增强一次性加载页面的用户体验，并减少交互页面的时间。</p><p id="9221" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管这是一种更好、更快的加载页面的方法，但是React中存在一个瓶颈，导致页面在等待数据加载时没有响应。</p><p id="930a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果我们正在加载3个组件，其中一个相对较慢，这将挂起屏幕，而不是加载其他组件，从而破坏用户体验。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/95e020c091207c8d2e929f5a39667b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QAupsrNGxgv_cODWK4W5w.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk">React SSR bottleneck</figcaption></figure><p id="d106" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了处理这一点，React 18引入了悬念。通过悬念，我们可以用悬念组件包装应用程序的慢速部分，它会告诉React延迟重组件的渲染。这样，最轻的组件会先加载，在这个过程中用户体验不会受到干扰。</p><h1 id="893f" class="md ku in bd kv me mf mg ky mh mi mj lb mk ml mm le mn mo mp lh mq mr ms lk mt bi translated">结论🎉</h1><p id="4f5f" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">React 18带来了一系列底层的变化，这无疑会在React中工作时有所帮助。虽然其中一些是实验性的，但它们最终会完全集成到库中，带来完整的体验。</p><blockquote class="oa ob oc"><p id="0c2e" class="jv jw lx jx b jy jz ka kb kc kd ke kf od kh ki kj oe kl km kn of kp kq kr ks ig bi translated"><em class="in">我希望这篇文章对你有帮助，如果你有，</em> <strong class="jx io"> <em class="in">关注我的</em> </strong> <a class="ae og" href="https://medium.com/@mrahmedkhan019" rel="noopener"> <strong class="jx io"> <em class="in">中的</em> </strong> </a> <strong class="jx io"> <em class="in">和</em></strong><a class="ae og" href="https://twitter.com/50shadeofkhan" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="in">Twitter</em></strong></a><strong class="jx io"><em class="in">获取更多软件开发文章的通知，别忘了点击</em> </strong> <em class="in">。终于！感谢阅读，快乐学习！</em></p></blockquote><p id="3bc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx">更多内容请看</em><a class="ae og" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lx">plain English . io</em></strong></a><em class="lx">。报名参加我们的</em> <a class="ae og" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lx">免费周报</em> </strong> </a> <em class="lx">。关注我们关于</em><a class="ae og" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lx">Twitter</em></strong></a><em class="lx">和</em><a class="ae og" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lx">LinkedIn</em></strong></a><em class="lx">。加入我们的</em> <a class="ae og" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lx">社区不和谐</em> </strong> </a> <em class="lx">。</em></p></div></div>    
</body>
</html>