<html>
<head>
<title>Next.js Static Site Generation Practical Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js静态站点生成实例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-static-site-generation-practical-example-9c0f53d2f897?source=collection_archive---------8-----------------------#2022-06-16">https://javascript.plainenglish.io/next-js-static-site-generation-practical-example-9c0f53d2f897?source=collection_archive---------8-----------------------#2022-06-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ff7b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">js如何通过默认预渲染每个页面来实现高性能网站，而不是全部由客户端JavaScript来完成。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/11e55ad477023f6ec937c89603c0ae23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUe_UAolY6u-4F5cPmy1Jw.png"/></div></div></figure><p id="dc48" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本文是我整理的整个Next.js系列文章的一部分，旨在帮助您成为Next.js专业人士，并开始构建速度极快的React应用程序。</p><p id="4a35" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">💡如果你不想错过任何教程，请通过<a class="ae lk" href="https://www.getrevue.co/profile/igorasilveira" rel="noopener ugc nofollow" target="_blank">点击这里</a>注册我的时事通讯，或者前往<a class="ae lk" href="https://dailydev.io/" rel="noopener ugc nofollow" target="_blank"> DailyDev.io </a>获取更多信息。</p><p id="da66" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个问题上，我们将了解Next.js如何通过默认预渲染每个页面来实现高性能网站，而不是像常规React应用程序通常所做的那样，全部由客户端JavaScript完成。</p><p id="23d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">💡你可以在这里找到这个项目<a class="ae lk" href="https://github.com/igorasilveira/blog-examples/tree/main/nextjs-static-generation" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><p id="8110" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以让我们开始吧！</p><h1 id="9deb" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">先决条件</h1><ul class=""><li id="a291" class="md me in kq b kr mf ku mg kx mh lb mi lf mj lj mk ml mm mn bi translated">节点≥ 12</li><li id="5bad" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">反应基础</li></ul><h1 id="47d4" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">快速回顾</h1><p id="21d3" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">到目前为止，我们一直在讨论页面的概念，如何在我们的Next.js项目中表示它们，以及如何使它们成为静态或动态的，以便Next.js知道如何呈现特定的URL并将其匹配到相应的React组件。</p><p id="b5b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们通过运行<code class="fe mw mx my mz b">npm run dev</code>启动我们的开发服务器，等待浏览器窗口弹出，显示我们在<code class="fe mw mx my mz b">http://localhost:3000</code>运行的应用程序。太好了！👍</p><p id="ccca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但有一件事我们还没有做，那就是深入研究Next.js是如何组装这些页面，并在我们访问某个URL时将它们返回给我们的。更好的是，我们的应用程序的生产版本与我们在本地运行的开发环境有什么不同。<strong class="kq io">而这才是Next.js真正大放异彩的地方。</strong></p><h1 id="238e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">预渲染</h1><p id="1f64" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">“什么是预渲染？”你可能会问。预渲染是在应用程序中获取一个页面并预先为其生成普通HTML的行为，而不是让客户端处理大部分工作。HTML还附带了最少的JavaScript代码，这些代码将在客户机上运行，是使页面完全交互所必需的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/2dcf5dcede8ef01174bb7840372141d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E3gSvpCA74K4n2r4"/></div></div></figure><p id="f714" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个过程有助于解决通常与React应用程序和一般单页应用程序(spa)相关的两个主要缺点:</p><ul class=""><li id="6af7" class="md me in kq b kr ks ku kv kx nb lb nc lf nd lj mk ml mm mn bi translated">令人震惊的是<strong class="kq io">搜索引擎优化</strong> (SEO)能力低下，因为所有页面和转换都由客户端通过JavaScript代码处理，因此搜索引擎无法抓取</li><li id="dd84" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">客户负担沉重</strong>因为他们必须在浏览器上下载并运行整个应用程序，随着应用程序变得越来越大，交互性越来越强，这很快就出现了问题</li></ul><h1 id="63ea" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">Next.js如何处理预渲染</h1><p id="8338" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">默认情况下，Next.js将预先呈现每个页面。它可以以两种不同的方式发生，不同的是当为页面生成HTML时<strong class="kq io">:</strong></p><ul class=""><li id="67b9" class="md me in kq b kr ks ku kv kx nb lb nc lf nd lj mk ml mm mn bi translated"><strong class="kq io">静态生成:</strong>HTML在<strong class="kq io">构建</strong> <strong class="kq io">时间</strong>生成，并在该页面的每个请求中重用。</li><li id="1c13" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">服务器端</strong> <strong class="kq io">渲染(针对另一篇文章):</strong>页面的HTML是在<strong class="kq io">每个请求</strong>上生成的。</li></ul><p id="5ad0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这两个选项都将提供我们在上一节中讨论的好处，但是它们可以根据不同的需求用于不同的用例，您甚至可以通过静态生成大多数页面和服务器端呈现其他页面，在同一应用程序中开发<em class="ne">混合</em>方法。</p><p id="4bbf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为web应用程序提供服务的最佳和最具性能的选择是静态生成所有应用程序的页面，因为它们可以很容易地缓存在<em class="ne">内容交付网络</em> (CDN)中，并通过在最靠近请求客户端的地方提供服务来提高性能。然而，在某些情况下，服务器端呈现可能是唯一的选择。</p><p id="f301" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们来看看如何在或狗app内实现静态生成。</p><h1 id="4c10" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">静态生成</h1><p id="dec8" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">使用静态生成，当我们运行<code class="fe mw mx my mz b">next build</code>命令时，页面的HTML在<strong class="kq io">构建时</strong>生成。每当页面被请求时，生成的HTML就被提供和重用。</p><p id="67e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有两种静态生成页面的方法，<strong class="kq io">有或没有来自外部来源的数据</strong>。</p><h1 id="2a43" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">无数据静态生成</h1><p id="fb59" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">这是Next.js页面最基本的用例，因为这是框架的默认行为。</p><p id="2bd7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从<code class="fe mw mx my mz b">pages</code>文件夹中的文件导出的简单组件在预渲染之前不需要获取任何外部数据，在构建期间会生成一个HTML文件。</p><p id="d008" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一个例子是我们在Next.js基本路由的第一个教程中创建的单个狗页面:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="67e1" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">数据静态生成</h1><p id="6307" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">然后是静态生成，依赖于获取外部数据进行预渲染。您可以想象需要获取外部数据来呈现页面的两种不同的用例:</p><ol class=""><li id="be92" class="md me in kq b kr ks ku kv kx nb lb nc lf nd lj nh ml mm mn bi translated">您的页面内容依赖于外部数据。</li><li id="db02" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj nh ml mm mn bi translated">您的页面<strong class="kq io">路径</strong>(现有路线)依赖于外部数据。</li></ol><p id="9839" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">场景1 </strong></p><p id="f32f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以在doggo应用程序中想到一个例子，其中我们的页面内容将依赖于外部数据。我们在上一个教程中制作了动态页面，所以所有的狗都由同一个React组件渲染。但是所有的狗都有不同的信息呈现在页面上，因此，每只狗的页面都有不同的内容。</p><p id="cd67" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们假设更新后的狗页面的以下片段:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6195" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了用正确的数据呈现每个狗页面，我们需要向React组件提供特定的狗数据。</p><p id="c8d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了在Next.js中做到这一点，我们将在导出表示页面的React组件的同一个页面中导出一个具有特定名称<code class="fe mw mx my mz b">getStaticProps</code>的<code class="fe mw mx my mz b">async</code>函数。这个函数将在构建时预呈现页面时被调用，您可以将必要的获取数据传递给页面的<code class="fe mw mx my mz b">props</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e4b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">场景二</strong></p><p id="d2ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">上次，我们在应用程序中创建了一个动态页面<strong class="kq io">来启用动态路线<strong class="kq io">。于是，我们的应用程序开始响应所有对<code class="fe mw mx my mz b">/dogs/:id</code>页面的请求。但是我们的应用程序并没有只为现有的狗<em class="ne">id</em>公开路线，而是匹配每一个id，所以它永远不会在该路线下返回一个<em class="ne"> 404 - Not Found </em>。</strong></strong></p><p id="f9df" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在现实世界中，这没有多大意义。我们只想为数据库中存在的特定和单独的资源呈现和提供页面。</p><p id="9053" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我们的页面路径<strong class="kq io">依赖于外部数据，应该被预先渲染。与之前类似，Next.js允许你在你的页面组件的文件中声明一个特定的函数，其唯一的目的是返回这个<strong class="kq io">动态页面</strong>应该呈现的<strong class="kq io">路径</strong>的列表，<code class="fe mw mx my mz b">getStaticPaths</code>。这个函数也会在构建时被调用。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0d9a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在<code class="fe mw mx my mz b">getStaticPaths</code>和<code class="fe mw mx my mz b">getStaticProps</code>可以协同工作，基于单个动态React组件预渲染现有狗的所有页面。</p><h1 id="d06e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">更新我们的狗应用程序</h1><p id="de58" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">现在是时候看看这是怎么回事了，给我们之前创建的动态页面加电，让它发挥最大潜力。</p><h1 id="69f6" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">创建狗界面</h1><p id="2350" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">由于我们使用TypeScript来确保类型安全和易于开发，我们应该利用它并创建一个<code class="fe mw mx my mz b">interface</code>来表示我们的狗，并通过应用程序方便它的使用。</p><p id="2568" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们创建一个新的<code class="fe mw mx my mz b">/definitions</code>文件夹来存储我们的定义文件，并创建一个包含以下内容的<code class="fe mw mx my mz b">dogs.d.ts</code>文件，现在我们有了一个简单的dog对象表示。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="d90e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">创建我们的狗数据库</h1><p id="3dea" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">为了简单起见，我们将创建一个小的内存结构来存储我们的狗和它们的信息，以便Next.js可以访问它们并预先呈现所有的页面。</p><p id="d144" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们创建一个<code class="fe mw mx my mz b">/db</code>文件夹，在这里我们可以存储所有内存中的数据结构，以便于访问。在里面，我们将创建一个<code class="fe mw mx my mz b">dogs.ts</code>文件，并使用我们之前创建的<code class="fe mw mx my mz b">interface</code>用一些狗的结构数据填充它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="5e43" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">更新我们的狗页面组件</h1><p id="e782" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">我们将对页面组件进行一些更新，以使其成为100%动态的，即:</p><ul class=""><li id="5972" class="md me in kq b kr ks ku kv kx nb lb nc lf nd lj mk ml mm mn bi translated">移除Next.js路由器的使用:Next.js将通过组件<code class="fe mw mx my mz b">props</code>为我们提供所有必要的信息。</li><li id="cdee" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">创建<code class="fe mw mx my mz b">getStaticPaths</code>函数来生成一个基于字符串的<strong class="kq io">路径列表</strong>，它只代表我们可用的狗。</li><li id="6a4c" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">创建<code class="fe mw mx my mz b">getStaticProps</code>函数，根据<code class="fe mw mx my mz b">params</code>中接收的信息获取相应的狗。</li><li id="ea4e" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">更新我们的页面内容，使用<code class="fe mw mx my mz b">dog</code>道具上的狗信息，它现在从<code class="fe mw mx my mz b">getStaticProps</code>接收。</li></ul><p id="7d58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们的React组件应该如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="155b" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">最后一笔:更新狗索引页面</h1><p id="b418" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">最后，让我们更新一下我们的狗的<code class="fe mw mx my mz b">index.tsx</code>页面，这样它会列出所有现存的狗，并链接到它们各自的页面。</p><p id="0da1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样的原则也适用于这里，但是因为它只是一个非动态页面，所以我们只使用<code class="fe mw mx my mz b">getStaticProps</code>并将狗列表作为<code class="fe mw mx my mz b">props</code>传递给页面，以便它可以呈现列表。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="109f" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">决赛成绩</h1><p id="0ed7" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">最后，您的应用程序应该看起来像这样。相当整洁！😎</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/0302cf0d643d1f9b0acb8d0d2f657b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bspai8AkxBNusIL9"/></div></div></figure><h1 id="d5e5" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">结束语</h1><p id="0ad6" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">要体验静态生成的全部功能和速度，不要忘记运行<strong class="kq io"> build </strong>命令(<code class="fe mw mx my mz b">npm run build</code>)，然后运行<strong class="kq io"> serving </strong> ( <code class="fe mw mx my mz b">npm run start</code>)生成的文件。这就是页面在生产环境中的服务方式，并由某个CDN进行缓存。</p><p id="ac9e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe mw mx my mz b">npm run dev</code>模式下运行项目将总是根据每个请求构建所有页面。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/1fed51db7f961d09c97404b21fed23c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eqC6qtdsGOa_9nDU"/></div></div></figure><p id="5e6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意Next.js如何检测哪些页面是静态的并依赖于外部数据，从而准确地生成由内存数据库定义的路径。</p><p id="19cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你遇到任何麻烦，请随时在<a class="ae lk" href="https://twitter.com/igorasilveira" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我，我的DMs永远是开放的。</p><p id="5492" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">下一步:</strong>请关注我接下来的Next.js教程，我们将在Next.js领域进行更多讨论！如果你不想错过任何教程，请通过<a class="ae lk" href="https://www.getrevue.co/profile/igorasilveira" rel="noopener ugc nofollow" target="_blank">点击这里</a>注册我的时事通讯。</p><p id="aab5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ne">更多内容看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">说白了就是</em> </strong> </a> <em class="ne">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">免费周报</em> </strong> </a> <em class="ne">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ne">Twitter</em></strong></a><em class="ne">和</em><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ne">LinkedIn</em></strong></a><em class="ne">。查看我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">社区不和谐</em> </strong> </a> <em class="ne">加入我们的</em> <a class="ae lk" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">人才集体</em> </strong> </a> <em class="ne">。</em></p></div></div>    
</body>
</html>