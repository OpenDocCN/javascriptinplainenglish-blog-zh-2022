<html>
<head>
<title>One Thing to Know to Manage Your Database With Sequelize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Sequelize管理数据库需要知道的一件事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/one-thing-to-know-when-managing-your-database-with-sequelize-a52f937d423d?source=collection_archive---------5-----------------------#2022-08-10">https://javascript.plainenglish.io/one-thing-to-know-when-managing-your-database-with-sequelize-a52f937d423d?source=collection_archive---------5-----------------------#2022-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="604d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">见解和技巧，使您的序列使用应用程序更健壮，不受竞争条件的影响。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4eed007945685f03872a8e4f8d7015a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXUN487eDmH6j03dYHNDkQ.png"/></div></div></figure><p id="c640" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最近，当我试图访问一个并发应用程序中的PostgreSQL数据库时，比如Node.js express服务器，我偶然发现了一个特别严重的问题。这个特殊的问题导致了安全相关代码中令人讨厌的竞争情况。Sequelize提供了<a class="ae lk" href="https://sequelize.org/docs/v6/other-topics/transactions/" rel="noopener ugc nofollow" target="_blank">事务和锁</a>来确保在我们的应用程序中没有任何虚假的事情发生，但是这些特性很难使用并且没有很好的文档记录。出于这个原因，我想为您提供一些见解和技巧，让您使用序列的应用程序更加健壮，不受竞争条件的影响。</p><p id="9c0a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面的给出了我遇到的问题的代码示例<a class="ae lk" href="https://schneider-lukas.com/blog/sequelize-transactions-and-locks-for-preventing-race-conditions#server-example" rel="noopener ugc nofollow" target="_blank">。该路由接受将被验证的电话号码。我们首先检查电话号码是否已经在过去15分钟内提交，以进行验证。如果是这种情况，我们会增加发起次数，这样用户在给定的时间窗口内发起同一封邮件的次数就不会超过10次。如果没有，我们在数据库中插入一个新条目。在这两种情况下，我们随后通过SMS发送验证码，并将验证ID返回给应用程序。</a></p><p id="c13b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这都是非常标准的代码。但问题是，如果一个用户快速提交多个请求，他可以躲过10次以上的初始化。这个错误是由于两个请求都可能在它们中的任何一个设法修改条目或创建新条目之前从数据库中读取phoneVerification条目。这种错误被称为<a class="ae lk" href="https://www.postgresql.org/docs/current/transaction-iso.html" rel="noopener ugc nofollow" target="_blank">序列化异常</a>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ll"><img src="../Images/753f16b3b9a853f00b16727d62dabbdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozK-7PhDwk_ywuhYv1Y4GQ.jpeg"/></div></div></figure><p id="cdc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了解决这个问题，我们希望使用Sequelize的事务和锁特性，如下一个代码示例中的<a class="ae lk" href="https://schneider-lukas.com/blog/sequelize-transactions-and-locks-for-preventing-race-conditions#lock-example" rel="noopener ugc nofollow" target="_blank">所示。在大多数情况下，使用Sequelize提供的锁完全没问题。但是锁只对现有的行起作用，对我们将来可能想要创建的行不起作用。并且由于用于电话验证的表条目可能在路由的开始处不存在，所以我们可能无法锁定它。</a></p><p id="dfbb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">克服这个问题的一个方法是<a class="ae lk" href="https://sequelize.org/docs/v6/other-topics/transactions/#isolation-levels" rel="noopener ugc nofollow" target="_blank">配置Sequelize使用SERIALIZABLE作为隔离级别</a>。虽然这样做效果很好，但每次违反隔离时都会导致异常。代码中必须注意这一点，如果发生异常，必须重新执行查询。因为这需要*大量*的代码更改，并且引入了各种各样的新挑战，所以这对我来说不是一个可行的解决方案。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lm"><img src="../Images/b59d29ae78257b07281c77f95b68a6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wXRQnDRZULSru2rbpvT-g.jpeg"/></div></div></figure><p id="f453" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二种方法，也是我选择的方法，是简单地锁定整个表。现在，Sequelize只允许您执行行级锁。这意味着您只能锁定某一行(并且该行必须已经存在)。但是幸运的是，我们可以用Sequelize执行<a class="ae lk" href="https://sequelize.org/docs/v6/core-concepts/raw-queries/" rel="noopener ugc nofollow" target="_blank">原始查询</a>。这个补丁只是要求我们在事务开始时锁定表，一旦事务被提交(或回滚)，锁就会被释放。你可以在下面找到最终的工作代码<a class="ae lk" href="https://schneider-lukas.com/blog/sequelize-transactions-and-locks-for-preventing-race-conditions#final-example" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="60a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作为最后的警告，您应该谨慎使用表锁！它们会降低应用程序代码的速度，因为它们锁定了整个表，如果不小心的话，甚至会导致死锁。在大多数情况下，如果您使用PostgreSQL，您可能希望使用Sequelize完全支持的<a class="ae lk" href="https://sequelize.org/docs/v6/other-topics/transactions/#locks" rel="noopener ugc nofollow" target="_blank">行级锁</a>，或者使用<a class="ae lk" href="https://www.postgresql.org/docs/current/explicit-locking.html#ADVISORY-LOCKS" rel="noopener ugc nofollow" target="_blank">咨询锁</a>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ln"><img src="../Images/b74b883740193ee3b2f1caca0d273434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zr0h9ToWl6mACZaFL-65hw.jpeg"/></div></div></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="02fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lv">原载于</em><a class="ae lk" href="https://schneider-lukas.com/blog/sequelize-transactions-and-locks-for-preventing-race-conditions" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://schneider-lukas.com</em></a><em class="lv">。</em></p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="f7ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lv">更多内容请看</em><a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lv">plain English . io</em></strong></a><em class="lv">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lv">免费周报</em> </strong> </a> <em class="lv">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lv">Twitter</em></strong></a><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lv">LinkedIn</em></strong></a><em class="lv">，以及</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lv">不和</em> </strong> </a> <em class="lv">。</em></p></div></div>    
</body>
</html>