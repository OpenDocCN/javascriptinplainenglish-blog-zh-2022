<html>
<head>
<title>The Fundamentals of TypeScript, in Increasing Levels of Difficulty</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿的基础，难度逐渐增加</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-fundamentals-of-typescript-in-increasing-levels-of-difficulty-c54bab69fbb9?source=collection_archive---------11-----------------------#2022-01-05">https://javascript.plainenglish.io/the-fundamentals-of-typescript-in-increasing-levels-of-difficulty-c54bab69fbb9?source=collection_archive---------11-----------------------#2022-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/05db14bcadd17daafb62c6915466e932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSMthMWomFZgqXr7B1q9Zw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: Wikimedia Commons</figcaption></figure><p id="0801" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当TypeScript在近十年前首次发布时，几乎所有使用它的开发人员都是从JavaScript过渡而来的。即使在今天，大多数使用TypeScript的开发人员都是在JavaScript之后或在JavaScript环境中学习这种语言的。毕竟，这是自然的方法。</p><p id="60dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是这种方法有一个关键问题:JavaScript中的类型不同于TypeScript中的类型。当您在JavaScript环境中学习TypeScript时，很难对类型的基础有很强的直觉。</p><p id="1268" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我们将更仔细地研究TypeScript，从基础开始，并有意识地向更健壮的设计模式前进。在每一步，我们将深入研究基础知识，以帮助培养对更复杂类型的直觉。</p><p id="7a27" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我写这篇文章的目的是让那些从未使用过TypeScript的人也能接触到它(有耐心，可能还会搜索一下),同时让那些每天使用它的人也能感受到它的趣味性和快节奏。</p><h1 id="87c4" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">基元</h1><p id="972f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">您可能不会对如何声明类型化变量感到惊讶:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="778e" class="mm lb iq mi b gy mn mo l mp mq">const query: string;</span></pre><p id="1b83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是很容易忘记即使是最简单的TypeScript语句实际上是如何在幕后工作的。</p><p id="6470" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不直接解释TypeScript。相反，它被转换成JavaScript，在此过程中所有类型注释都被删除。在执行时，就解释器所知，变量没有类型——只有它们的值有。保存数字的变量可以被设置为保存一个字符串，或者一个函数，或者什么都不保存。在运行时，你所有的辛苦工作都被扔出了窗外。</p><p id="c11d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这给我们带来了TypeScript最基本的规则之一:<strong class="ke ir">类型永远不会影响代码的执行，JavaScript中的运行时类型与TypeScript中的类型有着本质的区别。</strong>如果不完全吸收这一原则，你就无法开发或调试TypeScript应用程序。</p><p id="fb6b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，TypeScript开发的最大挑战之一是理解何时可以在运行时确定变量的类型，并知道该类型的精度。没有这些信息，您就不能分配正确的类型，或者根本不能分配任何类型。</p><h1 id="130a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">并集和交集</h1><p id="7c84" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><strong class="ke ir">TypeScript中的类型只不过是可能值的集合</strong>。例如，<code class="fe mr ms mt mi b">boolean</code>类型是包含值<code class="fe mr ms mt mi b">true</code>和<code class="fe mr ms mt mi b">false</code>的集合。</p><p id="057c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一些类型代表(实际上)无限大的集合，比如<code class="fe mr ms mt mi b">string</code>和<code class="fe mr ms mt mi b">number</code>。</p><p id="e83f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">而且甚至还有一种代表空集的类型:<code class="fe mr ms mt mi b">never</code>。没有什么可以被指定为<code class="fe mr ms mt mi b">never</code>类型。我们会深入探讨你为什么想这么做。</p><p id="3a02" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为类型是集合，我们可以考虑使用两个基本的集合操作来操作类型:并集和交集。两个集合的<strong class="ke ir">并</strong>是存在于<em class="mu">或</em>集合中的所有元素的集合。两个集合的<strong class="ke ir">交集</strong>是两个集合<em class="mu">中所有元素的集合。</em></p><p id="ff1b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们在TypeScript中用<code class="fe mr ms mt mi b">|</code>表示并集，用<code class="fe mr ms mt mi b">&amp;</code>表示交集。让我们看一些例子。</p><p id="3b49" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们这样定义一个类型:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="21de" class="mm lb iq mi b gy mn mo l mp mq">type DiceValues = 1 | 2 | 3 | 4 | 5 | 6;</span></pre><p id="cce9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">记住:类型只是一组值。类型<code class="fe mr ms mt mi b">1</code>是单个值的集合:数字<code class="fe mr ms mt mi b">1</code>。(原语既可以是类型，也可以是值；不要让这个迷惑你。)</p><p id="63af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，<code class="fe mr ms mt mi b">1 | 2</code>是类型<code class="fe mr ms mt mi b">1</code>和<code class="fe mr ms mt mi b">2</code>的并集，而类型<code class="fe mr ms mt mi b">DiceValues</code>代表了在6面骰子上可能出现的所有值。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3d8f" class="mm lb iq mi b gy mn mo l mp mq">type EvenValues = 2 | 4 | 6;<br/>type OddValues  = 1 | 3 | 5;<br/>type PrimeValues = 2 | 3 | 5;</span></pre><p id="3ba7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了这些类型，我们可以对它们执行有趣的操作:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e01f" class="mm lb iq mi b gy mn mo l mp mq">type A = EvenValues | OddValues</span></pre><p id="b48d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">类型<code class="fe mr ms mt mi b">A</code>相当于<code class="fe mr ms mt mi b">DiceValues</code>。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a697" class="mm lb iq mi b gy mn mo l mp mq">type B = EvenValues &amp; OddValues</span></pre><p id="1da9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个数不能既是偶数又是奇数。因此，类型<code class="fe mr ms mt mi b">B</code>相当于<code class="fe mr ms mt mi b">never</code>。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e619" class="mm lb iq mi b gy mn mo l mp mq">type C = OddValues &amp; PrimeValues;</span></pre><p id="1639" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">类型<code class="fe mr ms mt mi b">C</code>相当于<code class="fe mr ms mt mi b">3 | 5</code>。</p><h1 id="ac07" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">并集和交集-与对象</h1><p id="e015" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">对象是JavaScript的基础。对象只不过是键到值的映射。当所有的键和值都是同一类型时，我们可以使用<code class="fe mr ms mt mi b">Record</code>实用程序类型来表示:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="d8a0" class="mm lb iq mi b gy mn mo l mp mq">type WordsToLengths = Record&lt;string, number&gt;;</span><span id="a17e" class="mm lb iq mi b gy mv mo l mp mq">const wordsToLengths: WordsToLengths = {<br/>  "ruler": 5,<br/>  "file": 4,<br/>  "": 0,<br/>}</span></pre><p id="fe16" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很简单。但是JavaScript中的对象并不总是像字典一样结构化。键可以是字符串或数字，值可以是任何类型——键和值的类型甚至可以在同一个对象中不一致，就像在JSON对象中一样。</p><p id="1451" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要定义更复杂对象的类型，我们可以这样做:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="571f" class="mm lb iq mi b gy mn mo l mp mq">type User = {<br/>  id: number;<br/>  email: string;<br/>  name: string;<br/>  hasSignedIn: boolean;<br/>}</span><span id="216d" class="mm lb iq mi b gy mv mo l mp mq">type Guest = {<br/>  name: string;<br/>  ip: string;<br/>}</span></pre><p id="1f0a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样，这些类型是不言自明的。但是<code class="fe mr ms mt mi b">|</code>和<code class="fe mr ms mt mi b">&amp;</code>操作符如何处理这些类型呢？</p><p id="4d55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">记住类型<code class="fe mr ms mt mi b">User</code>和<code class="fe mr ms mt mi b">Guest</code>只是表示满足它们各自形状的所有可能值的集合。因此，<code class="fe mr ms mt mi b">User | Guest</code>是满足任一形状的对象集合。具体来说，这意味着什么？</p><p id="61fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们知道任何类型为<code class="fe mr ms mt mi b">User | Guest</code>的值都必须有一个值为<code class="fe mr ms mt mi b">string</code>的<code class="fe mr ms mt mi b">name</code>属性。我们知道它可能有一个<code class="fe mr ms mt mi b">ip</code>，也可能有一个<code class="fe mr ms mt mi b">email</code>、<code class="fe mr ms mt mi b">id</code>和<code class="fe mr ms mt mi b">hasSignedIn</code>；这些情况中至少有一个必须是真的。</p><p id="ee81" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">路口呢？嗯，<code class="fe mr ms mt mi b">User &amp; Guest</code>是同时满足<em class="mu"/><code class="fe mr ms mt mi b">User</code>形状和<code class="fe mr ms mt mi b">Guest</code>形状的对象集合。您可以添加任何您想要的任意的、不相关的属性，只要您拥有由<code class="fe mr ms mt mi b">User</code>和<code class="fe mr ms mt mi b">Guest</code>指定的属性。例如:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="72e5" class="mm lb iq mi b gy mn mo l mp mq">const userAndGuest: User &amp; Guest = {<br/>  id: 5,<br/>  name: "John",<br/>  email: "john@doe.com",<br/>  hasSignedIn: true,<br/>  ip: "127.0.0.1",<br/>  age: 80,<br/>}</span></pre><p id="9c2f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一般来说，当使用<code class="fe mr ms mt mi b">|</code>和<code class="fe mr ms mt mi b">&amp;</code>操作符时，将类型视为集合，并将并集和交集视为对这些集合的操作。</p><h1 id="3a58" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">泛型和“extends”关键字</h1><p id="9919" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">像大多数其他类型化语言一样，TypeScript支持泛型。你可以认为泛型是类型的一个函数；将一种类型传递给另一种类型来创建新类型。</p><p id="47a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，我们可能有一个通用的<code class="fe mr ms mt mi b">Action</code>类型:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1ab2" class="mm lb iq mi b gy mn mo l mp mq">type Action&lt;PAYLOAD&gt; = {<br/>  name: string;<br/>  payload: PAYLOAD;<br/>}</span><span id="6ac5" class="mm lb iq mi b gy mv mo l mp mq">const setAge: Action&lt;number&gt; = {<br/>  name: "setAge",<br/>  payload: 5,<br/>}</span></pre><p id="d0a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以将泛型类型<code class="fe mr ms mt mi b">PAYLOAD</code>约束为某种类型:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="af76" class="mm lb iq mi b gy mn mo l mp mq">type Action&lt;PAYLOAD extends number | string&gt; = {<br/>  name: string;<br/>  payload: PAYLOAD;<br/>}</span></pre><p id="b7ad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，<code class="fe mr ms mt mi b">"hello"</code>或<code class="fe mr ms mt mi b">5</code>或<code class="fe mr ms mt mi b">DiceValues</code>都是<code class="fe mr ms mt mi b">PAYLOAD</code>的有效类型，因为<code class="fe mr ms mt mi b">"hello”</code>扩展了<code class="fe mr ms mt mi b">string</code>而<code class="fe mr ms mt mi b">5</code>扩展了<code class="fe mr ms mt mi b">number</code>。例如，<code class="fe mr ms mt mi b">never</code>和<code class="fe mr ms mt mi b">true</code>类型都没有扩展。</p><p id="82e2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">乍一看，这似乎违反直觉:为什么类型<code class="fe mr ms mt mi b">"hello"</code>扩展了类型<code class="fe mr ms mt mi b">string</code>？难道不应该反过来吗？</p><p id="f429" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mr ms mt mi b">extends</code>可以认为是一个“是一个”的关系:<code class="fe mr ms mt mi b">"hello"</code>是一个<code class="fe mr ms mt mi b">string</code>，<code class="fe mr ms mt mi b">5</code>是一个<code class="fe mr ms mt mi b">DiceValues</code>。但是我们知道所有的类型都是集合，所以<code class="fe mr ms mt mi b">extends</code>关键字在集合论中一定有一些类比。这是什么？</p><p id="8a87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果类型<code class="fe mr ms mt mi b">A</code>扩展了<code class="fe mr ms mt mi b">B</code>，这意味着由类型<code class="fe mr ms mt mi b">A</code>表示的所有可能值也在类型<code class="fe mr ms mt mi b">B</code>中。这保证了我们可以对类型为<code class="fe mr ms mt mi b">B</code>(在本例中为<code class="fe mr ms mt mi b">number | string</code>)的值进行的任何操作也可以对传递给<code class="fe mr ms mt mi b">Action</code>的泛型类型的值进行。</p><p id="db92" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用集合的术语来说，这叫做子集。如果<code class="fe mr ms mt mi b">A</code>是<code class="fe mr ms mt mi b">B</code>的子集，则<code class="fe mr ms mt mi b">A</code>扩展<code class="fe mr ms mt mi b">B</code>。选择这个词是违反直觉的，但是将类型看作集合会使事情更容易推理。</p><h1 id="3321" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">条件类型和提取</h1><p id="876e" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">回想一下上面的<code class="fe mr ms mt mi b">Action</code>定义:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f79a" class="mm lb iq mi b gy mn mo l mp mq">type Action&lt;PAYLOAD extends number | string&gt; = {<br/>  name: string;<br/>  payload: PAYLOAD;<br/>}</span></pre><p id="b63b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设给了我们一个<code class="fe mr ms mt mi b">const a: Action&lt;any&gt;</code>，我们想知道<code class="fe mr ms mt mi b">a</code>的有效载荷类型。为了提取这个泛型类型，我们使用了一种叫做条件类型的东西。</p><p id="57e2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面，我们使用了<code class="fe mr ms mt mi b">extends</code>关键字来约束泛型类型——现在，我们可以反过来，使用相同的关键字来检查类型是否满足约束:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f7ee" class="mm lb iq mi b gy mn mo l mp mq">type PayloadOfAction&lt;A extends Action&lt;any&gt;&gt; = <br/>    A extends Action&lt;string&gt; ? string : number;</span></pre><p id="10db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种类型就像一个函数:它接受一个<code class="fe mr ms mt mi b">Action&lt;P&gt;</code>并返回<code class="fe mr ms mt mi b">P</code>。</p><p id="ff78" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它之所以有效，只是因为我们知道<code class="fe mr ms mt mi b">P</code>一定是<code class="fe mr ms mt mi b">number | string</code>。我们检查一下<code class="fe mr ms mt mi b">A extends Action&lt;string&gt;</code>；如果是，我们知道<code class="fe mr ms mt mi b">P</code>一定是字符串，如果不是，一定是数字。</p><p id="b5de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是如果有两种以上的可能性呢？假设我们从<code class="fe mr ms mt mi b">Action</code>类型中移除了通用约束:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8ef7" class="mm lb iq mi b gy mn mo l mp mq">type Action&lt;PAYLOAD&gt; = {<br/>  name: string;<br/>  payload: PAYLOAD;<br/>}</span></pre><p id="e506" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，<code class="fe mr ms mt mi b">PAYLOAD</code>可以是任何类型。如何用条件类型提取呢？</p><p id="6f61" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输入<code class="fe mr ms mt mi b">infer</code>关键字。在条件类型内部，我们可以使用<code class="fe mr ms mt mi b">infer</code>来要求TypeScript给出确切的泛型类型:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="592a" class="mm lb iq mi b gy mn mo l mp mq">type PayloadOfAction&lt;A extends Action&lt;any&gt;&gt; = <br/>    A extends Action&lt;infer P&gt; ? P : never;</span></pre><p id="4b8e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们遇到了一个实际使用<code class="fe mr ms mt mi b">never</code>类型的例子。<code class="fe mr ms mt mi b">A</code>将<em class="mu">总是</em>扩展<code class="fe mr ms mt mi b">Action&lt;infer P&gt;</code>，因为<code class="fe mr ms mt mi b">infer</code>关键字可以推断任何类型。因此，<code class="fe mr ms mt mi b">PayloadOfAction</code>将总是返回<code class="fe mr ms mt mi b">Action</code>的确切有效载荷类型。</p><p id="2685" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mr ms mt mi b">infer</code>只能在条件类型中使用，所以即使这种构造看起来不自然，使用<code class="fe mr ms mt mi b">never</code>是直接提取泛型类型的唯一方法。</p><h1 id="7aa6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">映射类型</h1><p id="16dc" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">从上面回忆我们的<code class="fe mr ms mt mi b">Guest</code>式:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8121" class="mm lb iq mi b gy mn mo l mp mq">type Guest = {<br/>  name: string;<br/>  ip: string;<br/>}</span></pre><p id="f549" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们有一个对象将客人的IP映射到姓名:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0827" class="mm lb iq mi b gy mn mo l mp mq">const ipsToNames = {<br/>  "127.0.0.1": "John",<br/>  "124.70.8.54": "Susan",<br/>  "1.1.1.1": "Alex",<br/>}</span></pre><p id="5604" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们想转换这个映射，使其将相同的IP映射到<code class="fe mr ms mt mi b">Guest</code>而不是名称，该怎么办？转换后的地图将如下所示:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c13d" class="mm lb iq mi b gy mn mo l mp mq">const transformedMap = {<br/>  "127.0.0.1": {<br/>    ip: "127.0.0.1",<br/>    name: "John",<br/>  },<br/>  "124.70.8.54": {<br/>    ip: "124.70.8.54",<br/>    name: "Susan",<br/>  },<br/>  "1.1.1.1": {<br/>    ip: "1.1.1.1",<br/>    name: "Alex",<br/>  },<br/>}</span></pre><p id="1ad8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果没有严格的类型，我们很容易忘记包含一个IP，或者添加一个额外的IP，或者输入错误的IP。我们希望在原始地图的基础上键入转换后的地图，以确保我们拥有完全相同的键:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="42ef" class="mm lb iq mi b gy mn mo l mp mq">type IPsToGuests&lt;M extends Record&lt;string, string&gt;&gt; = {<br/>  [KEY in keyof M]: Guest<br/>}</span></pre><p id="a8bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通用类型<code class="fe mr ms mt mi b">M</code>是原图的类型，是一个<code class="fe mr ms mt mi b">Record&lt;string, string&gt;</code>。</p><p id="7a7c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在可以给<code class="fe mr ms mt mi b">transformedMap</code>分配类型<code class="fe mr ms mt mi b">IPsToGuests&lt;typeof ipsToNames&gt;</code>。这将确保转换后的贴图具有与原始贴图完全相同的键。</p><p id="27fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是有一个问题。<code class="fe mr ms mt mi b">IPsToGuests</code>只是约束新映射的<em class="mu">键</em>——对象的值必须是<code class="fe mr ms mt mi b">Guest</code> s，但不一定是正确的IP或名称。例如，我们可以交换约翰和苏珊的来宾对象:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="96e9" class="mm lb iq mi b gy mn mo l mp mq">const transformedMap = {<br/>  "127.0.0.1": {<br/>    ip: "124.70.8.54",<br/>    name: "Susan",<br/>  },<br/>  "124.70.8.54": {<br/>    ip: "127.0.0.1",<br/>    name: "John",<br/>  },<br/>  "1.1.1.1": {<br/>    ip: "1.1.1.1",<br/>    name: "Alex",<br/>  },<br/>}</span></pre><p id="6ca8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们希望确保每个<code class="fe mr ms mt mi b">Guest</code>值都有相同的IP作为它的键，并且客人的名字是基于原始地图中相应的名字。</p><p id="00ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为此，我们首先使<code class="fe mr ms mt mi b">Guest</code>成为泛型，因为我们需要对它的属性引入特定的约束:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ccd1" class="mm lb iq mi b gy mn mo l mp mq">type Guest&lt;IP extends string, NAME extends string&gt; = {<br/>  ip: IP,<br/>  name: NAME,<br/>}</span></pre><p id="543c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们可以改进我们对<code class="fe mr ms mt mi b">IPsToGuests</code>的定义:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="d705" class="mm lb iq mi b gy mn mo l mp mq">type IPsToGuests&lt;M&gt; = {<br/>  [KEY in keyof M]: Guest&lt;KEY, M[KEY]&gt;<br/>}</span></pre><p id="26ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这告诉TypeScript,<code class="fe mr ms mt mi b">IP</code>类型应该匹配键，而<code class="fe mr ms mt mi b">NAME</code>应该匹配原始映射中的相应值。</p><p id="d3d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以更进一步。假设我们想要生成一个类型<code class="fe mr ms mt mi b">AllGuests</code>，它代表来自<code class="fe mr ms mt mi b">ipsToNames</code>的所有可能的<code class="fe mr ms mt mi b">Guest</code>类型:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="2cc2" class="mm lb iq mi b gy mn mo l mp mq">type John = {<br/>  ip: "127.0.0.1",<br/>  name: "John",<br/>}</span><span id="3281" class="mm lb iq mi b gy mv mo l mp mq">type Susan = {<br/>  ip: "124.70.8.54",<br/>  name: "Susan",<br/>}</span><span id="ad95" class="mm lb iq mi b gy mv mo l mp mq">type Alex = {<br/>  ip: "1.1.1.1",<br/>  name: "Alex",<br/>}</span><span id="6025" class="mm lb iq mi b gy mv mo l mp mq">type AllGuests = John | Susan | Alex;</span></pre><p id="bc99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，我们希望能够基于我们最初的<code class="fe mr ms mt mi b">ipsToNames</code>类型自动生成这个类型。</p><p id="f4b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以使用我们的<code class="fe mr ms mt mi b">IPToGuests</code>类型来帮助我们。我们想要的是<code class="fe mr ms mt mi b">IPsToGuests&lt;M&gt;</code>中所有<em class="mu">值</em>的联合。这很简单——只需通过类型本身的键来索引类型:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8d0b" class="mm lb iq mi b gy mn mo l mp mq">type AllGuests&lt;M&gt; = IPsToGuests&lt;M&gt;[keyof IPsToGuests&lt;M&gt;];</span></pre><h1 id="1c7f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="b639" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">TypeScript拥有令人印象深刻的处理复杂类型的能力。然而，如果没有很好地掌握基础知识，很容易迷失在关键字、类型操作符和泛型中。深入思考甚至最简单的类型有助于逐渐建立对更复杂类型的直觉，这有助于您构建更健壮和可伸缩的TypeScript应用程序。</p><p id="41a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mu">更多内容看</em> <strong class="ke ir"> <em class="mu"> </em> </strong> <a class="ae mw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="mu">说白了. io </em> </strong> </a> <strong class="ke ir"> <em class="mu">。</em> </strong> <em class="mu">报名参加我们的</em> <a class="ae mw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="mu">免费周报</em> </strong> </a> <strong class="ke ir"> <em class="mu">。</em> </strong> <em class="mu">在我们的</em><strong class="ke ir"><em class="mu"/></strong><a class="ae mw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mu">社区不和谐</em> </strong> </a> <strong class="ke ir"> <em class="mu">中获取独家写作机会和建议。</em> </strong></p></div></div>    
</body>
</html>