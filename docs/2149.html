<html>
<head>
<title>Stop Building REST APIs for Your Next.js Apps, Use tRPC Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止为你的Next.js应用构建REST APIs，改用tRPC</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-building-rest-apis-for-your-next-js-apps-use-trpc-instead-4b78e8f4d331?source=collection_archive---------0-----------------------#2022-05-18">https://javascript.plainenglish.io/stop-building-rest-apis-for-your-next-js-apps-use-trpc-instead-4b78e8f4d331?source=collection_archive---------0-----------------------#2022-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b783" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解tRPC:一个构建具有端到端类型安全的API的工具。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6ecd1862e06eb409d84ca79c7518bace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fAq2mqRZwrB6zkzx3g7BA.png"/></div></div></figure><p id="6c89" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我第一次开始开发全栈应用程序时，我正在构建和管理自己的REST APIs。我从用Spring在Java中构建它们开始，然后转移到。NET，然后用Express转到Node.js，甚至还稍微涉猎了一点Django。说用不同的语言管理两个不同的项目(有时)很麻烦是有点轻描淡写。</p><p id="a391" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">tRPC是一个构建端到端类型安全API的工具。tRPC允许您非常快速地为Next.js、React和Node.js应用程序创建健壮且可伸缩的后端。</p><p id="076d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我激起你的兴趣了吗？那我鼓励你继续读下去！在本文中，我们将了解tRPC是什么，以及如何在Next.js中设置和使用它。</p><h1 id="17f4" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">tRPC是什么？</h1><p id="e520" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">正如我前面提到的，tRPC允许您为Next.js、React和Node.js应用程序构建完全类型安全的API。借助其端到端的类型安全，您能够在编译时而不是运行时捕获前端和后端之间的错误。因为您只使用类型声明，而不导入实际的服务器代码，所以您的构建保持小而快。</p><h1 id="e6ad" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">安装tRPC</h1><p id="7fa3" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">安装tRPC非常简单。有几个我们需要的软件包，既有tRPC本身的，也有另外两个会让我们的生活变得更容易的。在Next.js项目中，运行以下命令来安装依赖项。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="ef10" class="mm ll in mi b gy mn mo l mp mq">$ yarn add <a class="ae mr" href="http://twitter.com/trpc/client" rel="noopener ugc nofollow" target="_blank">@trpc/client</a> <a class="ae mr" href="http://twitter.com/trpc/server" rel="noopener ugc nofollow" target="_blank">@trpc/server</a> <a class="ae mr" href="http://twitter.com/trpc/react" rel="noopener ugc nofollow" target="_blank">@trpc/react</a> <a class="ae mr" href="http://twitter.com/trpc/next" rel="noopener ugc nofollow" target="_blank">@trpc/next</a> zod react-query</span></pre><p id="5bf1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">tRPC是建立在“react-query”之上的，react-query是一个用于获取、缓存和管理数据的包，不需要弄乱任何全局状态。我们还使用“zod”来帮助我们的模式和输入验证。</p><p id="df68" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要做的下一件事是确保在我们的“tsconfig.json”中启用严格模式</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="3c30" class="mm ll in mi b gy mn mo l mp mq">json<br/>// tsconfig.json<br/>{<br/> // …<br/> “compilerOptions”: {<br/> // …<br/> “strict”: true<br/> }<br/>}</span></pre><p id="f151" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这并不是专门针对tRPC的，而是为了让‘zod’正确运行。zod也不是使用tRPC的必要条件，但是，正如你稍后会看到的，它真的很好地配合了tRPC，使我们的生活变得更容易。</p><h1 id="6a40" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">创建我们的服务器</h1><p id="892d" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">在我们的项目根目录中，或者如果你使用Next.js的话，在“/src”文件夹中，创建一个名为“/server”的新文件夹。这个文件夹将包含我们的tRPC上下文、路由器和我们实际的API路由。</p><p id="0dd9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里需要注意的一点是，我们的服务器将被部署为Next.js API路由。这段代码是作为服务器端的包发布的，不会以任何方式影响我们的客户端包的大小。</p><p id="45a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在[next . js Docs](<a class="ae mr" href="https://nextjs.org/docs/api-routes/introduction" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/docs/api-routes/introduction</a>)中阅读更多关于Next.js API路线的内容</p><h2 id="cf1b" class="mm ll in bd lm ms mt dn lq mu mv dp lu kx mw mx lw lb my mz ly lf na nb ma nc bi translated">配置我们的上下文</h2><p id="6ac1" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们首先要创建的是我们的上下文。我们的上下文允许我们将请求数据传递给路由中的每个解析器。要创建新的上下文，让我们创建一个名为“context.ts”的文件，并向其中添加以下代码。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="f132" class="mm ll in mi b gy mn mo l mp mq">// server/context.ts<br/>import { CreateNextContextOptions } from “<a class="ae mr" href="http://twitter.com/trpc/server" rel="noopener ugc nofollow" target="_blank">@trpc/server</a>/adapters/next”;<br/>import { inferAsyncReturnType } from “<a class="ae mr" href="http://twitter.com/trpc/server" rel="noopener ugc nofollow" target="_blank">@trpc/server</a>”;</span><span id="34f3" class="mm ll in mi b gy nd mo l mp mq">export async function createContext(contextOptions?: CreateNextContextOptions) {<br/> const req = contextOptions?.req;<br/> const res = contextOptions?.res;</span><span id="db4a" class="mm ll in mi b gy nd mo l mp mq">return {<br/> req,<br/> res,<br/> };<br/>}</span><span id="f0c1" class="mm ll in mi b gy nd mo l mp mq">export type MyContextType = inferAsyncReturnType&lt;typeof createContext&gt;;</span></pre><p id="6832" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们只是将请求和响应传递给我们的路由。你也可以在这里添加你想传递的其他东西。Prisma客户端和NextAuth会话就是很好的例子。</p><h2 id="094d" class="mm ll in bd lm ms mt dn lq mu mv dp lu kx mw mx lw lb my mz ly lf na nb ma nc bi translated">创建简单的路由器</h2><p id="df3e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">接下来，我们继续添加一个“create-router.ts”文件。在这个文件中，我们将设置一个简单的路由器作为根。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="7b00" class="mm ll in mi b gy mn mo l mp mq"><br/>// server/create-router.ts<br/>import * as trpc from “<a class="ae mr" href="http://twitter.com/trpc/server" rel="noopener ugc nofollow" target="_blank">@trpc/server</a>”;<br/>import { MyContextType } from “./context”;</span><span id="11f1" class="mm ll in mi b gy nd mo l mp mq">export function createRouter() {<br/> return trpc.router&lt;MyContextType&gt;();<br/>}</span></pre><p id="1ab4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">像这样声明您的路由器非常有用，因为它允许您向使用您的路由器的所有路由添加定制的中间件逻辑。例如，您可以创建一个路由器来检查用户是否登录，或者用户是否有访问资源的正确权限。</p><h2 id="e795" class="mm ll in bd lm ms mt dn lq mu mv dp lu kx mw mx lw lb my mz ly lf na nb ma nc bi translated">配置我们的API路由</h2><p id="eab0" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">让我们创建一个名为“路由器”的新文件夹，并向其中添加两个文件。首先，添加一个名为` _app.ts '的文件，这个文件将作为我们的根路径。我们添加的任何新路线都将添加到此处。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="4b2a" class="mm ll in mi b gy mn mo l mp mq"><br/>// server/routers/_app.ts<br/>import { createRouter } from “../create-router”;</span><span id="b46c" class="mm ll in mi b gy nd mo l mp mq">export const appRouter = createRouter();</span><span id="3382" class="mm ll in mi b gy nd mo l mp mq">export type AppRouter = typeof appRouter;</span></pre><p id="13cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，让我们创建第二个文件，并将其命名为“nameRouter.ts”。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="1217" class="mm ll in mi b gy mn mo l mp mq"><br/>// server/routers/nameRouter.ts<br/>import { z } from “zod”;<br/>import { createRouter } from “../create-router”;</span><span id="ea3c" class="mm ll in mi b gy nd mo l mp mq">export const nameRouter = createRouter.query(“getName”, {<br/>  input: z.object({<br/>  name: z.string().nullish(),<br/> }),<br/> resolve({ input }) {<br/>  return { greeting: `Hello ${input.name}!` };<br/> },<br/>});</span></pre><p id="8ad3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">tRPC使用查询和变异来定义动作。查询用于获取数据，而变异用于创建、更新和删除数据。在上面的代码中，我们创建了一个获取名称的查询。我们的查询接受两个参数。第一个是查询名，第二个是我们的参数。对于我们的参数，我们有输入和解析。输入是可选的，而解析是必需的。Resolve是我们端点的实际实现。在我们的例子中，我们使用Zod来验证我们有一个字符串输入，我们的端点将返回一个字符串，该字符串向我们传入的任何名称问好。</p><p id="0934" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在可以跳回到' _app.ts '并在那里添加我们的路线。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="db89" class="mm ll in mi b gy mn mo l mp mq"><br/>// server/routers/_app.ts<br/>// […]<br/>import { nameRouter } from “./nameRouter”;</span><span id="ba0b" class="mm ll in mi b gy nd mo l mp mq">export const appRouter = createRouter().merge(“names.”, nameRouter);</span><span id="9aef" class="mm ll in mi b gy nd mo l mp mq">// […]</span></pre><p id="af03" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在Next.js中添加端点</p><p id="ac6c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要在Next.js中添加一个新的端点。在`/pages/api `文件夹下，在`/trpc/[trpc].ts `下创建一个新文件。您的文件夹结构应该如下所示:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="284b" class="mm ll in mi b gy mn mo l mp mq">.<br/>+ — pages<br/>| + — api<br/>| + — trpc<br/>  | + — [trpc].ts</span></pre><p id="52c3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在将以下代码添加到`[trpc].ts `:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="a4ef" class="mm ll in mi b gy mn mo l mp mq"><br/>// pages/api/trpc/[trpc].ts<br/>import { createNextApiHandler } from “<a class="ae mr" href="http://twitter.com/trpc/server" rel="noopener ugc nofollow" target="_blank">@trpc/server</a>/adapters/next”;<br/>import { appRouter } from “../../../server/routers/_app”;<br/>import { createContext } from “../../../server/context”;</span><span id="bdd4" class="mm ll in mi b gy nd mo l mp mq">export default createNextApiHandler({<br/>  router: appRouter,<br/>  createContext,<br/>  batching: {<br/>  enabled: true,<br/> },<br/>});</span></pre><p id="938d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们可以设置我们的前端了！</p><h1 id="d3b9" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">调用我们的API路线</h1><p id="b1d3" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">将我们的后端连接到我们的前端非常简单。首先，我们需要转到我们的` _app.tsx `文件，并配置tRPC和React Query。为此，我们将使用“withTrpc()”高阶组件。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="1071" class="mm ll in mi b gy mn mo l mp mq">// pages/_app.tsx<br/>// […]<br/>import { withTRPC } from “<a class="ae mr" href="http://twitter.com/trpc/next" rel="noopener ugc nofollow" target="_blank">@trpc/next</a>”;<br/>import { AppRouter } from “./api/trpc/[trpc]”;</span><span id="a6ad" class="mm ll in mi b gy nd mo l mp mq">function getBaseUrl() {<br/> if (process.browser) return “”;<br/> if (process.env.VERCEL_URL) return `<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/${process.env.VERCEL_URL}`">https://${process.env.VERCEL_URL}`</a>;</span><span id="17fa" class="mm ll in mi b gy nd mo l mp mq">return `<a class="ae mr" href="http://localhost:${process.env.PORT" rel="noopener ugc nofollow" target="_blank">http://localhost:${process.env.PORT</a> ?? 3000}`;<br/>}</span><span id="e166" class="mm ll in mi b gy nd mo l mp mq">export default withTRPC&lt;AppRouter&gt;({<br/> config({ ctx }) {<br/> const url = `${getBaseUrl()}/api/trpc`;</span><span id="fc6a" class="mm ll in mi b gy nd mo l mp mq"> return {<br/>   url,<br/>  };<br/> },<br/> ssr: true,<br/>})(MyApp);</span></pre><p id="07a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，我们需要添加一个名为utils的新文件夹和一个名为` trpc.ts '的文件</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="04c8" class="mm ll in mi b gy mn mo l mp mq"><br/>// utils/trpc.ts<br/>import { createReactQueryHooks } from “<a class="ae mr" href="http://twitter.com/trpc/react" rel="noopener ugc nofollow" target="_blank">@trpc/react</a>”;<br/>import { AppRouter } from “../server/routers/_app”;<br/>import { inferProcedureOutput } from “<a class="ae mr" href="http://twitter.com/trpc/server" rel="noopener ugc nofollow" target="_blank">@trpc/server</a>”;</span></pre><p id="6bd7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里，我们创建了一个钩子来在客户机上使用tRPC。钩子是使用我们的API的类型签名强类型化的。这就是赋予我们端到端类型安全性的“魔力”。这个钩子让我们调用我们的后端，并从中获得完全类型化的输入和输出。而且，如果您更改了一个路由名称，您将在客户端得到一个错误。很厉害。</p><p id="d302" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要做的最后一件事就是使用我们的查询。创建一个新页面，并将其命名为“name.tsx”</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="c466" class="mm ll in mi b gy mn mo l mp mq"><br/>// pages/name.tsx<br/>import { trpc } from “../utils/trpc”;</span><span id="b672" class="mm ll in mi b gy nd mo l mp mq">export default function Name() {<br/> const nameQuery = trpc.useQuery([“name.getName”, { name: “Brock” }]);</span><span id="5e8b" class="mm ll in mi b gy nd mo l mp mq">return (<br/>  &lt;&gt;<br/>   {nameQuery.data ? (<br/>    &lt;h1&gt;{nameQuery.data.greeting}&lt;/h1&gt;<br/>   ) : (<br/>    &lt;span&gt;Loading…&lt;/span&gt;<br/>   )}<br/>  &lt;/&gt;<br/> );<br/>}</span></pre><p id="0159" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，你可以把“布洛克”换成你的名字！</p><p id="f82c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们运行Next.js应用程序，前往我们的新页面。在“/name”页面上，您现在应该看到一条消息，对您输入的任何名称说“Hello”。</p><h1 id="4e78" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">结论</h1><p id="7098" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">在本文中，我们研究了tRPC是什么以及如何在Next.js应用程序中使用它。tRPC使得为您的应用程序构建API非常容易。不仅可以与Next.js一起使用，还可以与React和Node.js应用程序一起使用。更多信息，请查看[tRPC文档](<a class="ae mr" href="https://trpc.io/" rel="noopener ugc nofollow" target="_blank">https://trpc.io/</a>)。你还可以在[示例应用](【https://trpc.io/docs/example-apps】T2)页面下找到各种示例，包括Next.js和React原生应用的入门。</p><p id="391a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">大家编码快乐！</p><p id="51cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ne">更多内容看</em> <a class="ae mr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">说白了就是</em> </strong> </a> <em class="ne">。报名参加我们的</em> <a class="ae mr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">免费周报</em> </strong> </a> <em class="ne">。关注我们关于</em><a class="ae mr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ne">Twitter</em></strong></a><em class="ne">和</em><a class="ae mr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ne">LinkedIn</em></strong></a><em class="ne">。查看我们的</em> <a class="ae mr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">社区不和谐</em> </strong> </a> <em class="ne">加入我们的</em> <a class="ae mr" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">人才集体</em> </strong> </a> <em class="ne">。</em></p></div></div>    
</body>
</html>