<html>
<head>
<title>Asynchronous JavaScript: Under the Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JavaScript:幕后故事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/asynchronous-javascript-under-the-hood-d2c2462be059?source=collection_archive---------3-----------------------#2022-11-23">https://javascript.plainenglish.io/asynchronous-javascript-under-the-hood-d2c2462be059?source=collection_archive---------3-----------------------#2022-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a9ed" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">回调、承诺和异步/等待解释</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7809d1b764f4ac4ec94f42a385a0c0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RkLEowAqqlvgHve9"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@tanelah?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Taneli Lahtinen</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e534" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经学习或使用JavaScript有一段时间了，你肯定听过这个短语<code class="fe ls lt lu lv b">asynchronous</code>。</p><p id="706a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是一种异步语言，这解释了这一点。然而，这实际上意味着什么呢？我想在这篇文章中向你展示这个想法有多简单。</p><h2 id="fa28" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">同步与异步</h2><p id="9ccc" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在继续操作之前，让我们仔细看看这两个术语，同步和异步。</p><p id="12cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，JavaScript是一种单线程同步编程语言。这意味着指令只能顺序执行，不能并发执行。看看下面这段简短的代码:</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="cebe" class="my lx iq lv b be mz na l nb nc">let a = 1;<br/>let b = 2;<br/>let sum = a + b;<br/>console.log(sum);</span></pre><p id="422d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码只是将两个数字相加，并将结果记录在浏览器的控制台中。这些指令由解释程序依次执行，直到全部执行完毕。</p><p id="1d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这种方法也有缺点。假设我们想在从数据库中检索数据后，在界面上呈现大量数据。一旦解释器到达获取该数据的指令，剩余的代码就被阻止运行，直到数据被获取并返回。</p><p id="d52a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以争辩说，由于要获取的数据量并不大，所以不会花很长时间。考虑必须从多个位置收集数据的情况。当这种延迟加剧时，用户可能不希望遇到这种情况。</p><p id="5f45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，开发异步JavaScript是为了解决同步JavaScript的问题。</p><p id="30be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步编程被认为是可以现在开始，以后结束的编程。当JavaScript异步运行时，命令并不总是按顺序执行，就像我们之前看到的那样。</p><p id="992a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多年来，开发人员采用了许多不同的方法来恰当地处理这种异步行为。每一个解决方案都建立在它之前的解决方案的基础上，这样可以优化代码，如果代码变得复杂了，也更容易理解。</p><p id="107e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将回顾回调函数、承诺、异步，并等待更好地理解JavaScript的异步本质。</p><h2 id="9d76" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">JavaScript中的回调</h2><p id="3a6a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">回调是一个函数，它接收另一个函数内部的参数，然后用于执行该函数内部的任务。</p><p id="c8e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迷惑？让我们通过付诸实践来简化它。</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="f622" class="my lx iq lv b be mz na l nb nc">console.log('fired first');<br/>console.log('fired second');<br/><br/>setTimeout(()=&gt;{<br/>    console.log('fired third');<br/>},2000);<br/><br/>console.log('fired last');</span></pre><p id="82f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的示例显示了一个将信息记录到控制台的小程序。但这是一种新颖的情况。解释器将执行第一条指令，然后转到第二条指令，跳过第三条指令，执行最后一条指令。</p><p id="2025" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个名为<code class="fe ls lt lu lv b">setTimeout</code>的JavaScript函数接受两个参数。第二个参数指定另一个函数在第一个函数之后应该运行多长时间，以毫秒为单位，第一个函数是另一个函数。您现在可以清楚地看到回调在实践中是如何定义的。</p><p id="c36c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个场景中，<code class="fe ls lt lu lv b">setTimeout</code>函数必须在两秒钟(2000毫秒)后执行。想象它被移动到浏览器的另一个区域执行，而其他指令仍在执行。两秒钟后返回函数的结果。</p><p id="9dd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们在程序中运行上述代码片段，我们将看到以下内容:</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="9902" class="my lx iq lv b be mz na l nd nc">fired first<br/>fired second<br/>fired last<br/>fired third</span></pre><p id="c684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到，在<code class="fe ls lt lu lv b">setTimeout</code>函数提供其输出之前，记录了最后一个命令。假设我们使用这种技术从数据库中检索数据。当用户等待数据库调用提供结果时，执行流程不会停止。</p><p id="73cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法非常有效，但只是在一定程度上有效。在他们的代码中，开发人员偶尔需要多次调用各种源。为了进行这些调用，回调被嵌套起来，这使得它们难以理解或维护。这就是所谓的<strong class="ky ir">回调地狱</strong>。</p><p id="1a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这一问题，出现了承诺。</p><h2 id="df90" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">JavaScript中的承诺</h2><p id="035e" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我们总是听到人们许诺一些事情。JavaScript中的承诺与你的堂兄承诺给你免费的钱或一个小孩承诺不问就不再打开饼干罐的承诺有一点不同。</p><p id="61da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的上下文中，承诺指的是需要时间来完成的任务。承诺可能有两种结果:</p><p id="96e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要么我们执行并履行承诺，要么因为一路上的错误而拒绝承诺。</p><p id="4a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">承诺是为了解决回调函数的问题而产生的。promise接受两个函数作为参数。换句话说，决定和拒绝。记住成功是解决的，失败是拒绝的。</p><p id="0be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看工作中的承诺:</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="58b3" class="my lx iq lv b be mz na l nb nc">const getData = (dataEndpoint) =&gt; {<br/>   return new Promise ((resolve, reject) =&gt; {<br/>     //some request to the endpoint;<br/>     <br/>     if(request is successful){<br/>       //do something;<br/>       resolve();<br/>     }<br/>     else if(there is an error){<br/>       reject();<br/>     }<br/>   <br/>   });<br/>};</span></pre><p id="2ce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面代码中的承诺被对端点的请求所包围。正如我已经指出的，这个承诺包括决心和拒绝。</p><p id="a188" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果在调用端点之后请求成功，我们将解析承诺，并继续对答案做我们想做的任何事情。但是，如果有一个错误，保证将被丢弃。</p><p id="d45f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用承诺和一种称为承诺链的技术，回调地狱相关的问题可以被巧妙地解决。通过更少的代码和更简单的技术，您可以使用这种方式从许多端点顺序检索数据。</p><p id="7a89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有一种方法要好得多！您可能对下面的方法很熟悉，因为它是JavaScript中管理数据和API调用的首选机制。</p><h2 id="df66" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">JavaScript中的异步和等待</h2><p id="d7ab" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">问题是，用与回调相同的方式将承诺链接在一起可能会变得相当笨拙和令人费解。正因为如此，<code class="fe ls lt lu lv b">async</code>和<code class="fe ls lt lu lv b">await</code>被研发出来。</p><p id="f968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您执行以下操作来定义一个<code class="fe ls lt lu lv b">async</code>函数:</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="591c" class="my lx iq lv b be mz na l nb nc">const asyncFunc = async() =&gt; {<br/><br/>}</span></pre><p id="f9e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住，运行一个<code class="fe ls lt lu lv b">async</code>函数总是会导致一个承诺被返回。查看以下内容:</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="3067" class="my lx iq lv b be mz na l nb nc">const test = asyncFunc();<br/>console.log(test);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ce45725876df090af337f2c8fb925d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*ygk-jIX2hTSW5bg4wHuAKw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Output</figcaption></figure><p id="f267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到<code class="fe ls lt lu lv b">asyncFunc</code>通过在浏览器控制台中运行上述代码产生了一个承诺。</p><p id="0727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们真正剖析一些代码。看看下面的短文:</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="b207" class="my lx iq lv b be mz na l nb nc">const asyncFunc = async () =&gt; {<br/>	const response = await fetch(resource);<br/>   	const data = await response.json();<br/>}</span></pre><p id="906d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我前面指出的，我们使用<code class="fe ls lt lu lv b">async</code>关键字定义异步函数。那么<code class="fe ls lt lu lv b">await</code>怎么样呢？嗯，在承诺实现之前，JavaScript无法将<code class="fe ls lt lu lv b">fetch</code>绑定到响应变量。现在，在承诺实现后，可以将检索方法的结果添加到响应变量中。</p><p id="4d64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第3行，同样的事情发生了。<code class="fe ls lt lu lv b">.json</code>方法返回一个承诺，我们仍然可以使用<code class="fe ls lt lu lv b">await</code>来延迟分配，直到承诺被解决。</p><p id="6c5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">闭锁或不闭锁代码</strong></p><p id="bd78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你必须假设当我提到<strong class="ky ir">停止</strong>时，我的意思是使用Async和Await以某种方式阻止代码执行。你会问，如果我们的请求耗时太长怎么办？</p><p id="78cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不正确。尽管<code class="fe ls lt lu lv b">async</code>函数包含阻塞代码，但这与程序的执行方式无关。我们的代码继续像以前一样异步运行。话虽如此，</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="ced5" class="my lx iq lv b be mz na l nb nc">const asyncFunc = async () =&gt; {<br/>	const response = await fetch(resource);<br/>   	const data = await response.json();<br/>}<br/><br/>console.log(1);<br/>cosole.log(2);<br/><br/>asyncFunc().then(data =&gt; console.log(data));<br/><br/>console.log(3);<br/>console.log(4);</span></pre><p id="88ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述内容的输出可能会在我们浏览器的控制台中显示如下:</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="7934" class="my lx iq lv b be mz na l nd nc">1<br/>2<br/>3<br/>4<br/>data returned by asyncFunc</span></pre><p id="01a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到在调用<code class="fe ls lt lu lv b">asyncFunc</code>之后，我们的代码一直运行，直到函数准备好返回结果。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h2 id="aade" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">结论</h2><p id="280d" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">虽然我没有在本文中详细介绍这些概念，但是我想让您了解一下什么是异步JavaScript以及一些潜在的陷阱。</p><p id="85ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文仅仅触及了JavaScript这个关键组件的表面。但是我确实希望这篇文章能够简化这些想法，至少在某种程度上。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="3e85" class="my lx iq lv b be mz na l nd nc"><strong class="lv ir">Want to Connect?<br/></strong><br/>Connect with me on <a class="ae kv" href="https://www.linkedin.com/in/gouravkajal/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre><p id="91fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><p id="ddc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nm">plain English . io</em></strong></a><em class="nm">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nm">免费周报</em> </strong> </a> <em class="nm">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nm">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nm">LinkedIn</em></strong></a><em class="nm"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nm">YouTube</em></strong></a><em class="nm"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nm">不和</em> </strong> </a> <em class="nm">。对增长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nm">电路</em> </strong> </a> <em class="nm">。</em></p></div></div>    
</body>
</html>