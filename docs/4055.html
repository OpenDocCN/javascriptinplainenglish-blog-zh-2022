<html>
<head>
<title>All About React’s Proposed New use() Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React提出的新用途()钩子的所有内容</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/all-about-reacts-proposed-new-use-hook-ba468a2302f6?source=collection_archive---------0-----------------------#2022-10-21">https://javascript.plainenglish.io/all-about-reacts-proposed-new-use-hook-ba468a2302f6?source=collection_archive---------0-----------------------#2022-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="66c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对承诺的一流支持开始起作用了——这是关于它应该如何运作的建议</h2></div><p id="d2fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自React核心团队的<a class="ae lb" href="https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#example-use-in-client-components-and-hooks" rel="noopener ugc nofollow" target="_blank">功能提案在React生态系统中引起了一些反响，既吸引了对其新功能的兴奋，也引起了对其将如何实现的一些关注。在这篇文章中，我们将深入探讨这个新特性看起来像什么，它解决了什么问题，以及提出了什么问题。</a></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/98e26b26432b94a9a3646aa08694f28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n0u9Q6W4hofRPh_c"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Hooks, of the non-React variety. Photo by <a class="ae lb" href="https://unsplash.com/@polarmermaid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anne Nygård</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f72a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">RFC:对承诺的一流支持</h1><p id="e044" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这个新特性完全是为了在React中获得对承诺的“一流”支持，并在React核心贡献者的RFC(征求意见稿)中进行了描述:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#example-use-in-client-components-and-hooks" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">rfcs/0000-一级支持承诺. md at一级承诺acdlite/rfcs</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">RFC对变更做出反应。在GitHub上创建一个帐户，为acdlite/rfcs的发展做出贡献。</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng lm ms"/></div></div></a></div><p id="3777" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该文档名为“对承诺的一流支持，async/await ”,描述了将使用承诺的代码更好地集成到React组件中的新特性。</p><p id="d94c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RFC并不一定意味着某个特性将被实现——任何人都可以编写一个RFC并在React RFCs repo中打开一个pull请求。不过，在这种情况下，来自React核心贡献者并得到高级别的支持，RFC似乎有可能以这样或那样的形式被接受，并且该特性会在React的未来版本中找到自己的路。</p><h1 id="7af7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">这解决了什么问题？</h1><p id="8646" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如果您正在使用执行任何类型的服务器通信或其他异步计算的React组件，那么您当前需要使用Promises或其他类型的回调模式自己处理该行为。下面是一个典型的代码片段，用于发出服务器请求并在组件内部呈现结果:</p><pre class="ld le lf lg gt nh ni nj nk aw nl bi"><span id="e7c5" class="nm lt iq ni b gy nn no l np nq">const WidgetList = () =&gt; {<br/>  const [widgets, setWidgets] = React.useState([])</span><span id="1b2f" class="nm lt iq ni b gy nr no l np nq">  React.useEffect(() =&gt; {<br/>    widgetsAPI.get().then((r) =&gt; {<br/>      setWidgets(r)<br/>    })<br/>  }, [])</span><span id="5fee" class="nm lt iq ni b gy nr no l np nq">  return (&lt;div&gt;<br/>    {widgets.map(w =&gt; (&lt;p id={w.id}&gt;{w.name}&lt;/p&gt;))}<br/>  &lt;/div&gt;)<br/>}</span></pre><p id="6fb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们的<code class="fe ns nt nu ni b">widgetsAPI</code>调用返回一个承诺。然后我们得到调用的结果，并通过<code class="fe ns nt nu ni b">then</code>回调来设置组件状态。这是一种常见的模式，它工作得相当好——但是也相当冗长，并且随着组件的增长会使组件变得复杂。</p><p id="3ecd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从表面上看，在组件中支持承诺的最直接方式是使用JavaScript现有的async/await功能:简单地<code class="fe ns nt nu ni b">await</code>承诺并使用结果！</p><pre class="ld le lf lg gt nh ni nj nk aw nl bi"><span id="74e1" class="nm lt iq ni b gy nn no l np nq">const widgets = await widgetsAPI.get()</span></pre><p id="819d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，服务器渲染的React组件<em class="nv">将</em>支持异步<em class="nv"> </em>渲染，从而可以<code class="fe ns nt nu ni b">await</code> <em class="nv"> </em>承诺的结果完全如上图所示。</p><p id="7b45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是客户端呢？在浏览器中，React组件暂时不能被设为异步。正如现在经典的<a class="ae lb" href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" rel="noopener ugc nofollow" target="_blank">你的函数是什么颜色</a>中所描述的，我们不能在非异步函数内部调用<code class="fe ns nt nu ni b">await</code>。RFC讨论了这一限制以及支持异步客户端组件的未来计划:</p><blockquote class="nw nx ny"><p id="f827" class="kf kg nv kh b ki kj jr kk kl km ju kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">我们强烈认为不仅要支持异步服务器组件，还要支持异步客户端组件。这在技术上是可能的，但是有足够多的陷阱和警告，到目前为止，我们还不习惯将这种模式作为一般的建议。计划是在运行时实现对异步客户端组件的支持，但是在开发期间记录一个警告。文件也将阻止它们的使用。</p></blockquote><p id="dd35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在还没有异步客户端组件——但是这又会给我们带来什么呢？我们如何在客户端实现一流的承诺支持？</p><p id="9153" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案是一种新的名字很好听的钩子。</p><h1 id="61a5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">解决方案:新的React使用()钩子</h1><p id="1b26" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">客户端异步问题的解决方案是一个新的钩子，简单地命名为<code class="fe ns nt nu ni b">use()</code>。钩子的功能在实践中非常类似于<code class="fe ns nt nu ni b">await</code>，但是有一些重要的区别:</p><pre class="ld le lf lg gt nh ni nj nk aw nl bi"><span id="8f14" class="nm lt iq ni b gy nn no l np nq">const WidgetList = () =&gt; {<br/>  const widgets = use(widgetsAPI.get())</span><span id="2e6f" class="nm lt iq ni b gy nr no l np nq">  return (&lt;div&gt;<br/>    {widgets.map(w =&gt; (&lt;p id={w.id}&gt;{w.name}&lt;/p&gt;))}<br/>  &lt;/div&gt;)<br/>}</span></pre><p id="b653" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像<code class="fe ns nt nu ni b">await</code>一样，使用有效解封我们<code class="fe ns nt nu ni b">widgetsAPI</code>返回的承诺值。然而，与<code class="fe ns nt nu ni b">await</code>不同的是，当承诺被解决时，组件的执行实际上并不从相同的地方恢复。相反，<code class="fe ns nt nu ni b">use</code>抛出异常，就像<code class="fe ns nt nu ni b">React.Suspense</code>中断渲染一样。当承诺解决时，组件被<em class="nv">重新呈现:</em></p><blockquote class="nw nx ny"><p id="4b92" class="kf kg nv kh b ki kj jr kk kl km ju kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">当承诺最终解决时，React将<em class="iq">重放</em>组件的渲染。在随后的尝试中，<code class="fe ns nt nu ni b">use</code>调用将返回承诺的履行值。</p></blockquote><p id="d854" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两种方法的最终结果<em class="nv">应该是</em>相同的，但是在行为上有潜在的差异。回想一下，<code class="fe ns nt nu ni b">await</code>只是调用<code class="fe ns nt nu ni b">promise.then(callback)</code>的语法糖。所以当promise用<code class="fe ns nt nu ni b">await</code>解决时，执行从完全相同的位置重新开始。但是当promise用<code class="fe ns nt nu ni b">use</code>解析时，部分组件代码被<em class="nv">重新运行</em>并且<code class="fe ns nt nu ni b">use</code>调用将返回结果值。</p><p id="8137" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在这个<em class="nv">不应该</em>有所不同，因为如RFC所述，React组件应该是等幂的:用相同的道具、状态和上下文重新渲染不应该改变结果:</p><blockquote class="nw nx ny"><p id="d2e7" class="kf kg nv kh b ki kj jr kk kl km ju kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">重放依赖于React组件需要是等幂的属性——它们在渲染期间不包含外部副作用，并且对于给定的一组输入(道具、状态和上下文)返回相同的输出。</p></blockquote><p id="8f38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在实践中，即使非幂等行为是错误的，也肯定有可能以触发副作用的方式构建一个组件，最终导致执行两次。举一个简单(无害)的例子，假设您的小部件API函数中有一个<code class="fe ns nt nu ni b">console.log</code>。使用<code class="fe ns nt nu ni b">async</code>实现，您会看到控制台记录了一个值。随着<code class="fe ns nt nu ni b">use</code>的实现，你会看到两个。</p><p id="c057" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，<code class="fe ns nt nu ni b">use</code>钩子的“第二次执行”引入了另一个约束:API调用<em class="nv">必须</em>缓存结果，以便在第二次调用发生时它们(或多或少)立即可用:</p><blockquote class="nw nx ny"><p id="d040" class="kf kg nv kh b ki kj jr kk kl km ju kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">只有当数据请求被缓存时，在挂起之前等待微任务刷新的机制才起作用。更准确地说，约束是:在没有接收新输入的情况下重新呈现的异步函数必须在微任务内解析。</p></blockquote><p id="7f96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的API不支持缓存(或者没有正确实现缓存)，而是返回了另一个在微任务中无法解析的承诺(例如，它启动了一个新的API调用)，React将再次挂起组件呈现—大概会导致一个继续进行API调用并且永远不会完成的循环！明确地说，这种情况可能是开发人员的错误，但也可能是容易犯的错误。</p><p id="c564" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，与其他React钩子不同，<code class="fe ns nt nu ni b">use</code>钩子不受钩子的<a class="ae lb" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">规则的约束，这意味着它可以在循环中被有条件地调用。这种怪癖在某种程度上是由缓存需求造成的:第二次呈现可以调用use with a "new" promise，它访问相同的数据并应该得到缓存的结果。没有必要跟踪<code class="fe ns nt nu ni b">use</code>钩子调用的顺序，这就是为什么其他钩子<em class="nv">遵循那些规则。</em></a></p><h1 id="6e60" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">这种方法有哪些问题？</h1><p id="f1ef" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">虽然在React中获得对承诺的一流支持是令人兴奋的，但我个人有许多担忧——根据讨论，许多担忧也是其他人共有的。我不会假装对所有这些问题都有正确的答案，但这里有一些我在讨论中关注的问题。</p><h2 id="f9c9" class="nm lt iq bd lu oc od dn ly oe of dp mc ko og oh me ks oi oj mg kw ok ol mi om bi translated">名字</h2><p id="2454" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">当然，命名这是计算机科学中最困难的问题，但是名称<code class="fe ns nt nu ni b">use()</code>非常普通，并没有真正表达这个函数做什么以及它如何与承诺一起工作。</p><p id="bd19" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RFC确实解决了这个问题，并指出<code class="fe ns nt nu ni b">use()</code>有望在未来与其他类型的“解包”一起工作，也许是与上下文或其他数据类型一起工作。此外，他们指出<code class="fe ns nt nu ni b">use()</code>的名字清楚地表明它是一个“只反应”的函数。这些都是合理的解释，但它们确实导致了下一个问题，这是围绕着<code class="fe ns nt nu ni b">use()</code>的特定行为怪癖。</p><h2 id="fd76" class="nm lt iq bd lu oc od dn ly oe of dp mc ko og oh me ks oi oj mg kw ok ol mi om bi translated">使用()与其他挂钩的不同规则</h2><p id="baee" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如前所述，<code class="fe ns nt nu ni b">use()</code>被免除了正常的钩子规则。这是，同时，精彩和困惑。</p><p id="351b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它很棒，因为它消除了我们使用它的一些限制。</p><p id="0a2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是它<em class="nv">混淆</em>是因为——如果它不遵循钩子的<a class="ae lb" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">规则，那它实际上是钩子吗？这又让我们回到了之前的问题:<code class="fe ns nt nu ni b">use()</code>真的是正确的名字吗？</a></p><p id="08dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我担心的是<code class="fe ns nt nu ni b">use()</code>和其他钩子之间的规则差异会让新开发者更难理解钩子的规则，事实上，更难理解钩子的核心是什么。</p><h2 id="0219" class="nm lt iq bd lu oc od dn ly oe of dp mc ko og oh me ks oi oj mg kw ok ol mi om bi translated">对use()调用的代码的新约束</h2><p id="5a94" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">虽然新的use()钩子不像其他钩子那样受到相同的约束，但它确实在使用的代码周围引入了新的行为约束。也就是说，关于缓存的需求和产生传递给<code class="fe ns nt nu ni b">use()</code>的承诺的代码副作用的缺乏。</p><p id="bd78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然缓存行为肯定是一个合理的需求，但它并不是由任何接口或契约强制的。它基于从调用API函数的地方的<em class="nv">隐含知识，对API函数的开发者施加约束。</em></p><p id="2bb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与其将这一负担推给开发人员，也许缓存需求可以通过API变更和依赖数组(如<code class="fe ns nt nu ni b">useEffect</code>)在内部处理:</p><p id="f119" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu ni b">use(() =&gt; myAPI.fetch(id), [id])</code></p><p id="0632" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，这种方法的实现可能会使use()钩子也遵循“正常的”钩子规则(以便“记住”正在使用哪个调用)。这不一定是坏事！</p><h2 id="5a34" class="nm lt iq bd lu oc od dn ly oe of dp mc ko og oh me ks oi oj mg kw ok ol mi om bi translated">不同的客户机/服务器组件行为</h2><p id="5401" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">随着<code class="fe ns nt nu ni b">use()</code>在客户端的引入和<code class="fe ns nt nu ni b">await</code>在服务器端的引入，客户端和服务器组件的代码、生命周期和行为(以及它们接触的代码)开始以微妙但有意义的方式产生差异。这阻碍了代码重用和代码理解。</p><p id="4621" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不同意RFC中的观点:</p><blockquote class="nw nx ny"><p id="4fd2" class="kf kg nv kh b ki kj jr kk kl km ju kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">尽管我们最初有些犹豫，但是在服务器和客户机上使用不同的方法访问数据也有一个好处:这使得跟踪他们在哪个环境中工作变得更加容易。</p><p id="1d3a" class="kf kg nv kh b ki kj jr kk kl km ju kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">服务器组件应该和客户端组件感觉相似，但是我们不希望它们感觉<em class="iq">太</em>相似。每个环境都有不同的功能，开发人员在构建应用程序时需要清楚这种区别。</p></blockquote><p id="b041" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有人在跟踪他们所处的环境方面有困难，我怀疑函数定义中的<em class="nv"> async </em>关键字是否能达到目的。</p><p id="e331" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果真正的目的是跟踪不同的环境并验证行为，那么有很多更好的方法来明确地做到这一点，例如，为客户端服务器模块或API使用不同的名称空间，引入一个T2包装器，等等。上面的解释听起来像是对不同API的事后证明。</p><h1 id="322f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">承诺，承诺…</h1><p id="3bd9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我认为在React中获得对承诺的一流支持是一个好主意，但我并不完全赞同提议的解决方案。幸运的是，这仍处于提议阶段，在<a class="ae lb" href="https://github.com/reactjs/rfcs/pull/229" rel="noopener ugc nofollow" target="_blank">拉动请求</a>中有许多关于它的良好对话，包括围绕本文提出的问题的讨论等等。</p><p id="d0f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就个人而言，考虑到这种方法的一些问题，我认为等待异步客户端组件得到解决并不是最糟糕的策略:与其发明一个新的、棘手的、只反应的东西，不如花时间让它与JS开发人员处理问题的标准方式<code class="fe ns nt nu ni b">async/await</code>一起工作。与此同时，在回调中解开值并不是世界末日。</p><p id="bb75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我愿意相信也许我错了，如果这对于React开发人员来说是一个主要的生产力优势，那么现在的改变是值得的。你对提议的新<code class="fe ns nt nu ni b">use()</code>挂钩和一级承诺支持有什么想法？</p><p id="9c78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初发布于<a class="ae lb" href="https://blixtdev.com" rel="noopener ugc nofollow" target="_blank"> Blixtdev </a>。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="b970" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乔纳森写了一些关于创业、软件工程和健康科学的文章。如果你喜欢这篇文章，请考虑加入Medium来支持 <a class="ae lb" href="https://medium.com/@jonnystartup/membership" rel="noopener"> <em class="nv"> Jonathan和其他数千位作者</em> </a> <em class="nv">。</em></p><p id="74b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nv">更多内容看</em> <a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="nv">说白了。报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="nv">免费周报</em> </strong> </a> <em class="nv">。关注我们上</em> <a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="nv">推特</em> </strong> </a>，<a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nv">LinkedIn</em></strong></a><strong class="kh ir"><em class="nv">，</em></strong><a class="ae lb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nv">YouTube</em></strong></a><strong class="kh ir"><em class="nv">，以及</em></strong><em class="nv"><a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nv">不和</em> </strong> </a></em> </strong></a></p></div></div>    
</body>
</html>