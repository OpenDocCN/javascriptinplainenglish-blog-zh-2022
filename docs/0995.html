<html>
<head>
<title>Let’s Create a Cryptocurrency for Fun using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用JavaScript创建一种有趣的加密货币</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-create-a-cryptocurrency-for-fun-using-javascript-42894b50e44c?source=collection_archive---------3-----------------------#2022-02-25">https://javascript.plainenglish.io/lets-create-a-cryptocurrency-for-fun-using-javascript-42894b50e44c?source=collection_archive---------3-----------------------#2022-02-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6f6d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用JavaScript制作简单的加密货币</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b484a95549ec6d977b6c07974e7b62c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxyAKmf0obC2kX3EBcI7KA.png"/></div></div></figure><p id="e5b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天，我们将使用我们之前创建的<em class="lk"> </em> <a class="ae ll" href="https://levelup.gitconnected.com/learn-blockchain-by-building-it-f2f8ccc54892" rel="noopener ugc nofollow" target="_blank"> <em class="lk">区块链</em> </a>来构建一种加密货币。如果你还没有读过，我会快速重述一下，稍加修改，但是你应该先读一下<a class="ae ll" href="https://levelup.gitconnected.com/learn-blockchain-by-building-it-f2f8ccc54892" rel="noopener ugc nofollow" target="_blank">以前的文章</a>。</p><h1 id="e952" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">什么是加密货币，它们是如何工作的？</h1><p id="ed14" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">加密货币是在区块链网络和其他web 3.0应用程序上进行交易的基本货币形式。根据<a class="ae ll" href="https://bitcoin.org/bitcoin.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> Satoshi的《比特币白皮书》</em> </a>的说法，一个电子币只是一串数字签名。它的主要特征是分散的，因此不可能有政府或外界的影响。加密货币的另一个好处是匿名性，也就是说，你无法跟踪一个人的交易，因为任何人都可以在没有KYC的情况下加入网络！</p><p id="9803" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一枚硬币被从一个人转移到另一个人，使用的是他们钱包里的公钥。并且该交易由发送者的私钥数字签名，使得任何人都可以使用发送者的公钥来验证该交易。</p><p id="8583" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每当启动一个事务，它就被临时存储在区块链网络上的一个池中。当网络池中收集了足够数量的事务时，所有事务都将永久存储在一个新的块中(启动挖掘过程),并从池中删除。</p><h2 id="e9c5" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">加密货币是如何产生的，由谁产生？</h2><p id="7996" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">加密货币的产生被称为铸造。货币由区块链网络铸造，作为对通过解决密码难题成功挖掘新区块的矿工节点的奖励(激励)。</p><h2 id="8802" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">如果用户没有帐户，硬币会存放在哪里？</h2><p id="33d1" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">钱包中显示的硬币余额只是在任何交易中没有花费的剩余硬币。我们只需要根据用户的公钥计算未用完硬币的数量，就可以找到他们的硬币余额。</p><h1 id="a1e2" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">先决条件</h1><p id="a15e" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">要学习和理解本教程，您应该熟悉以下内容:</p><ul class=""><li id="42f7" class="mv mw in kq b kr ks ku kv kx mx lb my lf mz lj na nb nc nd bi translated">JavaScript中的类和其他ES6特性的工作知识。</li><li id="7053" class="mv mw in kq b kr ne ku nf kx ng lb nh lf ni lj na nb nc nd bi translated">机器上安装了节点。</li></ul><h1 id="5f04" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">让我们快速回顾一下区块链</h1><p id="d4c2" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">从<a class="ae ll" href="https://ankan101.medium.com/learn-blockchain-by-building-it-f2f8ccc54892" rel="noopener">上一篇文章</a>中，我们了解到区块链只是一串积木。所以让我们先实现Block类:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1250" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的代码中，我们只是在块中添加了一个根哈希属性。这个根散列是通过从事务列表创建Merkle树来生成的。数据属性将包含事务列表。</p><p id="8dbf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe nl nm nn no b">getMerkleRoot</code>使用了我们在本文的<a class="ae ll" href="https://enlear.academy/merkle-tree-the-root-of-bitcoin-5a9062394fbf" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">中实现的Merkle树类。</em></strong></a>Merkle树实现在<a class="ae ll" href="https://bit.ly/34UxH1x" rel="noopener ugc nofollow" target="_blank">这个GitHub gist </a>中有。让我们看看<code class="fe nl nm nn no b">getMerkleRoot</code>和<code class="fe nl nm nn no b">calculateHash</code>是如何实现的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d7b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在实现区块链类:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9f0c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经通过删除包含空数据的genesis块更新了区块链类。这是因为我们想要铸造第一个加密货币，如果我们传递空数据，这是不可能的。我们将向第一个用户发起10000个硬币的交易，这些硬币将存储在创世纪区块中。</p><h1 id="1086" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">加密货币入门</h1><p id="d3ae" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我们将通过网络交易创造加密货币。硬币只是交易中的一个数字。除此之外他们不存在。事务类需要以下属性:</p><ul class=""><li id="26ea" class="mv mw in kq b kr ks ku kv kx mx lb my lf mz lj na nb nc nd bi translated">发送方和接收方的公钥</li><li id="82dd" class="mv mw in kq b kr ne ku nf kx ng lb nh lf ni lj na nb nc nd bi translated">要转移的金额</li><li id="59ac" class="mv mw in kq b kr ne ku nf kx ng lb nh lf ni lj na nb nc nd bi translated">交易的id</li><li id="1ca2" class="mv mw in kq b kr ne ku nf kx ng lb nh lf ni lj na nb nc nd bi translated">内容的哈希——发送者和接收者的公钥，金额&amp; id(验证时不要弄乱顺序很重要，否则哈希不匹配——发生在我身上；p)</li></ul><h2 id="bad1" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">定义事务处理分类</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c78f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经使用了来自npm的<code class="fe nl nm nn no b">uuid</code>包来生成我们唯一的事务id。要安装，只需从终端执行<code class="fe nl nm nn no b">npm i uuid</code>。</p><h2 id="6ed5" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">更新区块链类</h2><p id="1a44" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">现在我们需要在Blockchain类中添加一个<code class="fe nl nm nn no b">transactions</code>属性来存储网络上所有待处理的事务。还有一个<code class="fe nl nm nn no b">reward</code>属性，它包含给予miner节点的奖励金额。接下来，我们将向区块链添加一个<code class="fe nl nm nn no b">addTransaction</code>方法，该方法通过确保池中不存在给定的事务，将一个事务和它放入挂起的事务池中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fcc9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还需要一种方法来检查用户的余额。正如我们前面讨论的，余额只是给定公钥的未转移金额(用户的身份由他的公钥表示)。因此，我们需要检查存储在所有块中的所有交易的金额。</p><h2 id="64ba" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">获取平衡方法</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="304f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe nl nm nn no b">getBalance</code>方法中，我们检查了所有的块和块中的所有事务。如果事务包含给定的公钥，我们检查公钥是发送方还是接收方。如果密钥与发送者匹配，我们从余额中扣除金额，否则我们将金额添加到余额中。</p><h1 id="ad7a" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">继续说钱包</h1><p id="6d3c" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">钱包将包含用户的必要信息。所有用户都将通过他们的钱包进行互动和发起交易。Wallet类将拥有给定用户的私钥和公钥对。</p><h2 id="7059" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">定义钱包类</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6881" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里，我们使用了加密库的<code class="fe nl nm nn no b">generateKeyPairSync</code>方法。我们的实现使用RSA密钥，但比特币和以太坊在secp256k1曲线上使用ECDSA。不幸的是，加密不完全支持这种格式，所以我们使用RSA。</p><p id="5784" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们需要Wallet类中的一个send方法，它将为用户创建一个事务。send方法将接受一个金额和金额将被转移到的接收者的地址(公钥)。</p><p id="bdec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是在我们实现send方法之前，我们需要对事务进行数字签名。否则，交易将无法核实。因此，首先我们在事务类中实现sign方法。</p><h2 id="7f83" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">签署交易</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="65ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">既然sign方法已经在事务上实现了，我们可以把注意力放在send方法上。</p><h2 id="4eb0" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">发送方法</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2795" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">到目前为止，我们正在实施所有这些方法，但有一个致命的问题需要解决。您可能已经注意到，我们已经实现的事务还没有经过验证。让我们现在解决这个问题。</p><h1 id="d1a9" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">确认</h1><p id="371a" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我们将在事务类中添加一个<code class="fe nl nm nn no b">isValid</code>方法来验证事务。交易应该包含有效的发送方、接收方、金额，发送方的余额应该大于转账的金额，交易的哈希应该相等，签名应该经过验证。</p><h2 id="899f" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">验证单个交易</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2473" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还记得我们一直在区块链的交易池中添加交易，而没有验证区块链吗？我们需要在将每个事务推到池中之前对其进行验证。我们将在Blockchain类的<code class="fe nl nm nn no b">addTransaction</code>方法中添加下面一行来代替if条件。</p><blockquote class="np nq nr"><p id="621b" class="ko kp lk kq b kr ks jo kt ku kv jr kw ns ky kz la nt lc ld le nu lg lh li lj ig bi translated"><code class="fe nl nm nn no b">if(!isDuplicate &amp;&amp; transaction.isValid(this))</code></p></blockquote><h2 id="b6e7" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">验证块中的所有事务</h2><p id="0072" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">现在，我们需要验证一个块中的所有事务。我们可以通过循环所有事务并验证每一个事务来实现。我们将使用<code class="fe nl nm nn no b">every</code>方法，这是JS中的一个高阶函数，它让我们检查一个数组中的所有元素的条件，如果其中任何一个元素返回false，则返回false。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="0b22" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">挖掘交易</h2><p id="c9dc" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">最后，我们需要挖掘事务，即挖掘一个包含所有未决事务的块。我们将在Blockchain类中实现一个mine-transaction方法来挖掘一个块。将所有事务添加到新块后，我们将清空pending transactions列表。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="8ebb" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">还有一个问题需要解决</h1><p id="049f" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我们说了会给矿块固定奖励，还没落实。在区块链的<code class="fe nl nm nn no b">mineTransaction</code>方法中，我们需要创建另一个将奖励转移到矿工地址的事务。但问题是——在这种情况下，谁是发送者？</p><h2 id="70f5" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">奖励矿工</h2><p id="533e" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我们需要为区块链网络创建一个所有方法和类都可以访问的钱包。我们还需要为网络钱包的交易类中的<code class="fe nl nm nn no b">isValid</code>方法创建一个例外，因为网络钱包没有任何余额，但是能够创造新的硬币。然后，我们将在<code class="fe nl nm nn no b">mineTransaction</code>方法中添加一个奖励交易。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="eaa2" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">释放最初的几枚硬币</h1><p id="44fd" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我们将用第一个用户的一些硬币的初始交易来启动区块链实例。转帐将从网络钱包中进行，否则由于先前不存在硬币，转帐将不会生效。我们将铸造第一枚硬币，并将其转移到第一个用户的钱包中。</p><h2 id="64da" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">更新区块链创建方法</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="eee3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的方法中，我们首先创建了从<em class="lk">网络_钱包</em>到第一个用户地址的交易。然后，我们使用第一个事务挖掘一个新块，并将其添加到区块链中。这将是区块链的第一个区块，所以我们可以称之为创世区块。</p><h1 id="d065" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">斗牛中的最后一剑</h1><p id="ee81" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">所有必要的代码都已实现，现在是测试的时候了。首先，我们需要为两个用户创建钱包，以便在他们之间进行交易。出于显而易见的原因，让我们称他们为爱丽丝和鲍勃；现在我们将通过向第一个用户爱丽丝赠送第一枚硬币来实例化区块链网络。然后，我们将从Alice向Bob转移一些硬币，并检查两个用户的余额，并在所有交易后检查区块链是否有效。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="845b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">执行完文件后，我们应该得到Alice的余额为8356，Bob的余额为2322。而下一行应该是—“<em class="lk">区块链有效</em>”。区块链的快照应该类似于下图。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/c657e18b0451b9c7d46f5e51430b2016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cS0srnI96_gv3BMUxx5R-A.png"/></div></div></figure><h1 id="9aca" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">结论</h1><p id="a76f" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">今天我们学习了加密货币是如何工作的，以及如何使用JavaScript创建一个简单的加密货币。我们利用了<a class="ae ll" href="https://levelup.gitconnected.com/learn-blockchain-by-building-it-f2f8ccc54892" rel="noopener ugc nofollow" target="_blank"> <em class="lk">我们之前从这篇文章</em> </a>中学到的区块链。源代码可以在<a class="ae ll" href="https://bit.ly/3JLrN1z" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">这个Github仓库</em> </strong> </a>中找到，文件是用TypeScript编写的，TypeScript是JavaScript的超集。自述文件中提供了相关说明。</p><div class="nw nx gp gr ny nz"><a href="https://bit.ly/3JLrN1z" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd io gy z fp oe fr fs of fu fw im bi translated">GitHub-ankan gab 101/加密硬币</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">bit.ly</p></div></div><div class="oi l"><div class="oj l ok ol om oi on km nz"/></div></div></a></div><p id="5048" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">接下来的</strong>:我们将为硬币的交易实现一个<strong class="kq io"> <em class="lk">对等网络</em> </strong>。邮件很快就会投递。因此，如果可能的话，不要忘记关注我，订阅电子邮件更新。</p><h2 id="05a8" class="mj ln in bd lo mk ml dn ls mm mn dp lw kx mo mp ly lb mq mr ma lf ms mt mc mu bi translated">黑客快乐！</h2><p id="7de7" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated"><em class="lk">更多内容请看</em> <a class="ae ll" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">说白了就是</em> </strong> </a> <em class="lk">。报名参加我们的</em> <a class="ae ll" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费每周简讯</em> </strong> </a> <em class="lk">。关注我们</em><a class="ae ll" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">Twitter</em></strong></a><em class="lk">和</em><a class="ae ll" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">。加入我们的</em> <a class="ae ll" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">社区不和谐</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>