<html>
<head>
<title>Derive Time Complexity / Big O of an Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">推导算法的时间复杂度/大O</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basics-of-javascript-algorithms-part-2-a1b5a3ffcb71?source=collection_archive---------4-----------------------#2022-09-11">https://javascript.plainenglish.io/basics-of-javascript-algorithms-part-2-a1b5a3ffcb71?source=collection_archive---------4-----------------------#2022-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c5ce" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript算法基础第2部分:探索一种更好的机制来推导算法的时间复杂度。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2de0f55eaff3940ede4889a0562e6cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ez46Irbh6DsoITnw"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b76d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文是上一篇文章的延续，在上一篇文章中，我们研究了<strong class="kv io">算法</strong>和<strong class="kv io">时间复杂度</strong>的基础知识。如果你还没看过，这里有上一篇文章的链接。</p><p id="37a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://medium.com/@code.ceeker/basics-of-javascript-algorithms-bbc0ddb785c2" rel="noopener"><em class="lp">JavaScript算法基础—第一部分</em> </a></p><p id="c4f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还看到了如何通过识别函数在<strong class="kv io">不同输入</strong>下的<strong class="kv io">模式来<strong class="kv io">评估算法</strong>的时间复杂度。但是，如前一篇文章所述，这种基于时间模式评估时间复杂度的方法<strong class="kv io">并不可靠</strong>，因为它还依赖于<strong class="kv io">其他因素</strong>。</strong></p><p id="4bbe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们需要一个<strong class="kv io">更好的机制来推导算法</strong>的时间复杂度，它独立于任何其他因素。我们将在本文中探讨这种机制。</p><p id="e03b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，在开始之前，让我们先了解一下<strong class="kv io">大O符号</strong>。</p><h1 id="75ce" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">大O符号</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/bec7d3ea136f63593bb8201cc8dd2b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jd-aK8wlDG6AIo3CV-todA.png"/></div></div></figure><p id="9e04" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">除了<strong class="kv io">线性</strong>和<strong class="kv io">常数</strong>时间，我们还发现有<strong class="kv io">对数</strong>时间、<strong class="kv io">二次</strong>时间，甚至<strong class="kv io">三次</strong>时间的算法。还有很多其他的时间复杂性。不过这些都是<strong class="kv io">常见的</strong>。</p><p id="940f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们之前的文章中，我们能够得出结论，具有循环解的函数具有线性时间复杂度，而具有数学解的函数具有恒定时间复杂度。但是如果我们必须用一种标准的方式来表现它或传达它，那我们该怎么做呢？</p><p id="ad64" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在编程中，我们用叫做<strong class="kv io">大O符号</strong>的东西来表示这一点。这让我们更容易表达给定算法的<strong class="kv io">时间复杂度。一个<strong class="kv io">大O符号</strong>长这样，按照<strong class="kv io">性能</strong>从<strong class="kv io">好到最差</strong>的顺序排列。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mj"><img src="../Images/8eb47535cb4c17ef3a7efcf4fc0fac9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_32EHUUp8zf9qv_fsDZfzg.png"/></div></div></figure><p id="b7bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大O符号是比较的<strong class="kv io">标准方式</strong>和代表算法性能的<strong class="kv io">。我们推导出一个算法的<strong class="kv io">大O </strong>，然后我们知道<strong class="kv io"> O(n) </strong>是线性的，<strong class="kv io"> O(1) </strong>是常数。这里的<strong class="kv io"> (O) </strong>表示</strong>功能的<strong class="kv io">顺序。此外，我们使用这个符号来表达任何算法的复杂性。</strong></p><p id="5b67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，既然我们已经清楚了大O符号，让我们看看推导算法的<strong class="kv io">大O的实际方法。</strong></p><h1 id="478d" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak">推导时间复杂度/大O(渐近分析)</strong></h1><p id="4ead" class="pw-post-body-paragraph kt ku in kv b kw mk jo ky kz ml jr lb lc mm le lf lg mn li lj lk mo lm ln lo ig bi translated">在前一篇文章中，我们了解到我们应该关心<strong class="kv io">功能模式</strong>，而不是具体的时间数。因此，对于一个循环函数，我们可以说它有一个时间复杂度为O(n) 的解，这仅仅意味着它具有线性时间复杂度。</p><p id="8f75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，这是通过<strong class="kv io">比较函数</strong>的时间值来完成的，我们已经知道<strong class="kv io">不是一个可靠的解决方案，因为它取决于其他因素</strong>。那么，<strong class="kv io">我们怎样才能导出这个呢？</strong></p><blockquote class="mp mq mr"><p id="0f31" class="kt ku lp kv b kw kx jo ky kz la jr lb ms ld le lf mt lh li lj mu ll lm ln lo ig bi translated">为此，我们使用一种叫做渐近分析的技术。</p></blockquote><p id="4c6d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它包括几个简单的步骤。首先，对于给定的算法，我们<strong class="kv io">定义它的函数</strong>。这里我指的是我们写给<strong class="kv io">的<strong class="kv io">数学函数</strong>得到一个图形</strong>，就像我们在线性函数中看到的一样。因此，我们需要推导出数学函数，最终<strong class="kv io">将导致如下</strong>所示的线性图。让我们看看如何推导它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/72179f7a4988f734f91936f690d5a5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*kwCkzOnVMRCOCRm6"/></div></figure><p id="6d84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这听起来可能很吓人，但并不难。<strong class="kv io">我们需要做的就是计算函数</strong>中表达式执行的次数。大致来说，<strong class="kv io">函数中的每一行代码</strong>，我们<strong class="kv io">计算它被执行的频率</strong>。</p><p id="9127" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">请注意，用这种方法，我们不会得到真实的、</em> <strong class="kv io"> <em class="lp">毫秒或秒的时间</em> </strong> <em class="lp">。理解这一点很重要，因为现在我们对</em><strong class="kv io"><em class="lp"/></strong><em class="lp">不再感兴趣，因为它不可靠，受太多方面的影响。</em></p><p id="2e98" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事实上，我们简单地<strong class="kv io">假设JavaScript中的每个表达式花费大致相同的时间</strong>。<strong class="kv io"> <em class="lp">然后可以对表达式执行的次数进行计数，然后可以简单地将该次数与另一个替代函数</em> </strong>的次数进行比较。</p><p id="8859" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们在这里要采取的方法。让我们来看看循环函数的几个场景。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/eafc205d4ddb1ae25ee66cb9b5a62685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sknX4SUgt9tjXmD6m7BdQ.png"/></div></div></figure><p id="ead2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将数组输入的<strong class="kv io">长度定义为<strong class="kv io"> n因子</strong>。我们将发现具有不同长度数组的函数的行为</strong></p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="1df9" class="nc lr in my b gy nd ne l nf ng"><strong class="my io">n = [1]</strong></span><span id="cd22" class="nc lr in my b gy nh ne l nf ng"><strong class="my io">n = [1,2,3,4,5]</strong></span><span id="c038" class="nc lr in my b gy nh ne l nf ng"><strong class="my io">n = [1,2,3,4,5,6,7,8,9,0]</strong></span></pre><p id="adcd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在所有情况下，我们遍历函数中的每一行表达式，看看它执行了多少次。</p><ol class=""><li id="ce7a" class="ni nj in kv b kw kx kz la lc nk lg nl lk nm lo nn no np nq bi translated"><strong class="kv io">第一个表达式，</strong></li></ol><p id="7d25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">let total = 0;</strong></code></p><p id="7a42" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">这是</em> <strong class="kv io"> <em class="lp">只执行一次</em> </strong> <em class="lp">在所有情况下都当作只是一次赋值。</em></p><p id="9604" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.<strong class="kv io">for循环初始化的下一个表达式，</strong></p><p id="62dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">for(let index = 0; index &lt; n.length; index++)</strong></code></p><p id="d98d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">由于这也是一次初始化，在所有三种情况下，它只执行一次</em><strong class="kv io"><em class="lp"/></strong><em class="lp">。</em></p><p id="b1dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.<strong class="kv io">接下来，我们有for循环的主体，</strong></p><p id="c84e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">total += n[index];</strong></code></p><p id="5f46" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">在这里你会看到</em> <strong class="kv io"> <em class="lp">的结果是不同的</em> </strong> <em class="lp">，对于</em> <strong class="kv io"> <em class="lp">数组长度为1的</em> </strong> <em class="lp">，它只执行一次</em><strong class="kv io"/><em class="lp">但是对于</em> <strong class="kv io"> <em class="lp">数组长度为5的</em> </strong> <em class="lp">，</em> <strong class="kv io">而且，这是 <strong class="kv io"> <em class="lp">重要要注意的</em> </strong> <em class="lp">。</em></strong></p><p id="1245" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.<strong class="kv io">然后我们有一个返回语句，</strong></p><p id="aeaf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">return total;</strong></code></p><p id="59d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">也是在所有情况下只执行一次。</em></p><p id="536c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们看到所有三种情况下表达式的代码执行，我们再次看到这里的<strong class="kv io">模式</strong>。对于这个算法，我们可以说函数<strong class="kv io">唯一的<strong class="kv io">动态部分</strong>就是循环中的体(</strong> <code class="fe nr ns nt my b"><strong class="kv io">total += n[index];</strong></code> <strong class="kv io"> ) </strong>。而这个体被执行的次数<strong class="kv io">就是我们给这个函数的数组</strong>的<strong class="kv io">长度。</strong></p><p id="6ec2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，对于<strong class="kv io"> n = n(数组的n长度)</strong>，其他三个表达式将只运行一次，而<strong class="kv io">循环中的代码(</strong> <code class="fe nr ns nt my b"><strong class="kv io">total += n[index];</strong></code> <strong class="kv io"> ) </strong>将执行<strong class="kv io"> n次</strong>。这样，我们现在可以从<strong class="kv io">导出一个函数</strong>。</p><p id="54e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们想用<strong class="kv io"> T </strong>来表示这里的时间复杂度，那么我们可以说，对于<strong class="kv io"> n </strong> = n的情况，我们得到的这个函数的代码执行次数是(1 + 1 + <strong class="kv io"> n </strong> + 1)，即</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="ef8f" class="nc lr in my b gy nd ne l nf ng">n=[1]                   -&gt; <strong class="my io">T</strong> = 1 + 1 + <strong class="my io">1</strong> + 1<br/>n=[1,2,3,4,5]           -&gt; <strong class="my io">T</strong> = 1 + 1 + <strong class="my io">5</strong> + 1<br/>n=[1,2,3,4,5,6,7,8,9,0] -&gt; <strong class="my io">T</strong> = 1 + 1 + <strong class="my io">10</strong> + 1<br/><strong class="my io">n=[n]                   -&gt; T = 1 + 1 + n + 1</strong></span></pre><p id="88cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，</p><p id="7a9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">T = 1 + 1 + n + 1</strong></code></p><p id="69e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以总结为，</p><p id="fe8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">T = n + 3</strong></code></p><p id="0854" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这也可以写成，</p><p id="f498" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">T = 1*n + 3</strong></code></p><p id="554e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是<strong class="kv io">数学函数方程</strong>，它将<strong class="kv io">描述</strong>我们对上述JavaScript函数的<strong class="kv io">代码执行次数</strong>。</p><p id="3201" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它没有描述这个函数需要多少毫秒或多少秒，因为这很难量化。但是，<strong class="kv io">如果我们假设每一行代码执行</strong>花费的时间大致相同，那么我们可以使用这样一个等式<strong class="kv io">将这个算法与其他算法</strong>进行比较。</p><p id="b30b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们可以将其一般化，并将等式写成:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="3865" class="nc lr in my b gy nd ne l nf ng"><strong class="my io">T = a*n + b            (1 is replaced by 'a' &amp; 3 is replaced by 'b')</strong></span></pre><p id="b654" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，为了让<strong class="kv io">得到大O符号</strong>，我们需要<strong class="kv io">找到函数</strong>中增长最快的项。这很简单，真的，</p><p id="84e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">a*n</strong></code></p><p id="8cb7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为<strong class="kv io"> b </strong>是一个<strong class="kv io">常数系数</strong>那个<strong class="kv io">根本不增长</strong>。总是一模一样的数字。因此我们可以忽略它。另一方面，<code class="fe nr ns nt my b"><strong class="kv io">a*n</strong></code>实际上取决于<strong class="kv io"> n </strong>并且对于更大的<strong class="kv io"> n </strong>，该项也更大。</p><p id="72de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">既然我们找到了增长最快的项，<code class="fe nr ns nt my b"><strong class="kv io">i.e a*n</strong></code> <strong class="kv io"> </strong>把系数<code class="fe nr ns nt my b"><strong class="kv io">a</strong></code> <strong class="kv io"> </strong>从那个项中去掉是因为我们<strong class="kv io">不关心现在</strong>的确切数字，我们关心的是概貌。<strong class="kv io">这个过程在这里叫做渐近分析</strong>。</p><p id="ee3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们可以把它缩小到下面的函数方程。</p><p id="e270" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nr ns nt my b"><strong class="kv io">T = n</strong></code></p><p id="af89" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这清楚的告诉我们，这个函数的<strong class="kv io">时间复杂度</strong>取决于<strong class="kv io"> n </strong>。并且，那个<strong class="kv io"> n </strong>就是我们放在<strong class="kv io">大O符号</strong>的括号之间的东西，即</p><p id="1d39" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> O(n) </strong></p><p id="b650" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，</p><p id="8bec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> T = O(n) </strong></p><p id="1c07" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这就是为什么我们称之为n的大O，对于一个线性函数表示为T = O(n)。</strong></p><p id="f98e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，我们可以用上面的<strong class="kv io">渐近分析的方法来推导任何算法的大O。与我们之前使用的时间函数方法相比，它不依赖于任何其他因素，更加可靠。</strong></p><p id="00e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://medium.com/@code.ceeker/derive-constant-time-complexity-o-1-using-asymptotic-analysis-e786df20fc7b" rel="noopener"> <em class="lp">下一步- &gt;利用</em>渐近分析<em class="lp">导出常数时间复杂度的大O。</em> </a></p><p id="e381" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢您的阅读。</p></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><p id="1b07" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">plain English . io</em></strong></a><em class="lp">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">免费周报</em> </strong> </a> <em class="lp">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">LinkedIn</em></strong></a><em class="lp"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">YouTube</em></strong></a><em class="lp"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">不和</em> </strong> </a> <em class="lp">。对增长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">电路</em> </strong> </a> <em class="lp">。</em></p></div></div>    
</body>
</html>