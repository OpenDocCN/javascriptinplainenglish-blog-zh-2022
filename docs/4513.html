<html>
<head>
<title>Rendering dynamic components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中渲染动态组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rendering-dynamic-components-in-react-c859704492a?source=collection_archive---------12-----------------------#2022-12-09">https://javascript.plainenglish.io/rendering-dynamic-components-in-react-c859704492a?source=collection_archive---------12-----------------------#2022-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="a588" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">指南</h2><div class=""/><div class=""><h2 id="271d" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">有许多方法可以动态地呈现组件，让我们来看看一些方法。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/08f2368041076eb85b3a1b950c887289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zflBK7OewodVo8A4Oqa6og.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://res.cloudinary.com/practicaldev/image/fetch/s--Vy_yXzCy--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/y2ur8p8rgkf778lwdtrv.jpg" rel="noopener ugc nofollow" target="_blank">Credits</a></figcaption></figure><h1 id="5c05" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">介绍</h1><p id="6f19" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在我们的职业生涯中，有很多时候一个单一的因素是不够的。在本教程中，一个名为useScreenSize的钩子将根据屏幕大小返回三种状态:桌面、平板和移动。我们要为每个状态渲染一个不同的组件。</p><p id="3b06" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">DesktopLayout.ts当它返回桌面时，TabletLayout.ts用于平板电脑，MobileLayout.ts用于移动设备。</p><p id="3b40" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">本文的所有代码都可以在<a class="ae le" href="https://codesandbox.io/s/old-darkness-1tpz6i?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="0614" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">If / Else模式</h1><p id="2f20" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们学到的第一个调节应用程序流量的方法是我们如何解决这个问题。通过使用if/else语句。这是一个简单的问题解决方案，但是在React中呈现动态组件时，不建议使用If else语句，因为它们会变得复杂和难以阅读。此外，if else语句需要编写大量代码来呈现一个组件，这使得它很难维护。此外，if else语句很难调试，因为有很多潜在的失败点。</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="8a8a" class="nd lg iq mz b be ne nf l ng nh"><br/>const WithIfs = ({ size }) =&gt; {<br/>  if (size === "mobile") {<br/>    return &lt;MobileLayout /&gt;;<br/>  }<br/>  if (size === "tablet") {<br/>    return &lt;TabletLayout /&gt;;<br/>  }<br/>  return &lt;DesktopLayout /&gt;;<br/>};</span></pre><h1 id="a677" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">开关模式</h1><p id="4012" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们可以应用一个切换模式来稍微整理一下这种情况。这种策略有一些限制。开关不能直接用于你的渲染方法或函数的返回。相反，必须在我们的类中定义一个从我们的开关返回适当项的方法。在功能组件中，我们可以使用reactions use memo钩子来确保我们有正确的项目。</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="1ea7" class="nd lg iq mz b be ne nf l ng nh">// Class based<br/>class MyComponent {<br/> renderSwitch(param) {<br/>  let Component;<br/>  switch (param) {<br/>    case "mobile":<br/>      Component = MobileLayout;<br/>      break;<br/>    case "tablet":<br/>      Component = TabletLayout;<br/>      break;<br/>    default:<br/>      Component = DesktopLayout;<br/>  }<br/>  return &lt;Component /&gt;;<br/> }<br/><br/> render() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;<br/>          // stuff<br/>      &lt;/div&gt;<br/>      {this.renderSwitch()} // will render desktop as we have no param<br/>      &lt;div&gt;<br/>          // stuff<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/> }<br/>}<br/><br/>// functional based<br/>const MyComponent = ({ someProp }) =&gt; {<br/>    const DivToRender = useMemo(() =&gt; {<br/>       let Component;<br/>      switch (param) {<br/>        case "mobile":<br/>          return MobileLayout;<br/>        case "tablet":<br/>          return TabletLayout;<br/>        default:<br/>          return DesktopLayout<br/>      }<br/>    }, [someProp])<br/><br/>    return ( <br/>        &lt;div&gt;<br/>          &lt;div&gt;<br/>          // removed for brevity<br/>          &lt;/div&gt;<br/>          &lt;DivToRender /&gt;<br/>          &lt;div&gt;<br/>             // removed for brevity<br/>          &lt;/div&gt;<br/>       &lt;/div&gt;<br/>}</span></pre><p id="c9a8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">虽然这种模式可行，但我们遇到了与if/else块相同的问题，随着屏幕大小的增加，运行时复杂度仍然为O(n ),找到正确项目所需的时间也增加了。Switch语句没有针对性能进行优化。</p><p id="a4b0" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">Switch语句不是为处理大量组件而设计的，因为它们使用线性搜索来查找正确的案例。这可能会导致大量不必要的计算时间，尤其是当您有很多组件时。此外，switch语句不是为需要频繁更改的组件设计的，因为每次组件更改时都需要编辑代码。我们可以通过使用useMemo稍微减轻这一点。</p><h1 id="449d" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">对象映射模式</h1><p id="afe1" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">这就把我们带到了最后一个模式，我称之为对象映射模式。在这个模式中，我们将所有的组件存储在一个对象中。</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="9e44" class="nd lg iq mz b be ne nf l ng nh">const DynamicComponentMap = {<br/>  DESKTOP: DesktopComponent,<br/>  TABLET: TabletComponent,<br/>  MOBILE: MobileComponent,<br/>}<br/><br/>const MyResponsiveComponent = (props) =&gt; {<br/>   const { screenSize } = useScreenSize();<br/>   const Component = DynamicComponentMap[screenSize];<br/>   return &lt;Component {...props} /&gt;<br/>}</span></pre><p id="bff3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这种方法的美妙之处在于，我们也不会受到简单的基于屏幕大小的按键的限制。假设我们有一个需要为多个用户呈现动态组件的仪表板。我们可以像下面这样做。</p><pre class="kp kq kr ks gt my mz na bn nb nc bi"><span id="dfef" class="nd lg iq mz b be ne nf l ng nh">const Components = {<br/>  DesktopAdmin,<br/>  DesktopUser,<br/>  DesktopSuperAdmin,<br/>// ... more components here<br/>}<br/><br/>const getUserComponents = userAuthLevel =&gt; {<br/>   if (userAuthLevel === 'user') {<br/>     return ['DesktopUser', 'PanelUser', 'OtherComponentUser']<br/>   }<br/>}<br/><br/>const getUserComponentsWithProps = userAuthLevel =&gt; {<br/>   if (userAuthLevel === 'user') {<br/>     return [{ componentName: 'DesktopUser', props: { some: 'prop'},]<br/>   }<br/>}<br/><br/>const DynamicDashboard = () =&gt; {<br/>   const userComponents = getUserComponents('user');<br/><br/>   return (<br/>      &lt;div&gt;<br/>          {userComponents.map(componentName =&gt; {<br/>              const Component = Components[componentName];<br/>              return &lt;Component /&gt;<br/>           })<br/>      &lt;/div&gt;<br/>  )<br/>}<br/><br/>const DynamicDashboardWithDynamicProps = () =&gt; {<br/>   const userComponents = getUserComponentsWithProps('user');<br/><br/>   return (<br/>      &lt;div&gt;<br/>          {userComponents.map(({ componentName, props }) =&gt; {<br/>              const Component = Components[componentName];<br/>              return &lt;Component {...props}/&gt;<br/>           })<br/>      &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="d1c9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">使用JavaScript对象代替switch语句或if/else进行动态呈现在几个方面具有优势。JavaScript对象比switch语句更简洁，也更容易阅读和理解。JavaScript对象也更加通用，使开发人员能够完成比switch语句更复杂的任务。最后，JavaScript对象更容易维护和调试，因为它们很容易修改或替换。所有这些因素使得使用JavaScript对象代替switch语句进行动态呈现成为更好的选择。</p><h2 id="3cb7" class="ni lg iq bd lh nj nk dn ll nl nm dp lp mg nn no lr mk np nq lt mo nr ns lv iw bi translated">让它更有性能</h2><p id="80c9" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">为了确保所有这些组件不会在构建时捆绑在一起，我们还可以使用reactions Lazy system惰性加载它们。React惰性加载是一种提高web应用程序性能的好方法，它只在需要的时候加载组件。这有助于减少页面的初始加载时间，并带来更好的用户体验。此外，延迟加载可用于仅加载当前页面所需的组件，这将有助于减小应用程序的整体大小。最后，它可以帮助进行代码拆分，这有助于减少浏览器需要下载和解析的代码量，使应用程序更快、更高效。</p><h1 id="8d89" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="f1ed" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">虽然我说基于对象的方法是最好的，但这些方法都可以工作，并且都取决于你们每个人的用例，我希望这篇文章给了你一些灵感/想法，帮助你解决这些问题，如果你有这些问题的话。</p><h2 id="2867" class="ni lg iq bd lh nj nk dn ll nl nm dp lp mg nn no lr mk np nq lt mo nr ns lv iw bi translated">更多内容请访问<a class="ae le" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> PlainEnglish.io </a>。</h2><p id="0d44" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">报名参加我们的<a class="ae le" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja">免费周报</strong> </a>。关注我们<a class="ae le" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja">推特</strong> </a>，<a class="ae le" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lz ja">LinkedIn</strong></a><strong class="lz ja">，</strong><a class="ae le" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lz ja">YouTube</strong></a><strong class="lz ja">，</strong> <a class="ae le" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja">不和谐</strong> </a> <strong class="lz ja">。</strong></p><h2 id="3d1e" class="ni lg iq bd lh nj nk dn ll nl nm dp lp mg nn no lr mk np nq lt mo nr ns lv iw bi translated">想用内容来扩展你的科技创业吗？检查<a class="ae le" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank">电路</a>。</h2><p id="aac5" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们提供免费的专家建议和定制解决方案，帮助您建立对您的技术产品或服务的认知和采用。</p></div></div>    
</body>
</html>