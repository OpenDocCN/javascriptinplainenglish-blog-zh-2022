<html>
<head>
<title>React 18 useEffect Double Call for APIs: Emergency Fix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对API的双重调用:紧急修复</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-18-useeffect-double-call-for-apis-emergency-fix-724b7ee6a646?source=collection_archive---------0-----------------------#2022-06-01">https://javascript.plainenglish.io/react-18-useeffect-double-call-for-apis-emergency-fix-724b7ee6a646?source=collection_archive---------0-----------------------#2022-06-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/49a044d255995d5275682e3206bc04be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebSScvhXNYQjgEQJB4_P5Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">React 18 API Calls need an Emergency Fix!</figcaption></figure><p id="2199" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以你已经升级到React 18，启用了<a class="ae kx" href="https://reactjs.org/docs/strict-mode.html" rel="noopener ugc nofollow" target="_blank">严格模式</a>，现在你所有的使用效果都被调用了两次。</p><p id="84e3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这通常是好的，但是你在你的useEffects中有API调用，所以你在开发模式中看到双重流量。听起来熟悉吗？没问题，我会帮你解决一些潜在的问题。</p><h1 id="9543" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">解决方法1:接受现实</h1><p id="5c99" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">一个合理的选择就是忍受它，这只是开发模式的行为。它还试图通过对您的组件进行压力测试来帮助您，以确保它们与React中的未来功能兼容。但是，嘿，我明白，你在这里，你不喜欢它，所以…让我们继续前进。</p><h1 id="790f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">修复2:删除严格模式</h1><p id="8a33" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">是严格模式导致了双重渲染，所以另一个选择就是删除它。在<code class="fe mb mc md me b">index.js</code>中使用了现成的StrictMode组件，它在这里:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="d3aa" class="mn kz in me b gy mo mp l mq mr">root.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;App /&gt;<br/>  &lt;/React.StrictMode&gt;<br/>);</span></pre><p id="6533" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简单地把它拿掉，就像这样:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="7b8b" class="mn kz in me b gy mo mp l mq mr">root.render(&lt;App /&gt;);</span></pre><p id="17d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">也就是说，我不推荐这种方式，因为严格模式对你的应用程序代码做了很多有益的检查，所以你真的要考虑保留它。</p><h1 id="cc88" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">修复3:使用中止控制器</h1><p id="ff83" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">另一个修复方法是使用AbortController来终止来自第一个<code class="fe mb mc md me b">useEffect</code>的请求。假设这是您的代码:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="5de5" class="mn kz in me b gy mo mp l mq mr">  const [people, setPeople] = useState([]);<br/>  useEffect(() =&gt; {<br/>    fetch("/people")<br/>      .then((res) =&gt; res.json())<br/>      .then(setPeople);<br/>  }, []);</span></pre><p id="1a85" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这段代码在React 17中没什么问题，但在18中的严格模式下，在开发模式下挂载、卸载和重新挂载组件会出现问题。这表明，如果在卸载组件之前没有完成获取，您不会中止获取。所以让我们补充一下<code class="fe mb mc md me b">AbortController</code>的逻辑。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="b1b0" class="mn kz in me b gy mo mp l mq mr">  useEffect(() =&gt; {<br/><strong class="me io">    const controller = new AbortController();<br/></strong>    fetch("/people", <strong class="me io">{<br/>      signal: controller.signal,<br/>    }</strong>)<br/>      .then((res) =&gt; res.json())<br/>      .then(setPeople);<br/><strong class="me io">    return () =&gt; controller.abort();<br/></strong>  }, []);</span></pre><p id="fe0b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">代码非常简单。我们创建一个新的<code class="fe mb mc md me b">AbortController</code>，然后将它的<code class="fe mb mc md me b">signal</code>传递给<code class="fe mb mc md me b">fetch</code>，在我们的清理函数中，我们调用了<code class="fe mb mc md me b">abort</code>方法。</p><p id="8519" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在将要发生的是，第一个请求将被中止，但第二个装载不会中止，提取将成功完成。</p><p id="6d2f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我认为大多数人会使用这种方法，如果不是因为一件事，在Inspector中你会看到两个请求，其中第一个是红色的，因为它已经被取消了，这很难看。</p><h1 id="8f24" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">修复4:创建自定义提取器</h1><p id="8d36" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">JavaScript承诺的一个很酷的方面是，您可以像使用缓存一样使用它。一旦承诺被解决(或拒绝),您可以继续调用<code class="fe mb mc md me b">then</code>或<code class="fe mb mc md me b">catch</code>,您将获得解决(或拒绝)的值。它不会<strong class="kb io">而不是</strong>对已实现的承诺发出后续请求，它只会返回已实现的结果。</p><p id="5ffa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">由于这种行为，您可以构建一个创建自定义缓存<code class="fe mb mc md me b">fetch</code>函数的函数，如下所示:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="d675" class="mn kz in me b gy mo mp l mq mr">const createFetch = () =&gt; {<br/><em class="ms">  // Create a cache of fetches by URL<br/></em>  const fetchMap = {};</span><span id="f1cb" class="mn kz in me b gy mt mp l mq mr">  return (url, options) =&gt; {<br/><em class="ms">    // Check to see if its not in the cache otherwise fetch it<br/></em>    if (!fetchMap[url]) {<br/>      fetchMap[url] = fetch(url, options).then((res) =&gt; res.json());<br/>    }</span><span id="a53a" class="mn kz in me b gy mt mp l mq mr"><em class="ms">    // Return the cached promise<br/></em>    return fetchMap[url];<br/>  };<br/>};</span></pre><p id="b05a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个<code class="fe mb mc md me b">createFetch</code>函数将为您创建一个缓存的<code class="fe mb mc md me b">fetch</code>。如果你用同一个URL调用它两次，它将返回相同的承诺。所以你可以这样制作一个新的<code class="fe mb mc md me b">fetch</code>:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="701b" class="mn kz in me b gy mo mp l mq mr"><em class="ms">const</em> myFetch =<em class="ms"> createFetch</em>();</span></pre><p id="1762" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后用它在你的<code class="fe mb mc md me b">useEffect</code>中代替<code class="fe mb mc md me b">fetch</code>用一个简单的替换:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="d619" class="mn kz in me b gy mo mp l mq mr">  const [people, setPeople] = useState([]);<br/>  useEffect(() =&gt; {<br/>    <strong class="me io">myFetch</strong>("/people").then(setPeople);<br/>  }, []);</span></pre><p id="98c0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这就是为什么会这样。第一次调用<code class="fe mb mc md me b">useEffect</code>时<code class="fe mb mc md me b">myFetch</code>启动<code class="fe mb mc md me b">fetch</code>并将承诺存储在<code class="fe mb mc md me b">fetchMap</code>中。然后第二次调用<code class="fe mb mc md me b">useEffect</code>函数时，<code class="fe mb mc md me b">myFetch</code>函数返回缓存的承诺，而不是再次调用<code class="fe mb mc md me b">fetch</code>。</p><p id="fa4d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您选择使用这种方法，那么这里唯一需要解决的问题就是缓存失效。</p><h1 id="683e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">修复5:使用反应查询</h1><p id="3be4" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">如果您使用<a class="ae kx" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React-Query </a>，这些都不是问题。React-Query是一个神奇的库，无论如何你都应该诚实地使用它。从React-Query开始，首先安装<code class="fe mb mc md me b">react-query</code> NPM包。</p><p id="3724" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">从那里创建一个查询客户端，并将您的应用程序包装在一个<code class="fe mb mc md me b">QueryProvider</code>组件中:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="fa26" class="mn kz in me b gy mo mp l mq mr"><em class="ms">import</em> { <strong class="me io">QueryClient</strong>, <strong class="me io">QueryClientProvider</strong>} <em class="ms">from</em> "react-query";</span><span id="ccf6" class="mn kz in me b gy mt mp l mq mr">...</span><span id="c54f" class="mn kz in me b gy mt mp l mq mr">const AppWithProvider = () =&gt; (<br/><strong class="me io">  &lt;QueryClientProvider client={new QueryClient()}&gt;<br/></strong>    &lt;App /&gt;<br/><strong class="me io">  &lt;/QueryClientProvider&gt;<br/></strong>);</span></pre><p id="5899" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后在你的组件中使用<code class="fe mb mc md me b">useQuery</code>钩子，像这样:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="2194" class="mn kz in me b gy mo mp l mq mr">  const { data: people } = useQuery("people", () =&gt;<br/>    fetch("/people").then((res) =&gt; res.json())<br/>  );</span></pre><p id="b69c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那不是看起来更好吗？它不做双重提取。</p><p id="10b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这只是React-Query所能做的事情的一小部分。人们使用React-Query不仅仅是为了获取数据，还可以用它来监控任何基于承诺的异步工作。</p><h1 id="7e22" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">修复6:使用状态管理器</h1><p id="25f9" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我不打算在这一点上进入代码细节，因为它很大程度上取决于您使用的状态管理器。但是如果你使用Redux，那么如果你使用Redux工具包中的<a class="ae kx" href="https://redux-toolkit.js.org/rtk-query/overview" rel="noopener ugc nofollow" target="_blank"> RTK查询功能</a>，你将不会受到这种双重挂载行为的影响。</p><h1 id="2192" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">你不应该做什么</h1><p id="dad5" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我强烈建议不要使用<code class="fe mb mc md me b">useRef</code>来试图击败这种行为。不能保证第一次<code class="fe mb mc md me b">useEffect</code>调用的组件就是第二次调用的组件。所以如果你做一些事情，比如使用<code class="fe mb mc md me b">useRef</code>在坐骑之间进行追踪，那么……不清楚这是否可行。</p><p id="d1ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，当前用来创建<code class="fe mb mc md me b">useEffectOnce</code>的代码也不起作用。它不调用清理函数。这比调用两次<code class="fe mb mc md me b">useEffect</code>要糟糕得多。</p><h1 id="2dfd" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">你应该做什么</h1><p id="1a46" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">如果你喜欢这个内容，你应该看看我的<a class="ae kx" href="https://www.youtube.com/c/JackHerrington" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>。我一直在报道这样的话题。事实上，我已经在那边讲过了<code class="fe mb mc md me b"><a class="ae kx" href="https://youtu.be/j8s01ThR7bQ" rel="noopener ugc nofollow" target="_blank">useEffect</a></code> <a class="ae kx" href="https://youtu.be/j8s01ThR7bQ" rel="noopener ugc nofollow" target="_blank">主题，但是我还没有具体讲过API调用方面…还没有。</a></p><p id="fda1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="ms">更多内容看</em> <a class="ae kx" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ms">说白了。报名参加我们的</em> <a class="ae kx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ms">免费周报</em> </strong> </a> <em class="ms">。关注我们关于</em><a class="ae kx" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ms">Twitter</em></strong></a><em class="ms">和</em><a class="ae kx" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ms">LinkedIn</em></strong></a><em class="ms">。查看我们的</em> <a class="ae kx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ms">社区不和谐</em> </strong> </a> <em class="ms">加入我们的</em> <a class="ae kx" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ms">人才集体</em> </strong> </a> <em class="ms">。</em></strong></a></p></div></div>    
</body>
</html>