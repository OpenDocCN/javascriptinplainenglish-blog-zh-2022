<html>
<head>
<title>A Deep Introduction to Property Decorators in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对TypeScript中属性装饰器的深入介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec?source=collection_archive---------9-----------------------#2022-02-17">https://javascript.plainenglish.io/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec?source=collection_archive---------9-----------------------#2022-02-17</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="57f0" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">向TypeScript类中的属性添加数据和功能</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/ef981499854cc12320f3c32bbd34091e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XWDVlEKMwZpHMS46.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Image by Author, using logos from corresponding projects</figcaption></figure><p id="351e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">Decorators允许我们在TypeScript中向类或方法添加额外的信息，类似于Java中的注释。属性装饰器应用于TypeScript中的属性定义，并且可以观察它们。</p><p id="9b58" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在本文中，我们将探讨属性装饰器的使用和开发。这些装饰器附加到TypeScript类中的属性或字段，它们能够观察到已经为特定的类声明了一个属性。要使用decorator，必须在TypeScript中启用它们，所以请务必<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">阅读本系列的decorator介绍文章</a>。</p><p id="a389" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">实际上，它们看起来像这样:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="9559" class="ly lz ir lu b gz ma mb l mc md">class ContainingClass {<br/><br/>    @Decorator(?? optional parameters)<br/>    name: type;<br/>}</span></pre><p id="e7cf" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文是系列文章的一部分:</p><p id="24fa" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文是系列文章的一部分:</p><ul class=""><li id="ef28" class="me mf ir ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">装修工入门</a></li><li id="816c" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae ls" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装修工</a></li><li id="1a9f" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><strong class="ky is">物业装修工</strong> <em class="ms">本条</em></li><li id="70f8" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">访问器装饰器</a></li><li id="f9f6" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-parameter-decorators-in-typescript-b0042b5474ed">参数装饰器</a></li><li id="7908" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">方法装饰者</a></li><li id="4c5f" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0">混合装修工</a></li><li id="ee28" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7">反射和带装饰器的反射API</a></li><li id="11a1" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5">使用装饰器和反射元数据在TypeScript中进行运行时数据验证</a></li></ul><h1 id="d2aa" class="mt lz ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">TypeScript中的属性装饰函数</h1><p id="ae4d" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">属性装饰器附加到类定义中的属性上。在JavaScript中，属性是与对象相关联的值。最简单的属性只是在对象中声明的一个字段。</p><p id="f46b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">属性装饰函数接收两个参数:</p><ol class=""><li id="e95b" class="me mf ir ky b kz la lc ld lf mg lj mh ln mi lr np mk ml mm bi translated">静态成员的类的构造函数，或者实例成员的类的原型。</li><li id="4721" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr np mk ml mm bi translated">给出属性名称的字符串</li></ol><p id="feba" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这为属性装饰函数定义了一个必需的签名。请注意，我们没有得到指向与属性相关的PropertyDescriptor对象的指针。TypeScript文档解释说这是因为属性如何被实例化的细节。因此，结果是除了观察到以该名称命名的属性存在之外，不能做任何事情。</p><p id="80c5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">访问器装饰器接收PropertyDescriptor对象。如果您的应用程序需要该对象，那么就专注于使用访问器。</p><p id="c8cb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">让我们尝试一个简单的类装饰器的例子，它简单地打印给定的数据。</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="1da5" class="ly lz ir lu b gz ma mb l mc md">function logProperty(target: Object, member: string): any {<br/>    console.log(`PropertyExample logProperty ${target} ${member}`);<br/>}<br/><br/>class PropertyExample {<br/><br/>    @logProperty<br/>    name: string;<br/>}<br/><br/>const pe = new PropertyExample();<br/>if (!pe.hasOwnProperty('name')) {<br/>    console.log(`No property 'name' on pe`);<br/>}<br/>pe.name = "Stanley Steamer";<br/>if (!pe.hasOwnProperty('name')) {<br/>    console.log(`No property 'name' on pe`);<br/>}<br/><br/>console.log(pe);</span></pre><p id="ff49" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe nq nr ns lu b">logProperty</code>函数实现了属性装饰器所需的签名。</p><p id="9509" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在实验过程中，我们了解到，尽管在这个类中明确定义了<code class="fe nq nr ns lu b">name</code>属性，但是对<code class="fe nq nr ns lu b">hasOwnProperty</code>的第一次调用返回了<code class="fe nq nr ns lu b">false</code>，表明该属性不存在。也就是说，研究这个输出:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="2417" class="ly lz ir lu b gz ma mb l mc md">$ node dist/property.js <br/>PropertyExample logProperty [object Object] name<br/>No property 'name' on pe<br/>PropertyExample { name: 'Stanley Steamer' }</span></pre><p id="fb6b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">事情是这样的:</p><ol class=""><li id="c092" class="me mf ir ky b kz la lc ld lf mg lj mh ln mi lr np mk ml mm bi translated">输出的第一行来自装饰器内部，显示了我们收到的内容，演示了装饰器函数的执行。</li><li id="00d4" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr np mk ml mm bi translated">但是下一行输出发生了，因为<code class="fe nq nr ns lu b">pe.hasOwnProperty('name')</code>返回<code class="fe nq nr ns lu b">false</code>，表明该属性不存在。<code class="fe nq nr ns lu b">hasOwnProperty</code>函数是从<code class="fe nq nr ns lu b">Object</code>类中派生出来的，它指示对象是否具有该名称的属性。</li><li id="28dd" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr np mk ml mm bi translated">然后代码给<code class="fe nq nr ns lu b">pe.name</code>赋值。</li><li id="316c" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr np mk ml mm bi translated">之后，<code class="fe nq nr ns lu b">hasOwnProperty</code>表示该属性存在。</li><li id="6dbc" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr np mk ml mm bi translated">属性值由<code class="fe nq nr ns lu b">console.log</code>打印。</li></ol><p id="8459" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是不是告诉我们，在数据被分配给属性之前，属性是不存在的？</p><p id="83cf" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了更深入地研究这一点，让我们尝试检索PropertyDescriptor对象:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="1939" class="ly lz ir lu b gz ma mb l mc md">function logProperty(target: Object, member: string): any {<br/>    console.log(`PropertyExample logProperty ${target} ${member}`);<br/>}<br/><br/>function GetDescriptor() {<br/>    return (target: Object, member: string) =&gt; {<br/>        const prop = Object.getOwnPropertyDescriptor(target, member);<br/>        console.log(`Property ${member} ${prop}`);<br/>    };<br/>}<br/><br/>class Student {<br/><br/>    @GetDescriptor()<br/>    year: number;<br/>}<br/><br/>const stud1 = new Student();<br/>console.log(Object.getOwnPropertyDescriptor(stud1, 'year'));<br/>stud1.year = 2022;<br/>console.log(Object.getOwnPropertyDescriptor(stud1, 'year'));</span></pre><p id="c2c1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe nq nr ns lu b">Object</code>类有两个函数<code class="fe nq nr ns lu b">getOwnPropertyDescriptor</code>和<code class="fe nq nr ns lu b">defineProperty</code>，与属性的PropertyDescriptor对象相关。这个脚本在装饰器执行时调用<code class="fe nq nr ns lu b">getOwnPropertyDescriptor</code>,然后在对象实例创建之后，然后在属性赋值之后。</p><p id="0def" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">让我们运行这个脚本:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="f271" class="ly lz ir lu b gz ma mb l mc md">$ npx ts-node lib/properties/descriptor.ts <br/>Property year undefined<br/>undefined<br/>{ value: 2022, writable: true, enumerable: true, configurable: true }</span></pre><p id="a144" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在给属性赋值之前，我们无法获取描述符。这证实了我们之前提出的理论。</p><p id="6508" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">TypeScript文档是这样说的:</p><blockquote class="nt nu nv"><p id="6558" class="kw kx ms ky b kz la js lb lc ld jv le nw lg lh li nx lk ll lm ny lo lp lq lr ik bi translated"><em class="ir">注意，由于属性装饰器在TypeScript中的初始化方式，属性描述符不会作为参数提供给属性装饰器。这是因为在定义原型的成员时，目前没有机制来描述实例属性，也没有方法来观察或修改属性的初始化器。</em></p></blockquote><p id="06cd" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">换句话说，PropertyDescriptor函数在property descriptor对象存在之前执行。</p><h1 id="4262" class="mt lz ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">向框架注册属性设置</h1><p id="b794" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">在decorator函数中，我们得到了一个目标对象、属性名以及传递给decorator函数的任何参数。我们无法覆盖或修改属性的行为。我们能做的是记录来自装饰器的数据，就像我们在用框架注册一个类的<a class="ae ls" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">例子中所做的那样。</a></p><p id="f0a0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">出于基本原理，考虑数据验证的框架。我们可以将decorators附加到描述可接受值的属性上，然后验证框架将使用这些设置来确定一个值是否可接受。</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="b000" class="ly lz ir lu b gz ma mb l mc md">const registered = [];<br/><br/>function IntegerRange(min: number, max: number) {<br/>    return (target: Object, member: string) =&gt; {<br/>        registered.push({<br/>            target, member,<br/>            operation: {<br/>                op: 'intrange',<br/>                min, max<br/>            }<br/>        });<br/>    }<br/>}<br/><br/>function Matches(matcher: RegExp) {<br/>    return (target: Object, member: string) =&gt; {<br/>        registered.push({<br/>            target, member,<br/>            operation: {<br/>                op: 'match',<br/>                matcher<br/>            }<br/>        });<br/>    }<br/>}</span></pre><p id="d9b8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">下面是一对属性装饰工厂函数。第一个记录了一个验证操作，该操作确保值是给定范围内的整数。另一个操作是针对正则表达式的字符串匹配。两者的数据都记录在<code class="fe nq nr ns lu b">registered</code>数组中。</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="8391" class="ly lz ir lu b gz ma mb l mc md">class StudentRecord {<br/><br/>    @IntegerRange(1900, 2050)<br/>    year: number;<br/><br/>    @Matches(/^[a-zA-Z ]+$/)<br/>    name: string;<br/>}<br/><br/>const sr1 = new StudentRecord();<br/><br/>console.log(registered);</span></pre><p id="faaf" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ms"> StudentRecord </em>类正在使用这两个属性。然后我们生成该类的一个实例，并打印出<code class="fe nq nr ns lu b">registered</code>数组。</p><p id="72d0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在真正的验证框架中，我们会使用反射元数据API将这些数据存储到一个属性中。我们将在稍后讨论该API时讨论这个问题。</p><p id="2750" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">现在，让我们运行应用程序:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="0d87" class="ly lz ir lu b gz ma mb l mc md">$ npx ts-node lib/properties/register.ts <br/>[<br/>  {<br/>    target: {},<br/>    member: 'year',<br/>    operation: { op: 'intrange', min: 1900, max: 2050 }<br/>  },<br/>  {<br/>    target: {},<br/>    member: 'name',<br/>    operation: { op: 'match', matcher: /^[a-zA-Z ]+$/ }<br/>  }<br/>]</span></pre><p id="aaa1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">并且，<code class="fe nq nr ns lu b">registered</code>数组确实记录了可能对这样一个框架有用的信息。</p><p id="84c5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">无论我们是否实例化StudentRecord类实例，数组都用这些值填充。注释掉<code class="fe nq nr ns lu b">new StudentRecord</code>行，然后重新运行脚本，同样的数据被打印出来。</p><p id="510f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们已经证明，在另一个地方记录任何我们喜欢的关于房产的数据是非常容易的。在某种框架中，其他功能可以参考这些数据并做一些有用的事情。</p><h1 id="84cc" class="mt lz ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">走进死胡同的路径使用<code class="fe nq nr ns lu b">Object.defineProperty</code></h1><p id="6967" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">其他博客上关于properties decorator的几篇教程文章建议使用<code class="fe nq nr ns lu b">Object.defineProperty</code>来实现运行时数据验证。该建议的缺陷就是我们刚刚演示的PropertyDescriptor对象对properties decorator函数不可用。我们需要讨论一下使用<code class="fe nq nr ns lu b">defineProperty</code>的不正确建议。</p><p id="e11c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">让我们从装饰函数开始:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="3848" class="ly lz ir lu b gz ma mb l mc md">function ValidRange(min: number, max: number) {<br/>    return (target: Object, member: string) =&gt; {<br/>        console.log(`Installing ValidRange on ${member}`);<br/>        let value: number;<br/>        Object.defineProperty(target, member, {<br/>            enumerable: true,<br/>            get: function() {<br/>                console.log("Inside ValidRange get");<br/>                return value;<br/>            },<br/>            set: function(v: number) {<br/>                console.log(`Inside ValidRange set ${v}`);<br/>                if (v &lt; min || v &gt; max) {<br/>                    throw new Error(`Not allowed value ${v}`);<br/>                }<br/>                value = v;<br/>            }<br/>        });<br/>    }<br/>}</span></pre><p id="c6b5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这个装饰器旨在与一个数字属性一起使用，并在<code class="fe nq nr ns lu b">min</code>和<code class="fe nq nr ns lu b">max</code>之间强制一个有效的范围。它用<code class="fe nq nr ns lu b">get</code> / <code class="fe nq nr ns lu b">set</code>函数调用<code class="fe nq nr ns lu b">defineProperty</code>，其中<code class="fe nq nr ns lu b">set</code>函数强制范围。对于数据存储，函数将值存储在局部变量中。这看起来简单明了，不是吗？</p><p id="2c5a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这段代码经过精心设置，以匹配前面提到的其他博客中出现的装饰函数。其中一个博客的底部有评论指出了一个问题。看看你自己能否发现这个错误。</p><p id="1394" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要进行测试，请将以下内容添加到脚本中:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="b2e0" class="ly lz ir lu b gz ma mb l mc md">class Student {<br/>    @ValidRange(1900, 2050)<br/>    year: number;<br/>}<br/><br/>const stud = new Student();<br/>const stud2 = new Student();<br/><br/>stud.year = 1901;<br/>stud2.year = 1911;<br/>console.log(`stud1 ${stud.year} stud2 ${stud2.year}`);<br/>stud.year = 2030;<br/>console.log(`stud1 ${stud.year} stud2 ${stud2.year}`);<br/>// stud.year = 1899;<br/>// console.log(stud.year);<br/><br/>console.log(`stud1 ${stud.year} stud2 ${stud2.year}`);<br/>stud2.year = 2022;<br/>console.log(`stud1 ${stud.year} stud2 ${stud2.year}`);<br/>stud2.year = 2023;<br/>console.log(`stud1 ${stud.year} stud2 ${stud2.year}`);</span></pre><p id="b17e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这定义了一个类，并生成了两个实例。我们给一个或另一个实例赋值，然后打印出这些值。如果您想看到数据验证的运行，注释掉分配<code class="fe nq nr ns lu b">1899</code>的行，您将看到它抛出一个异常。</p><p id="4974" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">相反，让我们继续运行:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="03bf" class="ly lz ir lu b gz ma mb l mc md">$ npx ts-node lib/properties/descriptor2.ts <br/>Installing ValidRange on year<br/>Inside ValidRange set 1901<br/>Inside ValidRange set 1911<br/>Inside ValidRange get<br/>Inside ValidRange get<br/>stud1 1911 stud2 1911<br/>Inside ValidRange set 2030<br/>Inside ValidRange get<br/>Inside ValidRange get<br/>stud1 2030 stud2 2030<br/>Inside ValidRange get<br/>Inside ValidRange get<br/>stud1 2030 stud2 2030<br/>Inside ValidRange set 2022<br/>Inside ValidRange get<br/>Inside ValidRange get<br/>stud1 2022 stud2 2022<br/>Inside ValidRange set 2023<br/>Inside ValidRange get<br/>Inside ValidRange get<br/>stud1 2023 stud2 2023</span></pre><p id="7d69" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">每次设置或检索值时，我们都会打印出来。我们看到<code class="fe nq nr ns lu b">stud1</code>和<code class="fe nq nr ns lu b">stud2</code>分别被赋值为<code class="fe nq nr ns lu b">1901</code>和<code class="fe nq nr ns lu b">1911</code>，但是当这两个值被打印出来时，它们都是<code class="fe nq nr ns lu b">1911</code>。无论我们给哪个变量赋值，另一个变量都显示相同的值。</p><p id="993b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">发生什么事了？我们之前要求你指出错误。你做得怎么样？</p><p id="55d1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">问题是装饰函数内部的数据存储。在构造类定义时，对于给定的类中的每个属性，该函数只执行一次。该函数不是在每次创建类的实例时执行，而是在创建定义时执行。存储数据的本地变量<code class="fe nq nr ns lu b">value</code>只创建一次。<code class="fe nq nr ns lu b">instance</code>的实例在decorator函数的堆栈框架内，对于每个类的每个属性只执行一次。</p><p id="3edf" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这意味着存储在<code class="fe nq nr ns lu b">value</code>中的数据在所有使用<code class="fe nq nr ns lu b">@ValidRange</code>的属性实例之间共享。这是因为当使用<code class="fe nq nr ns lu b">@ValidRange</code>时，属性的数据存储由装饰器管理，而不是由JavaScript管理。</p><p id="1227" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在本例中，我们有一个类Student，它有一个属性<code class="fe nq nr ns lu b">year</code>，这个属性用<code class="fe nq nr ns lu b">@ValidRange</code>装饰。正如我们所展示的，相同的值在<code class="fe nq nr ns lu b">year</code>的两个实例之间共享。</p><p id="7ffe" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要验证此行为，请将以下字段添加到Student类中:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="6995" class="ly lz ir lu b gz ma mb l mc md">@ValidRange(0, 150)<br/>age: number;</span></pre><p id="b57d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们正在建立由<code class="fe nq nr ns lu b">@ValidRange</code>管理的另一个属性。我们会遇到同样的数据共享问题吗？<code class="fe nq nr ns lu b">age</code>的值会和<code class="fe nq nr ns lu b">year</code>的值一样吗？</p><p id="7c08" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">进行以下更改:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="1e40" class="ly lz ir lu b gz ma mb l mc md">stud.year = 1901;<br/>stud2.year = 1911;<br/>stud.age = 20;<br/>console.log(`stud1 ${stud.year} ${stud.age} stud2 ${stud2.year} ${stud2.age}`);</span></pre><p id="2004" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这为一个学生实例中的<code class="fe nq nr ns lu b">age</code>赋值，然后为两个实例打印<code class="fe nq nr ns lu b">age</code>。</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="3fec" class="ly lz ir lu b gz ma mb l mc md">Installing ValidRange on year<br/>Installing ValidRange on age<br/>Inside ValidRange set 1901<br/>Inside ValidRange set 1911<br/>Inside ValidRange set 20<br/>Inside ValidRange get<br/>Inside ValidRange get<br/>Inside ValidRange get<br/>Inside ValidRange get<br/>stud1 1911 20 stud2 1911 20</span></pre><p id="a142" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe nq nr ns lu b">year</code>和<code class="fe nq nr ns lu b">age</code>属性的值彼此不同，但在<code class="fe nq nr ns lu b">Student</code>实例之间共享。我们只给一个值赋值一次，但是请注意，两个实例打印的是相同的值。</p><p id="f427" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了进一步演示，生成一个新的学生实例:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="bbd1" class="ly lz ir lu b gz ma mb l mc md">const stud3 = new Student();</span></pre><p id="4eda" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">然后，不要给该实例分配任何值，而是添加一个<code class="fe nq nr ns lu b">console.log</code>语句:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="5b8f" class="ly lz ir lu b gz ma mb l mc md">console.log(`stud3 ${stud3.year} ${stud3.age}`);</span></pre><p id="e006" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">当脚本执行时，您会看到:</p><pre class="kh ki kj kk gu lt lu lv lw aw lx bi"><span id="0efe" class="ly lz ir lu b gz ma mb l mc md">stud3 1911 20</span></pre><p id="ae18" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">相同的值显示在<code class="fe nq nr ns lu b">stud3</code>中，尽管没有分配任何值。</p><p id="3305" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">属性的每个实例共享相同的值，就像属性的每个实例一样。这是因为<code class="fe nq nr ns lu b">@ValidRange</code>管理数据存储，而不是JavaScript来做。这背后的原因是使用<code class="fe nq nr ns lu b">Object.defineProperty</code>的方式不正确。JavaScript确实给了我们很多搬起石头砸自己脚的工具。</p><p id="8ab7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">当我阅读其他关于属性装饰者的博客文章时，令人惊讶的是运行时数据验证是多么容易。但是，这些帖子中展示的技术是一条死胡同，因为在实现中有一个主要的缺陷。</p><p id="4423" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在property decorator函数执行时，JavaScript还没有创建PropertyDescriptor对象。覆盖该属性描述符的<code class="fe nq nr ns lu b">get</code> / <code class="fe nq nr ns lu b">set</code>函数可能会非常有用。创建自己的属性描述符并认为已经达到了运行时数据验证的目标是一种误导。</p><p id="f1fc" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在我们关于<a class="ae ls" href="https://techsparx.com/nodejs/typescript/decorators/accessors.html" rel="noopener ugc nofollow" target="_blank">访问器装饰器</a>的文章中，我们展示了一种简单的方法，通过在正确的属性描述符中覆盖<code class="fe nq nr ns lu b">get</code> / <code class="fe nq nr ns lu b">set</code>函数来实现运行时数据验证。</p><h1 id="8d58" class="mt lz ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">摘要</h1><p id="30cf" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">我们能够将装饰者附加到属性上。这意味着我们可以记录与每个属性相关的装饰者的信息，然后用这些数据做一些事情。但是，我们无法访问PropertyDescriptor，也无法使用<code class="fe nq nr ns lu b">get</code> / <code class="fe nq nr ns lu b">set</code>函数做任何事情。</p><p id="478f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">原因是当类装饰函数执行时。</p><p id="3048" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如果我们可以覆盖PropertyDescriptor中的<code class="fe nq nr ns lu b">get</code> / <code class="fe nq nr ns lu b">set</code>方法，有很多可能性。但是，对于属性，在为属性赋值之前，该对象并不存在。</p><p id="f2e6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们注意到访问器装饰函数确实接收到了PropertyDescriptor对象。我们将在<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">对TypeScript </a>中的访问器装饰器的深入介绍中探讨如何处理这个问题。</p><p id="e9cc" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们能够做的是在数据结构中记录装饰者信息。例如，<code class="fe nq nr ns lu b">class-validator</code>包有类似于<code class="fe nq nr ns lu b">@IsInt</code>或<code class="fe nq nr ns lu b">@Min</code>或<code class="fe nq nr ns lu b">@Max</code>的装饰器来验证属性值。我们知道它必须将这些记录到一个数据结构中，当应用程序调用<code class="fe nq nr ns lu b">validate</code>函数时，它必须检查这些数据以知道如何验证类实例。</p><h1 id="c0ed" class="mt lz ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">关于作者</h1><p id="1af8" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated"><a class="ae ls" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ms">大卫·赫伦</em> </strong> </a> <em class="ms">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl nz oa hv ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ik il im in io"><p id="27be" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ms">原载于</em><a class="ae ls" href="https://techsparx.com/nodejs/typescript/decorators/properties.html" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://techsparx.com</em></a><em class="ms">。</em></p><p id="794b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ms">更多内容请看</em><a class="ae ls" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky is"><em class="ms">plain English . io</em></strong></a><em class="ms">。报名参加我们的</em> <a class="ae ls" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ms">免费周报</em> </strong> </a> <em class="ms">。在我们的</em> <a class="ae ls" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ms">社区</em> </strong> </a> <em class="ms">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>