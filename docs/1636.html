<html>
<head>
<title>How to Migrate a REST API to GraphQL the Smart Way with StepZen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用StepZen以智能的方式将REST API迁移到GraphQL</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-migrate-a-rest-api-to-graphql-the-smart-way-with-stepzen-5e60b7908291?source=collection_archive---------11-----------------------#2022-04-07">https://javascript.plainenglish.io/how-to-migrate-a-rest-api-to-graphql-the-smart-way-with-stepzen-5e60b7908291?source=collection_archive---------11-----------------------#2022-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="49a4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">为什么GraphQL可能比RESTful APIs更适合您的下一个项目</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/905caab9ec7161efd8cfc6d1dc7b68bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ynAmRgJKU0MLvTN3"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Original Photo by <a class="ae ks" href="https://www.pexels.com/@ann-poan-3111643?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Ann poan</a> from <a class="ae ks" href="https://www.pexels.com/photo/laptop-on-desk-near-lush-houseplant-5797997/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="ab29" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">随着从单一应用程序的转变，REST APIs已经成为标准化系统中不同移动部分如何协同工作和共享数据的首选方法。然而，REST也是一个不灵活的、通常不明确的标准(它只是一组指导原则)，有几个架构和实现问题，并且已经被证明不能很好地适应现代客户的需求——数据密集型和快速变化的需求。</p><p id="3252" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这正是GraphQL要解决的问题！带来灵活性和效率，并使处理大量数据变得轻而易举。</p><p id="0be1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将看看GraphQL如何比RESTful APIs更适合您的下一个项目，作为一个例子，通过使用免费工具<a class="ae ks" href="https://stepzen.com/" rel="noopener ugc nofollow" target="_blank"> StepZen </a>，将现有的REST API转换为GraphQL。</p><h1 id="1a7f" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">GraphQL如何改进REST APIs</h1><p id="3730" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">除了最简单的实现，REST APIs的设计会导致客户端:</p><p id="f256" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.下载<strong class="kv io">比实际需要更多的</strong>数据——因为API响应可能<em class="mm">也</em>包括对特定客户端无用的无关数据，</p><p id="d7e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.或者<strong class="kv io">不够</strong>——导致客户端用更多的请求来敲打API服务器，以获取它需要的数据(第一个get获取N个结果+对这N个结果中的每一个<strong class="kv io">进行一次GET，总共1+N个请求)</strong></p><p id="2493" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">无论哪种方式，我们都将面临服务器端和客户端的高带宽使用，这是一个坏消息，因为大多数网络应用消费都是在4G/5G上，即计量连接。</p><p id="5192" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">GraphQL通过使用声明性查询语法解决了这些问题。由于使用GraphQL API的每个客户端都有能力指定他们需要的精确数据，该API只提供这些数据——不多也不少<strong class="kv io"> — </strong>极大地减少了有效负载的大小。此外，客户端实际上可以访问不同数据之间定义的关系，并且可以一次性获得所有关系，而不需要1+N请求，也不需要编程来批处理或并行化API调用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/b12de7dfb78cfcfe8a7976482edbc207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nxe3ck1rVB377h-g"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Imagine REST APIs…that <em class="mo">also</em> let you transfer your SQL querying skills.</figcaption></figure><p id="dbd1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有一些附带的好处:GraphQL是严格类型化的，API中公开的所有类型都在模式中定义。现在，您可以将前端与后端分离，因此前端团队可以通过模仿所需的数据结构来轻松测试他们的应用程序，后端团队可以设计出明确、单一的圣经，即模式。更好的是，<em class="mm">模式本身</em>可以作为API的文档，节省了大量的繁琐工作。</p><h1 id="1cf0" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">那么StepZen在哪里呢？</h1><p id="991f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated"><em class="mm">太好了！那我们就什么都用GraphQL吧！</em>嗯，GraphQL <em class="mm">是</em>的牛逼，但它也是一项相对较新的技术，大多数公开的API都不支持它。将REST API迁移到GraphQL也不简单，而且会带来一些问题。</p><p id="05fa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不要害怕，这是StepZen的救援！</p><p id="64a7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简而言之，StepZen是一个GraphQL抽象层，用于<em class="mm">您所有的</em>数据源，它在幕后做了大量的工作，使您可以非常容易地将关系数据库、REST APIs、其他GraphQL APIs，无论您有什么，组合成一个单一的GraphQL端点，然后您可以在一个无服务器部署上托管它。</p><p id="bfdc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您将获得GraphQL的所有优势，并结合StepZen提供的“即服务”的所有优势—实时操作能力、监控、指标、缓存、服务器基础设施、可伸缩性、确保正常运行时间—为您节省大量时间来设置可伸缩、设计良好的高性能GraphQL API。</p><h1 id="3958" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">案例研究:通过StepZen将REST API迁移到GraphQL</h1><p id="dc32" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">因此，所有的方式，让我们看看我是如何利用StepZen在这里。我经常使用<a class="ae ks" href="https://randomuser.me/" rel="noopener ugc nofollow" target="_blank">randomuser . me</a>API——这是一种面向人们的<em class="mm"> lorem ipsum </em>生成器——来模拟测试前端的数据。有一些方法可以解决它的REST特有的缺点，但是它们使我的API调用更加冗长和复杂，对于这样简单的东西来说，这是多余的。所以我通过StepZen将它迁移到GraphQL，改善了响应时间并减少了近70%的带宽使用！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/6b1120f890d739b6ec1509bb73d05058.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/0*oJ-hnupPvxH-yvmF"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Payload size difference between REST and GraphQL versions of the same API. This effect is amplified further in real-world projects where payload sizes can be in the MegaBytes range for each page of displayed results, and that’s not even counting infinite scrolling and static assets!</figcaption></figure><p id="871f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我的设置非常简单。我在Express上构建了一个API代理服务器，公开了一个端点，该端点代表我的前端调用Randomuser.me API，在将结果发送回我的React应用程序之前对其进行整理和格式化。在真正的网站上，这只会从我的MongoDB存储中提取实际数据。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/04bb80e641481dec577052ca0979e1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AO49JhSuBX0mbo8Z"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">I get names, portrait image URLs, and use that data to mock up a testimonial page, for example.</figcaption></figure><h2 id="7a7e" class="mr lq in bd lr ms mt dn lv mu mv dp lz lc mw mx mb lg my mz md lk na nb mf nc bi translated">步骤0:先决条件</h2><p id="1453" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">StepZen提供了一个漂亮的命令行工具，可以让您快速构建和部署GraphQL API。让我们用npm来获取它并进行全局安装，以确保我们可以使用它的CLI命令。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="73c8" class="mr lq in ne b gy ni nj l nk nl">npm install -g stepzen</span></pre><p id="ce7b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，使用以下信息登录:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="85f2" class="mr lq in ne b gy ni nj l nk nl">stepzen login</span></pre><p id="69d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">…输入您的用户名，然后在出现提示时输入您的管理员密钥。</p><h2 id="b9b5" class="mr lq in bd lr ms mt dn lv mu mv dp lz lc mw mx mb lg my mz md lk na nb mf nc bi translated">步骤1:创建模式</h2><p id="980b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">💡StepZen CLI提供了一种非常简单的方法，可以为您需要点击的每个REST API端点自动创建模式(<code class="fe nm nn no ne b">stepzen import</code>命令),但是首先，让我们以“普通”的方式来做，因为这将帮助您熟悉如何创建GraphQL模式。我们一会儿就回来讨论这个问题！</p><p id="3c8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">创建一个新的项目目录，给它起一个有意义的名字，在这个目录中，创建一个名为<strong class="kv io"> randomuser.graphql </strong>的新文件——这是您的模式文件。这是我们定义类型和查询的地方，为我们需要的每个REST API指定端点。</p><p id="8793" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的具体用例非常简单，我们只需要点击https://randomuser.me/api/的<a class="ae ks" href="https://randomuser.me/api/" rel="noopener ugc nofollow" target="_blank"/>，可选地传入一个整数(表示我们希望生成的用户数量)作为查询参数。因此，我们的模式的内容将如下所示:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="5146" class="mr lq in ne b gy ni nj l nk nl"><strong class="ne io">./randomuser.graphql</strong><br/>--------------------------------------------------------------------</span><span id="53a0" class="mr lq in ne b gy np nj l nk nl">type User {<br/>  gender: String!<br/>  name: JSON!<br/>  location: JSON!<br/>  email: String!<br/>  login: JSON!<br/>  dob: JSON!<br/>  registered: JSON!<br/>  phone: String!<br/>  cell: String!<br/>  id: JSON!<br/>  picture: JSON!<br/>  nat: String!<br/>}</span><span id="e79a" class="mr lq in ne b gy np nj l nk nl">type Query {<br/>  getRandomUser(results: Int!): [User!]!<br/>  @rest(<br/>    endpoint: “https://randomuser.me/api/?results=$results"<br/>    resultroot: “results[]”<br/>  )<br/>}</span></pre><blockquote class="nq nr ns"><p id="d278" class="kt ku mm kv b kw kx jo ky kz la jr lb nt ld le lf nu lh li lj nv ll lm ln lo ig bi translated">GraphQL语法中的感叹号表示不可为空的字段。大括号表示我们期望用户类型的数组作为该查询的输出。</p></blockquote><p id="b502" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">💡正如所承诺的，这里有一个简单的方法:通过简单的<em class="mm">导入</em>一个REST API端点，自动生成一个模式！</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="147d" class="mr lq in ne b gy ni nj l nk nl">stepzen import curl <a class="ae ks" href="https://randomuser.me/api/?results=3" rel="noopener ugc nofollow" target="_blank">https://randomuser.me/api/?results=3</a> — query-name getRandomUser</span></pre><p id="6d40" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将为您创建一些文件和文件夹—最重要的是，自动生成的。curl文件夹中的graphql模式文件，带有一个名为<code class="fe nm nn no ne b">getRandomUser</code>的查询，它接受一个数字作为输入——这正是我们想要的。</p><p id="d132" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">仅此而已，我们已经完成了！比自己编写模式简单得多，而且您可以进一步定制自动生成的模式，以更好地满足您的需求。</p><p id="41cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">或者，您也可以使用StepZen的工具<a class="ae ks" href="https://www.json2sdl.com/" rel="noopener ugc nofollow" target="_blank"> JSON2SDL </a>来为您处理模式创建。或者，简单地使用StepZen从<a class="ae ks" href="https://graphql.stepzen.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL Studio </a>中预先构建的模式之一。</p><p id="2ecb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，对于任何给定的项目，StepZen还需要一个清单文件，这是一个名为<strong class="kv io"> index.graphql </strong>的文件，它将位于同一个目录中。它使用特殊的<code class="fe nm nn no ne b">@sdl</code>指令从所有指定的GraphQL文件中加载模式。如你所料，如果你有多个<strong class="kv io">。graphql </strong>文件，您可以将它们包含在这个数组中。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="66fc" class="mr lq in ne b gy ni nj l nk nl"><strong class="ne io">./index.graphql</strong><br/>--------------------------------------------------------------------</span><span id="85c7" class="mr lq in ne b gy np nj l nk nl">schema @sdl(files: [“randomuser.graphql”]){<br/>  query: Query<br/>}</span></pre><h2 id="c341" class="mr lq in bd lr ms mt dn lv mu mv dp lz lc mw mx mb lg my mz md lk na nb mf nc bi translated">步骤2:部署到云</h2><p id="9ad7" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们完了！开始部署吧！</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="6f1f" class="mr lq in ne b gy ni nj l nk nl">stepzen start</span></pre><p id="a758" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将使用我们指定的数据源创建我们的GraphQL API，并且——如果没有错误——将它部署到云中。您将被要求命名端点(CLI提供了一个您可以更改的默认值)，一旦完成上传，它将为您提供您的端点URL，以及您托管的GraphQL API的本地代理(您可以使用GraphiQL GUI进行浏览)。</p><h2 id="1aa7" class="mr lq in bd lr ms mt dn lv mu mv dp lz lc mw mx mb lg my mz md lk na nb mf nc bi translated">步骤API代理服务器</h2><p id="728b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们现在处于最后冲刺阶段。剩下的工作就是在<strong class="kv io"> index.js </strong>构建我们的Express服务器，它代表我们的前端进行查询。</p><p id="22dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，依赖性。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="45cf" class="mr lq in ne b gy ni nj l nk nl">npm i express axios dotenv</span></pre><p id="e0f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们正在为我们的服务器获取<strong class="kv io"> ExpressJS </strong>，获取<strong class="kv io"> Axios </strong>来发出HTTP请求，获取<strong class="kv io"> dotenv </strong>来存储我们不想在源代码中公开的环境变量——比如我们的服务器端口号、StepZen ApiKey和我们的API端点。(如果你使用的是像GitHub这样面向公众的源代码控件，不要忘记包含<strong class="kv io">。env </strong>文件在您的<strong class="kv io">中。gitignore </strong>！)</p><p id="d988" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，虽然我们可以访问用户类型的任何返回字段，但对于我们的用例，我们只需要名称和图片URL，因此这就是我们将在GraphQL查询中指定的所有内容，为我们节省了大量带宽。因此，我们的GraphQL查询将如下所示:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="0d68" class="mr lq in ne b gy ni nj l nk nl">query MyQuery {<br/>  getRandomUser(results:3){<br/>    name<br/>    picture<br/>  }<br/>}</span><span id="6f0f" class="mr lq in ne b gy np nj l nk nl">--------------------------------------------------------------------<br/><strong class="ne io">./index.js</strong><br/>--------------------------------------------------------------------</span><span id="818d" class="mr lq in ne b gy np nj l nk nl">const axios = require(“axios”).default;<br/>const express = require(“express”);<br/>require(“dotenv”).config();<br/>const app = express();</span><span id="27dd" class="mr lq in ne b gy np nj l nk nl">// RandomUser resource</span><span id="bf7e" class="mr lq in ne b gy np nj l nk nl">// for routes like /randomuser?results=3 (params optional)</span><span id="82c2" class="mr lq in ne b gy np nj l nk nl">app.get(“/randomuser”, async (req, res) =&gt; {</span><span id="1cd9" class="mr lq in ne b gy np nj l nk nl">// GraphQL query (only names &amp; pics)</span><span id="fc59" class="mr lq in ne b gy np nj l nk nl">const body = JSON.stringify({<br/>  query: `query MyQuery {<br/>    getRandomUser(results:${req.query.results || 1}){<br/>      name<br/>      picture<br/>    }<br/>  }`,<br/>});</span><span id="e6df" class="mr lq in ne b gy np nj l nk nl">// calling our deployed GraphQL API</span><span id="d2dd" class="mr lq in ne b gy np nj l nk nl">axios({<br/>  url: process.env.STEPZEN_GRAPHQL_API,<br/>  method: “post”,<br/>    headers: {<br/>      “Content-Type”: “application/json”,<br/>      “Content-length”: body.length,<br/>      Authorization: “Apikey “ + process.env.STEPZEN_API_KEY,<br/>      “User-Agent”: “Node”,<br/>    },<br/>  data: body,<br/>}).then((response) =&gt; {</span><span id="731c" class="mr lq in ne b gy np nj l nk nl">  res.send({<br/>    result: “success”,<br/>    users: response.data.data.getRandomUser,<br/>  });<br/>});</span><span id="758b" class="mr lq in ne b gy np nj l nk nl">});</span><span id="f7b4" class="mr lq in ne b gy np nj l nk nl">// no routes match</span><span id="7b9e" class="mr lq in ne b gy np nj l nk nl">app.use((req, res, next) =&gt; {<br/>  const error = new Error();<br/>  error.message = “Not found”;<br/>  error.status = 404;<br/>  next(error);<br/>});</span><span id="9cc8" class="mr lq in ne b gy np nj l nk nl">// json error handler</span><span id="44d4" class="mr lq in ne b gy np nj l nk nl">app.use(async (error, req, res, next) =&gt; {<br/>  res.status(404).send({<br/>    result: “failure”,<br/>    error: error,<br/>  });<br/>});</span><span id="37f3" class="mr lq in ne b gy np nj l nk nl">// create Express.js HTTP server</span><span id="cfc6" class="mr lq in ne b gy np nj l nk nl">app.listen(process.env.PORT || 3000);</span></pre><blockquote class="nq nr ns"><p id="d459" class="kt ku mm kv b kw kx jo ky kz la jr lb nt ld le lf nu lh li lj nv ll lm ln lo ig bi translated">请记住，标准的GraphQL API调用应该是HTTP POST请求，使用application/json内容类型，并包含json编码的主体(我们的查询)。</p></blockquote><p id="9540" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们都完成了！启动我们的服务器，然后我们可以用cURL、Postman或诸如此类的工具测试它，看看我们是否得到了我们想要的数据。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="c64f" class="mr lq in ne b gy ni nj l nk nl"><strong class="ne io">ExpressJS API response to a GET with query params ?results=3</strong><br/>--------------------------------------------------------------------</span><span id="9263" class="mr lq in ne b gy np nj l nk nl">{<br/>  “result”: “success”,<br/>  “users”: [<br/>  {<br/>    “name”: {<br/>    “first”: “Ivana”,<br/>    “last”: “Morin”,<br/>    “title”: “Madame”<br/>    },</span><span id="bc88" class="mr lq in ne b gy np nj l nk nl">“picture”: {<br/>  “large”: “https://randomuser.me/api/portraits/women/29.jpg",<br/>  “medium”: “https://randomuser.me/api/portraits/med/women/29.jpg",<br/>  “thumbnail”:<br/>    “https://randomuser.me/api/portraits/thumb/women/29.jpg"<br/>  }<br/>},</span><span id="3598" class="mr lq in ne b gy np nj l nk nl">{<br/>  “name”: {<br/>    “first”: “Mylan”,<br/>    “last”: “Olivier”,<br/>    “title”: “Mr”<br/>  },</span><span id="1106" class="mr lq in ne b gy np nj l nk nl">“picture”: {<br/>  “large”: “https://randomuser.me/api/portraits/men/25.jpg",<br/>  “medium”: “https://randomuser.me/api/portraits/med/men/25.jpg",<br/>  “thumbnail”: “https://randomuser.me/api/portraits/thumb/men/25.jpg"<br/>}</span><span id="623e" class="mr lq in ne b gy np nj l nk nl">},</span><span id="7bb7" class="mr lq in ne b gy np nj l nk nl">{<br/> “name”: {<br/>   “first”: “Josep”,<br/>   “last”: “Gutierrez”,<br/>   “title”: “Mr”<br/>  },</span><span id="3dfc" class="mr lq in ne b gy np nj l nk nl">“picture”: {<br/>  “large”: “https://randomuser.me/api/portraits/men/36.jpg",<br/>  “medium”: “https://randomuser.me/api/portraits/med/men/36.jpg",<br/>  “thumbnail”:   “https://randomuser.me/api/portraits/thumb/men/36.jpg"<br/>}</span><span id="042e" class="mr lq in ne b gy np nj l nk nl">}</span><span id="1b63" class="mr lq in ne b gy np nj l nk nl">]</span><span id="ebd2" class="mr lq in ne b gy np nj l nk nl">}</span></pre><p id="acb3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">完美。对于为前端设计生成快速和肮脏的模型，这将工作得很好。</p><h1 id="6a0c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">两全其美</h1><p id="c518" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">GraphQL非常强大和灵活，StepZen凭借其强大的CLI工具、丰富的特性、针对大量数据源的预制模式和丰富的文档，使得实现GraphQL变得非常容易，并且可以满足您的所有开发需求。</p><p id="f8ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">StepZen的GraphQL-as-a-service模型无疑是一个额外的抽象层，但由于StepZen从您(或您的组织的开发人员)的角度出发，负责开箱即用，所以您所做的只是定义数据的模式，描述您需要的API和DB调用，然后指导客户端应用程序开发人员简单地调用集中式StepZen GraphQL端点。</p><p id="f9a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">总而言之，StepZen让开发者——无论是前端还是后端— <em class="mm">和</em>用户的生活变得简单多了，因为他们可以更快地获得更多数据。</p><p id="dcd4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mm">原贴于</em><a class="ae ks" href="https://plainenglish.io/blog/how-to-migrate-rest-api-to-graphql-with-stepzen" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mm">plain English . io</em></strong></a><em class="mm">。</em></p></div></div>    
</body>
</html>