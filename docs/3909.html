<html>
<head>
<title>Use Master Theorem to Derive Big O of a Recursive Binary Search Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用主定理导出递归二分搜索法算法的大O</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-master-theorem-to-derive-big-o-of-a-recursive-binary-search-algorithm-7f32249f3f03?source=collection_archive---------6-----------------------#2022-10-07">https://javascript.plainenglish.io/use-master-theorem-to-derive-big-o-of-a-recursive-binary-search-algorithm-7f32249f3f03?source=collection_archive---------6-----------------------#2022-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c1ef" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript算法基础第7部分:理解主定理推导递归算法的时间复杂度</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3971e57e0fbb55e74f4eaaf8c5d3e855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8RCUnPfSxXLVxlL9eaRlw.png"/></div></div></figure><p id="6db3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们使用<strong class="kq io">渐近分析</strong>来确定算法的时间复杂度。然而，计算一些递归算法的时间复杂度有时是具有挑战性的。</p><p id="a386" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">大多数时候，这在具有<strong class="kq io">对数时间复杂度</strong>的递归算法中可以观察到。有利的是，我们可以使用被称为“<strong class="kq io">主定理</strong>”的数学定理来容易地确定这些算法的运行时间。</p><h2 id="2caf" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">什么是主定理？</h2><p id="edd1" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">主定理是一个数学公式，可以很容易地推导出递归算法的时间复杂度。该定理只适用于那些递归算法，在这些算法中，我们将问题(n)分成更小的块。</p><p id="1d17" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个公式不适用于其他递归方法，在这些方法中，我们只用(n-1)步调用递归函数，例如在阶乘的情况下。</p><p id="2003" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是如果我们正在处理一个算法，它把自己分成两半或者三分之一，或者类似的东西，那么这个公式仍然有效。</p><h2 id="d2fd" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">公式是什么？</strong></h2><p id="bbf4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">为了计算递归的运行时间，我们使用下面的主定理公式。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="d13f" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">O(n^logb a)</strong></span></pre><p id="d4a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在哪里，</p><p id="ef24" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> a </strong> =子问题的数量(递归分裂的数量)。函数多久调用一次自己？</p><p id="d37f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> b </strong> =从属子问题大小(每次分割的输入减量)。我们如何分割数组？无论我们在每次递归调用时是将其减半还是除以3。</p><p id="0de3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> f(n) </strong> =我们稍后也会看到这是递归之外的运行时(非递归部分)，尽管不是公式的一部分。但是我们需要它来导出函数的总运行时间。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/e8796dec62e011317820a7ca0a7c61d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXx93aC88TkUP7DKAyPxZQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Master Theorem</figcaption></figure><p id="f2ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据主理论，为了推导算法的总时间复杂度，我们必须区分三种情况。</p><h2 id="84ef" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">第一个案例</h2><p id="0bd9" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">第一种情况是<strong class="kq io">递归函数和非递归函数做同样多的工作</strong>。如果是这种情况，那么我们使用下面的公式。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="146c" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">O(n^logb a * log n)</strong></span></pre><h2 id="f4c8" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">第二种情况</strong></h2><p id="c9d9" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">第二种情况是当<strong class="kq io">递归步骤完成大部分工作</strong>时，即它有最大的运行时间。在这种情况下，整体算法运行时间由以下公式得出。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="364b" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">O(n^logb a)</strong></span></pre><h2 id="de56" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">第三个案例</strong></h2><p id="ec75" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">而且，如果我们让<strong class="kq io">非递归部分做了最多的工作</strong>，这种情况很少发生，那么我们使用下面的公式。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="2333" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">O(fn(n))</strong></span></pre><p id="153e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第三种情况下，我们忽略递归的运行时，只关注外部运行时，因为递归步骤几乎不做任何工作。</p><p id="8475" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们通过推导递归二分搜索法算法的运行时来理解这个例子。</p><h2 id="974e" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">导出递归二分搜索法的大O</strong></h2><p id="6858" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">下面的代码是二分搜索法算法的递归版本。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="c133" class="lk ll in mj b gy mn mo l mp mq">function searchElement(arr, searchElement, offset) {<br/> let startPosition = 0;<br/> let endPosition = arr.length - 1;<br/> <br/> let midPosition = Math.floor((endPosition - startPosition) / 2);</span><span id="06ea" class="lk ll in mj b gy mw mo l mp mq"> if (searchElement === arr[midPosition]) {<br/>   return midPosition + offset;<br/> }<br/>  <br/> if (searchElement &lt; arr[midPosition]) {<br/>   endPosition = midPosition - 1;<br/> } else {<br/>   startPosition = midPosition + 1;<br/>   offset = offset + midPosition + 1<br/> }<br/> <br/> return searchElement(arr.slice(startPosition, endPosition + 1), element, offset);<br/>}</span></pre><p id="889f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">第一步</strong></p><p id="2a0e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将首先使用主定理公式开始递归步骤的计算，即<strong class="kq io"> O(n^logb a) </strong>。</p><p id="d4cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面递归步骤的大O是什么？</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="6141" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">return searchElement(arr.slice(startPosition, endPosition + 1), element, offset);</strong></span></pre><p id="ef31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了找出“<strong class="kq io"> a </strong>”(子问题的数量)，我们看看函数调用自己的频率。在我们上面的例子中，只有一次。</p><p id="8f29" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，<strong class="kq io"> a </strong>准<strong class="kq io"> 1 </strong>。因此，我们有，</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="8a6a" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">a = 1</strong></span></pre><p id="c161" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，<strong class="kq io"> b </strong>是子问题的大小，也就是说，我们是分成一半还是三分之一？在我们的例子中，我们把它分成两半。因此，<strong class="kq io"> b </strong>就是<strong class="kq io"> 2 </strong>。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="555f" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">b = 2</strong></span></pre><p id="ac32" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，替换公式中的上述值。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="17c7" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">O(n^logb a) = O(n^log2 1)<br/>            = O(n^0)      </strong>// log2 (1) is 0<strong class="mj io"><br/>            = O(1)</strong></span></pre><p id="8fba" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">所以我们单独为递归步骤得到一个常数运行时间O(1)。</strong></p><p id="f3dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但这不是整体算法运行时。<strong class="kq io">为了得出总的运行时间，我们需要使用三种情况中的一种公式</strong>。</p><p id="f864" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要找出这个递归步骤比函数的其余部分做更多的工作，更少的工作，还是等量的工作。如果我们看看函数的其余部分，不包括递归步骤，那么我们可以很容易地说，它也有一个恒定的时间复杂度O(1)，因为我们在函数中没有任何循环或任何嵌套调用。</p><p id="3971" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，递归步骤的时间复杂度与递归步骤之外的工作相同。所以<strong class="kq io">我们可以用</strong> <strong class="kq io">第一种情况公式推导出整体算法</strong>的时间复杂度。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="6738" class="lk ll in mj b gy mn mo l mp mq"><strong class="mj io">O(n^logb a * log n) = O(1 * log n)<br/>                    = O(log n)</strong></span></pre><p id="5e91" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">替换上述第一种情况公式中的<strong class="kq io">递归步长时间复杂度</strong>即<strong class="kq io">O(1)</strong><strong class="kq io">得到对数时间复杂度</strong>。</p><p id="af63" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mx">这就是我们如何使用</em> <strong class="kq io"> <em class="mx">主定理</em> </strong> <em class="mx">数学推导出递归算法的时间复杂度。但是，同样重要的是要记住，这个定理并不是在所有情况下都适用，比如阶乘递归函数。</em></p><h2 id="ca30" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">专业提示</h2><p id="1773" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">如果您想避免使用上面的公式，而只是通过查看代码来获得运行时，那么这个技巧在大多数情况下都会对您有所帮助。</p><p id="fd75" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您看到子问题的大小，即<strong class="kq io">每次分割的输入减少一半、三分之一或四分之一，并且不是线性(n-1)步</strong>，那么您可以得出结论，该函数将主要具有对数时间复杂度<strong class="kq io"> O(log n) </strong>。</p><p id="45fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢您的阅读。</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="6235" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mx">更多内容请看</em><a class="ae nf" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mx">plain English . io</em></strong></a><em class="mx">。报名参加我们的</em> <a class="ae nf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mx">免费周报</em> </strong> </a> <em class="mx">。关注我们关于</em><a class="ae nf" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mx">Twitter</em></strong></a><a class="ae nf" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mx">LinkedIn</em></strong></a><em class="mx"/><a class="ae nf" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mx">YouTube</em></strong></a><em class="mx"/><a class="ae nf" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mx">不和</em> </strong> </a> <em class="mx">。对增长黑客感兴趣？检查</em> <a class="ae nf" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mx">电路</em> </strong> </a> <em class="mx">。</em></p></div></div>    
</body>
</html>