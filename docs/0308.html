<html>
<head>
<title>Higher-Order Functions that Simplify Pure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化纯函数的高阶函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/higher-order-functions-that-simplify-pure-functions-bb4ae1817092?source=collection_archive---------15-----------------------#2022-01-18">https://javascript.plainenglish.io/higher-order-functions-that-simplify-pure-functions-bb4ae1817092?source=collection_archive---------15-----------------------#2022-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6e4be8ed01074e3831f4f904752479c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJe7gxydFANFgUw0wIt7Ew.jpeg"/></div></div></figure><p id="7a30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我描述了一种强调声明式风格的纯函数实现模式。</p><p id="4d48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它基于放在基本原型中的两个新的高阶函数，以便它们可用于所有对象和函数(使用点符号)。</p><h1 id="c5b3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">高阶函数</h1><p id="2316" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在下文中，我将使用高阶函数的首字母缩写词HOF:在其输入参数中有一个或多个函数和/或作为其调用的结果产生一个新函数的函数。</p><h1 id="6132" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">纯功能实现</h1><p id="776f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">纯函数本质上是一系列基本变换，从输入参数开始，经过一系列中间结果，产生最终结果。</p><h2 id="8de6" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">程序实施</h2><p id="9960" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在一般情况下，转换需要由序列中在它们之前的转换生成的中间结果的子集作为输入(除了函数的输入参数的可能子集)。</p><p id="0b83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，该函数被分成一组将结果存储在局部变量中的过程步骤。</p><h2 id="c0f8" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">用函数链实现</h2><p id="b498" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在大多数情况下，可以简化上述方案，将函数实现为单个转换管道，其中一个转换管道的输出是下一个转换管道的输入。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/d3bd5a4caa85f18bb03352524bde9b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LPz84CwKBYr0O3tUwnbtA.png"/></div></div></figure><p id="3beb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果转换是内联定义的<em class="mn"/>，那么pure函数的输入参数在转换闭包内是可用的。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/c9692fa397a1bb6ec9043b5c8c4c47ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*7BHoUpqqiz7TK68hIlTbfQ.png"/></div></figure><p id="ea8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了最大化该模式的适用性，如果需要，转换可以将先前的结果传播到下游，在结果中插入输入(在这种情况下，结果是一个元组或一个映射)。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/230974ed58e167e3271625629da81d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*wESxypxlp0ua_i4qfrD0lw.png"/></div></figure><h1 id="1663" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一管函数(变换)</h1><p id="5cf0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对于JavaScript，有两种不同的方法来连接函数:</p><ul class=""><li id="5c97" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">点符号，通过使用预定义的方法，允许产生新字符串或新数组的转换的连接(但我们也将看到对象的解决方案)。</li><li id="cb6c" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">一种HOF，它将函数作为输入，并将中间结果和函数调用结合起来。这种HOF通常被称为<em class="mn">管。</em></li></ul><p id="9406" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两种技术可以混合在一起，以获得最佳的实现。</p><p id="e2f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将开始描述第二种选择。</p><h2 id="8e78" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">后缀组合(管道功能)</h2><p id="d133" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">可以使用函数组合的数学概念创建一个函数链:<code class="fe ne nf ng nh b">f( g( h(o) ) )</code>。这可以直接解释为JavaScript代码，但是这种方法有三个主要问题:</p><p id="264c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">大量嵌套层次。嵌套层次很难阅读。</strong> <em class="mn"> </em> <br/>一个简单的解决方案是定义一个HOF，它返回组合函数，然后将其应用于起始对象:<br/> <code class="fe ne nf ng nh b">compose(f,g,h)(o)</code></p><p id="a7bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作曲HOF的定义很简单:<br/> <code class="fe ne nf ng nh b">compose = (...fs) =&gt; o =&gt; fs.reduceRight((a, f) =&gt; f(a), o)</code></p><p id="f12c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">应用于输入对象(h)的第一个变换是<em class="mn">合成</em>参数列表中的最后一个。</strong></p><p id="0676" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在数学中，你也有类似的问题。可以避免采用所谓的反向波兰记法(或后缀记法):操作数列在运算符之前。如<code class="fe ne nf ng nh b">5 + 3</code>写成<code class="fe ne nf ng nh b">5 3 +</code>。同样，<code class="fe ne nf ng nh b">f( g( h(o) ) )</code>可以写成<code class="fe ne nf ng nh b">o h g f</code>(在后缀符号中不使用括号)。</p><p id="e408" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript中，我们定义了HOF <em class="mn">管道</em>，和RPN一样，它颠倒了操作符的顺序:<br/> <code class="fe ne nf ng nh b">pipe = (...fs) =&gt; o =&gt; fs.reduce((a, f) =&gt; f(a), o)</code></p><p id="59eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以写:<code class="fe ne nf ng nh b"><em class="mn">pipe(h,g,f)(o)</em></code></p><p id="5359" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">o的操作数<em class="mn">在函数管的错误一侧。</em></strong></p><p id="c346" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">参数<em class="mn"> o </em>应位于变换序列<code class="fe ne nf ng nh b"><em class="mn">pipe(h,g,f)(</em><strong class="jx io"><em class="mn">o</em></strong><em class="mn">) // wrong side</em></code> <em class="mn">的左侧。</em></p><p id="eb97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个问题将在我们讨论了点符号的用法之后解决。</p><p id="77ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上所述，<em class="mn">管道</em>函数本质上是函数组合的后缀符号，所以我更喜欢把它命名为<em class="mn">后缀组合</em>。</p><h2 id="2e39" class="lw ku in bd kv lx ly dn kz lz ma dp ld kg mb mc lh kk md me ll ko mf mg lp mh bi translated">调用纯函数的点符号</h2><p id="6487" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">点符号用于调用类<strong class="jx io">方法</strong>，这里我们想要构建纯函数(没有突变)。</p><p id="9c00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们只使用不改变对象的方法，我们仍然可以实现纯函数。在这种情况下，点符号可以解释为调用以对象作为第一个参数的函数的语法糖。</p><p id="ccd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照这种思路，使用点符号调用任何以对象作为第一个参数的函数将会很有趣。</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="96e8" class="lw ku in nh b gy nm nn l no np">f = (o, arg1, arg2, ...)    </span><span id="4d09" class="lw ku in nh b gy nq nn l no np"><strong class="nh io">o.f(arg1, arg2)   // not possible</strong></span></pre><p id="67aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，通过将函数定义为一个类的方法，将对象定义为该类的实例，这已经是可能的了…</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="f433" class="lw ku in nh b gy nm nn l no np">class MyObj { f(arg1, arg2)  { console.log(arg1, arg2) }}<br/>o = new MyObj()<br/>o.f('arg1', 'arg2')</span></pre><p id="bed9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但关键是能够做到这一点，而不陷入面向对象编程的沼泽(我知道，我对OOP不领情，但这符合本文的精神)。</p><p id="805c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不幸的是，这是不可能的…但类似的东西可以实现。</p><h1 id="10dd" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">调用HOF</h1><p id="1ac0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了模拟函数的点调用，可以使用点符号定义类似于<em class="mn">管道</em>函数的东西，并使其可从任何类型的对象调用:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="b034" class="lw ku in nh b gy nm nn l no np">Object.defineProperty(<br/>  Object.prototype,<br/>  'invoke’,<br/>  {<br/>    value:i<br/>      function<!-- -->(...fs) {<br/>        return fs.reduce((a, f) =&gt; f(a), this)<br/>      },<br/>    enumerable: false<br/>  }<br/>)</span></pre><p id="a966" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，即使不可能写出<code class="fe ne nf ng nh b">o.h.g.f</code>，至少也可以这样写:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="e122" class="lw ku in nh b gy nm nn l no np">o.invoke(h).invoke(g).invoke(f)    <br/>   // or<br/>o.invoke(h,g,f)</span></pre><p id="909b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，参数o位于函数管的正确一侧:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="2f06" class="lw ku in nh b gy nm nn l no np">pipe(h,g,f)(<strong class="nh io">o</strong>)  </span><span id="5055" class="lw ku in nh b gy nq nn l no np"><strong class="nh io">o</strong>.invoke(h,g,f)     </span></pre><h1 id="c98e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">矩形的周长和面积(管道示例)</h1><p id="0df4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了说明上面表达的概念，让我们考虑一个将正交(垂直或水平)矩形转换为包含矩形面积和周长的字符串的函数。</p><p id="da75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终结果不是很有用，但是让我们把重点放在函数的实现上。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/d359d1c4c9411bc9db08581e3eb37cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osMYM7SN7UnEdkaJqiftig.png"/></div></div></figure><p id="eba6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">垂直/水平矩形可以由两个点来表示:两个相对的顶点。一个点可以用一个数字向量来表示:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="d4b6" class="lw ku in nh b gy nm nn l no np">rect = {a: [2, 6], b: [5, 2]}</span></pre><p id="1fad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个转换检索边:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="345f" class="lw ku in nh b gy nm nn l no np">const sides =<br/>  r =&gt; [Math.abs(r.a[0] - r.b[0]), Math.abs(r.a[1] - r.b[1])]</span></pre><p id="0c16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个转换将周长和面积添加到结果元组中:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="3dfb" class="lw ku in nh b gy nm nn l no np">const  addPerimeterAndArea =<br/>  sides =&gt; [...sides, 2*(sides[0]+sides[1]), sides[0]*sides[1]]</span></pre><p id="3885" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第三个转换创建输出字符串:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="aeb2" class="lw ku in nh b gy nm nn l no np">const rectPropsToString =<br/>  rectProps =&gt; `<br/>    sides: ${rectProps[0]}, ${rectProps[1]}<br/>    perimeter: ${rectProps[2]}<br/>    area: ${rectProps[3]}<br/>  `</span></pre><p id="031e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们准备将函数定义为一个单一的转换管道:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="2d41" class="lw ku in nh b gy nm nn l no np">const rectToString = <br/>  rect =&gt; rect.invoke(sides, addPerimeterArea, rectPropsToString)</span><span id="7dcd" class="lw ku in nh b gy nq nn l no np">console.log(rectToString({a: [2, 6], b: [5, 2]}))</span><span id="2687" class="lw ku in nh b gy nq nn l no np"><strong class="nh io">      sides: 3, 4<br/>      perimeter: 14<br/>      area: 12</strong></span></pre><h1 id="fe11" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">中值(点符号示例)</h1><p id="4e11" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">给定一个数值向量，中值是排序向量的中心值(当向量长度为偶数时，两个中心值的平均值)。</p><p id="0357" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该函数可以作为一个管道来实现，而不需要调用函数，但是中心值的提取有点复杂，所以最好为它使用一个有感召力的名称。</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="6db9" class="lw ku in nh b gy nm nn l no np">const extractCentralValues =<br/>  v =&gt; v.slice(div2(v.length&gt;&gt;1 - 1, v.length&gt;&gt;2 + !v.length%2)</span></pre><p id="199c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<em class="mn">二进制</em>中，整数被2除就像在<em class="mn">以10为基数</em>中被10除一样:跳过最后一个数字。在二进制中，这可以简单地通过<em class="mn">符号传播右移</em>运算符(&gt; &gt;)来实现。</p><p id="37f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个实现变体，使用有感召力的名称，并且只执行一次除以2，在代码片段中使用了更高阶的IIFE(立即调用的函数表达式)，以粗体显示。</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="2215" class="lw ku in nh b gy nm nn l no np">const extractCentralValues =<br/>  <strong class="nh io">((middleIndex, evenLength) =&gt; </strong><br/>    v =&gt; v.slice(middleIndex, middleIndex + 1 + evenLength)<br/>  <strong class="nh io">)(v.length&gt;&gt;1 - 1, !v.length%2)</strong></span></pre><p id="48ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以将<em class="mn"> middeIndex </em>和<em class="mn"> evenLength </em>定义为函数，并且为了执行一次除法(除以2 ),可以使用<em class="mn">middeIndex</em>的内存化版本(具有单值缓存),但是在这些情况下，我更喜欢IIFEs。</p><p id="29d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mn">中值</em>功能<em class="mn">T15】现在可以定义为一个管:</em></p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="433e" class="lw ku in nh b gy nm nn l no np">const median = v =&gt; <br/>  v.sort()<br/>   .invoke(extractCentralValues)<br/>   .reduce((a, e) =&gt; a+e/2, 0)</span></pre><p id="ba99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，reduce可以被一个有着动人名字的函数代替:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="579d" class="lw ku in nh b gy nm nn l no np">const meanValue = v =&gt;<br/>  v.reduce((a,e) =&gt; a + e)/v.length</span></pre><p id="4741" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我们有两种选择来列出转换(我更喜欢第一种):</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="83fe" class="lw ku in nh b gy nm nn l no np">const median = v =&gt; <br/>  v.sort()<br/>   .invoke(extractCentralValues)<br/>   .invoke(meanValue)</span><span id="765b" class="lw ku in nh b gy nq nn l no np"><em class="mn">or</em></span><span id="ef40" class="lw ku in nh b gy nq nn l no np">const median = v =&gt; <br/>  v.sort()<br/>   .invoke(<br/>      extractCentralValues,<br/>      meanValue<br/>   )</span></pre><h1 id="81f2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">绑定额外参数(bindArgs HOF)</h1><p id="6901" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果一个转换需要main函数的附加输入参数，那么这个转换应该被内联定义，这样它们在闭包中是可用的。但是这种解决方案排除了使用可唤起的名字的可能性。</p><p id="e8dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">幸运的是，有一个选择:我们可以部分地应用转换。</p><p id="a314" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mn">部分应用</em>将函数的一些参数绑定到固定值，并返回一个采用更少输入参数的新函数。在我们的例子中，只有第一个参数是自由的:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="76b4" class="lw ku in nh b gy nm nn l no np">Object.defineProperty(<br/>  Function.prototype,<br/>  'bindArgs',<br/>  {<br/>    value:<br/>      function<!-- -->(...args) {<br/>        return <strong class="nh io">o =&gt; this(o, ...args)</strong><br/>      },<br/>    enumerable: false<br/>  }<br/>)</span></pre><p id="6a53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面代码中新应用的部分函数以粗体显示。注意args值是如何冻结到闭包中的。</p><h1 id="5910" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">点的旋转(绑定示例)</h1><p id="6f25" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">(笛卡尔)点旋转一个角度<em class="mn">α</em>(以弧度为单位)可以通过将该点变换到极坐标中，将该角度加到极角上，然后反向变换到笛卡尔坐标中来获得。</p><p id="3446" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，旋转一个点最有效的方法是通过使用<em class="mn">旋转矩阵</em> …但这只是一个演示绑定函数用法的例子。</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="23f1" class="lw ku in nh b gy nm nn l no np">const toPolar = <br/>  p =&gt; [Math.sqrt(p[0]*p[0]+p[1]*p[1]), Math.atan2(p[1],p[0])]</span><span id="26d9" class="lw ku in nh b gy nq nn l no np">const polarRotation = (p, angle) =&gt; [p[0], p[1] + angle]</span><span id="37cf" class="lw ku in nh b gy nq nn l no np">const toCartesian = p =&gt; [p[0]*Math.cos(p[1]), p[0]*Math.sin(p[1])]</span></pre><p id="4537" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">polarRotation函数有两个参数…在函数管中使用该函数之前，必须绑定第二个参数。</p><p id="ac3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">旋转功能是:</p><pre class="mj mk ml mm gt ni nh nj nk aw nl bi"><span id="0714" class="lw ku in nh b gy nm nn l no np">const rotate = (p, angle) =&gt;<br/>  p.invoke(<br/>    toPolar,<br/>    polarRotation.bindArgs(angle),<br/>    toCartesian<br/>  )</span></pre><h1 id="b522" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">概述</h1><p id="c1c5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在提出了一个实现纯函数的模型(管道模型)之后，我定义了两个Hof(<em class="mn">invoke</em>和<em class="mn"> bindArgs </em>)，这两个Hof允许这个模型应用于大多数函数的实现。三个简单的例子阐明了如何使用它。</p><p id="4ea4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mn">更多内容看</em> <a class="ae ns" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mn">说白了。报名参加我们的</em> <a class="ae ns" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mn">免费周报</em> </strong> </a> <em class="mn">。在我们的</em> <a class="ae ns" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mn">社区不和谐</em> </strong> </a> <em class="mn">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>