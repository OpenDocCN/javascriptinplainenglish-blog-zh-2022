<html>
<head>
<title>How to Implement Concurrency Control in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中实现并发控制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-concurrency-control-in-javascript-df4da29f81c4?source=collection_archive---------4-----------------------#2022-07-28">https://javascript.plainenglish.io/how-to-implement-concurrency-control-in-javascript-df4da29f81c4?source=collection_archive---------4-----------------------#2022-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c147" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以有限的并发性运行多个承诺返回&amp;异步函数。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4d090a9f3e4090cb09e52a9d37220adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5YBR17zS1eyzn5-6I_cpg.jpeg"/></div></div></figure><h1 id="a608" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">什么是并发控制？</h1><p id="dded" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在日常开发中，可能会遇到并发控制的场景，比如控制并发请求的数量。那么如何在JavaScript中实现并发控制呢？在回答这个问题之前，我们先简单介绍一下并发控制。</p><p id="3832" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">假设有6个待办任务要执行，我们想限制同时执行的任务数量，即只能同时执行2个任务。当执行任务列表中的任一任务完成后，程序会自动从待办任务列表中获取一个新的待办任务，并将该任务添加到执行任务列表中。</p><p id="aa83" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">具体执行过程如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/94a0ffe8f7fcad1adf03a6cc08a6827d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*08Z733X7Oc4iT5NJxn5XuA.gif"/></div></div></figure><p id="f139" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">接下来，我们将以Github上的<a class="ae ml" href="https://github.com/rxaviers/async-pool" rel="noopener ugc nofollow" target="_blank"> tiny-async-pool </a>库为例，分析异步任务并发控制的具体实现。</p><h1 id="323f" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">如何实现并发控制？</h1><p id="d026" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae ml" href="https://github.com/rxaviers/async-pool" rel="noopener ugc nofollow" target="_blank">微型异步池</a>库提供了3个不同版本的ES7、ES6和ES9的实现。在分析它的具体实现之前，我们先来看看它是如何使用的。</p><h2 id="b362" class="mm ks iq bd kt mn mo dn kx mp mq dp lb ls mr ms ld lw mt mu lf ma mv mw lh mx bi translated">1.如何使用异步池</h2><p id="4f2f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">首先，通过npm安装异步池</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="af56" class="mm ks iq mz b gy nd ne l nf ng">$ npm install tiny-async-pool</span></pre><p id="cc82" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">然后从<strong class="ll ir">微型异步池</strong>模块导入异步池函数</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f575" class="mm ks iq mz b gy nd ne l nf ng">import asyncPool from "tiny-async-pool";</span></pre><p id="e936" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">asyncPool函数的签名如下所示:</p><p id="5615" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe nh ni nj mz b">asyncPool(concurrency, iterable, iteratorFn)</code></p><ul class=""><li id="cb5c" class="nk nl iq ll b lm mf lp mg ls nm lw nn ma no me np nq nr ns bi translated">并发性:并发限制数(&gt; = 1)</li><li id="f61c" class="nk nl iq ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">iterable:输入的可迭代对象，如String、Array、TypedArray、Map和Set。</li><li id="914a" class="nk nl iq ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">iteratorFn:接受两个参数的迭代器函数:每次迭代的值和iterable对象本身。迭代器函数应该返回一个承诺或者是一个异步函数。</li></ul><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b9a9" class="mm ks iq mz b gy nd ne l nf ng">import asyncPool from "tiny-async-pool";</span><span id="54cf" class="mm ks iq mz b gy ny ne l nf ng">const timeout = i =&gt; new Promise(<br/>  resolve =&gt; setTimeout(() =&gt; resolve(i), i)<br/>);</span><span id="fef4" class="mm ks iq mz b gy ny ne l nf ng">await asyncPool(2, [1000, 5000, 3000, 2000], timeout);</span></pre><p id="e6e6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们来看看上面例子的执行过程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/e53f91ccc25238787466421b705f3b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bkuHJxvYvrNbs-Y3SCdmwg.gif"/></div></div></figure><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f3e4" class="mm ks iq mz b gy nd ne l nf ng"><em class="nz">// Call iterator (i = 1000)</em><br/><em class="nz">// Call iterator (i = 5000)</em><br/><em class="nz">// Pool limit of 2 reached, wait for the quicker one to complete...</em><br/><em class="nz">// 1000 finishes</em><br/><em class="nz">// Call iterator (i = 3000)</em><br/><em class="nz">// Pool limit of 2 reached, wait for the quicker one to complete...</em><br/><em class="nz">// 3000 finishes</em><br/><em class="nz">// Call iterator (i = 2000)</em><br/><em class="nz">// Itaration is complete, wait until running ones complete...</em><br/><em class="nz">// 5000 finishes</em><br/><em class="nz">// 2000 finishes</em><br/><em class="nz">// Resolves, results are passed in given array order `[1000, 5000, 3000, 2000]`.</em></span></pre><p id="4d72" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">看了上面的评论，你应该对asyncPool函数实现的功能有个大概的了解了。接下来，让我们分析asyncPool函数的ES7实现。</p><h2 id="bac4" class="mm ks iq bd kt mn mo dn kx mp mq dp lb ls mr ms ld lw mt mu lf ma mv mw lh mx bi translated">2.如何使用ES7特性实现asyncPool？</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">async-pool-es7.js</figcaption></figure><p id="0d38" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在上面的代码中，充分利用了<code class="fe nh ni nj mz b"><a class="ae ml" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all</a></code>和<code class="fe nh ni nj mz b"><a class="ae ml" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" rel="noopener ugc nofollow" target="_blank">Promise.race</a></code>的功能特性，结合ES7中提供的<strong class="ll ir"> async await </strong>特性，最终实现了并发控制的功能。使用await <code class="fe nh ni nj mz b">Promise.race(executing);</code>语句，我们将等待执行任务列表中更快的任务完成，然后再继续下一个循环。</p><p id="58a7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">asyncPool ES7的实现相对简单。接下来，让我们看看如何在不使用异步await特性的情况下实现相同的功能。</p><h2 id="7a57" class="mm ks iq bd kt mn mo dn kx mp mq dp lb ls mr ms ld lw mt mu lf ma mv mw lh mx bi translated">3.如何使用E6特性实现asyncPool？</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">async-pool-es6.js</figcaption></figure><p id="e6ab" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在ES6实现版本中，核心控制逻辑是通过内部封装的<code class="fe nh ni nj mz b">enqueue</code>函数实现的。当<code class="fe nh ni nj mz b">Promise.race(executing);</code>返回的Promise对象完成时，将调用<code class="fe nh ni nj mz b">enqueue</code>函数从数组中获取一个新的待办任务。</p><h1 id="8266" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">如何实现简单的Promise.all和Promise.race函数</h1><p id="a0d7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在asyncPool函数ES7和ES6的具体实现中，我们使用了<code class="fe nh ni nj mz b">Promise.all</code>和<code class="fe nh ni nj mz b">Promise.race</code>函数。它们在异步流控制场景中都非常有用，所以让我们实现更简单的<code class="fe nh ni nj mz b">Promise.all</code>和<code class="fe nh ni nj mz b">Promise.race</code>函数。</p><h2 id="00f6" class="mm ks iq bd kt mn mo dn kx mp mq dp lb ls mr ms ld lw mt mu lf ma mv mw lh mx bi translated">1.承诺。所有</h2><p id="59f4" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">调用<code class="fe nh ni nj mz b">Promise.all(iterable)</code>方法后会返回一个promise对象。当所有输入promise对象的状态变为resolved时，返回的promise对象将以数组的形式返回每个promise对象的解析结果。当任何输入承诺对象的状态变为拒绝时，返回的承诺对象将拒绝相应的错误消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">promise.all.js</figcaption></figure><p id="851b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">需要注意的是，对于<code class="fe nh ni nj mz b">Promise.all</code>的标准实现，其参数是一个可迭代的对象，如数组、字符串或集合等。</p><h2 id="6628" class="mm ks iq bd kt mn mo dn kx mp mq dp lb ls mr ms ld lw mt mu lf ma mv mw lh mx bi translated">2.承诺.种族</h2><p id="b8ec" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">调用<code class="fe nh ni nj mz b">Promise.race(iterable)</code>方法后会返回一个promise对象。一旦迭代器中的promise对象被解析或拒绝，返回的promise对象将解析或拒绝相应的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">promise.race.js</figcaption></figure><p id="a7b8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">本文为您分析tiny-async-pool异步任务并发控制的具体实现，同时，为了让您更好地理解tiny-async-pool的核心代码。最后，我们还实现了一个简单版本的<code class="fe nh ni nj mz b">Promise.all</code>和<code class="fe nh ni nj mz b">Promise.race</code>函数。其实除了<code class="fe nh ni nj mz b">Promise.all</code>功能，还有一个功能——<code class="fe nh ni nj mz b"><a class="ae ml" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" rel="noopener ugc nofollow" target="_blank">Promise.allSettled</a></code>，用来解决<code class="fe nh ni nj mz b">Promise.all</code>的问题。</p><h1 id="ba61" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">资源</strong></h1><div class="og oh gp gr oi oj"><a href="https://github.com/rxaviers/async-pool" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">GitHub - rxaviers/async-pool:用有限的资源运行多个承诺返回和异步函数…</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">这个库的目标是使用本地异步迭代器(ES9)，本地异步函数和本地承诺来实现…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox kp oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">Promise.all() - JavaScript | MDN</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">Promise.all()方法接受一个可迭代的承诺作为输入，并返回一个解析为…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">developer.mozilla.org</p></div></div><div class="os l"><div class="oy l ou ov ow os ox kp oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">Promise.race() - JavaScript | MDN</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">race函数返回一个承诺，该承诺以与第一个承诺相同的方式结算(并采用相同的值),即…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">developer.mozilla.org</p></div></div><div class="os l"><div class="oz l ou ov ow os ox kp oj"/></div></div></a></div></div><div class="ab cl pa pb hu pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="ij ik il im in"><p id="9ee7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><em class="nz">更多内容看</em> <a class="ae ml" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="nz">说白了。报名参加我们的</em> <a class="ae ml" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="nz">免费周报</em> </strong> </a> <em class="nz">。关注我们关于</em> <a class="ae ml" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="nz">推特</em></strong></a><strong class="ll ir"><em class="nz"/></strong><em class="nz">和</em><a class="ae ml" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="nz">LinkedIn</em></strong></a><em class="nz">。查看我们的</em> <a class="ae ml" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="nz">社区不和谐</em> </strong> </a> <em class="nz">加入我们的</em> <a class="ae ml" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="nz">人才集体</em> </strong> </a> <em class="nz">。</em></strong></a></p></div></div>    
</body>
</html>