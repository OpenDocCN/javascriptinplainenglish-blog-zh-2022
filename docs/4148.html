<html>
<head>
<title>Angular Custom Directive Example — HostBinding &amp; HostListener</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度自定义指令示例—主机绑定和主机侦听器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-custom-directive-example-hostbinding-hostlistener-1b18bb08a5d1?source=collection_archive---------5-----------------------#2022-10-31">https://javascript.plainenglish.io/angular-custom-directive-example-hostbinding-hostlistener-1b18bb08a5d1?source=collection_archive---------5-----------------------#2022-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="c3c1" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">棱角分明</a></h2><div class=""/><div class=""><h2 id="f03b" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">指令赋予HTML元素超能力。使用HostBinding &amp; HostListener创建自定义指令</h2></div><p id="b864" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">指令是向Angular应用程序中的元素添加额外行为的类。(<a class="ae lh" href="https://angular.io/guide/built-in-directives" rel="noopener ugc nofollow" target="_blank"> Angular.io </a>)</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/766337f5704479e9001c8bd9cd065858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sICJ2g29uLCb8w47tkDzg.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Angular Custom Directive</figcaption></figure><p id="3abb" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">Angular提供了几个内置的指令，您肯定使用了@Component来创建角度组件。</p><p id="2e3d" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">简而言之，Angular有3种类型的指令:</p><ol class=""><li id="10cc" class="ly lz in kn b ko kp kr ks ku ma ky mb lc mc lg md me mf mg bi translated"><strong class="kn ix">组件</strong></li><li id="dc11" class="ly lz in kn b ko mh kr mi ku mj ky mk lc ml lg md me mf mg bi translated"><strong class="kn ix">属性指令</strong> —改变元素、组件或其他指令的样式或行为。你可能知道NgClass，NgStyle，NgModel。</li><li id="6f20" class="ly lz in kn b ko mh kr mi ku mj ky mk lc ml lg md me mf mg bi translated"><strong class="kn ix">结构化指令</strong> —通过添加和删除DOM元素来操作DOM布局。你可能知道*ngIf，*ngFor，*ngSwitch。</li></ol><p id="c02e" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">只有结构指令才会加上星号(*)。</p><p id="c056" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">结构化指令将元素包装在一个<code class="fe mm mn mo mp b">ng-template</code>元素中，从<a class="ae lh" href="https://medium.com/p/c95531731367" rel="noopener">文档对象模型(DOM) </a>中添加和删除其内容。</p><p id="1943" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">在某些情况下，您可能希望创建自定义指令。</p><h1 id="fa63" class="mq mr in bd ms mt mu mv mw mx my mz na kc nb kd nc kf nd kg ne ki nf kj ng nh bi translated">从指令到自定义指令</h1><p id="e57a" class="pw-post-body-paragraph kl km in kn b ko ni jx kq kr nj ka kt ku nk kw kx ky nl la lb lc nm le lf lg ig bi translated">因为Angular将指令定义为类，所以您可以将指令视为没有接口的组件。</p><p id="88ab" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">指令与HTML元素一起使用来添加额外的行为。</p><pre class="lj lk ll lm gt nn mp no np aw nq bi"><span id="e8ae" class="nr mr in mp b gy ns nt l nu nv">&lt;div *ngIf="isLoaded"&gt; ... &lt;/div&gt;</span></pre><p id="a7d5" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">在上面的例子中，当变量<em class="nw">被加载</em>为真时，显示一些内容。</p><p id="29e0" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">对我们来说重要的是注意到<code class="fe mm mn mo mp b">ngIf</code>指令使用了数据绑定！</p><p id="2673" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">因此，自定义指令也可以从使用数据绑定和事件侦听器中受益。</p><p id="1d73" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">为此，我们将使用HostBinding和HostListener装饰器。</p><h1 id="7809" class="mq mr in bd ms mt mu mv mw mx my mz na kc nb kd nc kf nd kg ne ki nf kj ng nh bi translated">创建自定义指令</h1><p id="988b" class="pw-post-body-paragraph kl km in kn b ko ni jx kq kr nj ka kt ku nk kw kx ky nl la lb lc nm le lf lg ig bi translated">在进入编码示例之前，让我们描述一下HostBinding和HostListener decorators。</p><h2 id="213a" class="nr mr in bd ms nx ny dn mw nz oa dp na ku ob oc nc ky od oe ne lc of og ng it bi translated">主机绑定</h2><p id="c8b1" class="pw-post-body-paragraph kl km in kn b ko ni jx kq kr nj ka kt ku nk kw kx ky nl la lb lc nm le lf lg ig bi translated"><a class="ae lh" href="https://angular.io/api/core/HostBinding#hostbinding" rel="noopener ugc nofollow" target="_blank">主机绑定</a>装饰器提供配置元数据。此外，“<em class="nw"> Angular在变化检测期间自动检查主机属性绑定，如果绑定发生变化，它将更新指令</em>的主机元素。”</p><h2 id="fc41" class="nr mr in bd ms nx ny dn mw nz oa dp na ku ob oc nc ky od oe ne lc of og ng it bi translated">主机监听器</h2><p id="9d18" class="pw-post-body-paragraph kl km in kn b ko ni jx kq kr nj ka kt ku nk kw kx ky nl la lb lc nm le lf lg ig bi translated">host listenerdecorator "<em class="nw">声明一个DOM事件来监听，并提供一个处理程序方法在事件发生时运行。</em>”</p><h2 id="1f74" class="nr mr in bd ms nx ny dn mw nz oa dp na ku ob oc nc ky od oe ne lc of og ng it bi translated">如何创建自定义指令</h2><p id="ac88" class="pw-post-body-paragraph kl km in kn b ko ni jx kq kr nj ka kt ku nk kw kx ky nl la lb lc nm le lf lg ig bi translated">我们将创建一个指令，当用户每次单击元素时，这个指令将改变应用它的元素的背景颜色。</p><p id="d939" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated"><strong class="kn ix"> 1。定义自定义指令</strong></p><p id="e675" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">首先，我们创建一个名为click-color.directive.ts的新文件。</p><p id="b7d4" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">在文件中，我们需要定义一个指令。我们通过用@Directive decorator标记类并提供元数据来做到这一点。</p><p id="6c9a" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">具体来说，我们可以通过在装饰器中将指令分配给选择器来提供指令的名称，如下所示:</p><pre class="lj lk ll lm gt nn mp no np aw nq bi"><span id="a996" class="nr mr in mp b gy ns nt l nu nv">//click-color.directive.ts</span><span id="7cf4" class="nr mr in mp b gy oh nt l nu nv">import {Directive} from '@angular/core';</span><span id="7481" class="nr mr in mp b gy oh nt l nu nv">@Directive({<br/>  selector: '[clickColor]',<br/>})<br/>export class ClickColor {}</span></pre><p id="6bc4" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">指令的名称是ClickColor，选择器的名称是clickColor。</p><p id="26d3" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated"><strong class="kn ix"> 2。收听事件</strong></p><p id="ae97" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">我们使用@HostListener装饰器来监听特定的事件，并在事件发生时触发一个函数。</p><p id="6930" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">在指令的类中，我们添加了</p><pre class="lj lk ll lm gt nn mp no np aw nq bi"><span id="aaed" class="nr mr in mp b gy ns nt l nu nv">//click-color.directive.ts</span><span id="93be" class="nr mr in mp b gy oh nt l nu nv">...<br/>export class ClickColor {<br/>  @HostListener('click') onClick() {<br/>    console.log('clicked');<br/>  }<br/>}</span></pre><p id="5b48" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">@HostListener装饰器监听Click事件，并在click事件发生时触发onClick函数来记录一个字符串。</p><p id="ac40" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated"><strong class="kn ix"> 3。注册指令</strong></p><p id="6656" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">请记住，在需要导入自定义指令并将其添加到声明中的AppModule中进行注册。</p><pre class="lj lk ll lm gt nn mp no np aw nq bi"><span id="0566" class="nr mr in mp b gy ns nt l nu nv">// app.module.ts<br/>...<br/>import { ClickColor } from './click-color.directive';</span><span id="b987" class="nr mr in mp b gy oh nt l nu nv">@NgModule({<br/>  imports: ...,<br/>  declarations: [AppComponent, ClickColor],<br/>  bootstrap: [AppComponent],<br/>})<br/>export class AppModule {}</span></pre><p id="be40" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">从Angular 15开始，您可以使用稳定的独立API。</p><p id="67f4" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">因此，您还有另一个选择来注册指令！您可以使用<a class="ae lh" href="https://angular.io/api/core/Directive#standalone" rel="noopener ugc nofollow" target="_blank">独立标志</a>并跳过AppModule中的注册。</p><p id="c3c6" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">"<em class="nw">标记为独立的角度指令不需要在NgModule中声明。这样的指令不依赖于NgModule </em>的任何“中间上下文”</p><p id="e894" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated"><strong class="kn ix"> 4。使用指令</strong></p><p id="c0be" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">使用自定义指令和使用内置指令一样简单。您只需要将选择器添加到应该使用它的HTML元素中。</p><pre class="lj lk ll lm gt nn mp no np aw nq bi"><span id="2fb1" class="nr mr in mp b gy ns nt l nu nv">&lt;div class="box" clickColor&gt;Click Me&lt;/div&gt;</span></pre><p id="815f" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">我们刚刚创建了一个自定义指令，它依赖HostListener在用户每次单击HTML元素时记录一个字符串。</p><h2 id="27d8" class="nr mr in bd ms nx ny dn mw nz oa dp na ku ob oc nc ky od oe ne lc of og ng it bi translated">改进指令</h2><p id="561e" class="pw-post-body-paragraph kl km in kn b ko ni jx kq kr nj ka kt ku nk kw kx ky nl la lb lc nm le lf lg ig bi translated">我们现在希望指令改变它所应用到的元素的背景颜色。</p><p id="a003" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">通过使用Hostbinding装饰器，我们可以绑定到主机元素的属性，在本例中，就是上面的<code class="fe mm mn mo mp b">div</code>。</p><p id="7b01" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">我们可以告诉装饰者通过传入属性名(例如<code class="fe mm mn mo mp b">style.background</code>)来绑定主机元素的属性。</p><pre class="lj lk ll lm gt nn mp no np aw nq bi"><span id="0d3d" class="nr mr in mp b gy ns nt l nu nv">export class ClickColor {<br/>  @HostListener('click') onClick() { ... }</span><span id="f220" class="nr mr in mp b gy oh nt l nu nv">  @HostBinding('style.background') background: string = 'red';<br/>}</span></pre><p id="a799" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">在我们的例子中，<code class="fe mm mn mo mp b">background</code>是指令的属性名，该指令将为主机元素的<code class="fe mm mn mo mp b">style.background</code>赋值。</p><p id="8da9" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">通过分配<code class="fe mm mn mo mp b">red</code>，颜色立即被应用。更好的解决方案可能是暂时不定义<code class="fe mm mn mo mp b">background</code>。</p><pre class="lj lk ll lm gt nn mp no np aw nq bi"><span id="531a" class="nr mr in mp b gy ns nt l nu nv">@HostBinding('style.background') background: string;</span></pre><p id="b1ba" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated"><strong class="kn ix">添加逻辑以提供颜色</strong></p><p id="7d83" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">通过使用下面的代码，在每次单击时设置背景颜色。</p><pre class="lj lk ll lm gt nn mp no np aw nq bi"><span id="1491" class="nr mr in mp b gy ns nt l nu nv">@HostListener('click') onClick() {<br/>  let randomN = Math.random();<br/>  this.background = randomN &lt; 0.5 ? 'red' : 'blue';<br/>}</span></pre><p id="edd1" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">检测到更改后，颜色将应用于宿主元素的背景。</p><p id="350a" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">这是Stackblitz 上<a class="ae lh" href="https://stackblitz.com/edit/angular-ivy-iyeakp?file=src/app/click-color.directive.ts" rel="noopener ugc nofollow" target="_blank">项目的链接，下面你可以找到一个演示。</a></p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Project available on Stackblitz</figcaption></figure><h1 id="a8d1" class="mq mr in bd ms mt mu mv mw mx my mz na kc nb kd nc kf nd kg ne ki nf kj ng nh bi translated">结论</h1><p id="9197" class="pw-post-body-paragraph kl km in kn b ko ni jx kq kr nj ka kt ku nk kw kx ky nl la lb lc nm le lf lg ig bi translated">我们在一个定制指令中使用了@HostBinding和@ HostListener decorators来监听主机上的click事件。</p><p id="4e2f" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">也可以在组件中使用“@HostListener”装饰器；例如，侦听浏览器窗口对象的事件。</p><p id="0453" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated">请随意使用Stackblitz上的项目，并关注我！</p></div><div class="ab cl ok ol hr om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ig ih ii ij ik"><p id="a42e" class="pw-post-body-paragraph kl km in kn b ko kp jx kq kr ks ka kt ku kv kw kx ky kz la lb lc ld le lf lg ig bi translated"><em class="nw">更多内容请看</em><a class="ae lh" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="nw">plain English . io</em></strong></a><em class="nw">。报名参加我们的</em> <a class="ae lh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ix"> <em class="nw">免费周报</em> </strong> </a> <em class="nw">。关注我们关于</em><a class="ae lh" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="nw">Twitter</em></strong></a><a class="ae lh" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="nw">LinkedIn</em></strong></a><em class="nw"/><a class="ae lh" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="nw">YouTube</em></strong></a><em class="nw"/><a class="ae lh" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kn ix"><em class="nw">不和</em> </strong> </a> <em class="nw">。对增长黑客感兴趣？检查</em> <a class="ae lh" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ix"> <em class="nw">电路</em> </strong> </a> <em class="nw">。</em></p></div></div>    
</body>
</html>