<html>
<head>
<title>What is the JavaScript Array.slice() Method?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Array.slice()方法是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-array-slice-method-58526c52bd85?source=collection_archive---------7-----------------------#2022-10-18">https://javascript.plainenglish.io/javascript-array-slice-method-58526c52bd85?source=collection_archive---------7-----------------------#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1dcb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">slice()方法用于根据可选的开始和结束参数返回数组的浅表副本。下面是slice()方法的工作原理。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6362e23a319d5da86d9b74e329d91845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ht32gyqM43AZ7eYKpSIjg.png"/></div></div></figure><p id="517c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数组上的<code class="fe ln lo lp lq b">slice</code>方法返回数组一部分的浅表副本。它需要两个数字，一个<code class="fe ln lo lp lq b">start</code>和一个<code class="fe ln lo lp lq b">end</code>。每个数组都有一个<code class="fe ln lo lp lq b">slice</code>方法。这里有一个简单的例子:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="db15" class="lv lw iq lq b gy lx ly l lz ma">let myArray = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let newArray = myArray.slice(2, 3);</span><span id="ea48" class="lv lw iq lq b gy mb ly l lz ma">console.log(newArray); // [ '🔑' ]</span></pre><p id="7238" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">slice</code>方法有两个可选参数<code class="fe ln lo lp lq b">start</code>和<code class="fe ln lo lp lq b">end</code>。如果您愿意，您可以两者都提供、只提供<code class="fe ln lo lp lq b">start</code>，或者都不提供——因此所有这些都是有效的:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="8375" class="lv lw iq lq b gy lx ly l lz ma">let arrayOne = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayOneSlice = arrayOne.slice(2, 3);  // [ '🔑' ]</span><span id="441a" class="lv lw iq lq b gy mb ly l lz ma">let arrayTwo = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayTwoSlice = arrayTwo.slice(2);  // [ '🔑', '🔩' ]</span><span id="52de" class="lv lw iq lq b gy mb ly l lz ma">let arrayThree = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayThreeSlice = arrayThree.slice();  // [ '⚡️', '🔎', '🔑', '🔩' ]</span></pre><h1 id="3f9e" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">开始</h1><p id="11d0" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这是要包含在新数组中的第一个项目的索引。例如，如果设置为<code class="fe ln lo lp lq b">2</code>，<code class="fe ln lo lp lq b">slice</code>将从索引2开始新的数组复制。如果使用负数，则表示从序列末尾的偏移量。例如:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="5cd3" class="lv lw iq lq b gy lx ly l lz ma">let arrayOne = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayOneSlice = arrayOne.slice(-2);  // [ '🔑', '🔩' ]<br/>let arrayOneSliceAgain = arrayOne.slice(-1);  // [ '🔩' ]</span></pre><h1 id="0441" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结束</h1><p id="23ea" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这是从切片数组中排除的第一个元素——这有点令人困惑。您可能希望<code class="fe ln lo lp lq b">end</code>表示最后一个要包含的项目——但是它是第一个要排除的项目。如果你使用<code class="fe ln lo lp lq b">slice</code>，请记住这一点！如果省略此参数，<code class="fe ln lo lp lq b">slice</code>方法将简单地继续到数组的末尾，如下例所示:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="b5e4" class="lv lw iq lq b gy lx ly l lz ma">let arrayTwo = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayTwoSlice = myArray.slice(2);  // [ '🔑', '🔩' ]</span></pre><p id="8000" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果使用了大于数组长度的值，<code class="fe ln lo lp lq b">slice</code>只会继续到数组的末尾。如果使用负值，则表示从数组末尾的偏移量。例如，<code class="fe ln lo lp lq b">(2, -1)</code>将从数组的开始处为2，从末尾处为-1:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="f185" class="lv lw iq lq b gy lx ly l lz ma">let arrayOne = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayOneSlice = arrayOne.slice(2, -1);  // [ '🔑' ]<br/>let arrayOneSliceAgain = arrayOne.slice(1, -1);  // [ '🔎', '🔑' ]</span></pre><h1 id="9abd" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">使用slice制作数组的副本<a class="ae my" href="https://fjolt.com/article/javascript-slice#using-slice-to-make-a-copy-of-an-array" rel="noopener ugc nofollow" target="_blank"> # </a></h1><p id="a1fe" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">Slice不会改变原始数组。相反，它会创建一个新的浅层副本。因此，现有数组仍将继续包含相同的值:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="3da3" class="lv lw iq lq b gy lx ly l lz ma">let arrayOne = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayOneSlice = arrayOne.slice(2, 3);  </span><span id="67ad" class="lv lw iq lq b gy mb ly l lz ma">console.log(arrayOne); // [ '⚡️', '🔎', '🔑', '🔩' ]<br/>console.log(arrayOneSlice); // [ '🔑' ]</span></pre><p id="8b1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于<code class="fe ln lo lp lq b">slice</code>对数组进行浅层复制，所以它有时也用于复制数组数据。例如，一个空的<code class="fe ln lo lp lq b">slice</code>函数也将在内存中创建一个新的数组——允许您在内存中拥有同一个数组的两个副本，引用相同:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="83dd" class="lv lw iq lq b gy lx ly l lz ma">let arrayOne = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayOneSlice = arrayOne.slice();</span><span id="16c6" class="lv lw iq lq b gy mb ly l lz ma">arrayOneSlice[2] = '⚡️'<br/>console.log(arrayOne); // [ '⚡️', '🔎', '🔑', '🔩' ]<br/>console.log(arrayOneSlice); // [ '⚡️', '🔎', '⚡️', '🔩' ]</span></pre><p id="fd22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这在某些情况下很有用。然而，<code class="fe ln lo lp lq b">slice</code>只是做了一个数组的浅层拷贝。这意味着当数组中有对象时，事情会变得有点混乱。考虑以下阵列:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="4699" class="lv lw iq lq b gy lx ly l lz ma">let arrayOne = [ { items: [ '⚡️', '🔎', '🔑', '🔩' ]}, '👨‍💻', '😄', '🐔' ]</span></pre><p id="b913" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该数组中包含一个对象。让我们尝试制作这个数组的切片副本，然后更新<code class="fe ln lo lp lq b">items</code>:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="3fbe" class="lv lw iq lq b gy lx ly l lz ma">let arrayOne = [ { items: [ '⚡️', '🔎', '🔑', '🔩' ]}, '👨‍💻', '😄', '🐔' ]<br/>let arrayOneSlice = arrayOne.slice(0, 2);</span><span id="7d42" class="lv lw iq lq b gy mb ly l lz ma">arrayOneSlice[0].items = [ '🔎' ];<br/>arrayOneSlice[1] = '🔎';</span><span id="2b0b" class="lv lw iq lq b gy mb ly l lz ma">console.log(arrayOne); // [ { items: [ '🔎' ]}, '👨‍💻', '😄', '🐔' ]<br/>console.log(arrayOneSlice); // [ { items: [ '🔎' ]}, '🔎' ]</span></pre><p id="b901" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">等等，什么？我们改变了<code class="fe ln lo lp lq b">arrayOneSlice</code>的<code class="fe ln lo lp lq b">items</code>对象，但是它在<code class="fe ln lo lp lq b">arrayOne</code>和<code class="fe ln lo lp lq b">arrayOneSlice</code>中都改变了！同时<code class="fe ln lo lp lq b">arrayOneSlice[1]</code>只改变了<code class="fe ln lo lp lq b">arrayOneSlice</code>！欢迎来到另一个Javascript怪癖。在第一个例子中，使用了<code class="fe ln lo lp lq b">arrayOneSlice[0].items</code>符号，Javascript将其解释为更新浅层副本中的现有元素，因此它影响了原始元素。然而，有些令人困惑的是，通过使用<code class="fe ln lo lp lq b">arrayOneSlice[1]</code>符号，Javascript将其解释为将新值放入浅层副本本身的<code class="fe ln lo lp lq b">[1]</code>位置。</p><p id="14e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着，尽管在处理简单的数组时，看起来像是在用<code class="fe ln lo lp lq b">slice</code>做一个拷贝，但在处理更复杂的对象时，这并不成立。了解这一点小事，总有一天会为你节省很多时间。</p><h1 id="d6dd" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论<a class="ae my" href="https://fjolt.com/article/javascript-slice#conclusion" rel="noopener ugc nofollow" target="_blank"> # </a></h1><p id="ea14" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">Javascript slice方法对于使用原始数组数据的子集创建新的数组浅层副本非常有用。它还可以以有限的方式用于制作可以独立更新的副本。Javascript切片副本在内存中仍然具有与原始副本相同的引用，在操作它们时知道这一点很有用。</p><p id="ce8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢这个指南。<a class="ae my" href="https://fjolt.com/category/javascript" rel="noopener ugc nofollow" target="_blank">要了解更多JavaScript，请点击这里查看我的其他文章</a>。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="ee4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ng">更多内容请看</em><a class="ae my" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">plain English . io</em></strong></a><em class="ng">。报名参加我们的</em> <a class="ae my" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们关于</em><a class="ae my" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">Twitter</em></strong></a><a class="ae my" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">LinkedIn</em></strong></a><strong class="kt ir"><em class="ng"/></strong><a class="ae my" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">YouTube</em></strong></a><strong class="kt ir"><em class="ng">，以及</em></strong><em class="ng"/><a class="ae my" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">不和</em> </strong> </a>  <em class="ng">对成长黑客感兴趣？检查</em> <a class="ae my" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">电路</em> </strong> </a> <strong class="kt ir"> <em class="ng">。</em> </strong></p></div></div>    
</body>
</html>