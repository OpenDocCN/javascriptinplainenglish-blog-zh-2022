<html>
<head>
<title>Modern Test-Driven Development with TypeScript and Redux Slices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript和Redux切片的现代测试驱动开发</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/modern-test-driven-development-with-typescript-and-redux-slices-32c249fdc8fe?source=collection_archive---------8-----------------------#2022-02-21">https://javascript.plainenglish.io/modern-test-driven-development-with-typescript-and-redux-slices-32c249fdc8fe?source=collection_archive---------8-----------------------#2022-02-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a0e6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">测试你的React应用，让它防弹。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/912645fbd74806a5481df9b1799d757f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ejy_WacOj2q7X10ltf_ThA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@clark_fransa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae ks" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9b95" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">敏捷软件开发中最重要但最容易被忽视的实践之一是单元测试。在我的职业生涯中，我使用过很多工具和语言，但还没有发现任何一种工具和语言能像在TypeScript/JavaScript中那样容易地测试您的代码。作为前端工程师，我们有责任确保尽可能多的代码被某种单元测试覆盖。除了检查错误的明显好处之外，单元测试还可以作为一种文档形式，以及使我们的功能和组件更小、更可重用的一种练习。</p><p id="1e44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在过去的几年里，我们有幸在React世界中拥有了处理TypeScript和Redux切片的能力。TypeScript为我们提供了类型(显然🙂)而Redux片使我们的状态管理代码比传统的Redux更简洁。它们一起作为React应用程序的强大工具。本文将使用一个todo列表示例向这些工具的用户展示如何有效地对他们的代码进行单元测试并构建防弹应用程序。</p><h2 id="225c" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">入门</strong></h2><p id="9a78" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">为了构建我们的待办事项列表，我们将使用单元测试的红/绿重构模型。这意味着对于每个功能，我们将经历以下步骤:</p><ol class=""><li id="3977" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">用足够的代码写一个函数来编译(还没有逻辑)🙅)</li><li id="caa5" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">编写一个包含该功能预期结果的单元测试</li><li id="1444" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">运行测试，看着它失败</li><li id="4296" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">写一个我们认为会通过单元测试的函数</li><li id="75ca" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">运行函数并观察测试通过</li></ol><p id="44b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们将创建一个样板文件缩减器和单元测试来确保一切正常。我们不写任何逻辑，只写足够的代码来编译应用程序。Redux切片应该如下所示:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="c1f4" class="lp lq in nc b gy ng nh l ni nj">import { createSlice } from "@reduxjs/toolkit";</span><span id="add6" class="lp lq in nc b gy nk nh l ni nj">const todoSlice = createSlice({<br/>  name: "todo",<br/>  reducers: {}, <br/>  initialState: {}, <br/>});</span><span id="1d99" class="lp lq in nc b gy nk nh l ni nj">export default todoSlice.reducer;</span></pre><p id="8cc6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您的单元测试文件应该如下所示:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="4757" class="lp lq in nc b gy ng nh l ni nj">import todoSlice from "../todo.reducer";</span><span id="2acf" class="lp lq in nc b gy nk nh l ni nj">describe("Todo Slice", () =&gt; {<br/>  describe("My First function", () =&gt; {<br/>    it("should compile", () =&gt; {<br/>      expect(1).toEqual(1);<br/>    });<br/>  });<br/>});</span></pre><p id="70d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果此时运行<code class="fe nl nm nn nc b">yarn test</code>，测试应该会编译并通过。</p><h2 id="6c61" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">添加待办事宜</strong></h2><p id="385c" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们将在本文中构建的第一个函数是向我们的状态添加一个todo。因为我们使用单元测试的红/绿方法，我们从编写足够编译的代码开始，但是不足以通过我们的测试。一旦我们的测试失败，我们可以逆向创建我们的函数。让我们首先为我们的todos创建一个模型。我们的todo模型将有<code class="fe nl nm nn nc b">isCompleted</code>、<code class="fe nl nm nn nc b">text</code>和<code class="fe nl nm nn nc b">id</code>属性。然后我们可以用这个模型来创建我们的初始状态。它看起来会像这样:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="630d" class="lp lq in nc b gy ng nh l ni nj">type Todo = {<br/>  id: String;<br/>  text: String;<br/>  isCompleted: boolean;<br/>};</span><span id="efb4" class="lp lq in nc b gy nk nh l ni nj">export type TodoState = {<br/>  todos: Todo[];<br/>};</span><span id="8e04" class="lp lq in nc b gy nk nh l ni nj">export const INITIAL_STATE: TodoState = {<br/>  todos: [],<br/>};</span><span id="a055" class="lp lq in nc b gy nk nh l ni nj">const todoSlice = createSlice({<br/>  name: "todo",<br/>  reducers: {},<br/>  initialState: INITIAL_STATE,<br/>});</span></pre><p id="704c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还将编写一个函数，它的主体什么也不做，并将它添加到reducers中:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="977a" class="lp lq in nc b gy ng nh l ni nj">const todoSlice = createSlice({<br/>  name: "todo",<br/>  reducers: {<br/>    addTodo: (state, action) =&gt; {<br/>      return state;<br/>    },<br/>  },<br/>  initialState: INITIAL_STATE,<br/>});</span><span id="bc4b" class="lp lq in nc b gy nk nh l ni nj">export const { addTodo } = todoSlice.actions;</span></pre><p id="267e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们可以编写第一个失败的测试😄！我们的测试将创建一个todo模型，创建todo操作并尝试修改状态。我们可以将之前的测试重构为以下形式:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="2426" class="lp lq in nc b gy ng nh l ni nj">import todoSlice, {<br/>  addTodo,<br/>  INITIAL_STATE,<br/>  Todo,<br/>  TodoState,<br/>} from "../todo.reducer";</span><span id="65e9" class="lp lq in nc b gy nk nh l ni nj">describe("Todo Slice", () =&gt; {<br/>  describe("addTodo", () =&gt; {<br/>    it("should add a todo to the state", () =&gt; {<br/>      const todo: Todo = {<br/>        id: "1",<br/>        isCompleted: false,<br/>        text: "hello world",<br/>      };<br/>      const action = addTodo(todo);<br/>      const expectedResult: TodoState = {<br/>        todos: [todo],<br/>      };<br/>      const actualResult = todoSlice(INITIAL_STATE, action);<br/>      expect(actualResult).toEqual(expectedResult);<br/>    });<br/>  });<br/>});</span></pre><p id="7a14" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们在这一点上运行我们的测试，我们应该看到图标红色的测试失败文本。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ae2c319aab084971a8a53159adc6bf1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*HPGUxyt1olZ0y8mQsOlBjg.png"/></div></figure><p id="5fc1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">酷！现在我们已经设置了todo模型，这样我们就知道了模型的样子，我们也设置了todo状态，这样我们就知道了它应该是什么样子。让我们来构建一个可以向状态添加数据的函数。更改reducer函数，使其具有添加新todo的逻辑。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="dbdd" class="lp lq in nc b gy ng nh l ni nj">reducers: {<br/>  addTodo: (<br/>    state: TodoState, action: PayloadAction&lt;Todo&gt;<br/>  ) =&gt; {<br/>    const newTodo = action.payload;<br/>    state.todos = [...state.todos, newTodo];<br/>  },<br/>},</span></pre><p id="a600" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此时，您应该通过了测试！我们已经完成了第一次红绿重构🎉。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0dfc142f0b65665c4fc00760f5d8874d.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*FyZVrLLWT1Juq5rqevVoJg.png"/></div></figure><h2 id="d87f" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">修改一个待办事宜</strong></h2><p id="2554" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">让我们再做几个函数，这样您可以更好地感受TS/Redux片单元测试的体验。这一次，我们将通过将现有的todo更新为completed状态来解决状态中已经有数据的情况。像上次一样，我们添加一个空存根并导出它。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="f561" class="lp lq in nc b gy ng nh l ni nj">updateTodo: (state, action) =&gt; {<br/>  return state;<br/>},</span><span id="8bb2" class="lp lq in nc b gy nk nh l ni nj">...</span><span id="fb56" class="lp lq in nc b gy nk nh l ni nj">export const { addTodo, updateTodo } = todoSlice.actions;</span></pre><p id="743c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后我们编写失败的测试，显示标记为完成后的状态。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="0661" class="lp lq in nc b gy ng nh l ni nj">describe("updateTodo", () =&gt; {<br/>  it("should update a todo in the state", () =&gt; {<br/>    const todo: Todo = {<br/>      id: "1",<br/>      isCompleted: false,<br/>      text: "hello world",<br/>    };<br/>    const state: TodoState = {<br/>      todos: [todo],<br/>    };</span><span id="9c4b" class="lp lq in nc b gy nk nh l ni nj">    const updatedTodo: Todo = {<br/>      id: "1",<br/>      isCompleted: true,<br/>      text: "hello world",<br/>    };</span><span id="eff4" class="lp lq in nc b gy nk nh l ni nj">    const action = updateTodo(updatedTodo);</span><span id="af44" class="lp lq in nc b gy nk nh l ni nj">    const expectedResult: TodoState = {<br/>      todos: [updatedTodo],<br/>    };</span><span id="5e5f" class="lp lq in nc b gy nk nh l ni nj">    const actualResult = todoSlice(state, action);<br/>    expect(actualResult).toEqual(expectedResult);<br/>  });<br/>});</span></pre><p id="8f35" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意我是如何使用todo创建一个“状态”来模拟<code class="fe nl nm nn nc b">todoSlice</code> reducer函数中的应用程序状态的？这种“嘲笑”状态的方式对于初学者来说通常很难掌握。我想强调一下，作为对这一领域初学者的一点专业提示。不过，通过这次测试，我们又回到了赤字状态。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/542d29e683c19682701cbb208928d38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*_FosVTyWUPOXH-uEPVyqbA.png"/></div></figure><p id="f887" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们通过真正实现我们的更新函数来解决这个问题。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="d287" class="lp lq in nc b gy ng nh l ni nj">updateTodo: (<br/>  state: TodoState, action: PayloadAction&lt;Todo&gt;<br/>) =&gt; {<br/>  const updatedTodo = action.payload;<br/>  const newTodoArray = [...state.todos];<br/>  const index = newTodoArray.findIndex((todo) =&gt; {<br/>    return updatedTodo.id === todo.id;<br/>  });<br/>  newTodoArray[index] = updatedTodo;<br/>  state.todos = newTodoArray;<br/>},</span></pre><p id="b463" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">至此，红绿循环二完成🔥。我们现在可以在应用程序中添加和更新todos。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8c47033da586f1e1a1def0306af5be19.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*Zm7-sdgn_yarSCNaDstaSg.png"/></div></figure><h2 id="8b85" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">删除待办事宜</strong></h2><p id="efaf" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">让我们通过实现delete来结束本文。这将非常类似于update，但是为了完整起见，我想用最后一个CRUD操作来结束。实现您的<code class="fe nl nm nn nc b">deleteTodo</code>存根并如下导出:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="0999" class="lp lq in nc b gy ng nh l ni nj">deleteTodo: (state, action) =&gt; {<br/>  return state<br/>}<br/>...<br/>export const { addTodo, updateTodo, deleteTodo } = todoSlice.actions;</span></pre><p id="39e5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后进行如下的<code class="fe nl nm nn nc b">deleteTodo</code>测试:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="1ae8" class="lp lq in nc b gy ng nh l ni nj">describe("deleteTodo", () =&gt; {<br/>  it("should delete a todo in the state", () =&gt; {<br/>    const todo: Todo = {<br/>      id: "1",<br/>      isCompleted: false,<br/>      text: "hello world",<br/>    };<br/>    const state: TodoState = {<br/>      todos: [todo],<br/>    };<br/>    const action = deleteTodo("1");<br/>    const expectedResult: TodoState = {<br/>      todos: [],<br/>    };<br/>    const actualResult = todoSlice(state, action);<br/>    expect(actualResult).toEqual(expectedResult);<br/>  });<br/>});</span></pre><p id="483e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看着它失败</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e0df4409d496aa9fb504bac2ae17a8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*1DqHXUBQCFgbcADQ1W1hVA.png"/></div></figure><p id="d225" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后通过实现函数来结束:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="3af2" class="lp lq in nc b gy ng nh l ni nj">deleteTodo: (<br/>  state: TodoState, action: PayloadAction&lt;string&gt;<br/>) =&gt; {<br/>  const id = action.payload;<br/>  state.todos = [...state.todos].filter((todo) =&gt; id !== todo.id);<br/>},</span></pre><p id="6535" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样，所有的测试都通过了，我们有了一个工作的todo reducer:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/659c6f2e1bc515f1ade991175155c690.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*FNKGIZ3wBbk6kymuXHD9vQ.png"/></div></figure><h2 id="403d" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">最终想法</strong></h2><p id="aed2" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">感谢您阅读我关于TDD和TypeScript和Redux Slices的文章。因为这段代码太短了，所以我不会把它全部放在GitHub上。如果你想要一个用TS和TDD进行单元测试的项目的例子，你可以检查<a class="ae ks" href="https://github.com/friyiajr/ReduxSliceCodeAlong" rel="noopener ugc nofollow" target="_blank">这个repo </a>并导航到<code class="fe nl nm nn nc b">final-solution</code>分支。这是一个小项目，从互联网上获取一个口袋妖怪使用其Pokédex号码。我希望您喜欢这篇文章，并期待在您的下一个项目中使用TS和Redux尝试红/绿重构技术！</p><p id="7d66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nu">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nu">plain English . io</em></strong></a><em class="nu">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nu">免费周报</em> </strong> </a> <em class="nu">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nu">社区</em> </strong> </a> <em class="nu">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>