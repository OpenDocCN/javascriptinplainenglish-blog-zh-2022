<html>
<head>
<title>Why Custom React Hooks Could Destroy Your App’s Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么自定义的React钩子会破坏你的应用程序的性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-custom-react-hooks-could-destroy-your-app-performance-2fabbcbdff8e?source=collection_archive---------2-----------------------#2022-01-25">https://javascript.plainenglish.io/why-custom-react-hooks-could-destroy-your-app-performance-2fabbcbdff8e?source=collection_archive---------2-----------------------#2022-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d158" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">探究为什么react自定义挂钩会对React性能产生不利影响，以及如何应对。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7298c94e45c58fd06c0e851c605ce689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sbNfHPfF2zAcpOJ6A3t2LQ.png"/></div></div></figure><p id="a885" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">吓人的标题，不是吗？可悲的是，这是真的:对于性能敏感的应用程序，如果不小心编写和使用，自定义的React钩子很容易变成最大的性能杀手。</p><p id="95bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我不打算在这里解释如何构建和使用钩子，如果你以前从未构建过钩子，React文档有一个<a class="ae lk" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">很好的介绍</a>。今天我想重点讨论的是它们对复杂应用程序的性能影响。</p><h1 id="8437" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">让我们在自定义钩子上构建一个模态对话框</h1><p id="57ac" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">本质上，钩子只是一些高级功能，允许开发人员使用状态和上下文之类的东西，而无需创建新的组件。当您需要在应用程序的不同部分之间共享需要状态的相同逻辑时，它们非常有用。随着钩子的出现，React开发进入了一个新时代:我们的组件从来没有像钩子一样纤细整洁，不同关注点的分离也像钩子一样容易实现。</p><p id="252e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，让我们实现一个模态对话框。使用定制挂钩，我们可以在这里打造出一件美丽的作品。</p><p id="0c50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们实现一个“基础”组件，它没有任何状态，只是在提供了<code class="fe mi mj mk ml b">isOpen</code> prop时呈现对话框，并在单击对话框下面的毯子时触发<code class="fe mi mj mk ml b">onClose</code>回调。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="4899" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">type ModalProps = {<br/>  isOpen: boolean;<br/>  onClosed: () =&gt; void;<br/>};<br/><br/>export const ModalBase = ({ isOpen, onClosed }: ModalProps) =&gt; {<br/>  return isOpen ? (<br/>    &lt;&gt;<br/>      &lt;div css={modalBlanketCss} onClick={onClosed} /&gt;<br/>      &lt;div css={modalBodyCss}&gt;Modal dialog content&lt;/div&gt;<br/>    &lt;/&gt;<br/>  ) : null;<br/>};</em></span></pre><p id="97f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在转到状态管理，即“打开对话/关闭对话”逻辑。在“旧”的方式中，我们通常会实现它的“智能”版本，它处理状态管理并接受一个组件，该组件应该作为道具触发对话框的打开。大概是这样的:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="0649" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">export const ModalDialog = ({ trigger }) =&gt; {<br/>  const [isOpen, setIsOpen] = useState(false);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;div onClick={() =&gt; setIsOpen(true)}&gt;{trigger}&lt;/div&gt;<br/>      &lt;ModalBase isOpen={isOpen} onClosed={() =&gt; setIsOpen(false)} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="2120" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它会被这样使用:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="01d1" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">&lt;ModalDialog trigger={&lt;button&gt;Click me&lt;/button&gt;} /&gt;</em></span></pre><p id="c2a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不是一个特别好的解决方案，我们将触发器组件包装在一个div中，从而打乱了它在模态对话框中的位置和可访问性。更不用说这个不必要的div会导致DOM变得更大更乱。</p><p id="e3d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在看魔术。如果我们将“打开/关闭”逻辑提取到一个定制的钩子中，将这个组件<strong class="kq io">呈现在钩子</strong>中，并公开API来控制它作为钩子的返回值，我们就可以两全其美了。在钩子中，我们将有一个“智能”对话框来处理它自己的状态，但不会干扰触发器，也不需要触发器:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="3413" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">const [isOpen, setIsOpen] = useState(false);<br/><br/>  const open = () =&gt; setIsOpen(true);<br/>  const close = () =&gt; setIsOpen(false);<br/>  const Dialog = () =&gt; &lt;ModalBase onClosed={close} isOpen={isOpen} /&gt;;<br/><br/>  return { isOpen, Dialog, open, close };<br/>};</em></span></pre><p id="b8f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在消费者方面，我们将拥有最少的代码，同时完全控制触发对话的内容:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="1103" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">const ConsumerComponent = () =&gt; {<br/>  const { Dialog, open } = useModal();<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={open}&gt;Click me&lt;/button&gt;<br/>      &lt;Dialog /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="1c17" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果这还不是完美，我不知道什么是完美！😍<a class="ae lk" href="https://codesandbox.io/s/modal-dialog-example1-9ds2c?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank">在codesandbox </a>看到这个美女。只是不要急着马上在你的应用中使用它，直到你读到它的阴暗面😅</p><h1 id="614e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">性能影响</h1><p id="2243" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在<a class="ae lk" href="https://www.developerway.com/posts/how-to-write-performant-react-code" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我详细介绍了导致性能不佳的各种模式，我实现了一个“慢”应用程序:页面上呈现了一个简单的、未经优化的大约250个国家的列表。但是每一次交互都会导致整个页面被重新渲染，这可能是最慢的简单列表。<a class="ae lk" href="https://codesandbox.io/s/re-renders-final-bad-4znwe" rel="noopener ugc nofollow" target="_blank">这里是codesandbox </a>，点击列表中不同的国家来明白我的意思(如果你在最新的Mac上稍微调节一下你的CPU来获得更好的印象)。</p><blockquote class="mw mx my"><p id="3901" class="ko kp mv kq b kr ks jo kt ku kv jr kw mz ky kz la na lc ld le nb lg lh li lj ig bi translated"><strong class="kq io">如何节流CPU </strong>:在Chrome开发者工具中打开“性能”标签，点击右上角的“齿轮”图标——会打开一个附加的小面板，里面有节流选项。</p></blockquote><p id="a8cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将在那里使用我们新的完美模态对话框，看看会发生什么。主<code class="fe mi mj mk ml b">Page</code>组件的代码相对简单，如下所示:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="fc05" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  const [selectedCountry, setSelectedCountry] = useState&lt;Country&gt;(countries[0]);<br/>  const [savedCountry, setSavedCountry] = useState&lt;Country&gt;(countries[0]);<br/>  const [mode, setMode] = useState&lt;Mode&gt;('light');<br/><br/>  return (<br/>    &lt;ThemeProvider value={{ mode }}&gt;<br/>      &lt;h1&gt;Country settings&lt;/h1&gt;<br/>      &lt;button onClick={() =&gt; setMode(mode === 'light' ? 'dark' : 'light')}&gt;Toggle theme&lt;/button&gt;<br/>      &lt;div className="content"&gt;<br/>        &lt;CountriesList countries={countries} onCountryChanged={(c) =&gt; setSelectedCountry(c)} savedCountry={savedCountry} /&gt;<br/>        &lt;SelectedCountry country={selectedCountry} onCountrySaved={() =&gt; setSavedCountry(selectedCountry)} /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/ThemeProvider&gt;<br/>  );<br/>};</em></span></pre><p id="405d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我需要一个靠近“切换主题”按钮的按钮，该按钮将打开一个模式对话框，其中包含该页面的一些未来附加设置。幸运的是，现在已经简单得不能再简单了:在顶部添加<code class="fe mi mj mk ml b">useModal</code>钩子，在需要的地方添加按钮，并将<code class="fe mi mj mk ml b">open</code>回调传递给按钮。<code class="fe mi mj mk ml b">Page</code>组件几乎没有变化，仍然非常简单:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/fe5d6d80e3b6d949849f3b54f9ec2074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o_PRF_r___-SFZIY.png"/></div></div></figure><p id="3ce2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可能已经猜到了结果🙂有史以来最慢的两个空div出现😱。<a class="ae lk" href="https://codesandbox.io/s/re-renders-bad-with-dialog-6egnq?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">参见codesandbox。</a></p><p id="58f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你看，这里所发生的，就是我们的<code class="fe mi mj mk ml b">useModal</code>钩使用状态。正如我们所知，状态变化是组件重新呈现自身的原因之一。这也适用于钩子——如果钩子的状态改变,“主机”组件将重新呈现。这完全说得通。如果我们仔细观察<code class="fe mi mj mk ml b">useModal</code>钩子内部，我们会发现它只是围绕<code class="fe mi mj mk ml b">setState</code>的一个很好的抽象，它存在于<code class="fe mi mj mk ml b">Dialog</code>组件的之外的<strong class="kq io">。本质上，这与直接调用<code class="fe mi mj mk ml b">Page</code>组件中的<code class="fe mi mj mk ml b">setState</code>没有什么不同。</strong></p><p id="d3b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是钩子的最大危险:是的，它们帮助我们使API变得非常好。但是我们所做的结果是，钩子的方式非常鼓励它，本质上是从它应该在的地方<strong class="kq io">提升状态。除非你深入到<code class="fe mi mj mk ml b">useModal</code>实现内部，或者对钩子和重新渲染有丰富的经验，否则这是完全不明显的。我甚至没有在<code class="fe mi mj mk ml b">Page</code>组件中直接使用状态，从它的角度来看，我所做的只是渲染一个<code class="fe mi mj mk ml b">Dialog</code>组件，并调用一个命令式API来打开它。</strong></p><p id="0d06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在“旧世界”中，状态会被封装在带有<code class="fe mi mj mk ml b">trigger</code>道具的略显丑陋的<code class="fe mi mj mk ml b">Modal</code>对话框中，当按钮被点击时<code class="fe mi mj mk ml b">Page</code>组件会保持完整。现在点击按钮改变了整个页面组件<strong class="kq io">的状态</strong>，导致其重新渲染(这对于这个应用程序来说超级慢)。只有在React完成了所有重新渲染后，对话框才会出现，因此会有很大的延迟。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/7f411a1ea86d5194fe6a381545734ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZQjUW2mjwnuPkFqP.png"/></div></div></figure><p id="b96d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么，我们能做些什么呢？我们可能没有时间和资源来修复<code class="fe mi mj mk ml b">Page</code>组件的底层性能，因为这通常会发生在“真正的”应用程序上。但至少我们可以确保这个新特性不会增加性能问题，而且它本身很快。这里我们需要做的只是将模态状态“下移”，远离缓慢的<code class="fe mi mj mk ml b">Page</code>组件:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="74cf" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">const SettingsButton = () =&gt; {<br/>  const { Dialog, open } = useModal();<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={open}&gt;Open settings&lt;/button&gt;<br/>      &lt;Dialog /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="27dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">而在<code class="fe mi mj mk ml b">Page</code>中只是渲染了<code class="fe mi mj mk ml b">SettingsButton</code>:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="0b0d" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  // same as original page state<br/>  return (<br/>    &lt;ThemeProvider value={{ mode }}&gt;<br/>      // stays the same<br/>      &lt;SettingsButton /&gt;<br/>      // stays the same<br/>    &lt;/ThemeProvider&gt;<br/>  );<br/>};</em></span></pre><p id="6c46" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当点击按钮时，只有<code class="fe mi mj mk ml b">SettingsButton</code>组件会重新渲染，慢速的<code class="fe mi mj mk ml b">Page</code>组件不受影响。本质上，我们在模仿状态模型，就像它在“旧”世界中一样，同时保留了基于钩子的API。参见<a class="ae lk" href="https://codesandbox.io/s/re-renders-bad-with-dialog-fixed-rrfey?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>中的解决方案。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/f2d16bc7e334ecf773e8020322848ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mK7Ci-02qgcIZp8U.png"/></div></div></figure><h1 id="3f49" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">为<code class="fe mi mj mk ml b">useModal</code>挂钩增加更多功能</h1><p id="13dc" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">让我们的钩子性能对话稍微暗一点🙂。例如，假设您需要跟踪模式内容中的滚动事件。也许你想在用户滚动文本时发送一些分析事件来跟踪阅读。如果我不想在<code class="fe mi mj mk ml b">BaseModal</code>中引入“智能”功能，而是在<code class="fe mi mj mk ml b">useModal</code>钩子中实现，会发生什么？</p><p id="6938" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相对容易实现。我们可以在那里引入一个新的状态来跟踪滚动位置，在<code class="fe mi mj mk ml b">useEffect</code>钩子中添加事件侦听器，并将ref传递给<code class="fe mi mj mk ml b">BaseModal</code>以获取内容元素来附加侦听器。大概是这样的:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="6c3c" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">export const ModalBase = React.forwardRef(({ isOpen, onClosed }: ModalProps, ref: RefObject&lt;any&gt;) =&gt; {<br/>  return isOpen ? (<br/>    &lt;&gt;<br/>      &lt;div css={modalBlanketCss} onClick={onClosed} /&gt;<br/>      &lt;div css={modalBodyCss} ref={ref}&gt;<br/>        // add a lot of content here<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  ) : null;<br/>});<br/><br/>export const useModal = () =&gt; {<br/>  const [isOpen, setIsOpen] = useState(false);<br/>  const ref = useRef&lt;HTMLElement&gt;(null);<br/>  const [scroll, setScroll] = useState(0);<br/><br/>  // same as before<br/><br/>  useEffect(() =&gt; {<br/>    const element = ref.current;<br/>    if (!element) return;<br/><br/>    const handleScroll = () =&gt; {<br/>      setScroll(element?.scrollTop || 0);<br/>    };<br/><br/>    element.addEventListener('scroll', handleScroll);<br/>    return () =&gt; {<br/>      element.removeEventListener('scroll', handleScroll);<br/>    };<br/>  });<br/><br/>  const Dialog = () =&gt; &lt;ModalBase onClosed={close} isOpen={isOpen} ref={ref} /&gt;;<br/><br/>  return {<br/>    isOpen,<br/>    Dialog,<br/>    open,<br/>    close,<br/>  };<br/>};</em></span></pre><p id="5f31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们可以对这个状态做任何事情。现在让我们假设前面的性能问题不是什么大问题，并再次在慢速页面组件中直接使用这个钩子。<a class="ae lk" href="https://codesandbox.io/s/re-renders-bad-with-dialog-with-scroll-p9wi8?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">参见codesandbox </a>。</p><p id="8588" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">滚动甚至不能正常工作！😱每次我试图滚动对话框内容时，它都会重置到顶部！</p><p id="5821" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好吧，我们来逻辑思考一下。<a class="ae lk" href="https://www.developerway.com/posts/how-to-write-performant-react-code" rel="noopener ugc nofollow" target="_blank">我们已经知道</a>，在渲染函数中创建组件是邪恶的，因为React会在每次重新渲染时重新创建和挂载它们。我们知道钩子会随着状态的改变而改变。这意味着现在，当我们引入滚动状态时，每次滚动改变我们都在改变状态，这导致钩子重新呈现，这导致<code class="fe mi mj mk ml b">Dialog</code>组件重新创建自己。完全相同的问题，就像在渲染函数中创建组件一样，有完全相同的解决方法:我们需要将这个组件提取到钩子之外，或者只是将它屏蔽掉。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="d6a0" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">const Dialog = useMemo(() =&gt; {<br/>  return () =&gt; &lt;ModalBase onClosed={close} isOpen={isOpen} ref={ref} /&gt;;<br/>}, [isOpen]);</em></span></pre><p id="f5b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">焦点行为是固定的，但这里有另一个问题:缓慢的<code class="fe mi mj mk ml b">Page</code>组件在每次滚动时重新渲染！这一点很难注意到，因为对话内容只是文本。例如，尝试将CPU降低6倍，滚动，然后立即高亮显示对话框中的文本。浏览器甚至不允许这样做，因为它忙于重新渲染下面的<code class="fe mi mj mk ml b">Page</code>组件！<a class="ae lk" href="https://codesandbox.io/s/re-renders-bad-with-dialog-with-scroll-fixed-scroll-0s5g3?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">参见codesandbox。</a>滚动几下后，你的笔记本电脑可能会因为100%的CPU负载而试图飞向月球😅</p><p id="4b80" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">是的，我们肯定需要在发布到生产之前解决这个问题。让我们再来看看我们的组件，尤其是这一部分:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="bcc5" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">return {<br/>  isOpen,<br/>  Dialog,<br/>  open,<br/>  close,<br/>};</em></span></pre><p id="7f5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们在每次重新渲染时都返回一个新的对象，因为我们现在在每次滚动时都重新渲染我们的钩子，这意味着对象在每次滚动时都会改变。但是我们在这里没有使用滚动状态，它完全是在<code class="fe mi mj mk ml b">useModal</code>钩子内部使用的。难道仅仅记住那个物体就能解决问题吗？</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="6be4" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">return useMemo(<br/>  () =&gt; ({<br/>    isOpen,<br/>    Dialog,<br/>    open,<br/>    close,<br/>  }),<br/>  [isOpen, Dialog],<br/>);</em></span></pre><p id="18ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你知道这最精彩(或最恐怖)的部分吗？它没有！😱<a class="ae lk" href="https://codesandbox.io/s/re-renders-bad-with-dialog-with-scroll-fixed-scroll-and-memo-35lqx?file=/src/country-settings/modal-dialog.tsx" rel="noopener ugc nofollow" target="_blank">参见codesandbox </a>。</p><p id="af65" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是另一个与钩子有关的巨大的性能问题。事实证明，钩子中的状态变化是不是“内部的”并不重要。<strong class="kq io">钩子的每一次状态变化，无论是否影响其返回值，都会导致“宿主”组件重新渲染。</strong></p><p id="1679" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，链接钩子的情况完全相同:如果钩子的状态发生变化，它将导致它的“主机”钩子也发生变化，这将通过整个钩子链向上传播，直到它到达“主机”组件并重新渲染它(这将导致重新渲染的另一个连锁反应，现在只在下游)，<strong class="kq io">而不管中间应用的任何记忆</strong>。</p><p id="5401" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将“滚动”功能提取到一个钩子中绝对没有任何区别，缓慢的页面组件将重新呈现😔。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="3c10" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">const useScroll = (ref: RefObject) =&gt; {<br/>  const [scroll, setScroll] = useState(0);<br/><br/>  useEffect(() =&gt; {<br/>    const element = ref.current;<br/>    if (!element) return;<br/><br/>    const handleScroll = () =&gt; {<br/>      setScroll(element?.scrollTop || 0);<br/>    };<br/><br/>    element.addEventListener('scroll', handleScroll);<br/>    return () =&gt; {<br/>      element.removeEventListener('scroll', handleScroll);<br/>    };<br/>  });<br/><br/>  return scroll;<br/>};<br/><br/>export const useModal = () =&gt; {<br/>  const [isOpen, setIsOpen] = useState(false);<br/>  const ref = useRef&lt;HTMLElement&gt;(null);<br/>  const scroll = useScroll(ref);<br/><br/>  const open = useCallback(() =&gt; {<br/>    setIsOpen(true);<br/>  }, []);<br/><br/>  const close = useCallback(() =&gt; {<br/>    setIsOpen(false);<br/>  }, []);<br/><br/>  const Dialog = useMemo(() =&gt; {<br/>    return () =&gt; &lt;ModalBase onClosed={close} isOpen={isOpen} ref={ref} /&gt;;<br/>  }, [isOpen, close]);<br/><br/>  return useMemo(<br/>    () =&gt; ({<br/>      isOpen,<br/>      Dialog,<br/>      open,<br/>      close,<br/>    }),<br/>    [isOpen, Dialog, open, close],<br/>  );<br/>};</em></span></pre><p id="745d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://codesandbox.io/s/re-renders-bad-with-dialog-with-scroll-extracted-woeer?file=/src/country-settings/modal-dialog.tsx" rel="noopener ugc nofollow" target="_blank">参见codesandbox </a>。</p><p id="2d84" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">怎么修？好吧，这里唯一要做的就是将滚动跟踪钩子移到<code class="fe mi mj mk ml b">useModal</code>钩子之外，并在不会导致重渲染链的地方使用它。可以介绍<code class="fe mi mj mk ml b">ModalBaseWithAnalytics</code>组件为例:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="ecef" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">const ModalBaseWithAnalytics = (props: ModalProps) =&gt; {<br/>  const ref = useRef&lt;HTMLElement&gt;(null);<br/>  const scroll = useScroll(ref);<br/><br/>  console.log(scroll);<br/><br/>  return &lt;ModalBase {...props} ref={ref} /&gt;;<br/>};</em></span></pre><p id="41b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后用在<code class="fe mi mj mk ml b">useModal</code>钩上代替<code class="fe mi mj mk ml b">ModalBase</code>:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="e019" class="mq lm in ml b gy mr ms l mt mu"><em class="mv">export const useModal = () =&gt; {<br/>  // the rest is the same as in the original useModal hook<br/><br/>  const Dialog = useMemo(() =&gt; {<br/>    return () =&gt; &lt;ModalBaseWithAnalytics onClosed={close} isOpen={isOpen} ref={ref} /&gt;;<br/>  }, [isOpen, close]);<br/><br/>  return useMemo(<br/>    () =&gt; ({<br/>      isOpen,<br/>      Dialog,<br/>      open,<br/>      close,<br/>    }),<br/>    [isOpen, Dialog, open, close],<br/>  );<br/>};</em></span></pre><p id="64d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，滚动导致的状态变化将局限于<code class="fe mi mj mk ml b">ModalBaseWithAnalytics</code>组件，不会影响慢速的<code class="fe mi mj mk ml b">Page</code>组件。<a class="ae lk" href="https://codesandbox.io/s/re-renders-bad-with-dialog-scroll-fixed-for-good-v6ohp?file=/src/country-settings/modal-dialog.tsx" rel="noopener ugc nofollow" target="_blank">参见codesandbox。</a></p><p id="ebba" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天到此为止！希望这篇文章足够让你害怕，帮助你更好地理解定制钩子，以及如何在不影响应用程序性能的情况下编写和使用它们。在离开之前，让我们回顾一下性能挂钩的规则:</p><ul class=""><li id="d89c" class="ne nf in kq b kr ks ku kv kx ng lb nh lf ni lj nj nk nl nm bi translated">钩子中的每一个状态变化都会导致它的“主机”组件重新呈现，不管这个状态是否在钩子值中返回，是否被memoised</li><li id="5f7b" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">与链式挂钩相同，挂钩中的每个状态变化都会导致所有“父”挂钩发生变化，直到它到达“主机”组件，这将再次触发重新渲染</li></ul><p id="a1ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以及在编写或使用定制钩子时需要注意的事项:</p><ul class=""><li id="a5fc" class="ne nf in kq b kr ks ku kv kx ng lb nh lf ni lj nj nk nl nm bi translated">当使用一个定制钩子时，确保这个钩子封装的状态没有在组件方法中没有使用的级别上使用。如有必要，将其“向下”移动到一个较小的组件</li><li id="6f86" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">永远不要在钩子中实现“独立”状态，也不要在独立状态下使用钩子</li><li id="4a72" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">当使用自定义钩子时，确保它不会执行一些独立的状态操作，这些操作不会在其返回值中公开</li><li id="f82d" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">当使用一个自定义钩子时，确保它使用的所有钩子都遵循上面的规则</li></ul><p id="969f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">保持安全，并希望您的应用程序从现在开始快速运行！✌🏼</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="678a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mv">最初发表于</em><a class="ae lk" href="https://www.developerway.com" rel="noopener ugc nofollow" target="_blank"><em class="mv">【https://www.developerway.com】</em></a><em class="mv">。网站上有更多这样的文章</em>😉</p><p id="27d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.developerway.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mv">订阅简讯</em> </a>、<em class="mv"> </em> <a class="ae lk" href="https://www.linkedin.com/in/adevnadia/" rel="noopener ugc nofollow" target="_blank"> <em class="mv">在LinkedIn </em> </a> <em class="mv">或</em> <a class="ae lk" href="https://twitter.com/adevnadia" rel="noopener ugc nofollow" target="_blank"> <em class="mv">上关注Twitter </em> </a> <em class="mv">以便在下一篇文章出来时立即获得通知。</em></p><p id="03f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mv">更多内容请看</em><a class="ae lk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mv">plain English . io</em></strong></a><em class="mv">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mv">免费周报</em> </strong> </a> <em class="mv">。在我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mv">社区不和谐</em> </strong> </a> <em class="mv">获取独家写作机会和建议。</em></p></div></div>    
</body>
</html>