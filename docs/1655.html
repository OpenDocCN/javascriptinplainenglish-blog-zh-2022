<html>
<head>
<title>How to write polyfills for the call(), apply(), and bind() methods in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中为call()、apply()和bind()方法编写polyfills</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-polyfills-for-call-apply-and-bind-methods-in-javascript-13b4ba313273?source=collection_archive---------0-----------------------#2022-04-09">https://javascript.plainenglish.io/writing-polyfills-for-call-apply-and-bind-methods-in-javascript-13b4ba313273?source=collection_archive---------0-----------------------#2022-04-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/be7479b45bc432abceb97d68e743aa99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q0xvXSgqWh0ljzKL"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f4c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JavaScript中，<code class="fe ky kz la lb b">call()</code>、<code class="fe ky kz la lb b">apply()</code>和<code class="fe ky kz la lb b">bind()</code>方法用于函数借用。这意味着通过使用它们，我们可以在不同的对象上使用一个对象的方法，而不必复制那个方法并在两个不同的地方维护它。</p><p id="d704" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个带有属性<strong class="kc io">名字</strong> &amp; <strong class="kc io">姓氏</strong>的对象<strong class="kc io">我的名字</strong>和一个打印名字和姓氏的函数<code class="fe ky kz la lb b"><strong class="kc io">printName()</strong></code>，如下所示:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="f948" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们想借用<strong class="kc io"> </strong> <code class="fe ky kz la lb b"><strong class="kc io">printName()</strong></code>函数来打印<strong class="kc io"> myName </strong>对象的名字和姓氏属性。让我们了解一下如何使用<code class="fe ky kz la lb b">call()</code>、<code class="fe ky kz la lb b">apply()</code>和<code class="fe ky kz la lb b">bind()</code>方法来实现。</p><h1 id="f137" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">呼叫方法</h1><p id="ec4e" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">使用<code class="fe ky kz la lb b">call()</code>，我们可以为myName对象借用<code class="fe ky kz la lb b">printName()</code>函数，如下所示:</p><pre class="lc ld le lf gt ml lb mm mn aw mo bi"><span id="fd5b" class="mp lj in lb b gy mq mr l ms mt">printName.call(myName, "Palia", "India");</span></pre><p id="9712" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个参数是上下文或所有者对象(即我们例子中的myName)。其余的值(“Palia”和“India”)是<code class="fe ky kz la lb b">printName()</code>函数接受的额外参数。</p><p id="8411" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="mu">输出:</em> </strong></p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/f0e279447748cea9c33ec0b633810d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGkmAE06sNjmjvvGSbEO8A.png"/></div></div></figure><h2 id="a531" class="mp lj in bd lk mw mx dn lo my mz dp ls kl na nb lw kp nc nd ma kt ne nf me ng bi translated">call()的Polyfill:</h2><p id="c802" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">JavaScript中的每个函数都可以访问这些<code class="fe ky kz la lb b">call()</code>、<code class="fe ky kz la lb b">apply()</code>和<code class="fe ky kz la lb b">bind()</code>方法。同样，JavaScript中的每个函数都应该可以访问我们的<code class="fe ky kz la lb b">myCall</code>方法。这可以通过将myCall函数放在函数原型中来实现。</p><pre class="lc ld le lf gt ml lb mm mn aw mo bi"><span id="fc80" class="mp lj in lb b gy mq mr l ms mt">eg. Function.prototype.myCall = function(){}</span></pre><p id="9fb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于<code class="fe ky kz la lb b">call()</code>的简单聚合填充:</p><pre class="lc ld le lf gt ml lb mm mn aw mo bi"><span id="e69a" class="mp lj in lb b gy mq mr l ms mt">Function.prototype.myCall = function(context, ...args){<br/>    context.myFn = this;<br/>    context.myFn(...args);<br/>}</span><span id="a20e" class="mp lj in lb b gy nh mr l ms mt">printName.myCall(myName, "Palia", "India");</span></pre><p id="1e14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以上代码是<code class="fe ky kz la lb b">call()</code>方法的简单多项填充。这里<strong class="kc io">上下文</strong>指向<strong class="kc io"> myName </strong>对象，而<strong class="kc io"> this </strong>关键字指向<code class="fe ky kz la lb b"><strong class="kc io">printName()</strong></code>函数。函数定义中的参数<strong class="kc io"> …arg </strong> s表示我们在使用<code class="fe ky kz la lb b"><strong class="kc io">myCall</strong></code>方法时可以传递的所有额外参数(例如城市和国家)。</p><p id="ec27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在这里所做的就是将<code class="fe ky kz la lb b"><strong class="kc io">printName()</strong></code>函数作为属性(<strong class="kc io"> myFn </strong>)分配给<strong class="kc io"> myName </strong>对象并执行它。但这不是一个完整的解决方案。如果属性<strong class="kc io"> myFn </strong>已经存在于<strong class="kc io"> myName </strong>中怎么办？我们会改写它。所以我们需要确保我们正在使用的属性的名称是唯一的。</p><p id="47b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">全填充:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="8dc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，我们使用<code class="fe ky kz la lb b">Math.random()</code>生成一个随机属性(以确保该属性是惟一的)。</p><h1 id="7388" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">运用方法</h1><p id="654d" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated"><code class="fe ky kz la lb b">call()</code>和<code class="fe ky kz la lb b">apply()</code>方法之间唯一的区别是<code class="fe ky kz la lb b">call()</code>方法单独接受参数，而<code class="fe ky kz la lb b">apply()</code>方法以数组的形式接受参数。参见下面的例子。</p><pre class="lc ld le lf gt ml lb mm mn aw mo bi"><span id="dd06" class="mp lj in lb b gy mq mr l ms mt">printName.apply(myName, ["Palia", "India"]);</span></pre><h2 id="37be" class="mp lj in bd lk mw mx dn lo my mz dp ls kl na nb lw kp nc nd ma kt ne nf me ng bi translated">应用的聚合填充():</h2><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="8d83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，<code class="fe ky kz la lb b">apply()</code>的聚合填充与<code class="fe ky kz la lb b">call()</code>的聚合填充几乎相同。唯一的区别是我们在函数定义中没有将<strong class="kc io"> …args </strong>作为参数。我们只有一个args参数，因为它是一个数组/列表。</p><h1 id="da63" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">绑定方法</h1><p id="80de" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated"><code class="fe ky kz la lb b">bind()</code>方法不是直接调用<code class="fe ky kz la lb b">printName()</code>方法，而是返回一个函数，我们可以在以后调用它。</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/75e0481718e09f214d03de678cce7c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*8P-RfYyvJCewfGYotEaK2Q.gif"/></div></figure><p id="2792" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上下文和参数被保留。<code class="fe ky kz la lb b">bind()</code>函数的美妙之处在于，您甚至可以向返回的函数传递一些/更多的参数(在我们的例子中就是<code class="fe ky kz la lb b">result()</code>)。</p><pre class="lc ld le lf gt ml lb mm mn aw mo bi"><span id="4bff" class="mp lj in lb b gy mq mr l ms mt">const result = printName.bind(myName, "Palia");<br/>result("India");</span></pre><h2 id="e795" class="mp lj in bd lk mw mx dn lo my mz dp ls kl na nb lw kp nc nd ma kt ne nf me ng bi translated">绑定的聚合填充():</h2><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="286c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，<strong class="kc io">这个</strong>关键字指向了<code class="fe ky kz la lb b"><strong class="kc io">printName()</strong></code>函数。变量<strong class="kc io"> args[0] </strong>是传递给我们的<code class="fe ky kz la lb b">myBind()</code>方法(即myName对象)的第一个参数，而<strong class="kc io"> ctx </strong>包含传递给我们的<code class="fe ky kz la lb b">myBind()</code>方法的所有其他参数。参数<strong class="kc io">…一个</strong>包含所有可以传递给<code class="fe ky kz la lb b">result2()</code>方法的参数。最后，我们使用<code class="fe ky kz la lb b"><strong class="kc io">call()</strong></code>方法调用<code class="fe ky kz la lb b"> <strong class="kc io">printName()</strong></code>函数，将<strong class="kc io"> myName </strong>对象作为上下文，并将所有参数组合在一起。</p><h1 id="fa21" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">视频解释:</h1><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="nj lh l"/></div></figure><p id="15e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mu">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mu">plain English . io</em></strong></a><em class="mu">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mu">免费周报</em> </strong> </a> <em class="mu">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mu">Twitter</em></strong></a><em class="mu">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mu">LinkedIn</em></strong></a><em class="mu">。加入我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mu">社区不和谐</em> </strong> </a> <em class="mu">。</em></p></div></div>    
</body>
</html>