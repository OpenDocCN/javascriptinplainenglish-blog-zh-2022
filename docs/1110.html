<html>
<head>
<title>The React.ReactNode type is a black hole</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">的反应。反应节点类型是一个黑洞</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-react-reactnode-type-is-a-black-hole-49a8e5516c32?source=collection_archive---------23-----------------------#2022-03-03">https://javascript.plainenglish.io/the-react-reactnode-type-is-a-black-hole-49a8e5516c32?source=collection_archive---------23-----------------------#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0cf412b5e4708c8cca1ad4bf0b0db081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBdDCnj0AwkxjTDHz50NLw.png"/></div></div></figure><p id="803a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为开发人员，我们出于几个不同的原因使用TypeScript。自我文档方面是巨大的——能够进入一个不熟悉的功能，并知道它所期望的对象的形状，这在处理大型项目时是一个巨大的好处。增加的工具特性，包括智能感知和类似的功能，对生产力也有很大的帮助。但是对我来说，使用强类型系统的最重要的原因是<em class="kx">消除</em>一整类运行时错误，其中一个函数被传递了一个它不知道如何处理的对象，并且在运行时失败。</p><p id="71a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正是最后一个原因导致了这篇文章的目的。我最近处理了一个错误，React组件在运行时抛出了一个异常。问题的根源是最近在国际化我们的应用程序的这个区域时进行的重构，其中一个期望可呈现的属性意外地被传递了一个不能呈现的类的对象。</p><p id="56b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是我们期望TypeScript在编译时捕捉到的那种错误！</p><p id="93a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是怎么发生的？从高层次上来说，这是因为包含在<code class="fe ky kz la lb b">DefinitelyTyped</code>中的<code class="fe ky kz la lb b">React.ReactNode</code>类型，在全世界成千上万的代码库中使用，被定义得如此之弱以至于几乎没有意义。</p><p id="48cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">我们在</em><a class="ae kw" href="https://jsparty.fm/213" rel="noopener ugc nofollow" target="_blank"><em class="kx">JS Party # 213</em></a><em class="kx">的TIL段子里高层次的讨论过这个问题，但是我觉得它值得更严谨的处理。</em></p><p id="1d3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">跟我一起分享探索，为什么这种虫子在野外逗留超过3！)年<a class="ae kw" href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/29307" rel="noopener ugc nofollow" target="_blank">以来，它最初被报道</a>，以及我们如何在我们的代码库中解决它，使我们自己再次受到保护。</p><h1 id="b47f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">形势</h1><p id="a994" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">它始于一个简单的错误报告:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="ca1c" class="mn ld iq lb b gy mo mp l mq mr">When I click on "Boost nudges" and attempt to select a filter group, I get an error saying something went wrong. This feature is vital for a demo I have tomorrow.</span></pre><p id="5511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的第一个检查是看我是否能在生产应用程序中重现它。我可以。接下来是启动一个开发人员环境，这样我就可以得到一个有用的回溯，错误非常明显:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/4901ed573bbb5b00708152c5587ed3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_FOvpwmsWAumf8vs.png"/></div></div></figure><p id="f89c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解释:React试图渲染一些它无法渲染的东西。使用文件号和行号进一步追踪，我可以看到这个有问题的对象是一个名为<code class="fe ky kz la lb b">description</code>的道具，它有以下类型定义:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="dabd" class="mn ld iq lb b gy mo mp l mq mr">description: string | React.ReactNode;</span></pre><p id="9740" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调用者传递给它的是一个<code class="fe ky kz la lb b">TranslatedText</code>对象，这是我们在系统中用来处理国际化的一个类。预期的用途是将该对象传递给一个知道如何使用它的<code class="fe ky kz la lb b">&lt;T&gt;</code>组件和一个字符串库，以便为当前用户以正确的语言呈现文本。</p><p id="9e04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到这一点:修复非常简单。在将<code class="fe ky kz la lb b">TranslatedText</code>对象作为道具传入之前，将其包装在<code class="fe ky kz la lb b">&lt;T&gt;</code>组件中。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/674077110fd2d0f627cc27fdb5ade1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vli2sTwnwUIKFlbh.png"/></div></div></figure><p id="23a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个补丁，直接的bug就解决了，票里提到的演示也解除了。</p><p id="2206" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理解bug是如何产生的非常简单——应用程序的这一部分最近才被国际化，bug就是在这项工作中引入的。但是真正的难题开始了:这种类型的错误不正是使用TypeScript和类型应该防止的吗？类型系统怎么会允许React无法渲染的东西被传递到类型为<code class="fe ky kz la lb b">string | React.ReactNode</code>的道具中呢？</p><h1 id="eeab" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">这条小径</h1><p id="d8d6" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">当我第一次看到这个问题没有被发现时，我最初的想法是，可能由于某种原因，类型检查根本没有运行。也许我们有一个跨模块调用的bug，或者我们的配置有问题。但是我很快就排除了这种可能性，只是将prop类型减少到<code class="fe ky kz la lb b">string</code>，并发现它触发了一个类型错误。</p><p id="a339" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我尝试的下一件事是测试<code class="fe ky kz la lb b">TranslatedText</code>是否以某种方式实现了<code class="fe ky kz la lb b">React.ReactNode</code>接口，但是向TranslatedText(即<code class="fe ky kz la lb b">class TranslatedText implements React.ReactNode</code>)添加快速<code class="fe ky kz la lb b">implements</code>注释导致编译器抛出错误。这符合我的预期，因为它<strong class="ka ir">没有</strong>实现接口——如果它实现了，我们一开始就不会有这个问题了！</p><p id="54a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我开始深入研究<code class="fe ky kz la lb b">React.ReactNode</code>的定义方式。这些定义来自<code class="fe ky kz la lb b">DefinitelyTyped</code>，npm包的类型定义的规范开源存储库，它本身不包含类型，而<a class="ae kw" href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/2034c45/types/react/index.d.ts#L203" rel="noopener ugc nofollow" target="_blank">键定义</a>看起来像这样:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="6e09" class="mn ld iq lb b gy mo mp l mq mr">type ReactText = string | number; <br/>type ReactChild = ReactElement | ReactText; <br/>interface ReactNodeArray extends Array&lt;ReactNode&gt; {} <br/>type ReactFragment = {} | ReactNodeArray; <br/>type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;</span></pre><p id="cfba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，在<code class="fe ky kz la lb b">ReactFragment</code>定义中！</p><p id="c44a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">ReactNode</code>类型中包含的<code class="fe ky kz la lb b">ReactFragment</code>包含一个空接口。由于【TypeScript处理多余属性检查的方式，这意味着<code class="fe ky kz la lb b">ReactNode</code>类型将接受任何对象<em class="kx">，除了</em>一个对象文字。对于几乎所有的意图和目的，它在功能上等同于一个<code class="fe ky kz la lb b">any</code>类型。尽管大多数使用这种类型的函数都希望它意味着“React可以渲染的东西”。</p><p id="6594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，我把它带回了我们在胡姆的团队:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/9cd5dc62cc0932ef997d75efcc26b091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2KjmmS7JON_p6eTe.png"/></div></div></figure><p id="345e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着人们深入调查，我们的一名团队成员发现，这是一个自2018年以来的<a class="ae kw" href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/29307" rel="noopener ugc nofollow" target="_blank">已知问题！有</a><a class="ae kw" href="https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/55422" rel="noopener ugc nofollow" target="_blank">一个讨论</a>暗示了解决问题的意图，但是担心引入修复的连锁反应，并且在一年的大部分时间里没有进展。</p><h1 id="2ea7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第一次尝试修复</h1><p id="5d1d" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">当我们开始在代码库中寻找解决这个问题的方法时，我们考虑了两个选项:</p><ol class=""><li id="7502" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">将我们代码库中的所有内容转移到自定义类型</li><li id="bb55" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">使用<code class="fe ky kz la lb b">patch-package</code>来更新React。反应节点定义</li></ol><p id="dec0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">评估这些不同方法的优缺点，我们认为<code class="fe ky kz la lb b">patch-package</code>方法需要更少的代码更改和更少的持续认知负载，但是缺点是需要额外的依赖(和相关的暂时依赖),并且可能使正在发生的事情不太明显。</p><p id="e062" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们决定先试试<code class="fe ky kz la lb b">patch-package</code>，因为这样工作量会少一些。变化非常简单；我们尝试了一个<code class="fe ky kz la lb b">ReactFragment</code>类型的补丁，它看起来非常像在确定类型讨论线程中提出的那个:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="92df" class="mn ld iq lb b gy mo mp l mq mr">type Fragment = { <br/>  key?: string | number | null;<br/>  ref?: null;<br/>  props?: { <br/>    children?: ReactNode; <br/>  }; <br/>}</span></pre><p id="5905" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这种方法不会在我们的代码库中引发任何内部类型问题，并且导致类型系统能够捕获一开始就困扰我们的错误类，但它会导致调用几个React生态系统库时出现级联类型错误。我们在代码与<code class="fe ky kz la lb b">react-beautiful-dnd</code>的接口处遇到了麻烦:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/bdffe526177c06f5bc5e754384ab2120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HtnLAjJZA0L6HGKR.png"/></div></div></figure><p id="908b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在潜入兔子洞并试图解决这些类型问题一会儿之后，只是让每一个改变都导致越来越多的类型挑战，我决定这需要比我更有打字天赋的人来解决。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/ebdeb0fd711f5a7f5b610a960c43b0b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LKSAoq7oxpkD-A8o.png"/></div></div></figure><h1 id="f1af" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第二种方法</h1><p id="04e7" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我们尝试的第二种方法是在我们的代码库中创建一个更严格的类型，查找/替换以在任何地方使用它，然后添加一个linter以防止它被使用。我们最终得到的类型文件与我们在补丁方法中尝试过的文件非常相似:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="9d31" class="mn ld iq lb b gy mo mp l mq mr">import { ReactChild, ReactPortal, ReactNodeArray } from 'react';</span><span id="a17f" class="mn ld iq lb b gy nl mp l mq mr">export type StrictReactFragment = <br/>  | { <br/>      key?: string | number | null;<br/>      ref?: null; <br/>      props?: { <br/>        children?: StrictReactNode; <br/>      }; <br/>    } <br/>  | ReactNodeArray; </span><span id="8917" class="mn ld iq lb b gy nl mp l mq mr">export type StrictReactNode = <br/>  | ReactChild<br/>  | StrictReactFragment<br/>  | ReactPortal<br/>  | boolean<br/>  | null<br/>  | undefined;</span></pre><p id="a210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在验证该类型确实捕获了我们试图防止的类型错误之后，是时候在我们的代码库中进行替换了。</p><p id="6dba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我简要地探索了使用<a class="ae kw" href="https://github.com/facebook/jscodeshift" rel="noopener ugc nofollow" target="_blank"> jscodeshift </a>来自动进行替换。我开始沿着这条路走下去，但是我以前没有使用jscodeshift的经验，这被证明是很棘手的。由于时间有限，我认为我们的代码库足够小，在VS代码中运行find/replace加上手动添加导入将是易处理的，并且比继续试图找出jscodeshift要快得多。</p><p id="f32d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:如果有人想写这个codemod并发送给我，我很乐意把它作为这篇文章的附录，并为你大声喊出来！</p><p id="eeb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一次公关之后，我们有了一个更安全的代码库，在任何地方都可以使用<code class="fe ky kz la lb b">StrictReactNode</code>,但是还有一个步骤可以让它持续下去。</p><h1 id="01b6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">编写ESLint插件</h1><p id="3ac4" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated"><code class="fe ky kz la lb b">React.ReactNode</code>渗透到我们的代码库的原因是它是一种在许多情况下都可以使用的逻辑类型。任何时候你想要断言一个道具可以被React渲染，很自然的就要用到<code class="fe ky kz la lb b">React.ReactNode</code>。</p><p id="ae0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要我们所有的开发人员转而使用<code class="fe ky kz la lb b">StrictReactNode</code>。让开发人员自行决定或者要求这成为手工代码审查和/或教育的一部分似乎是站不住脚的，尤其是在像Humu这样快速发展的公司。</p><p id="6e30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了执行新的实践，并使其无缝地保持我们的代码库最新和安全，我们决定编写一个自定义的ESLint linter来检查<code class="fe ky kz la lb b">React.ReactNode</code>，并抛出一个指向我们首选类型的错误。</p><p id="26c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章不是关于ESLint插件如何工作的，但是如果你想使用它，这里是我们得到的插件:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="f9f9" class="mn ld iq lb b gy mo mp l mq mr">module.exports = {<br/>    create(context) {<br/>        return {<br/>            TSTypeReference(node) {<br/>                if (<br/>                    node.typeName.type === 'TSQualifiedName' &amp;&amp;<br/>                    node.typeName.left.name === 'React' &amp;&amp;<br/>                    node.typeName.right.name === 'ReactNode'<br/>                ) {<br/>                   context.report(<br/>                       node,<br/>                       node.loc,<br/>                       'React.ReactNode considered unsafe. Use StrictReactNode from humu-components/src/util/strictReactNode instead.',<br/>                   );<br/>                }<br/>            },<br/>        };<br/>    },<br/>};</span></pre><p id="a48e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果有人不小心试图在类型声明中使用<code class="fe ky kz la lb b">React.ReactNode</code>，他们会得到如下所示的错误:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/027c4a7d6c4e19ac543236f283f99102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gzwbGezFpIESUKiP.png"/></div></div></figure><p id="6d4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">林挺是我们CI测试的一部分，它发生在任何分支可以被合并之前，所以这可以防止任何人意外地引入不安全的<code class="fe ky kz la lb b">React.ReactNode</code>类型并将他们指向替换类型。</p><p id="5e0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">更新</em> : <a class="ae kw" href="https://twitter.com/mathieutu" rel="noopener ugc nofollow" target="_blank"> Mathieu TUDISCO </a>写了一个<a class="ae kw" href="https://gist.github.com/mathieutu/577be7f0cbeba71a894981f07fc082e3" rel="noopener ugc nofollow" target="_blank">更广义的eslint插件，带一个fixer </a>！</p><h1 id="df27" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">包扎</h1><p id="b373" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">从我的角度来看，使用TypeScript和类型系统的整个目标是能够防止一整类的错误，并使重构像最初的那个一样安全。</p><p id="488a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个超级常用的库中有一个像这样的宽开放类型是超级可怕的。如果时间允许的话，我会继续努力让这个补丁明确地定型，但是生态系统的问题太大了，这不太可能及时发生。如此巨大的变化产生了巨大的波动，类型需要更新。</p><p id="9c94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，我强烈推荐使用类似我们的<code class="fe ky kz la lb b">StrictReactNode</code>的方法来保护你的代码库。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="3c31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">最初发表于</em><a class="ae kw" href="https://changelog.com/posts/the-react-reactnode-type-is-a-black-hole" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://changelog.com</em></a><em class="kx">。</em></p><p id="7cf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">更多内容看</em> <a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="kx">说白了就是</em> </strong> </a> <em class="kx">。报名参加我们的</em> <a class="ae kw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="kx">免费每周简讯</em> </strong> </a> <em class="kx">。关注我们</em><a class="ae kw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kx">Twitter</em></strong></a><em class="kx">和</em><a class="ae kw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kx">LinkedIn</em></strong></a><em class="kx">。加入我们的</em> <a class="ae kw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="kx">社区不和谐</em> </strong> </a> <em class="kx">。</em></p></div></div>    
</body>
</html>