<html>
<head>
<title>UseSyncExternalStore to Manage Global State in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SyncExternalStore管理React中的全局状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/usesyncexternalstore-to-manage-global-state-in-react-ac31c7191376?source=collection_archive---------7-----------------------#2022-12-21">https://javascript.plainenglish.io/usesyncexternalstore-to-manage-global-state-in-react-ac31c7191376?source=collection_archive---------7-----------------------#2022-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jm jn jo jp gh gi paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gh gi jl"><img src="../Images/174fa017adcb1826bd20d9002936a003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iutILfK_8Bm3SOtV"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">Photo by <a class="ae ka" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ka" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="efb0" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们都知道React希望我们如何管理状态，主要是通过<em class="kz">钩子</em>。我写了一本关于它的书<a class="ae ka" href="https://www.amazon.com/Designing-React-Hooks-Right-Way-dp-1803235950/dp/1803235950/ref=mt_other?_encoding=UTF8&amp;me=&amp;qid=1640158953" rel="noopener ugc nofollow" target="_blank">以正确的方式设计React钩子</a>，在那里你可以找到很多使用钩子来保存组件渲染数据的例子。坦率地说，<em class="kz"> React </em>都是关于使用局部状态驱动组件渲染的。</p><p id="fd4a" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">尽管我很喜欢本地状态管理，但在某些情况下，尤其是在与捆绑了外部数据存储的第三方集成时，我们希望第三方在外部数据发生变化时通知<em class="kz"> React </em>。</p><p id="9163" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">让我们来看看最近推出的<a class="ae ka" href="https://thisweekinreact.com/articles/useSyncExternalStore-the-underrated-react-api" rel="noopener ugc nofollow" target="_blank"> React 18 </a>钩子<code class="fe la lb lc ld b">useSyncExternalStore</code>是如何做到这一点的。假设我们有客房服务，每当有新客人出现，我们都要为他登记一个房间。如果有任何房间活动，他会得到通知。以下是图书馆代码:</p><pre class="le lf lg lh gt li ld lj bn lk ll bi"><span id="ba5b" class="lm ln in ld b be lo lp l lq lr">let occupied = []<br/>const list = []<br/><br/>function checkIn(room) { <br/>  occupied = [...occupied, room]<br/>  notify()<br/>}<br/><br/>function checkOut(room) { <br/>  occupied = occupied.filter(r =&gt; r !== room)<br/>  notify()<br/>}<br/><br/>function notify() {<br/>  list.forEach(cb =&gt; {<br/>    cb()<br/>  })<br/>}<br/><br/>export function subscribe(callback) {<br/>  list.push(callback)<br/>  ...<br/>}<br/><br/>export function getOccupied() {<br/>  return occupied<br/>}</span></pre><p id="36be" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">客房服务是建立在一个<code class="fe la lb lc ld b">occupied</code>数组之上的，这个数组记录了已入住房间的列表。最重要的是，它使用了一个订阅<code class="fe la lb lc ld b">list</code>，所以我们可以使用<code class="fe la lb lc ld b">subscribe</code>来添加一个<code class="fe la lb lc ld b">callback</code>功能，以防任何<code class="fe la lb lc ld b">checkIn</code>和<code class="fe la lb lc ld b">checkOut</code>活动发生，所有的听众都可以立即得到通知。</p><p id="c5a5" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="kz">注意:</em> <code class="fe la lb lc ld b"><em class="kz">subscribe</em></code> <em class="kz">和</em> <code class="fe la lb lc ld b"><em class="kz">getOccupied</em></code> <em class="kz">都是从库的接口导出的，所以它们是公共的消费者方法。</em></p><h2 id="99f5" class="ls ln in bd lt lu lv dn lw lx ly dp lz km ma mb mc kq md me mf ku mg mh mi mj bi translated">什么是useSyncExternalStore？</h2><p id="ad95" class="pw-post-body-paragraph kb kc in kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky ig bi translated">现在在<em class="kz"> React </em>内部，我们想要使用这个库，比如<code class="fe la lb lc ld b">checkIn</code>和<code class="fe la lb lc ld b">checkOut</code>，此外我们想要它，以便每当房间可用性发生变化时，组件可以反映这种变化。</p><p id="7781" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">下面是<code class="fe la lb lc ld b">useSyncExternalStore</code>钩子的定义:</p><pre class="le lf lg lh gt li ld lj bn lk ll bi"><span id="c8aa" class="lm ln in ld b be lo lp l lq lr">function useSyncExternalStore&lt;Snapshot&gt;(<br/>  subscribe: (onStoreChange: () =&gt; void) =&gt; () =&gt; void,<br/>  getSnapshot: () =&gt; Snapshot<br/>): Snapshot;</span></pre><p id="4aba" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">钩子将两个函数<code class="fe la lb lc ld b">subscribe</code>和<code class="fe la lb lc ld b">getSnapshot</code>作为输入，返回<code class="fe la lb lc ld b">Snapshot</code>状态。这有点复杂。让我们将客房服务插入其中，看看它实际上是如何工作的:</p><pre class="le lf lg lh gt li ld lj bn lk ll bi"><span id="9151" class="lm ln in ld b be lo lp l lq lr">const App = () =&gt; {<br/>  const occupied = useSyncExternalStore(subscribe, getOccupied)<br/>  ...<br/>}</span></pre><p id="405a" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">第一个参数是一个<code class="fe la lb lc ld b">subscribe</code>函数，它的唯一目的是允许我们的钩子通过回调来监听房间服务的变化。你可能想知道为什么我们看不到<code class="fe la lb lc ld b">callback</code>出现在界面的任何地方。这是因为这个回调变量是在初始化时在<code class="fe la lb lc ld b">useSyncExternalStore</code>钩子内创建的，并且将在订阅过程中被发送给<code class="fe la lb lc ld b">subscribe</code>。我们的工作是确保客房服务确实实现了这个接受<code class="fe la lb lc ld b">callback</code>作为输入的<code class="fe la lb lc ld b">subscribe</code>函数。完成所有这些设置后，从现在开始，客房服务应该与<em class="kz"> React </em>组件连接。</p><p id="4ae6" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">第二个参数是一个<code class="fe la lb lc ld b">getSnapshot</code>函数，在我们的例子中，它返回<code class="fe la lb lc ld b">occupied</code>状态。如果从函数返回的状态发生变化，<code class="fe la lb lc ld b">App</code>组件将像<em class="kz">反应</em>一样尝试重新渲染。我们这些来自<em class="kz"> Redux </em>的人可以把这个函数和<code class="fe la lb lc ld b">selector</code>函数联系起来。这里的想法是相似的。</p><p id="88bf" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">钩子函数以第二个函数<code class="fe la lb lc ld b">getOccupied</code>给出的格式返回状态<code class="fe la lb lc ld b">occupied</code>。您可以将这个状态与<code class="fe la lb lc ld b">App</code>中UI的其余部分连接起来。</p><p id="67a6" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">就是这样。你可能会想，这个钩子什么时候能派上用场？我猜想任何支持订阅模型的库在这里都是很好的候选，比如<code class="fe la lb lc ld b">window.addEventListener</code>。</p><h2 id="7a5a" class="ls ln in bd lt lu lv dn lw lx ly dp lz km ma mb mc kq md me mf ku mg mh mi mj bi translated">与<code class="fe la lb lc ld b">useState</code>的区别</h2><p id="4209" class="pw-post-body-paragraph kb kc in kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky ig bi translated">让我们快速比较一下这个吓人的<code class="fe la lb lc ld b">useSyncExternalStore</code>和常见的<code class="fe la lb lc ld b">useState</code>:</p><ul class=""><li id="fcaf" class="mp mq in kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated"><code class="fe la lb lc ld b">useState</code>定义一个本地状态</li><li id="750c" class="mp mq in kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><code class="fe la lb lc ld b">useSyncExternalStore</code>基于全局状态导出局部状态</li></ul><p id="fa2d" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">相似之处在于两个钩子都定义了本地状态，而关键的不同之处在于，由于<code class="fe la lb lc ld b">useSyncExternalStore</code>所基于的服务是一个<strong class="kd io">全局</strong>服务，很可能该服务甚至在我们进入<code class="fe la lb lc ld b">App</code>组件之前就已经被初始化了。在此之后，服务可以被任何其他组件调用，甚至可以在任何时候在<em class="kz"> React </em>之外调用，因此理论上可以有很多东西与<em class="kz"> React </em>代码一起进行。只有当服务生成一个<strong class="kd io">新的</strong> <code class="fe la lb lc ld b">Snapshot</code>(可能在<em class="kz"> React </em>之外)时，钩子才会得到一个新状态的通知，从而进入常规的<em class="kz"> React </em>渲染周期。</p><p id="2ccf" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="kz">更多内容看</em> <a class="ae ka" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io"> <em class="kz">说白了就是</em> </strong> </a> <em class="kz">。报名参加我们的</em> <a class="ae ka" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io"> <em class="kz">免费每周简讯</em> </strong> </a> <em class="kz">。关注我们</em> <a class="ae ka" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io"> <em class="kz">推特</em> </strong> </a>，<a class="ae ka" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io"> <em class="kz">领英</em> </strong> </a> <em class="kz">，</em><a class="ae ka" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kd io"><em class="kz">YouTube</em></strong></a><em class="kz">，</em> <a class="ae ka" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io"> <em class="kz">不和</em> </strong> </a> <strong class="kd io"> <em class="kz">。</em> </strong></p><p id="3a7f" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kd io"> <em class="kz">有兴趣缩放你的软件启动</em> </strong> <em class="kz">？检查出</em> <a class="ae ka" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io"> <em class="kz">电路</em> </strong> </a> <em class="kz">。</em></p></div></div>    
</body>
</html>