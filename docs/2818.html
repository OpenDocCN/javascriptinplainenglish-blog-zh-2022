<html>
<head>
<title>Image Optimization in the Browser in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年浏览器中的图像优化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/image-optimization-in-the-browser-in-2022-8691a3fa35d2?source=collection_archive---------8-----------------------#2022-07-06">https://javascript.plainenglish.io/image-optimization-in-the-browser-in-2022-8691a3fa35d2?source=collection_archive---------8-----------------------#2022-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/498b9a22fe2dacb62c89805985c10efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-levqeSYukWrIyQT"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ideasboom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Qingbao Meng</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e9a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将讨论一些实践，这些实践允许您优化站点上图像的加载和呈现。</p><h1 id="dfba" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">图像缓存</h1><p id="f18a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">客户端缓存是浏览器将文件存储在本地以便不被再次访问的能力。这对图像和CSS/JavaScript文件非常有用。当用户浏览页面时，如果不使用浏览器上的缓存机制，浏览器将不断请求相同的文件。</p><p id="c1f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哪些文件应该被缓存由Cache-control和Expires HTTP头控制。服务器随响应一起发送这样的头，指示浏览器是否将该文件保存到本地存储。</p><h2 id="263d" class="mb kz in bd la mc md dn le me mf dp li kl mg mh lm kp mi mj lq kt mk ml lu mm bi translated">缓存控制</h2><p id="cc10" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Cache-control HTTP头用于控制浏览器缓存。它必须与所有需要缓存的文件一起传输。它具有以下格式:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="351c" class="mb kz in ms b gy mw mx l my mz">Cache-Control: <strong class="ms io">private</strong>, max-age=0, no-cache</span></pre><ul class=""><li id="2fb9" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">私有意味着缓存只能在用户的浏览器上工作。相反，您可以使用public语句。这允许在公共代理服务器上进行缓存(通常出现在公司中)。</li><li id="5d89" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">无缓存意味着不能缓存请求。</li><li id="0a33" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">max-age是缓存结果的时间。以秒为单位设定。</li></ul><h2 id="f109" class="mb kz in bd la mc md dn le me mf dp li kl mg mh lm kp mi mj lq kt mk ml lu mm bi translated">期满</h2><p id="6568" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">可选的HTTP Expires标头指定浏览器刷新缓存的日期和时间:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="fee8" class="mb kz in ms b gy mw mx l my mz">Expires: Mon, 20 Mar 2024 00:00:00 GMT</span></pre><p id="1b91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">浏览器最早将在2024年发送第二次请求，直到那时它将使用缓存</p><p id="c0d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此标头应与Cache-Control结合使用。</p><h1 id="69ef" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">现代图像格式</h1><p id="e902" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">WebP是Google在2010年开发的一种文件格式。它的特点是一个先进的压缩算法，允许您减少图像的大小，而没有明显的质量损失。</p><p id="ca14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目前，几乎所有现代<a class="ae jz" href="https://caniuse.com/webp" rel="noopener ugc nofollow" target="_blank">浏览器</a>都支持这种格式。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/17219e91fc0350fcae2cea255965894c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4JvW-_Yf6Uop8C5hH203w.jpeg"/></div></div></figure><p id="a165" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">平均而言，webp图像的重量减少了25–35%。尽管所有这些足以让你相信WebP的好处，但是仅仅依赖一种非后备格式仍然不是一个好主意。在不支持WebP的浏览器中，图像会被破坏。</p><p id="b2c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用<picture>元素回退到WebP。这个HTML5元素允许我们为一个图像添加多种格式。</picture></p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dc52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">webp优势:</p><ul class=""><li id="af5e" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">带有压缩WebP图像的网站工作速度更快。处理小文件花费的时间更少。即使这篇文章只有不到100张图片，压缩也会让你免于太长的下载时间。</li><li id="f2b1" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">当用户通过智能手机访问网站时，将花费更少的移动流量。</li></ul><h1 id="f7ef" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">垂直空间的保留</h1><p id="3d8f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">不久前，最新版本的浏览器学会了在布局中为加载的图像预留空间，从而防止可能的布局偏移(<a class="ae jz" href="https://web.dev/cls/" rel="noopener ugc nofollow" target="_blank"> CLS </a>)。为了让浏览器为上传的图像保留空间，您必须设置它的宽度和高度属性。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="ac42" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">惰性装载</h1><p id="0cf3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将一些资源定义为不太重要，以便推迟加载它们，直到真正需要它们的时候。因此，您可以在特定的时间点减少网络和处理器的负载。</p><p id="293c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">img元素的loading属性可以用来告诉浏览器延迟加载图像，直到用户达到与图像交互的阶段，比如滑动页面。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="5b6a" class="mb kz in ms b gy mw mx l my mz">&lt;<strong class="ms io">img</strong> <!-- -->src="testImage.webp"<!-- --> <strong class="ms io">loading</strong>="<strong class="ms io">lazy</strong>" /&gt;</span></pre><p id="6fbe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，并非所有的<a class="ae jz" href="https://caniuse.com/loading-lazy-attr" rel="noopener ugc nofollow" target="_blank">浏览器</a>都支持加载属性。因此，惰性加载技术也可以使用数据属性和JavaScript来实现。</p><h1 id="9564" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">响应性</h1><p id="63bb" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">使用srcset和sizes属性，可以指定同一图像的多个变体。浏览器将计算并选择下载为用户设备提供最佳图像尺寸和图像质量比例的那个。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="cb92" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">img标签的解码属性</h1><p id="dba9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">属性允许您控制是否允许浏览器尝试并行加载您的图像。如果这样做会导致问题，您可以指定<code class="fe nr ns nt ms b">sync</code>来禁用异步加载。这在应用于<code class="fe nr ns nt ms b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" rel="noopener ugc nofollow" target="_blank">&lt;img&gt;</a></code>元素时很有用，但在用于屏幕外图像对象时可能更有用。</p><p id="16cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nr ns nt ms b">sync</code></p><p id="e845" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同步解码图像，以便与其他内容一起进行原子呈现。</p><p id="a058" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nr ns nt ms b">async</code></p><p id="72a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">异步解码图像以减少呈现其他内容的延迟。</p><p id="34af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nr ns nt ms b">auto</code></p><p id="02f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认模式，表示没有解码模式的首选项。浏览器决定什么最适合用户。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="bbea" class="mb kz in ms b gy mw mx l my mz">&lt;<strong class="ms io">img</strong> <strong class="ms io">src</strong>="testImage.jpg" <strong class="ms io">decoding</strong>="<strong class="ms io">async</strong>" /&gt;</span></pre><h1 id="98e6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">内容可见性</h1><p id="1a1a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">content-visibility CSS属性控制一个元素是否呈现它的内容，同时强制一组强大的容器，允许用户代理潜在地省略大量的布局和呈现工作，直到需要时为止。基本上，它使用户代理能够跳过元素的呈现工作(包括布局和绘画),直到需要它为止——这使得初始页面加载速度更快。</p><p id="a4c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当设置为auto时，属性通知浏览器图像在布局中的定位可以延迟，直到它接近用户的显示区域。当用户翻阅网站页面时，浏览器将决定图像与视窗的距离。当到达一定距离时，DOM元素将被渲染，之后图像将被加载。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="a2f9" class="mb kz in ms b gy mw mx l my mz"><strong class="ms io">img</strong> {<br/>  <strong class="ms io">content-visibility</strong>: auto;<br/>}</span></pre><h1 id="7115" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="c554" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">今天我们已经回顾了一些最相关的网络图像优化方法。我希望这些材料对您有用，并且您现在已经准备好在您的项目中使用这些实践。在这篇小文章中不可能解释所有的主要观点。</p><p id="d97b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nu">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nu">plain English . io</em></strong></a><em class="nu">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nu">免费周报</em> </strong> </a> <em class="nu">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nu">Twitter</em></strong></a><em class="nu">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nu">LinkedIn</em></strong></a><em class="nu">。查看我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nu">社区不和谐</em> </strong> </a> <em class="nu">加入我们的</em> <a class="ae jz" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nu">人才集体</em> </strong> </a> <em class="nu">。</em></p></div></div>    
</body>
</html>