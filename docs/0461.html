<html>
<head>
<title>Try MobX instead of Redux for Your State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尝试使用MobX而不是Redux进行状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/try-mobx-instead-of-redux-for-your-state-management-2120d3239c6f?source=collection_archive---------13-----------------------#2022-01-26">https://javascript.plainenglish.io/try-mobx-instead-of-redux-for-your-state-management-2120d3239c6f?source=collection_archive---------13-----------------------#2022-01-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6c4f1ca657af679d61de71b6a4672d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKQaBLAT3XbVfwHT4lXUgQ.png"/></div></div></figure><p id="b340" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">MobX是一个久经考验的库，它通过透明地应用函数式反应式编程(TFRP)使状态管理变得简单和可伸缩。MobX背后的理念很简单:</p><ol class=""><li id="a2da" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">直截了当:编写最少的、没有样板文件的代码，抓住你的意图。</li><li id="0315" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">轻松实现最佳渲染:在运行时跟踪对数据的所有更改和使用，构建一个依赖树来捕获状态和输出之间的所有关系。</li><li id="5330" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">架构自由:MobX是非独立的，允许您在任何UI框架之外管理应用程序状态。</li></ol></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="dfe1" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated">安装:<strong class="jx io"> MobX可以在任何ES5环境下工作，包括浏览器和node . js</strong>React绑定有两种，mobx-react-lite只支持功能组件，而mobx-react也支持基于类的组件。将适合您的用例的绑定附加到<em class="in">纱线</em>或<em class="in"> NPM </em>命令:<code class="fe lv lw lx ly b"> $ yarn add mobx mobx-react</code></p></blockquote></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="dbdb" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated">MobX的要点:</p></blockquote><p id="8130" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lr">状态</em> </strong>:状态就像保存一个值的电子表格单元格。将状态存储在您喜欢的任何数据结构中:普通对象、数组、类、循环数据结构或引用。这对MobX的运作来说无关紧要。只要确保所有想要随时间改变的属性都被标记为可观察的，这样MobX就可以跟踪它们。" @可观察"</p><p id="6e55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lr">动作:</em> </strong>一个<em class="lr">动作</em>是改变<em class="lr">状态</em>的任何一段代码。用户事件、后端数据推送、预定事件等。动作就像用户在电子表格单元格中输入新值。建议您将任何改变observable的代码标记为一个<a class="ae lz" href="https://mobx.js.org/actions.html" rel="noopener ugc nofollow" target="_blank">动作</a>。这样，MobX可以自动应用事务，轻松获得最佳性能。" @动作"</p><p id="4ba7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lr">推导:</em> </strong> <em class="lr">任何能够从<em class="lr">态</em>中推导出来而没有任何进一步相互作用的东西都是推导。衍生以多种形式存在:</em></p><ul class=""><li id="e7b0" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ma kz la lb bi translated"><em class="lr">用户界面</em></li><li id="112c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated"><em class="lr">导出数据</em>，如剩余待办事项的数量</li><li id="f1f1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated"><em class="lr">后端集成</em>，例如向服务器发送更改</li></ul><p id="ad75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">MobX区分了两种类型的派生:</p><ul class=""><li id="12d9" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ma kz la lb bi translated"><strong class="jx io"/></li><li id="265a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated"><em class="lr">反应</em>，状态改变时需要自动发生的副作用(命令式和反应式编程之间的桥梁)</li></ul><p id="7c85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当开始使用MobX时，人们倾向于过度使用反应。黄金法则是，如果您想基于当前状态创建一个值，请始终使用<strong class="jx io"><em class="lr"/></strong>。" @computed "</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="81c2" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> MobX核心</em> </strong></p></blockquote><p id="2921" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">属性、整个对象、数组、地图和集合都可以被观察到。使对象可观察的基础是使用makeObservable为每个属性指定一个注释。最重要的注释是:</p><ul class=""><li id="bfbb" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ma kz la lb bi translated"><strong class="jx io"> <em class="lr">可观察的</em> </strong>定义了存储状态的可跟踪字段。</li><li id="a2c1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated"><strong class="jx io"> <em class="lr">动作</em> </strong>将方法标记为将修改状态的动作。</li><li id="7fa9" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated"><strong class="jx io"> <em class="lr"> computed </em> </strong>标记一个getter，它将从状态中获取新的事实并缓存其输出。</li></ul><ol class=""><li id="c3ec" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io"><em class="lr">make observable</em></strong></li></ol><p id="938b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它可以用来捕获<em class="lr">现有的</em>对象属性，并使它们可被观察到。任何JavaScript对象(包括类实例)都可以传入目标。通常makeObservable用在类的构造函数中，它的第一个参数是这样的。annotations参数将注释<a class="ae lz" href="https://mobx.js.org/observable-state.html#available-annotations" rel="noopener ugc nofollow" target="_blank">映射到每个成员。注意，当使用</a><a class="ae lz" href="https://mobx.js.org/enabling-decorators.html" rel="noopener ugc nofollow" target="_blank">装饰器</a>时，可以省略annotations参数。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/c5c0fe8931ee9410ee6c06d613992241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AwKth1kgrOOpYh9GNjgG6Q.png"/></div></div></figure><p id="c0cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">推理规则:</p><ul class=""><li id="b42e" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ma kz la lb bi translated">所有<em class="lr">拥有的</em>属性变得可观察。</li><li id="6c6f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated">所有的getters都变成计算的。</li><li id="303c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated">所有的设定者都变成了行动者。</li><li id="25a0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated">原型上的所有<em class="lr">功能变为自动动作。</em></li><li id="cd69" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated">原型上的所有<em class="lr">发电机功能变为流量。(请注意，在某些transpiler配置中，生成器函数是不可检测的，如果flow没有按预期工作，请确保显式指定flow。)</em></li><li id="ef76" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ma kz la lb bi translated">overrides参数中标记为false的成员将不会被注释。例如，将它用于标识符等只读字段。</li></ul><p id="9d81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">2<em class="lr">。可观察的</em> </strong></p><p id="65a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用法:可观察的(源，覆盖？，选项？)</p><p id="7ec6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可观察注释也可以作为一个函数来调用，以使整个对象立即可观察。源对象将被克隆，所有成员都将成为可观察的，类似于makeAutoObservable所做的。同样，可以提供覆盖映射来指定特定成员的注释。查看上面的代码块中的示例。</p><p id="5a48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lr"> 3。使用动作</em>更新状态</strong></p><p id="02f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用法:action <em class="lr">(注释)|| </em> action(fn) || action(name，fn)</p><p id="7959" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有应用程序都有操作。动作是修改状态的任何一段代码。原则上，动作总是响应事件而发生。例如，一个按钮被点击，一些输入被改变，一个WebSocket消息到达，等等。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/3834d9103f9179b8328cdbd163a09338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*BcVXIidiUY4DreOc3xEMYA.png"/></div></figure><p id="7fd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lr"> 4。用计算机导出信息</em> </strong></p><p id="32ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用法:computed <em class="lr">(注释)|| </em> computed(选项)<em class="lr">(注释)|| </em> computed(fn，选项？)</p><p id="d725" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">计算值可用于从其他可观测值中获得信息。它们缓慢地进行计算，缓存它们的输出，并且只有在底层的某个可观察值发生变化时才重新计算。如果它们没有被任何东西观察到，它们就会完全中止。</p><p id="07a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从概念上讲，它们与电子表格中的公式非常相似，不可小觑。它们有助于减少您必须存储的状态数量，并且是高度优化的。尽可能使用它们。</p><p id="4d87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">计算值可以通过用Computed注释JavaScript <a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" rel="noopener ugc nofollow" target="_blank"> getters </a>来创建。使用makeObservable将getter声明为computed。或者@computed如果您希望所有getters都自动声明为computed，您可以使用makeAutoObservable、Observable或extendObservable。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/300c7e25c44177564ca9c3800a589ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Ycl67oRFN_tjKHo0KfCAg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">The above example nicely demonstrates the benefits of a computed value, it acts as a caching point.</figcaption></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="5c52" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated">R <strong class="jx io"> <em class="in"> eact积分</em> </strong></p></blockquote><p id="8d6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用法:</p><p id="65c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从“mobx-react-lite”//或“mobx-react”导入{ observer }。</p><p id="44b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">const my component = observer(props = &gt; ReactElement)</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/e5f7eb6590e8b9fdb242a3e4a247efea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_tAwJ09Ao2pGKKUc7xIDw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">or you can use useObserver Hook from mobx-react</figcaption></figure><p id="6ba0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">observer HoC自动为React组件订阅渲染过程中使用的任何可观察对象。因此，当相关的可观测量发生变化时，组件将自动重新呈现。它还确保组件在没有相关更改时不会重新呈现。因此，组件可访问但未实际读取的可观察对象不会导致重新呈现。</p><p id="3f20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在实践中，这使得MobX应用程序开箱即可得到很好的优化，它们通常不需要任何额外的代码来防止过度渲染。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="92f9" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated"><strong class="jx io"><em class="in">React打字稿App中的用法</em> </strong></p></blockquote><p id="5e13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面你已经看到了我们的App.tsx，提到了，为什么我们用了observer。我们还需要整个应用程序中状态管理的上下文。不要忘记在tsConfig.json文件的compilerOptions中添加-“allowSyntheticDefaultImports”:true、-。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/887d05e29204c828ab1dccb2b7fe3879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*_ff9f8U885C7QIAJvZN4_Q.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">index.ts</figcaption></figure><p id="0c82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要用商店包装我们的应用程序，以便在整个应用程序中使用商店的价值。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/7ee5a40153ac1816d44f5b0e8fdfb36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lelT85YnxcyBMZLI8a124g.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">StoreContex.ts</figcaption></figure><p id="7f18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从react导入createContext和useContext。CustomerList将来自我们的商店，这是我们使用mobX创建的。你也可以创建一个自定义挂钩来使用商店，如左图所示。</p><blockquote class="lo lp lq"><p id="085c" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated"><strong class="jx io">让我们创建自己的商店。首先从mobX导入必要的注释。然后创建一个可观察的商店。</strong></p></blockquote><p id="d8b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从“mobx”导入{ action，computed，makeObservable，observable }；</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/5f104ef5b56f3eb2642560ad14b7ab01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*VHhT7HoSfJs-GrQM9UHeIA.png"/></div></figure><p id="17c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">SortedCustomer是一个界面，根据我们从服务器上获得的数据创建。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="edb3" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">创建动作Crud操作</em> </strong></p></blockquote><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/8393db3d8fc8d7544056ca08eb45f54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*Avh6vjPjWpkVmDfVkPg7AQ.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Read the Data</figcaption></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7bfb97641702735acaf164f167d904d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*QbJ2wqWmapL7YXTOSQnTjg.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Create a new Data</figcaption></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/ba424dc0d18553fb13e50220345be289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHl5ZjbiaXQ4lzbjvwpt5w.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Delete a data</figcaption></figure><div class="mc md me mf gt ab cb"><figure class="mt jo mu mv mw mx my paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/24f7105fd797ef35d7e8997adc85b94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*mQI_rUTO_wph0j-FLvqu5g.png"/></div></figure><figure class="mt jo mz mv mw mx my paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/f6da93c5ab46307613d1f799b9add592.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*_ZL9Dq70BMc6iH7Ir3wyyg.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk na di nb nc">Derivation from the existing state with computed annotation. It is good for caching.</figcaption></figure></div><blockquote class="lo lp lq"><p id="81bc" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated">我们已经创建了我们的存储、操作和计算值。但是我们如何在组件中使用它们呢？</p></blockquote><p id="680e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从导入{ useStore }../context/StoreContex "；</p><p id="eff6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在反应组分中:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6a35f75ad21c7fd593303a7d721f2fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*QDk8zE_nU945-kIvRj7GxQ.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">usage of store</figcaption></figure><p id="9b69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">const customer list = use store()；然后我们可以使用像<strong class="jx io"><em class="lr">customer list . get customers()</em></strong>或<strong class="jx io"><em class="lr">customer list . asccustomernumbers</em></strong></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="76f2" class="jv jw lr jx b jy jz ka kb kc kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">优化React组件渲染:</em> </strong></p></blockquote><ol class=""><li id="f668" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">使用许多小组件:observer组件将跟踪它们使用的所有值，并在其中任何一个值发生变化时重新呈现。因此，组件越小，它们需要重新渲染的变化就越小。这意味着用户界面的更多部分有可能彼此独立地呈现。</li><li id="35b4" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在专用组件中呈现列表:在呈现大型集合时尤其如此。React在呈现大型集合方面是出了名的糟糕，因为协调器必须在每次集合更改时评估由集合产生的组件。因此，建议使用只映射集合并呈现它的组件，而不呈现其他内容。</li><li id="52a9" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">不要使用数组索引作为键:如果需要的话，为你的对象生成id。</li><li id="4b24" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">后期取消引用值:</li></ol><p id="0ef7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">较慢:<displayname name="{person.name}"/></p><p id="fac9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更快:<displayname person="{person}"/></p><p id="c73c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢耐心阅读。如果你给我反馈，我会很高兴。你可以从我的<a class="ae lz" href="https://github.com/emrekrt1655/UserInterface-MobX-Example" rel="noopener ugc nofollow" target="_blank">user interface-MobX-Example GitHub资源库</a>中找到该项目的代码。</p><p id="0963" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lr">更多内容请看</em> <a class="ae lz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lr">说白了就是</em> </strong> </a> <em class="lr">。报名参加我们的</em> <a class="ae lz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lr">免费每周简讯</em> </strong> </a> <em class="lr">。在我们的</em> <a class="ae lz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lr">社区</em> </strong> </a> <em class="lr">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>