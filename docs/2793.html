<html>
<head>
<title>How to Implement Infinite Scrolling with Intersection Observer API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用交集观察者API实现无限滚动</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-infinite-scrolling-with-intersection-observer-api-9f2bc9ad8662?source=collection_archive---------2-----------------------#2022-07-05">https://javascript.plainenglish.io/how-to-implement-infinite-scrolling-with-intersection-observer-api-9f2bc9ad8662?source=collection_archive---------2-----------------------#2022-07-05</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><div class=""><h2 id="0ffc" class="pw-subtitle-paragraph jl in io bd b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dk translated">通过使用交叉点观察器API实现更简单、性能更好的无限滚动</h2></div><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj kd"><img src="../Images/ec7859bc7a18a1f1ccf5d6eaf9eca223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GTrODcoq7f7vDgIb"/></div></div><figcaption class="kp kq gk gi gj kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@taypaigey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Taylor Wilcox</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2eaa" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">介绍</h1><p id="efa5" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">当我们的列表页面有很多数据，比如200个条目，但我们不能一次请求所有数据，因为请求会很慢，这将导致糟糕的体验。通常，我们会对数据进行分页，每个分页可能包含10项。我们将只加载前10个项目，当需要浏览更多的项目，接下来的10个项目将被加载。</p><p id="5730" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">在移动页面上，无限滚动是一种非常常见的分页方式。由于传统的分页模式，更多的数据只有在用户点击之后才被加载。无限滚动允许用户在滚动到页面底部时自动加载更多内容，无需任何额外操作，体验更好。</p><p id="9563" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">在本文中，我们将通过使用<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver" rel="noopener ugc nofollow" target="_blank">交叉点观察器API </a>实现无限滚动。</p><h1 id="a590" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">如何实施</h1><p id="124f" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">我们将分两步实现无限滚动:</p><ol class=""><li id="5a46" class="mn mo io lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">用JavaScript生成一个列表。</li><li id="f5c0" class="mn mo io lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">使用交叉点观察器API加载更多内容。</li></ol><h2 id="a634" class="nb kv io bd kw nc nd dn la ne nf dp le lv ng nh lg lz ni nj li md nk nl lk nm bi translated">用JavaScript生成列表</h2><p id="ebf3" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">首先，我们生成一个空白列表页面，然后通过JavaScript的setTimeout模拟一个请求来加载数据，最后将数据呈现到页面上。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nn no l"/></div></figure><h2 id="a415" class="nb kv io bd kw nc nd dn la ne nf dp le lv ng nh lg lz ni nj li md nk nl lk nm bi translated">使用交叉点观察器API加载更多内容</h2><p id="7f3c" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">交叉点观察器API可以观察一个元素是否可见，所以当用它来完成无限滚动时，需要在列表底部添加一个元素。当元素可见时，加载更多内容。</p><p id="5074" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">在<code class="fe np nq nr ns b">ol</code>旁边添加一个<code class="fe np nq nr ns b">div</code>元素:</p><pre class="ke kf kg kh gu nt ns nu nv aw nw bi"><span id="0233" class="nb kv io ns b gz nx ny l nz oa">&lt;ol class="list"&gt;&lt;/ol&gt;<br/>&lt;div class="more"&gt;loading&lt;/div&gt;</span></pre><p id="11b8" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">然后使用交叉点观察器API观察元素，当元素可见时，加载接下来的10项:</p><pre class="ke kf kg kh gu nt ns nu nv aw nw bi"><span id="35f6" class="nb kv io ns b gz nx ny l nz oa">const intersectionObserver = new IntersectionObserver(entries =&gt; {<br/>  if (entries[0].intersectionRatio &lt;= 0) return;<br/>  // load more content;<br/>  loadItems(10);<br/>});<br/>// start observing<br/>intersectionObserver.observe(document.querySelector(".more"));</span></pre><p id="b0a3" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">用交叉点观察器API做无限滚动就是这么简单。不过这个实现会有一个小的体验问题。只有当用户看到<code class="fe np nq nr ns b">loading… </code>元素时，数据才会被加载。如果数据是在用户从页面底部再向前滚动一点时加载的，那就太好了。</p><p id="574c" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">我们可以通过添加一个占位符元素来优化它，让观察者提前执行。</p><pre class="ke kf kg kh gu nt ns nu nv aw nw bi"><span id="1be3" class="nb kv io ns b gz nx ny l nz oa">&lt;ol class="list"&gt;&lt;/ol&gt;<br/>&lt;div class="more"&gt;<br/>  &lt;p class="virtual"&gt;&lt;/p&gt;  // and a placeholder element<br/>  loading ...<br/>&lt;/div&gt;</span></pre><p id="c2ae" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">添加一些样式以确保占位符元素不会影响列表的显示:</p><pre class="ke kf kg kh gu nt ns nu nv aw nw bi"><span id="a12d" class="nb kv io ns b gz nx ny l nz oa">.virtual {<br/>  position: absolute;<br/>  height: 200px;<br/>  top: -200px;<br/>  width: 100%;<br/>  pointer-event:none;<br/>}</span></pre><p id="8030" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">您可以通过CodePen上的以下示例来体验它:</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="ob no l"/></div></figure><h1 id="2b10" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">结论</h1><p id="b01c" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">无限滚动也可以通过监听滚动事件来实现，但是我们必须不断计算滚动位置。而使用交集观察者API，只需要提供一个回调函数，当目标元素进入视区时，就会自动执行，不仅简单而且性能更好。</p><p id="8675" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated"><em class="oc">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="oc">plain English . io</em></strong></a><em class="oc">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ip"> <em class="oc">免费周报</em> </strong> </a> <em class="oc">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="oc">Twitter</em></strong></a><em class="oc">和</em><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="oc">LinkedIn</em></strong></a><em class="oc">。查看我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ip"> <em class="oc">社区不和谐</em> </strong> </a> <em class="oc">加入我们的</em> <a class="ae kt" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ip"> <em class="oc">人才集体</em> </strong> </a> <em class="oc">。</em></p></div></div>    
</body>
</html>