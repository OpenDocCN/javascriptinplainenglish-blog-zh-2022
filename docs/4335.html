<html>
<head>
<title>Easy and Custom Angular-RxJS State Management Under 50 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">50行代码下的简单定制Angular-RxJS状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/easy-and-custom-angular-rxjs-state-management-under-50-lines-of-code-a2e7188da926?source=collection_archive---------1-----------------------#2022-11-22">https://javascript.plainenglish.io/easy-and-custom-angular-rxjs-state-management-under-50-lines-of-code-a2e7188da926?source=collection_archive---------1-----------------------#2022-11-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/7f2fe9e0f98f082b5965e8d4109bfbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqFRPzTVNROw0U5pmX0Jew.jpeg"/></div></div></figure><p id="dcdf" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">前端应用程序中的状态管理总是一个可怕的话题。”<em class="kx">对NGRX </em>的恐惧“是真实存在的(😅)，至少对我来说是这样。所以我尽量远离它，除非在我的工作场所需要它。但是，在其核心，状态管理是一个强大的概念，可以帮助您编写健壮、可维护、可读和高质量的代码。一旦我掌握了这个概念，我就不会回头了。现在我所有的个人项目都使用状态管理，虽然不是用NGRX。我遵循一个非常简单和轻量级的实现，对我的大脑来说很容易，我希望对你也是如此！所以，让我们开始吧。</p><h2 id="8aec" class="ky kz ir bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">步骤1:陈述主题</h2><p id="8032" class="pw-post-body-paragraph jz ka ir kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ik bi translated">你知道RxJS给你三种题材——<code class="fe lw lx ly lz b">Subject, BehaviorSubject</code>，和<code class="fe lw lx ly lz b">AsyncSubject</code>。为了开发我自己的状态管理解决方案，我需要从BehaviorSubject中获取更多信息。</p><p id="ed94" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">进入<strong class="kb is">状态服从</strong>。</p><p id="b486" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">基本上，StateSubject是一个扩展的BehaviorSubject，它拥有一个初始值，可以被重置为初始值，并且可以通过深度相等操作来检查它的可观察流。</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="ab17" class="mi kz ir lz b be mj mk l ml mm">import { isEqual } from 'radash'<br/>import { BehaviorSubject, distinctUntilChanged, Observable } from 'rxjs'<br/><br/>/**<br/> * An extended BehaviorSubject that can be reset to its initial value.<br/> * The stream of change is checked for deep equality so that only when <br/> * the value has trully changed, the stream will emit.<br/> * <br/> * This util is also available as a npm package: <br/> * https://www.npmjs.com/package/rxjs-state-subject<br/> * @author Touhid Rahman &lt;touhidrahman1987@gmail.com&gt;<br/> */<br/>export class StateSubject&lt;T&gt; extends BehaviorSubject&lt;T&gt; {<br/>    private initialValue: T<br/><br/>    constructor(value: T) {<br/>        super(value)<br/>        this.initialValue = value<br/>    }<br/><br/>    get value$(): Observable&lt;T&gt; {<br/>        return super.asObservable().pipe(<br/>            distinctUntilChanged((a, b) =&gt; isEqual(a, b))<br/>        )<br/>    }<br/><br/>    update(value: T): void {<br/>        this.next(value)<br/>    }<br/><br/>    reset(): void {<br/>        this.next(this.initialValue)<br/>    }<br/>}</span></pre><p id="a809" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">StateSubject的用途主要是在值没有发生本质变化时限制不必要的发出。例如，您可能有一个带有布尔值的BehaviorSubject。稍后，您用相同的值更新它两次。该流将发出两次。</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="4397" class="mi kz ir lz b be mj mk l ml mm">const loading = new BehaviorSubject&lt;boolean&gt;(false)<br/><br/>loading<br/>    .asObservable()<br/>    .subscribe({ next: (val) =&gt; console.log(val) })<br/><br/>// update<br/>loading.next(true)<br/>loading.next(true)<br/><br/>// output (timeline)<br/>// -false-----true-----true----</span></pre><p id="2d37" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">另一方面，如果使用StateSubject，它将发出一次，因为第二次文本值没有改变。</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="ebda" class="mi kz ir lz b be mj mk l ml mm">const loading = new StateSubject&lt;boolean&gt;(false)<br/><br/>loading<br/>    .value$<br/>    .subscribe({ next: (val) =&gt; console.log(val) })<br/><br/>// update<br/>loading.next(true)<br/>loading.next(true)<br/><br/>// output (timeline)<br/>// -false-----true-------------</span></pre><h2 id="5e63" class="ky kz ir bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">第二步:储存</h2><p id="e5d1" class="pw-post-body-paragraph jz ka ir kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ik bi translated">好的，我们花了大约15行在StateSubject类上。接下来是带<strong class="kb is">店</strong>级的~35。</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="4b76" class="mi kz ir lz b be mj mk l ml mm">import { isEqual } from 'radash'<br/>import { distinctUntilChanged, filter, map, Observable, share, Subject, takeUntil } from 'rxjs'<br/>import { StateSubject } from './state-subject'<br/><br/>export class Store&lt;T extends Object&gt; {<br/>    private unsubscriber: Subject&lt;void&gt;<br/>    private state: StateSubject&lt;T&gt;<br/><br/>    constructor(value: T, unsubscriber: Subject&lt;void&gt;) {<br/>        this.state = new StateSubject(value)<br/>        this.unsubscriber = unsubscriber<br/>    }<br/><br/>    setState(value: Partial&lt;T&gt;): void {<br/>        this.state.next({ ...this.state.value, ...value })<br/>    }<br/><br/>    getState(): T {<br/>        return this.state.value<br/>    }<br/><br/>    select&lt;K extends keyof T&gt;(key: K): Observable&lt;T[K]&gt; {<br/>        return this.state.value$.pipe(<br/>            map((state) =&gt; state[key]),<br/>            distinctUntilChanged((a, b) =&gt; isEqual(a, b)),<br/>            share(),<br/>            takeUntil(this.unsubscriber),<br/>        )<br/>    }<br/><br/>    selectAll(): Observable&lt;T&gt; {<br/>        return this.state.value$.pipe(<br/>            share(), <br/>            takeUntil(this.unsubscriber)<br/>        )<br/>    }<br/><br/>    reset(): void {<br/>        this.state.reset()<br/>    }<br/>}</span></pre><p id="a5a2" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">为了初始化store类，我们需要一个起始值和一个终止Store的退订器<code class="fe lw lx ly lz b">Subject</code>。商店的其他方法:</p><ul class=""><li id="bb4e" class="mn mo ir kb b kc kd kg kh kk mp ko mq ks mr kw ms mt mu mv bi translated"><strong class="kb is"> setState </strong>:用输入值覆盖状态。</li><li id="acb8" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is"> getState </strong>:获取当前状态的静态值。有时它会非常方便。</li><li id="7795" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is">选择</strong>:你可能熟悉其他状态管理库中的术语<code class="fe lw lx ly lz b">select</code>。它选取状态的一部分作为可观测值。</li><li id="237c" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is">选择全部</strong>:当需要整个状态为可观察时。</li><li id="34bb" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is">复位</strong>:将整个状态复位到初始值。</li></ul><h2 id="b810" class="ky kz ir bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">步骤3:用法:MovieListStateService</h2><p id="5d02" class="pw-post-body-paragraph jz ka ir kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ik bi translated">我们已经完成了管理应用程序状态所需的类。在这个示例场景中，我们正在编写一个具有搜索和分页功能的电影列表页面。首先，我们需要弄清楚组件的状态需要什么值:</p><ul class=""><li id="fc0a" class="mn mo ir kb b kc kd kg kh kk mp ko mq ks mr kw ms mt mu mv bi translated"><strong class="kb is">加载</strong>:显示一个微调按钮或进度条。</li><li id="89f5" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is">页</strong>:当前页码。</li><li id="4eb3" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is">大小</strong>:每页的结果数。</li><li id="322d" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is">搜索词</strong>:按名称搜索电影。</li><li id="5ba7" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is">年份</strong>:过滤特定年份以后上映的电影。</li><li id="9bcb" class="mn mo ir kb b kc mw kg mx kk my ko mz ks na kw ms mt mu mv bi translated"><strong class="kb is">电影</strong>:最后是API/数据库返回的电影列表。</li></ul><p id="122c" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">其次，我们需要为整个状态得出一个合理的初始值。开始的时候，不会有电影，搜索栏也是空的。所以我们可以这样声明我们的商店:</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="794b" class="mi kz ir lz b be mj mk l ml mm">store = new Store&lt;{<br/>    loading: boolean<br/>    movies: Movie[]<br/>    page: number<br/>    size: number<br/>    year: number<br/>    search: string<br/>}&gt;(<br/>    {<br/>        loading: false,<br/>        movies: [],<br/>        page: 0,<br/>        size: 10,<br/>        year: new Date().getFullYear(),<br/>        search: '',<br/>    },<br/>    this.unsubscriber, // 1<br/>)</span></pre><p id="e836" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">注意(1)，我们需要一个退订主题，它将在组件被销毁时完成。这将确保不会发生内存泄漏。我们可以将它挂在<code class="fe lw lx ly lz b">ngOnDestroy</code>挂钩上，轻松制作一个:</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="b040" class="mi kz ir lz b be mj mk l ml mm">private unsubscriber = new Subject&lt;void&gt;()<br/><br/>ngOnDestroy() {<br/>    this.unsubscriber.next()<br/>    this.unsubscriber.complete()<br/>}</span></pre><p id="16ed" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">现在，我们需要一种机制，无论何时搜索、页码、页面大小或年份值发生变化，都可以获取电影:</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="cd88" class="mi kz ir lz b be mj mk l ml mm">combineLatest({<br/>    search: this.store.select('search'),<br/>    page: this.store.select('page'),<br/>    size: this.store.select('size'),<br/>    year: this.store.select('year'),<br/>})<br/>.pipe(<br/>    debounceTime(300), // 2<br/>    tap(() =&gt; this.store.setState({ loading: true })),<br/>    switchMap(({ search, page, size, year }) =&gt; {<br/>        return this.movieApi.find({ search, page, size, year })<br/>    }),<br/>    takeUntil(this.unsubscriber),<br/>)<br/>.subscribe({<br/>    next: (res) =&gt; {<br/>        this.store.setState({ <br/>            movies: res.data, <br/>            loading: false <br/>        })<br/>    },<br/>})</span></pre><p id="a124" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">注意(2):有些时候参数更新得非常快——比如用户在分页栏上单击next太快。这就是为什么我们使用<code class="fe lw lx ly lz b">debounceTime()</code> RxJS操作符来丢弃间歇值，以便后端不会被过于频繁地调用。</p><p id="89f8" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">我们可以考虑另一个功能—每当搜索词更新时，页码应该重置为1:</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="b888" class="mi kz ir lz b be mj mk l ml mm">private onSearchTermChange(): void {<br/>    this.store.select('search').pipe(<br/>        distinctUntilChange(),<br/>        takeUntil(this.unsubscriber),<br/>    ).subscribe({<br/>        next: () =&gt; this.store.setState({ page: 1 })<br/>    })<br/>}</span></pre><p id="0b95" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">请注意，即使在编写模板之前，您也在定义业务逻辑。以这种方式隔离业务逻辑给了您对可读性和可测试性的巨大控制。现在大多数代码都是单元可测试的，不需要进行e2e测试来以编程方式点击一个按钮并测试一个特性。如果业务逻辑正常工作，表示层也是如此。</p><p id="afc4" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">这里是<code class="fe lw lx ly lz b">MovieListStateService</code>的完整代码。因为它将在一个组件中提供，所以我们不在<code class="fe lw lx ly lz b">@Injectable</code>装饰器中使用<code class="fe lw lx ly lz b">providedIn: 'root'</code>。</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="4357" class="mi kz ir lz b be mj mk l ml mm">import { Injectable, OnDestroy } from '@angular/core'<br/>import { Movie} from '@core/interfaces'<br/>import { Store } from '@core/utils/store'<br/>import { combineLatest, debounceTime, Subject, switchMap, takeUntil, tap } from 'rxjs'<br/>import { MovieApiService } from '../services/movie-api.service'<br/><br/>@Injectable()<br/>export class MovieListStateService implements OnDestroy {<br/>    private unsubscriber: Subject&lt;void&gt; = new Subject&lt;void&gt;()<br/><br/>    store = new Store&lt;{<br/>        loading: boolean<br/>        movies: Movie[]<br/>        page: number<br/>        size: number<br/>        year: number<br/>        search: string<br/>    }&gt;(<br/>        {<br/>            loading: false,<br/>            movies: [],<br/>            page: 0,<br/>            size: 10,<br/>            year: new Date().getFullYear(),<br/>            search: '',<br/>        },<br/>        this.unsubscriber,<br/>    )<br/><br/>    constructor(private movieApi: MovieApiService) {<br/>        this.init()<br/>        this.onSearchTermChange()<br/>    }<br/><br/>    ngOnDestroy(): void {<br/>        this.unsubscriber.next()<br/>        this.unsubscriber.complete()<br/>    }<br/><br/>    private init(): void {<br/>        combineLatest({<br/>            search: this.store.select('search'),<br/>            page: this.store.select('page'),<br/>            size: this.store.select('size'),<br/>            year: this.store.select('year'),<br/>        })<br/>        .pipe(<br/>            debounceTime(300),<br/>            tap(() =&gt; this.store.setState({ loading: true })),<br/>            switchMap(({ search, page, size, year }) =&gt; {<br/>                return this.movieApi.find({ search, page, size, year })<br/>            }),<br/>            takeUntil(this.unsubscriber),<br/>        )<br/>        .subscribe({<br/>            next: (res) =&gt; {<br/>                this.store.setState({ <br/>                    movies: res.data, <br/>                    loading: false <br/>                })<br/>            },<br/>        })<br/>    }<br/><br/>    private onSearchTermChange(): void {<br/>        // when search term changes, reset page to 1<br/>        this.store.select('search').pipe(<br/>            distinctUntilChange(),<br/>            takeUntil(this.unsubscriber),<br/>        ).subscribe({<br/>            next: () =&gt; this.store.setState({ page: 1 })<br/>        })<br/>    }<br/>}</span></pre><h2 id="6652" class="ky kz ir bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">步骤4:将它插入组件</h2><p id="cdfc" class="pw-post-body-paragraph jz ka ir kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ik bi translated">现在让我们将我们的<code class="fe lw lx ly lz b">MovieListStateService</code>提供给页面组件。</p><pre class="ma mb mc md gu me lz mf bn mg mh bi"><span id="b5d5" class="mi kz ir lz b be mj mk l ml mm">@Component({<br/>    standalone: true,<br/>    imports: [CommonModule, RouterModule, //...],<br/>    template: `<br/>    &lt;app-loading-spinner *ngIf="loading$ | async"&gt;&lt;/app-loading-spinner&gt;<br/><br/>    &lt;input type="text" [(ngModel)]="search"&gt;<br/>    &lt;button (click)="doSearch()"&gt;Search&lt;/button&gt;<br/><br/>    &lt;div <br/>        *ngIf="movies$ | async as movies" <br/>    &gt;<br/>        &lt;app-movie-card<br/>            *ngFor="let movie of movies"<br/>            [movie]="movie"<br/>        &gt;&lt;/app-movie-card&gt;<br/>    &lt;/div&gt;<br/><br/>    &lt;button (click)="changePage(-1)"&gt;Prev&lt;/button&gt;<br/>    &lt;button (click)="changePage(1)"&gt;Next&lt;/button&gt;<br/>    `,<br/>    providers: [MovieListStateService],<br/>})<br/>export class HomePageComponent {<br/>    search = ''<br/><br/>    constructor(<br/>        private movieListState: MovieListStateService,<br/>        private activatedRoute: ActivatedRoute,<br/>    ) {<br/>        const page = +this.activatedRoute.snapshot.queryParams.page<br/>        // load first page<br/>        this.movieListState.store.setState({ page: page ?? 1 })<br/>    }<br/><br/>    get movies$(): Observable&lt;Movie[]&gt; {<br/>        return this.movieListState.store.select('movies')<br/>    }<br/><br/>    get loading$(): Observable&lt;boolean&gt; {<br/>        return this.movieListState.store.select('loading')<br/>    }<br/><br/>    changePage(dir: 1 | -1): void {<br/>        const next = this.movieListState.store.getState().page + dir<br/>        this.movieListState.store.setState({ page: next })<br/>    }<br/><br/>    doSearch(): void {<br/>        this.movieListState.store.setState({ search: this.search })<br/>    }<br/>}</span></pre><p id="6607" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">我们从状态中选择<code class="fe lw lx ly lz b">movies</code>数组和<code class="fe lw lx ly lz b">loading</code>值，在模板中查看。然而，我们更新页面，搜索等。通过事件用新值设置状态。就是这样！我们的组件除了演示之外不做任何复杂的工作。Angular本来就是这样的。</p><p id="a381" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">你一直编码错误！😄</p><h2 id="4a41" class="ky kz ir bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">结论</h2><p id="3110" class="pw-post-body-paragraph jz ka ir kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ik bi translated">使用状态管理解决方案为您的代码库带来了许多可能性。您的业务逻辑与世隔绝，这是一个巨大的好处。您可以在多个组件中重用一个状态。最重要的是，你的应用程序会感觉流畅。</p><p id="eef6" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">让团队的新成员使用基本解决方案更容易。当每个人都准备好了，你就可以很容易地移植到NGRX或任何其他高级状态管理库，因为它们的工作原理是一样的。</p><p id="896b" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">感谢您的阅读。关注我更多类似这样有趣的有角度的文章。</p><ul class=""><li id="5c69" class="mn mo ir kb b kc kd kg kh kk mp ko mq ks mr kw ms mt mu mv bi translated"><em class="kx"> *如果你不想在每个项目中写StateSubject和Store类，那么好消息！我已经在一个名为</em><a class="ae nb" href="https://www.npmjs.com/package/rxjs-state-subject" rel="noopener ugc nofollow" target="_blank"><em class="kx">rxjs-state-subject</em></a><em class="kx">的npm包中发布了这些类。它使用RxJS v7.5+，和</em><a class="ae nb" href="https://www.npmjs.com/package/radash" rel="noopener ugc nofollow" target="_blank"><em class="kx">radash</em></a>v 9.3+(lodash的现代替代)。</li></ul><p id="6879" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><em class="kx">更多内容看</em> <a class="ae nb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb is"> <em class="kx">说白了就是</em> </strong> </a> <em class="kx">。报名参加我们的</em> <a class="ae nb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb is"> <em class="kx">免费周报</em> </strong> </a> <em class="kx">。关注我们</em> <a class="ae nb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kb is"> <em class="kx">推特</em> </strong> </a>，<a class="ae nb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kb is"><em class="kx">LinkedIn</em></strong></a><em class="kx">，</em><a class="ae nb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kb is"><em class="kx">YouTube</em></strong></a><em class="kx">，</em><a class="ae nb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><em class="kx">不和</em>  </a> <em class="kx">。对增长黑客感兴趣？检查出</em> <a class="ae nb" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb is"> <em class="kx">电路</em> </strong> </a> <em class="kx">。</em></p></div></div>    
</body>
</html>