<html>
<head>
<title>React: Suspense with Lazy &amp; Axios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:与懒惰和Axios的悬念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/suspense-with-lazy-axios-react-471a43113e4b?source=collection_archive---------3-----------------------#2022-09-30">https://javascript.plainenglish.io/suspense-with-lazy-axios-react-471a43113e4b?source=collection_archive---------3-----------------------#2022-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d4a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">等等，悬疑不仅仅是代码分裂</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/252b2c9626e47f04bef1bc5fcfced644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKMsE9RS0snqQtm06ysGdQ.jpeg"/></div></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="4683" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于React的未来，有一件事是肯定的:React团队希望让API变得更容易、更简单🦋</p><p id="cfb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">react 16 . x版本自发布以来就在业界掀起了一场风暴。在此次发布的新特性中，最受欢迎的是<em class="lb">挂钩</em>、<em class="lb">懒人</em>、<em class="lb">加载</em>、、<em class="lb">缓存</em>...等等。</p><blockquote class="lc ld le"><p id="5f4f" class="jk jl lb jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated">v16:异步模式</p><p id="1f5a" class="jk jl lb jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated">v17:并发模式</p><p id="da08" class="jk jl lb jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated">v18:并发渲染(并发)</p></blockquote><p id="d29b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并发不是一个特性，它是一个新的幕后机制，使React能够同时准备多个版本的UI。</p><p id="c7c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现并发后，下一个方向可能会扩展可以使用并发的场景(<em class="lb">悬疑</em>、<em class="lb"> React.lazy </em>、<em class="lb"> useTransition、</em> <em class="lb">流媒体服务器渲染</em>……)</p><p id="0f75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近，我试着用<a class="ae li" href="https://17.reactjs.org/docs/concurrent-mode-suspense.html#approach-3-render-as-you-fetch-using-suspense" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"/></a>和<a class="ae li" href="https://axios-http.com/docs/intro" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Axios</strong></a><strong class="jm io"/>获取一些数据，并用<a class="ae li" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> React.lazy </strong> </a>渲染组件，创作了一些例子，我想在本文中分享一下。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="f4e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们都知道这一点，如果一个组件的代码还没有加载，那么呈现它显然是“不安全”的。所以，从狭义上来说，代码准备好的组件才算“安全”，包括同步组件和异步组件(<em class="lb">你不知道什么时候能做好，就当是承诺:)</em>)。</p><p id="9302" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么悬念和这有什么关系呢？悬念字面意思是<em class="lb">未决定</em>，它让你的组件<strong class="jm io">等待⏰</strong>对某事才能“放心地”渲染。</p><p id="d80f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我看来，这就像<em class="lb"> try…catch </em>，决定UI是否“安全”，在加载时显示一些回退，并在完成时显示“安全”的组件，因为用户需要看到类似<em class="lb">微调器</em>或<em class="lb">加载状态</em>的东西，所以他们知道他们可以期待数据被显示。</p><pre class="kj kk kl km gt lj lk ll lm aw ln bi"><span id="efed" class="lo lp in lk b gy lq lr l ls lt">try { <br/>    // things are not ready yet<br/>} catch { <br/>    // immediately enter the catch block, show fallback <br/>}</span></pre><p id="18d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是也许你会想，为了显示一些加载状态，我们可以像平常一样进行条件渲染👇</p><pre class="kj kk kl km gt lj lk ll lm aw ln bi"><span id="072f" class="lo lp in lk b gy lq lr l ls lt">function <strong class="lk io">ParentComponent</strong>() {<br/>  const [data, setData] = useState(null);<br/>  useEffect(() =&gt; {    <br/>    <strong class="lk io">fetchData</strong>().then(res =&gt; setData(res));  <br/>    }, []);</span><span id="694c" class="lo lp in lk b gy lu lr l ls lt">  if (data === null) {<br/>     return <!-- -->&lt;<strong class="lk io">LoadingSpinner1</strong> /&gt;<!-- -->;<br/>   }</span><span id="262c" class="lo lp in lk b gy lu lr l ls lt">return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;{<strong class="lk io">data</strong>.<strong class="lk io">heading</strong>}&lt;/h1&gt;<br/>      &lt;<strong class="lk io">ChildComponent</strong> /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>function <strong class="lk io">ChildComponent</strong>() {<br/>  const [otherData, setOtherData] = useState(null);<br/>  useEffect(() =&gt; {    <br/>    <strong class="lk io">fetchOtherData</strong>().then(res =&gt; setOtherData(res));  <br/>  }, []);</span><span id="be95" class="lo lp in lk b gy lu lr l ls lt">  return (<br/>    &lt;&gt;{otherData === null? <!-- -->&lt;<strong class="lk io">LoadingSpinner2</strong> /&gt; <!-- -->: otherData}&lt;/&gt;<br/>  );<br/>}</span></pre><p id="14bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">效果很好，那为什么现在要用悬疑呢？以上代码实际上是这样说的:</p><ol class=""><li id="cb6c" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh ma mb mc md bi translated">开始获取<strong class="jm io">数据</strong></li><li id="ea56" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">显示LoadingSpinner1，然后显示标题，然后等待…</li><li id="2617" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">完成提取数据</li><li id="47d5" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">开始获取<strong class="jm io">其他数据</strong></li><li id="204f" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">显示LoadingSpinner2，然后等待…</li><li id="3343" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">完成提取其他数据</li><li id="6299" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">完成的</li></ol><p id="9c22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个<em class="lb">瀑布</em>效应，我们必须等待一些请求数据的代码，直到它被加载，然后我们才能继续。为了改善这一点，<strong class="jm io">我们不应该等待响应，</strong>这意味着我们应该同时获取代码和数据，处理异步操作，承诺。</p><p id="b4ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">👉悬念是为了解决异步操作，而不仅仅是显示组件的内容。</p><p id="e924" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，悬念分为两个功能:异步加载<strong class="jm io">代码(</strong> <a class="ae li" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb">代码拆分</em> </a>)和异步加载<strong class="jm io">数据。</strong></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="f5d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来看第一个例子:用<em class="lb">悬念</em>和<em class="lb">懒惰</em> API(动态导入组件)异步加载代码。</p><p id="a62d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">📌<a class="ae li" href="https://beta.reactjs.org/apis/react/lazy" rel="noopener ugc nofollow" target="_blank"> lazy </a> API是react给<em class="lb">lazy load</em><em class="lb">components</em>(<strong class="jm io"><em class="lb">dynamically</em></strong>import)提供的一个方法，它带一个参数并将其包装为React组件。</p><pre class="kj kk kl km gt lj lk ll lm aw ln bi"><span id="d984" class="lo lp in lk b gy lq lr l ls lt">Promise&lt;() =&gt; {default: <strong class="lk io">ReactComponent</strong>}&gt;</span></pre><p id="0713" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ReactComponent可以是任何类型的组件，</p><pre class="kj kk kl km gt lj lk ll lm aw ln bi"><span id="2f2d" class="lo lp in lk b gy lq lr l ls lt">const <strong class="lk io">Lazy</strong> = <strong class="lk io">lazy</strong>(() =&gt; import("./<strong class="lk io">LazyComponent</strong>")) <br/>&lt;Suspense <strong class="lk io">fallback</strong>={&lt;div&gt;Loading ...&lt;/div&gt;}&gt; <br/>  &lt;<strong class="lk io">Lazy</strong>/&gt; <br/>&lt;/Suspense&gt;</span></pre><p id="6e46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于<strong class="jm io"> Lazy </strong>经常从远程位置加载，React直到加载完成才知道如何渲染组件，所以看起来<em class="lb">动态导入</em>类似于<strong class="jm io">承诺</strong>，它也有三种状态(<em class="lb">待定</em>、<em class="lb">已解决</em>、<em class="lb">已拒绝)。</em>如果是待定，那么此时什么都不显示，会造成不好的用户体验。⚡️现在，悬念来了，它表明在加载过程中应该显示什么内容。当加载完成时，悬念将切换回<strong class="jm io">惰性</strong>组件的内容。</p><p id="1232" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在这里创建了一个沙盒<a class="ae li" href="https://codesandbox.io/s/react-router-useeffect-suspense-lazy-t4tthn?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"><em class="lb"/></a>，你可以从导航栏导航到“懒惰”并尝试一下。👐</p><p id="4e7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，用户可以<strong class="jm io">在输入字段中键入</strong>，并通过勾选“<em class="lb">显示预览</em>”复选框<strong class="jm io">预览</strong>文本。在这里，预览的代码不会被加载，直到复选框被选中，如果预览还没有被加载，在它的位置会显示“<em class="lb">正在加载…”</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/df335ca06013c93b44837b8492285f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCnsplj1PusVj2apSM0MvA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">component initial render</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/87125ebfd66681f0314de7b4294c5138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IpmMBbze2F4jUnJZio6FQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">render fallback with suspense after checkbox is checked by user</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/0d4d55a50176923d990647547a423e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOi7WY-whtboGe6LfMad6Q.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">loading complete, render preview</figcaption></figure><p id="8a8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的代码中，我在<strong class="jm io">预览</strong>组件上使用<em class="lb"> setTimeout </em>来“伪造”一个长加载时间(2秒)，以便查看加载回退是如何呈现的。👇</p><pre class="kj kk kl km gt lj lk ll lm aw ln bi"><span id="cd1e" class="lo lp in lk b gy lq lr l ls lt">import { useState, <strong class="lk io">Suspense</strong>, <strong class="lk io">lazy</strong> } from "react";<br/>import InputField from "./components/InputField";</span><span id="fbe0" class="lo lp in lk b gy lu lr l ls lt"><em class="lb">// </em>🔴<em class="lb"> dynamic import and fake "delay" Preview <br/></em>const <strong class="lk io">Preview</strong> = <strong class="lk io">lazy</strong>(async() =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>       setTimeout(() =&gt; resolve(), 2000)<br/>  })<br/>   .then(() =&gt; <strong class="lk io">import</strong>("./components/Preview"))<br/>   .catch((e) =&gt; console.log(e))<br/>});</span><span id="4b3f" class="lo lp in lk b gy lu lr l ls lt">const SuspenseLazy = () =&gt; {<br/>    const [inputValue, setInputValue] = useState("Say hello to");<br/>    const [showPreview, setShowPreview] = useState(false);<br/>    return (<br/>     &lt;&gt;<br/>       &lt;p&gt;Suspense-Lazy&lt;/p&gt;<br/>       &lt;<strong class="lk io">InputField</strong><br/>          inputValue={inputValue}<br/>          showPreview={showPreview}<br/>          setShowPreview={setShowPreview}<br/>          setInputValue={setInputValue}/&gt;</span><span id="48bf" class="lo lp in lk b gy lu lr l ls lt">        {showPreview &amp;&amp; (<br/>          &lt;Suspense <strong class="lk io">fallback</strong>={&lt;div&gt;Loading ...&lt;/div&gt;}&gt;<br/>            &lt;<strong class="lk io">Preview</strong> inputValue={inputValue} /&gt;<br/>          &lt;/Suspense&gt;<br/>        )}<br/>    &lt;/&gt;<br/> )};<br/>export default SuspenseLazy;</span><span id="8cd1" class="lo lp in lk b gy lu lr l ls lt">export default function <strong class="lk io">InputField</strong>(props) {<br/>    const {showPreview, inputValue, setShowPreview, setInputValue} = props;<br/>    return (<br/>       &lt;&gt;<br/>         &lt;input<br/>            value={inputValue}<br/>            type="text"<br/>            onChange={(e) =&gt; setInputValue(e.target.value)} /&gt;<br/>         &lt;input<br/>            type="checkbox"<br/>            onChange={() =&gt; setShowPreview(!showPreview)}<br/>            checked={showPreview} /&gt;</span><span id="30f6" class="lo lp in lk b gy lu lr l ls lt">         &lt;label&gt;<br/>           {!showPreview ? "Show Preview" : "Hide Preview"}<br/>         &lt;/label&gt;<br/>      &lt;/&gt;<br/> )}</span></pre><p id="4a20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，代码加载就是一个异步的过程，整个加载状态不需要被开发人员控制。</p><p id="4109" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然悬疑经常和懒一起用，但是悬疑<strong class="jm io">只有</strong>可以和懒一起用吗？懒一定要配合悬疑吗？好吧，比方说，悬疑是加载数据的一个<strong class="jm io">标准</strong>，懒是在这个标准下实现的一个<strong class="jm io">方法</strong>。📌这就意味着<strong class="jm io">懒不能毫无悬念的使用</strong>。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="a159" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来看第二个例子:用<em class="lb">悬念</em> <em class="lb">和</em><a class="ae li" href="https://axios-http.com/docs/intro" rel="noopener ugc nofollow" target="_blank"><em class="lb">Axios</em></a><em class="lb">异步加载<strong class="jm io">数据</strong>。</em></p><p id="2919" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上所述，悬念是为了解决异步操作，而不仅仅是显示组件的内容，下面这个例子是使用<em class="lb"> axios </em>和<em class="lb">悬念</em>来实现异步加载数据。</p><blockquote class="lc ld le"><p id="538f" class="jk jl lb jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated">悬念要求代码被挂起，即<strong class="jm io">抛出</strong>一个可捕捉的承诺异常，在承诺结束后渲染组件。</p></blockquote><p id="4a9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">*如果我们把没有承诺的组件用悬念包裹起来，有可能什么都没有发生，因为悬念需要孩子的承诺被触发，然后返回结果，渲染孩子。</p><p id="47f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着如果我们想使用悬念，我们需要对它的子组件做些什么。</p><ul class=""><li id="088c" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh mq mb mc md bi translated">children组件中必须有一个<strong class="jm io">承诺</strong>。</li><li id="e34f" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh mq mb mc md bi translated">儿童组件的承诺应<strong class="jm io">被置于</strong>待定状态以供暂停。</li><li id="fcbb" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh mq mb mc md bi translated">承诺成功后，悬疑会重新渲染儿童组件。</li><li id="988e" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh mq mb mc md bi translated">重新呈现的子组件将不再执行承诺，因为数据已被缓存。</li><li id="9abb" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh mq mb mc md bi translated">完成上述所有步骤后，您可以在组件上暂停显示回退。</li></ul></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="d167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为<em class="lb"> Axios支持Promise API，</em>我们现在就从它开始。</p><p id="e187" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">*在同一个<a class="ae li" href="https://codesandbox.io/s/react-router-useeffect-suspense-lazy-t4tthn?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">沙箱</a>中，您可以从导航栏导航到“获取”并试用。👐</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/3a11c514e707323e6bcf122fe2fa2585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppLisvlOit3VOB52OuYQwQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">render fallback</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/aedbc0e57c28bcdf648ad64ba6c47f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voZmAazV8L7DK_0U1-hH9w.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">cat images are complete</figcaption></figure><p id="a055" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我将有一个需要获取一些猫的组件，让我们首先创建axios获取请求:</p><pre class="kj kk kl km gt lj lk ll lm aw ln bi"><span id="2a87" class="lo lp in lk b gy lq lr l ls lt">import axios from "axios";</span><span id="a332" class="lo lp in lk b gy lu lr l ls lt">export async function <strong class="lk io">fetchCats</strong>() {<br/>  return axios<br/>    .get("https://...")<br/>    .then((res) =&gt; res.data)<br/>    .catch((err) =&gt; console.log(err));<br/> }</span></pre><p id="e00a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上所述，如果我们的组件正在加载或失败，我们需要抛出一个承诺异常，然后在承诺成功解决时返回响应。</p><p id="d0b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，<em class="lb"> fetchCats </em>将是一个承诺，现在我们需要"<strong class="jm io">包装</strong>它，"<strong class="jm io">检查</strong>承诺的状态然后"<strong class="jm io">返回"</strong>一个与悬念兼容的响应对象并导出它:</p><pre class="kj kk kl km gt lj lk ll lm aw ln bi"><span id="807e" class="lo lp in lk b gy lq lr l ls lt">export default function <strong class="lk io">fetchAllCatsData</strong>() {<br/>   const catsPromise = <strong class="lk io">fetchCats</strong>;<br/>      return {<br/>         <strong class="lk io">data</strong>: <strong class="lk io">wrapPromise</strong>(catsPromise)<br/>  }}</span><span id="2d35" class="lo lp in lk b gy lu lr l ls lt">export function <strong class="lk io">wrapPromise</strong>(promise) {<br/>   let status = "pending";<br/>   let result;<br/>   let suspend = promise().then((res) =&gt; {<br/>      status = "success";<br/>      result = res;<br/>     }, (err) =&gt; {<br/>      status = "error";<br/>      result = err;<br/>  });<br/>    return {<br/>      👉<strong class="lk io">read</strong>() {<br/>         <em class="lb">// let suspense catch the error and return the fallback<br/>        </em>if (status === "pending") {<br/>            throw suspend;<br/>       } else if (status === "error") {<br/>            throw result;<br/>       } <br/>         // <em class="lb">change fallback to content when value is returned<br/>         </em>else if (status === "success") {<br/>            return result;<br/>}}}}</span></pre><p id="9587" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码将检查承诺的状态，然后返回一个名为<strong class="jm io"> read </strong>的函数，稍后我们将在组件中用<em class="lb">fetchalcatsdata()</em>调用该函数。</p><p id="8b52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">❗️注意到，必须使用<strong class="jm io"> read </strong>方法，否则会抛出一个错误。</p><p id="c2e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的组件代码:</p><pre class="kj kk kl km gt lj lk ll lm aw ln bi"><span id="e349" class="lo lp in lk b gy lq lr l ls lt">import { Suspense, lazy } from "react";<br/>import <strong class="lk io">fetchAllCatsData</strong> from "./fetchAllCatsData";</span><span id="84d4" class="lo lp in lk b gy lu lr l ls lt">const <strong class="lk io">resource</strong> = fetchAllCatsData(); // 👉use<strong class="lk io"> </strong>data</span><span id="71ea" class="lo lp in lk b gy lu lr l ls lt">const <strong class="lk io">LazyCatsUsingSuspense</strong> = lazy(async() =&gt; {<br/>    ... // same as first example<br/>    .then(() =&gt; import("./components/<strong class="lk io">CatsUsingSuspense</strong>"))<br/> });</span><span id="ed4c" class="lo lp in lk b gy lu lr l ls lt">const SuspenseFetch = () =&gt; {<br/>  return (<br/>    &lt;Suspense <strong class="lk io">fallback</strong>={&lt;h1&gt;Loading cats...&lt;/h1&gt;}&gt;<br/>      &lt;LazyCatsUsingSuspense fetchedResource={<strong class="lk io">resource.data</strong>} /&gt;<br/>    &lt;/Suspense&gt;<br/>)};</span><span id="0d90" class="lo lp in lk b gy lu lr l ls lt">function <strong class="lk io">CatsUsingSuspense</strong>({fetchedResource}){<br/>  return (<br/>    &lt;&gt;<br/>      {fetchedResource.<strong class="lk io">read</strong>().map(({ url, id, width, height }) =&gt; {<br/>         return (<br/>            &lt;div key={id}&gt;<br/>              &lt;img src={url} alt={id} width={150} height={100} /&gt;<br/>         );<br/>      })}<br/>&lt;/&gt;)}</span></pre><p id="ab76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！🍄你会看到“加载猫…”在图像出现之前，*数据将被缓存，要再次查看加载状态，刷新页面。</p><p id="9437" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总结，使用悬念的部分:</p><ol class=""><li id="5efd" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh ma mb mc md bi translated"><strong class="jm io">进口</strong>悬念</li><li id="fed3" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated"><strong class="jm io">包装</strong>带悬念获取数据的组件</li><li id="752d" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">直到该数据被解析，它将呈现<strong class="jm io">回退</strong></li><li id="cf37" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated"><strong class="jm io">渲染</strong>你的组件</li></ol><p id="4dd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，我还在学习，但是目前来说，我们可以尝试在某些情况下使用悬念，而不是<em class="lb"> useEffect </em>，这有时会让人头疼。☘️</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="eeed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你也对我的其他与React相关的文章感兴趣，这里有一些链接，谢谢你的时间🌹</p><div class="mt mu gp gr mv mw"><a href="https://xiaominzhu.medium.com/common-use-cases-of-react-hook-form-b7cf961a42f6" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">React-Hook-Form库|常见用例</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">因为绝对没有人喜欢创建和重建带有验证的复杂表单</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">xiaominzhu.medium.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener  ugc nofollow" target="_blank" href="/a-shopping-list-with-react-hook-usereducer-310a3b6578"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">用React Hook useReducer创建购物清单</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">带有useReducer React挂钩的购物清单——一个让useReducer更容易理解的小练习。</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener  ugc nofollow" target="_blank" href="/create-a-simple-react-custom-hook-fc733d7b977a"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">创建一个简单的React自定义挂钩</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">关于如何创建一个简单的React自定义钩子的教程</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nf l"><div class="nm l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener  ugc nofollow" target="_blank" href="/create-a-simple-express-server-node-js-for-react-application-e2b2bd0c7e93"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">为React应用程序创建一个简单的Express服务器(Node.js)</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">关于如何创建一个简单的Express服务器(Node.js)、将其连接到React应用程序以及解决错误的教程…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nf l"><div class="nn l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://xiaominzhu.medium.com/react-functional-components-using-refs-a5ad1d2817d4" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">使用引用对功能组件进行反应</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">forwardRef和useImperativeHandle的示例</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">xiaominzhu.medium.com</p></div></div><div class="nf l"><div class="no l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://medium.com/geekculture/update-parent-state-from-child-component-with-react-context-api-a56cf3742428" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">用React上下文将状态从子节点更新到父节点</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">— React Context提供了一种通过组件树传递数据的方法，而不必在…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="np l nh ni nj nf nk ks mw"/></div></div></a></div><p id="dd24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lb">更多内容请看</em><a class="ae li" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lb">plain English . io</em></strong></a><em class="lb">。报名参加我们的</em> <a class="ae li" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="lb">免费周报</em> </strong> </a> <em class="lb">。关注我们关于</em><a class="ae li" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lb">Twitter</em></strong></a><a class="ae li" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lb">LinkedIn</em></strong></a><strong class="jm io"><em class="lb"/></strong><a class="ae li" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lb">YouTube</em></strong></a><strong class="jm io"><em class="lb">，以及</em></strong><em class="lb"/><a class="ae li" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lb">不和</em> </strong> </a>  <em class="lb">对成长黑客感兴趣？检查</em> <a class="ae li" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="lb">电路</em> </strong> </a> <strong class="jm io"> <em class="lb">。</em> </strong></p></div></div>    
</body>
</html>