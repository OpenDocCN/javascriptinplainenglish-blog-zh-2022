<html>
<head>
<title>useImmutableRefValue to Help You Code Better in TypeScript + React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ImmutableRefValue帮助您在TypeScript + React中更好地编码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useimmutablerefvalue-to-help-you-code-better-in-typescript-react-d3767d20d79d?source=collection_archive---------8-----------------------#2022-11-29">https://javascript.plainenglish.io/useimmutablerefvalue-to-help-you-code-better-in-typescript-react-d3767d20d79d?source=collection_archive---------8-----------------------#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9383" class="pw-subtitle-paragraph jr ip iq bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">另一个抽象层次<code class="fe jn jo jp jq b">useRef</code></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/cc7bef6e2ab8aca2324683b84dc2e8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XAt0XEtfDm3YJCVT"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@marinajune?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">marina</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="21c0" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在React中，你可能经常使用<code class="fe jn jo jp jq b">useRef</code>，它允许你引用渲染不需要的值。这很重要，例如，在一个组件中创建一个唯一的<code class="fe jn jo jp jq b">VideoPlayer</code>。</p><pre class="kk kl km kn gt lw jq lx bn ly lz bi"><span id="2528" class="ma mb iq jq b be mc md l me mf">function Component() {<br/>  const playerRef = useRef(new VideoPlayer());<br/>  // ...</span></pre><p id="4b8c" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是请记住，<code class="fe jn jo jp jq b">useRef</code>保存初始的<code class="fe jn jo jp jq b">ref</code>值一次，并在下次渲染时忽略它。</p><p id="490e" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对于上面的例子，组件初始化时调用<code class="fe jn jo jp jq b">new VideoPlayer()</code>的结果会被存储在<code class="fe jn jo jp jq b">ref</code>中，这没问题，但是注意下次渲染时<code class="fe jn jo jp jq b">new VideoPlayer()</code>还是会被再次调用，只是其调用的结果不再被<code class="fe jn jo jp jq b">useRef</code>接收。这意味着这是无效的浪费，如果您正在创建昂贵的对象，这很可能会影响您的应用程序的性能。</p><p id="565a" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">值得一提的是，<code class="fe jn jo jp jq b">useState</code>钩子也有这种情况，但是它可以接收一个<em class="mg">初始化器</em>函数，并且在下一次渲染中不再调用它，就像这样:<code class="fe jn jo jp jq b">const [player] = useState(() = &gt; new VideoPlayer());</code>，但是这里<code class="fe jn jo jp jq b">player</code>不是渲染所需要的值，所以还是用<code class="fe jn jo jp jq b">useRef</code>比较好。</p><p id="0be7" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所以为了处理这种情况，我们可能需要在每个组件渲染中做出判断:</p><pre class="kk kl km kn gt lw jq lx bn ly lz bi"><span id="f3fc" class="ma mb iq jq b be mc md l me mf">function Component() {<br/>  const playerRef = useRef(null);<br/>  if (playerRef.current === null) {<br/>    playerRef.current = new VideoPlayer();<br/>  }<br/>  // ...</span></pre><p id="c6ec" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">看起来不错，这个组件将只调用<code class="fe jn jo jp jq b">new VideoPlayer()</code>一次，并生成一个惟一的实例存储在<code class="fe jn jo jp jq b">playerRef</code>中。但是如果您正在使用TypeScript，那么在访问<code class="fe jn jo jp jq b">playerRef</code>时您将需要一个非空检查:</p><pre class="kk kl km kn gt lw jq lx bn ly lz bi"><span id="25bf" class="ma mb iq jq b be mc md l me mf">function Component() {<br/>  const playerRef = useRef&lt;VideoPlayer | null&gt;(null);<br/>  if (playerRef.current === null) {<br/>    playerRef.current = new VideoPlayer();<br/>  }<br/><br/>  const onClick = () =&gt; {<br/>    // Error: Object is possibly 'null'.<br/>    playerRef.current.play();<br/>  };<br/>}</span></pre><p id="d04a" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您当然可以简单地通过使用可选的链接操作符<code class="fe jn jo jp jq b">?.</code>来解决这个问题，就像这样:<code class="fe jn jo jp jq b">playerRef.current?.play();</code>。如果是一个或者两个也没问题，但是如果<code class="fe jn jo jp jq b">player</code>有很多可访问的属性和方法，这就需要你把它添加到你使用的每一个地方，这是多余的。</p><p id="74d5" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所以我们可以创建一个简单的函数来规避这个问题:</p><pre class="kk kl km kn gt lw jq lx bn ly lz bi"><span id="b3b7" class="ma mb iq jq b be mc md l me mf">const getPlayer = () =&gt; {<br/>  if (!playerRef.current) {<br/>    playerRef.current = new VideoPlayer();<br/>  }<br/><br/>  return playerRef.current;<br/>};<br/><br/><br/>getPlayer().play();</span></pre><p id="c45d" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">它工作得很好，但是如果您的React应用程序中有很多地方需要这样处理，那么最好抽象成一个自定义钩子:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7d70" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">使用它可以在类似的逻辑中获得唯一的不可变参考值:</p><pre class="kk kl km kn gt lw jq lx bn ly lz bi"><span id="e37d" class="ma mb iq jq b be mc md l me mf">function Component() {<br/>  const player = useImmutableRefValue(() =&gt; new VideoPlayer());<br/><br/>  const onClick = () =&gt; {<br/>    player.play();<br/>  };<br/>}</span></pre><p id="2121" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">玩得开心！感谢阅读，下次再见，干杯🍻</p><p id="6217" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="mg">不是中等会员？</em> <a class="ae kz" href="https://medium.com/@hellostephanie2022/membership" rel="noopener"> <em class="mg">支持我在这里成为一个</em> </a> <em class="mg">。</em></p><p id="46d0" class="pw-post-body-paragraph la lb iq lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="mg">更多内容请看</em><a class="ae kz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mg">plain English . io</em></strong></a><em class="mg">。报名参加我们的</em> <a class="ae kz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="mg">免费周报</em> </strong> </a> <em class="mg">。关注我们关于</em><a class="ae kz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mg">Twitter</em></strong></a><a class="ae kz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mg">LinkedIn</em></strong></a><em class="mg"/><a class="ae kz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mg">YouTube</em></strong></a><em class="mg"/><a class="ae kz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mg">不和</em> </strong> </a> <em class="mg">。对增长黑客感兴趣？检查</em> <a class="ae kz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="mg">电路</em> </strong> </a> <em class="mg">。</em></p></div></div>    
</body>
</html>