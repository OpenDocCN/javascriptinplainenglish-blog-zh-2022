<html>
<head>
<title>React 18 Quick Guide &amp; Core Concepts Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18快速指南和核心概念解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-18-quick-guide-core-concepts-explained-7be7ecac9dee?source=collection_archive---------4-----------------------#2022-04-15">https://javascript.plainenglish.io/react-18-quick-guide-core-concepts-explained-7be7ecac9dee?source=collection_archive---------4-----------------------#2022-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd3a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React 18概述。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e6a7be284871690fe2557faf4b3744f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Go0qm0BRtW-NBDSvbAzesQ.jpeg"/></div></div></figure><p id="4c8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React 18为并发渲染API奠定了基础，未来的React特性将建立在这些API之上。此版本侧重于性能改进和更新渲染引擎。</p><h1 id="7511" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">如何升级到React 18</h1><ol class=""><li id="f4a7" class="mf mg iq kt b ku mh kx mi la mj le mk li ml lm mm mn mo mp bi translated">从npm或yarn安装React 18和React DOM</li></ol><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c145" class="mv lo iq mr b gy mw mx l my mz"><br/> npm install react react-dom</span></pre><p id="0b72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.使用“createRoot”而不是“render”</p><p id="2777" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在index.js中，将“ReactDOM.render”更新为“ReactDOM.createRoot”以创建根，并使用root -呈现您的应用程序</p><p id="e456" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">反应17:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8bfa" class="mv lo iq mr b gy mw mx l my mz">import ReactDOM from ‘react-dom’;<br/>import App from ‘App’;</span><span id="c01e" class="mv lo iq mr b gy na mx l my mz">const container = document.getElementById(‘app’);</span><span id="dc05" class="mv lo iq mr b gy na mx l my mz">ReactDOM.render(&lt;App /&gt;, container);</span></pre><p id="ec85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">反应18:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1893" class="mv lo iq mr b gy mw mx l my mz">import ReactDOM from ‘react-dom’;<br/>import App from ‘App’;<br/>const container = document.getElementById(‘app’);</span><span id="ba82" class="mv lo iq mr b gy na mx l my mz">// create a root<br/>const root = ReactDOM.createRoot(container);</span><span id="71d8" class="mv lo iq mr b gy na mx l my mz">//render app to root<br/>root.render(&lt;App /&gt;);</span></pre><h1 id="1f91" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">核心概念:并发性</h1><p id="9cf1" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">为了理解并发性，让我们考虑一下来自React 18工作组讨论的Dan Abramov的这个例子。</p><p id="8f90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们需要给两个人打电话——爱丽丝和鲍勃。在非并发设置中，我们一次只能有一个呼叫——我们首先呼叫Alice，结束呼叫，然后呼叫Bob。当通话时间很短时，这是没问题的，但是如果与Alice的通话有很长的等待时间(例如等待)，这可能是一个时间接收器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/344ad80a50235eb8e53be40a2f682ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0HqfTDmJ51gf_uddgAQ6w.png"/></div></div></figure><p id="d7d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在并发设置中，我们可以呼叫Alice，一旦我们被挂起，我们可以呼叫Bob。这并不意味着我们在同时与两个人通话，这意味着我们可以同时进行两个或更多的通话，并决定哪个通话更重要。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/efb6e3fa14767fa9243b79972ed984a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2yiyqrOmLwC6sPYUgMIJg.png"/></div></div></figure><p id="b0fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，在具有并发渲染的React 18中，React可以中断、暂停、恢复或放弃渲染。这允许React快速响应用户交互，即使它正在执行繁重的渲染任务。在React 18之前，渲染是一个单一的、不间断的同步事务，一旦渲染开始，就不能被中断。</p><p id="3261" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并发是React渲染机制的一个基础更新。并发允许对中断渲染做出反应。React 18引入了并发渲染的基础和新功能，如悬念、流服务器渲染和过渡由并发渲染支持。</p><h1 id="703e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">新功能:自动配料</h1><p id="9481" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">React 18具有自动配料功能。为了理解批处理，让我们考虑一下来自<a class="ae ne" href="https://github.com/reactwg/react-18/discussions/46#discussioncomment-846694" rel="noopener ugc nofollow" target="_blank"> same React工作组讨论</a>的杂货店购物的例子。假设你正在为晚餐做意大利面。如果你要优化你的购物之旅，你应该创建一个你需要购买的所有原料的清单，去一趟杂货店，在一次旅行中得到你所有的原料。这是批处理。如果没有配料，你会开始烹饪，发现你需要一种配料，去杂货店买配料，回来继续烹饪，发现你需要另一种配料，去杂货店把自己逼疯。</p><p id="1016" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在React中，当您调用<code class="fe ng nh ni mr b">setState</code>时，批处理有助于减少状态改变时发生的重新渲染次数。以前，在事件处理程序中对批处理状态更新作出反应，例如:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4981" class="mv lo iq mr b gy mw mx l my mz">const handleClick = () =&gt; {<br/>setCounter();<br/>setActive();<br/>setValue();<br/>}<br/><br/>//re-rendered once at the end.</span></pre><p id="fd0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，在事件处理程序之外发生的状态更新不会被批处理。例如，如果你有一个承诺或者打了一个网络电话，状态更新就不会被批量处理。例如:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="22e6" class="mv lo iq mr b gy mw mx l my mz">fetch('/network').then( () =&gt; {<br/>setCounter(); //re-rendered 1 times<br/>setActive();  //re-rendered 2 times<br/>setValue();   //re-rendered 3 times<br/>});<br/><br/>//Total 3 re-renders</span></pre><p id="ab94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，这不是表演。React 18引入了自动批处理，允许所有状态更新——甚至在承诺、设置超时和事件回调中进行批处理。这大大减少了React必须在后台完成的工作。React将在重新渲染之前等待微任务完成。</p><p id="8d09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React中的自动批处理是现成可用的，但是如果您想退出，可以使用<code class="fe ng nh ni mr b">flushSync</code>。</p><h1 id="91a1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">新功能:过渡</h1><p id="6e79" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">转换可用于标记不需要紧急资源进行更新的UI更新。例如:当在typeahead字段中键入时，会发生两件事——一个闪烁的光标显示正在键入的内容的视觉反馈，以及在后台搜索键入的数据的搜索功能。</p><p id="f9f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">向用户展示视觉反馈很重要，因此也很紧迫。搜索不是很紧急，因此可以标记为非紧急。这些非紧急更新称为转换。通过将非紧急的UI更新标记为“过渡”，React将知道哪些更新应该优先，从而更容易优化渲染并消除陈旧的渲染。</p><p id="a12c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ng nh ni mr b">startTransition</code>可以将更新标记为非紧急。下面是一个示例，说明当用过渡标记时，typeahead组件会是什么样子:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="401b" class="mv lo iq mr b gy mw mx l my mz">import { startTransition } from 'react';<br/><br/>// Urgent: Show what was typed<br/>setInputValue(input);<br/><br/>// Mark any non-urgent state updates inside as transitions<br/>startTransition(() =&gt; {<br/>  // Transition: Show the results<br/>  setSearchQuery(input);<br/>});</span></pre><p id="6e7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">它与去抖或setTimeout有何不同？</strong></p><ol class=""><li id="5877" class="mf mg iq kt b ku kv kx ky la nj le nk li nl lm mm mn mo mp bi translated">与setTimeout不同，startTransition会立即执行。</li><li id="16d3" class="mf mg iq kt b ku nm kx nn la no le np li nq lm mm mn mo mp bi translated">setTimeout有保证的延迟，而startTransition的延迟取决于设备的速度和其他紧急渲染。</li><li id="0c18" class="mf mg iq kt b ku nm kx nn la no le np li nq lm mm mn mo mp bi translated">与setTimeout不同，startTransition更新可以被中断，并且不会冻结页面。</li><li id="8fff" class="mf mg iq kt b ku nm kx nn la no le np li nq lm mm mn mo mp bi translated">当用startTransition标记时，React可以为您跟踪挂起状态。</li></ol><h1 id="2243" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">新功能:服务器上的悬念</h1><p id="8c58" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">React 18介绍了:</p><ol class=""><li id="3b6c" class="mf mg iq kt b ku kv kx ky la nj le nk li nl lm mm mn mo mp bi translated">暂停服务器上的代码分割</li><li id="5e3e" class="mf mg iq kt b ku nm kx nn la no le np li nq lm mm mn mo mp bi translated">服务器上的流式渲染</li></ol><p id="2e88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">客户端渲染vs服务器渲染</strong></p><p id="1f3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在客户端呈现的应用程序中，您从服务器加载页面的HTML以及运行页面并使其具有交互性所需的所有JavaScript。但是，如果您的javascript包很大，或者您的连接速度很慢，这个过程可能需要很长时间，用户可能会等待页面变得具有交互性或看到有意义的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/889749449a77a474fa70952f2596035f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2yRc27rfemzCUIbFUdy5A.jpeg"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Illustration of client rendering flow. Source: React Conf 2021 <strong class="bd nv">Streaming Server Rendering with Suspense</strong> by Shaundai Person <a class="ae ne" href="https://www.youtube.com/watch?v=pj5N-Khihgc&amp;list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&amp;index=4" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=pj5N-Khihgc</a></figcaption></figure><p id="a9f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了优化用户体验，避免用户坐在空白屏幕上，我们可以使用服务器渲染。服务器呈现是一种在服务器上呈现React组件的HTML输出并从服务器发送HTML的技术。这允许用户在JS包加载时和应用变得可交互之前查看一些UI。关于客户端与服务器渲染的详细概述，<a class="ae ne" href="https://www.youtube.com/watch?v=pj5N-Khihgc" rel="noopener ugc nofollow" target="_blank">查看Shaundai Person的React Conf 2021 talk </a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/649d5431c80332415662520775003e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WElL6GnBsGtkmkAhRWTLCg.jpeg"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Illustration of server rendering flow. Source: React Conf 2021 <strong class="bd nv">Streaming Server Rendering with Suspense</strong> by Shaundai Person <a class="ae ne" href="https://www.youtube.com/watch?v=pj5N-Khihgc&amp;list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&amp;index=4" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=pj5N-Khihgc</a></figcaption></figure><p id="9b93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务器渲染进一步增强了用户加载页面的体验，减少了交互时间。</p><p id="593b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果，你的大部分应用都很快，除了一部分？可能这部分加载数据比较慢，也可能需要下载很多JS才能进行交互。</p><p id="933a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在React 18之前，这部分可以成为app的瓶颈，增加渲染组件的时间。一个缓慢的组件会降低整个页面的速度。这是因为服务器渲染要么全有，要么全无——您不能告诉React延迟加载速度较慢的组件，也不能告诉React发送其他组件的HTML。</p><p id="cdc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React 18在服务器上增加了对悬念的支持。在悬念的帮助下，你可以在悬念组件中包装应用程序的缓慢部分，告诉React延迟缓慢组件的加载。这也可以用来指定在加载时可以显示的加载状态。</p><p id="e650" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在React 18中，一个缓慢的组件不一定会降低整个应用程序的渲染速度。有了悬念，您可以告诉React首先发送其他组件的HTML以及占位符的HTML，就像加载微调器一样。然后，当慢速组件准备好并获取其数据时，服务器呈现器将在同一个流中弹出其HTML。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/48444d12675ce37b83de29314dc4cdc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVJk6oLflx5DrNtBNDvanw.jpeg"/></div></div></figure><p id="ed2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这种方式，用户可以尽早看到页面的框架，并随着更多HTML片段的到来，看到它逐渐显示更多的内容。所有这些都发生在页面上加载任何JS或React之前，从而显著改善了用户体验和用户感知的延迟。</p><h1 id="839b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">严格模式</h1><p id="787a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">React 18中的严格模式将模拟安装、卸载和重新安装具有先前状态的组件。这为将来的可重用状态奠定了基础，react可以通过在卸载之前使用相同的组件状态重新安装树来立即安装上一个屏幕。严格模式将确保组件能够承受多次安装和卸载的影响。</p><p id="d8f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">来源:</p><ol class=""><li id="1c3d" class="mf mg iq kt b ku kv kx ky la nj le nk li nl lm mm mn mo mp bi translated"><a class="ae ne" href="https://github.com/reactjs/rfcs/blob/react-18/text/0000-react-18.md" rel="noopener ugc nofollow" target="_blank"> React RFC </a></li><li id="12d2" class="mf mg iq kt b ku nm kx nn la no le np li nq lm mm mn mo mp bi translated"><a class="ae ne" href="https://dev.to/shrutikapoor08/what-s-new-in-react-18-1713" rel="noopener ugc nofollow" target="_blank">我之前的React 18帖子</a></li><li id="1edc" class="mf mg iq kt b ku nm kx nn la no le np li nq lm mm mn mo mp bi translated"><a class="ae ne" href="https://reactjs.org/blog/2022/03/29/react-v18.html" rel="noopener ugc nofollow" target="_blank"> React V18博客</a></li><li id="27ad" class="mf mg iq kt b ku nm kx nn la no le np li nq lm mm mn mo mp bi translated"><a class="ae ne" href="https://www.youtube.com/watch?v=ytudH8je5ko" rel="noopener ugc nofollow" target="_blank"> React Conf 2021 —面向应用开发者的React</a></li><li id="da5a" class="mf mg iq kt b ku nm kx nn la no le np li nq lm mm mn mo mp bi translated"><a class="ae ne" href="https://www.youtube.com/watch?v=pj5N-Khihgc" rel="noopener ugc nofollow" target="_blank">React Conf 2021——带悬念的流媒体服务器渲染</a></li></ol></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="7986" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你喜欢这篇文章，给它一个❤️，这样其他人也可以找到它。</p><ul class=""><li id="8daf" class="mf mg iq kt b ku kv kx ky la nj le nk li nl lm od mn mo mp bi translated">更多提示，<a class="ae ne" href="http://twitter.com/shrutikapoor08" rel="noopener ugc nofollow" target="_blank">在Twitter上保持联系</a></li><li id="2fb9" class="mf mg iq kt b ku nm kx nn la no le np li nq lm od mn mo mp bi translated">想要这样的文章直接出现在你的收件箱里吗？</li></ul><p id="d912" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="oe">更多内容看</em> <a class="ae ne" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oe">说白了。报名参加我们的</em><strong class="kt ir"><em class="oe"/></strong><a class="ae ne" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oe">免费周报</em> </strong> </a> <em class="oe">。关注我们</em><a class="ae ne" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oe">Twitter</em></strong></a><em class="oe">和</em><a class="ae ne" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oe">LinkedIn</em></strong></a><em class="oe">。加入我们的</em><strong class="kt ir"><em class="oe"/></strong><a class="ae ne" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oe">社区不和谐</em> </strong> </a> <em class="oe">。</em></strong></a></p></div></div>    
</body>
</html>