<html>
<head>
<title>React useEffect Hook is Not Broken; Your Code Is</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React useEffect挂钩未断开；你的代码是</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reactjs-useeffect-is-not-broken-your-code-is-5d0a80b24b53?source=collection_archive---------0-----------------------#2022-06-11">https://javascript.plainenglish.io/reactjs-useeffect-is-not-broken-your-code-is-5d0a80b24b53?source=collection_archive---------0-----------------------#2022-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6fd3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">useEffect钩子在严格模式下有一个“double-call”bug，但不是bug；这是一个特点。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/976023e8db7270cf9ff813d700c79056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*620T61qpye-BuunB"/></div></div></figure><p id="7a58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您正在使用React 18，并且已经转移到功能组件。然后，您意识到没有办法控制组件的生命周期。不能在函数中覆盖函数！</p><p id="e5b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你去谷歌找到了<code class="fe ln lo lp lq b"><strong class="kt ir">useEffect</strong></code>钩子，并意识到当你使用一个空的依赖数组时，<code class="fe ln lo lp lq b">useEffect</code>钩子的行为就像是<code class="fe ln lo lp lq b"><strong class="kt ir">componentDidMount</strong></code>方法。但是只有一个问题:<code class="fe ln lo lp lq b">useEffect</code>调用你的函数两次！</p><h1 id="54d7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">那么问题出在哪里？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/bdff8a7190a749a133a4eca8cd787c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*paBHUnPN_3v418Bl"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Simple counter for the number of times useEffect is called</figcaption></figure><p id="b787" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的TSX代码创建了一个名为<code class="fe ln lo lp lq b">count</code>的状态变量，并且只有在组件挂载后才会生效。效果将<code class="fe ln lo lp lq b">count</code>增加<code class="fe ln lo lp lq b">1</code>。当我们呈现该组件时，您会看到以下页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/b06b70c45e88e3368f4e4e5016a2f8f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*l6XuSWVKtWFAnfE2"/></div></figure><p id="36f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">useEffect</code>被调用两次。一个简单但糟糕的解决方案是删除严格模式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/a41a986208baffffbbdb293ac095d9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pWeDJ-FlhXJG0ZN6"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Strict mode is commented out</figcaption></figure><p id="7736" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">禁用严格模式是一个糟糕的解决方案，因为它帮助您调试组件的生命周期。对你有什么帮助？继续读。</p><h1 id="3c8f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">清理您的组件</h1><p id="1b75" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated"><code class="fe ln lo lp lq b">useEffect</code>钩子被调用两次，因为React挂载、卸载、然后重新挂载组件，以捕捉组件生命周期中的常见错误。</p><p id="9387" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你的问题的根源是你没有清理你的组件！当React组件重新挂载时，应该有效地重置它:应该清除所有间隔，应该删除事件侦听器，应该重置状态变量。</p><p id="2f7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你传递给<code class="fe ln lo lp lq b">useEffect</code>的函数应该<code class="fe ln lo lp lq b">return</code>清理函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/a600c80d80bbe444b62bdd45038c5377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rp7GXiWYm0rwxD9R"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Notice the <strong class="bd mu">return</strong> in the callback to useEffect</figcaption></figure><p id="5d36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，当您运行上面的代码时，我们看到<code class="fe ln lo lp lq b">count</code>只增加一次:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/b911da010a6a9b0353c2c54460b6c31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*t-nIqn3Uk4zBUrE5"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Use effect is only invoked 1 time</figcaption></figure><h1 id="5176" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">但是我不想清理我的组件！</h1><p id="bdb0" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">你应该这么做。让我们看看一些更有问题的代码。你有一个每秒钟递增一次的计时器。为此，您可以使用<code class="fe ln lo lp lq b">setInterval</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/475c9afcc0c0aeb2a80d9320052f1743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jJEh8I-kmc8NjG4h"/></div></div></figure><p id="05be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的组件重新安装，您会注意到时钟将以两倍的速度递增时间:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/374cc6a22c02e65b7b059370e0ccb171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/0*40diVnMnhXeqWjEn"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Notice how the timer skips every other number</figcaption></figure><p id="df80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样做的另一个副作用是，如果你卸载组件，隐藏它，或者使用<code class="fe ln lo lp lq b">react-router</code>导航离开页面，你的计时器将仍然运行。如你所知，浏览器中的JavaScript是单线程的。因此，这个计时器将占用宝贵的计算和浏览器资源。你的页面会变慢，用户体验会变差，Safari会给出这个警告:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/f2e4c8132858eecc29f90d77820a7eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/0*ECp6AGNLSPGuAiLl"/></div></figure><p id="5b1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这同样适用于事件侦听器。事件侦听器有自己的线程来侦听事件。但是如果你有一个事件监听器，回调在主JavaScript线程中运行，再次占用宝贵的资源。这会影响站点的响应能力，并可能为更重要的事件造成瓶颈。</p><p id="6086" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要忘记在使用完组件后清理它们，祝编码愉快！👍</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt ne"><a rel="noopener  ugc nofollow" target="_blank" href="/stop-using-for-loops-use-iterators-instead-javascript-62682c74427d"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">停止使用For循环，改用迭代器</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">For循环不再是JavaScript中迭代数组的最佳方式。相反，使用数组迭代器函数。这里…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nn l"><div class="no l np nq nr nn ns kp ne"/></div></div></a></div><div class="nt nu gp gr nv ne"><a href="https://medium.com/@thesoggywaffle/please-stop-writing-sh-t-javascript-ba8fd4e1cd9e" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">请停止编写Sh*t JavaScript</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">你做错了什么，以及如何弥补。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">medium.com</p></div></div><div class="nn l"><div class="nw l np nq nr nn ns kp ne"/></div></div></a></div><div class="nt nu gp gr nv ne"><a rel="noopener  ugc nofollow" target="_blank" href="/the-correct-way-to-use-ionicons-in-your-reactjs-project-3b65c97d5b1"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">在React项目中使用Ionicons的正确方法</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">HTML中的IonIcons很容易，但在React中却很难。尽管缺少文档，我还是弄明白了！</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nn l"><div class="nx l np nq nr nn ns kp ne"/></div></div></a></div><p id="126c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ny">更多内容看</em><a class="ae nz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny"/></strong><em class="ny">o</em></a><em class="ny">。报名参加我们的</em> <a class="ae nz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em><a class="ae nz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny">Twitter</em></strong></a><em class="ny">和</em><a class="ae nz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny">LinkedIn</em></strong></a><em class="ny">。查看我们的</em> <a class="ae nz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ny">社区不和谐</em> </strong> </a> <em class="ny">，加入我们的</em> <a class="ae nz" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ny">人才集体</em> </strong> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>