<html>
<head>
<title>Type of Scopes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的作用域类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/type-of-scopes-in-javascript-e717571721a2?source=collection_archive---------12-----------------------#2022-01-03">https://javascript.plainenglish.io/type-of-scopes-in-javascript-e717571721a2?source=collection_archive---------12-----------------------#2022-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/90135f84f30749961de8eef78e70d21a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SBFNjCA0Bq4854MObDCbQ.png"/></div></div></figure><p id="d33e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章是为那些试图更深入研究这种语言的JavaScript开发人员准备的。在开始阅读之前，了解以下主题将是有益的。</p><ul class=""><li id="1643" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/JavaScript_engine" rel="noopener ugc nofollow" target="_blank"> JavaScript引擎</a></li><li id="fde0" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated"><a class="ae lc" href="https://hellocode.dev/execution-context-in-javascript/" rel="noopener ugc nofollow" target="_blank">执行上下文(EC) </a></li><li id="8a18" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated"><a class="ae lc" href="https://www.javascripttutorial.net/javascript-call-stack/" rel="noopener ugc nofollow" target="_blank">调用堆栈</a></li><li id="de5f" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">一般范围和变量</li></ul><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/bc6cbf5f8932090727f5c844f546f440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-U_VH6jELWdQGkwnvXsL3g.png"/></div></div></figure><p id="94c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript代码在<strong class="jx io">执行上下文(EC)中运行。</strong>代码执行时，<strong class="jx io">执行上下文</strong>被推送到调用堆栈上。每个JavaScript程序都有一个<strong class="jx io">全局执行上下文</strong>,当它开始执行时就会被推送。每当遇到函数调用时，都会为该特定函数创建一个新的执行上下文，并将其推送到调用堆栈上。</p><p id="0430" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该图显示了执行下面代码的<strong class="jx io">行7 </strong>时调用栈的快照。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="65d5" class="ls lt in lo b gy lu lv l lw lx">1  var a0 = 0;<br/>2  function testFunc() {<br/>3      var a1 = 10;<br/>4      testFunc1();<br/>5      function testFunc1(){<br/>6          var a2 = 20;<br/><strong class="lo io">7          console.log(a0,a1,a2);</strong><br/>8      }<br/>9  }<br/>10 testFunc();<br/>11 console.lob(a0);</span></pre><p id="a69c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它在底部显示了<strong class="jx io">全局执行上下文(GEC) </strong>和它上面两个嵌套函数的执行上下文。</p><h1 id="724b" class="ly lt in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak">词汇环境</strong></h1><p id="0854" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">一个<strong class="jx io">词汇环境(LE) </strong>作为每个执行上下文的一部分被创建。它由该执行上下文的本地内存及其直接父上下文的词法环境组成。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/993c9f027e91fb0aa46a7d6cf1cd8f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvKeqi9ZfueC10KCQZoRYA.png"/></div></div></figure><p id="b4d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript代码的执行过程中，调用堆栈可能有几个上下堆叠的执行上下文，全局执行上下文(GEC)位于堆栈的底部。</p><blockquote class="na nb nc"><p id="9d0c" class="jv jw nd jx b jy jz ka kb kc kd ke kf ne kh ki kj nf kl km kn ng kp kq kr ks ig bi translated">最顶层<strong class="jx io">执行上下文</strong>的<strong class="jx io">词法环境</strong>引用了其<strong class="jx io">父</strong>的<strong class="jx io">EC</strong>(EC就在它的下面)。</p></blockquote><p id="ae78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这对于它下面的所有EC都是一样的，除了指向空值的GEC。这个词法环境链被称为<strong class="jx io">范围链</strong>。</p><h1 id="e757" class="ly lt in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak">瞄准镜的类型</strong></h1><p id="5c9b" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">执行上下文的词法环境或范围可能包含以下不同类型的范围。</p><p id="b905" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 1。全球:</strong>🌏</p><p id="7ac7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript文件的所有函数之外使用<code class="fe nh ni nj lo b">var</code>关键字声明的变量成为<strong class="jx io">全局作用域</strong>的一部分。它成为JavaScript作用域链的根。存储在这里的变量在文件的任何地方都可以访问。默认情况下，这是浏览器中的<code class="fe nh ni nj lo b">window</code>对象和NodeJS中的<code class="fe nh ni nj lo b">global</code>对象。</p><p id="7a03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以将变量添加到全局范围，如下所示:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="b24e" class="ls lt in lo b gy lu lv l lw lx">var a0 = 0;</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/4dc57ff092784dcc7ecf5d1d34febb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nN6DDSrMnNBOOsooDCpaqw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk">Status of Call Stack</figcaption></figure><p id="26a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。脚本:</strong>📜</p><p id="5d22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript文件的所有块和函数之外使用<code class="fe nh ni nj lo b">let</code>或<code class="fe nh ni nj lo b">const</code>关键字声明的变量成为<strong class="jx io">脚本范围</strong>的一部分。它类似于全局范围，但是没有任何声明为<code class="fe nh ni nj lo b">var</code>的变量。它出现在作用域链中的全局作用域之后。存储在这里的变量也可以在文件的任何地方访问。</p><p id="c211" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以将变量添加到全局范围，如下所示:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="abef" class="ls lt in lo b gy lu lv l lw lx">let b0 = 0;</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/07d193ceb8cedf355572e68a5e865cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GpEvNMNRHqV5JHlaRj_GA.png"/></div></div></figure><p id="f02e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。区块:</strong> 🧱</p><p id="0643" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript块<code class="fe nh ni nj lo b"><strong class="jx io">{}</strong></code>中使用<code class="fe nh ni nj lo b">let</code>或<code class="fe nh ni nj lo b">const</code>关键字声明的变量成为该<strong class="jx io">块范围</strong>的一部分。(注意:JavaScript引擎将块中使用<code class="fe nh ni nj lo b">var</code>关键字声明的任何变量移动到其父作用域(全局/函数/闭包))。块可以出现在JavaScript文件中的任何地方。它可以在函数内部或外部声明。它也可以嵌套在其他块中。因此，只要在代码中遇到它，它就会被添加到范围链中。存储在这里的变量只能在那个特定的块中访问。</p><p id="cbc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以将变量添加到块范围，如下所示:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="441c" class="ls lt in lo b gy lu lv l lw lx">{<br/>    var a1 = 10;<br/>    let b1 = 10;<br/>}</span></pre><p id="f085" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意<code class="fe nh ni nj lo b">a1</code>被移到了全局范围，即使它是在块中声明的。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/22e8f09d4a4539d95e03810e49c74e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wg8xaR1FiT57WkFqQGx0A.png"/></div></div></figure><p id="e024" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。本地(功能):</strong>🏡</p><p id="662f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数内部声明的变量成为其<strong class="jx io">局部函数作用域</strong>的一部分。使用任何变量类型(<code class="fe nh ni nj lo b">var/let/const</code>)声明的变量可以出现在这里。一旦该函数被推送到调用堆栈上，它就会被添加到该函数的执行上下文中。存储在这里的变量只能在那个函数中访问。</p><p id="7924" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以将变量添加到局部范围，如下所示:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="88ad" class="ls lt in lo b gy lu lv l lw lx">function testFunc(){<br/>    var a2 = 20;<br/>    let b2 = 20;<br/>}<br/>testFunc();</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/545ca2154b41ae308740f55b50d650d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1K8d_xjLCH1i0KULIeQfmQ.png"/></div></div></figure><p id="c2c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 5。关闭:</strong>📦</p><p id="e94e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当一个函数在另一个函数中定义时，存在于父函数局部环境中的变量成为新函数的<strong class="jx io">闭包</strong>。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/a59d21d0147ec2d7ef69c231d0a90e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ok1bjni-QjAoYMsBwecK9w.png"/></div></div></figure><p id="2dfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当父函数成为新函数的一部分时，父函数的局部环境中标记为<strong class="jx io">‘local’</strong>的变量现在标记为<strong class="jx io">‘closure’</strong>。</p><p id="35a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe nh ni nj lo b">var</code>、<code class="fe nh ni nj lo b">let</code>和<code class="fe nh ni nj lo b">const</code>声明的变量可以出现在这里。就在该函数的局部作用域被附加之前，它被附加到作用域链的顶端。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="6580" class="ls lt in lo b gy lu lv l lw lx">function testFunc() {<br/>    var a2 = 20;<br/>    let b2 = 20;<br/>    function testFunc1() {<br/>        var a3 = 30;<br/>        let b3 = 30;<br/>    }<br/>    testFunc1();<br/>}<br/>testFunc();</span></pre></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h1 id="a64c" class="ly lt in bd lz ma nw mc md me nx mg mh mi ny mk ml mm nz mo mp mq oa ms mt mu bi translated"><strong class="ak">形成作用域链:</strong></h1><p id="5d7e" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">默认情况下，全局范围被添加到<strong class="jx io">全局执行上下文</strong>的词法环境中。即使JavaScript文件完全为空，它也会被添加。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="f51d" class="ls lt in lo b gy lu lv l lw lx">1 var a0 = 0;</span></pre><p id="902a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑上面的代码。<code class="fe nh ni nj lo b">a0</code>被添加到全局范围，因为它是一个被全局声明的<code class="fe nh ni nj lo b">var</code>类型的变量。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/c5062b5524de94f134e9b74c621f5ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_-z1Nmr_78MH4E1EYjLkA.png"/></div></div></figure><p id="18b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">GEC的LE也可以包含脚本和块作用域。如果有任何全局声明的<code class="fe nh ni nj lo b">let</code>或<code class="fe nh ni nj lo b">const</code>变量，就会添加<strong class="jx io">脚本</strong>作用域，如下所示。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="7b13" class="ls lt in lo b gy lu lv l lw lx">1 var a0 = 0;<br/>2 let b0 = 0;<br/>3 const c0 = 0;</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/2d431ff376804a9041fd4939befbb4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RN9OxCDVz_ji-zHnSAFn9Q.png"/></div></div></figure><p id="e5a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果有任何块被全局声明，那么<strong class="jx io">块</strong>范围被添加到GEC。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="e7c5" class="ls lt in lo b gy lu lv l lw lx">1 var a0 = 0;<br/>2 let b0 = 0;<br/>3 const c0 = 0;<br/>4 {<br/>5    var a1 = 10;<br/>6    let b1 = 10;<br/>7    const c1 = 10;<br/>8 }<br/>9</span></pre><p id="d116" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只有在执行过程中遇到块范围时，才会将其添加到词法环境中。在上面的例子中，块范围是在执行第5到7行时添加的。一旦执行从该块中出来，它就会从作用域中移除。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/7f91dc0d5826631f6a69321073e2849d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJ7iE-f_nnt-VKu79wbraA.png"/></div></div></figure><p id="1553" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上图显示了执行<strong class="jx io">行3 </strong>、<strong class="jx io">行7 </strong>和<strong class="jx io">行9 </strong>时调用栈的快照。请注意，<code class="fe nh ni nj lo b">a1</code>成为全局范围的一部分，即使是在一个块中声明。另外，<code class="fe nh ni nj lo b">a1</code>从一开始就存在于全局范围内。</p><h1 id="f144" class="ly lt in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak">功能和范围</strong></h1><h2 id="3199" class="ls lt in bd lz oc od dn md oe of dp mh kg og oh ml kk oi oj mp ko ok ol mt om bi translated"><strong class="ak">全局功能</strong></h2><p id="df2b" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">如果一个函数是全局声明的，它的词法环境由GEC的<strong class="jx io">词法环境</strong>和它的<strong class="jx io">局部环境</strong>组成。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="c33c" class="ls lt in lo b gy lu lv l lw lx">1 var a0 = 0;<br/>2 let b0 = 0;<br/>3 const c0 = 0;<br/>4 function testFunc() {<br/>5    var a1 = 10;<br/>6    let b1 = 10;<br/>7    const c1 = 10;<br/>8 }</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/e458924263d7460a001623c5e15b6929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GlmlpfV9xgqtPaCd2LTbA.png"/></div></div></figure><h2 id="df9b" class="ls lt in bd lz oc od dn md oe of dp mh kg og oh ml kk oi oj mp ko ok ol mt om bi translated">嵌套函数</h2><p id="b42e" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">如果函数嵌套在其他函数中，那么它的词法环境包含</p><ul class=""><li id="1efd" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">祖父母的词汇环境</li><li id="8070" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">作为闭包的父元素的本地环境</li><li id="6fcb" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">自身的局部环境</li></ul><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi on"><img src="../Images/c7ecc038367437dfdc34d1c7d13b7166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQJklTCbkez5mSFd-CJVZw.png"/></div></div></figure><p id="e5f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的代码演示了函数如何嵌套在其他函数中。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="a2bb" class="ls lt in lo b gy lu lv l lw lx">1 var a0 = 0;<br/>2 let b0 = 0;<br/>3 function testFunc() {<br/>4    var a1 = 10;<br/>5    let b1 = 10;<br/>6    function testFunc1() {<br/>7        var a2 = 20;<br/>8        let b2 = 20;<br/>9    }<br/>10}</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi on"><img src="../Images/e4b0a67948de7053cabb2c002dffb1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RORrlZS1AtVelmtlq9X-RQ.png"/></div></div></figure><p id="5157" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数闭包中的变量与它捆绑在一起。即使其父函数的执行上下文不再存在于调用堆栈中，这些值也将被保留。考虑下面的例子。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="28e3" class="ls lt in lo b gy lu lv l lw lx">1  function testFunc() {<br/>2    var a2 = 20;<br/>3    let b2 = 20;<br/>4    console.log(a2, b2);<br/>5    function testFunc1() {<br/>6        var a3 = 30;<br/>7        let b3 = 30;<br/>8        console.log(a2, a3, b2, b3);<br/>9    }<br/>10    return testFunc1;<br/>11 }<br/>12 var testFunc1 = testFunc();<br/>13 testFunc1();</span></pre><p id="6b99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，<code class="fe nh ni nj lo b">testFunc()</code>中定义的<code class="fe nh ni nj lo b">testFunc1()</code>不是在函数中调用，而是从函数中返回。我们在<strong class="jx io">行12 </strong>得到从<code class="fe nh ni nj lo b">testFunc()</code>返回的<code class="fe nh ni nj lo b">testFunc1()</code>，它在<strong class="jx io">行13 </strong>被调用。此时，调用栈只包含GEC和<code class="fe nh ni nj lo b">testFunc1()</code>的EC。但是<code class="fe nh ni nj lo b">testFunc1()</code>的词法环境将有<code class="fe nh ni nj lo b">a2</code>和<code class="fe nh ni nj lo b">b2</code>，它们是<code class="fe nh ni nj lo b">testFunc()</code>的一部分，定义在其闭包内。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/cdab076ef60917da222ada61ecb54871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJgWax6W9yYPt25g89jhkA.png"/></div></div></figure><h2 id="d947" class="ls lt in bd lz oc od dn md oe of dp mh kg og oh ml kk oi oj mp ko ok ol mt om bi translated">包含块的函数</h2><p id="05fc" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">函数中也可能包含块。如果是这样，函数的局部环境可能包含块。如果当前函数存在于其父函数的块(嵌套块)中，那么将有一个块作用域附加到其闭包上。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="bbf9" class="ls lt in lo b gy lu lv l lw lx">var a0 = 0;<br/>let b0 = 0;<br/>function testFunc() {<br/>    var a1 = 10;<br/>    let b1 = 10;<br/>    {<br/>        var a2 = 20;<br/>        let b2 = 20;<br/>        function testFunc1() {<br/>            var a3 = 30;<br/>            let b3 = 30;<br/>        }<br/>    }<br/>}</span></pre><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oo"><img src="../Images/f1de332f1dd69ad92fea274caf1d3cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKU3j7vLVXYC9wOAFHoHyw.png"/></div></div></figure><h2 id="e2b6" class="ls lt in bd lz oc od dn md oe of dp mh kg og oh ml kk oi oj mp ko ok ol mt om bi translated">函数嵌套在多个级别中</h2><p id="5d14" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">如果函数嵌套在多个层次中，它的闭包会形成其父函数的闭包链。下面的代码包含了到目前为止讨论的所有不同类型的作用域的几种不同的可能性。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="615d" class="ls lt in lo b gy lu lv l lw lx">1 var a0 = 0;<br/>2 let b0 = 0;<br/>3 function testFunc() {<br/>4    var a1 = 10;<br/>5    let b1 = 10;<br/>6    console.log(a0, a1, b0, b1);<br/>7    {<br/>8        var a2 = 20;<br/>9        let b2 = 20;<br/>10       console.log(a0, a1, a2, b0, b1, b2);<br/>11       function testFunc1() {<br/>12          var a3 = 30;<br/>13          let b3 = 30;<br/>14          console.log(a0, a1, a2, a3, b0, b1, b2, b3);<br/>15          function testFunc2() {<br/>16              var a4 = 40;<br/>17              let b4 = 40;<br/>18              console.log(a0, a1, a2, a3, a4, b0, b1, b2, b3, b4);<br/>19              {<br/>20                  var a5 = 50;<br/>21                  let b5 = 50;<br/>22                  console.log(a0, a1, a2, a3, a4, a5, <br/>23                              b0, b1, b2, b3, b4, b5);<br/>24              }<br/>25          }<br/>26          testFunc2();<br/>27      }<br/>28      testFunc1();<br/>29   }<br/>30}<br/>31testFunc();</span></pre><p id="0731" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面给出了执行上述代码的<strong class="jx io">行22 </strong>时调用堆栈的快照</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/b0c2c1b1fa0c84a008f738089f1f7d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzW7zyJsSwZAY9z0O0WlEQ.png"/></div></div></figure><p id="74e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当在浏览器中执行上述代码时，执行<strong class="jx io">行22 </strong>时的范围选项卡如下所示。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oq"><img src="../Images/e4e0809ff0abc6bc2af1dcab340e0ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQ8xKi0UeKR1huWE3kX6Pg.png"/></div></div></figure><h1 id="86a4" class="ly lt in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak">结论</strong></h1><p id="96c7" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">这篇文章是关于JavaScript中的词法环境、作用域链和不同类型的作用域。我们还讨论了作用域的行为，以及在各种代码场景中作用域链是如何形成的。</p><p id="6609" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nd">更多内容看</em> <a class="ae lc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nd">说白了就是</em> </a> <em class="nd">。报名参加我们的</em> <a class="ae lc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nd">免费每周简讯</em> </a> <em class="nd">。在我们的</em> <a class="ae lc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nd">社区不和谐</em> </a> <em class="nd">获得独家访问写作机会和建议。</em></p></div></div>    
</body>
</html>