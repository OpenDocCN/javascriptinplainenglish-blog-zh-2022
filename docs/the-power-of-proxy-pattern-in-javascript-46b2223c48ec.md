# JavaScript 中代理模式的威力

> 原文：<https://javascript.plainenglish.io/the-power-of-proxy-pattern-in-javascript-46b2223c48ec?source=collection_archive---------4----------------------->

## 代理人不需要总是听起来很无聊。

![](img/583e2c823b34726d596cff3fbf2e0b30.png)

*Photo by Caspar Camille Rubin on Unsplash*

我在职业生涯后期学到的一个更有趣的模式是代理。

当您寻找代理模式的例子时，您可能经常会看到不同的实现变体。这是因为代理并不局限于一个用例。一个代理可能充当验证者，而另一个可能对提高性能更感兴趣，等等。

其思想是，通过利用一个代理，我们包装现有的对象，其功能与原始对象相同，其中其方法(甚至属性)完全相同，直到我们在包装的函数被调用之前，在包装的方法*中添加额外的逻辑。这是一个对外界完全隐藏的过程，并且这个呼叫对呼叫者来说总是相同的。*

换句话说，代理正好位于对象的客户端和实际对象本身之间。这是它可以选择充当“保护者”或添加自定义逻辑的地方，比如*缓存*，而调用者对此一无所知。正因为如此，它有时可以被称为调解人。有些人也可能把它归类为装饰模式的另一种形式，但还是有一些不同。

在本帖中，我们将介绍 JavaScript 中代理设计模式的强大功能，以及它对您的下一个应用程序有多大益处的几个例子。

因为 JavaScript 本身添加了一个实现该模式的`Proxy`类，所以我们将直接使用`Proxy`类来演示这个模式。

# 装饰者和代理的区别

在装饰器模式中，装饰器的主要职责是增强它所包装(或“装饰”)的对象，而代理具有更多的可访问性并控制对象。

代理可以选择增强它所包装的对象，或者以其他方式控制它，比如限制来自外界的访问，但是装饰器会通知并应用增强。

责任方面的区别是显而易见的。工程师通常使用 decorators 来添加新的行为，或者作为旧的或遗留类的适配器的一种形式，在那里他们返回一个增强的接口*，客户端可能知道但同时并不关心这个接口*。代理通常打算返回*同一个接口，在这个接口上，客户端可能假设它正在处理同一个未被触及的对象*。

# 验证器/助手

我将在这里展示的代理模式的第一个实现是一个验证器。

这个例子展示了作为一种帮助验证输入和保护属性不被设置为错误数据类型的方法而实现的模式。请记住，调用方必须始终假设它正在处理原始对象，因此代理不能更改它正在包装的对象的签名或接口:

这个例子展示了一个简单的助手，它验证一个对象的字段，当验证失败时抛出一个`TypeError`异常。

代理取得`id`属性的`getter`和`setter`的所有权，并选择允许或拒绝试图设置的值。

在`Proxy`类中，它可以这样实现:

验证器工作得非常好:

# 剪贴板多填充

这一节将通过确保浏览器支持`Navigator.clipboard` API，将代理作为一种支持旧浏览器的方式，将选择的文本复制到用户的剪贴板中。如果没有，那么它将使用`execCommand`来复制选择。

同样，客户端将总是假设它正在调用方法的对象是原始对象，并且只知道它正在调用上述方法:

您可能会问，在这种情况下应用代理有什么意义，而不是在实际的`copyToClipboard`函数中直接硬编码实现。如果我们使用一个代理，我们可以把它作为一个独立的来重用，并且通过[控制反转](https://en.wikipedia.org/wiki/Inversion_of_control#:~:text=In%20software%20engineering%2C%20inversion%20of,control%20from%20a%20generic%20framework.)来自由地改变实现。

使用这种策略的另一个好处是我们不会修改原始函数。

# 缓存器(增强性能)

在许多不同的场景中，缓存可以采用许多不同的形式。比如 HTTP 请求的重新验证时有 [Stale、](https://datatracker.ietf.org/doc/html/rfc5861) [nginx 内容缓存](https://docs.nginx.com/nginx/admin-guide/content-cache/content-caching/)、 [CPU 缓存](https://en.wikipedia.org/wiki/CPU_cache)、[懒加载缓存](https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/Strategies.html)、内存等。

在 JavaScript 中，我们还可以在代理的帮助下实现缓存。

要实现代理模式而不直接使用`Proxy`类，我们可以这样做:

缓存:

在`Proxy`类中直接实现这一点很简单:

# `Proxy`类

我们已经在几个准系统代理模式实现中看到了持久模式，而不是直接使用`Proxy`类。因为 JavaScript 直接将`Proxy`作为对象提供给语言，所以为了方便起见，本文的其余部分将使用它。

所有剩下的例子都可以在没有`Proxy`的情况下实现，但是我们将把重点放在类语法上，因为它更简洁，更容易操作，特别是为了这篇文章。

# 单例的代理

如果您从未听说过 Singleton，那么它是另一种设计模式，可以确保如果感兴趣的对象已经在应用程序的整个生命周期中被实例化，那么它将被返回和重用。在实践中，你很可能会看到它被用作一些全局变量。

例如，如果我们正在编写一个 MMORPG 游戏，我们有三个类`Equipment`、`Person`和`Warrior`，其中只能有一个*`Warrior`，我们可以在实例化`Warrior`*类上的`Proxy`时使用第二个参数中的`construct`处理程序方法:**

**如果我们试图创建多个`Warrior`实例，我们可以确保每次只使用第一个创建的实例:**

**结果:**

# **偷饼干的人**

**在这一节中，我们将演示一个使用`Proxy`来防止 cookies 列表突变的例子。这将防止原始对象发生变异，并且变异者(`CookieStealer`)会认为他们的邪恶操作成功了。**

**让我们来看看这个例子:**

**乔治的食物:**

**我们使用`Human`类实例化了`george`,并在它的存储中添加了 7 种食物。乔治很高兴他将要吃他的水果和饼干。他对他的饼干特别兴奋，因为他同时得到了他最喜欢的口味，很快就会狼吞虎咽地吃下去，以满足他对饼干的渴望。**

**然而，有一个问题:**

**那只`CookieStealer`突然出现来偷他的饼干。`CookieStealer`现在在他的存储器中有 5 个 cookies:**

**乔治:**

**如果我们倒回去，介绍我们的救世主`Superman`来应用他的一种实现`Proxy`模式的方法来阻止`CookieStealer`的邪恶行为，这将解决我们的问题:**

**我们的朋友`superman`幸运地碰巧有一个`protectFromCookieStealers`利用`Proxy`的力量给*伪造了*一份饼干名单！他把真正的包含乔治饼干的食物收藏藏起来，不让 T3 看到。`CookieStealer`继续他邪恶的计划，似乎被*骗了*以为他带走了饼干:**

**`CookieStealer`拿走了他储藏室里的饼干，而*认为*他侥幸逃脱了:**

**他一点也不知道他被超人骗了，那些是假饼干！`george`多亏了`Proxy`的力量将他从邪恶的黑暗中拯救出来，他的饼干仍然完好无损:**

# **结论**

**我希望这有助于阐明代理模式，以及如何使用 JavaScript 中现在内置的`Proxy`类来利用这一概念。**

**这篇文章到此结束:)我希望这篇文章对你有所帮助，并确保在以后的文章中关注我！**

***更多内容看* [***说白了就是***](https://plainenglish.io/) *。报名参加我们的* [***免费每周简讯***](http://newsletter.plainenglish.io/) *。关注我们* [***推特***](https://twitter.com/inPlainEngHQ) *和*[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*。加入我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *。***