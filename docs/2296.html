<html>
<head>
<title>Understanding Web Workers in JavaScript With Real-World Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过真实的例子理解JavaScript中的Web Workers</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-web-workers-in-js-with-real-world-example-1629a283aeec?source=collection_archive---------0-----------------------#2022-05-28">https://javascript.plainenglish.io/understanding-web-workers-in-js-with-real-world-example-1629a283aeec?source=collection_archive---------0-----------------------#2022-05-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="32b1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中的web workers是什么？用一个真实的例子来解释。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/501d4322746dd50308012805af413d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DEmR3-q141lAMli0"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Gower</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a72c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript是一种单线程编程语言。这意味着所有事情都发生在那个主线程上。它不能同时做多件事。Web workers 被引入来解决这个问题。Web工作者给了我们编写多线程JavaScript的可能性，它不会阻塞DOM。即使是异步操作也会在某种程度上阻塞DOM。</p><p id="9865" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank"> Web workers </a>不能执行任何类型的DOM操作，因为它不能访问窗口对象、文档对象或DOM。但是，它可以访问location对象、navigator对象、fetch、应用程序缓存以及使用importScripts()导入外部脚本。</p><h2 id="1c75" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">语法:</h2><p id="4564" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">下面是创建新的worker实例的语法。worker构造函数获取一个worker脚本的路径(即worker.js)。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="8b95" class="lp lq in mo b gy ms mt l mu mv">var myWorker = new Worker('worker.js');</span></pre><h2 id="5be8" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">向网络工作者发送消息</h2><p id="c2e7" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们可以使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" rel="noopener ugc nofollow" target="_blank"> postMessage() </a>方法和<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/message_event" rel="noopener ugc nofollow" target="_blank"> onmessage </a>事件处理程序将数据从主线程发送到工作文件，反之亦然。数据是复制的而不是共享的，也就是说，你可以传递对象，这些对象会被复制。</p><p id="e3bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">从主线程向工作线程发送数据:</strong></p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="0e1e" class="lp lq in mo b gy ms mt l mu mv">worker.postMessage('Hello');</span></pre><p id="cf3a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正在为我们的工作线程添加onmessage事件侦听器。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="2612" class="lp lq in mo b gy ms mt l mu mv">worker.onmessage = function(e) {<br/>   let data = ev.data;<br/>   console.log(data);<br/>}</span></pre><p id="3232" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">从网络工作者发送数据:</strong></p><p id="9fe7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们的worker.js文件中，我们可以使用<strong class="kv io"> self.onmessage </strong>和<strong class="kv io"> self.postMessage </strong>来接收和发送数据到父线程。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="b437" class="lp lq in mo b gy ms mt l mu mv">self.onmessage = (e) =&gt; {<br/> if(e.data !== undefined) {<br/>        var msg = e.data + ' World';<br/>        // Posting back to the page<br/>        self.postMessage(msg)<br/>    }<br/>});</span></pre><h2 id="892a" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">现实世界的例子:</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/a67728b9b02959e69bf8e9954c0749ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gJ8yLdnJmil6M5JFgkr8rw.gif"/></div></div></figure><p id="ac6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们有一个简单的HTML页面，上面有一些动画和一个按钮(计算总和)来执行繁重的操作。单击此按钮，我们将执行从0到1000000000的求和计算。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="0f1a" class="lp lq in mo b gy ms mt l mu mv">let sum = 0;<br/>for (let i = 0; i &lt; 1000000000; i++) {<br/>    sum += i;<br/>}<br/>alert(sum);</span></pre><p id="953e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们点击这个按钮时，动画将会冻结，因为我们的主线程正忙于执行那个复杂的计算。并且只有当计算完成时，动画才会继续。所以网络工作者来拯救我们了。我们可以将这个复杂的计算任务提供给网络工作者，如下所示:</p><p id="dcd4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">在app.js中</strong></p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="97d2" class="lp lq in mo b gy ms mt l mu mv">document.getElementById('sumBtn').addEventListener('click', ()=&gt; {<br/>      worker.postMessage({'do':'Sum'})<br/>});</span></pre><p id="4939" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">在worker.js中</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a8c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">结果显示在下面的gif中。现在，动画不会因为单击按钮而停止，因为复杂的计算任务现在由web worker在后台处理。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/85bb288a511a2b1ee55af330590f9308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LKAXi3ZkwyRFWXb4f99d6Q.gif"/></div></div></figure><h1 id="d11d" class="mz lq in bd lr na nb nc lu nd ne nf lx jt ng ju ma jw nh jx md jz ni ka mg nj bi translated">共享员工:</h1><p id="8ec7" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">专用工作器只能访问并连接到一个脚本，不能向其他脚本或工作器发送消息。另一方面，一个<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#shared_workers" rel="noopener ugc nofollow" target="_blank">共享工作器</a>可以被多个脚本访问——即使它们被不同的窗口、iframes甚至工作器访问。</p><h2 id="6b1e" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">语法:</h2><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="b708" class="lp lq in mo b gy ms mt l mu mv">var myWorker = new SharedWorker('worker.js');</span></pre><h2 id="5e98" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">向共享工作人员发送数据</h2><p id="04c5" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">对于一个共享的工作者，我们必须通过一个端口对象进行通信——一个显式的端口被打开，脚本可以使用它与工作者进行通信。这个端口连接将通过使用<strong class="kv io"> onmessage </strong>事件处理程序隐式启动。<br/>因此，我们必须使用<strong class="kv io">my worker . port . postmessage()</strong>，而不是使用<strong class="kv io"> myWorker.postMessage() </strong>。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="86bf" class="lp lq in mo b gy ms mt l mu mv">document.getElementById('sumBtn').addEventListener('click', ()=&gt; {<br/>      myWorker.port.postMessage({'do':'Sum'})<br/>});</span></pre><p id="7bf3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意:</strong>如果对onmessage事件使用addEventListener()方法，需要使用start()方法。</p><h2 id="d469" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">从共享工作者发送数据</h2><p id="3c5c" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">与网络工作者相比，这里的方法有点不同。首先，我们使用一个<strong class="kv io"> onconnect </strong>处理程序在连接到端口时触发代码(例如，当父线程中的<strong class="kv io"> onmessage </strong>事件处理程序被设置时，或者当父线程中的start()方法被显式调用时)。接下来，我们在端口上添加一个onmessage处理程序来进行计算，并将结果返回给主线程。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="69ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意:</strong>如果可以从几个浏览上下文访问SharedWorker，那么所有这些浏览上下文必须共享完全相同的源(相同的协议、主机和端口)。</p><h2 id="5307" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">完整源代码:</h2><p id="324d" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated"><strong class="kv io"> Web Workers示例:</strong> <a class="ae ks" href="https://github.com/ankitsaxena21/Web-Workers-Demo" rel="noopener ugc nofollow" target="_blank"> Github回购链接</a> <strong class="kv io"> <br/>共享Workers示例:</strong> <a class="ae ks" href="https://github.com/ankitsaxena21/Shared-Worker" rel="noopener ugc nofollow" target="_blank"> Github回购链接</a></p><h2 id="4ea0" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">视频解释:</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk my l"/></div></figure><p id="c0f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nl">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nl">plain English . io</em></strong></a><em class="nl">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nl">免费周报</em> </strong> </a> <em class="nl">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nl">Twitter</em></strong></a><em class="nl">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nl">LinkedIn</em></strong></a><em class="nl">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nl">社区不和谐</em> </strong> </a> <em class="nl">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nl">人才集体</em> </strong> </a> <em class="nl">。</em></p></div></div>    
</body>
</html>