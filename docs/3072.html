<html>
<head>
<title>Build a Modern Web App Without Frameworks — Classes, Components, &amp; Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个没有框架的现代Web应用程序——类、组件和继承</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-modern-web-app-without-frameworks-classes-components-inheritance-1bfd314fc582?source=collection_archive---------2-----------------------#2022-07-28">https://javascript.plainenglish.io/building-a-modern-web-app-without-frameworks-classes-components-inheritance-1bfd314fc582?source=collection_archive---------2-----------------------#2022-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db66" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">没有反应，没有Vue.js？有可能用组件、状态管理、主题化和继承来构建一个现代化的前端应用吗？</h2></div><p id="6940" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有React，没有Vue.js，没有Angular，没有jQuery？有没有可能轻松地<strong class="kh ir">构建一个现代前端应用程序</strong>，其中组件和状态管理遵循所有最佳实践<strong class="kh ir">，只使用普通的旧JavaScript </strong>，使用类、继承，并添加更高级的架构模式，如store和reducer？</p><blockquote class="lb"><p id="18f3" class="lc ld iq bd le lf lg lh li lj lk la dk translated">嗯，这正是我所做的，我认为这太棒了！</p></blockquote><p id="b617" class="pw-post-body-paragraph kf kg iq kh b ki ll jr kk kl lm ju kn ko ln kq kr ks lo ku kv kw lp ky kz la ij bi translated">让我解释一下…</p><h1 id="c369" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">目录</h1><ul class=""><li id="93b0" class="mi mj iq kh b ki mk kl ml ko mm ks mn kw mo la mp mq mr ms bi translated"><a class="ae mt" href="#5088" rel="noopener ugc nofollow">简介</a></li><li id="3b36" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#5dac" rel="noopener ugc nofollow">为什么，为了什么？</a></li><li id="2ac9" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#0383" rel="noopener ugc nofollow">使用Webpack进行环境设置</a></li><li id="8519" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#51df" rel="noopener ugc nofollow">启动示例应用</a></li><li id="9506" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#2998" rel="noopener ugc nofollow">用HTML制作模板</a></li><li id="3a8d" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#6668" rel="noopener ugc nofollow"> CSS变量和主题</a></li><li id="6cc9" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#3517" rel="noopener ugc nofollow">组件类型</a></li><li id="e82b" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#68fc" rel="noopener ugc nofollow">建筑简单构件</a></li><li id="9d3d" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#aef3" rel="noopener ugc nofollow">全局应用状态</a></li><li id="b951" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#3b7d" rel="noopener ugc nofollow">创建商店和减速器</a></li><li id="1c52" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#676e" rel="noopener ugc nofollow">订阅店铺变更</a></li><li id="7dce" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#93cb" rel="noopener ugc nofollow">theme toggle组件</a></li><li id="89e2" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#d406" rel="noopener ugc nofollow">类和模板继承</a></li><li id="a0e4" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><a class="ae mt" href="#2c50" rel="noopener ugc nofollow">总结</a></li></ul><h1 id="4446" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">下载样板文件</h1><p id="7518" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">如果您想使用样板文件，请下载它:</p><div class="nc nd gp gr ne nf"><a href="https://github.com/webondevices/stracciatella" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">GitHub—webon devices/stracciatella:一个简单的普通JS前端应用程序的样板文件，带有…</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt nu nf"/></div></div></a></div><p id="fb10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我称之为Stracciatella，因为它基本上是香草味的🍦</p><figure class="nw nx ny nz gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi nv"><img src="../Images/e1f7059e26cd33e9a72d49ba43b52ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSPc6CJmzgTmvWhSzg-IsA.jpeg"/></div></div></figure><h1 id="5088" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">介绍</h1><p id="3d6c" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">整个应用架构被分成<strong class="kh ir">可重用的JavaScript、CSS和HTML块</strong>组织成单独的文件夹和模块。这些块要么是你的组件，你的页面模板，要么是其他可重用的代码。</p><p id="c128" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的组件和页面模板有自己的HTML模板和CSS样式表，它们的应用程序逻辑在JavaScript <code class="fe og oh oi oj b">Class </code>或独立模块中的独立函数中捕获。您可以导入和导出它们，并用<code class="fe og oh oi oj b">new</code>关键字进行初始化。</p><p id="b453" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用模板和嵌套，我使用了一个简单的Webpack插件来允许将HTML文件导入到其他HTML文件中。是的，Webpack是一个库，但是正如你将会看到的，我使用它几乎就像一个polyfill。</p><p id="e81e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序逻辑的其余部分被分解成模块，并与组件一起导出和导入到其他文件中，就像您基于React、Vue.js或Angular等常用框架处理任何其他复杂的前端应用程序一样！</p><figure class="nw nx ny nz gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ok"><img src="../Images/443d81d30be13005a12b16e68781814d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aig1Ar1rm8v1tNu207fhEg.png"/></div></div></figure><p id="2cad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">澄清一下，我对整个项目的最初动机是<strong class="kh ir">尽可能让事情简单、轻量、快速</strong>！我对React或其他框架没有固有的问题，它们对于某些项目来说是完全合理的。</p><p id="46c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的7-8年里，我一直在使用React和类似的现代框架和架构，所以我100%相信模块化和使用可重用组件。因此，最大的挑战是实现类似的抽象，并从本质上找到一种方法，将我的HTML、CSS和JS分成块，然后自由地组合它们。</p><p id="42d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">^</strong>T7<strong class="kh ir">回顶</strong>T10<strong class="kh ir">^</strong></p><h1 id="5dac" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">为什么，为了什么？</h1><p id="15e8" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">我认为以这种方式从头开始构建简单的web应用程序有很多好处:</p><ul class=""><li id="a834" class="mi mj iq kh b ki kj kl km ko ol ks om kw on la mp mq mr ms bi translated">你从100%的谷歌灯塔速度分数开始！</li><li id="40ba" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">你100%了解你的代码库</li><li id="096a" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">你不包括你不需要的代码</li><li id="e27f" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">您的web应用程序加载速度极快</li><li id="5a42" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">你会成为更好的JavaScript开发人员</li><li id="a0d2" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">修复JS和CSS中的Bug既容易又不费力</li></ul><p id="250f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议对简单的web应用程序和简单的网站使用我的样板文件。</p><p id="84f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我如何知道所有这些在生产中是否可行？当我在一家英国豪华旅行社做软件工程顾问时，我用同样的架构重建了它的网站。</p><p id="ff6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">项目进展顺利，我对结果非常满意。该网站已经运行了一年多，没有出现任何问题。</p><p id="6702" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong></a>t19】^</p><h1 id="0383" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">使用Webpack进行环境设置</h1><p id="d5c4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">第一个挑战是建立一个环境，在这个环境中，我可以在本地服务器和<code class="fe og oh oi oj b">localhost</code>上提供模板，并将整个应用程序整合在一起，还可以实现一些自动化。你还会看到我使用SCSS进行一些非常基本的处理，比如导入变量。</p><p id="cc62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这一切，我使用了一个简单的Webpack设置，允许我简单地运行<code class="fe og oh oi oj b">npm start</code>来启动整个应用程序，然后访问<code class="fe og oh oi oj b">localhost:8080</code>来预览我的工作。正如您所料，它还会为我编译CSS和JS文件！</p><p id="f0f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你仔细查看<code class="fe og oh oi oj b">webpack.common.js</code>和插件部分，你会发现一些代码暴露了本地服务器的模板:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="15f8" class="os lr iq oj b gy ot ou l ov ow">plugins: [<br/>  new HtmlWebpackPlugin({<br/>    template: "./src/pages/home/home.html",<br/>    filename: "index.html",<br/>  }),<br/>],</span></pre><p id="3892" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将查看<code class="fe og oh oi oj b">src/pages/home</code>文件夹，获取<code class="fe og oh oi oj b">home.html</code>文件，并在服务器上将其显示为<code class="fe og oh oi oj b">index.html</code>。因此，你可以直接进入<code class="fe og oh oi oj b">localhost:8080/</code>的根目录，这个页面就会为你服务。</p><p id="a2af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在<code class="fe og oh oi oj b">src/pages/about/about.html</code>中有第二个关于页面的HTML页面模板，并且您想在<code class="fe og oh oi oj b">localhost:8080/about</code>中公开它，那么您只需添加一个新的声明:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="3c3d" class="os lr iq oj b gy ot ou l ov ow">plugins: [<br/>  new HtmlWebpackPlugin({<br/>    template: "./src/pages/about/about.html",<br/>    filename: "about/index.html",<br/>  }),<br/>],</span></pre><p id="b19d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们的web应用程序有了单独的页面模板！</p><p id="8bec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong></a>t17】^</p><h1 id="51df" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">启动示例应用程序</h1><p id="ee10" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">为了能够轻松演示该架构的所有方面，我将开始构建一个简单的页面，如下所示:</p><figure class="nw nx ny nz gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ok"><img src="../Images/443d81d30be13005a12b16e68781814d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aig1Ar1rm8v1tNu207fhEg.png"/></div></div></figure><p id="35f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将允许我们:</p><ul class=""><li id="bdf6" class="mi mj iq kh b ki kj kl km ko ol ks om kw on la mp mq mr ms bi translated">打开和关闭模式窗口</li><li id="7a30" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">在亮/暗主题之间切换</li></ul><p id="42f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序将具有:</p><ul class=""><li id="568b" class="mi mj iq kh b ki kj kl km ko ol ks om kw on la mp mq mr ms bi translated">组件和页面模板</li><li id="f0ac" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">主题和变量</li><li id="d2e7" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">类来演示本地状态和继承</li><li id="2c64" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">一个存储器和一个减速器来演示全局状态</li><li id="5585" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated">以及围绕它的所有样板文件，使应用程序易于扩展</li></ul><p id="d445" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong> </a> <strong class="kh ir"> ^ </strong></p><h1 id="2998" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">用HTML制作模板</h1><p id="1989" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">好的，我们现在用<code class="fe og oh oi oj b">npm start</code>运行应用程序，我们有一个来自<code class="fe og oh oi oj b">home.html</code>文件的页面。你可以在这里添加你常用的HTML内容，一切都会像预期的那样工作。我们已经取得了一些进展！</p><p id="f891" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们有一个组件，想把它的HTML导入到我们的HTML页面模板中，会怎么样呢？嗯，我对此做了一些研究，没有本地方法可以将一大块HTML导入另一个HTML文件中。</p><p id="d849" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个相对简单的任务，我添加了post HTML include和模块加载器Webpack插件。</p><p id="1b09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae mt" href="https://github.com/posthtml/posthtml-include" rel="noopener ugc nofollow" target="_blank"> post HTML include插件</a>允许我在一个单独的HTML文件中包含一段HTML，并将其包含在另一个HTML中:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="b43b" class="os lr iq oj b gy ot ou l ov ow">&lt;body&gt;<br/>  &lt;include src="components/button/button.html"&gt;&lt;/include&gt;<br/>&lt;/body&gt;</span></pre><p id="3616" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会将<code class="fe og oh oi oj b">button.html</code>的内容导入到您的页面模板中。这里我们应该提到，我们还有一个<code class="fe og oh oi oj b">npm run build</code>命令，它可以生成一个分发文件夹，在那里您将得到一个<code class="fe og oh oi oj b">home.html</code>文件，其中所有的导入都已经被协调和复制了！</p><p id="962b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用post HTML插件，<strong class="kh ir">你甚至可以将某些值注入到你的模板中</strong>。在我们的例子中，<code class="fe og oh oi oj b">button.html</code>接受一个自定义的<code class="fe og oh oi oj b">class</code>和一个<code class="fe og oh oi oj b">text</code>值:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="86d3" class="os lr iq oj b gy ot ou l ov ow">&lt;button class="str-button {{class}}"&gt;{{text}}&lt;/button&gt;</span></pre><p id="7cba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe og oh oi oj b">home.html</code>中，我们可以将这些值传入:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="5dd7" class="os lr iq oj b gy ot ou l ov ow">&lt;include src="components/button/button-primary.html"&gt;<br/>  {<br/>    "text": "Open Modal",<br/>    "class": "home__open-modal"<br/>  }<br/>&lt;/include&gt;</span></pre><p id="f6c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更重要的是，我们可以做嵌套，所以在你的组件中，你实际上可以进入多个层次，并有额外的包含！</p><p id="b95b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">post HTML include插件有一些限制，但是它可以和<a class="ae mt" href="https://github.com/posthtml/posthtml-modules" rel="noopener ugc nofollow" target="_blank"> post HTML模块插件</a>一起工作来扩展我们的工具集。作为一个例子，你可以传递一大块HTML，甚至是组件的<code class="fe og oh oi oj b">&lt;includes&gt;</code>。比方说，如果您有一个菜单组件，并且您想从其他组件传入您的菜单项:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="2e68" class="os lr iq oj b gy ot ou l ov ow">&lt;module href="src/components/menu/menu.html"&gt;<br/>  &lt;include src="components/menu-item/menu-item.html"&gt;<br/>    {<br/>      "text": "home",<br/>      "url: "/",<br/>    }<br/>  &lt;/include&gt;<br/>  &lt;include src="components/menu-item/menu-item.html"&gt;<br/>    {<br/>      "text": "about",<br/>      "url: "/about",<br/>    }<br/>  &lt;/include&gt;<br/>&lt;/module&gt;</span></pre><p id="f031" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe og oh oi oj b">menu.html</code>中，您可以使用<code class="fe og oh oi oj b">&lt;content&gt;</code>元素来放置您注入的HTML内容:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="51cb" class="os lr iq oj b gy ot ou l ov ow">&lt;ul class="str-menu"&gt;<br/>  &lt;content&gt;&lt;/content&gt;<br/>&lt;/ul&gt;</span></pre><p id="74c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的<code class="fe og oh oi oj b">menu-item.html</code>文件会给你列表项:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="d6ce" class="os lr iq oj b gy ot ou l ov ow">&lt;li class="str-menu-item"&gt;<br/>  &lt;a href="{{url}}"&gt;{{text}}&lt;/a&gt;<br/>&lt;/li&gt;</span></pre><p id="faab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不错！</p><p id="4cc2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong></a>t23】^</p><h1 id="6668" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">CSS变量和主题</h1><p id="72cb" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">对于CSS样式，我决定使用SCSS来允许我简单地导入CSS块，也可以处理变量，你会看到为什么我不能只使用普通的旧CSS自定义属性。</p><p id="3f5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe og oh oi oj b">src</code>文件夹的根目录中，我们有一个<code class="fe og oh oi oj b">styles.scss</code>文件，它是我们所有样式的入口点。它只是引入了我们所有的风格:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="a6ea" class="os lr iq oj b gy ot ou l ov ow">// Theme<br/>@import "./theme/variables.scss";<br/>@import "./theme/normalize.scss";<br/>@import "./theme/theme.scss";<br/>@import "./theme/base.scss";</span><span id="20b7" class="os lr iq oj b gy ox ou l ov ow">// Global styles<br/>@import "./global/containers.scss";</span><span id="6987" class="os lr iq oj b gy ox ou l ov ow">// Static styles<br/>@import "./static-styles/flex/flex.scss";</span><span id="c59b" class="os lr iq oj b gy ox ou l ov ow">// Static components<br/>@import "./static-components/horizontal-rule/horizontal-rule.scss";</span><span id="fd13" class="os lr iq oj b gy ox ou l ov ow">// Components<br/>@import "./components/modal/modal.scss";<br/>@import "./components/button/button.scss";</span><span id="883e" class="os lr iq oj b gy ox ou l ov ow">// Pages<br/>@import "./pages/home/home.scss";</span></pre><p id="0377" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的顺序非常重要，因为如果以后想使用变量和可重用模块，就需要定义它们。因此，我们需要从应用程序的变量开始，包括所有字体、颜色和以“str-”为前缀的测量值，以区分Stracciatella的品牌价值:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="15f1" class="os lr iq oj b gy ot ou l ov ow">/* Fonts */<br/>$helvetica: "Helvetica";</span><span id="d5e5" class="os lr iq oj b gy ox ou l ov ow">/* Colors */<br/>$str-black: black;<br/>$str-white: white;<br/>$str-dark-brown: #2b231d;<br/>$str-brown: #bc6c25;<br/>$str-cream: #fefae0;<br/>$str-green: #283618;</span><span id="0f6a" class="os lr iq oj b gy ox ou l ov ow">/* Breakpoints */<br/>$str-tablet: 768px;<br/>$str-laptop: 1024px;<br/>$str-desktop: 1280px;</span><span id="8bd3" class="os lr iq oj b gy ox ou l ov ow">/* Unit */<br/>$unit: 12px;</span></pre><p id="d1f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有所有的品牌颜色、断点和12像素的单位，这将是我们测量的基础。</p><p id="c46c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在设计系统中，边距、填充和尺寸通常是基本单位的倍数，以保持一致性。</p><p id="a117" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加一个简单的<a class="ae mt" href="https://necolas.github.io/normalize.css/" rel="noopener ugc nofollow" target="_blank"> normalize </a>之后，是时候根据我们预定义的值来构建我们的主题了:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="1b2e" class="os lr iq oj b gy ot ou l ov ow">:root {<br/>  /* Colors */<br/>  --primary: #{$str-green};<br/>  --accent: #{$str-brown};<br/>  --accent-dark: #{$str-dark-brown};<br/>  --light: #{$str-cream};<br/>  --background: #{$str-white};<br/>  --text: #{$str-black};</span><span id="4d7c" class="os lr iq oj b gy ox ou l ov ow">  /* Fonts */<br/>  --font-primary: #{$helvetica};</span><span id="4fd4" class="os lr iq oj b gy ox ou l ov ow">  /* Breakpoints */<br/>  --tablet: #{$str-tablet};<br/>  --laptop: #{$str-laptop};<br/>  --desktop: #{$str-desktop};</span><span id="8803" class="os lr iq oj b gy ox ou l ov ow">  --unit: #{$unit};<br/>}</span><span id="0acf" class="os lr iq oj b gy ox ou l ov ow">body.dark {<br/>  --background: #{$str-black};<br/>  --text: #{$str-white};<br/>  --light: #{$str-dark-brown};<br/>  --accent-dark: #{$str-cream};<br/>}</span></pre><p id="cf84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们现在从已经定义的颜色变量中定义主题值，如“原色”、“强调色”、“背景色”或“文本”颜色。</p><p id="0224" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我觉得这里需要说明两件事！</p><p id="4d1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，为什么我们需要额外的步骤来定义一个<code class="fe og oh oi oj b">--primary</code>颜色属性，而不是仅仅在应用程序中使用<code class="fe og oh oi oj b">$str-green</code>的品牌价值？我可以给你两个理由:</p><ul class=""><li id="ba80" class="mi mj iq kh b ki kj kl km ko ol ks om kw on la mp mq mr ms bi translated"><strong class="kh ir">主题化:</strong>假设您正在为奥迪网站构建一个“立即购买”按钮，但也想为兰博基尼网站重用相同的按钮。在这种情况下，您可以定义按钮使用主要品牌颜色，只需添加<code class="fe og oh oi oj b">background-color: var(--primary)</code>。有了这个，你可以只改变原色的值一次，从一个品牌的颜色到另一个品牌的颜色，而不必改变CSS代码本身。例如，在我们的例子中，当body有了<code class="fe og oh oi oj b">.dark</code>类来实现一个黑暗主题时，我们将改变这些值。</li><li id="a38d" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">抽象值:</strong>你可能还想引入第二层颜色定义，以便更准确地实现你的设计系统。原色或强调色只是品牌的基本价值，但它们可以用在很多地方:边框颜色、带有透明度的阴影或标题文本的颜色。如果您以后需要进行一些更改，这些附加分组会对您有所帮助。</li></ul><p id="55c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我需要解释的第二件事是，为什么我对变量使用SCSS，然后对实际的主题值使用CSS自定义属性。这很简单:CSS自定义属性不允许你从另一个属性的值定义一个新的属性:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="805e" class="os lr iq oj b gy ot ou l ov ow">/* This will NOT work */<br/>--primary: var(--str-green);</span></pre><p id="3a1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续我们的主风格文件，我们正在导入<code class="fe og oh oi oj b">base.scss</code>。这个文件负责为所有标准HTML元素和主体的全局样式分配一些基本值。</p><p id="07b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这之后，我们有了组件和页面的所有导入，所以现在让我们讨论一下这些。</p><p id="a936" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong></a>t17】^</p><h1 id="3517" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">组件类型</h1><p id="7cb5" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">在开发应用程序的过程中，我意识到组件是不一样的，它们需要进行不同的分类和处理:</p><ul class=""><li id="551c" class="mi mj iq kh b ki kj kl km ko ol ks om kw on la mp mq mr ms bi translated"><strong class="kh ir">静态样式:</strong>这些是简单的可重用CSS块，就像带有flexbox的中心对齐元素，或者特定的边框样式，或者可能是阴影。我们的组件库定义的所有组件和可重用样式都将以前缀<code class="fe og oh oi oj b">.str-</code>开始，例如，用于flexbox定心的可重用静态样式将具有<code class="fe og oh oi oj b">.str-flex-center</code>类。</li><li id="da00" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">静态组件:</strong>这些组件可以只有HTML或者HTML和CSS，但是不允许有JS逻辑。在我们的例子中，我们有每个模板的<code class="fe og oh oi oj b">&lt;head&gt;</code>部分的可重用定义，根本没有CSS，还有一个HTML中带有<code class="fe og oh oi oj b">&lt;hr&gt;</code>元素的水平标尺分隔符组件，以及<code class="fe og oh oi oj b">.str-horizontal-rule</code>类下的一些相关CSS样式。为了遵循一些<a class="ae mt" href="http://getbem.com/" rel="noopener ugc nofollow" target="_blank"> BEM </a>方法，组件中的任何附加元素都需要用双下划线分隔。我们将通过一些例子回到这个问题上。</li><li id="cc13" class="mi mj iq kh b ki mu kl mv ko mw ks mx kw my la mp mq mr ms bi translated"><strong class="kh ir">组件:</strong>这些组件类似于静态组件，但是会有一些JS逻辑分配给它们，并带有<code class="fe og oh oi oj b">class</code>定义。</li></ul><p id="2c5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，我们还有页面和页面模板。它们有自己的HTML和一个相关的CSS文件。随着应用的增长，你甚至可以考虑添加一些页面级的JavaScript。</p><p id="10b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您将组件导入模板时，您可能需要额外的样式来定义页面级别的布局。任何与单页面模板严格相关的样式都需要加上前缀:<code class="fe og oh oi oj b">home__hero</code>、<code class="fe og oh oi oj b">home__content</code>等。</p><p id="d5a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常情况下，<strong class="kh ir">组件样式负责组件</strong>框架内发生的一切，它通常会尝试伸展100%的可用宽度。</p><p id="b8e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您的<strong class="kh ir">页面级样式负责定义总体布局，并在该布局中调整组件</strong>的大小和位置。</p><p id="9a99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你确定了一些可以跨模板使用的样式，比如“宽容器”或“窄容器”样式，这些样式也应该加上前缀并保存在一个单独的文件中:<code class="fe og oh oi oj b">global__wide-container</code>、<code class="fe og oh oi oj b">global__narrow-container</code>等。</p><p id="baa9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong> </a> <strong class="kh ir"> ^ </strong></p><h1 id="68fc" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">头部静态组件</h1><p id="10d6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">让我们开始构建我们的页面模板，因为我们通常从顶部到按钮工作，让我们从文档的<code class="fe og oh oi oj b">&lt;head&gt;</code>开始:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="fc75" class="os lr iq oj b gy ot ou l ov ow">&lt;head&gt;<br/>  &lt;meta charset="utf-8" /&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;<br/>  &lt;include src="static-components/head/head.html"&gt;<br/>    {<br/>      "title_text": "Home Page"<br/>    }<br/>  &lt;/include&gt;<br/>&lt;/head&gt;</span></pre><p id="aa40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了头部静态组件的<code class="fe og oh oi oj b">include</code>之外，这里没有什么特别的，头部静态组件将简单地添加一个<code class="fe og oh oi oj b">&lt;title&gt;</code>并生活在<code class="fe og oh oi oj b">static-components/head/head.html</code>内部，本质上是我们的第一个组件:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="badc" class="os lr iq oj b gy ot ou l ov ow">&lt;title&gt;{{title_text}}&lt;/title&gt;</span></pre><p id="5db6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当页面呈现时，标题将是“主页”，我们从模板传递到组件中。</p><p id="0843" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回到顶级</strong> </a> <strong class="kh ir"> ^ </strong></p><h1 id="551a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">HorizontalRule静态组件</h1><p id="0f52" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">进入到文档的<code class="fe og oh oi oj b">&lt;body&gt;</code>部分，我们有一个全屏英雄图像和一些内容的盒子，我们可以把它们翻译成一些HTML:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="00d4" class="os lr iq oj b gy ot ou l ov ow">&lt;main&gt;<br/>  &lt;section class="home__hero str-flex-center"&gt;<br/>    &lt;h1&gt;Stracciatella&lt;/h1&gt;<br/>  &lt;/section&gt;</span><span id="b2a4" class="os lr iq oj b gy ox ou l ov ow">  &lt;section class="home__introduction global__container--narrow"&gt;<br/>    &lt;h2&gt;Hello!&lt;/h2&gt;<br/>    &lt;p&gt;Why complicate things when you can keep it simple?&lt;/p&gt;<br/>    &lt;include src="static-components/horizontal-rule/horizontal-rule.html"&gt;&lt;/include&gt;</span><span id="755a" class="os lr iq oj b gy ox ou l ov ow">    &lt;!-- ... --&gt;<br/>  &lt;/section&gt;<br/>&lt;/main&gt;</span></pre><p id="5d77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意所有的类，以及我是如何添加它们的，还包括了第二个静态组件，它将使用自己的HTML和CSS:</p><p id="1c61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae mt" href="https://github.com/webondevices/stracciatella/tree/main/src/static-components/horizontal-rule" rel="noopener ugc nofollow" target="_blank">https://github . com/webondervices/stracciatella/tree/main/src/static-components/卧式-rule </a></p><p id="de5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong></a>^</p><h1 id="df4b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">按钮组件</h1><p id="ca7f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">现在事情越来越令人兴奋了！我们现在将需要一些JS逻辑和一个新的按钮组件以及<code class="fe og oh oi oj b">class</code>来支持所有你可能从按钮中得到的功能。</p><p id="cc97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您查看样板文件夹，您可能已经注意到按钮有三个单独的HTML文件，这是因为它们导出时有三个不同的类名，以提供按钮的默认版本、主版本和辅助版本:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="eae2" class="os lr iq oj b gy ot ou l ov ow">/* button.html */<br/>&lt;button class="str-button {{class}}"&gt;{{text}}&lt;/button&gt;</span><span id="29ce" class="os lr iq oj b gy ox ou l ov ow">/* primary-button.html */<br/>&lt;button class="str-button--primary {{class}}"&gt;{{text}}&lt;/button&gt;</span><span id="e3bf" class="os lr iq oj b gy ox ou l ov ow">/* secondary-button.html */<br/>&lt;button class="str-button--secondary {{class}}"&gt;{{text}}&lt;/button&gt;</span></pre><p id="89c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意我们现在是如何使用主要和次要修饰符后缀来分隔类名的。您还可以添加其他状态作为修改器，例如活动、禁用等。</p><p id="e833" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些都使得样式更容易构建和理解:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="d088" class="os lr iq oj b gy ot ou l ov ow">@mixin default-button {<br/>  /* default button style */</span><span id="c147" class="os lr iq oj b gy ox ou l ov ow">  &amp;:hover {<br/>    transform: scale(1.1);<br/>  }</span><span id="d81d" class="os lr iq oj b gy ox ou l ov ow">  &amp;:active {<br/>    opacity: 0.6;<br/>    transform: scale(0.9);<br/>  }<br/>}</span><span id="a6a9" class="os lr iq oj b gy ox ou l ov ow">.str-button {<br/>  @include default-button;</span><span id="e586" class="os lr iq oj b gy ox ou l ov ow">  &amp;--primary {<br/>    @include default-button;<br/>    background-color: var(--primary);<br/>    color: var(--background);<br/>  }</span><span id="4b67" class="os lr iq oj b gy ox ou l ov ow">  &amp;--secondary {<br/>    @include default-button;<br/>    background-color: var(--text);<br/>    color: var(--background);<br/>  }<br/>}</span></pre><p id="8367" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这很酷！</p><p id="026e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们现在准备好创建我们的第一个班级了！我们将其添加到<code class="fe og oh oi oj b">Button.js</code>文件中:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="99d7" class="os lr iq oj b gy ot ou l ov ow">class Button {<br/>  constructor(DOMelement, clickCallback = () =&gt; {}) {<br/>    this.el = DOMelement;<br/>    this.el.addEventListener("click", clickCallback);<br/>   }<br/>}</span><span id="aa58" class="os lr iq oj b gy ox ou l ov ow">export default Button;</span></pre><p id="9266" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就组件逻辑而言，这可能是我们能做到的最简单的了。我们的类向传入的DOM元素添加了一个click事件侦听器，并分配了click回调函数。</p><p id="bab0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些逻辑都发生在<code class="fe og oh oi oj b">constructor</code>内部，当您用<code class="fe og oh oi oj b">new</code>关键字创建一个新的类实例时，这个逻辑只运行一次。您可以使用构造函数在开始时设置实例。构造函数接收的参数值是在实例化新的类实例时传入的值:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="f9af" class="os lr iq oj b gy ot ou l ov ow">new Button(DOMelement, clickCallback);</span></pre><p id="57f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong> </a> <strong class="kh ir"> ^ </strong></p><h1 id="6a3b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">主应用程序文件</h1><p id="1460" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">要在另一个文件中使用我们的组件类，您所要做的就是导入它，然后选择一个DOM元素并使用<code class="fe og oh oi oj b">new</code>关键字。让我们在<code class="fe og oh oi oj b">index.js</code>条目文件中这样做，这样我们可以讨论一些其他的事情:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="f02b" class="os lr iq oj b gy ot ou l ov ow">import Button from "./components/button/Button";<br/>import "./style.scss";</span><span id="9d88" class="os lr iq oj b gy ox ou l ov ow">function initialise() {<br/>  const myButtonDOM = document.querySelector(".home__test-button");<br/>  const callback = () =&gt; {<br/>    console.log("The button was clicked!!");<br/>  };<br/>  const myButton = new Button(myButtonDOM, callback);<br/>}</span><span id="3e8a" class="os lr iq oj b gy ox ou l ov ow">document.addEventListener("DOMContentLoaded", initialise);</span></pre><p id="de2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个文件本质上是我们应用程序的入口点。最后一行负责在页面加载完成后调用main函数。然后我们首先获取按钮DOM元素并创建一个回调函数，然后从<code class="fe og oh oi oj b">Button</code>类中初始化按钮的一个新实例，并将其保存到<code class="fe og oh oi oj b">myButton</code>变量中。</p><p id="f57d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们类的所有属性和方法都可以在实例上访问。在这个简单的类中，我们没有方法，只有一个属性<code class="fe og oh oi oj b">this.el</code>，我们将传入的DOM元素赋给它:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="2fa8" class="os lr iq oj b gy ot ou l ov ow">/* The instance can return the original DOM element */<br/>myButton.el</span></pre><p id="691a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，请注意Webpack如何要求导入样式表:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="5564" class="os lr iq oj b gy ot ou l ov ow">import "./style.scss";</span></pre><p id="1dba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong> </a> <strong class="kh ir"> ^ </strong></p><h1 id="3850" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">弹出模式组件</h1><p id="244c" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">现在我们已经了解了基础知识，让我们引入一个更复杂的弹出模态组件。</p><p id="a504" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的模态组件需要是一个HTML模块，这样我们就可以从页面模板本身传入模态内容:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="94ee" class="os lr iq oj b gy ot ou l ov ow">&lt;module href="src/components/modal/modal.html" locals='{"id": "info-modal"}'&gt;<br/>  &lt;p&gt;I don't think I have anything else to say...&lt;/p&gt;<br/>  &lt;include src="components/button/button-primary.html"&gt;<br/>    {<br/>      "text": "Close Modal",<br/>      "class": "home__close-modal"<br/>    }<br/>  &lt;/include&gt;<br/>&lt;/module&gt;</span></pre><p id="491c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模式将包含一段文本和一个按钮来关闭自己。除此之外，我们还为这个模型传入一个ID，为这个按钮传入一个标签和一个类名。</p><p id="80d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模态组件将把您传入的内容放在它的HTML模板(src/components/modal/modal . HTML)中的<code class="fe og oh oi oj b">&lt;content&gt;</code>标签的位置:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="8ab7" class="os lr iq oj b gy ot ou l ov ow">&lt;div class="str-modal str-flex-center" id="{{id}}"&gt;<br/>  &lt;div class="str-modal__container"&gt;<br/>    &lt;button type="button" class="str-modal__close"&gt;Close&lt;/button<br/>    &lt;div class="str-modal__content"&gt;<br/><strong class="oj ir">      &lt;content&gt;&lt;/content&gt;</strong><br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="8b92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们继续讨论模态类的应用程序逻辑:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="85d9" class="os lr iq oj b gy ot ou l ov ow">class Modal {<br/>  constructor(DOMelement, openButtonsDOMlist, closeButtonsDOMlist,openCallback, closeCallback) {</span><span id="ec0b" class="os lr iq oj b gy ox ou l ov ow">    this.isOpen = false;<br/>    this.el = DOMelement;<br/>    this.contentWrapper = DOMelement.querySelector(".str-modal__content");<br/>    this.openButtons = openButtonsDOMlist;<br/>    this.openCallback = openCallback;<br/>    this.ownCloseButton = DOMelement.querySelector(".str-modal__close");<br/>    this.closeButtons = closeButtonsDOMlist;<br/>    this.closeCallback = closeCallback</span><span id="2431" class="os lr iq oj b gy ox ou l ov ow">    [...openButtonsDOMlist].forEach((button) =&gt; {<br/>      button.addEventListener("click", (event) =&gt; {<br/>        event.preventDefault();<br/>        this.open();<br/>      });<br/>    });</span><span id="0f3d" class="os lr iq oj b gy ox ou l ov ow">    [...closeButtonsDOMlist, this.ownCloseButton].forEach((button) =&gt; {<br/>      button.addEventListener("click", (event) =&gt; {<br/>        event.preventDefault();<br/>        this.close();<br/>      });<br/>    });<br/>  }</span><span id="8bcf" class="os lr iq oj b gy ox ou l ov ow">  open() {<br/>    this.isOpen = true;<br/>    this.el.classList.add("opened");<br/>    document.querySelector("html").classList.add("modal-open");<br/>    this.openCallback();<br/>  }</span><span id="25d2" class="os lr iq oj b gy ox ou l ov ow"> close() {<br/>    this.isOpen = false;<br/>    this.el.classList.remove("opened");<br/>    document.querySelector("html").classList.remove("modal-open");<br/>    this.closeCallback();<br/>  }<br/>}</span><span id="af7f" class="os lr iq oj b gy ox ou l ov ow">export default Modal;</span></pre><p id="7a1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能看起来需要消化很多，但是构造函数的前半部分只是将值保存到<code class="fe og oh oi oj b">this</code>对象中，使其在整个类和所有实例中都可用。</p><p id="bd65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像以前一样，我们将模态容器的DOM元素保存到<code class="fe og oh oi oj b">this.el</code>，我们还将内部内容包装器和内部关闭按钮保存到<code class="fe og oh oi oj b">this.contentWrapper</code>和<code class="fe og oh oi oj b">this.ownCloseButton</code>。需要记住的一件重要事情是不要使用<code class="fe og oh oi oj b">document.querySelector</code>,因为那样会获取整个页面上给定类的所有元素，而不仅仅是当前组件实例。取而代之的是，你使用<code class="fe og oh oi oj b">this.el.querySelector</code>,因为它只会查看所提供的DOM元素内部，也就是我们正在处理的当前模态窗口DOM元素。</p><p id="45f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续，我们还将<code class="fe og oh oi oj b">this.isOpen</code>设置为<code class="fe og oh oi oj b">false</code>，它保持模态的打开状态，并且<strong class="kh ir">将基本上作为本地状态</strong>运行。</p><p id="5565" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模态组件也可以接受一个打开和关闭按钮的传入列表(DOM元素列表),所以我们也把它们保存在<code class="fe og oh oi oj b">this</code>对象上。这些按钮将能够控制模态并打开和关闭它。</p><p id="993c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以传入可选的“打开时”和“关闭时”回调函数，当这些事件在模型的生命周期中发生时，这些函数将被触发。</p><p id="6752" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe og oh oi oj b">class</code>的<code class="fe og oh oi oj b">constructor</code>中做的最后一件事是遍历打开和关闭按钮，并为每个按钮添加一个事件监听器。在事件监听器的回调中，我们分别调用两个内部方法<code class="fe og oh oi oj b">open</code>和<code class="fe og oh oi oj b">close</code>。</p><p id="17c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以本质上，<strong class="kh ir">我们的类所做的就是获取一个打开和关闭按钮的列表，并确保当任何打开和关闭按钮被按下时</strong> <code class="fe og oh oi oj b"><strong class="kh ir">open</strong></code> <strong class="kh ir">和</strong> <code class="fe og oh oi oj b"><strong class="kh ir">close</strong></code> <strong class="kh ir">方法被调用。</strong></p><p id="4ab5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看<code class="fe og oh oi oj b">open</code>方法内部发生了什么:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="d233" class="os lr iq oj b gy ot ou l ov ow">open() {<br/>  this.isOpen = true;<br/>  this.el.classList.add("opened");<br/>  document.querySelector("html").classList.add("modal-open");<br/>  this.openCallback();<br/>}</span></pre><p id="215b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将内部打开状态改为<code class="fe og oh oi oj b">true</code>，并将包装器DOM元素的类名改为<code class="fe og oh oi oj b">opened</code>。然后可以在CSS中使用这个类来隐藏/显示模式:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="7fd1" class="os lr iq oj b gy ot ou l ov ow">.str-modal {<br/>  display: none;</span><span id="56bb" class="os lr iq oj b gy ox ou l ov ow">  &amp;.opened {<br/>    display: flex;<br/>  }</span><span id="bedd" class="os lr iq oj b gy ox ou l ov ow">  /* Rest of the styling */<br/>}</span></pre><p id="410e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们还将<code class="fe og oh oi oj b">modal-open</code>类添加到整个文档的<code class="fe og oh oi oj b">&lt;html&gt;</code>元素中。这是为了以防万一，例如，当模态打开时，防止在主体内滚动:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="bec9" class="os lr iq oj b gy ot ou l ov ow">html {<br/>  scroll-behavior: smooth;<br/>  overflow-y: auto;</span><span id="a258" class="os lr iq oj b gy ox ou l ov ow">  &amp;.modal-open {<br/>    overflow: hidden;<br/>  }<br/>}</span></pre><p id="5db1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们触发<code class="fe og oh oi oj b">onCloseCallback</code>函数，该函数是在模式初始化时传入的。就是这样！</p><p id="0257" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe og oh oi oj b">close</code>方法与此完全相同，但方向相反:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="b769" class="os lr iq oj b gy ot ou l ov ow">close() {<br/>  this.isOpen = false;<br/>  this.el.classList.remove("opened");<br/>  document.querySelector("html").classList.remove("modal-open");<br/>  this.closeCallback();<br/>}</span></pre><p id="17bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，<code class="fe og oh oi oj b">Modal</code>类完成了！那么我们现在如何使用这个新组件呢？</p><p id="b9ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在主<code class="fe og oh oi oj b">index.js</code>文件中初始化<code class="fe og oh oi oj b">initialise</code>函数内的类，就像我们对按钮示例所做的一样:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="0e31" class="os lr iq oj b gy ot ou l ov ow">// Buttons for modal<br/>const openButtons = document.querySelectorAll(".home__open-modal");<br/>const closeButtons = document.querySelectorAll(".home__close-modal");</span><span id="8dca" class="os lr iq oj b gy ox ou l ov ow">[...openButtons, ...closeButtons].forEach((button) =&gt;<br/>  new Button(button));</span><span id="16f8" class="os lr iq oj b gy ox ou l ov ow">// Modal<br/>const modalContainer = document.getElementById("info-modal");<br/>new Modal(modalContainer, openButtons, closeButtons, () =&gt; {<br/>  console.log("Modal opened!!");<br/>}, () =&gt; {<br/>  console.log("Modal closed!!");<br/>});</span></pre><p id="3607" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让模式工作，我们需要首先初始化按钮。我们用<code class="fe og oh oi oj b">.home__open-modal</code>类选择所有打开按钮，用<code class="fe og oh oi oj b">.home__close-modal</code>类选择所有关闭按钮。然后我们将它们合并成一个数组，并用<code class="fe og oh oi oj b">Button</code>类初始化它们。</p><p id="13df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们获取带有<code class="fe og oh oi oj b">info-modal</code> ID的模态容器，然后将所有按钮和回调传递给<code class="fe og oh oi oj b">new Modal()</code>调用。</p><p id="b160" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，模态就完全工作了:你可以点击“打开模态”按钮，然后你可以用模态组件提供的X按钮和我们在模板中定义的作为模态内容一部分的附加关闭按钮来关闭它。</p><p id="b797" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，模态在内部处理所有的逻辑，我们甚至没有将模态实例保存到变量中。但是如果我们这么做了呢？</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="1d3e" class="os lr iq oj b gy ot ou l ov ow">const infoModal = new Modal(...);</span></pre><p id="ee4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在将模态实例保存到一个变量中，这给了我们很大的灵活性。<code class="fe og oh oi oj b">infoModal</code>现在包含了关于模态的所有信息，你可以通过访问它的内部属性来发现模态是否打开:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="093e" class="os lr iq oj b gy ot ou l ov ow">infoModal.isOpen</span></pre><p id="7148" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将根据模态的状态返回<code class="fe og oh oi oj b">true</code>或<code class="fe og oh oi oj b">false</code>。</p><p id="c7ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以通过调用实例上的方法随时打开或关闭模式:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="786e" class="os lr iq oj b gy ot ou l ov ow">infoModal.open();<br/>infoModal.close();</span></pre><p id="cbc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你愿意，你可以把这些作为一个按钮的点击回调来传递，这给了我们另一种让按钮控制模态的方法:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="6619" class="os lr iq oj b gy ot ou l ov ow">new Button(buttonEl, infoModal.open);</span></pre><p id="ab94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者一个切换按钮？？</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="4ac0" class="os lr iq oj b gy ot ou l ov ow">new Button(buttonEl, () =&gt; {<br/>  if (infoModal.isOpen) {<br/>    infoModal.close();<br/>  } else {<br/>    infoModal.open();<br/>  }<br/>});</span></pre><p id="a26a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">讨论这些组件在更复杂的系统中结合的所有可能性和方式是不可能的，因为我们所处理的只是普通的旧JavaScript，而天空是无限的！</p><p id="fe42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong></a>t14】^</p><h1 id="aef3" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">全局应用程序状态</h1><p id="0884" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">我们现在可以看到如何创建和初始化组件，以及它们如何处理内部状态，公开方法和属性，传递回调，最重要的是，彼此交互。</p><p id="87c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在多个组件和级别之间传递值和回调很容易引入不必要的复杂性，更重要的是很难跟踪错误。</p><p id="22cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，<strong class="kh ir">我们需要一个全局状态管理系统</strong>，比如Redux、Flux或React Context。如果我们想让事情变得简单，我们需要创建自己的系统！</p><p id="6f52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们将在这个全局状态中管理单个属性:<strong class="kh ir">全局亮度主题</strong>，它可以是<strong class="kh ir">暗</strong>或<strong class="kh ir">亮</strong>。</p><p id="4643" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看我们最终会得到什么样的界面，以了解我们实际上在构建什么！</p><p id="ca30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单独的状态(暗或亮)将是一个简单的字符串“暗”或“亮”，当我们最终从我们的存储(本质上是我们的状态管理类实例)中检索到状态时，我们将能够将该状态与一个字符串进行比较:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="9454" class="os lr iq oj b gy ot ou l ov ow">// Theme is set to dark<br/>store.getState().brightnessTheme === "dark"</span><span id="abec" class="os lr iq oj b gy ox ou l ov ow">// Theme is set to light<br/>store.getState().brightnessTheme === "light"</span></pre><p id="8b40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将能够在应用程序的任何地方获取状态，并根据当前主题执行操作。</p><p id="15ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，您也可以随时随地改变状态本身:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="4efe" class="os lr iq oj b gy ot ou l ov ow">store.dispatch(<br/>  setBrightnessTheme("dark")<br/>);</span></pre><p id="6652" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您可以订阅更改，并在状态更改时做一些事情:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="7135" class="os lr iq oj b gy ot ou l ov ow">store.subscribeValue("brightnessTheme", (theme) =&gt; {<br/>  // This function is called when brightnessTheme changes<br/>  // The theme we get is the new value<br/>});</span></pre><p id="a7bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能听说过<strong class="kh ir">在代码中使用神奇的字符串或神奇的数字被认为是不好的做法</strong>。这些是没有保存到变量中的字符串或数字值，所以它们没有任何关于它们来自哪里以及它们代表什么的解释。</p><p id="fa47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们在状态的生命周期中多次输入“黑暗”和“光明”,这很容易出错。相反，您希望在一个地方定义所有可能的值:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="39f0" class="os lr iq oj b gy ot ou l ov ow">const BrightnessTheme = {<br/>  Dark: "dark",<br/>  Light: "light",<br/>};</span><span id="0860" class="os lr iq oj b gy ox ou l ov ow">export { BrightnessTheme };</span></pre><p id="f5ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将你的价值观与这些进行比较:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="b2ab" class="os lr iq oj b gy ot ou l ov ow">import { BrightnessTheme } from "../store/enums";</span><span id="b2cb" class="os lr iq oj b gy ox ou l ov ow">// Theme is set to dark<br/>store.getState().brightnessTheme === BrightnessTheme.Dark</span><span id="8cde" class="os lr iq oj b gy ox ou l ov ow">// Theme is set to light<br/>store.getState().brightnessTheme === BrightnessTheme.Light</span></pre><p id="8e1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">额外的好处是，一旦像这样定义了值，就可以通过VSCode获得IntelliSense建议:</p><figure class="nw nx ny nz gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oz"><img src="../Images/d61a96c8e67c681f068c314a4caf6bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hpt_3Efg56paxAh3zGTn7w.png"/></div></div></figure><p id="b2ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在犯错误变得更加困难，你不再需要记住所有可用的选项。</p><p id="7a62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">^</strong>T7<strong class="kh ir">回顶</strong>T10<strong class="kh ir">^</strong></p><h1 id="3b7d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">创建商店和减速器</h1><p id="3772" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated"><strong class="kh ir">存储本质上是我们的状态容器</strong>，我们将把它实现为一个JavasScript类。它将存储状态，并为我们提供上面提到的方法，如<code class="fe og oh oi oj b">getState</code>、<code class="fe og oh oi oj b">dispatch</code>、<code class="fe og oh oi oj b">subscribeValue</code>。</p><p id="559b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你没有使用过现代框架，状态本质上是一个值(字符串、数字、布尔值、对象等)。)定义了应用程序的某种“状态”,所以当它发生变化时，我们通常希望UI也能更新和重新呈现。</p><p id="aa3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存储本身非常简单，实际上它自己做不了多少事情，相反，大部分状态处理将发生在reducer内部。</p><p id="5d56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缩减器<strong class="kh ir">是一个函数，它采用一个动作和应用程序的先前状态，并返回新状态</strong>。动作描述了意图是什么，reducer函数将基于动作和动作传递的任何潜在值返回新的和可能修改的状态。</p><p id="74ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的状态对象可以包含多个单独的状态属性。我们的只有一个:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="d7ac" class="os lr iq oj b gy ot ou l ov ow">{<br/>  brigthnessTheme: BrightnessTheme.Dark<br/>}</span></pre><p id="c96b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们假设动作是“将亮度主题改为光”。我们将这些动作定义为对象:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="65ac" class="os lr iq oj b gy ot ou l ov ow">{<br/>  type: "setBrightnessTheme",<br/>  payload: "light",<br/>}</span></pre><p id="7621" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些信息，reducer函数应该能够计算出新的状态，并返回更新后的值:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="b7c7" class="os lr iq oj b gy ot ou l ov ow">{<br/>  brigthnessTheme: BrightnessTheme.Light<br/>}</span></pre><p id="8d6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的action对象的惟一问题是它使用了一个神奇的字符串作为action类型，并且有效负载被硬编码为“light”。让我们在一个<code class="fe og oh oi oj b">ActionType</code>对象中捕获动作类型的值，然后创建一个名为<code class="fe og oh oi oj b">setBrightnessTheme</code>的函数，它接受一个有效载荷值(亮或暗)并返回已经按预期填充的动作对象:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="84e0" class="os lr iq oj b gy ot ou l ov ow">export const ActionType = {<br/>  SetBrightnessTheme: "setBrightnessTheme",<br/>};</span><span id="2b09" class="os lr iq oj b gy ox ou l ov ow">export const setBrightnessTheme = (payload) =&gt; ({<br/>  type: ActionType.SetBrightnessTheme,<br/>  payload: payload,<br/>});</span><span id="3ad9" class="os lr iq oj b gy ox ou l ov ow">export default ActionType;</span></pre><p id="3be1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以调用该函数，并获得添加了正确类型和有效负载的正确操作对象:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="be7c" class="os lr iq oj b gy ot ou l ov ow">setBrightness(BrightnessTheme.Light)</span></pre><p id="1b78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于所有这些和我们最初的目标，这就是减压器功能的样子:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="cda4" class="os lr iq oj b gy ot ou l ov ow">import { BrightnessTheme } from "./enums";</span><span id="952c" class="os lr iq oj b gy ox ou l ov ow">const initialState = {<br/>  brightnessTheme: BrightnessTheme.Light,<br/>};</span><span id="887b" class="os lr iq oj b gy ox ou l ov ow">const reducer = (state = initialState, action) =&gt; {<br/>  switch (action?.type) {<br/>    case ActionType.SetBrightnessTheme:<br/>      return {<br/>        ...state,<br/>        brightnessTheme: action.payload,<br/>      }; <br/>    <br/>    default:<br/>      return state;<br/>    }<br/>};</span><span id="fbfe" class="os lr iq oj b gy ox ou l ov ow">export default reducer;</span></pre><p id="8136" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看这里发生了什么。因此，我们可以看到，缩减器需要旧状态，因为它需要基于旧状态返回新状态。reducer还需要action对象来计算新的状态。</p><p id="3e68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的reducer的switch语句中，我们实际上只接受一种动作类型，如果这种类型匹配，那么我们就用作为动作对象的<code class="fe og oh oi oj b">payload</code>属性传入的新值替换状态的<code class="fe og oh oi oj b">brightnessTheme</code>值。</p><p id="03e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，注意如何用<code class="fe og oh oi oj b">...state</code>将旧状态复制到返回值中。这确保了所有其他值都不加修改地返回。目前我们只有<code class="fe og oh oi oj b">brightnessTheme</code>，但这在未来可能会改变。</p><p id="bab4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能遇到的唯一另一种情况是当我们没有收到动作类型或者动作类型不匹配时。在这种情况下，我们进入switch语句的缺省分支，并不加修改地返回旧状态。</p><p id="1888" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建商店:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="c0b3" class="os lr iq oj b gy ot ou l ov ow">class Store {<br/>  constructor(reducer, initialState) {<br/>    this.reducer = reducer;<br/>    this.state = initialState || this.reducer();<br/>  }<br/>  <br/>  getState() {<br/>    return this.state;<br/>  }</span><span id="fb9d" class="os lr iq oj b gy ox ou l ov ow">  dispatch(action) {<br/>    this.state = this.reducer(this.state, action);<br/>  }<br/>}</span><span id="e8cb" class="os lr iq oj b gy ox ou l ov ow">export default Store;</span></pre><p id="062b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，store类的构造函数采用了一个<code class="fe og oh oi oj b">reducer</code>，这是我们刚刚定义的reducer函数，也是一个可选的<code class="fe og oh oi oj b">initalState</code>对象，但是，如果你回到reducer，你可以看到，如果你只是调用它而没有传入任何东西，它将为我们返回一个初始默认状态对象，这解释了我们的构造函数的第二行。</p><p id="5ea2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">store的<code class="fe og oh oi oj b">getState</code>方法再简单不过了:它将返回当前状态对象供我们使用。</p><p id="e043" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe og oh oi oj b">dispatch</code>方法中，我们将分派商店要处理的操作，例如:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="c92a" class="os lr iq oj b gy ot ou l ov ow">myStore.dispatch(<br/>  setBrightness(BrightnessTheme.Light)<br/>);</span></pre><p id="063a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们使用dispatch方法的基本方式:只需<strong class="kh ir">从store实例中调用它，并传入一个action </strong>(带有类型和可选有效负载的action对象)。</p><p id="f605" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在调度方法中，<code class="fe og oh oi oj b">this.state</code>从reducer获得一个全新的状态。</p><p id="cae4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们需要的一个简单的状态管理器和一个存储和一个缩减器！</p><p id="4a1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在应用中使用新商店，我们可以在<code class="fe og oh oi oj b">index.js</code>中初始化它，也可以导出它供其他模块或组件导入和使用:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="9e9b" class="os lr iq oj b gy ot ou l ov ow">export const store = new Store(reducer);</span></pre><p id="be2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从现在开始，您可以在任何地方导入它并调用它的方法:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="f0c6" class="os lr iq oj b gy ot ou l ov ow">import { store } from "../../index";<br/>import { BrightnessTheme } from "../../store/enums";<br/>import { setBrightnessTheme } from "../../store/actions";</span><span id="8479" class="os lr iq oj b gy ox ou l ov ow">// returns either "light" or "dark"<br/><strong class="oj ir">store.getState().brightnessTheme;</strong></span><span id="3290" class="os lr iq oj b gy ox ou l ov ow">// can change the state to "light" or "dark"<br/><strong class="oj ir">store.dispatch(setBrightnessTheme(BrightnessTheme.Light));<br/>store.dispatch(setBrightnessTheme(BrightnessTheme.Dark));</strong></span></pre><p id="9bcb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">^</strong>T9<strong class="kh ir">回顶</strong>T12】t13】^</p><h1 id="676e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">订阅存储更改</h1><p id="2ef5" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">这一切都很好，但现在如果您的任何其他组件使用这个亮度值，他们将需要轮询状态，以了解它是否已经改变。这将涉及获取并检查<code class="fe og oh oi oj b">setInterval</code>中的状态值。</p><p id="a16e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">绝对不是你想做的事！</p><p id="b0d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们希望订阅更改，并在值更改时随时调用回调函数:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="d17d" class="os lr iq oj b gy ot ou l ov ow">store.subscribeValue("brightnessTheme", (theme) =&gt; {<br/>  // This function is called when brightnessTheme changes<br/>  // The theme we get is the new value<br/>});</span></pre><p id="a375" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看这个方法在store类中是什么样子的:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="40c2" class="os lr iq oj b gy ot ou l ov ow">subscribeValue(value, listener) {<br/>  this.valueListeners.push({ value, listener });<br/>}</span></pre><p id="dd92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，我们简单地将状态值的名称和相应的回调函数放入一个名为<code class="fe og oh oi oj b">valueListeners</code>的数组中。</p><p id="9151" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一点要注意:推送里面的对象是<br/> <code class="fe og oh oi oj b">{ value: value, listener: listener }</code>的简称</p><p id="14d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在还可以做的是，当调度一个动作时，遍历该数组，如果状态的值实际上已经改变，则调用值侦听器:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="a6da" class="os lr iq oj b gy ot ou l ov ow">dispatch(action) {<br/>  const oldState = this.state;<br/>  this.state = this.reducer(oldState, action);<br/>  <br/>  this.valueListeners.forEach(({ value, listener }) =&gt; {<br/>    if (oldState[value]) {<br/>      if (oldState[value] !== this.state[value]) {<br/>        listener(this.state[value])<br/>      }<br/>    }<br/>  });<br/>}</span></pre><p id="a211" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">^</strong><a class="ae mt" href="#c369" rel="noopener ugc nofollow">t19】回顶</a>t22】^</p><h1 id="93cb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">ThemeToggle组件</h1><p id="1d25" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">现在有了新的商店，我们可以创建一个新的按钮组件，我们称之为<code class="fe og oh oi oj b">ThemeToggle</code>，并方便地从已经存在的<code class="fe og oh oi oj b">Button</code>组件继承属性和方法。换句话说，我们正在<strong class="kh ir">通过扩展和重用为已经存在的按钮</strong>组件定义的逻辑来创建一个专门的按钮。</p><figure class="nw nx ny nz gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi pa"><img src="../Images/36b99eef3927e4382fd5f0d52bdf937f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4XDEmxwtVGXnrKjPVmBmhQ.png"/></div></div></figure><p id="3718" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击这个按钮将会切换亮暗主题，并自动改变按钮内的文字。</p><p id="7be2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">^</strong>t28<strong class="kh ir">回顶</strong>t32】^</p><h1 id="d406" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">类和模板继承</h1><p id="af54" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">首先，让我们在新的<code class="fe og oh oi oj b">theme-toggle</code>文件夹中定义<code class="fe og oh oi oj b">theme-toggle.html</code>:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="07b4" class="os lr iq oj b gy ot ou l ov ow">&lt;include src="components/button/button.html"&gt;<br/>  {<br/>    "text": "Default",<br/>    "class": "str-theme-toggle {{class}}"<br/>  }<br/>&lt;/include&gt;</span></pre><p id="1b1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个挺好看的！我们不仅扩展和继承了组件的JavaScript逻辑，还扩展和继承了带有自定义类名和一些文本的HTML标记。</p><p id="c859" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们继续上课:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="e758" class="os lr iq oj b gy ot ou l ov ow">import Button from "../button/Button";<br/>import { BrightnessTheme } from "../../store/enums";<br/>import { setBrightnessTheme } from "../../store/actions";<br/>import { store } from "../../index";</span><span id="4343" class="os lr iq oj b gy ox ou l ov ow">class ThemeToggle extends Button {<br/>  constructor(DOMelement, clickCallback = () =&gt; {}) {<br/>    super(DOMelement, clickCallback);<br/>    this.el.addEventListener("click", this.toggleTheme);<br/>    this.currentTheme = store.getState().brightnessTheme;</span><span id="913d" class="os lr iq oj b gy ox ou l ov ow">    store.subscribeValue("brightnessTheme", (theme) =&gt; {<br/>      this.currentTheme = theme;<br/>    });<br/>  }</span><span id="fcc4" class="os lr iq oj b gy ox ou l ov ow">  toggleTheme() {<br/>    if (this.currentTheme === BrightnessTheme.Light) {<br/>      store.dispatch(setBrightnessTheme(BrightnessTheme.Dark));<br/>    } else {<br/>      store.dispatch(setBrightnessTheme(BrightnessTheme.Light));<br/>    }<br/>  }<br/>}</span><span id="ca99" class="os lr iq oj b gy ox ou l ov ow">export default ThemeToggle;</span></pre><p id="d2f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事情变得有点复杂了。最激动人心的是我们导入了<code class="fe og oh oi oj b">Button</code>并定义了新的<code class="fe og oh oi oj b">ThemeToggle</code>作为它的扩展。button组件非常简单:它的构造函数用一个click事件侦听器将传入的回调函数赋给传入的DOM元素，这就是我们想要继承的。不多，但它将作为一个很好的例子！</p><p id="59ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的是要记住，父类的构造函数不是简单地使用<code class="fe og oh oi oj b">extend</code>来执行的。只需这一步，您就可以继承这些方法。</p><p id="eb2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你真的想运行<code class="fe og oh oi oj b">Button</code>类的构造函数，你需要调用<code class="fe og oh oi oj b">super()</code>，并传入预期的DOM元素和回调函数。</p><p id="88e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到<code class="fe og oh oi oj b">ThemeToggle</code>的构造函数中，我们为按钮设置了一个新的事件监听器来调用内部的<code class="fe og oh oi oj b">toggleTheme</code>方法。因此<strong class="kh ir">点击按钮将执行传入的回调函数和内部主题切换方法</strong>。</p><p id="56db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们从存储中获取<code class="fe og oh oi oj b">brightnessTheme</code>值，并将其保存到<code class="fe og oh oi oj b">this.currentTheme</code>，然后订阅任何将来会自动更新<code class="fe og oh oi oj b">this.currentTheme</code>的更改。</p><p id="3e24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<code class="fe og oh oi oj b">toggleTheme</code>函数将根据当前主题调度商店中的主题变化。</p><blockquote class="lb"><p id="8122" class="lc ld iq bd le lf lg lh li lj lk la dk translated">至此，我们已经完成了获取、更新和订阅存储中的值所需的所有逻辑。</p></blockquote><p id="28dc" class="pw-post-body-paragraph kf kg iq kh b ki ll jr kk kl lm ju kn ko ln kq kr ks lo ku kv kw lp ky kz la ij bi translated">但是现在我们的组件应该在UI上做一些实际的工作，实际上把主题从暗变亮，不是吗？</p><p id="25c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些工作都应该属于CSS，所以我们最好的选择是在文档体中简单地切换“黑暗”和“光明”类。这将很好地结合到我们以前做过的主题工作中:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="8782" class="os lr iq oj b gy ot ou l ov ow">body.dark {<br/>  --background: #{$str-black};<br/>  --text: #{$str-white};<br/>  --light: #{$str-dark-brown};<br/>  --accent-dark: #{$str-cream};<br/>}</span></pre><p id="144b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了切换主体上的类，组件还应该更新按钮内的文本，为此，我们可以只使用状态的实际值。下面是实现这一切所需的所有更改，添加到原始类并突出显示:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="6bd4" class="os lr iq oj b gy ot ou l ov ow">import Button from "../button/Button";<br/>import { BrightnessTheme } from "../../store/enums";<br/>import { setBrightnessTheme } from "../../store/actions";<br/>import { store } from "../../index";</span><span id="3d45" class="os lr iq oj b gy ox ou l ov ow">class ThemeToggle extends Button {<br/>  constructor(DOMelement, clickCallback = () =&gt; {}) {<br/>    super(DOMelement, clickCallback);<br/>    this.toggleTheme = this.toggleTheme.bind(this);<br/>    <strong class="oj ir">this.updateBodyClass = this.updateBodyClass.bind(this);<br/>    this.updateText = this.updateText.bind(this);</strong><br/>    this.el.addEventListener("click", this.toggleTheme);<br/>    this.currentTheme = store.getState().brightnessTheme;</span><span id="b47a" class="os lr iq oj b gy ox ou l ov ow">    store.subscribeValue("brightnessTheme", (theme) =&gt; {<br/>      this.currentTheme = theme;<br/><strong class="oj ir">      this.updateBodyClass();<br/>      this.updateText();</strong><br/>    });</span><span id="01ef" class="os lr iq oj b gy ox ou l ov ow"><strong class="oj ir">    this.updateBodyClass();<br/>    this.updateText();</strong><br/>  }</span><span id="13e4" class="os lr iq oj b gy ox ou l ov ow">  toggleTheme() {<br/>    if (this.currentTheme === BrightnessTheme.Light) {<br/>      store.dispatch(setBrightnessTheme(BrightnessTheme.Dark));<br/>    } else {<br/>      store.dispatch(setBrightnessTheme(BrightnessTheme.Light));<br/>    }<br/>  }</span><span id="44d2" class="os lr iq oj b gy ox ou l ov ow">  <strong class="oj ir">updateBodyClass() {<br/>    document.body.classList.remove(<br/>      ...Object.values(BrightnessTheme)<br/>    );<br/>    document.body.classList.add(<br/>      this.currentTheme<br/>    );<br/>  }<br/>  <br/>  updateText() {<br/>    this.el.innerHTML = this.currentTheme;<br/>  }</strong><br/>}</span><span id="96f4" class="os lr iq oj b gy ox ou l ov ow">export default ThemeToggle;</span></pre><p id="1050" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢我用<code class="fe og oh oi oj b">classList</code>玩的把戏😎我使用类名的实际状态值，这样我就可以在<code class="fe og oh oi oj b">Object.values</code>的帮助下从<code class="fe og oh oi oj b">BrightnessTheme</code>获得一个<em class="oy">所有</em>值的列表，并同时删除它们。聪明！</p><p id="3cb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个新组件现在已经完成，所以我们准备在主<code class="fe og oh oi oj b">index.js</code>文件中初始化它:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="11ee" class="os lr iq oj b gy ot ou l ov ow">const themeToggle = document.querySelector(".home__theme-toggle");</span><span id="d9cd" class="os lr iq oj b gy ox ou l ov ow">new ThemeToggle(themeToggle, () =&gt; {<br/>  console.log("Theme toggled!!");<br/>});</span></pre><p id="66f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做的最后一件事是把这个按钮放在页面的右上角。如果我们可以肯定地说，这个定位CSS规则应该应用于应用程序中任何地方使用的每个主题按钮，那么您会希望在组件文件夹中定义它，并将其分配给<code class="fe og oh oi oj b">str-theme-toggle</code>类名。</p><p id="308e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但我个人认为按钮的定位不应该是组件的一部分，相反，这是我们在页面层面上做出的决定。因此，我将把该样式分配给页面级类<code class="fe og oh oi oj b">home__theme-toggle</code>:</p><pre class="nw nx ny nz gt oo oj op oq aw or bi"><span id="ffd5" class="os lr iq oj b gy ot ou l ov ow">.home__theme-toggle {<br/>  position: fixed;<br/>  right: calc(var(--unit) * 4);<br/>  top: calc(var(--unit) * 4);<br/>}</span></pre><p id="3d21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！我们都做完了。</p><p id="a235" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ^ </strong> <a class="ae mt" href="#c369" rel="noopener ugc nofollow"> <strong class="kh ir">回顶</strong> </a> <strong class="kh ir"> ^ </strong></p><h1 id="2c50" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">摘要</h1><p id="63f0" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">我们已经定义了一个普通的JS应用架构，包括类、组件、主题、继承、模板和一个全局状态，还有一个存储和一个缩减器！</p><p id="7a75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释起来要花一点时间，但最终，所有这些都很简单，而且应该很简单，因为它只是我们使用的普通JavaScript，根本没有库。</p><p id="e728" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子有一个带有抽象UI值的主题设置和一个我们可以用按钮切换的深色主题。我们也有一个可以打开和关闭的模式，以及一些应用程序和HTML模板的基本样式。</p><p id="0242" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们围绕文件结构、组件和类以及样式制定的所有规则应该允许您轻松地扩展应用程序，并通过保持清晰来使它变得更加复杂，这是您通常在使用React或任何其他前端框架构建的成熟应用程序中所习惯的。</p><p id="4529" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最感兴趣的是你的意见。你喜欢或不喜欢什么，你会改变什么？</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="7748" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oy">更多内容请看</em><a class="ae mt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oy">plain English . io</em></strong></a><em class="oy">。报名参加我们的</em> <a class="ae mt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="oy">免费周报</em> </strong> </a> <em class="oy">。关注我们关于</em><a class="ae mt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oy">Twitter</em></strong></a><a class="ae mt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oy">LinkedIn</em></strong></a><em class="oy"/><a class="ae mt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oy">YouTube</em></strong></a><em class="oy"/><a class="ae mt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oy">不和</em> </strong> </a> <em class="oy">。</em></p></div></div>    
</body>
</html>