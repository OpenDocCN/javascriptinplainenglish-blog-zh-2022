<html>
<head>
<title>JavaScript: The Most Efficient Way to Check if a Number is a Fibonacci Number</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:检查一个数字是否是斐波纳契数的最有效方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-the-most-efficient-way-to-check-if-a-number-is-a-fibonacci-number-e513618a598d?source=collection_archive---------12-----------------------#2022-12-21">https://javascript.plainenglish.io/javascript-the-most-efficient-way-to-check-if-a-number-is-a-fibonacci-number-e513618a598d?source=collection_archive---------12-----------------------#2022-12-21</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><h2 id="aca6" class="ip iq ir bd b dl is it iu iv iw ix dk iy translated" aria-label="kicker paragraph">毁灭2022</h2><div class=""/><div class=""><h2 id="6dc4" class="pw-subtitle-paragraph jx ja ir bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">利用比奈公式节省时间和资源</h2></div><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/45af3ed228ebf8c774cbfa1a216c30c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbO1VghTPXz4HGyWbRTHsg.jpeg"/></div></div></figure><p id="c796" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">圣诞节快到了，这个多灾多难的2022也接近尾声。我今天没有太多时间，所以我将解决一个与斐波那契数列和JavaScript相关的小问题。我需要一个有效的方法来检查一个数字是否属于斐波纳契数列。最好不必每次都重建数值序列。</p><h1 id="fa43" class="lx ly ir bd lz ma mb mc md me mf mg mh kg mi kh mj kj mk kk ml km mm kn mn mo bi translated">斐波那契数</h1><p id="f89f" class="pw-post-body-paragraph lb lc ir ld b le mp kb lg lh mq ke lj lk mr lm ln lo ms lq lr ls mt lu lv lw ik bi translated">但是让我们从基础开始。首先，什么是斐波那契数列？它是一个整数序列，其中每个数字都是前两个数字的和，除了前两个数字，根据定义，它们是0和1。</p><p id="9b77" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">该系列的第一个元素是数字:</p><blockquote class="mu mv mw"><p id="f17c" class="lb lc mx ld b le lf kb lg lh li ke lj my ll lm ln mz lp lq lr na lt lu lv lw ik bi">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,</p></blockquote><h1 id="963b" class="lx ly ir bd lz ma mb mc md me mf mg mh kg mi kh mj kj mk kk ml km mm kn mn mo bi translated">明显的解决方案</h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/56cb7e319af9f1db455858c0c7b79bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egCtLaC7s4MwRBoqC6R34w.jpeg"/></div></div></figure><p id="f9c8" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">找出一个数是否属于该数列的最明显的解决方法是每次都计算数列本身，直到达到所寻找的数。这是一个函数示例:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="fb2e" class="ng ly ir nc b be nh ni l nj nk">const isFibonacci = (n) =&gt; {<br/>  let a = 0;<br/>  let b = 1;<br/>  if (n == a || n == b) {<br/>    return true;<br/>  }<br/><br/>  let c = a + b;<br/>  while (c &lt;= n) {<br/>    if (c === n) return true;<br/>    a = b;<br/>    b = c;<br/>    c = a + b;<br/>  }<br/>  return false;<br/>};</span></pre><p id="f846" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">这种做法有什么问题？嗯，随着要检查的数量增加，所需的计算时间也会增加。这是一种可行的方法，但在现实世界中没有用。</p><h1 id="ff22" class="lx ly ir bd lz ma mb mc md me mf mg mh kg mi kh mj kj mk kk ml km mm kn mn mo bi translated">更好的解决方案</h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/91ae950d02b3a92c15e2224f9e284213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABjtdGhVDHma9OCSfTTRiw.jpeg"/></div></div></figure><p id="8961" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">为了解决这个问题，稍微研究一下斐波纳契数列的性质是很有用的。维基百科来帮忙了，并引用了雅克·菲利普·玛丽·比奈的话。比奈是法国数学家。在他的发现中，我们可以算出一个公式，它允许我们<a class="ae nl" href="https://en.wikipedia.org/wiki/Jacques_Philippe_Marie_Binet" rel="noopener ugc nofollow" target="_blank">计算斐波那契数列的第n个数字</a>:</p><blockquote class="mu mv mw"><p id="ae7a" class="lb lc mx ld b le lf kb lg lh li ke lj my ll lm ln mz lp lq lr na lt lu lv lw ik bi translated">f(n)=(φ^n-(1-φ)^n)/sqrt(5)</p></blockquote><p id="90de" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">其中<code class="fe nm nn no nc b">F(n)</code>是斐波那契数列的第n个数字，<code class="fe nm nn no nc b">φ</code> ( <code class="fe nm nn no nc b">phi</code>)是黄金分割比例，大约等于<code class="fe nm nn no nc b">1.61803398875.</code></p><p id="0920" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">下面是一个JavaScript函数，它实现了计算第n个斐波那契数的比奈公式:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="f594" class="ng ly ir nc b be nh ni l nj nk">const fibonacci = (n) =&gt; {<br/>  const phi = (1 + Math.sqrt(5)) / 2;<br/>  return Math.round(<br/>    (Math.pow(phi, n + 1) - Math.pow(1 - phi, n + 1)) / Math.sqrt(5)<br/>  );<br/>};</span></pre><p id="7b16" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">或者，如果您愿意，您可以使用以下功能:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="ca8a" class="ng ly ir nc b be nh ni l nj nk">const fibonacci = (n) =&gt; {<br/>  const x = n - 1;<br/>  const sqr = 5 ** 0.5;<br/>  const a = (1 + sqr) ** x;<br/>  const b = (1 - sqr) ** x;<br/>  const c = 2 ** x * sqr;<br/>  return Math.round((a - b) / c);<br/>};</span></pre><p id="3225" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">这个函数有一个参数<code class="fe nm nn no nc b">n</code>，它是要计算的斐波那契数列的索引。它返回计算出的斐波那契数。</p><p id="2b33" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">例如，要计算第8个斐波那契数，可以像这样调用函数:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="216d" class="ng ly ir nc b be nh ni l nj nk">console.log(fibonacci(8)); // Output: 13</span></pre><p id="7581" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">从比奈公式出发，我可以推导出一个公式来检验一个数是否属于斐波纳契数列:</p><blockquote class="mu mv mw"><p id="8b65" class="lb lc mx ld b le lf kb lg lh li ke lj my ll lm ln mz lp lq lr na lt lu lv lw ik bi translated">如果(5 * N + 4)或(5 * N — 4)是一个完美的平方，那么这个数就是斐波纳契数列的一部分</p></blockquote><p id="c714" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">基于这个定义，我可以编写函数<code class="fe nm nn no nc b">isFibonacci(n)</code>:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="e565" class="ng ly ir nc b be nh ni l nj nk">const isFibonacci = (n) =&gt; {<br/>  const x1 = 5 * n ** 2 + 4;<br/>  const x2 = 5 * n ** 2 - 4;<br/>  return Number.isInteger(Math.sqrt(x1)) || Number.isInteger(Math.sqrt(x2));<br/>};</span></pre><p id="7b12" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">这个函数有一个参数<code class="fe nm nn no nc b">n</code>，它是要检查的数字。如果数字是斐波纳契数，它返回<code class="fe nm nn no nc b">true</code>，否则返回<code class="fe nm nn no nc b">false</code>。</p><p id="55e9" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">例如，要检查数字13是否是斐波纳契数，您可以像这样调用函数:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="96c5" class="ng ly ir nc b be nh ni l nj nk">console.log(isFibonacci(13)); // Output: true</span></pre><p id="00fb" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我可以更简洁地编写相同的函数:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="f536" class="ng ly ir nc b be nh ni l nj nk">const isFibonacci = (n) =&gt;<br/>  Number.isInteger((5 * n ** 2 + 4) ** 0.5) ||<br/>  Number.isInteger((5 * n ** 2 - 4) ** 0.5);</span></pre><h1 id="45f4" class="lx ly ir bd lz ma mb mc md me mf mg mh kg mi kh mj kj mk kk ml km mm kn mn mo bi translated">如何求一个数在斐波那契数列中的位置？</h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/e98e20daac57227a3289f4ce56d8e61e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Jt9j3pKHHKfS8Q2SbDNvg.jpeg"/></div></div></figure><p id="0dfc" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">总而言之，我们编写了一个JavaScript函数来计算第n个斐波那契数列(<code class="fe nm nn no nc b">fibonacci(n)</code>)和另一个函数来检查一个数是否属于斐波那契数列(<code class="fe nm nn no nc b">isFibonacci(n)</code>)。现在我们只需要写一个函数来计算一个斐波那契数在序列中的位置。</p><p id="af8a" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">最简单的解决方案也是最耗费资源和时间的:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="e7dd" class="ng ly ir nc b be nh ni l nj nk">const fibonacciPosition = (n) =&gt; { {<br/>  let position = 0;<br/>  let current = 0;<br/>  let next = 1;<br/>  while (current &lt; n) {<br/>    position++;<br/>    let temp = current;<br/>    current = next;<br/>    next = temp + current;<br/>  }<br/>  if (current === n) {<br/>    return position + 1;<br/>  } else {<br/>    return -1;<br/>  }<br/>}</span></pre><p id="349b" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我们可以再次用比奈公式写出一个更好的函数:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="250b" class="ng ly ir nc b be nh ni l nj nk">const fibonacciPosition = (n) =&gt; {<br/>  // Calculate the golden ratio<br/>  const phi = (1 + Math.sqrt(5)) / 2;<br/><br/>  // Calculate the position using the formula<br/>  const position = Math.log(n * 5 ** 0.5 + 0.5) / Math.log(phi);<br/><br/>  // Return the position as an integer<br/>  return Math.floor(position) + 1;<br/>};</span></pre><p id="fed0" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">但是，有一个问题。数列中的第一个数字很特殊:它们是斐波那契数列本身定义的一部分。尽管这是一种糟糕的编程实践，但在这种情况下，在开始时添加几个条件是值得的:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="8478" class="ng ly ir nc b be nh ni l nj nk">const fibonacciPosition = (n) =&gt; {<br/>  if (n === 0) return 1;<br/>  if (n === 1) return 2;<br/><br/>  const phi = (1 + Math.sqrt(5)) / 2;<br/>  const position = Math.log(n * 5 ** 0.5 + 0.5) / Math.log(phi);<br/>  return Math.floor(position) + 1;<br/>};</span></pre><p id="4672" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">最后，还有一个条件要查，最好是先查。如果这个数字不是斐波那契数，那么我们可以跳过所有的计算并返回值<code class="fe nm nn no nc b">-1</code>:</p><pre class="kq kr ks kt gu nb nc nd bn ne nf bi"><span id="868a" class="ng ly ir nc b be nh ni l nj nk">const fibonacciPosition = (n) =&gt; {<br/>  if (!isFibonacci(n)) return -1;<br/>  if (n === 0) return 1;<br/>  if (n === 1) return 2;<br/><br/>  const phi = (1 + Math.sqrt(5)) / 2;<br/>  const position = Math.log(n * 5 ** 0.5 + 0.5) / Math.log(phi);<br/>  return Math.floor(position) + 1;<br/>};</span></pre><p id="0720" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">到此，我想我们已经完成了主题。</p><p id="c144" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">但是在我们说再见之前，有一个小注意。在函数中，我将数字<code class="fe nm nn no nc b">1</code>添加到位置(在<code class="fe nm nn no nc b">fibonacciPosition(n)</code>和<code class="fe nm nn no nc b">fibonacci(n)</code>中)，使第一个位置有索引<code class="fe nm nn no nc b">1</code>。然而，如果我们打算使用数组，因此使用第一个位置的索引为<code class="fe nm nn no nc b">0</code>的对象，那么不添加任何东西会更简单。</p><p id="9932" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">感谢阅读！敬请关注更多内容。</p></div><div class="ab cl np nq hv nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ik il im in io"><p id="9ef0" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><strong class="ld jb"> <em class="mx">不要错过我的下一篇文章—报名参加我的</em> </strong> <a class="ae nl" href="https://medium.com/subscribe/@el3um4s" rel="noopener"> <strong class="ld jb"> <em class="mx">中邮件列表</em> </strong> </a></p><div class="nw nx gq gs ny nz"><a href="https://el3um4s.medium.com/membership" rel="noopener follow" target="_blank"><div class="oa ab fp"><div class="ob ab oc cl cj od"><h2 class="bd jb gz z fq oe fs ft of fv fx ja bi translated">通过我的推荐链接加入Medium—Samuele</h2><div class="og l"><h3 class="bd b gz z fq oe fs ft of fv fx dk translated">阅读萨缪尔的每一个故事(以及媒体上成千上万的其他作家)。不是中等会员？在这里加入一块…</h3></div><div class="oh l"><p class="bd b dl z fq oe fs ft of fv fx dk translated">el3um4s.medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kz nz"/></div></div></a></div></div><div class="ab cl np nq hv nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ik il im in io"><p id="4a2e" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">【https://blog.stranianelli.com】原载于2022年12月21日<a class="ae nl" href="https://blog.stranianelli.com/devadvent-2022-21-how-to-check-if-a-given-number-is-fibonacci-number/" rel="noopener ugc nofollow" target="_blank"><em class="mx"/></a><em class="mx">。</em></p><p id="5fbb" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><em class="mx">更多内容请看</em><a class="ae nl" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ld jb"><em class="mx">plain English . io</em></strong></a><em class="mx">。报名参加我们的</em> <a class="ae nl" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ld jb"> <em class="mx">免费周报</em> </strong> </a> <em class="mx">。关注我们关于</em><a class="ae nl" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ld jb"><em class="mx">Twitter</em></strong></a><a class="ae nl" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ld jb"><em class="mx">LinkedIn</em></strong></a><em class="mx"/><a class="ae nl" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ld jb"><em class="mx">YouTube</em></strong></a><em class="mx"/><a class="ae nl" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ld jb"><em class="mx">不和</em> </strong> </a> <strong class="ld jb"> <em class="mx">。</em>T49】</strong></p><p id="86e1" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><strong class="ld jb"> <em class="mx">对缩放您的软件启动感兴趣</em> </strong> <em class="mx">？检查</em> <a class="ae nl" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="ld jb"> <em class="mx">电路</em> </strong> </a> <em class="mx">。</em></p></div></div>    
</body>
</html>