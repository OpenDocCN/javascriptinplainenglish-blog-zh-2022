<html>
<head>
<title>Recursive Algorithms and Their Time Complexities O(n) vs O(2^n)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归算法及其时间复杂度O(n) vs O(2^n)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recursive-algorithms-and-their-time-complexities-o-n-vs-2-n-713856ad4e2?source=collection_archive---------5-----------------------#2022-09-19">https://javascript.plainenglish.io/recursive-algorithms-and-their-time-complexities-o-n-vs-2-n-713856ad4e2?source=collection_archive---------5-----------------------#2022-09-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d72b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript算法基础第四部分:<strong class="ak"> <em class="kc">线性时间复杂度为O(n)的递归算法&amp;指数时间复杂度O(2^n) </em> </strong></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/afe4a494efc2d1637c5b84fa6b4c2359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zYqhEM9ir6RyGWfa"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fbad" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">递归</strong>是编程中的关键概念之一。作为一种解决问题的方法，它也被广泛应用于<strong class="kw io">数据结构和算法</strong>。它帮助我们把复杂的大问题分解成小问题。因此，理解递归的时间复杂度对于理解和提高代码效率至关重要。</p><p id="3690" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">关于本系列<strong class="kw io"> JavaScript算法</strong>的<strong class="kw io"> part 3 </strong>，可以参考下面的链接。</p><p id="7354" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><a class="ae kt" href="https://medium.com/@code.ceeker/derive-constant-time-complexity-o-1-using-asymptotic-analysis-e786df20fc7b" rel="noopener">第3部分:使用渐近分析导出常数时间复杂度O(1)</a></p><p id="6293" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在本文中，我们将研究递归算法的两个例子及其时间复杂度。</p><ol class=""><li id="4d8d" class="lq lr in kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw io"> <em class="lz">线性时间复杂度为O(n)的递归算法</em> </strong></li><li id="2548" class="lq lr in kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw io"> <em class="lz">具有指数时间复杂度的递归算法【o(2^n】</em></strong></li></ol><p id="c5f4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">首先，简单介绍一下递归。</p><h2 id="d5bd" class="mf mg in bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">什么是递归？</strong></h2><p id="9980" class="pw-post-body-paragraph ku kv in kw b kx my jo kz la mz jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">如果一个函数直接或间接地调用自己，我们说它是递归函数。下面是递归函数的大概样子。</p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="b1b2" class="mf mg in ne b gy ni nj l nk nl">function recursiveFunction() {<br/> return recursiveFunctionn();<br/>}</span></pre><p id="fb4d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上面的函数是递归函数的一个<strong class="kw io">例子，因为它正在调用自己，但是它也是不完整的，因为它会<strong class="kw io">导致一个无限循环</strong>。这是因为该功能没有任何<strong class="kw io">退出条件</strong>。但是，这里的<strong class="kw io">要点是，递归就是从函数内部调用函数。</strong></strong></p><p id="5ab5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了说明得更清楚，我们来看下面一个简单的例子。</p><p id="3ce3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">例题</strong></p><p id="14db" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">创建一个简单的函数来计算输入数字的阶乘。</p><p id="e43b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果你不知道什么是阶乘，看看下面函数的行为，输入如下。</p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="1ae2" class="mf mg in ne b gy ni nj l nk nl">factorial(3);  // 3 * 2 * 1 = 6</span><span id="ba48" class="mf mg in ne b gy nm nj l nk nl">factorial(4);  // 4 * 3 * 2 * 1 = 24</span></pre><p id="e2b9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你把输入的数字，乘以那个数字减1，重复同样的操作，直到你达到1。这是我们计算阶乘的方法。最后，我们可以写一个这样的函数。</p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="5420" class="mf mg in ne b gy ni nj l nk nl">Fn = n * (n - 1) * (n - 2) * (n - 3) * … * 3 * 2 * 1</span><span id="22f6" class="mf mg in ne b gy nm nj l nk nl">5! = 5 * 4 * 3 * 2 * 1 = 120</span></pre><p id="738d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们先来看一个<strong class="kw io">非递归方法</strong>。因为通常，不是总是，递归只是常规循环的一种替代。所以，让我们先用基于循环的方法来解决它。</p><h2 id="d112" class="mf mg in bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">功能(基于循环的方法)</strong></h2><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="e113" class="mf mg in ne b gy ni nj l nk nl">function factorial(n){<br/> let result = 1;<br/> <br/> for(let index = 1; index &lt;= n; index++){<br/>  result = result * index;<br/> }<br/> return result;<br/>}</span></pre><p id="9299" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">所以，这是一个使用普通循环的阶乘函数<strong class="kw io">。使用这样的循环是解决阶乘问题的一个不错的方法。但是<strong class="kw io">也存在一种不同的方法来使用递归</strong>解决上述问题。而且，正如您将进一步看到的，递归将允许我们编写更少的代码，这通常是我们可能想要使用递归的原因之一。</strong></p><h2 id="d477" class="mf mg in bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">递归求解O(n) </strong></h2><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="9d2a" class="mf mg in ne b gy ni nj l nk nl">function factorial(n){<br/> <strong class="ne io">if (n === 1) { </strong>-&gt; Exit condition/Base case<strong class="ne io"><br/>  return 1;<br/> }</strong></span><span id="6600" class="mf mg in ne b gy nm nj l nk nl">return n * <strong class="ne io">factorial(n - 1)</strong>; -&gt; Recursive step<br/>}</span></pre><p id="2e16" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上面的函数是递归的，因为它在调用自己。<strong class="kw io">在函数中有两件重要的事情需要注意，即“if块”和参数为(n-1) </strong>的“函数调用”。</p><p id="4651" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们称if块为<strong class="kw io">“退出条件”或总是返回值的“基本情况”</strong>。并且，<strong class="kw io">“函数调用”为“递归步骤”</strong>。</p><p id="73c9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">另一个需要注意的重要事情是，我们在递归步骤</strong>中向函数调用传递了一个不同的参数。因为，如果我们再次调用带有<strong class="kw io"> n </strong>的函数，我们不会改变任何东西。我们会得到一个无限循环。</p><p id="bab9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> <em class="lz">因此，一个递归函数应该总是有这两个组成部分，即“退出条件”和“递归步骤”，否则我们将总是有一个无限循环，这会使我们的程序崩溃。</em>T19】</strong></p><p id="7d1b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">退出条件</strong>或<strong class="kw io">基本情况</strong>为我们提供了基本条件满足时退出函数的方法。</p><p id="ff60" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">并且，<strong class="kw io">递归步骤</strong>通过对同一个函数进行递归调用来帮助我们<strong class="kw io">计算</strong>结果，但是<strong class="kw io">输入的大小</strong>减小了。</p><p id="2a18" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这可以表示为一连串的函数调用。如下例所示，对于一个<strong class="kw io">事实(4) </strong>，我们将返回<strong class="kw io"> 4 *事实(3) </strong>，这将为我们提供<strong class="kw io"> 3 *事实(2) </strong>，这将再次为我们提供<strong class="kw io"> 2 *事实(1) </strong>。并且，它最终返回<strong class="kw io"> 1 </strong>，然后将计算出的返回值传递给函数调用，导致<strong class="kw io"> 24 </strong>。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi nn"><img src="../Images/87073a049f630b692a6a055a8e1c2f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ho32_IYFzO3OwjJlRD6iCA.png"/></div></div></figure><h2 id="0b9d" class="mf mg in bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">如何推导递归算法的时间复杂度？</strong></h2><p id="4b6e" class="pw-post-body-paragraph ku kv in kw b kx my jo kz la mz jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">根据渐近分析，我们仍然可以对上述函数中的<strong class="kw io">运算</strong>进行计数。因此，每个操作将执行一次，包括return语句中的函数调用。</p><p id="cb76" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是，因为我们在return语句中有一个函数调用。我们开始一个新的函数调用，因此该函数中的所有代码都会再次运行多次，直到满足退出条件。因此，我们可以在这里计算递归函数的函数调用次数。因此，我们可以看到，在上面的例子中，对于4的阶乘，我们得到了<strong class="kw io"> 4个函数调用</strong>。</p><p id="7942" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在每个函数调用中，我们有一个固定的时间，函数中没有任何循环。因此，我们可以这样写。</p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="3377" class="mf mg in ne b gy ni nj l nk nl"><strong class="ne io">T = O(1) =&gt; Time complexity of a single function call</strong></span></pre><p id="3186" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是，当输入值为<strong class="kw io"> n </strong>时，上述函数调用触发了多个函数调用，即<strong class="kw io"> n </strong>函数调用。</p><p id="3711" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">因此，我们对于多个函数调用的时间复杂度是，</p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="6875" class="mf mg in ne b gy ni nj l nk nl"><strong class="ne io">T = n * (Time complexity of individual function)</strong></span></pre><p id="42aa" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">那就是，</p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="a9a7" class="mf mg in ne b gy ni nj l nk nl"><strong class="ne io">T = n * O(1)</strong></span></pre><p id="5e3e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">可以写成，</strong></p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="10c2" class="mf mg in ne b gy ni nj l nk nl"><strong class="ne io">T = O(n)</strong></span></pre><p id="80b1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">上式最后简单来说就是O(n)</strong>。这与基于循环的解决方案的时间复杂度相同，即<strong class="kw io">线性时间复杂度</strong>。</p><p id="b897" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">虽然这是递归算法的一个非常简单的例子，但是我们也有使用递归的算法，因为它们产生的结果比替代解决方案更好。</p><h2 id="188a" class="mf mg in bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">递归算法指数时间复杂度O(2^n) </strong></h2><p id="b9bb" class="pw-post-body-paragraph ku kv in kw b kx my jo kz la mz jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">在前面的例子中，递归看起来不错，我们通常可以编写更少的代码来解决问题。但是，让我告诉你，递归并不总是最好的解决方案。为了证明这一点，我们将看看斐波纳契数列的<strong class="kw io">递归实现。</strong></p><p id="91e1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">功能</strong></p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="d3b6" class="mf mg in ne b gy ni nj l nk nl">function fib(n){<br/> <strong class="ne io">if (n === 0 || n === 1) {  -&gt; Exit Condition<br/>  return 1;<br/> }</strong></span><span id="d69c" class="mf mg in ne b gy nm nj l nk nl">return <strong class="ne io">fib(n-1) + fib(n-2)</strong>; <strong class="ne io">-&gt; Recursive Step</strong><br/>}</span></pre><p id="3338" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上面的函数是一个<strong class="kw io">斐波那契</strong>函数，它启动<strong class="kw io">两个递归函数</strong>，触发新的函数调用，直到满足退出条件。一旦所有这些函数调用都被解析，结果就会冒泡并返回到初始函数。这里这两个函数都将返回一个值，然后将这些值相加。</p><p id="5fe1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">那么，这种方法有什么问题呢？</p><p id="16e1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这种方法的错误在于，当我们调用它时，函数会构建一个跨越多个分支的嵌套递归函数调用树。</p><p id="f321" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这可以在下面的<strong class="kw io"> n = 4 </strong>的示例图中看到。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi no"><img src="../Images/013d05a029fab6bb0950f23426673f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BimfNnb1AHB0tt59tAq6WQ.png"/></div></div></figure><p id="5d1f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如你所见，对于像<strong class="kw io"> 4 </strong>这样的数字，我们得到了<strong class="kw io"> 9个函数调用</strong>。如果我们使用基于循环的解决方案，那么我们将只迭代<strong class="kw io">4次</strong>。这不是一个好的解决方案，因为即使对于像<strong class="kw io"> 4 </strong>这样的较小输入数，也有大约<strong class="kw io"> 9次函数调用</strong>的执行。</p><p id="bd8b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">类似地，函数调用<strong class="kw io">随着<strong class="kw io">输入数</strong>的<strong class="kw io">线性增加</strong>而指数增加</strong>，如下图从<strong class="kw io"> 4到6 </strong>所示。</p><pre class="ke kf kg kh gt nd ne nf ng aw nh bi"><span id="48b6" class="mf mg in ne b gy ni nj l nk nl">fib(4); // 09 executions<br/>fib(5); // 15 executions<br/>fib(6); // 25 executions</span></pre><p id="0d17" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果输入数量进一步增加，情况会变得更糟。</p><p id="bac6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">那么这个递归函数的时间复杂度是多少？</strong></p><p id="a358" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">不一定是O(n)</strong>，这是<strong class="kw io">基于循环的解决方案</strong>的情况。我们得到了对4人的(<strong class="kw io"> 9)次处决，对5人的(15)次处决，对6人的(25)次处决。因此，如果我们将提供给函数的数字增加<strong class="kw io"> 1 </strong>，我们的执行次数就会有<strong class="kw io">的指数增长</strong>。它不是线性增长的</strong>。我们添加的执行数似乎随着我们的n的增大而呈指数增长。</p><p id="1db1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">因此，相对微小的上升需要越来越长的时间。事实上，这个时间尺度的复杂性是指数级的。随着第n个中的每一个增量，我们将整个新的分支添加到这个递归树中，而不仅仅是一个函数调用。此外，每个分支由其他分支组成。结果，这很快增加到我们的机器无法处理的量。因此，对于一个我们已经有线性时间复杂度解决方案的问题，这是一个糟糕的解决方案。<strong class="kw io">像这样的递归函数是次于基于循环的解决方案的一个例子</strong>。这需要更多的时间。虽然看起来很优雅，但这是一个糟糕的解决方案。</p><p id="4529" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">这是一个指数时间复杂度的O(2^n) </strong>。我们确定函数调用的增长，因为它是指数级的，我们可以说这个算法具有指数级的时间复杂度。</p><p id="b362" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">但是，你知道吗，上面的递归指数函数也可以改进成具有线性时间复杂度？如果你知道答案，请在评论里告诉我。</strong></p><p id="f5ca" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">感谢您的阅读。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="4214" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lz">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lz">plain English . io</em></strong></a><em class="lz">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="lz">免费周报</em> </strong> </a> <em class="lz">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lz">Twitter</em></strong></a><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lz">LinkedIn</em></strong></a><em class="lz"/><a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lz">YouTube</em></strong></a><em class="lz"/><a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lz">不和</em> </strong> </a> <em class="lz">。对增长黑客感兴趣？检查</em> <a class="ae kt" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="lz">电路</em> </strong> </a> <em class="lz">。</em></p></div></div>    
</body>
</html>