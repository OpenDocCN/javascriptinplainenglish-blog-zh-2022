<html>
<head>
<title>Multitasking in Node.js Using Worker Pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工作池在Node.js中进行多任务处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/multitasking-in-node-js-using-worker-pool-201ac6dfd0f4?source=collection_archive---------2-----------------------#2022-10-12">https://javascript.plainenglish.io/multitasking-in-node-js-using-worker-pool-201ac6dfd0f4?source=collection_archive---------2-----------------------#2022-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="97fa" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">以下是工作者池库如何管理工作者。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/061f1e83bbaf0da4c511463315d95beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwFRNAmvjbSAPwsc0XqoKQ.png"/></div></div></figure><p id="d137" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">默认情况下，Node.js是单线程的，这意味着如果您的代码中有CPU密集型操作，它可能会阻塞该单线程。<a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/multitasking-in-node-js-with-child-process-d82841fd8d29"> <strong class="kq io">子进程</strong> </a>或<a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/a-brief-guide-on-worker-threads-in-node-js-80bd1e7846cb"> <strong class="kq io">工作线程</strong> </a>可以帮助将这些繁重的操作卸载到单独的工作线程，以便主线程可以自由处理其他传入的请求。手动管理这些工人，虽然肯定是可能的，但总的来说效率不高。有一些图书馆在员工管理方面做得很好，在这篇博客文章中，我们将看到一个名为<strong class="kq io">员工池</strong>的图书馆。</p><p id="ebc4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个工人池背后的基本思想是立即产生一群工人。将会有一个包含所有用户请求的任务队列。这些衍生出来的工作人员将从队列中一个接一个地拾取任务，并独立解决它们。该模式被称为<strong class="kq io">线程池模式</strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ll"><img src="../Images/8d5d8dbc994da6de2aa1a9c4f63f9e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t--1MdjlT5CVEUANpP0Hkw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Thread pool pattern</figcaption></figure><p id="27b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个库最棒的地方在于它运行在nodejs和所有现代浏览器中。所以你可以使用一个工作池来管理<strong class="kq io">网络工作人员</strong>或者你可以管理<strong class="kq io">工作线程/子进程</strong>。让我们看看如何在NodeJS中实现它。</p><p id="4f7f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://youtu.be/yI1PjfXhIpk" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lq">我也有这个帖子的视频可以在Youtube上找到，一定要查看。</em> </strong> </a></p><h2 id="9139" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">基本设置</h2><p id="93ab" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">通过键入<code class="fe mp mq mr ms b">npm init -y</code>创建节点应用程序。通过键入<code class="fe mp mq mr ms b">npm i express</code>安装express(不需要)。创建一个名为<code class="fe mp mq mr ms b">app.js</code>的服务器文件。将下面的代码片段复制到文件中。</p><pre class="kd ke kf kg gt mt ms mu mv aw mw bi"><span id="5616" class="lr ls in ms b gy mx my l mz na">const app = require("express")()</span><span id="38d0" class="lr ls in ms b gy nb my l mz na">const complexCalc = () =&gt; {<br/>    let counter = 0;<br/>    while (counter &lt; 900000000) {<br/>        counter++;<br/>    }<br/>    return counter;<br/>}</span><span id="eca5" class="lr ls in ms b gy nb my l mz na">app.get("/<strong class="ms io">light</strong>", (req, res) =&gt; {<br/>    res.send("Resloved light request, easy peasy!")<br/>})</span><span id="3e60" class="lr ls in ms b gy nb my l mz na">app.get("/<strong class="ms io">heavy</strong>", (req, res) =&gt; {<br/>    complexCalc();<br/>    res.send("Resolved heavy reques, phew!")<br/>})</span><span id="2177" class="lr ls in ms b gy nb my l mz na">app.listen(3000, () =&gt; console.log("Listening to port 3000"))</span></pre><p id="9040" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该脚本有两个端点，一个<code class="fe mp mq mr ms b">light</code>端点和一个<code class="fe mp mq mr ms b">heavy</code>端点。光端点将立即解析，而<code class="fe mp mq mr ms b">heavy</code>端点将进行一些无意义的计算(以模拟阻塞行为)并阻塞该过程中的事件循环。</p><p id="941c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过键入<code class="fe mp mq mr ms b">node app</code>运行该应用程序。先转到<code class="fe mp mq mr ms b">http://localhost:3000/heavy</code>，然后打开另一个标签页，路径为<code class="fe mp mq mr ms b"><a class="ae lk" href="http://localhost:3000/light." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/light</a></code> <a class="ae lk" href="http://localhost:3000/light." rel="noopener ugc nofollow" target="_blank">。</a>很明显<code class="fe mp mq mr ms b">heavy</code>请求需要时间，但结果是<code class="fe mp mq mr ms b">light</code>请求也需要时间。这是因为<code class="fe mp mq mr ms b">heavy</code>请求阻塞了事件循环，而事件循环又阻塞了任何后续请求。</p><h2 id="0329" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">实施工人池</h2><p id="15e3" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">现在，让我们将工作池添加到这个应用程序中，并尝试解决这个问题。要将其安装到您的应用程序中，请键入<code class="fe mp mq mr ms b">npm i workerpool</code>。一旦安装完成，将其导入到顶部的<code class="fe mp mq mr ms b">app.js</code>文件中，<code class="fe mp mq mr ms b">const workerpool = require("workerpool")</code>。</p><p id="cd95" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一步是建立一个工人人才库。你可以通过使用<code class="fe mp mq mr ms b">pool</code>方法来做到这一点，所以<code class="fe mp mq mr ms b">const pool = workerpool.pool()</code>。这个<code class="fe mp mq mr ms b">pool</code>方法可以接受两个可选参数。第一个参数是文件的路径。如果你传入一个文件，这个工人将会产生，它将会执行这个文件。如果你没有传入任何东西作为第一个参数，它将会产生一个默认的worker，你可以在将来使用这个worker来卸载一些任务给它。</p><p id="f741" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二个参数是options对象。它有几个配置，您可以用来设置您的工人池。举个例子，</p><ul class=""><li id="e63a" class="nc nd in kq b kr ks ku kv kx ne lb nf lf ng lj nh ni nj nk bi translated"><strong class="kq io"> minWorkers </strong>:必须初始化并保持可用的最小工作线程数。</li><li id="adac" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><strong class="kq io"> maxWorkers </strong>:可以初始化的最大工作线程数。</li><li id="cc04" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated">maxQueueSize :允许排队的最大任务数。</li><li id="8cde" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><strong class="kq io"> workerType </strong>:您将与之一起工作的工作者的类型(自动、web、进程或线程)。</li></ul><p id="77fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，让我们保持配置为空。我们将创建一个没有配置的简单工作池实例。</p><p id="40aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe mp mq mr ms b">heavy</code>端点中，我们不是直接运行计算，而是将它卸载给worker池中的worker。为此，我们在pool实例上使用了<code class="fe mp mq mr ms b">exec</code>方法，该方法将复杂的计算作为字符串或函数。</p><p id="8d3e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二个可选参数是我们刚刚在exec方法中传递的函数的参数列表。我们将忽略这个参数，因为我们复杂的计算函数没有参数。请记住，这些函数被序列化并传递给worker，所以如果您有一个大的函数或函数参数，它可能会影响性能。</p><p id="f298" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个函数返回一个<code class="fe mp mq mr ms b">promise</code>,因此您可以使用一个回调函数来检查计算是否完成或者是否有错误。最后，当这些工人完成他们的工作时，终止他们是一种好的做法，所以我们也将添加这一点。</p><pre class="kd ke kf kg gt mt ms mu mv aw mw bi"><span id="a45d" class="lr ls in ms b gy mx my l mz na">app.get("/heavy", (req, res) =&gt; {<br/>    <strong class="ms io">pool.exec(complexCalc).then(result =&gt; {<br/>        res.send(`Resolved heavy request. ${result} iterations completed!`)</strong><br/>    }).catch(err =&gt; {<br/>        console.log(err);<br/>    }).then(res =&gt; {<br/>        <strong class="ms io">pool.terminate()</strong><br/>    })<br/>})</span></pre><p id="ae1e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您的<code class="fe mp mq mr ms b">app.js</code>文件现在应该看起来像这样。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9502" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果您保存它，并尝试发出一个<code class="fe mp mq mr ms b">heavy</code>请求，然后发出一个<code class="fe mp mq mr ms b">light</code>请求，您会看到它工作得非常好。<code class="fe mp mq mr ms b">heavy</code>操作被卸载给一个工人，因此事件循环不再被阻塞。因此，这基本上是工人池的最基本的实现。</p><h2 id="e6f3" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">为员工使用单独的文件</h2><p id="592e" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">现在回到<code class="fe mp mq mr ms b">pool</code>方法，我之前提到过，您可以将一个文件的路径作为第一个参数传入。这个派生的工作进程将运行这个文件。让我们试着那样做。</p><p id="e8bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要首先创建工人文件，所以让我们创建它。我就叫它<code class="fe mp mq mr ms b">worker.js</code>。这个文件将具有复杂的计算功能，所以我将它从服务器文件移到这个文件。</p><pre class="kd ke kf kg gt mt ms mu mv aw mw bi"><span id="492c" class="lr ls in ms b gy mx my l mz na">//worker.js<br/>const complexCalc = () =&gt; {<br/>    let counter = 0;<br/>    while (counter &lt; 900000000) {<br/>        counter++;<br/>    }<br/>    return counter;<br/>}</span></pre><p id="b223" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们通过使用<code class="fe mp mq mr ms b">worker</code>方法创建工人。在方法内部，我们传递一个带有<code class="fe mp mq mr ms b">complexCalc</code>函数的对象，所以就像我们在这个worker内部注册我们的函数一样。</p><p id="6450" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在在我们的<code class="fe mp mq mr ms b">app.js</code>文件中，我们将首先添加worker文件的路径。然后在exec方法中，我们必须将它转换成一个字符串，因为它引用了在worker文件中创建的worker实例。您的代码现在应该看起来像这样。</p><pre class="kd ke kf kg gt mt ms mu mv aw mw bi"><span id="9e23" class="lr ls in ms b gy mx my l mz na">//worker.js<br/><strong class="ms io">const workerpool = require("workerpool")</strong></span><span id="1782" class="lr ls in ms b gy nb my l mz na">const complexCalc = () =&gt; {<br/>    let counter = 0;<br/>    while (counter &lt; 900000000) {<br/>        counter++;<br/>    }<br/>    return counter;<br/>}</span><span id="b59d" class="lr ls in ms b gy nb my l mz na"><strong class="ms io">workerpool.worker({<br/>   complexCalc: complexCalc<br/>})</strong></span></pre><p id="4147" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">应用程序文件应该是这样的。</p><pre class="kd ke kf kg gt mt ms mu mv aw mw bi"><span id="0743" class="lr ls in ms b gy mx my l mz na">//app.js<br/>const app = require("express")()<br/>const workerpool = require("workerpool")<br/>const pool = workerpool.pool(<strong class="ms io">"./worker.js"</strong>)<br/> <br/>app.get("/light", (req, res) =&gt; {<br/>    res.send("Resloved light request, easy peasy!")<br/>})</span><span id="a26a" class="lr ls in ms b gy nb my l mz na">app.get("/heavy", (req, res) =&gt; {<br/>    pool.exec(<strong class="ms io">"complexCalc"</strong>).then(result =&gt; {<br/>        res.send(`Resolved heavy request. ${result} iterations completed!`)<br/>    }).catch(err =&gt; {<br/>        console.log(err);<br/>    }).then(() =&gt; {<br/>        pool.terminate()<br/>    })<br/>}) </span><span id="8a10" class="lr ls in ms b gy nb my l mz na">app.listen(3000, () =&gt; console.log("Listening to port 3000"))</span></pre><p id="402f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您现在运行它，它应该像预期的那样工作，也就是说，繁重的操作应该被卸载到worker，而不会阻塞事件循环。</p><h2 id="52f7" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">您的员工库的统计数据</h2><p id="0ab9" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">这个worker pool实例有一个名为<code class="fe mp mq mr ms b">stats</code>的方法，您可以使用它来获得对您的池实例的一些统计洞察。这是一个非常简单的对象，包含关于您的任务和工作人员的基本信息。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/463df7c5f49fff0ffa1e8324d38a808f.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*2UNwuU2nxvAKrOwFTtSGeQ.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">pool.stats()</figcaption></figure><p id="ee2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">尝试将<code class="fe mp mq mr ms b">pool.stats()</code>添加到主文件的不同位置，例如，在复杂计算之前和之后，甚至在<code class="fe mp mq mr ms b">pool.terminate</code>方法之后。你会看到一些有趣的结果。</p><h2 id="dcda" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">从工作人员向池发送消息</h2><p id="ca7e" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">当任务正在执行时，您还可以使用<code class="fe mp mq mr ms b">workerEmit</code>函数将数据从workers发送回池。所以在我们的计算函数中，我将发送两条消息。一个在while循环之前，一个在while循环之后。</p><pre class="kd ke kf kg gt mt ms mu mv aw mw bi"><span id="0a68" class="lr ls in ms b gy mx my l mz na">//worker.js<br/>const complexCalc = () =&gt; {<br/>    let counter = 0;<br/>    <strong class="ms io">workerpool.workerEmit("Worker will now start the computation.")</strong><br/>    while (counter &lt; 9000000000) {<br/>        counter++;<br/>    }<br/>    <strong class="ms io">workerpool.workerEmit("Worker is done with the computation.")</strong><br/>    return counter;<br/>}</span></pre><p id="aa8a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了监听这些消息，在我们的<code class="fe mp mq mr ms b">pool.exec</code>方法中，我们可以用<code class="fe mp mq mr ms b">on</code>事件监听器传入一个对象。(第二个参数是一个空数组，因为我们的复杂计算函数没有参数)。它将有一个回调函数，在这个函数中，你可以做任何你想做的事情，只要你收到来自工人的消息。现在，我们只需要<code class="fe mp mq mr ms b">console.log</code>消息。</p><pre class="kd ke kf kg gt mt ms mu mv aw mw bi"><span id="fcee" class="lr ls in ms b gy mx my l mz na">app.get("/heavy", (req, res) =&gt; {<br/>    pool.exec("complexCalc", [], <strong class="ms io">{<br/>        on: (message) =&gt; console.log(message)<br/>    }</strong>).then(result =&gt; {<br/>        res.send(`Resolved heavy request, ${result} iterations`)<br/>    }).catch(err =&gt; {<br/>        console.log(err);<br/>    }).then(res =&gt; {<br/>        pool.terminate()<br/>    })<br/>})</span></pre><p id="67a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果您运行这个程序并发出一个<code class="fe mp mq mr ms b">heavy</code>请求，您将会在计算前后收到来自工人的消息。</p><h2 id="3729" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">结论</h2><p id="a7ac" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">这个<code class="fe mp mq mr ms b">workerpool</code>库是您管理员工的一种非常简单的方式。你可以在npm注册表上查看这个库。它在nodeJS社区中被很好地记录和大量使用。</p><p id="2e43" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我在Youtube上也有这篇文章的视频，你可以去看看。  </p><p id="70ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这篇文章是我们研究Node.js中多任务处理的系列文章的一部分。</p><ul class=""><li id="3aa2" class="nc nd in kq b kr ks ku kv kx ne lb nf lf ng lj nh ni nj nk bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/multitasking-in-node-js-with-child-process-d82841fd8d29"><strong class="kq io">node . js中多任务带子进程</strong> </a></li><li id="c95a" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/multitasking-in-node-js-with-the-cluster-module-ee8480208f86"> <strong class="kq io">用集群模块</strong> </a>在Node.js中多任务</li><li id="3666" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/process-management-in-node-js-with-pm2-ca32d75c94af"> <strong class="kq io">同</strong></a>node . js中的流程管理</li><li id="0650" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/a-brief-guide-on-worker-threads-in-node-js-80bd1e7846cb"><strong class="kq io">NodeJS</strong></a>中工作线程的简要指南</li></ul><p id="7637" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何疑问或建议，你可以在评论中提出，或者通过我的任何一个社交网站与我联系。干杯！</p><p id="7d18" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/><a class="ae lk" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae lk" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae lk" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">GitHub</a></p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="cc27" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lq">更多内容请看</em><a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lq">plain English . io</em></strong></a><em class="lq">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lq">免费周报</em> </strong> </a> <em class="lq">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lq">Twitter</em></strong></a><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lq">LinkedIn</em></strong></a><em class="lq"/><a class="ae lk" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lq">YouTube</em></strong></a><em class="lq"/><a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lq">不和</em> </strong> </a> <em class="lq">。对增长黑客感兴趣？检查</em> <a class="ae lk" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lq">电路</em> </strong> </a> <em class="lq">。</em></p></div></div>    
</body>
</html>