<html>
<head>
<title>How to Design Cache in a Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Web应用程序中设计缓存</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-design-cache-in-a-web-app-e34d30a8c32?source=collection_archive---------0-----------------------#2022-09-17">https://javascript.plainenglish.io/how-to-design-cache-in-a-web-app-e34d30a8c32?source=collection_archive---------0-----------------------#2022-09-17</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><div class=""><h2 id="5b39" class="pw-subtitle-paragraph jl in io bd b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dk translated">在web应用程序中设计干净、可靠的缓存的准则。</h2></div><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj kd"><img src="../Images/aa0cafcbcf6f3d896bb661f66ae55239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W0lB8ncFTOR3nX19"/></div></div><figcaption class="kp kq gk gi gj kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@aldyrkhanov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artur Aldyrkhanov</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="bc99" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">前言</h1><p id="ddba" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">当我访问一个交互非常慢的网站时，我会变得很烦躁。例如，当我们点击一个按钮时，几秒钟后页面没有反馈。而且我相信每个人都应该有同感。作为开发人员，如果我们开发的页面太慢，我们将面临挑战。</p><p id="faf8" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">改善用户体验的更好方法是缓存数据。如果我们没有通过http头<code class="fe mn mo mp mq b">cache-control</code>禁用动作，浏览器将缓存静态文件。后端服务器将使用Redis来缓存数据，而不是直接从数据库中查询。在web应用程序中，缓存无处不在。在React项目中，我们可以用<code class="fe mn mo mp mq b">memo</code>缓存组件，<code class="fe mn mo mp mq b">useCallback</code>缓存函数，<code class="fe mn mo mp mq b">useMemo</code>缓存数据，</p><p id="f2c0" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">缓存是有用的。本文将介绍如何在web应用程序中设计缓存，并包含以下章节:</p><ol class=""><li id="9dcf" class="mr ms io lo b lp mi ls mj lv mt lz mu md mv mh mw mx my mz bi translated">如何选择存储数据的位置</li><li id="ae82" class="mr ms io lo b lp na ls nb lv nc lz nd md ne mh mw mx my mz bi translated">如何管理数据的生命周期</li><li id="0745" class="mr ms io lo b lp na ls nb lv nc lz nd md ne mh mw mx my mz bi translated">如何确保缓存的可靠性</li></ol><h1 id="fca2" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">如何选择存储数据的位置</h1><p id="6393" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">在一个web应用程序中，存储数据的方式有很多种，我们可以通过memory、cookie、localStore/sessionStorage、IndexedDB保存在本地浏览器中。我们还可以通过频繁的http请求将数据发送到后端服务器。</p><p id="bd2e" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果网站不是纯文本的，一般会有以下两种类型的数据:</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj nf"><img src="../Images/6bdb92cc45b737319de42a986f1dd3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6l8AT-n5t3o1tsDTBwV4A.png"/></div></div></figure><p id="b0f5" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated"><strong class="lo ip">系统数据</strong>总是从后端服务器获取。在大多数情况下，我们需要转换数据，然后将其呈现到页面上。如果转换数据很耗时，并且可能发生多次，我们可以将结果缓存在内存中。我们可以在React项目中使用<code class="fe mn mo mp mq b">useMemo</code>,或者只使用一个全局变量来保存结果，如下所示:</p><pre class="ke kf kg kh gu ng mq nh ni aw nj bi"><span id="0f55" class="nk kv io mq b gz nl nm l nn no">let cacheResult = null;<br/>function calculateSomething(params) {<br/>  if (cacheResult) {<br/>    return cacheResult;<br/>  }<br/>  // do some thing <br/>  ...<br/>  cacheResult = theFinalResult;<br/>  return cacheResult;<br/>}</span></pre><p id="a56c" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">您甚至可以使用function属性缓存数据:</p><pre class="ke kf kg kh gu ng mq nh ni aw nj bi"><span id="e3de" class="nk kv io mq b gz nl nm l nn no">// Don't need variable, but the property may be changed.<br/>function calculateSomething(params) {<br/>  if (calculateSomething.__cached){<br/>     return calculateSomething.__cached;<br/>  }<br/>  ....<br/>  return (calculateSomething.__cached = theFinalResult);<br/>}</span></pre><p id="c994" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated"><strong class="lo ip">用户动作</strong>是指用户与网站交互时的状态，比如搜索数据、在页面上前进/后退、写东西等等。用户行为产生的数据在不同的场景下需要使用不同的存储方式。</p><p id="e04d" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果需要跨设备或浏览器访问数据，最好将其存储在后端。例如，一篇中型文章的草稿，在我们停止编辑时，它将在大约5s后被发送到后端服务器。</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj np"><img src="../Images/aefdcdbc44f7a9944f9e09cdb9b5cefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klMRuAp0IYX8ZmXtFtAyHw.png"/></div></div><figcaption class="kp kq gk gi gj kr ks bd b be z dk">autosave code of medium</figcaption></figure><p id="0063" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果在重新打开页面时需要恢复页面状态，最好使用localStorage将其存储在磁盘中。比如当页面支持大量过滤操作时，我们可以缓存用户的过滤项，当页面再次打开时，可以显示最后浏览的数据。</p><p id="69f6" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果我们想在不同的页面中共享一些数据，我们可以使用sessionStorage来存储它。例如，在下面的例子中，我们必须从应用程序1页面a导航到另一个应用程序2，执行一些操作，然后返回到应用程序1页面b。</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj nq"><img src="../Images/a553ca950723d33d29dcf3f125c3f055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBkabj4JXOMjD6xtcQrAWw.png"/></div></div></figure><p id="4c29" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果后端服务需要感知用户的状态，建议使用cookies。例如用户是否点击了灰度功能或ab测试。</p><p id="9875" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">IndexedDB用于大量的结构化数据，它在大多数项目中并不需要，我还没有使用过。</p><h1 id="6182" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">如何管理数据的生命周期</h1><p id="6ef1" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">每次创建数据时，考虑如何清理数据是一个好主意。在JavaScript中，我们创建变量，并在不需要的时候由GC清理掉。当我们使用内存缓存数据时，它将被清理。sessionStorage类似于内存，在窗口关闭时被清除。但是如果我们使用cookie或者localStorage，最好考虑一下什么时候清理。</p><p id="5046" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">Cookie支持设置过期时间，所以我们只需要提供一个过期策略。</p><p id="92a7" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">本地存储需要手动管理生命周期。我们可以实现一个方法来做到这一点:</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nr ns l"/></div></figure><p id="f39b" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">我们可以用一个额外的键<code class="fe mn mo mp mq b">${key}__expires__</code>来存储时间戳。当我们从localStorage中获取值时，我们会判断它是否过期，如果过期，就会被清除。我们还可以使用<code class="fe mn mo mp mq b">removeExpired</code>方法在安装应用程序时删除所有过期的密钥。</p><p id="bcf1" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果我们的草稿数据保存在后端服务器上，最好有一个版本来记录数据是否从另一个页面被修改过。例如，当选项卡被激活时，媒体编辑器页面将检查草稿是否是最新的，如果您在其他浏览器或页面中编辑，则可能会给出提示:</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div class="gi gj nt"><img src="../Images/60cf70fac90ee8d1beca61c9a4719fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*_nqSNBzHvdw71P0k0Wf7Xw.png"/></div></figure><h1 id="8f28" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">如何确保缓存的可靠性</h1><p id="3c97" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">最重要的是缓存可以命中，但是需要保证我们从缓存中获取的日期是正确的。例如，当我们使用一个对象作为localStorage的键时，会出现意想不到的结果:</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj nu"><img src="../Images/8c0d5bf482f10272f8a3fc17602dfad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78iG9B5hjmPfX5y69zX_Xw.png"/></div></div></figure><p id="f8ad" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">原因是当我们发布一个对象时，localStorage的键必须是一个字符串，通过使用对象的<code class="fe mn mo mp mq b">toString</code>属性将它转换成字符串。</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj nv"><img src="../Images/053f7b4928cb76ba68b270057d10ad88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XtI-3yHciUJHwumid2GApQ.png"/></div></div></figure><p id="1cf6" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated"><strong class="lo ip">首先，我们需要确保key是字符串类型</strong>，如果不是字符串类型，我们需要提示或者提供一个自动序列化util。</p><p id="4c70" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果我们在一个复杂的应用程序中使用localStorage，<strong class="lo ip">我们需要确保缓存键是惟一的</strong>。我通常使用以下结构来命名键:</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj nw"><img src="../Images/f495229c113869624bffc80a7a9ba606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lNN27RIF73RrvuMQizrog.png"/></div></div></figure><p id="6da7" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果缓存数据将在项目或不同页面中共享，则键可能类似于<code class="fe mn mo mp mq b">project_feature</code>。只有当数据结构经常改变时，版本字段才是可选的。</p><p id="ab3d" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">最后，如果我们想使用localStorage来存储函数或对象，我们需要先对它们进行序列化，然后在获得它们时再进行反序列化。通常的做法是使用JSON.stringify和JSON.parse，但对function没用。</p><h1 id="d964" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">结论</h1><p id="9527" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">缓存对于页面性能非常重要。在本文中，我们学习如何选择内存、cookie、会话存储/本地存储或后端服务器。当我们使用缓存时，如何处理生命周期并为数据提供唯一的键。</p><p id="7fed" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">感谢阅读，希望这篇文章对你有所帮助。</p><p id="2abb" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated"><em class="nx">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="nx">plain English . io</em></strong></a><em class="nx">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ip"> <em class="nx">免费周报</em> </strong> </a> <em class="nx">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="nx">Twitter</em></strong></a><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="nx">LinkedIn</em></strong></a><strong class="lo ip"><em class="nx"/></strong><a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="nx">YouTube</em></strong></a><strong class="lo ip"><em class="nx">，以及</em></strong><em class="nx"/><a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="nx">不和</em> </strong> </a>  <em class="nx">对成长黑客感兴趣？检查</em> <a class="ae kt" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ip"> <em class="nx">电路</em> </strong> </a> <strong class="lo ip"> <em class="nx">。</em> </strong></p></div></div>    
</body>
</html>