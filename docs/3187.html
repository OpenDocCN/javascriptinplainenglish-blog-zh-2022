<html>
<head>
<title>How to Make Real-Time Multiplayer WebXR Experiences — part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作实时多人WebXR体验—第2部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-real-time-multiplayer-webxr-experiences-part-2-89015bf198fd?source=collection_archive---------6-----------------------#2022-08-07">https://javascript.plainenglish.io/how-to-make-real-time-multiplayer-webxr-experiences-part-2-89015bf198fd?source=collection_archive---------6-----------------------#2022-08-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c5f8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用WebSockets、React Three Fiber和DynamoDB实时提交和检索用户位置。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/46ede3956310863bf8d840738bbb2d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYWLSPZlDskgM-EwNIL_sQ.jpeg"/></div></div></figure><h1 id="1691" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="3d9e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在我的上一篇博文中，我谈到了实现实时多人WebXR体验的概念。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi md"><img src="../Images/a965a4dbc96e64f0a7961b712a3515ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gVY8KKyKM5vNSbR45w_AqQ.gif"/></div></div></figure><p id="5ca3" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">这篇文章将展示那篇博客文章的实际方面，这样你就可以开始将代码样本应用到你的应用程序中——或者如果你愿意的话——利用<a class="ae mc" href="https://github.com/JamesMillerBlog/wrapper.js/tree/main/templates/webxr" rel="noopener ugc nofollow" target="_blank">包装器。我已经创建的JS WebXR模板</a>(代码片段取自这里)。</p><p id="1f9d" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">如果你还不知道，那么<a class="ae mc" href="https://jamesmiller.blog/how-to-make-real-time-multiplayer-webxr-experiences-part-1/#" rel="noopener ugc nofollow" target="_blank">请阅读本系列教程的第1部分</a>——这样你就能理解下面代码片段背后的概念。</p><p id="b4e9" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">准备，预备，开始！:D</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="fab2" class="ko kp in bd kq kr mq kt ku kv mr kx ky jt ms ju la jw mt jx lc jz mu ka le lf bi translated">代码示例</h1><p id="7a49" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在我最近的另一篇关于<a class="ae mc" href="https://jamesmiller.blog/create-cross-device-compatible-webxr-experiences/" rel="noopener ugc nofollow" target="_blank">如何让WebXR体验在任何设备上工作</a>的帖子中，我谈到了我创建的一个名为<strong class="li io"> XRScene </strong>的高阶组件(HOC)。</p><p id="df12" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在这些代码示例中，我们将详述:</p><ol class=""><li id="dc98" class="mv mw in li b lj me lm mf lp mx lt my lx mz mb na nb nc nd bi translated"><a class="ae mc" href="https://jamesmiller.blog/?p=4054&amp;preview=true#elementor-toc__heading-anchor-2" rel="noopener ugc nofollow" target="_blank">如何实例化WebSockets </a></li><li id="9ac5" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">H <a class="ae mc" href="https://jamesmiller.blog/?p=4054&amp;preview=true#elementor-toc__heading-anchor-6" rel="noopener ugc nofollow" target="_blank">如何用WebSockets发出数据</a></li><li id="3e16" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb na nb nc nd bi translated">R <a class="ae mc" href="https://jamesmiller.blog/?p=4054&amp;preview=true#elementor-toc__heading-anchor-11" rel="noopener ugc nofollow" target="_blank">可视化&amp;可视化WebSocket数据</a></li></ol><p id="ddee" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">让我们从:D开始</p><h2 id="7bb7" class="nj kp in bd kq nk nl dn ku nm nn dp ky lp no np la lt nq nr lc lx ns nt le nu bi translated">如何实例化WebSockets</h2><p id="1df1" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">为了使用WebSockets发送和检索数据，您需要首先在您的应用程序中设置它们。</p><p id="0fe4" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">让我们看看我是如何设置它们的，首先看看我的index.js文件是如何设置的。</p><p id="26f5" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io">index . js文件</strong></p><p id="5976" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">您可以看到，该文件声明了为索引路由“/”呈现的前端。</p><p id="205b" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">我突出显示了第7行和第19–42行，它们显示了编写3D应用程序(Three.js)逻辑的高阶组件(HOC) XRScene。</p><p id="0df3" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在这个组件内部，我们需要看到WebSockets是在哪里实现的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="eaf7" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io"> XRScene组件</strong></p><p id="2944" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">该组件负责为用于打开网页的浏览器动态选择合适的WebGL呈现器(如我在上一篇文章中所述)。</p><p id="3a85" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">我不会重复我在那篇文章中已经讨论过的内容，但是请注意，在第18行和第34行，有一个Sockets HOC，它包含WebGL渲染逻辑作为其子组件。</p><p id="ec50" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">我们需要看的就是这个套接字组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7d17" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io">插座组件</strong></p><p id="4361" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在这个组件中，你可以看到我们正在使用一个名为<a class="ae mc" href="http://react-use-websocket/" rel="noopener ugc nofollow" target="_blank"> react-use-websocket </a>的库来实现WebSockets。</p><p id="1a9e" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在第11行，您可以看到我们正在设置应用程序应该使用的WebSocket，并使用Cognito收到的JWT来确保它的安全，以确保后端仅对经过身份验证的用户可见。</p><p id="e0bc" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在第19–23行之间，我们用最新收到的消息和一个发送消息的函数来更新应用程序的全局状态。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="de8e" class="nj kp in bd kq nk nl dn ku nm nn dp ky lp no np la lt nq nr lc lx ns nt le nu bi translated">如何用WebSockets发出数据</h2><p id="a8d3" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在我们已经了解了WebSockets是如何设置的，让我们看看如何使用它们来实时发送用户位置数据。</p><p id="395d" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">让我们从查看Sockets组件中呈现的任何组件开始，例如，让我们使用RenderAR组件。</p><p id="73f7" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io"> RenderAR组件</strong></p><p id="776a" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">该组件负责返回ARCanvas组件(这是一个WebGL渲染器，用于可以在浏览器上使用增强现实的设备)。</p><p id="044a" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">我将在本教程中讨论两个组件，即<strong class="li io">相机</strong>组件和<strong class="li io">化身</strong>组件。</p><p id="b770" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io"> Avatars </strong>组件用于渲染在站点中移动的其他用户，因此用户可以看到他们——我将在教程中进一步解释这一点。</p><p id="e13f" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io"> Camera </strong>组件负责为登录用户配置移动和视线，这是我们开始查看如何使用WebSockets发送数据的地方。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="af6d" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io">摄像头组件</strong></p><p id="65a0" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">相机组件负责为登录到应用程序的用户配置移动和视线设置。</p><p id="4f1c" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">我将详细介绍这个应用程序的前端如何工作，以及它如何与后端(实际的WebSockets本身)交互。</p><p id="03ed" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">下面这个例子中有很多代码，为用户可以用来移动/瞄准的摄像机设置细节。</p><p id="1fd5" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">为了简单起见，我假设您了解Three.js的基本工作原理，并将直接跳到实现实际套接字的部分。</p><p id="c722" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">我突出显示了第51–53行和第61–81行，它们显示:</p><ul class=""><li id="ca87" class="mv mw in li b lj me lm mf lp mx lt my lx mz mb nx nb nc nd bi translated"><strong class="li io">51–53</strong>:每250毫秒触发一次</li><li id="298e" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb nx nb nc nd bi translated"><strong class="li io">61–81</strong>:每次触发器被激活时被触发的useEffect生命周期方法。该函数负责使用名为sendJsonMessage的函数发出位置数据。</li></ul><p id="8851" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在这个useEffect函数中，发生了以下情况:</p><ol class=""><li id="e915" class="mv mw in li b lj me lm mf lp mx lt my lx mz mb na nb nc nd bi translated"><strong class="li io">第62行</strong>获取登录用户的用户名</li></ol><p id="c973" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">2.<strong class="li io">第63–67行</strong>定义了将发送给WebSocket的数据</p><ul class=""><li id="943c" class="mv mw in li b lj me lm mf lp mx lt my lx mz mb nx nb nc nd bi translated">当我们为用户定义位置数据时，类型被设置为“用户”</li><li id="d32c" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb nx nb nc nd bi translated">唯一标识符(uid)被设置为我们刚刚在第62行定义的用户名</li><li id="345d" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb nx nb nc nd bi translated">实际移动数据在“用户”本地状态变量中定义</li></ul><p id="92ee" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">3.<strong class="li io">第68–73行</strong>主要检查触发器是否设置为真，然后确保是否有移动数据可用于重置允许跟踪移动数据的状态，如果没有，则发送空数据包</p><p id="18f9" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">4.第74 -77行包含向WebSocket发送数据的实际函数</p><p id="786f" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">5.<strong class="li io">第79行</strong>重置触发状态变量</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3c08" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io">在后端提交位置数据</strong></p><p id="019e" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">一旦数据在WebSocket上提交，包含以下代码的Lamda函数将在后端运行。</p><p id="9f7d" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">它获取前端发送的数据，并将其保存到DynamoDB表中(见第47行)。</p><p id="a3da" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">然后，DynamoDB表的内容被返回到前端(参见第21–25行)。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="f6cc" class="nj kp in bd kq nk nl dn ku nm nn dp ky lp no np la lt nq nr lc lx ns nt le nu bi translated">检索和可视化WebSocket数据</h2><p id="d334" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在，我们已经了解了如何发出用户位置数据，我们现在可以看看我们如何渲染其他用户位置，以便您可以看到他们实时移动！</p><p id="dd7c" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">为此，我们需要RenderAR组件，看看头像组件是如何工作的。</p><p id="dc42" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io">头像组件— index.js </strong></p><p id="1496" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">该组件负责获取HTTP和WebSocket数据，然后遍历在DynamoDB中保存了条目的所有其他用户，然后将他们的道具传递给一个名为Avatar的组件。</p><p id="1a44" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在这一节中，我将讨论前端代码和DynamoDB表。</p><p id="7eb2" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">这是另一个有很多内容的大文件，有两个关键方面需要您查看和理解:</p><ul class=""><li id="961c" class="mv mw in li b lj me lm mf lp mx lt my lx mz mb nx nb nc nd bi translated"><strong class="li io">第29行</strong>:这里我们传递最后接收到的WebSocket数据，包含所有其他用户的位置、当前登录的用户以及所有其他登录用户的图像</li><li id="33e0" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb nx nb nc nd bi translated"><strong class="li io">第49–56行</strong>:我们正在为传入第29行的每个用户渲染一个虚拟角色组件，注意他们的位置/旋转/uid/图像包含在道具中</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3045" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io">web socket位置数据的数据库</strong></p><p id="cbde" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">我在下面附上了WebSocket数据在DynamoDB中的样子。</p><p id="2816" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在该表中，您可以看到存储的数据被分类为对象(例如，像本文顶部gif中的狗这样的3D模型)或用户。</p><p id="23ca" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">这篇文章只关注如何实现用户之间的实时交互，但我可能会发表另一篇后续文章来解释如何实时共享用户在其他3D模型上的交互。:D</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/2b24a4c92b072bf0636c7554d2297d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mVC-GpuyDtTnkagtPXrSw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Screenshot of the positional data in the DynamoDB Table</figcaption></figure><p id="55fa" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">现在，如果我们看看DynamoDB表中的一个用户的例子，您可以看到位置和旋转数据是什么样子的。</p><p id="2560" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">正是这些数据被传递给Three.js渲染器来更新化身组件的位置。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fda1" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io">头像组件— Avatar.js </strong></p><p id="ce45" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">最后，一旦所有数据都被传递到<strong class="li io">化身</strong>组件——这就是可视化接收数据的神奇之处。</p><p id="97e2" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">这篇文章的这一部分将讨论前端逻辑，以及HTTP数据是什么样子的。</p><p id="1343" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">需要理解的代码的关键部分是:</p><ul class=""><li id="5b0d" class="mv mw in li b lj me lm mf lp mx lt my lx mz mb nx nb nc nd bi translated"><strong class="li io">第10–12行</strong>:传入组件的图像被设置为Three.js的纹理，如果不存在的话加载备份图像</li><li id="b33a" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb nx nb nc nd bi translated"><strong class="li io">第16–19行</strong>:这是WebSocket每次返回新数据时更新另一个登录用户的位置和旋转的地方</li><li id="edfb" class="mv mw in li b lj ne lm nf lp ng lt nh lx ni mb nx nb nc nd bi translated"><strong class="li io">第24–31行</strong>:这是3D网格渲染为平面，图像加载为纹理(我们在第10–12行之间定义的那个)</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="59c6" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated"><strong class="li io">HTTP用户数据的数据库</strong></p><p id="a284" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">至于在前端呈现的“非实时”数据，可以通过HTTP api访问并存储在DynamoDB中。</p><p id="b0e6" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">每个用户都作为一个单独的条目存储在DynamoDB表中，并保存了他们的角色、电子邮件地址和图像。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/c42c6db92c3baad565ab4595f379dc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAQfwgsJK7oPTsLlK2GR9g.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Screenshot of the http user data in the DynamoDB Table</figcaption></figure><p id="d267" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">查看JSON格式的数据，返回这个对象——这是返回到前端的内容。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="6453" class="ko kp in bd kq kr mq kt ku kv mr kx ky jt ms ju la jw mt jx lc jz mu ka le lf bi translated">结论</h1><p id="e219" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">哇！如果你真的走到了这里，你就是冠军——祝贺你，:D</p><p id="3bdf" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">幸运的话，您了解如何在您的WebXR应用程序中实现实时用户位置的实际方面，从而能够根据您的需要对其进行调整。</p><p id="74a2" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在我的下一篇文章中，我将讨论如何用实时逻辑实现用户与3D对象的交互结果，以便多个用户可以一起与环境交互。</p><p id="2d9b" class="pw-post-body-paragraph lg lh in li b lj me jo ll lm mf jr lo lp mg lr ls lt mh lv lw lx mi lz ma mb ig bi translated">在那之前，希望你喜欢这篇文章，并在:D玩得开心</p></div></div>    
</body>
</html>