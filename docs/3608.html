<html>
<head>
<title>What is Deep Copy &amp; Shallow Copy in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的深度复制和浅度复制是什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-deep-and-shallow-copy-e519c64493d5?source=collection_archive---------2-----------------------#2022-09-11">https://javascript.plainenglish.io/javascript-deep-and-shallow-copy-e519c64493d5?source=collection_archive---------2-----------------------#2022-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0661" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我破坏应用程序的旅程以及如何避免它</h2></div><h1 id="5717" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">重要的事情先来</h1><p id="7bfe" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在讨论我如何破坏我一直在构建的web应用程序之前，这也是我写这篇文章的动机，让我们了解一下深层复制和浅层复制的含义，以及JavaScript如何在幕后管理它们。</p><h1 id="e9a0" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">浅拷贝</h1><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/f1257e3d4064c7a5d39ce27c918068f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*Ywltcvolf-qtjXRnhAPwnw.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Objects referencing values in memory</figcaption></figure><p id="2aea" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">假设您创建了两个对象A和B，并为它们分配了一些属性。</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="ccfd" class="mm kd in mi b gy mn mo l mp mq">A = {<br/>name: "Johny",<br/>Age: "47<br/>}<br/>B = {<br/>name: "Annie",<br/>age: 42<br/>}</span></pre><p id="d2af" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">它们是一样的吗？嗯，不。它们看起来不一样，当然，JavaScript在这里符合常识，但事实往往并非如此。</p><p id="fbbd" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">如果我们把B赋值给A呢？</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="0e96" class="mm kd in mi b gy mn mo l mp mq">A = B</span></pre><p id="2aa0" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">现在它们是相同的，它们共享相同的属性，也许…对内存的引用是相同的？让我们不要超越自己，但Javascript确实认为它们是一样的，正如计划中的那样</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/9d6550105061b51bce0e4dd533cced20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*5MjZ6H6wB25a9EIEEm7qyQ.png"/></div></figure><p id="1599" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">但是你知道吗？这是一个错误，我从来没有想过有两个副本的B，没有个人，安妮。幸运的是，我记得什么是A属性，所以让我们通过把它们分配给我们的A对象键来回到这个问题。</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="2e19" class="mm kd in mi b gy mn mo l mp mq">A.name = "Johny"<br/>A.age = 47</span></pre><p id="d79b" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">很好，现在我们的好兄弟张诗钟回来了。希望A打印出我们给他的最新属性</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/239c543b813704cadac900eed8be3b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*toDtmKGMxhB6LlDNLi0O4w.png"/></div></figure><p id="0f94" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">那是什么？安妮刚刚打电话来，她现在感觉像张诗钟。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/ff7d0a5470989a312ab4a5eefc6e69bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*vySSF2tF75n9eWHrk56J_Q.png"/></div></figure><p id="dc78" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">这里发生了什么？嗯，浅显的抄。还记得我们的第一幅画吗？当我们把B赋值给A时</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="ef32" class="mm kd in mi b gy mn mo l mp mq">A = B</span></pre><p id="db99" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">在这个黑暗、泥泞、难闻的内存管理世界中发生的事情是，A现在指向B指向的相同内存区域。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/9418a4729a660fba2f5cd07dfefd1993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*zaC2D_NEqtpPrZDlPDv83g.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Shallow copy — Now B refers to the same memory as A</figcaption></figure><p id="0ea5" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">这是什么意思？这意味着它们在你能想象到的任何方面都是同一个物体。<strong class="kw io">如果您对A或B进行更新、删除或添加值，相同的更改将会反映在对应部分中。</strong></p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="46ca" class="mm kd in mi b gy mn mo l mp mq">B.name = "Johny"</span></pre><p id="e53e" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">这实质上改变了存储在内存中的值。由于A和B使用相同的内存，因此A和B的参数“name”值将是相同的</p><p id="a86c" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">如果我们给B添加一个新的密钥，A也会被更新:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/3fd899c4ab72cb2e9ac13c10ad9a2c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*-b90IDWAWy-YwNI1BSUUbg.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Key being added to the Shallow Copy</figcaption></figure><p id="ec6e" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">现在让我们重置我们的对象A和b。因为它们是“相同的”,我们可以说:</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="3e0b" class="mm kd in mi b gy mn mo l mp mq">A = {}</span></pre><p id="c812" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">他们都将变得空虚…或者他们会吗？</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/a88afdc04fe115a2e046a6735ebe9a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*wOsDsoD1-gFzndCJgMRwOA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Assigning a new Object to A changes its memory reference</figcaption></figure><p id="e1a4" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">他们不会。我们的空对象{}有它自己的内存区域，这意味着A现在指向那个区域，并且与B分离，因为<strong class="kw io">他们不再引用同一块内存。</strong></p><p id="d2a1" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">当谈到浅层拷贝时，有大量的例子可以用来检验它有时有多直观。如果不小心的话，很容易搞乱整个应用程序，对吗？但是在我们到达那里之前…</p><h1 id="ebd2" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">深层拷贝</h1><p id="7d50" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">谈论深层拷贝就没那么有趣了。深度复制意味着您希望将属性从一个对象复制到另一个对象，而不使它们共享对内存的相同引用。这在很多方面都是有用的，主要是为了避免意外打破东西。这样，您可以将值从A复制到B，并在不更改B的情况下更改A的值，反之亦然。</p><p id="6f94" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">有多种方法可以实现深度复制。</p><p id="c3b1" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">最简单的一种是通过使用<a class="ae mx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread语法</a>，用现有对象的属性创建一个全新的对象，我们来看看。</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="0edb" class="mm kd in mi b gy mn mo l mp mq">A = {name: "Johny", age: 47}<br/>B = A<br/>C = {...A}</span></pre><p id="42df" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">让我们看看Javascript是如何看待我们新创建的对象的。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/59c4a9f46aab7d5a1346a0fe41c15907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*j9np_567PKJroK6HZ9KdCg.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Three Objects with the same parameters</figcaption></figure><p id="72f4" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">然而，并非一切都像它看起来那样:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/259bc4973649e590c794e4a6e67d8e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*08Jqe4yVkpCzhngg_sOHzA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Shallow and deep copy output different Boolean on equality check</figcaption></figure><p id="7e0c" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">我们的spread操作符完成了它的工作，我们最终得到了<strong class="kw io">两个属性相同但不相同的对象</strong>。我们可以安全地改变A的属性，而不会影响到c。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5ceb720f4bafeba81df935aa8dd27753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*boIdht7BA_JckIf966vhLQ.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">The deep Copy doesn’t change values</figcaption></figure><p id="3d68" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">各种其他方法是可用的，为了更深入地解释它们，我强烈推荐<a class="ae mx" href="https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy" rel="noopener ugc nofollow" target="_blank"> MDN文档的深层拷贝。</a></p><h1 id="a2d6" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我是怎么弄坏我的APP的？</h1><p id="59c5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你可能会想</p><p id="7b8b" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">是的，当然，这种深度复制和浅层复制的东西会让你大吃一惊，但这并不完全是火箭科学，似乎很容易就能发现发生了什么。</p><p id="f7b9" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">在很大程度上，你是对的，然而……事情还是发生了。我不会演示应用程序运行的整个过程，但假设我到处滥用浅层拷贝，突然一个数组变成了另一个数组的浅层拷贝，而我并不想这样做。</p><p id="2949" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">让我们看一个更简单的例子，它准确地展示了基本问题是什么。我将分享所有的代码，这样你就可以打开你最喜欢的IDE并创建一个. js文件。</p><p id="6611" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">所以我有两个数组。两者都将保存我从API中获取的项目，但它们有一个关键的区别:虽然一个是可变的，会发生变化，但另一个应该保持不变，以防我想重置第一个。让我们用datausa.io API把它写下来。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/0523c4283fb63bff23abc6110512a3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJpEIISiMYQL1le5U7IhUQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Code snippet</figcaption></figure><p id="3d30" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">让我们检查一下控制台，看看我们得到了什么:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7d55e655250ed5f97a00e60c9b946cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*czYBS6bNKIMq88avXu5_cg.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Output saved to our Mutable Array</figcaption></figure><p id="17f7" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">听起来差不多。两个数组打印的是一样的，让我们把我们的mutableArray的2020年改为我们的老A对象和console.log()两个数组。</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="eca4" class="mm kd in mi b gy mn mo l mp mq">mutableArray.data[0] = {name: "Johny", age: 47}<br/>console.log(mutableArray.data[0], originalArray.data[0])</span></pre><p id="6659" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">我敢打赌你已经猜到这是怎么回事了。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/87cdb590f2ae0ada8fdb8fa63b972d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*H_x8Mq3oBikrIPoMLKDG2Q.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Both arrays change their value</figcaption></figure><p id="8dca" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">发生了什么事？FetchUSAData()返回一个Javascript对象Data，它引用内存的某个区域，然后我们告诉originalArray和mutableArray引用完全相同的区域。正如我们在本文前面看到的，这意味着改变一个数组也会改变另一个数组。</p><p id="4c56" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">我们如何解决这个问题？我们前面已经看到，我们可以使用“…”spread语法进行修复，但是我们也可以使用JSON stringify()和parse()方法的组合:</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="1439" class="mm kd in mi b gy mn mo l mp mq">mutableArray = JSON.parse(JSON.stringify(data))</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/83cc51dd30e968a1c8cbbe441ba6faa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*Bv0phwm6AMLLb9_S1zma0Q.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Thanks to parse() and stringify() we have a deep copy</figcaption></figure><p id="ab19" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">我们修好了！值得注意的是，这是更普遍推荐的方法。</p><h1 id="0026" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">提出的方法的局限性</h1><p id="4290" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">“…”spread语法和JSON . parse(JSON . stringify(Object))都有其局限性。</p><h1 id="f9c2" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">扩展语法</h1><p id="9100" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们以下面的对象A为例。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/3f04335060f9e402af79e8cc4008316a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*AvT8FfkZ6K0dMDyaYU6pMA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Nested Object A</figcaption></figure><p id="f9ab" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">对象A有名字，年龄，还有一个对象叫爱好。让我们使用“…”展开语法将A深度复制到一个名为B的新对象。</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="d3df" class="mm kd in mi b gy mn mo l mp mq">B = {...A}</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4d3963bce891d6d03983987fb32a50d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*TWHUu06dUAvhLt828r05YA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">“Deep copy” of Object A using “…” spread syntax</figcaption></figure><p id="2314" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">正如计划的那样，我们最终得到了A的副本。但是你知道吗，让我们换个名字和爱好，说实话，我可能不太擅长魔法聚会，我宁愿被叫做本尼。</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="82da" class="mm kd in mi b gy mn mo l mp mq">A.name = "Benny"<br/>A.hobbies[1].expertise = "A little above average"<br/>console.log(B)</span></pre><p id="54fb" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">我们最好看起来像这样:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9ca7951e7e9a1c191a59391f3d919dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*5WfyBNdSjrq6bMAP-XzCSg.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Deep copy doesn’t go deep enough</figcaption></figure><p id="b7dd" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">看起来名字没有改变，这是应该发生的，因为我们刚刚了解到“…”展开语法对一个对象进行深层复制，然而…爱好改变了？</p><p id="2451" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">这是“…”展开语法的一个已知限制，它的行为取决于被复制的对象是否嵌套。如果它不是嵌套的，整个对象将被深度复制。如果它是嵌套的，它将只深度复制最上面的数据，而浅度复制其余的数据。</p><p id="1400" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">您可以通过对每个数据级别使用“…”展开语法来解决这一限制，在这种情况下:</p><pre class="lr ls lt lu gt mh mi mj mk aw ml bi"><span id="19af" class="mm kd in mi b gy mn mo l mp mq">B = {...A, hobbies.{...A.hobbies}}</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a773164ef4cb2931f3683496efd849d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*UKOwfNyu1s5hEJNLYWzc1Q.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Create deep copy for each data level using “…” spread syntax fixes the problem</figcaption></figure><p id="d2e5" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">它工作了..但是代价是什么呢？随着对象嵌套越来越多，这种解决方案会变得越来越糟糕。</p><h1 id="15ee" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">Parse()和Stringify()一个对象</h1><p id="b99b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这种方法适用于大多数情况，包括上述情况。然而，当您的对象不可序列化时，它将会失败，而事实往往并非如此。您将会遇到的不可序列化对象的最常见示例有:</p><p id="5a80" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated">类<br/>类方法<br/>函数<br/> DOM节点</p><h1 id="b2a6" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">结论</h1><p id="80c6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">像这样的bug很难捕捉。想象一下，你有一个完整的应用程序状态，函数调用其他函数，其中一部分使用状态，一些改变状态，也许你有一些道具训练正在进行。很快就会变得一团糟。</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="4498" class="pw-post-body-paragraph ku kv in kw b kx mc jo kz la md jr lc ld me lf lg lh mf lj lk ll mg ln lo lp ig bi translated"><em class="mt">更多内容尽在</em> <a class="ae mx" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="mt">说白了. io </em> </strong> </a> <em class="mt">。报名参加我们的</em> <a class="ae mx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="mt">免费周报</em> </strong> </a> <em class="mt">。关注我们关于</em> <a class="ae mx" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="mt">推特</em> </strong> </a>，<a class="ae mx" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="mt">LinkedIn</em></strong></a><em class="mt">，</em><a class="ae mx" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="mt">YouTube</em></strong></a><em class="mt">，</em> <a class="ae mx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="mt">不和</em> </strong> </a> <em class="mt">。对增长黑客感兴趣？检查</em> <a class="ae mx" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="mt">电路</em> </strong> </a> <em class="mt">。</em></p></div></div>    
</body>
</html>