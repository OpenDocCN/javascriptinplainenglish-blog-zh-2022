<html>
<head>
<title>How to Implement the SOLID Principle in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中实现固体原理？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solid-principle-in-javascript-part-1-4f67d8f9a31f?source=collection_archive---------4-----------------------#2022-07-25">https://javascript.plainenglish.io/solid-principle-in-javascript-part-1-4f67d8f9a31f?source=collection_archive---------4-----------------------#2022-07-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c48e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这是一个初学者教程，介绍了固体原理的基础知识以及如何在JavaScript编程中实现它。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ac28b9999d645048c4b8932656947278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U9RL8fxMN3uGbW-x"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9fbc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将为您提供JavaScript语言中固体原理的基本概念。对于每种语言，我们都有不同的方式来遵循这一原则。然而，在JavaScript中，很难在代码中应用这个原则。</p><p id="c9b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了让您方便，我向您展示了实现代码的方法。在这个例子中，我混合了两种方法(类和函数)来应用遵循固体原理的代码。</p><p id="77a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个原则帮助我们构建软件。以下是固体原理的主要特点:</p><ul class=""><li id="007e" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io"> <em class="ly">代码的可重用性。</em> </strong></li><li id="3296" class="lp lq in kv b kw lz kz ma lc mb lg mc lk md lo lu lv lw lx bi translated"><strong class="kv io"> <em class="ly">在功能上很容易进行代码修改。</em> </strong></li><li id="6382" class="lp lq in kv b kw lz kz ma lc mb lg mc lk md lo lu lv lw lx bi translated"><strong class="kv io"> <em class="ly">使代码易于维护。</em> </strong></li><li id="3ef2" class="lp lq in kv b kw lz kz ma lc mb lg mc lk md lo lu lv lw lx bi translated"><strong class="kv io"> <em class="ly">编写测试代码很容易。</em> </strong></li></ul><h2 id="3887" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">固体代表什么？</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/2d84b71e3aef8726aec1b014ea2564be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fyqq4IR08t72HzBEbjNo9g.png"/></div></div></figure><p id="8e70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将详细讨论单词“固体”中的每个字符。</p><h2 id="0d67" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">史:单一责任</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/8f82a28e419633b2c0a4004a232795fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxbdNHkdc_mwVSbg_1mKVw.png"/></div></div></figure><blockquote class="mz"><p id="95fa" class="na nb in bd nc nd ne nf ng nh ni lo dk translated">一个类(方法)应该只有一个职责</p></blockquote><p id="0c01" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">代码示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/5b52ade8ce55d780a972bb51b7de9ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JN8R4JfZS80-UIwTdlrQ3Q.png"/></div></div></figure><p id="f624" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从这个例子中，我们可以看到(SuperTool)有很多责任来处理剑和弓的动作。当我们向这个类(方法)添加越来越多的动作时，它会变得越来越复杂。当一个新来的人在想要做出改变之前必须理解课堂时(他们担心新改变的影响)，我们必须阅读并保持它。</p><p id="b74f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="ly">该原则的目标是</em> </strong>:将类(方法)行为分解为单个点动作。将代码(类、函数)分解成尽可能小的组件。</p><p id="7728" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而不是用1中的很多(n)个工具来构建超级工具。只需将支持工具分解为多个工具，每个工具都必须对其所有操作负责。它有助于代码库变得清晰，当一个新的特性在剑术类(或弓箭手)上改变时，我们不会影响另一个工具。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="ad0f" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">o:打开-关闭</h2><blockquote class="mz"><p id="439e" class="na nb in bd nc nd nw nx ny nz oa lo dk translated">开放供扩展，但关闭供修改</p></blockquote><p id="f2c3" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">该原则与代码维护和新代码更改相关。为了便于理解系统中的原理示例，我们有一个现有的类Person(它具有所有的属性，人类跳跃、奔跑、进食等的方法)。新的特性想给我们的系统增加一个剑客或者巫师，他们也有所有的属性和行为，就像一个人类。然而，如果我们改变人类目前的行为以满足要求，例如人类可以跳1米高，剑客可以在地球上跳100米高。我们必须修改person类的现有函数。它可能会对您使用该类的系统产生副作用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/40974900a47f8573f45450ae89a8189a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kksrgAsQQApNsof4EYR9Dw.png"/></div></div></figure><p id="684e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">代码示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oc"><img src="../Images/0d4c0a6aed2837b08c1078216f257f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7-gQ_mHG13tvE9oH_kXfA.png"/></div></div></figure><p id="568c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="ly">这个原则的目标:</em> </strong>新的代码变化要尽可能避免冲击类的存在。它有助于新特性(新代码变更)避免导致错误和影响原始类。相反，要修改Person类，我们可以从SwordMan和Wizard类中扩展Person类，自己处理角色的功能，而不用担心在哪里使用Person类和新特性的新类，而不会影响旧特性。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="2b42" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">利斯科夫替代法</h2><blockquote class="mz"><p id="3394" class="na nb in bd nc nd nw nx ny nz oa lo dk translated">程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性。-维基百科</p></blockquote><p id="b1d0" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">这个原则坚持面向对象的概念，它告诉我们如何创建一个抽象，并定义父类(超类型)和子类(子类型)之间的关系。如果子类不能执行与其父类相同的动作，将来可能会发生未知的问题。 </p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi od"><img src="../Images/e2d6b0de10a312dd5dca1698312fb00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpVPTdAsYIv_p-RBtEZ6rg.png"/></div></div></figure><p id="43ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">代码示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d9bd5baa507cbaac667ab60002474bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*v7CEMNx9zJnCHq0nBN1HqA.png"/></div></figure><p id="9929" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">#Q1:盲剑侠是人吗？-&gt;是的</p><p id="482b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">#Q2:人(超类)可以查看云吗？-&gt;是的，我能</p><p id="e13a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">#Q3:盲剑侠(子类)可以查看云吗？-&gt;不，我不能</p><p id="de1c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">未知的问题可能发生在系统上，从第一个例子开始，你可以调用“查看”对盲人剑士的操作。所以要解决这个问题，我们应该定义正确的抽象类，盲人不应该像正常人一样实现“视图”方法。</p><p id="f440" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="ly">这个原则的目标是:</em> </strong>避免父类和子类之间的不一致，确保父类可以做到，子类也可以做到。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="049c" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated"><strong class="ak">界面偏析</strong></h2><blockquote class="mz"><p id="0fbe" class="na nb in bd nc nd nw nx ny nz oa lo dk translated">“许多特定于客户端的接口比一个通用接口要好。-维基百科"</p></blockquote><p id="4151" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">这个原则解决了当我们试图实现一个大的接口时所引起的问题。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/4154cfb6183705f2b6707150bee3f8c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iS2-Dq_eCwGa83WMxPnIeg.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/8513e9ce7c12032739eaabf89d09636c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Na-CSqNP2MWxeRH52Ywryg.png"/></div></div></figure><p id="63eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="ly">这个原则的目标是:应该</em> </strong>把一组动作拆分成更小的集合，让一个类只运行它需要的那组动作。它帮助我们减少依赖，减少系统中类之间的耦合，增加接口之间的可重用性。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="8b4e" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">依赖性倒置</h2><blockquote class="mz"><p id="4433" class="na nb in bd nc nd nw nx ny nz oa lo dk translated">一个人应该“依赖抽象，而不是具体。”-维基百科</p></blockquote><figure class="oi oj ok ol om kh gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/6240240b1eaf15a97a70be6d731d8efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*H2BE0hCbvN4XZU9M-NJKyg.png"/></div></figure><p id="7533" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简单来说，你可以认为一个类本身不应该包含依赖(外部服务)。它使这个类变得依赖于那个服务。否则，外部服务应该以单一的方式工作，减少相互之间的依赖，使代码变得干净，易于被另一个类使用。</p><p id="a134" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当一个类想要使用另一个类或另一个服务时，我们可以通过构造函数注入它，或者使用包装器返回一个注入了服务的新实例。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi on"><img src="../Images/ff21a254655e230ddfa2b94225ef6e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSka24UwLvj4eIcTHLEf3g.png"/></div></div></figure></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="5a4a" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">结论</h2><p id="8e98" class="pw-post-body-paragraph kt ku in kv b kw oo jo ky kz op jr lb lc oq le lf lg or li lj lk os lm ln lo ig bi translated">固体不是万能的。对于每一种语言，你都会有一种专门处理问题的方法。一些坚持OOP(类、接口、抽象)的原则不能应用于GUI编程(函数式编程)</p><p id="6b8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它不是一个规则，不要强迫自己坚持它。然而，它有助于你思考如何使你的代码易于阅读和维护。</p><p id="a636" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ly">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ly">plain English . io</em></strong></a><em class="ly">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ly">免费周报</em> </strong> </a> <em class="ly">。关注我们上</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ly">推特</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ly">领英</em> </strong> </a> <em class="ly">与</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ly">不和</em> </strong> </a> <strong class="kv io"> <em class="ly">。</em>T41】</strong></p></div></div>    
</body>
</html>