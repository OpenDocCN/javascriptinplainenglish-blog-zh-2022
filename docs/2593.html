<html>
<head>
<title>The Latest ES13 JavaScript Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最新的ES13 JavaScript特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/latest-es13-javascript-features-24cba45c93f7?source=collection_archive---------0-----------------------#2022-06-20">https://javascript.plainenglish.io/latest-es13-javascript-features-24cba45c93f7?source=collection_archive---------0-----------------------#2022-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/766ba195e743a2a7e7231f37ec7b6854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldbWkZrQEzDoKwDXwtqH9w.png"/></div></div></figure><p id="a45a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ECMAScript 2022 (ES13)是一个新的JavaScript标准集，将于2022年6月发布。让我们回顾一下新版本中的最后几个变化，因为它们<a class="ae kt" href="https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">完成了提案</strong> </a>(那些在<a class="ae kt" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">提案流程</strong> </a>中已经达到第4阶段的，因此在几个实现中实现了的，并且将在下一个实际修订中实现)。</p><p id="a1ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ECMAScript 2022包含九个已完成的提案:</p><ul class=""><li id="82b1" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank">类字段</a>声明</li><li id="4737" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/tc39/proposal-private-fields-in-in" rel="noopener ugc nofollow" target="_blank">人体工程学</a>私人场地的品牌检查</li><li id="32c0" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/tc39/proposal-class-static-block" rel="noopener ugc nofollow" target="_blank">类静态块</a></li><li id="f3bd" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/tc39/proposal-regexp-match-indices" rel="noopener ugc nofollow" target="_blank">正则表达式</a>匹配索引</li><li id="2f36" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/tc39/proposal-top-level-await" rel="noopener ugc nofollow" target="_blank">等待顶层的</a>操作员</li><li id="1144" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">方法<a class="ae kt" href="https://github.com/tc39/proposal-relative-indexing-method" rel="noopener ugc nofollow" target="_blank">。</a>at()【索引】功能</li><li id="4bd8" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noopener ugc nofollow" target="_blank">可访问的</a>object . prototype . hasownproperty()</li><li id="9899" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/tc39/proposal-error-cause" rel="noopener ugc nofollow" target="_blank">错误原因</a></li><li id="ba66" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://github.com/tc39/proposal-array-find-from-last" rel="noopener ugc nofollow" target="_blank">从最后一个数组开始查找</a></li></ul><h1 id="5562" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">类字段声明</h1><p id="f920" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">在ES13之前，我们会这样定义<code class="fe ml mm mn mo b">constructor</code>中的<code class="fe ml mm mn mo b">class</code>的属性:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5ba6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ml mm mn mo b">constructor</code>中，我们定义了两个字段。正如你所看到的，其中一个在名字前面标有一个<code class="fe ml mm mn mo b">_</code>，这只是一个<code class="fe ml mm mn mo b">JavaScript</code>命名约定，将字段声明为<code class="fe ml mm mn mo b">private</code>，意味着它只能从<code class="fe ml mm mn mo b">class</code>方法内部访问。但是，这只是一个命名约定，这就是为什么当我们试图访问它时，它没有引发任何错误。</p><p id="37be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在ES13中，我们有一种更简单的方法来声明<code class="fe ml mm mn mo b">public</code>和<code class="fe ml mm mn mo b">private</code>字段。首先，我们不必在<code class="fe ml mm mn mo b">constructor</code>内部定义它们。其次，我们也可以通过预先确定<code class="fe ml mm mn mo b">#</code>来定义<code class="fe ml mm mn mo b">private</code>字段。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fba8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与前面示例的主要区别在于，这一次，如果我们试图访问或修改类外的字段，将会引发实际的错误。</p><h1 id="6544" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">针对私人领域的人体工程学品牌检查</h1><p id="81d7" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">该功能帮助我们检查<em class="mv">对象</em>中是否有给定的私有槽，为此，使用了<code class="fe ml mm mn mo b">in</code>运算符。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8695" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">在不同的类中使用相同的私有标识符。</strong>两类<code class="fe ml mm mn mo b">User</code>和<code class="fe ml mm mn mo b">Person</code>都有一个标识为<code class="fe ml mm mn mo b">#name</code>的插槽。<code class="fe ml mm mn mo b">in</code>操作者正确区分:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="b3eb" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">类静态块</h1><p id="9117" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">类中的静态初始化块。对于静态数据，我们有<strong class="jx io">静态字段</strong>和<strong class="jx io">静态块</strong>，它们在类创建时执行<strong class="jx io"/>。一个<code class="fe ml mm mn mo b">class</code>在其类体中可以有任意数量的<code class="fe ml mm mn mo b">static {}</code>初始化块。按照它们被声明的顺序，它们和任何交错的静态字段初始值一起被评估。<code class="fe ml mm mn mo b">super.property</code>可在<code class="fe ml mm mn mo b">static</code>块内使用，以引用超类的属性。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="91da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的示例显示了如何从类外的对象授予对类的私有对象的访问权限</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="9ebb" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">正则表达式匹配索引</h1><p id="017a" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">这个升级将允许我们使用<code class="fe ml mm mn mo b">d</code>字符来指定我们想要得到我们的正则表达式的匹配索引(开始和结束)。以前这是不可能的。您只能在字符串匹配操作过程中获取索引数据。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3871" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不知道的是字符串结束时的索引，我们现在可以添加<code class="fe ml mm mn mo b">d</code>字符并查看结果。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fa32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">新字段<code class="fe ml mm mn mo b">indices</code>如您所见，它返回了[15，21]</p><p id="04b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用<code class="fe ml mm mn mo b">Regexp.exec</code>或<code class="fe ml mm mn mo b">String.matchAll</code>来查找匹配列表，它们之间的主要区别在于<code class="fe ml mm mn mo b">Regexp.exec</code>一个接一个地返回结果，而<code class="fe ml mm mn mo b">String.matchAll</code>返回迭代器。</p><h1 id="7b2a" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">顶层等待操作员</h1><p id="fb61" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated"><code class="fe ml mm mn mo b">await</code>操作符只能在<code class="fe ml mm mn mo b">async</code>方法中使用，这可能是您经常遇到的错误。在ES13中，我们将能够在<code class="fe ml mm mn mo b">async</code>方法的上下文之外使用它。</p><p id="5336" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">动态加载模块</strong></p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="424c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果模块加载失败，使用回退</strong></p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9f6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用加载最快的资源</strong></p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="2fbd" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">方法。at()函数用于索引</h1><p id="8691" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">目前，要从可索引对象的末尾访问一个值，通常的做法是编写<code class="fe ml mm mn mo b">arr[arr.length - N]</code>，其中N是从末尾开始的第N个项目(从1开始)。这需要命名索引两次，并为<code class="fe ml mm mn mo b">.length</code>额外增加7个字符。</p><p id="9cfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种方法避免了其中的一些缺点，但是具有其<code class="fe ml mm mn mo b">arr.slice(-N)[0]</code>的一些性能缺点</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fa21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以写下:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c649" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下“可转位”类型有方法<code class="fe ml mm mn mo b">.at()</code>:</p><ul class=""><li id="85d4" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><code class="fe ml mm mn mo b">string</code></li><li id="568e" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe ml mm mn mo b">Array</code></li><li id="c09b" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">所有类型化数组类:<code class="fe ml mm mn mo b">Uint8Array</code>等。</li></ul><h1 id="a630" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">accessible object . prototype . hasownproperty()</h1><p id="ee7d" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">在<code class="fe ml mm mn mo b">JavaScript</code>中，我们已经有了一个<code class="fe ml mm mn mo b">Object.prototype.hasOwnProperty</code>，但是，正如MDN文档所建议的，最好不要在原型本身之外使用<code class="fe ml mm mn mo b">hasOwnProperty</code>,因为它不是一个受保护的属性，这意味着<code class="fe ml mm mn mo b">object</code>可能有一个名为<code class="fe ml mm mn mo b">hasOwnProperty</code>的属性，与<code class="fe ml mm mn mo b">Object.prototype.hasOwnProperty</code>无关</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3586" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个问题<code class="fe ml mm mn mo b">Object.create(null)</code>将创建一个不从<code class="fe ml mm mn mo b">Object.prototype</code>继承的对象，使得那些方法不可访问。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="acc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与调用<code class="fe ml mm mn mo b">Object.hasOwnProperty</code>行为相同的<code class="fe ml mm mn mo b">Object.hasOwn()</code>方法，将我们的<code class="fe ml mm mn mo b">Object</code>作为第一个参数，将我们想要检查的属性作为第二个参数:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="fc72" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">错误原因</h1><p id="0bd4" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">为了帮助意外行为诊断，需要用上下文信息(如错误消息)和错误实例属性来补充错误，以解释当时发生了什么，error对象的<code class="fe ml mm mn mo b">.cause</code>属性将允许我们指定哪个错误导致了另一个错误。因此，错误可以被链接起来，而不需要在条件中包装错误的不必要的和过于复杂的手续。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="91ed" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">从最后一个开始查找数组</h1><p id="89ad" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">在<code class="fe ml mm mn mo b">JavaScript</code>中，我们已经有了<code class="fe ml mm mn mo b">Array.prototype.find</code>和<code class="fe ml mm mn mo b">Array.prototype.findIndex</code>。我们知道从最后一个开始查找可能会有更好的性能(数组尾部的目标元素，可以在队列或堆栈中添加<code class="fe ml mm mn mo b">push</code>或<code class="fe ml mm mn mo b">concat</code>，例如:时间线中最近匹配的时间点)。如果我们关心元素的顺序(数组中可能有重复的项目，例如:数字列表中的最后一个奇数)，更好的方法是使用<em class="mv">新方法</em> <code class="fe ml mm mn mo b">Array.prototype.findLast</code>和<code class="fe ml mm mn mo b">Array.prototype.findLastIndex</code></p><p id="b5b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与其为“从最后开始查找”写作:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2f88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以写道:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="ac98" class="mw lj in bd lk mx my dn lo mz na dp ls kg nb nc lw kk nd ne ma ko nf ng me nh bi translated">最终说明</h2><p id="3c75" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">因此，我们已经了解了可以提高效率的最新ES13 JavaScript特性。这些ES13 JavaScript功能都将在2022年6月发布。让我们等待释放。</p><p id="15b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mv">更多内容见于</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mv"/></strong></a><em class="mv">。</em><a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">《T21》免费周报 </strong> </a> <em class="mv">。在</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mv">Twitter</em></strong></a>和<a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mv">LinkedIn</em></strong></a><em class="mv">上跟随我们。查看我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mv">社区不和</em> </strong> </a> <em class="mv">并加入我们的</em> <a class="ae kt" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mv">人才集体</em> </strong> </a> <em class="mv">。</em></p></div></div>    
</body>
</html>