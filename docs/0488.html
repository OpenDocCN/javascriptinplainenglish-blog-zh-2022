<html>
<head>
<title>The For Loop Dilemma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">For循环困境</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-for-loop-dilemma-11a431abe3b6?source=collection_archive---------22-----------------------#2022-01-27">https://javascript.plainenglish.io/the-for-loop-dilemma-11a431abe3b6?source=collection_archive---------22-----------------------#2022-01-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e6f199b9795effbe230274c82488ee09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwJlO5hW2hb_9ilnGS8Ksg.png"/></div></div></figure><p id="7857" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">稍微熟悉计算机编程的人都会知道什么是循环。这是遍历元素列表的标准方式，在不同的编程语言中有三种最常见的方式，for、while和do-while循环。但是当你在别人的代码中寻找这些循环时，你很可能找不到它们。这是因为每种语言都有自己优化的、不太冗长的循环实现。</p><p id="0bae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript有几十种方法可以迭代不同类型的数据结构，虽然看起来这些方法可以互换，但也有一些特性使每种方法都有其独特之处。</p><blockquote class="kt"><p id="2319" class="ku kv in bd kw kx ky kz la lb lc ks dk translated">Youtube上也有视频版本。</p></blockquote><h1 id="b217" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">良好的旧循环</h1><p id="0419" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">我们将从我们自己的传统循环开始。正是这种美丽的表达方式让你可以浏览一系列元素，并对每一个元素做一些事情。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8767" class="mt lf in mk b gy mu mv l mw mx">let arr = [1,2,3,4,5];<br/>for(let i=0; i&lt;arr.length; i++){<br/>   console.log(arr[i]);  //1 2 3 4 5<br/>}</span></pre><p id="d53b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种类型的循环中，你会注意到几个要点，那就是你可以从数组内部的任何地方运行这个循环。例如，如果您愿意，可以只对数组的后半部分运行循环。您也可以在任何时候使用<code class="fe mh mi mj mk b">break</code>关键字来中断循环。它让你可以完全控制你想对iterable做什么。</p><p id="7239" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个循环本质上比你在下面的文章中找到的其他遍历方法更快，比如<code class="fe mh mi mj mk b">for each</code>或<code class="fe mh mi mj mk b">for…of</code>，但是在现代浏览器中，这些遍历方法也有优化。因此，从性能角度来看，它们几乎都处于同一水平。</p><h1 id="43ac" class="le lf in bd lg lh li lj lk ll lm ln lo lp my lr ls lt mz lv lw lx na lz ma mb bi translated">for-each循环</h1><p id="0614" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">现在，这个循环有点不同。它不是遍历数组的每个索引，而是对数组中的每个元素执行一个回调函数。这个回调函数接受几个参数。第一个是实际的数组元素。接下来的两个参数，元素的索引和被调用的数组<code class="fe mh mi mj mk b">forEach</code>，是可选的。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d141" class="mt lf in mk b gy mu mv l mw mx">let arr = [1,2,3,4,5]<br/>arr.forEach(element =&gt; console.log(element));  //1 2 3 4 5</span></pre><p id="00b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与典型的<code class="fe mh mi mj mk b">for</code>循环相比，这更易于阅读，但它也有一些缺点。这个循环不允许你使用<code class="fe mh mi mj mk b">break</code>关键字。不管添加什么中断条件，它都将遍历整个数组。</p><p id="d112" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在循环结束时，它将返回<code class="fe mh mi mj mk b">undefined</code>。因此，如果您想将其他方法链接到这个循环，或者甚至将结果存储在一个单独的变量中，您就不能这样做。从技术上来说，你可以把它存储在一个变量中，但它将是<code class="fe mh mi mj mk b">undefined</code>。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fa29" class="mt lf in mk b gy mu mv l mw mx">let arr = [1,2,3,4,5]<br/>let result = arr.forEach(element =&gt; {<br/>   return element * element   //Returning square of each element<br/>})</span><span id="36ba" class="mt lf in mk b gy nb mv l mw mx">console.log(result)  //undefined</span></pre><p id="e57c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种类型循环的一些常见用例是将每个数组元素存储在数据库中，或者用每个数组元素作为上下文来调用API。在这些情况下，你实际上并不期望从这个循环中得到任何回报，所以使用它更有意义。现在，如果你想从循环中返回一个值，你应该使用<code class="fe mh mi mj mk b">map</code>方法。</p><h1 id="f907" class="le lf in bd lg lh li lj lk ll lm ln lo lp my lr ls lt mz lv lw lx na lz ma mb bi translated">映射方法</h1><p id="54f9" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">这个和<code class="fe mh mi mj mk b">forEach</code>很像。它为数组中的每个元素执行一个回调函数。它也有同样的一组参数，就像<code class="fe mh mi mj mk b">forEach</code>循环一样。这里唯一的关键区别是，它不是返回<code class="fe mh mi mj mk b">undefined</code>，而是在最后返回一个数组。所以你在回调函数中添加的任何逻辑，都将为每个元素执行，这个新元素将被添加到一个数组中，这是最后返回的结果。所以这让我们把结果存储在一个变量中，甚至链接这个函数。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2b3e" class="mt lf in mk b gy mu mv l mw mx">let arr = [1,2,3,4,5]<br/>let result = arr.forEach(element =&gt; {<br/>   return element * element   //Returning square of each element<br/>})</span><span id="4568" class="mt lf in mk b gy nb mv l mw mx">console.log(result)  //1 4 9 16 25</span><span id="5f57" class="mt lf in mk b gy nb mv l mw mx">//Chaining the "find" method to the result<br/>console.log(result.find(num =&gt; num == 9))  //9</span></pre><p id="5a0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以基本上，如果你想修改数组中的元素并将它们存储在前端，使用<code class="fe mh mi mj mk b">map</code>会更有意义。但是如果您想对数组中的每个元素进行操作，并且不期望任何回报，那么您应该使用<code class="fe mh mi mj mk b">forEach</code>循环。</p><h1 id="38f7" class="le lf in bd lg lh li lj lk ll lm ln lo lp my lr ls lt mz lv lw lx na lz ma mb bi translated">for…of循环</h1><p id="ff93" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">就功能而言，<code class="fe mh mi mj mk b">for...of</code>循环最接近传统的<code class="fe mh mi mj mk b">for</code>循环。它创建了一个遍历数组、字符串、映射或集合等可迭代对象的循环。(令人惊讶的是，一个对象不是可迭代的，但是它可以被转换成可迭代的)</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="13d1" class="mt lf in mk b gy mu mv l mw mx">let arr = [1,2,3,4,5]<br/>let dummyMap = new Map([['a', 1], ['b', 2], ['c', 3]]);</span><span id="52b8" class="mt lf in mk b gy nb mv l mw mx">//FOR OF ON AN ARRAY<br/>for (let num of arr) {<br/>   console.log(num);    //1 2 3 4 5<br/>}</span><span id="94c8" class="mt lf in mk b gy nb mv l mw mx">//FOR OF ON A STRING<br/>for (let str of "Hey there") {<br/>   console.log(str);   //H e y   t h e r e<br/>}</span><span id="e9dd" class="mt lf in mk b gy nb mv l mw mx">//FOR OF ON A MAP<br/>for (let [key, value] of dummyMap) {<br/>   console.log(key, value);    // a 1   b 2   c 3<br/>}</span></pre><p id="47c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在一个<code class="fe mh mi mj mk b">for</code>循环中，由于我们专门设置了一个初始化表达式，我们可以从循环中的任何地方开始。这在<code class="fe mh mi mj mk b">for…of</code>循环中是不可能的。(甚至是<code class="fe mh mi mj mk b">forEach</code>循环或<code class="fe mh mi mj mk b">map</code>方法)。</p><p id="b590" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，您不能像在传统的for循环中那样访问索引。但是由于数组基本上是Javascript中的一个对象，所以您可以从对象的原型中使用<code class="fe mh mi mj mk b">entries</code>方法。因此，现在可以迭代数组的条目(一个键值对)，而不是迭代数组。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a7a5" class="mt lf in mk b gy mu mv l mw mx">let arr = [1,2,3,4,5]<br/>for (let num of Object.keys(arr)) {<br/>   console.log(num); // ['0',1] ['1',2] ['2',3] ['3',4] ['4',5]<br/>}</span></pre><h1 id="568e" class="le lf in bd lg lh li lj lk ll lm ln lo lp my lr ls lt mz lv lw lx na lz ma mb bi translated">for…in循环</h1><p id="42be" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated"><code class="fe mh mi mj mk b">for...in</code> <strong class="jx io"> </strong>语句<strong class="jx io"> </strong>遍历对象的所有可枚举属性，包括继承的属性。马上你可以看到这个迭代方法更适合于一个对象而不是一个数组。这个定义还提到了一些关于可枚举的东西。所以，如果一个属性是可枚举的，这仅仅意味着你可以在迭代对象时访问这个属性。例如，在这个物体内部，</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="27b1" class="mt lf in mk b gy mu mv l mw mx">const Person = {<br/>   name : "John",<br/>   height : "6ft"<br/>}</span></pre><p id="e747" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我现在尝试在这个对象上使用<code class="fe mh mi mj mk b">for...in</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="516a" class="mt lf in mk b gy mu mv l mw mx">for (let prop in Person) {<br/>    console.log(num);  // name height<br/>}</span></pre><p id="4da3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它给了我Person对象中的所有属性。所以这意味着属性name和height都是可枚举的。现在要创建一个不可枚举的属性，我们可以使用<code class="fe mh mi mj mk b">Object.defineProperty()</code>方法。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ec0a" class="mt lf in mk b gy mu mv l mw mx">Object.defineProperty(person, "gender", {<br/>   value: "Male",<br/>   enumerable: false<br/>})</span></pre><p id="bf9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个方法让我们为一个对象创建一个属性，这个属性可以根据我们的用例进一步配置。所以现在，如果我再次运行该文件，我将获得与添加性别之前相同的属性(姓名和身高)。但是，如果我将enumerable标志设置为true，我将得到姓名、身高和性别作为结果。</p><p id="6a00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您也可以使用<code class="fe mh mi mj mk b">for...in</code>来迭代数组。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a95c" class="mt lf in mk b gy mu mv l mw mx">let arr = [1,2,3,4,5]<br/>for (let num in arr) {<br/>   console.log(num);  //0 1 2 3 4<br/>}</span></pre><p id="5b61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它不是返回实际的元素，而是给我们每个元素的索引。现在这里的主要问题是<code class="fe mh mi mj mk b">for...in</code>循环不仅迭代数组内部的内容，还会迭代添加到原型链中的任何其他属性。</p><p id="8ca4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我向数组原型添加了一个名为name的随机属性，并将该属性的值设置为“John”。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="52c5" class="mt lf in mk b gy mu mv l mw mx">let arr = [1,2,3,4,5]<br/>Array.prototype.name = "John"<br/>for (let num in arr){<br/>   console.log(num)  //0 1 2 3 4 name<br/>}</span></pre><p id="9290" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您将看到，即使我们没有在数组中添加“name”属性，它仍然在结果中添加了名称，因为它遍历了整个原型链。</p><p id="041c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以你应该主要使用<code class="fe mh mi mj mk b">for…in</code>进行调试，看看一个对象上有哪些属性。要遍历一个数组，你应该坚持传统的<code class="fe mh mi mj mk b">for</code>循环。</p><h2 id="5928" class="mt lf in bd lg nc nd dn lk ne nf dp lo kg ng nh ls kk ni nj lw ko nk nl ma nm bi translated">关键要点</h2><ul class=""><li id="d3c0" class="nn no in jx b jy mc kc md kg np kk nq ko nr ks ns nt nu nv bi translated">你可以使用典型的<code class="fe mh mi mj mk b">for</code>循环来完成几乎任何事情，而且它比大多数其他方法都要快。</li><li id="9a13" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated"><code class="fe mh mi mj mk b">forEach</code>返回未定义，而<code class="fe mh mi mj mk b">map</code>返回数组。所以你可以使用<code class="fe mh mi mj mk b">map</code>来存储信息或者链接方法，但是你不能用<code class="fe mh mi mj mk b">forEach</code>来做。</li><li id="a7f7" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated">如果您只想对数组中的每个元素运行操作而不担心结果，您应该使用<code class="fe mh mi mj mk b">forEach</code>，但是如果您想修改数组并在应用程序中的某个地方使用这个修改后的版本，您应该使用<code class="fe mh mi mj mk b">map</code>。</li><li id="1182" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated">您无法脱离<code class="fe mh mi mj mk b">forEach</code>或<code class="fe mh mi mj mk b">map</code>。</li><li id="82e8" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated"><code class="fe mh mi mj mk b">for...of</code>循环遍历可迭代对象，如数组、字符串、映射或集合。您不能使用for of来访问索引，但是您可以在数组上使用<code class="fe mh mi mj mk b">Object.entries</code>方法来获取每个元素的索引和值，然后访问索引。</li><li id="efc0" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated">你可以打破一个<code class="fe mh mi mj mk b">for...of</code>循环。所以你不必遍历数组中的每一个元素，而在遇到<code class="fe mh mi mj mk b">forDach</code>和<code class="fe mh mi mj mk b">map</code>的情况下，你会这样做。</li><li id="7ca9" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated"><code class="fe mh mi mj mk b">for...in</code>循环遍历对象的可枚举属性。因为数组也是一个对象，数组索引是可枚举的属性，所以可以使用<code class="fe mh mi mj mk b">for...in</code>遍历数组。作为回报，您可以获得每个元素的索引值。</li><li id="da4b" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated">但是不建议在数组上使用它，因为可能会得到意想不到的结果。该规范本身指出，不同浏览器之间的元素顺序可能会不匹配。</li><li id="5dca" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated">此外,<code class="fe mh mi mj mk b">for...in</code>将在原型链中寻找所有可枚举的属性，因此您可能会得到除数组元素之外的额外的、意外的值。</li><li id="c0c1" class="nn no in jx b jy nw kc nx kg ny kk nz ko oa ks ns nt nu nv bi translated">所以你通常应该对对象的<code class="fe mh mi mj mk b">for...in</code>方法进行调试，看看它有什么属性。</li></ul><h1 id="b588" class="le lf in bd lg lh li lj lk ll lm ln lo lp my lr ls lt mz lv lw lx na lz ma mb bi translated">结论</h1><p id="7270" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">如果你对这篇文章有任何疑问或建议，你可以在评论中提出来，或者你可以通过下面提到的我的社交网站与我联系。</p><p id="9afa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Youtube上也有这篇博文的视频版本。</p><p id="1432" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ld" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/><a class="ae ld" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae ld" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae ld" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">GitHub</a></p><p id="63f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ob">更多内容看</em> <a class="ae ld" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ob">说白了就是</em> </strong> </a> <em class="ob">。报名参加我们的</em> <a class="ae ld" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ob">免费每周简讯</em> </strong> </a> <em class="ob">。在我们的</em> <a class="ae ld" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ob">社区</em> </strong> </a> <em class="ob">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>