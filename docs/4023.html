<html>
<head>
<title>What is the JavaScript Array.filter() Method?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Array.filter()方法是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-the-javascript-array-filter-method-13800c2f6488?source=collection_archive---------12-----------------------#2022-10-18">https://javascript.plainenglish.io/what-is-the-javascript-array-filter-method-13800c2f6488?source=collection_archive---------12-----------------------#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c9e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">filter()方法用于过滤一个数组并返回该数组的一个子集。下面是filter()方法的工作原理。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4ab6ebaaa6041c081903f6cd9c45300a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gryk_wd9iOkLtNe9h2nzGQ.png"/></div></div></figure><p id="2717" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript中的filter方法创建了一个数组的浅层副本，并根据许多条件对其进行过滤。它接受回调函数。<code class="fe ln lo lp lq b">filter</code>产生的数组通常是原始数组的缩小版。下面是一个基本的例子:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="0b5a" class="lv lw iq lq b gy lx ly l lz ma">let myArray = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let filteredArray = myArray.filter((element) =&gt; {<br/>    return (element == '🔑' || element == '🔩'))<br/>});</span><span id="52ef" class="lv lw iq lq b gy mb ly l lz ma">console.log(filteredArray); // [ '🔑', '🔩' ]</span></pre><p id="3066" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，如果元素返回<code class="fe ln lo lp lq b">true</code>，filter方法将允许该元素位于新的过滤后的数组中。它有效地遍历每个元素，并对其运行测试，以查看应该留下什么。由于arrow函数在一行中隐式返回true，您可能会看到如下代码的简化版本:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="f9e5" class="lv lw iq lq b gy lx ly l lz ma">let myArray = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let filteredArray = myArray.filter(element =&gt; element == '🔑' || element == '🔩');</span><span id="a5f5" class="lv lw iq lq b gy mb ly l lz ma">console.log(filteredArray); // [ '🔑', '🔩' ]</span></pre><h1 id="3415" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">filter方法回调函数</h1><p id="b579" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">如上所述，<code class="fe ln lo lp lq b">filter</code>接受回调函数。回调函数由3个参数组成:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="93ef" class="lv lw iq lq b gy lx ly l lz ma">Array.filter((element, index, array) =&gt; {<br/>    // Filter the array<br/>});</span></pre><p id="c1fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看它们各自的功能</p><h1 id="1997" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">元素</h1><p id="ccac" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这是<code class="fe ln lo lp lq b">filter</code>正在检查的当前元素。<code class="fe ln lo lp lq b">filter</code>遍历数组中的每一项，测试它是否应该存在于新的过滤后的数组中。</p><h1 id="8447" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">指数</h1><p id="2361" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这是我们正在处理的数组项的从零开始的索引。例如，如果我们正在查看数组中的第一个元素，这将是<code class="fe ln lo lp lq b">0</code>。</p><h1 id="b860" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">排列</h1><p id="bfec" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这是整个数组，如果你想对原始数组做些什么的话。</p><h1 id="cfc7" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">在筛选方法中改变数组</h1><p id="0ea2" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">因为filter使用了回调函数，所以有可能改变我们正在检查的原始数组。例如，我们可以在每次筛选一个项目时，将新项目推送到数组中:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="5afd" class="lv lw iq lq b gy lx ly l lz ma">let myArray = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let filteredArray = myArray.filter((element) =&gt; {<br/>    myArray.push('⚡️');<br/>    return true;<br/>});</span><span id="18b5" class="lv lw iq lq b gy mb ly l lz ma">console.log(filteredArray); // [ '⚡️', '🔎', '🔑', '🔩' ]</span></pre><p id="440f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能已经意识到，这将产生一个无限循环。幸运的是，就像在<a class="ae my" href="https://fjolt.com/article/javascript-reduce" rel="noopener ugc nofollow" target="_blank"> reduce </a>中一样，Javascript不允许这种情况发生——相反，以这种方式添加到数组中的任何新元素都会被忽略。然而，现有元素的突变完全没问题:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="fd87" class="lv lw iq lq b gy lx ly l lz ma">let myArray = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let filteredArray = myArray.filter((element, index) =&gt; {<br/>    myArray[index + 1] = '⚡️';<br/>    return (element == '⚡️');<br/>});</span><span id="eb1e" class="lv lw iq lq b gy mb ly l lz ma">console.log(filteredArray); // [ '⚡️', '⚡️', '⚡️', '⚡️' ]</span></pre><h1 id="03aa" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">过滤对象数组</h1><p id="230c" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">过滤对象数组遵循与数组相同的约定。我们可以使用<code class="fe ln lo lp lq b">.</code>符号过滤数组中对象的子属性。例如，如果我想通过<code class="fe ln lo lp lq b">age</code>过滤下面的数组，其中年龄应该是&gt; 18，我会这样做:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="7df2" class="lv lw iq lq b gy lx ly l lz ma">let myArray = [ { age: 4 }, { age: 12 }, { age: 19 }, { age: 21 } ];<br/>let filteredArray = myArray.filter((element, index) =&gt; {<br/>    return (element.age &gt; 18);<br/>});<br/>console.log(filteredArray); // [ { age: 19 }, { age: 21 } ]</span></pre><h1 id="e462" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">按搜索标准过滤数组</h1><p id="30d6" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated"><code class="fe ln lo lp lq b">filter</code>的一个常见用途是获取一个值数组，并基于一个搜索词对它们进行搜索。这可以用<code class="fe ln lo lp lq b">includes</code>或<code class="fe ln lo lp lq b">regex</code>来完成。例如:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="1546" class="lv lw iq lq b gy lx ly l lz ma">let myArray = [ 'cat', 'catdog', 'dog', 'fish', 'fishcat' ]<br/>let filteredArray = myArray.filter((element, index) =&gt; {<br/>    return element.match(/cat/)<br/>});<br/>console.log(filteredArray); // ['cat', 'catdog', 'fishcat']</span></pre><h1 id="7e61" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">Filter生成数组的浅层副本</h1><p id="201f" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">虽然看起来<code class="fe ln lo lp lq b">filter</code>制作了原始数组的新副本，但事实并非如此。事实上，<code class="fe ln lo lp lq b">filter</code>对原始数组做了一个<strong class="kt ir">浅拷贝</strong>，这意味着如果我们改变数组中的对象，原始数组也会改变。为了理解这一点，让我们再次看看我们的年龄例子:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="0671" class="lv lw iq lq b gy lx ly l lz ma">let myArray = [ { age: 4 }, { age: 12 }, { age: 19 }, { age: 21 } ];<br/>let filteredArray = myArray.filter((element, index) =&gt; {<br/>    return (element.age &gt; 18);<br/>});</span><span id="6214" class="lv lw iq lq b gy mb ly l lz ma">console.log(filteredArray); // [ { age: 19 }, { age: 21 } ]</span><span id="dfe6" class="lv lw iq lq b gy mb ly l lz ma">filteredArray[0].age = 50;<br/>filteredArray[1] = { age: 40 };</span><span id="3f48" class="lv lw iq lq b gy mb ly l lz ma">console.log(filteredArray); // [ { age: 50 }, { age: 40 } ]<br/>console.log(myArray); // [ { age: 4 }, { age: 12 }, { age: 50 }, { age: 21 } ]</span></pre><p id="d3a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，使用<code class="fe ln lo lp lq b">filteredArray[0].age</code>符号修改过滤后的数组也会修改原始数组——但是<strong class="kt ir">等一下</strong>！<code class="fe ln lo lp lq b">filteredArray[1] = { age: 40 }</code>只改变过滤后的数组。这是因为尽管Javascript将<code class="fe ln lo lp lq b">.</code>符号解释为更新两个数组，但它将方括号符号<code class="fe ln lo lp lq b">[]</code>解释为在过滤后的数组的第二个位置设置一个新值。</p><p id="ed1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这只是Javascript的另一个怪癖，可能会令人困惑，但知道它非常有用！</p><h1 id="d57d" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="bf23" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">filter方法被广泛使用，并且是一种基于特定标准更改和创建新数组子集的简单方法。需要注意的是，只有原始数组的浅层副本，所以以某些方式修改数组会影响原始数组。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="d93f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ng">更多内容看</em> <a class="ae my" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">说白了。报名参加我们的</em> <a class="ae my" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们上</em> <a class="ae my" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">推特</em> </strong> </a>，<a class="ae my" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">领英</em> </strong> </a> <strong class="kt ir"> <em class="ng">，</em></strong><a class="ae my" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">YouTube</em></strong></a><strong class="kt ir"><em class="ng">，以及</em></strong><em class="ng"><a class="ae my" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">不和</em> </strong> </a></em> </strong> <em class="ng">对成长黑客感兴趣？检查出</em> </a><a class="ae my" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">电路</em> </strong> </a> <strong class="kt ir"> <em class="ng">。</em>T77】</strong></p></div></div>    
</body>
</html>