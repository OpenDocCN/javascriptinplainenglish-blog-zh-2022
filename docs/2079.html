<html>
<head>
<title>Dockerize Next.js With Prisma App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Prisma App实现Dockerize Next.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dockerize-next-js-with-prisma-app-ff4ab5d79a31?source=collection_archive---------2-----------------------#2022-05-12">https://javascript.plainenglish.io/dockerize-next-js-with-prisma-app-ff4ab5d79a31?source=collection_archive---------2-----------------------#2022-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd8f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Prisma应用程序的简单docker文件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/be2b5cb143380608f04019280083c0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avWsA_iSl1RRg-b0z5HaUA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: Author</figcaption></figure><p id="f4bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您是否曾经遇到过这样的情况:您找到了部署应用程序的理想平台，但却未能对应用程序进行dockerize？</p><p id="7c0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近我想在Fly.io上部署我的SaaS <a class="ae lr" href="https://usewildfire.com" rel="noopener ugc nofollow" target="_blank"> Wildfire </a>，唯一的方法是使用Dockerfiles来部署。</p><p id="c0d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我遇到了一堆问题，除了一堆不直观的GitHub问题之外，我找不到任何关于在M1芯片上使用Prisma的Next.js指南。</p><p id="f81e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我成功地建立了一个图像，但它非常大，我花了将近半个小时来建立。</p><p id="5f7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理想情况下，您希望docker图像尽可能小，当您使用Prisma时，您需要在开始Next.js项目之前运行几个命令来生成Prisma客户端。</p><p id="aacd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本指南中，我们将为Next.js和Prisma应用程序构建一个精简、简单的Docker映像。我假设你没有对你的应用程序进行docker化，并且对docker文件有一定的了解。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="01bc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">M1芯片的Mac用户注意</h1><p id="ff5d" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">如果你没有M1芯片，你可以安全地跳过这一部分。</p><p id="1a49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">苹果M1芯片、docker和Prisma似乎相处得不太好。</p><p id="31dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当你用Node alpine base image在M1芯片上运行Prisma命令<code class="fe mx my mz na b">npx prisma generate</code>时，它会抛出许多错误，提示你缺少库或者花费了非常长的时间(超过20分钟)。你可以在这里找到一个这样的问题<a class="ae lr" href="https://github.com/prisma/prisma/issues/7755" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4e6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用任何其他节点图像可能可行，但它会极大地影响您的图像大小。</p><p id="cb34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">解决方案？</strong></p><p id="1a4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只需使用远程生成器。这不是理想的方式，但我强烈建议使用远程构建器，因为它们运行在x86架构上，而不是我们的M1芯片的arm64上。</p><p id="7d2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Fly.io免费提供远程构建器。您还可以设置一个GitHub操作来为您构建docker映像，并将其推送到Docker hub(如果您想要一个关于设置它的详细指南，请对本文进行评论)。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="013f" class="nb ma iq bd mb nc nd dn mf ne nf dp mj le ng nh ml li ni nj mn lm nk nl mp nm bi translated">Docker文件</h2><p id="518c" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">下面是整个Dockerfile文件，您可以安全地复制和试验。这个Dockerfile文件使用NPM作为包管理器。</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="8b6d" class="nb ma iq na b gy nr ns l nt nu">FROM node:16-alpine AS builder</span><span id="c6b8" class="nb ma iq na b gy nv ns l nt nu"># Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine to understand why libc6-compat might be needed.</span><span id="8bc6" class="nb ma iq na b gy nv ns l nt nu">RUN apk add --no-cache libc6-compat</span><span id="7211" class="nb ma iq na b gy nv ns l nt nu">WORKDIR /app</span><span id="fe30" class="nb ma iq na b gy nv ns l nt nu">COPY . .<br/></span><span id="0f29" class="nb ma iq na b gy nv ns l nt nu">RUN npm ci</span><span id="b622" class="nb ma iq na b gy nv ns l nt nu">ENV NEXT_TELEMETRY_DISABLED 1</span><span id="acdc" class="nb ma iq na b gy nv ns l nt nu">RUN npx prisma migrate deploy</span><span id="f830" class="nb ma iq na b gy nv ns l nt nu">RUN npx prisma generate</span><span id="3640" class="nb ma iq na b gy nv ns l nt nu">RUN npm run build</span><span id="ba07" class="nb ma iq na b gy nv ns l nt nu">RUN mkdir -p /app/.next/cache/images<br/></span><span id="be26" class="nb ma iq na b gy nv ns l nt nu"># Production image, copy all the files and run next</span><span id="2f57" class="nb ma iq na b gy nv ns l nt nu">FROM node:16-alpine AS runner</span><span id="012f" class="nb ma iq na b gy nv ns l nt nu">WORKDIR /app</span><span id="c1bf" class="nb ma iq na b gy nv ns l nt nu">ENV NODE_ENV production</span><span id="2a9e" class="nb ma iq na b gy nv ns l nt nu">ENV NEXT_TELEMETRY_DISABLED 1</span><span id="bafe" class="nb ma iq na b gy nv ns l nt nu">RUN addgroup --system --gid 1001 nodejs</span><span id="a980" class="nb ma iq na b gy nv ns l nt nu">RUN adduser --system --uid 1001 nextjs<br/></span><span id="282a" class="nb ma iq na b gy nv ns l nt nu">COPY --chown=nextjs:nodejs --from=builder /app/ ./</span><span id="cb5a" class="nb ma iq na b gy nv ns l nt nu">USER nextjs</span><span id="302e" class="nb ma iq na b gy nv ns l nt nu">ENV PORT 3000</span><span id="5912" class="nb ma iq na b gy nv ns l nt nu">CMD ["npm", "run","start"]</span></pre><p id="356d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有。dockerignore文件:</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="1d16" class="nb ma iq na b gy nr ns l nt nu">node_modules</span><span id="53d0" class="nb ma iq na b gy nv ns l nt nu">.next</span><span id="2e50" class="nb ma iq na b gy nv ns l nt nu">.env.local</span></pre><p id="1340" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们把app分成了两个阶段，叫做<code class="fe mx my mz na b">runner</code>和<code class="fe mx my mz na b">builder</code>。</p><p id="86eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这称为多阶段构建。核心概念是通过仅从<code class="fe mx my mz na b">builder</code>阶段复制必要的文件来创建非常精简的映像。</p><p id="0946" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在构建阶段，我们安装依赖项并构建Next.js应用程序，而在构建阶段，我们只是复制文件。</p><h2 id="9efe" class="nb ma iq bd mb nc nd dn mf ne nf dp mj le ng nh ml li ni nj mn lm nk nl mp nm bi translated">构建阶段</h2><p id="a850" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">在构建器阶段，我们已经使用Node.js 16 alpine image作为基础。</p><p id="9dc7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还增加了<code class="fe mx my mz na b">libc6-compat</code>。</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="0da2" class="nb ma iq na b gy nr ns l nt nu">RUN apk add --no-cache libc6-compat</span></pre><p id="e6e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要这个库，因为它为<code class="fe mx my mz na b">glibc</code>提供了兼容性库，而<code class="fe mx my mz na b">glibc</code>为GNU系统和GNU/Linux系统以及许多其他使用Linux作为内核的系统提供了核心库。</p><p id="541a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们运行标准命令来安装所有的依赖项。</p><p id="fdc7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在构建发生之前运行Prisma generate命令是很重要的。</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="8cf1" class="nb ma iq na b gy nr ns l nt nu">RUN npx prisma migrate deploy</span><span id="c9a7" class="nb ma iq na b gy nv ns l nt nu">RUN npx prisma generate</span></pre><p id="8e39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">确保您的文件夹中有一个包含<code class="fe mx my mz na b">DATABASE_URL</code>变量的<code class="fe mx my mz na b">.env</code>文件。</p><p id="555d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我尝试在<code class="fe mx my mz na b">.next/cache/images</code>中运行docker镜像而不创建目录，但是我遇到了一些问题，因此我必须显式地创建目录。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="aaec" class="nb ma iq bd mb nc nd dn mf ne nf dp mj le ng nh ml li ni nj mn lm nk nl mp nm bi translated">转轮阶段</h2><p id="e364" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">在跑步者阶段，我们使用了与构建者阶段相同的基础图像。</p><p id="8165" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们将环境变量<code class="fe mx my mz na b">NODE_ENV</code>设置为生产，并选择退出Next.js <a class="ae lr" href="https://nextjs.org/telemetry" rel="noopener ugc nofollow" target="_blank">遥测</a>收集。</p><p id="2d7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">出于安全目的，我们还创建了一个用户组和用户，并相应地从构建器阶段的<code class="fe mx my mz na b">./app</code>文件夹中复制了文件。</p><p id="44fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">文件的其余部分是不言自明的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="208f" class="nb ma iq bd mb nc nd dn mf ne nf dp mj le ng nh ml li ni nj mn lm nk nl mp nm bi translated"><strong class="ak">结论</strong></h2><p id="cf4b" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">尽管docker文件对于部署来说是完美的，并且在生产服务器中工作得非常好，但我仍然无法弄清楚如何在我的Macbook Air M1中构建这个映像。</p><p id="01a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一种可能的方法是使用<code class="fe mx my mz na b">buildx</code>设置平台<code class="fe mx my mz na b">linux/amd64</code>。</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="8204" class="nb ma iq na b gy nr ns l nt nu">docker buildx build --tag [image-tag] -o type=image --platform=linux/arm64,linux/amd64 .</span></pre><p id="c8ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，即使这样，它在20分钟的构建映像抛出错误(关于内存使用限制和其他类似问题)后还是失败了。</p><p id="d11b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论如何，我希望这些问题在不久的将来得到解决，因为苹果不会很快停止推出苹果硅芯片。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="b35a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mw">更多内容请看</em><a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="mw">plain English . io</em></strong></a><em class="mw">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="mw">Twitter</em></strong></a><em class="mw">和</em><strong class="kx ir"><em class="mw"/></strong><a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="mw">LinkedIn</em></strong></a><em class="mw">。加入我们的</em> <a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="mw">社区</em> </strong> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>