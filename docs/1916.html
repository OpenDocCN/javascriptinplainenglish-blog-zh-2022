<html>
<head>
<title>Why You Should Use Enums for Better Angular Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该使用枚举为更好的角度应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-enums-for-better-angular-apps-ee2d3992f21?source=collection_archive---------3-----------------------#2022-04-29">https://javascript.plainenglish.io/use-enums-for-better-angular-apps-ee2d3992f21?source=collection_archive---------3-----------------------#2022-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b42a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么以及如何在你的Angular应用中使用枚举，而不是使用旧的容易出错的数据操作方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ebc7a95d87c303c4a466de8a14ff312b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oau3dzpwaMjYD2CEfW_Q0w.png"/></div></div></figure><p id="6212" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">枚举是定义变量的一种方式，变量的值可以是几个常量中的一个。它们非常适合于状态驱动设计、强类型函数参数以及在代码中显示意图。他们绝对应该在你的Angular app里有一席之地。</p><h2 id="b04f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">组件中的枚举</h2><p id="31ff" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">设想一个用来显示用户状态的UserComponent。用户可以是我们虚拟订阅服务的标准会员、黄金会员或白金会员。当然，您可以像这样简单地设置您的组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f327" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，<code class="fe mn mo mp mq b">memberStatus</code>是一个字符串变量，我们(希望)将它设置为“标准”、“黄金”或“白金”。这个方法是可行的，但是现在每当我们想要操作或引用<code class="fe mn mo mp mq b">memberStatus</code>时，我们必须将它与我们期望的三个字符串中的一个进行比较。如果成员类型改变了怎么办？没有简单的方法找到所有处理<code class="fe mn mo mp mq b">memberStatus</code>的代码并相应地更新它。如果一个API或其他组件返回一个大写的<code class="fe mn mo mp mq b">memberStatus</code>怎么办？事情会很快变得一团糟。或者，如果我们只是忘记了这三种成员类型是什么呢？我们必须回到这个组件，仔细检查预期值。</p><p id="980d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了enums，这些问题就可以为我们解决了。在这个例子中，我们可以定义一个枚举来帮助我们:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="eb36" class="ln lo iq mq b gy mv mw l mx my"><em class="mz">enum </em>MemberType {<br/>  <em class="mz">Standard</em>,<br/>  <em class="mz">Gold</em>,<br/>  <em class="mz">Platinum<br/></em>}</span></pre><p id="ff23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了一个具体的数据类型来定义我们的<code class="fe mn mo mp mq b">memberStatus</code>可能是什么。如果将来添加成员类型，我们可以简单地将它们添加到这个枚举中，而不需要进一步修改代码。现在我们的组件看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="917e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们将<code class="fe mn mo mp mq b">memberStatus</code>从一个字符串更改为新的MemberType。任何引用它的函数现在也可以用MemberType类型化。这提高了清晰度，有助于简化编程(假设使用了智能IDE)，并大大降低了无效数据的风险。</p><p id="ec09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步我们将会遇到一个问题。如果我们尝试在模板中引用我们的枚举，我们将得到一个编译错误，告诉我们“MemberType”在类型“UserComponent”上不存在问题是本地和导入的枚举在组件外部都不可用。</p><p id="35e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们可以定义一个简单的<code class="fe mn mo mp mq b">get</code>函数来返回枚举结构，如下所示:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="5078" class="ln lo iq mq b gy mv mw l mx my"><em class="mz">public get </em>MemberType(): <em class="mz">typeof </em>MemberType{ <em class="mz">return </em>MemberType; }</span></pre><p id="34b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，函数名不需要与枚举名匹配，但是这样很好，因为它允许我们以一种看起来像是直接引用枚举的方式调用它。这允许我们有一个引用枚举的模板:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="4bcb" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">关于枚举的更多信息</h2><p id="9908" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">你还可以使用枚举做更多的事情。您可以创建字符串枚举:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="7b70" class="ln lo iq mq b gy mv mw l mx my"><em class="mz">enum </em>MemberType {<br/>  <em class="mz">Standard = "STANDARD"</em>,<br/>  <em class="mz">Gold = "GOLD"</em>,<br/>  <em class="mz">Platinum = "PLATINUM"<br/></em>}</span></pre><p id="52c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这对于在组件模板中显示文本或序列化数据可能很有用，尤其是出于调试目的。</p><p id="3c92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，您可以创建数字枚举。此外，只给第一个值一个数字会自动递增，并给后面的值适当的数字:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="f1b3" class="ln lo iq mq b gy mv mw l mx my"><em class="mz">enum </em>MemberType {<br/>  <em class="mz">Standard = "1"</em>,<br/>  <em class="mz">Gold</em>, // Will have value 2<br/>  <em class="mz">Platinum // Will have value 3<br/></em>}</span></pre><p id="dcd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">枚举还可以有计算值、常数值，以及用于更多的应用。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="f57e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望您看到枚举的价值，并且不再在您的应用程序中使用中世纪的、容易出错的数据操作方法。如需进一步阅读:</p><div class="nh ni gp gr nj nk"><a href="https://www.typescriptlang.org/docs/handbook/enums.html#computed-and-constant-members" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">手册-列举</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">枚举是TypeScript具有的为数不多的特性之一，它不是JavaScript的类型级扩展。枚举允许一个…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">www.typescriptlang.org</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kp nk"/></div></div></a></div><p id="00eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mz">更多内容请看</em><a class="ae nz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mz">plain English . io</em></strong></a><em class="mz">。报名参加我们的</em> <a class="ae nz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mz">免费周报</em> </strong> </a> <em class="mz">。关注我们关于</em><a class="ae nz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mz">Twitter</em></strong></a><em class="mz">和</em><a class="ae nz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mz">LinkedIn</em></strong></a><em class="mz">。加入我们的</em> <a class="ae nz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mz">社区不和谐</em> </strong> </a> <em class="mz">。</em></p></div></div>    
</body>
</html>