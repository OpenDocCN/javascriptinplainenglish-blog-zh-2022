<html>
<head>
<title>Meet React useEvent(): The Latest and Greatest React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Meet React useEvent():最新最棒的React钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-useevent-the-latest-and-greatest-react-hook-56ae71febbf3?source=collection_archive---------0-----------------------#2022-05-05">https://javascript.plainenglish.io/react-useevent-the-latest-and-greatest-react-hook-56ae71febbf3?source=collection_archive---------0-----------------------#2022-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5fe1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">被誉为“原Hooks版本中缺失的部分”，useEvent()将改变你编写modern React的方式。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/08eaa89e8e96181a576978f7b5a66131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ITCatxekJnNvC7s7"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1cca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反应钩子很棒，我们不能同意吗？在很大程度上，它们允许您编写干净的、可扩展的、易于理解的具有明确定义行为的功能组件。与旧的基于类的生命周期方法和本地状态管理相比，你会想知道React是如何变得如此流行的。</p><p id="30f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React团队当然将hooks视为未来，并准备在现有库的基础上加入<strong class="ky ir"> useEvent()。</strong></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="3ca2" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">useEvent解决什么问题？</h2><p id="05e5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在这一节，我们来看看回调函数中的<strong class="ky ir">引用相等。这可能看起来令人困惑，但让我们通过一些代码示例来理解这意味着什么。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4e5d2e807e82948efe130cc64c3fd152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*ImTsvjexEkYTrOuONgEiyw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">New hooks for use to play with!</figcaption></figure><p id="0624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个购物篮组件作为父组件，一个“购买”按钮作为子组件。我们希望“购买”按钮(子按钮)在被按下时在父按钮中执行一些代码。这可以在<strong class="ky ir">回调函数的帮助下完成。</strong>你可能见过数百个这样的例子，因为它们是一种极其常见的模式，但它可能是这样的:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="549b" class="lz ma iq mz b gy nd ne l nf ng">export const Basket = () =&gt; {<br/>  const [total, setTotal] = useState('');<br/><br/>  ... More component logic here ...  </span><span id="ee74" class="lz ma iq mz b gy nh ne l nf ng">  const onBuyClick = () =&gt; {<br/>    showTotal(total);<br/>  };<br/><br/>  return &lt;BuyButton onClick={onBuyClick}/&gt;;<br/>}</span></pre><p id="e760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常有效的React回调实现——但是还可以改进。</p><p id="fc2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次重新呈现“Basket”组件时，它当前也会重新呈现“BuyButton”组件。这可能会导致下游的巨大性能损失(想象一下BuyButton有10层以上的组件，所有这些组件也将被重新呈现)。</p><p id="be41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni">但是为什么会发生这种情况呢？这是因为</em> <strong class="ky ir"> <em class="ni">的参照完整性！</em>T13】</strong></p><p id="e050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看回调函数<code class="fe nj nk nl mz b">onClickBuy</code> <em class="ni">。</em>当“Basket”被重新渲染时，它拆掉并重新创建这个方法。虽然这个方法的行为不会随着渲染而改变，但是它的引用标识会改变。</p><p id="2638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni">本质上，React并不认为上一次渲染的方法与当前渲染的方法相同。</em></p><p id="a153" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为(默认情况下)组件在其属性改变时会重新呈现，所以“BuyButton”会重新呈现，因为<code class="fe nj nk nl mz b">onClickBuy</code>方法的引用标识已经改变。</p><p id="82c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在每次渲染时更改引用标识并导致子级重新渲染是useEvent()旨在解决的问题。</p><h2 id="3748" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">useMemo() + useCallback()怎么样？</h2><p id="a807" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">还记得30秒前我说过，默认情况下，当组件的属性改变时，组件会重新渲染吗？useMemo()和useCallback()改变了这个默认行为。</p><p id="180c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在useMemo()中包装我们的子组件——这意味着只要props等于它们在先前渲染中的值，子组件<strong class="ky ir">就不会重新渲染</strong>。</p><p id="e1d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是解决方案的一半，因为目前<code class="fe nj nk nl mz b">onClickBuy</code>仍将通过useMemo shallow props比较检查。我们真正想做的是阻止<code class="fe nj nk nl mz b">onClickBuy</code>在每次渲染时都有一个新的引用身份。我们可以通过将它包装在useCallback()中来实现这一点，例如，</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a120" class="lz ma iq mz b gy nd ne l nf ng">export const Basket = () =&gt; {<br/>  const [total, setTotal] = useState('');<br/><br/>  const onBuyClick = useCallback(() =&gt; {<br/>    showTotal(total);<br/>  }, [total]);<br/><br/>  return &lt;BuyButton onClick={onBuyClick}/&gt;;<br/>}</span></pre><p id="b5a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这需要一点努力，但是现在我们有了一个解决引用完整性问题的好办法。现在，只有当<code class="fe nj nk nl mz b">onBuyClick</code>的引用标识改变时，子元素才会重新呈现，而<code class="fe nj nk nl mz b">onBuyClick</code>只有当它的依赖数组改变时才会改变。这是目前解决重新渲染问题的最好方法。<strong class="ky ir">但并不完美。</strong></p><p id="6475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nj nk nl mz b">onBuyClick</code>只有当它的依赖关系改变时才会改变，但如果它们经常改变呢？如果每次用户在购物篮中添加或删除东西时,<code class="fe nj nk nl mz b">total</code>状态值都发生变化，那该怎么办？这意味着<code class="fe nj nk nl mz b">onBuyClick</code>的参照完整性仍然会有很大的变化，因此BuyButton最终仍然会重新呈现很多。</p><p id="00e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哦不！看起来我们已经做了很多工作，但最终还是出现了几乎相同的问题！嗯……是的。<br/>但是不用担心，因为useEvent可以解决这个问题！</p><p id="78f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用useEvent()，即使函数中使用的属性或状态发生变化，我们也可以保持相同的引用身份。</p><p id="7117" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦函数被创建，它会给你一个相同的身份。你可以把它想象成一个更强大的useCallback()。这是一个游戏规则的改变，当谈到整理子组件重新渲染优化。</p><h2 id="6e7d" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">useEvent实现看起来像什么？</h2><p id="0818" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">useEvent()与useCallback()非常相似，所以实现非常相似，只是useEvent()没有依赖数组(这意味着没有额外的deps数组lint错误)。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="e8b7" class="lz ma iq mz b gy nd ne l nf ng">export const Basket = () =&gt; {<br/>  const [total, setTotal] = useState('');<br/><br/>  const onBuyClick = useEvent(() =&gt; {<br/>    showTotal(total);<br/>  });<br/><br/>  return &lt;BuyButton onClick={onBuyClick}/&gt;;<br/>}</span></pre><h2 id="c476" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">太好了，我等不及要用了！</h2><p id="3a70" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我很高兴你能看到useEvent()的价值，但很抱歉打破你的幻想，目前React的当前版本中不提供useEvent()。<br/>好消息是，该功能还不足以构成一个主要版本，并且将作为次要版本发布，但还没有确认何时发布，所以请保持警惕！</p><p id="a80e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要阅读更多关于useEvent的内容，请访问React GitHub上的<a class="ae kv" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md" rel="noopener ugc nofollow" target="_blank">官方RFC。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="6bfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章或者觉得它有用，那么欢迎关注。或者，你可以在这里的<a class="ae kv" href="https://jamesmbrightman.medium.com/membership" rel="noopener"><em class="ni"/></a><em class="ni">培养基上支持我，或者给我买一杯</em> <a class="ae kv" href="https://ko-fi.com/jamesbrightman" rel="noopener ugc nofollow" target="_blank"> <em class="ni">咖啡</em> </a> <em class="ni">！非常感谢所有的支持。</em></p><p id="67a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni">更多内容请看</em><strong class="ky ir"><em class="ni"/></strong><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ni">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">免费每周简讯</em> </strong> </a> <em class="ni">。关注我们</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">推特</em> </strong> </a> <em class="ni">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ni">LinkedIn</em></strong></a><em class="ni">。加入我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">社区不和谐</em> </strong> </a> <em class="ni">。</em></strong></a></p></div></div>    
</body>
</html>