<html>
<head>
<title>A Hands-on Guide for a Server-Side Rendering React 18 App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端渲染React 18应用的实践指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-hands-on-guide-for-a-server-side-rendering-react-18-app-4e630aae274c?source=collection_archive---------0-----------------------#2022-10-11">https://javascript.plainenglish.io/a-hands-on-guide-for-a-server-side-rendering-react-18-app-4e630aae274c?source=collection_archive---------0-----------------------#2022-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d2c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用React 18探索SSR，创建React App 5和React Router 6</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/053b3899d41b5d49c755b88a3be7e909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Djk24As9KsJ5ehAiB3g-Jg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by author</figcaption></figure><p id="40e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们写了一篇关于<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/a-hands-on-guide-for-a-server-side-rendering-react-app-dd1efa3ec0d8">的文章，这是一篇关于服务器端渲染React应用</a>的实践指南。两年过去了，从<a class="ae lr" href="https://betterprogramming.pub/the-complete-guide-to-react-18-dd8763430345" rel="noopener ugc nofollow" target="_blank"> React 18 </a>开始，服务器端渲染(SSR)已经发生了变化。这篇文章是对SSR的改写，有React 18、<a class="ae lr" href="https://betterprogramming.pub/an-in-depth-guide-for-create-react-app-5-cra-5-b94b03c233f2" rel="noopener ugc nofollow" target="_blank"> Create React App 5 </a>和<a class="ae lr" href="https://betterprogramming.pub/a-step-by-step-guide-on-react-router-6-8964c10af364#71a9-41181d1f934" rel="noopener ugc nofollow" target="_blank"> React Router 6 </a>。</p><p id="c3bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/a-hands-on-guide-for-creating-a-production-ready-react-app-864ad98e7497">创建生产就绪型React应用的实践指南</a>描述了如何进行生产构建并将其部署到服务器。自然，下一步就是服务器端的渲染了。我们将通过将Create React应用程序转换为SSR应用程序来完成这个过程。</p><p id="fa9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://betterprogramming.pub/5-major-features-of-node-js-18-5f4a164cc9fc" rel="noopener ugc nofollow" target="_blank"> Node.js </a>可以用来启动服务器。或者，在本文中使用<code class="fe ls lt lu lv b">nodemon</code>。它是一个工具，通过在检测到文件更改时自动重启应用程序来帮助开发Node.js应用程序。</p><p id="8fd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是全局安装<code class="fe ls lt lu lv b">nodemon</code>的命令。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5880" class="ma mb iq lv b gy mc md l me mf">% npm install -g nodemon</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e957" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">术语</h1><h1 id="5ee7" class="mn mb iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">什么是客户端渲染(CSR)？</h1><p id="b13c" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">它是一种浏览器下载最小HTML页面，使用JavaScript渲染并填充内容的技术。</p><p id="0ffa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">初始页面加载的CSR时间可能会更长，但后续加载会更快。它减轻了服务器的负担，并依靠JavaScript库的力量。然而，搜索引擎优化(SEO)很难，因为没有静态的内容可以抓取。</p><h1 id="d3f5" class="mn mb iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">什么是服务器端渲染(SSR)？</h1><p id="b141" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">它是一种浏览器下载完整的HTML页面的技术，该页面已经由服务器呈现。</p><p id="5c61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SSR的优势是为了SEO。初始页面加载速度更快。但是它需要重新加载整个页面以进行后续更改。这可能会使服务器过载。</p><h1 id="8335" class="mn mb iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">什么是单页应用程序(SPA)？</h1><p id="07a4" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">这是一个使用客户端渲染的应用程序。它在浏览器中直接动态地呈现每条路线，而不是每条路线都有不同的HTML页面。</p><h1 id="bfb7" class="mn mb iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">什么是通用(同构)JavaScript？</h1><p id="2b39" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">它是一个运行在客户机和服务器上的Javascript应用程序。它在客户机上将HTML呈现为SPA，还在服务器端呈现相同的HTML，然后将其发送到浏览器进行显示。</p><p id="b2a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们为CSR编写React代码。相同的代码库可用于SSR。React是通用JavaScript。</p><p id="2d04" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SSR先于CSR存在。今天，随着通用JavaScript的出现，它又复活了。当今天提到SSR时，它很可能意味着带有通用JavaScript的SSR。</p><h1 id="4b2f" class="mn mb iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">创建React应用程序和CSR</h1><p id="7177" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">安装创建React应用程序:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9828" class="ma mb iq lv b gy mc md l me mf">% npx create-react-app react-ssr<br/>% cd react-ssr</span></pre><p id="a583" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行<code class="fe ls lt lu lv b">npm start</code>。</p><p id="308f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">Elements</code>选项卡中，它显示了JavaScript渲染的旋转标志的HTML (JSX)和一些文本信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/6ce89aa59c4f0cde402594a0fc1adf47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNj_1W0b09ajW3rWVlFMbQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><p id="4bb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个典型的CSR，HTML内容由JavaScript呈现。从<code class="fe ls lt lu lv b">Network</code>标签中，我们可以读取从服务器下载的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/58f5d7495ab71311253b060bcaafd35d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azJ1wfUhvM1Fgm6iN1vHQQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><p id="370e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">HTML的主体有一个JavaScript包，但没有实际内容。SEO很难获得任何有意义的信息。</p><p id="9e64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是HTML代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="41ad" class="mn mb iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">使用Express部署生产版本</h1><p id="6adc" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">为了让SSR工作，我们需要部署一个生产构建。</p><p id="4b28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://medium.com/javascript-in-plain-english/a-hands-on-guide-for-creating-a-production-ready-react-app-864ad98e7497" rel="noopener">创建生产就绪型React应用的实践指南</a>为服务器端渲染奠定了基础。我们需要创建一个服务器来服务编译好的React代码。</p><p id="7a59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里是<a class="ae lr" href="https://betterprogramming.pub/what-are-cjs-amd-umd-esm-system-and-iife-3633a112db62" rel="noopener ugc nofollow" target="_blank"> CJS格式的</a>文件，<code class="fe ls lt lu lv b">server/index.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="df5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者，这里是<a class="ae lr" href="https://betterprogramming.pub/what-might-be-coming-in-npm-9-6985cf2678a6" rel="noopener ugc nofollow" target="_blank"> ESM格式</a>文件，<code class="fe ls lt lu lv b">server/index.mjs</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e194" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">执行<code class="fe ls lt lu lv b">npm run build</code>创建生产版本。然后运行<code class="fe ls lt lu lv b">nodemon server</code>或<code class="fe ls lt lu lv b">nodemon server/index.mjs</code>将其部署到Express服务器。</p><p id="6271" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">Network</code>选项卡中，它显示了从服务器中检索到的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b6c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一个JavaScript包(第12行)带有空的标记内容(第17行)。因此，这是企业社会责任。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="9d62" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">在Express服务器内部构建SSR</h1><p id="db65" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">在Express服务器中构建SSR需要3个步骤。</p><h2 id="b7d7" class="ma mb iq bd mo ns nt dn ms nu nv dp mw le nw nx my li ny nz na lm oa ob nc oc bi translated">步骤1:使用ReactDOM.hydrateRoot()显示服务器呈现的标记。</h2><p id="bcd6" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><code class="fe ls lt lu lv b">ReactDOM.hydrateRoot()</code> <strong class="kx ir"> </strong>类似于<code class="fe ls lt lu lv b">ReactDOM.createRoot()</code>。它用于水合一个容器，该容器的HTML内容已经由<code class="fe ls lt lu lv b">ReactDOMServer</code>对象呈现。它的语法是<code class="fe ls lt lu lv b">hydrateRoot(container, element[, options])</code>，类似于<code class="fe ls lt lu lv b">createRoot(container[, options])</code>。</p><p id="6c20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于<code class="fe ls lt lu lv b">ReactDOM.hydrateRoot()</code>是在一个已经有服务器呈现的标记的节点上调用的，React将保留它并只附加事件处理程序。这使得初始负载性能良好。</p><p id="7dd6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">ReactDOM.hydrateRoot()</code>(第7行)用于<code class="fe ls lt lu lv b">src/index.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="68f9" class="ma mb iq bd mo ns nt dn ms nu nv dp mw le nw nx my li ny nz na lm oa ob nc oc bi translated">步骤2:使用ReactDOMServer对象将组件呈现为静态标记。</h2><p id="0fed" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">React提供了<code class="fe ls lt lu lv b"><a class="ae lr" href="https://reactjs.org/docs/react-dom-server.html" rel="noopener ugc nofollow" target="_blank">ReactDOMServer</a></code>对象来将组件呈现给静态标记。它向浏览器发送一个已经填充了数据的页面。</p><p id="6033" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React代码是通用的JavaScript，在客户端和服务器上都可以运行。</p><p id="839c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实现SSR有不同的方案和方法。<code class="fe ls lt lu lv b">@babel/register</code>是简单的方法之一。它作为<code class="fe ls lt lu lv b"><a class="ae lr" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">devDependencies</a></code>的一部分与<code class="fe ls lt lu lv b">babel-plugin-transform-assets</code>一起安装。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e4c6" class="ma mb iq lv b gy mc md l me mf">"devDependencies": {<br/>  "@babel/register": "^7.18.9",<br/>  "babel-plugin-transform-assets": "^1.0.2"<br/>}</span></pre><p id="842d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">@babel/register</code>动态自动编译文件。我们可以配置它来转换JSX和资产。但是，它不支持动态编译本机Node.js es模块，因为目前没有稳定的API来拦截ES模块加载。因此，我们将使用CJS格式的文件来探索SSR。</p><p id="365e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从React 18开始，<code class="fe ls lt lu lv b">renderToString</code>仍然可以工作，但是支持<code class="fe ls lt lu lv b">Suspense</code>有限。React 18改版服务器端API，放入<code class="fe ls lt lu lv b">react-dom/server</code>。这些新的API，包括<code class="fe ls lt lu lv b">renderToPipeableStream</code>，在服务器和流媒体SSR上完全支持<code class="fe ls lt lu lv b">Suspense</code>。</p><p id="5709" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是改进的<code class="fe ls lt lu lv b">server/index.js</code>，具有SSR功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5f69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第1–15行，我们通过<code class="fe ls lt lu lv b">require</code>钩子设置了Babel，它可以动态地自动编译文件。</p><p id="4a4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第2行，我们设置了两个预设:</p><ul class=""><li id="2e60" class="od oe iq kx b ky kz lb lc le of li og lm oh lq oi oj ok ol bi translated"><code class="fe ls lt lu lv b">@babel/preset-env</code>，一个智能预设，它使用最新的JavaScript，而不需要微观管理目标环境需要哪些语法转换。</li><li id="5a98" class="od oe iq kx b ky om lb on le oo li op lm oq lq oi oj ok ol bi translated"><code class="fe ls lt lu lv b">@babel/preset-react</code>，一个智能预设，自动导入JSX转换到的功能。</li></ul><p id="ebac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第3–14行是<code class="fe ls lt lu lv b">babel-plugin-transform-assets</code>的插件。它设置了如何转换静态媒体文件的规则。如果没有这个，它会抛出<code class="fe ls lt lu lv b">svg</code>标签的<code class="fe ls lt lu lv b">SyntaxError: Unexpected token ‘&lt;’</code>。</p><p id="2dd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第16行，<code class="fe ls lt lu lv b">React</code>是必需的。</p><p id="f718" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第17行需要<code class="fe ls lt lu lv b">ReactDOMServer</code>。</p><p id="7235" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第18行，需要默认导出<code class="fe ls lt lu lv b">src/App.js</code>。</p><p id="4ad7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">app.use()</code>(第47行)在<code class="fe ls lt lu lv b">app.get()</code>(第25 - 45行)之后执行。否则，<code class="fe ls lt lu lv b">app.use()</code>将为根路由服务静态文件，包括<code class="fe ls lt lu lv b">index.html</code>，执行将没有机会到达<code class="fe ls lt lu lv b">app.get()</code>中间件。</p><p id="5a66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第26行显示了被调用的请求URL。对于创建React应用程序，它们列出如下:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="115b" class="ma mb iq lv b gy mc md l me mf">Request URL = /<br/>Request URL = /static/js/main.b92cc87b.js<br/>Request URL = /static/css/main.073c9b0a.css<br/>Request URL = /static/media/logo.06e73328.svg<br/>Request URL = /static/css/main.073c9b0a.css.map<br/>Request URL = /static/js/main.b92cc87b.js.map<br/>Request URL = /static/media/logo.6ce24c58023cc2f8fd88fe9d219db6c6.svg<br/>Request URL = /favicon.ico<br/>Request URL = /manifest.json<br/>Request URL = /logo192.png</span></pre><p id="99ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第27–29行确保只有根路径被<code class="fe ls lt lu lv b">app.get()</code>渲染。静态资产将跳到第47行的下一个中间件。</p><p id="9080" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第30行，<code class="fe ls lt lu lv b">ReactDOMServer.renderToString(element)</code>用于在服务器上生成HTML。从理论上讲，它可以写成<code class="fe ls lt lu lv b">ReactDOMServer.renderToString(&lt;App /&gt;)</code>，但是这需要将JSX代码包含在一个与<code class="fe ls lt lu lv b">@babel-register</code>配置不同的文件中。</p><p id="6d3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第31行显示了服务器呈现的标记代码:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ff1f" class="ma mb iq lv b gy mc md l me mf">&lt;div class="App"&gt;&lt;header class="App-header"&gt;&lt;img src="static/media/logo.06e73328.svg" class="App-logo" alt="logo"/&gt;&lt;p&gt;Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.&lt;/p&gt;&lt;a class="App-link" href="<a class="ae lr" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank">https://reactjs.org</a>" target="_blank" rel="noopener noreferrer"&gt;Learn React&lt;/a&gt;&lt;/header&gt;&lt;/div&gt;</span></pre><p id="854d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">33号线装载产品<code class="fe ls lt lu lv b">index.html</code>。</p><p id="fad3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第34–44行读取<code class="fe ls lt lu lv b">index.html</code>的内容。如果没有错误，服务器生成的标记(第42行)被呈现给根标签，然后最终的<code class="fe ls lt lu lv b">index.html</code>响应初始加载。</p><p id="b3cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">执行<code class="fe ls lt lu lv b">nodemon server</code>。从<code class="fe ls lt lu lv b">Network</code>选项卡中，下载的脚本显示了服务器呈现的标记。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6d8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正文内容(第15–29行)包含完整的内容，SEO可以使用它来获取有意义的信息。</p><p id="9a1a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果从bowser关闭JavaScript，代码会继续工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/2357fe6087b508ef8779f10daaa061cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3gbsBdyfeVvq0TGhAn6Cw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><p id="0308" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是SSR。</p><h2 id="d58a" class="ma mb iq bd mo ns nt dn ms nu nv dp mw le nw nx my li ny nz na lm oa ob nc oc bi translated">步骤3:处理页面特定的需求。</h2><p id="ce36" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">我们让单页React应用程序发挥了作用。多条路线的app怎么样？</p><p id="524b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，将<code class="fe ls lt lu lv b">react-router-dom</code>作为<code class="fe ls lt lu lv b">dependencies</code>之一安装。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5a0e" class="ma mb iq lv b gy mc md l me mf">"devDependencies": {<br/>  "react-router-dom": "^6.4.2",<br/>  ...<br/>}</span></pre><p id="b707" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">修改<code class="fe ls lt lu lv b">src/App.js</code>如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8a08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第1行，<code class="fe ls lt lu lv b">React</code>被导入，这是SSR所需要的。</p><p id="eaef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第2行，导入的是<code class="fe ls lt lu lv b">MemoryRouter</code>，而不是<code class="fe ls lt lu lv b">BrowserRoute</code>。<code class="fe ls lt lu lv b">BrowserRoute</code>在幕后使用html 5<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries" rel="noopener ugc nofollow" target="_blank">pushState history API</a>，Node.js不支持<code class="fe ls lt lu lv b">MemoryRouter</code>将URL历史保存在内存中(不读写地址栏)。它在测试和非浏览器环境中很有用。我们应该使用<code class="fe ls lt lu lv b">import { StaticRouter } from "react-router-dom/server"</code>。然而，它还没有准备好投入生产。</p><p id="f09e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第34–40行使用<code class="fe ls lt lu lv b">MemoryRouter</code>。</p><p id="a81b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">执行<code class="fe ls lt lu lv b">npm run build</code>，然后运行<code class="fe ls lt lu lv b">nodemon server</code>。转到<code class="fe ls lt lu lv b">http://localhost:8080</code>，我们看到如下页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/c06581ad63321c4d0406ff386b0d7010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*m8yNxKdpUOVRx31I.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><p id="9407" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SSR可以工作，尽管地址栏中的URL不会更新。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="1aa2" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">对现有框架/库使用SSR</h1><p id="8967" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">路由工作有一个警告。还有其他事情需要处理，比如数据获取、Redux等。服务器端的工作不像客户端那么简单。根据要求，每个页面可能都需要特别注意。</p><p id="ef3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们如何处理这么多的复杂情况？</p><p id="79cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，我们不需要。现有的框架和库都有内置的SSR功能。</p><p id="d999" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Remix是一个全栈的web框架，专注于用户界面，并通过web基础工作。它包括SSR和其他开箱即用的特性，没有样板文件。</p><p id="7c71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是Remix的客户端代码，它在下面代码的第4行使用了<code class="fe ls lt lu lv b">hydrateRoot</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5cbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是Remix的服务器代码，它在下面代码的第4行使用了<code class="fe ls lt lu lv b">renderToPipeableStream</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="04ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b"><a class="ae lr" href="https://reactjs.org/docs/react-dom-server.html#rendertopipeablestream" rel="noopener ugc nofollow" target="_blank">renderToPipeableStream(element, options)</a></code>在React 18中引入。它将一个React元素呈现给它的初始HTML，并返回一个流，用<code class="fe ls lt lu lv b">pipe(res)</code>方法来传输输出，用<code class="fe ls lt lu lv b">abort()</code>来中止请求。它完全支持HTML的悬念和流，“延迟”的内容通过内嵌的<code class="fe ls lt lu lv b">&lt;script&gt;</code>标签阻止“突然出现”。</p><p id="0daa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从<code class="fe ls lt lu lv b">Network</code>页签中，我们可以看到索引页的正文有该页的全部内容。是SSR。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/4137c8e671accccef487de8ed818d27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-i7dg3TAtxAV5uminfg2hQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><p id="22d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/a-complete-guide-to-gatsby-react-34039da49438"> Gatsby </a>、Next.js、NuxtJS、Quasar和SvelteKit都提供了SSR和其他开箱即用的功能，没有样板文件，尽管它们对SSR的定义可能略有不同。</p><p id="87bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里是Gatsby的索引页的<code class="fe ls lt lu lv b">Network</code>选项卡，显然，主体具有页面的全部内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/903843c024e04e5be83fae99734cc532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFZu3Xl3WE75EI8wCvNwJg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><p id="b354" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Gatsby是一个健壮而快速的静态站点生成器。它使用React在web上呈现静态内容。它允许改变静态HTML文件的内容。</p><p id="ecd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果页面只包含静态数据，静态呈现会更快。但是，如果响应是动态的，SSR是更好的选择。有时，混合方法可能最适合这种情况。当请求文件时，SSR按需发生。静态呈现在构建时发生一次。它们都是SEO友好的，而两个HTML的主体内容都有完整的内容。</p><h1 id="247d" class="mn mb iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">结论</h1><p id="922d" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">我们已经展示了如何为Create React应用程序设置SSR。这些是步骤:</p><ol class=""><li id="a900" class="od oe iq kx b ky kz lb lc le of li og lm oh lq ou oj ok ol bi translated">使用<code class="fe ls lt lu lv b">ReactDOM.hydrateRoot()</code>显示服务器呈现的标记。</li><li id="7b5c" class="od oe iq kx b ky om lb on le oo li op lm oq lq ou oj ok ol bi translated">使用<code class="fe ls lt lu lv b">ReactDOMServer</code>对象将组件呈现为静态标记。</li><li id="5c9a" class="od oe iq kx b ky om lb on le oo li op lm oq lq ou oj ok ol bi translated">处理页面特定需求</li></ol><p id="a6af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用<code class="fe ls lt lu lv b">ReactDOMServer</code>对象将组件呈现为静态标记。它的API可以用于SSR和静态渲染。</p><p id="dcd5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于一个真实的项目，最好的选择是使用现有的框架或库。</p><p id="e52c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2a8f" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">Want to Connect?</strong></span><span id="8d5e" class="ma mb iq lv b gy ov md l me mf">If you are interested, check out <a class="ae lr" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">my directory of web development articles</a>.</span></pre><p id="4289" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ow">注:感谢Raja Nagendra Kumar将本文的全部代码放入一个</em> <a class="ae lr" href="https://github.com/nagkumar/experiments/tree/main/fe/react/ssr" rel="noopener ugc nofollow" target="_blank"> <em class="ow">存储库</em> </a> <em class="ow">，使用他在回复评论中建议的服务器端文件夹结构。</em></p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="2ca6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ow">更多内容请看</em><a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ow">plain English . io</em></strong></a><em class="ow">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="ow">免费周报</em> </strong> </a> <em class="ow">。关注我们关于</em><a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ow">Twitter</em></strong></a><a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ow">LinkedIn</em></strong></a><em class="ow"/><a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ow">YouTube</em></strong></a><em class="ow"/><a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ow">不和</em> </strong> </a> <em class="ow">。对增长黑客感兴趣？检查</em> <a class="ae lr" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="ow">电路</em> </strong> </a> <em class="ow">。</em></p></div></div>    
</body>
</html>