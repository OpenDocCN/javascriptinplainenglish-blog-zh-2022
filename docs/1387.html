<html>
<head>
<title>What the Heck is SSG? Static Site Generation Explained with Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SSG到底是什么？用Next.js解释静态站点生成</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-the-heck-is-ssg-static-site-generation-explained-with-next-js-63d3a8c2cc1a?source=collection_archive---------11-----------------------#2022-03-21">https://javascript.plainenglish.io/what-the-heck-is-ssg-static-site-generation-explained-with-next-js-63d3a8c2cc1a?source=collection_archive---------11-----------------------#2022-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d9a36fa442c6332ed3a581024f241de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FRFZsqVtS11Uf9WN.png"/></div></div></figure><p id="1d5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你是一名网络开发人员，并且你不是生活在岩石下，你一定遇到过这个叫做“SSG”的流行词。</p><p id="c8da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在接下来的5分钟里，我们将学习它的基础知识。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/b16b957538f48abc94da304632dd435c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*bUBYQc3X--05R8sL.gif"/></div></figure><h1 id="7156" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是SSG？</h1><p id="c536" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">静态网站生成又名SSG是在构建时将你的React应用预渲染成HTML。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/5e06702c7702018dc108756dff14d885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IFMD2NrLWG7U-Ve5.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">SSG vs SSR vs CSR</figcaption></figure><p id="38c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分解一下。理想情况下，您的React应用程序是客户端呈现的，这意味着用户的浏览器将首先下载完整的JavaScript包，然后在用户可以看到任何内容之前执行它。听起来很慢，是吧？真的是。</p><p id="74da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">预渲染为HTML意味着我们将React组件转换为HTML文件，并将HTML文件发送到客户端，这样它就可以快速向我们的用户显示，而无需太多的处理或带宽。</p><p id="fb8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能会想，这就是服务器端渲染。</p><p id="76ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，它是，SSG的<strong class="jx io">静态</strong>来自于这样一个事实，即整个过程不是为每个用户请求(像SSR)而发生，而是在构建时发生，这使得SSG甚至比服务器端渲染更快。</p><p id="9bf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，SSG将在构建时在React应用程序中制作HTML页面，这样它就不必为每个请求都这样做，浏览器也不必在客户端这样做。</p><h1 id="d644" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们为什么需要SSG？</h1><p id="3f70" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">SSG的存在是为了服务于一个特定的用例，以HTML的形式提供React内置的动态页面。</p><p id="5d95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你问的好处是什么？</p><ul class=""><li id="1477" class="mg mh in jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated"><strong class="jx io"> SEO </strong>，搜索引擎优化是做SSG的最大好处之一，因为它让爬虫很容易索引页面。</li><li id="c6d4" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated"><strong class="jx io">速度</strong>:正如你所猜测的，为最终用户提供一个HTML页面要快得多，因为浏览器不需要做太多的前期处理。预渲染使浏览器很容易获取HTML并直接呈现出来。</li><li id="5aed" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated"><strong class="jx io">用CDN缓存</strong>:构建HTML页面为CDN缓存展现魅力打开了可能性。这些页面存储在离用户更近的地方，因此可以更快地访问。每个请求不必等待服务器渲染页面，它只需从CDN接收页面，从而节省我们的计算资源和资金。</li></ul><h1 id="52d3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用例</h1><p id="9cea" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">虽然您可以在任何场景中使用SSG，只要页面可以在构建时呈现，但是这里有一些流行的SSG用例模式</p><ul class=""><li id="b60a" class="mg mh in jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">营销网站</li><li id="e3a4" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">博客和文档，比如我自己的<a class="ae mu" href="https://theanshuman.dev/articles" rel="noopener ugc nofollow" target="_blank">博客</a></li><li id="17e1" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">投资组合网站</li></ul><blockquote class="mv mw mx"><p id="7420" class="jv jw my jx b jy jz ka kb kc kd ke kf mz kh ki kj na kl km kn nb kp kq kr ks ig bi translated"><em class="in">提示:知道你是否应该使用SSG的一个简单方法是回答:“你能在用户请求之前预渲染页面吗？”如果答案是肯定的，那么你应该选择静态生成。</em></p></blockquote><h1 id="84fd" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将Next.js用于SSG</h1><p id="e07f" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">用Next.js构建静态页面很简单。它的工作方式与构建任何其他页面非常相似，即在<code class="fe nc nd ne nf b">pages</code>目录中创建新文件。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/e9a4a64cdf553329878c876d1238a10e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fygzahn4pfZ8jiD5.png"/></div></div></figure><h2 id="5d5f" class="nh kz in bd la ni nj dn le nk nl dp li kg nm nn lm kk no np lq ko nq nr lu ns bi translated">静态路由的静态页面</h2><p id="e785" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">让我们从创建静态路由<code class="fe nc nd ne nf b">./pages/first-ssg.tsx</code>开始</p><p id="0504" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为页面是在构建时呈现的，所以Next.js需要在呈现之前获取所有数据。Next.js寻找一个从页面导出的<code class="fe nc nd ne nf b">getStaticProps</code>方法，以便在构建时运行。这个方法应该返回一个带有<code class="fe nc nd ne nf b">props</code>键的对象，它被传递给页面组件。</p><p id="ba3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nc nd ne nf b">getStaticProps</code>应该被用来获取渲染页面所需的所有信息。例如，如果我们正在制作一个关于公司的页面，<code class="fe nc nd ne nf b">getStaticProps</code>是从我们的API端点获取公司详细信息的合适位置。</p><pre class="ku kv kw kx gt nt nf nu nv aw nw bi"><span id="81f2" class="nh kz in nf b gy nx ny l nz oa">// ./pages/first-ssg.tsx<br/>import type { NextPage } from "next";<br/><br/>export async function getStaticProps() {<br/>  // get all the data needed for rendering the page<br/>  const data = await fetchPageData();<br/>  return {<br/>    props: { data },<br/>  };<br/>}<br/><br/>const FirstSSG = ({ data }) =&gt; {<br/> return (<br/>      &lt;main&gt;<br/>        {/* more html content */}<br/>      &lt;/main&gt;<br/> )<br/>}<br/><br/>export default FirstSSG;</span></pre><blockquote class="mv mw mx"><p id="60a3" class="jv jw my jx b jy jz ka kb kc kd ke kf mz kh ki kj na kl km kn nb kp kq kr ks ig bi translated"><em class="in">注意:</em> <code class="fe nc nd ne nf b"><em class="in">getStaticProps</em></code> <em class="in">不能访问传入的请求(如查询参数或HTTP头)，因为它在构建时运行，而不是在请求时运行。</em></p></blockquote><h2 id="89c1" class="nh kz in bd la ni nj dn le nk nl dp li kg nm nn lm kk no np lq ko nq nr lu ns bi translated">动态路由的静态页面</h2><p id="e290" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">让我们创建一条动态路线<code class="fe nc nd ne nf b">./pages/[id].tsx</code></p><p id="05a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了针对特定于页面的数据的<code class="fe nc nd ne nf b">getStaticProps</code>之外，Next.js现在还需要找出这条路径的所有可能路径，因为Next.js将不得不在构建时呈现这些路径的页面。</p><p id="36ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，Next.js期望一个<code class="fe nc nd ne nf b">getStaticPaths</code>方法，它将在构建时列出动态路由的所有可能路径。例如，如果它是一个动态博客页面，我们将需要列出所有可用的博客作为路径。</p><p id="f701" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由<code class="fe nc nd ne nf b">getStaticPaths</code>返回的<code class="fe nc nd ne nf b">paths</code>包含一个将被传递给<code class="fe nc nd ne nf b">getStaticProps</code>的<code class="fe nc nd ne nf b">params</code>对象。您可以使用<code class="fe nc nd ne nf b">params</code>来传递关于路径的数据，比如blog slug或id，这些数据稍后会被<code class="fe nc nd ne nf b">getStaticProps</code>用来获取页面数据。</p><pre class="ku kv kw kx gt nt nf nu nv aw nw bi"><span id="7223" class="nh kz in nf b gy nx ny l nz oa">// ./pages/[id].tsx<br/>import type { NextPage } from "next";<br/><br/>export async function getStaticPaths() {<br/>  return {<br/>    paths: [<br/>      { params: { ... } }<br/>    ],<br/>    fallback: // true or false or 'blocking', to be discussed later<br/>  };<br/>}<br/><br/>export async function getStaticProps({ params }) {<br/>  // get all the data needed for rendering the page<br/>  const data = await fetchPageData(params);<br/>  return {<br/>    props: { data },<br/>  };<br/>}<br/><br/>// Your page layout<br/>const FirstSSG = ({ data }) =&gt; {<br/> return (<br/>      &lt;main&gt;<br/>        {/* more html content */}<br/>      &lt;/main&gt;<br/> )<br/>}<br/><br/>export default FirstSSG;</span></pre><p id="6457" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使用Next.js构建一个静态网站，这就是你需要做的全部工作。</p><p id="e369" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不可能都是美好的，对吧？先说一些陷阱。</p><h1 id="49a8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">陷阱</h1><ol class=""><li id="a296" class="mg mh in jx b jy lw kc lx kg ob kk oc ko od ks oe mm mn mo bi translated">这种方法的最大缺点之一是构建时间。如果你有成千上万的页面，建立所有的页面会花费很多时间。我知道有像<em class="my">增量静态再生</em>和<code class="fe nc nd ne nf b">fallback</code>道具这样的解决方案，可以结合使用来解决这个问题。我们一会儿会看到这一点。</li><li id="49dc" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks oe mm mn mo bi translated">另一个可能出现的问题是过时的页面。因为您在构建时获取页面数据，所以一段时间后数据可能会过时。因此，您可能必须计划构建或以特定的时间间隔触发它们，以确保数据是最新的。这也可以通过<em class="my">增量静态再生</em>解决。但是，如果是这种情况，您可能应该考虑服务器端呈现，而不是静态页面。</li></ol><h1 id="9aaa" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><code class="fe nc nd ne nf b">fallback</code>选项</h1><p id="425e" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">正如我们上面讨论的，有一个<code class="fe nc nd ne nf b">fallback</code>选项可以从<code class="fe nc nd ne nf b">getStaticPaths</code>返回，它用于从<code class="fe nc nd ne nf b">getStaticPaths</code>返回的不在<code class="fe nc nd ne nf b">paths</code>列表中的路径。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/af7dd955e421f5e8141f2cda911b2186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ztzN9DYskckAq9sE.png"/></div></div></figure><blockquote class="mv mw mx"><p id="690c" class="jv jw my jx b jy jz ka kb kc kd ke kf mz kh ki kj na kl km kn nb kp kq kr ks ig bi translated"><em class="in">重要的是要理解回退选项不会重新生成或更新在构建时渲染的路径，而是仅适用于构建时未预渲染的路径。</em></p></blockquote><p id="d191" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nc nd ne nf b">fallback</code>选项对于有数千页的应用程序来说非常有用，可以加快构建速度，同时保持最佳的用户体验。</p><h1 id="d936" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么是Next.js？</h1><p id="fe01" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">我更喜欢Next.js，因为它提供了两种选择，</p><ol class=""><li id="c982" class="mg mh in jx b jy jz kc kd kg mi kk mj ko mk ks oe mm mn mo bi translated">服务器端渲染</li><li id="4277" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks oe mm mn mo bi translated">静态站点生成</li></ol><p id="69cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，我可以在写作的时候选择我想走的路。</p><p id="a5be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它还提供了与Vercel云平台的高度集成，该平台允许免费的边缘缓存和CI/CD。</p><p id="3618" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一次到此为止。我将很快写另一篇文章解释<em class="my">增量静态再生</em>。希望这篇文章对你有帮助！如果您有任何反馈或问题，请随时在下面的评论中提出。更多此类文章，请在Twitter上关注我</p><blockquote class="mv mw mx"><p id="71f6" class="jv jw my jx b jy jz ka kb kc kd ke kf mz kh ki kj na kl km kn nb kp kq kr ks ig bi translated"><em class="in">直到下一次</em></p></blockquote><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5dd2098c08dad67339454a498bcecba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*VOq-0y3svMhT1ySO.gif"/></div></figure></div><div class="ab cl og oh hr oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ig ih ii ij ik"><p id="621b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="my">原载于2022年3月21日</em><a class="ae mu" href="https://theanshuman.dev/articles/create-your-own-url-shortener-with-nextjs-and-mongodb-in-10-minutes-4fg" rel="noopener ugc nofollow" target="_blank"><em class="my">https://theanshuman . de</em>v</a><em class="my">。</em></p><p id="8ce7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="my">更多内容请看</em><a class="ae mu" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae mu" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="my">免费周报</em> </strong> </a> <em class="my">。关注我们关于</em><a class="ae mu" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="my">Twitter</em></strong></a><em class="my">和</em><a class="ae mu" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="my">LinkedIn</em></strong></a><em class="my">。加入我们的</em> <a class="ae mu" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="my">社区不和谐</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>