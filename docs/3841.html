<html>
<head>
<title>How to Handle Dynamic &amp; Async Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中处理动态和异步组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-handle-dynamic-async-components-in-react-99ca13578fd8?source=collection_archive---------7-----------------------#2022-09-30">https://javascript.plainenglish.io/how-to-handle-dynamic-async-components-in-react-99ca13578fd8?source=collection_archive---------7-----------------------#2022-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="dd76" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过异步组件，我们可以向浏览器加载重要的和必不可少的组件。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/14829c92dc741fb619657362db70ce69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cc-ijnN-qXtpOtlw"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ed3a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">异步不仅仅是获取数据，它还可以应用于代码或组件。通过异步组件，我们可以向浏览器加载重要的和必不可少的组件。不太重要的组件可以缓慢加载和渲染。在React中，这个概念是内置的，并为此提供了许多API。</p><p id="c4da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React组件的延迟加载可以:</p><ul class=""><li id="a453" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">减少初始加载时间，</li><li id="5e80" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">仅在需要时下载组件</li></ul><p id="564d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React的暂记API允许您处理UI中组件的异步加载。它让组件在渲染前“等待”一些东西。</p><h1 id="503d" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">1.React.lazy()的使用</h1><p id="3fcf" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated"><code class="fe na nb nc nd b"><a class="ae ks" href="https://reactjs.org/docs/react-api.html#reactlazy" rel="noopener ugc nofollow" target="_blank">React.lazy()</a></code>允许您定义一个动态加载的组件。</p><p id="a61b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要动态加载组件<code class="fe na nb nc nd b">LazyComponent.js</code>，我们需要动态导入并加载它，如下所示。</p><pre class="kd ke kf kg gt ne nd nf ng aw nh bi"><span id="1429" class="ni me in nd b gy nj nk l nl nm">import { lazy } from 'react';<br/>...<br/>const LazyLoadComponent = lazy(() =&gt; import('./LazyComponent');</span></pre><p id="093d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe na nb nc nd b">React.lazy</code>仅支持默认导入。我们必须修改动态导入返回的承诺，使其具有命名导入的默认值。</p><pre class="kd ke kf kg gt ne nd nf ng aw nh bi"><span id="4a81" class="ni me in nd b gy nj nk l nl nm">const LazyLoadComponent = lazy(() =&gt; import('./LazyComponent')<br/>  .then(<br/>     module =&gt; ({ default: module.Content })<br/>  )<br/>);</span></pre><p id="2b52" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">动态导入和加载使组件不属于主捆绑包或代码块。因此，减少了初始页面加载。这样，我们可以根据组件是否很大、是否是初始渲染的一部分、对用户的可见性、是否是有条件渲染或者是否不太重要来划分组件。</p><h1 id="424b" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">2.React的使用。焦虑</h1><p id="2439" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">如果导入和加载量大、网络连接差、旧设备的处理时间长等，惰性加载组件可能需要等待一段时间。在这种情况下，我们需要提供一个后备UI，向用户表明组件正在加载。这就是反应。悬念就来了。</p><p id="568b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe na nb nc nd b"><a class="ae ks" href="https://reactjs.org/docs/react-api.html#reactsuspense" rel="noopener ugc nofollow" target="_blank">React.Suspense</a></code>允许您指定加载指示器，以防其下树中的某些组件尚未准备好进行渲染。</p><pre class="kd ke kf kg gt ne nd nf ng aw nh bi"><span id="80fd" class="ni me in nd b gy nj nk l nl nm">import { lazy, Suspense } from 'react;<br/>const Content = lazy(() =&gt; import("./Content"));</span><span id="9791" class="ni me in nd b gy nn nk l nl nm">export const AppComponent = () =&gt; (<br/>   &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>      &lt;Content cost={COST} /&gt;<br/>   &lt;/Suspense&gt;<br/>);</span></pre><p id="1ccd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">多个组件也可以嵌套在一个<code class="fe na nb nc nd b">Suspense</code>中。</p><h1 id="5893" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">3.交叉点观察器API的使用</h1><p id="a225" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">做出反应。悬念API不支持惰性数据抓取。使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交集观察者API </a>我们可以在组件可见的情况下获取数据。这样我们可以在延迟加载的基础上再次减少加载时间，我们也可以延迟获取组件。我们也可以使用相同的原理为组件提供数据。</p><p id="773e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要使用交叉点观察器API，我们可以创建如下观察器:</p><pre class="kd ke kf kg gt ne nd nf ng aw nh bi"><span id="803d" class="ni me in nd b gy nj nk l nl nm">const options = {<br/>  <!-- -->root: null,<br/>  rootMargin: '750px',<br/>  threshold: 1.0,<br/>};</span><span id="00d3" class="ni me in nd b gy nn nk l nl nm">const observer = new IntersectionObserver(callback, options);<br/>observer.observe(targetElement);</span></pre><p id="5871" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也可以使用<code class="fe na nb nc nd b"><a class="ae ks" href="https://www.npmjs.com/package/react-intersection-observer" rel="noopener ugc nofollow" target="_blank">react-intersection-observer</a></code> npm包，它使用API来提供钩子、道具等。对于您的React应用程序。</p><p id="2105" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">阅读更多关于React应用程序代码分割的信息:</p><div class="no np gp gr nq nr"><a href="https://reactjs.org/docs/code-splitting.html" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">代码分解-反应</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">大多数React应用程序会使用Webpack、Rollup或Browserify等工具“捆绑”文件。捆绑是一个过程…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">reactjs.org</p></div></div><div class="oa l"><div class="ob l oc od oe oa of km nr"/></div></div></a></div></div><div class="ab cl og oh hr oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ig ih ii ij ik"><p id="eccf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="on">更多内容尽在</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="on">说白了. io </em> </strong> </a> <em class="on">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="on">免费周报</em> </strong> </a> <em class="on">。关注我们关于</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="on">推特</em> </strong> </a>，<a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="on">LinkedIn</em></strong></a><em class="on">，</em><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="on">YouTube</em></strong></a><em class="on">，</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="on">不和</em> </strong> </a> <em class="on">。对增长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="on">电路</em> </strong> </a> <em class="on">。</em></p></div></div>    
</body>
</html>