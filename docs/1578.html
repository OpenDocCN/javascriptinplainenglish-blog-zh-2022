<html>
<head>
<title>7 TypeScript Built-in Utility Types You Must Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您必须知道的7种TypeScript内置实用程序类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-typescript-built-in-utility-types-you-must-know-d7a73a489d7?source=collection_archive---------6-----------------------#2022-04-04">https://javascript.plainenglish.io/7-typescript-built-in-utility-types-you-must-know-d7a73a489d7?source=collection_archive---------6-----------------------#2022-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="974b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高对内置类型的理解。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6a3712f741f64b7291f52b0a8d5bb185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qShRb0WvSjF9p5zbz-deaw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><p id="19cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">TypeScript内置了许多有用的实用工具类型，正确使用它们可以使我们的代码更加健壮和优雅。</p><p id="925a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将选择7种典型的实用程序类型并分析它们的源代码，列出那些要点，并在StackBlitz上创建一个小示例来帮助您理解(您可以调试它)，所以让我们开始吧！</p><h1 id="9266" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">部分<type/></h1><p id="41b0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">它将传入的<code class="fe mo mp mq mr b">Type</code>的所有属性设置为可选。其源代码如下:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="2b0a" class="mw ls iq mr b gy mx my l mz na">/**<br/> * Make all properties in T optional<br/> */<br/>type Partial&lt;T&gt; = {<br/>    [P in keyof T]?: T[P];<br/>};</span></pre><p id="a6c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来分析一下关键点:</p><p id="4db1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">in</code>操作符:在JavaScript中<code class="fe mo mp mq mr b">in</code>操作符主要是检查一个属性名是否在一个对象中，在TypeScript中主要是缩小潜在类型的范围。</p><p id="bab9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">keyof</code>操作符:<code class="fe mo mp mq mr b">keyof</code>操作符接受一个对象类型，并生成其键的字符串或数字联合。</p><p id="1b7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下StackBlitz示例显示了它们的功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="ed20" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">必需的<type/></h1><p id="5d6d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">根据需要设置传入<code class="fe mo mp mq mr b">Type</code>的所有属性。其源代码如下:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="e29e" class="mw ls iq mr b gy mx my l mz na">/**<br/> * Make all properties in T required<br/> */<br/>type Required&lt;T&gt; = {<br/>    [P in keyof T]-?: T[P];<br/>};</span></pre><p id="0995" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是<code class="fe mo mp mq mr b">Partial&lt;Type&gt;</code>的反义词。两者对比，发现只多了一个<code class="fe mo mp mq mr b">-</code>修饰语，可以理解为“减”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="3a26" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">只读<type/></h1><p id="55c0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">它将传入<code class="fe mo mp mq mr b">Type</code>的所有属性设置为<code class="fe mo mp mq mr b">readonly</code>。其源代码如下:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="4bae" class="mw ls iq mr b gy mx my l mz na">/**<br/> * Make all properties in T readonly<br/> */<br/>type Readonly&lt;T&gt; = {<br/>    readonly [P in keyof T]: T[P];<br/>};</span></pre><p id="1911" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以看到只添加了<code class="fe mo mp mq mr b">readonly</code>修改器。</p><p id="8f1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">能不能根据上一节说的<code class="fe mo mp mq mr b">-</code>描述符做一个“OnlyChanged”？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="69a1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">记录<keys type=""/></h1><p id="c3b3" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">从属性键<code class="fe mo mp mq mr b">Keys</code>和属性值<code class="fe mo mp mq mr b">Type</code>构造一个对象类型。其源代码如下:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="1993" class="mw ls iq mr b gy mx my l mz na">/**<br/> * Construct a type with a set of properties K of type T<br/> */<br/>type Record&lt;K extends keyof any, T&gt; = {<br/>    [P in K]: T;<br/>};</span></pre><p id="a532" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来分析一下关键点:</p><p id="10a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">extends</code>关键字:此处表示限额K必须可分配给<code class="fe mo mp mq mr b">keyof any</code>。</p><p id="b19f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">keyof any</code>:返回任何可以作为对象索引的值的类型。为什么这么说？这是因为TypeScript编译选项中只有<a class="ae nd" href="https://www.typescriptlang.org/tsconfig#keyofStringsOnly" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">key of strings only</strong></a>，默认为false，那么<code class="fe mo mp mq mr b">keyof any</code>将返回<code class="fe mo mp mq mr b">string | number | symbol</code>类型，为true时，<code class="fe mo mp mq mr b">keyof any</code>将返回类型<code class="fe mo mp mq mr b">string</code>。</p><h1 id="c0b8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">选择<type keys=""/></h1><p id="e0cf" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">从“类型”中选择一组属性键来构造新类型。其源代码如下:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="7d58" class="mw ls iq mr b gy mx my l mz na">/**<br/> * From T, pick a set of properties whose keys are in the union K<br/> */<br/>type Pick&lt;T, K extends keyof T&gt; = {<br/>    [P in K]: T[P];<br/>};</span></pre><p id="0ef2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它与上面的<code class="fe mo mp mq mr b">Record&lt;Keys, Type&gt;</code>非常相似，除了它将传递的联合<code class="fe mo mp mq mr b">K</code>限定为T的所有属性的联合类型，并使用<code class="fe mo mp mq mr b">T[P]</code>来访问相应的属性值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="eaea" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">排除<uniontype excludedmembers="">、提取<type union="">、不可空<type/></type></uniontype></h1><p id="793a" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我把这三个放在一起，因为它们很相似，理解其中一个，剩下的就容易了。</p><p id="602b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">Exclude&lt;UnionType, ExcludedMembers&gt;</code>:通过从<code class="fe mo mp mq mr b">UnionType</code>中排除所有可赋给<code class="fe mo mp mq mr b">ExcludedMembers</code>的联合成员来构造类型。</p><p id="e206" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">Extract&lt;Type, Union&gt;</code>:通过从<code class="fe mo mp mq mr b">Type</code>中提取所有可分配给<code class="fe mo mp mq mr b">Union</code>的联合成员来构造类型。</p><p id="6d88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">NonNullable&lt;Type&gt;</code>:通过从<code class="fe mo mp mq mr b">Type</code>中排除<code class="fe mo mp mq mr b">null</code>和<code class="fe mo mp mq mr b">undefined</code>来构造类型。</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="4b70" class="mw ls iq mr b gy mx my l mz na">/**<br/> * Exclude from T those types that are assignable to U<br/> */<br/>type Exclude&lt;T, U&gt; = T extends U ? never : T;</span><span id="c206" class="mw ls iq mr b gy ne my l mz na">/**<br/> * Extract from T those types that are assignable to U<br/> */<br/>type Extract&lt;T, U&gt; = T extends U ? T : never;</span><span id="85ed" class="mw ls iq mr b gy ne my l mz na">/**<br/> * Exclude null and undefined from T<br/> */<br/>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</span></pre><p id="4d9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从源代码可以看出，它们的逻辑很简单，如果前者可以赋给后者，那么就设置为<code class="fe mo mp mq mr b">never</code>类型或者原类型。</p><p id="dad9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里<code class="fe mo mp mq mr b">never</code>表示永远不会出现的值的类型，在这里可以用来删除选中的类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7101" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于TypeScript中<code class="fe mo mp mq mr b">never</code>类型的秘密，请查看我的另一篇文章:</p><div class="nf ng gp gr nh ni"><a href="https://blog.bitsrc.io/secrets-of-never-types-in-typescript-de57795a34da" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">TypeScript中“从不”类型的秘密</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">如何在TypeScript中获取never类型的值，never vs. void在TypeScript中，never在TypeScript函数声明中。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">blog.bitsrc.io</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kp ni"/></div></div></a></div><h1 id="acd2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">省略<type keys=""/></h1><p id="2388" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">通过从<code class="fe mo mp mq mr b">Type</code>中选取所有属性，然后移除<code class="fe mo mp mq mr b">Keys</code>(字符串文字或字符串文字的联合)来构造类型。其源代码如下:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="b823" class="mw ls iq mr b gy mx my l mz na">/**<br/> * Construct a type with the properties of T except for those in type K.<br/> */<br/>type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span></pre><p id="0963" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以看出，它结合了之前介绍的实用程序类型，最终实现了更强大的功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="03d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天就到这里。我是Zachary，我将继续输出与web开发相关的故事。如果你喜欢这样的故事，想支持我，请考虑成为 <a class="ae nd" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="oe">中等会员</em> </a> <em class="oe">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae nd" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="oe">我的链接</em> </a> <em class="oe">报名，我会得到一点佣金。</em></p><p id="7f07" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你的支持对我来说很重要——谢谢。</p><p id="84da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="oe">更多内容请看</em><a class="ae nd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="oe">plain English . io</em></strong></a><em class="oe">。报名参加我们的</em> <a class="ae nd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="oe">免费周报</em> </strong> </a> <em class="oe">。关注我们关于</em><a class="ae nd" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="oe">Twitter</em></strong></a><em class="oe">和</em><a class="ae nd" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="oe">LinkedIn</em></strong></a><em class="oe">。加入我们的</em> <a class="ae nd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="oe">社区不和谐</em> </strong> </a> <em class="oe">。</em></p></div></div>    
</body>
</html>