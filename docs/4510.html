<html>
<head>
<title>Five Minimum Viable Javascript Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">五个最低可行的Javascript面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/five-minimum-viable-javascript-interview-questions-d839d855a8a4?source=collection_archive---------9-----------------------#2022-12-09">https://javascript.plainenglish.io/five-minimum-viable-javascript-interview-questions-d839d855a8a4?source=collection_archive---------9-----------------------#2022-12-09</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="3c5c" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">面试官:问他们你的面试是不是快没时间了。签证人:如果你的准备时间快用完了，就练习一下。</h2></div></div><div class="ab cl kg kh hv ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ik il im in io"><p id="8b0c" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><em class="lj">这是我的</em> <a class="ae lk" href="https://medium.com/50ld/five-minimum-viable-interview-questions-series-e8531b5f7db2" rel="noopener"> <em class="lj">五个最起码可行的面试问题系列</em> </a> <em class="lj">的一部分，在这里我研究并整理了每个面试题目的五个基本面试问题。所有这些问题都旨在评估工作中需要的实际技能</em></p></div><div class="ab cl kg kh hv ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ik il im in io"><p id="346e" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">如今，公司招聘全栈职位是很常见的。一个全栈开发人员通常会同时从事前端和后端开发。同样的期望也适用于面试。</p><p id="6471" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">因此，要想获得一个全栈职位，面试或被面试都很难。会有太多的问题要问或准备。但是如果你快没时间了，这里有五个问题我觉得你应该知道。</p><figure class="lm ln lo lp gu lq gi gj paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gi gj ll"><img src="../Images/30a99320cce8c74b9847b4fa89ce729d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ufACmK4armozbXnU"/></div></div><figcaption class="lx ly gk gi gj lz ma bd b be z dk">Photo by <a class="ae lk" href="https://unsplash.com/@wocintechchat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christina @ wocintechchat.com</a> on <a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kg kh hv ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ik il im in io"><h1 id="b401" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">#1 —运算符<code class="fe mt mu mv mw b">==</code>和===有什么区别？</h1><blockquote class="mx my mz"><p id="ced8" class="kn ko lj kp b kq kr js ks kt ku jv kv na kx ky kz nb lb lc ld nc lf lg lh li ik bi translated">良好的Javascript实践不鼓励使用<code class="fe mt mu mv mw b">==</code>操作符来减少类型转换导致的错误。现代林挺工具通常会标记出<code class="fe mt mu mv mw b">==</code>的任何用法。因此，这个问题测试考生对Javascript的实际知识和经验</p></blockquote><p id="88fc" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">两个运算符都比较它们的两个操作数，并返回一个布尔结果</p><p id="c664" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">严格相等操作符<code class="fe mt mu mv mw b">===</code>要求其操作数类型相同，否则返回<code class="fe mt mu mv mw b">false</code>，而<code class="fe mt mu mv mw b">==</code>操作符可能会在比较结果值之前尝试类型转换。</p><p id="11d0" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><code class="fe mt mu mv mw b">===</code>认为<code class="fe mt mu mv mw b">null</code>和<code class="fe mt mu mv mw b">undefined</code>不同，而<code class="fe mt mu mv mw b">==</code>认为相同</p><p id="767c" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">示例代码:</p><pre class="lm ln lo lp gu nd mw ne bn nf ng bi"><span id="a730" class="nh mc ir mw b be ni nj l nk nl">/* Equality */<br/>1 == "1"           // true<br/>1 == "00001"       // true<br/>1 == "  00001   "  // true<br/>null == undefined  // true<br/><br/>/* Strict equality */<br/>1 === "1"          // false<br/>null == undefined  // false  </span></pre><p id="0f8f" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">参考资料:</p><ul class=""><li id="99cd" class="nm nn ir kp b kq kr kt ku kw no la np le nq li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Strict _ equality</a></li><li id="da4f" class="nm nn ir kp b kq nv kt nw kw nx la ny le nz li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Equality</a></li></ul></div><div class="ab cl kg kh hv ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ik il im in io"><h1 id="2931" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">#2 —什么时候使用<code class="fe mt mu mv mw b">const</code>、<code class="fe mt mu mv mw b">let</code>和<code class="fe mt mu mv mw b">var</code>？</h1><blockquote class="mx my mz"><p id="0264" class="kn ko lj kp b kq kr js ks kt ku jv kv na kx ky kz nb lb lc ld nc lf lg lh li ik bi translated">这个问题不仅测试候选人对新结构的熟悉程度，还验证候选人是否区分常数和正态变量。</p></blockquote><p id="d3c9" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><code class="fe mt mu mv mw b">var</code>是Javascript中声明变量的最古老方式。函数中用<code class="fe mt mu mv mw b">var</code>声明的变量具有该函数的作用域。如果在任何函数之外声明，它具有全局范围。使用<code class="fe mt mu mv mw b">var</code>声明的变量在任何代码被执行之前<em class="lj">被创建，这个过程被称为提升，初始值被设置为<code class="fe mt mu mv mw b">undefined</code>。使用<code class="fe mt mu mv mw b">var</code>重新声明变量不会触发错误或重置其值，除非执行另一个赋值</em></p><pre class="lm ln lo lp gu nd mw ne bn nf ng bi"><span id="ff7e" class="nh mc ir mw b be ni nj l nk nl">'use strict';<br/>function foo() {<br/>  function bar() {<br/>    var y = 2;<br/>    console.log(x); // undefined (x is hoisted, carrying "undefined")<br/>    console.log(y); // 2 (`y` is in scope)<br/>  }<br/>  bar();<br/>  var x = 1;        // x is initialized<br/>  console.log(x);   // 1 (`x` is in scope)<br/>  console.log(y);   // ReferenceError in strict mode, `y` is scoped to `bar`<br/>}<br/><br/>foo();</span></pre><p id="8ac8" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><code class="fe mt mu mv mw b">let</code>是声明变量的更新和首选方式。用<code class="fe mt mu mv mw b">let</code>声明的变量具有块作用域(对同一个块和任何嵌套的作用域可见)，并且只有在其声明被执行<em class="lj">后才可访问</em> —相关概念:时间死区(TDZ)。在同一个块或函数中用<code class="fe mt mu mv mw b">let</code>重新声明变量会导致语法错误</p><pre class="lm ln lo lp gu nd mw ne bn nf ng bi"><span id="c857" class="nh mc ir mw b be ni nj l nk nl">/* block scope variable */<br/>let x = 1;<br/>if (x === 1) {<br/>  let x = 2;       // OK, redeclare in a different block<br/><br/>  console.log(x);  // expected output: 2<br/>}<br/>console.log(x);   // expected output: 1<br/>let x = 10;        // syntax error<br/><br/><br/>/* TDZ example */<br/>{<br/>  // TDZ starts at beginning of scope<br/>  const func = () =&gt; console.log(letVar); // OK<br/><br/>  // Within the TDZ letVar access throws `ReferenceError`<br/><br/>  let letVar = 3; // End of TDZ (for letVar)<br/>  func();         // Called outside TDZ!<br/>}</span></pre><p id="b735" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><code class="fe mt mu mv mw b">const</code>在<code class="fe mt mu mv mw b">var</code>之后<code class="fe mt mu mv mw b">let</code>之前引入，用于声明一个值不能改变的常量。因此<code class="fe mt mu mv mw b">const</code>声明需要一个初始化器给变量分配一个常量值。变量的范围可以是全局的，也可以是块范围的。重新声明<code class="fe mt mu mv mw b">const</code>变量导致语法错误。一个常见的惯例是用大写字母表示常量变量</p><pre class="lm ln lo lp gu nd mw ne bn nf ng bi"><span id="505f" class="nh mc ir mw b be ni nj l nk nl">const MY_CONSTANT = 111;<br/><br/>/** Errors:<br/>MY_CONSTANT= 20;   // TypeError: Assignment to constant variable.<br/>const MY_CONSTANT= 20;<br/>let MY_CONSTANT= 20;<br/>var MY_CONSTANT= 20;<br/>*/<br/><br/>if (true) {<br/>  let MY_CONSTANT = 20; // OK, different block scope<br/>  console.log("my favorite number is " + MY_CONSTANT);  // 20<br/>}<br/><br/>console.log("my favorite number is " + MY_CONSTANT);    // 111</span></pre><p id="a67e" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">参考资料:</p><ul class=""><li id="ec14" class="nm nn ir kp b kq kr kt ku kw no la np le nq li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/const</a></li><li id="03e1" class="nm nn ir kp b kq nv kt nw kw nx la ny le nz li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/let</a></li><li id="07e5" class="nm nn ir kp b kq nv kt nw kw nx la ny le nz li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/var</a></li></ul></div><div class="ab cl kg kh hv ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ik il im in io"><h1 id="b221" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated"># 3—如何创建新对象？</h1><blockquote class="mx my mz"><p id="55bb" class="kn ko lj kp b kq kr js ks kt ku jv kv na kx ky kz nb lb lc ld nc lf lg lh li ik bi translated">尽管不是面向对象的语言，object还是经常出现在Javascript代码中。因此，知道如何用属性和方法创建对象是必须的。</p></blockquote><p id="c641" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">在Javascript中创建对象最简单的方法是使用对象初始化器语法:一个由零对或多对属性名和对象的相关值组成的逗号分隔的列表，用花括号<code class="fe mt mu mv mw b">{}</code>括起来。</p><pre class="lm ln lo lp gu nd mw ne bn nf ng bi"><span id="fa64" class="nh mc ir mw b be ni nj l nk nl">const emptyObject = {}<br/><br/>const objectWithProperty = { <br/>   a: 1, <br/>   b: 'b', <br/>   c: true, <br/>   d: { nested: 'property'} <br/>}<br/><br/>const a = 1, b = 'b', c = true, d = { nested: 'property'}<br/>const anotherObjectWithProperty = { a, b, c, d }<br/><br/>// Computed property names<br/>const prop = 'foo';<br/>const computedObjectProperty = {<br/>  [prop]: 'hey',<br/>  ['b' + 'ar']: 'there',<br/>};</span></pre><p id="9ef6" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><code class="fe mt mu mv mw b">new Object()</code>或<code class="fe mt mu mv mw b">Object.create()</code>也可以用来创建一个新对象</p><pre class="lm ln lo lp gu nd mw ne bn nf ng bi"><span id="9aa9" class="nh mc ir mw b be ni nj l nk nl">const newObject = new Object();<br/>newObject.a = 1;<br/>newObject.b = 'b'<br/><br/>const anotherObject = Object.create(null);</span></pre><p id="6b23" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">参考资料:</p><ul class=""><li id="1cfa" class="nm nn ir kp b kq kr kt ku kw no la np le nq li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Object</a></li><li id="5f95" class="nm nn ir kp b kq nv kt nw kw nx la ny le nz li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Object _ initializer</a></li></ul><h1 id="091c" class="mb mc ir bd md me oa mg mh mi ob mk ml jx oc jy mn ka od kb mp kd oe ke mr ms bi translated"><strong class="ak"># 4——如何用计算面积的方法创建一个新的5x5正方形对象？</strong></h1><blockquote class="mx my mz"><p id="630f" class="kn ko lj kp b kq kr js ks kt ku jv kv na kx ky kz nb lb lc ld nc lf lg lh li ik bi translated">这类似于问题3，我们想测试候选人创造物体的能力。此外，它还测试考生的<code class="fe mt mu mv mw b">this</code>知识和声明对象功能的不同方式</p></blockquote><p id="f65e" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">在版本1和版本2中，有两种有效的方法来声明下面显示的方法。</p><p id="6784" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">第三个版本是一个陷阱，因为arrow函数捕获封闭上下文的<code class="fe mt mu mv mw b">this</code>的方式。使用<code class="fe mt mu mv mw b">.call</code>或<code class="fe mt mu mv mw b">.bind</code>将箭头功能绑定到对象不起作用。</p><pre class="lm ln lo lp gu nd mw ne bn nf ng bi"><span id="c3c7" class="nh mc ir mw b be ni nj l nk nl">// version 1<br/>const square1 = { <br/>  side: 5,<br/>  area: function () {<br/>    return this.side * this.side;<br/>  }<br/>}<br/>square1.area();  // 25<br/><br/>// version 2<br/>const square2 = { <br/>  side: 5,<br/>  area() {<br/>    return this.side * this.side<br/>  }<br/>}<br/>square2.area();  // 25<br/><br/><br/>// version 3: warning: this with arrow function<br/>const square3 = { <br/>  side: 5,<br/>  area: () =&gt; this.side * this.side<br/>}<br/>square3.area();  // NaN - why?<br/></span></pre><p id="18d7" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">参考资料:</p><ul class=""><li id="c49c" class="nm nn ir kp b kq kr kt ku kw no la np le nq li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/this</a></li><li id="f9a8" class="nm nn ir kp b kq nv kt nw kw nx la ny le nz li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Object _ initializer</a></li></ul><h1 id="5e68" class="mb mc ir bd md me oa mg mh mi ob mk ml jx oc jy mn ka od kb mp kd oe ke mr ms bi translated">#5 —你用承诺(或可观察到的)做什么？</h1><blockquote class="mx my mz"><p id="3900" class="kn ko lj kp b kq kr js ks kt ku jv kv na kx ky kz nb lb lc ld nc lf lg lh li ik bi translated">异步执行非常普遍。编写前端程序时很少不进行一些网络调用，或者设置超时或间隔。承诺的知识(或者如果你使用Angular或RxJs的话，是可观察的)是必不可少的。</p></blockquote><p id="1296" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">Promise(或Observable)是一种流行的异步Javascript编程方式。它允许开发人员编写代码来:</p><ul class=""><li id="1c84" class="nm nn ir kp b kq kr kt ku kw no la np le nq li nr ns nt nu bi translated">触发异步执行</li><li id="cd4c" class="nm nn ir kp b kq nv kt nw kw nx la ny le nz li nr ns nt nu bi translated">然后，当它成功完成时，或者出错时，或者不管怎样，处理结果。</li></ul><p id="83bb" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">Promise(或Observable)允许链接调用和处理程序。这提供了一种强大而直观的方式来对多个异步执行进行编程并处理它们的结果。</p><pre class="lm ln lo lp gu nd mw ne bn nf ng bi"><span id="b0f4" class="nh mc ir mw b be ni nj l nk nl">// Promise<br/>const hello = fetch('https://echook.azurewebsites.net/echo')<br/>  .then(resp =&gt; resp.text())<br/>  .then(text =&gt; JSON.parse(text))   // or  resp.json() instead of text()<br/>  .then(console.log)<br/><br/><br/>// Angular's Observable<br/>this.httpClient.get&lt;string&gt;('https://echook.azurewebsites.net/echo')<br/>   .subscribe(resp =&gt; {<br/>      console.log(resp.body)<br/>    });<br/>}</span></pre><p id="3041" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">参考资料:</p><ul class=""><li id="ae4d" class="nm nn ir kp b kq kr kt ku kw no la np le nq li nr ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Promise</a></li><li id="0efe" class="nm nn ir kp b kq nv kt nw kw nx la ny le nz li nr ns nt nu bi translated"><a class="ae lk" href="https://angular.io/guide/observables-in-angular" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/observables-in-angular</a></li></ul></div><div class="ab cl kg kh hv ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ik il im in io"><p id="e115" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">如果你喜欢这篇文章，请<a class="ae lk" href="https://medium.com/@geraldnguyen" rel="noopener">关注我</a>获取更多优质内容。</p><p id="9652" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated">谢谢你。</p><p id="209c" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><em class="lj">更多内容看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp is"> <em class="lj">说白了就是</em> </strong> </a> <em class="lj">。</em></p><p id="4efb" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><em class="lj">报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp is"> <em class="lj">免费每周简讯</em> </strong> </a> <em class="lj">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kp is"><em class="lj">Twitter</em></strong></a>，<a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kp is"><em class="lj">LinkedIn</em></strong></a><em class="lj">，</em><a class="ae lk" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kp is"><em class="lj">YouTube</em></strong></a><em class="lj"/><a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kp is"><em class="lj">不和</em> </strong> </a> <strong class="kp is"> <em class="lj">。</em>T55】</strong></p><p id="e97f" class="pw-post-body-paragraph kn ko ir kp b kq kr js ks kt ku jv kv kw kx ky kz la lb lc ld le lf lg lh li ik bi translated"><strong class="kp is"> <em class="lj">对缩放您的软件启动感兴趣</em> </strong> <em class="lj">？检查出</em> <a class="ae lk" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kp is"> <em class="lj">电路</em> </strong> </a> <em class="lj">。</em></p></div></div>    
</body>
</html>