<html>
<head>
<title>How to Implement the Binary Tree Using JavaScript in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年如何用JavaScript实现二叉树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-tree-how-to-implement-using-javascript-in-2022-8b1960fc73fa?source=collection_archive---------6-----------------------#2022-02-20">https://javascript.plainenglish.io/binary-tree-how-to-implement-using-javascript-in-2022-8b1960fc73fa?source=collection_archive---------6-----------------------#2022-02-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6116" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">二叉树数据结构实用指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6de5289f62d29cf31fecdbdddf08b40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5d4o2UE6WEMgkGKgUHClg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Binary Tree</figcaption></figure><p id="f87a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本文中，我们将详细阅读二叉树。我们将看到如何用JavaScript构建和遍历它。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="cd0e" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">树形数据结构</h1><p id="4f43" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">树是一种遵循某种层次结构的非线性数据结构。它是树节点的集合。</p><p id="659f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">树节点存储关于它的节点值、它的左子地址和右子地址的信息。</p><p id="a2cf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在树中，一个树节点可以有多个子节点。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/e53d7fbe0d4fa2b32db5efe1cb7cc84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*VWw_eU1ajL14e22FZoMPPQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Binary Tree — weekendtutorial.com</figcaption></figure><h1 id="d8b5" class="lv lw in bd lx ly mt ma mb mc mu me mf jt mv ju mh jw mw jx mj jz mx ka ml mm bi translated">树木的基本术语</h1><p id="1f01" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">在深入研究代码之前，让我们先了解一下基本术语</p><ol class=""><li id="354d" class="my mz in ku b kv kw ky kz lb na lf nb lj nc ln nd ne nf ng bi translated"><strong class="ku io">根</strong> —根是树的最顶端节点，例如上图中10是根节点。</li><li id="f378" class="my mz in ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated"><strong class="ku io">兄弟</strong> —父节点的孩子彼此是兄弟，例如20 &amp; 30是兄弟，因为两者都是节点10的孩子。</li><li id="f561" class="my mz in ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated"><strong class="ku io">表亲</strong>——叔叔的孩子是我们的表亲，例如节点30是节点40 &amp; 50的叔叔。因此，节点40、50、60和70都是表亲。</li><li id="b16e" class="my mz in ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated"><strong class="ku io">节点的高度</strong> —从当前节点到最远叶子的距离，例如Height(20) = 2，因为80是离节点20最远的叶子。</li><li id="29c8" class="my mz in ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated"><strong class="ku io">节点的深度</strong> —从根到节点的距离，例如深度(20) = 1</li></ol><p id="aae8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">整个树的高度=根节点的高度</p><p id="8d91" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">整棵树的深度=整棵树的高度</p><h1 id="d735" class="lv lw in bd lx ly mt ma mb mc mu me mf jt mv ju mh jw mw jx mj jz mx ka ml mm bi translated">二叉树数据结构</h1><p id="0776" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">二叉树是一种树，其中一个树节点最多可以有0、1或2个子节点。</p><h1 id="e856" class="lv lw in bd lx ly mt ma mb mc mu me mf jt mv ju mh jw mw jx mj jz mx ka ml mm bi translated">如何用JavaScript实现二叉树？</h1><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="fb95" class="nr lw in nn b gy ns nt l nu nv">function TreeNode(data) {<br/>  this.data = data;<br/>  this.left = null;<br/>  this.right = null;<br/>}<br/><br/>function createTree() {<br/>  let root = new TreeNode(10);<br/><br/>  root.left = new TreeNode(20);<br/>  root.right = new TreeNode(30);<br/><br/>  root.left.left = new TreeNode(40);<br/>  root.left.right = new TreeNode(50);<br/><br/>  root.right.left = new TreeNode(60);<br/>  root.right.right = new TreeNode(70);<br/><br/>  root.left.left.right = new TreeNode(80);<br/><br/>  return root;<br/>}</span></pre><h1 id="28d9" class="lv lw in bd lx ly mt ma mb mc mu me mf jt mv ju mh jw mw jx mj jz mx ka ml mm bi translated">如何遍历一棵二叉树？</h1><p id="a9c8" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">遍历意味着访问二叉树的每个节点。</p><p id="b4ea" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有3种方法可以遍历二叉树</p><ol class=""><li id="4a28" class="my mz in ku b kv kw ky kz lb na lf nb lj nc ln nd ne nf ng bi translated">前序遍历</li><li id="047f" class="my mz in ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">有序遍历</li><li id="3088" class="my mz in ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">后序遍历</li></ol><p id="7a3b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">还有一个遍历<strong class="ku io">级别顺序遍历</strong>不在本文讨论范围内。我们会在解二叉树的左视图，右视图等时读到。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/e53d7fbe0d4fa2b32db5efe1cb7cc84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*VWw_eU1ajL14e22FZoMPPQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Binary Tree</figcaption></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="a96d" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">前序遍历(使用递归)</h1><p id="d5a1" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">它以下面的方式遍历树— <strong class="ku io">数据左向右。</strong></p><p id="5678" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上述树的前序遍历是-10 20 40 80 50 30 60 70</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="6f83" class="nr lw in nn b gy ns nt l nu nv">function preOrder(root) {<br/>  if (root === null) return;</span><span id="7bf6" class="nr lw in nn b gy nw nt l nu nv">  // print the node data<br/>  console.log(root.data);</span><span id="3a7f" class="nr lw in nn b gy nw nt l nu nv">  // goto left<br/>  preOrder(root.left);</span><span id="9690" class="nr lw in nn b gy nw nt l nu nv">  // goto right<br/>  preOrder(root.right);<br/>}</span></pre><p id="a6fc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">时间复杂度:</strong> O(n)(每个树节点处理一次)<br/> <strong class="ku io">空间复杂度:</strong> O(h) h是树的高度。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="9cdd" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">前序遍历(无递归)</h1><p id="7397" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">递归非常简单，但是如果你要申请一个软件开发人员的职位，你可能会被要求迭代地遍历树，也就是说不需要递归。</p><p id="2fab" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将使用一个<strong class="ku io">堆栈</strong>来记住前一个节点，并使用一个<strong class="ku io">数组</strong>来存储答案。</p><p id="1153" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">要解决这个问题，可以考虑一下前序公式— <strong class="ku io">数据左右</strong>并将其可视化。</p><p id="3f59" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">考虑一个只有3个节点的例子</p><p id="dc61" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">5 <br/> / \ <br/> 10 15</p><p id="06f0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">预订时间是5 10 15</p><p id="7240" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，在处理完节点5之后，下一个将是节点10。如果我们使用一个堆栈，并推动当前节点的左和右节点，那么将首先推动右节点，然后推动左节点，因为我们需要先遍历左子节点。</p><p id="0a32" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你理解了这一点，实现就更容易理解了。</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="e43d" class="nr lw in nn b gy ns nt l nu nv">function preOrder(root) {</span><span id="8f9c" class="nr lw in nn b gy nw nt l nu nv">  let ans = [];</span><span id="ff9c" class="nr lw in nn b gy nw nt l nu nv">  if (root === null) return ans;</span><span id="cc6b" class="nr lw in nn b gy nw nt l nu nv">  // push root into stack<br/>  let stack = [root];</span><span id="1895" class="nr lw in nn b gy nw nt l nu nv">  // loop while stack is not empty<br/>  while (stack.length) {</span><span id="ea19" class="nr lw in nn b gy nw nt l nu nv">    let cur = stack.pop();</span><span id="6867" class="nr lw in nn b gy nw nt l nu nv">    // push the node data to ans<br/>    ans.push(cur.data);</span><span id="aced" class="nr lw in nn b gy nw nt l nu nv">    // push right node into stack<br/>    if (cur.right) {<br/>      stack.push(cur.right);<br/>    }</span><span id="a674" class="nr lw in nn b gy nw nt l nu nv">    // push left node into stack<br/>    // as it pushed last so will be pop first<br/>    // i.e this ensures data left right ordering<br/>    if (cur.left) {<br/>      stack.push(cur.left);<br/>    }</span><span id="f235" class="nr lw in nn b gy nw nt l nu nv">  }</span><span id="08f0" class="nr lw in nn b gy nw nt l nu nv">  return ans;<br/>}</span></pre><p id="a74f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">时间复杂度:</strong> O(n)(每个树节点处理一次)</p><p id="ae69" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">空间复杂度:</strong> O(h) + O(n) ~= O(n) h是树的高度。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="ab46" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">有序遍历(使用递归)</h1><p id="9687" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">它以如下方式遍历树— <strong class="ku io">左数据右</strong></p><p id="94fd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上述树的顺序遍历是-40 80 20 50 10 60 30 70</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="3f06" class="nr lw in nn b gy ns nt l nu nv">function inOrder(root) {<br/>  if (root === null) return;</span><span id="eb12" class="nr lw in nn b gy nw nt l nu nv">  // goto left<br/>  inOrder(root.left);</span><span id="45bf" class="nr lw in nn b gy nw nt l nu nv">  // print the node data<br/>  console.log(root.data);</span><span id="82c2" class="nr lw in nn b gy nw nt l nu nv">  // goto right<br/>  inOrder(root.right);<br/>}</span></pre><p id="e449" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">时间复杂度:</strong> O(n)(每个树节点处理一次)</p><p id="ebde" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">空间复杂度:</strong> O(h) h是树的高度。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="1ab1" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">有序遍历(无递归)</h1><p id="68c4" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">顺序公式:<strong class="ku io">左数据右</strong></p><p id="12c8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">根据公式，我们将遵循以下步骤—</p><p id="3a19" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> Step1 </strong>:我们将向左移动，继续将每个节点推入堆栈。</p><p id="300b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">步骤2 </strong>:弹出栈顶元素</p><p id="f833" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">步骤3 </strong>:向右并跟随<strong class="ku io">步骤1 </strong></p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="515e" class="nr lw in nn b gy ns nt l nu nv">function inOrder(root) {</span><span id="3eb3" class="nr lw in nn b gy nw nt l nu nv">  let ans = [];</span><span id="125f" class="nr lw in nn b gy nw nt l nu nv">  if (root === null) return ans;</span><span id="c5b5" class="nr lw in nn b gy nw nt l nu nv">  // push root into stack<br/>  let stack = [];</span><span id="1107" class="nr lw in nn b gy nw nt l nu nv">  let cur = root;</span><span id="d27c" class="nr lw in nn b gy nw nt l nu nv">  // loop while stack is not empty<br/>  while (cur || stack.length) {</span><span id="b59b" class="nr lw in nn b gy nw nt l nu nv">    // goto left<br/>    while(cur) {<br/>      stack.push(cur);<br/>      cur = cur.left;<br/>    }</span><span id="921a" class="nr lw in nn b gy nw nt l nu nv">    // push the node data to ans<br/>    cur = stack.pop();<br/>    ans.push(cur.data);</span><span id="96ec" class="nr lw in nn b gy nw nt l nu nv">    // push right node into stack<br/>    cur = cur.right;</span><span id="99c1" class="nr lw in nn b gy nw nt l nu nv">  }</span><span id="47fc" class="nr lw in nn b gy nw nt l nu nv">  return ans.reverse();<br/>}</span></pre><p id="792c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">时间复杂度:</strong> O(n)(每个树节点处理一次)</p><p id="fe59" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">空间复杂度:</strong> O(h) + O(n) ~= O(n) h是树的高度。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="3389" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">后序遍历(使用递归)</h1><p id="d617" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">它以如下方式遍历树— <strong class="ku io">左右数据</strong></p><p id="6788" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上述树的后序遍历是-80 40 50 20 60 70 30 10</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="88d2" class="nr lw in nn b gy ns nt l nu nv">function postOrder(root) {<br/>  if (root === null) return;</span><span id="c2fd" class="nr lw in nn b gy nw nt l nu nv">  // goto left<br/>  postOrder(root.left);</span><span id="dd8c" class="nr lw in nn b gy nw nt l nu nv">  // goto right<br/>  postOrder(root.right);</span><span id="3a99" class="nr lw in nn b gy nw nt l nu nv">  // print the node data<br/>  console.log(root.data);<br/>}</span></pre><p id="6da7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">时间复杂度:</strong> O(n)(每个树节点处理一次)</p><p id="effc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">空间复杂度:</strong> O(h) h是树的高度。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="eb00" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">后序遍历(无递归)</h1><p id="df72" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">让我们再来考虑一下前序遍历的解决方案。这个和那个相似。</p><p id="1654" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">预定公式:<strong class="ku io">数据左右</strong></p><p id="4db0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，颠倒左右位置，公式将变成<strong class="ku io">数据右-左</strong></p><p id="9610" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">而如果我们把整个公式反过来，最后的公式就会变成——<strong class="ku io">左右数据</strong></p><p id="478e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是后序遍历的公式。</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="9b41" class="nr lw in nn b gy ns nt l nu nv">function postOrder(root) {</span><span id="3fda" class="nr lw in nn b gy nw nt l nu nv">  let ans = [];</span><span id="6657" class="nr lw in nn b gy nw nt l nu nv">  if (root === null) return ans;</span><span id="f779" class="nr lw in nn b gy nw nt l nu nv">  // push root into stack<br/>  let stack = [root];</span><span id="de74" class="nr lw in nn b gy nw nt l nu nv">  // loop while stack is not empty<br/>  while (stack.length) {</span><span id="19e4" class="nr lw in nn b gy nw nt l nu nv">    let cur = stack.pop();</span><span id="231a" class="nr lw in nn b gy nw nt l nu nv">    // push the node data to ans<br/>    ans.push(cur.data);</span><span id="e14d" class="nr lw in nn b gy nw nt l nu nv">    // push left node into stack<br/>    if (cur.left) {<br/>      stack.push(cur.left);<br/>    }</span><span id="1e42" class="nr lw in nn b gy nw nt l nu nv">    // push right node into stack<br/>    if (cur.right) {<br/>      stack.push(cur.right);<br/>    }<br/>  }</span><span id="8bf1" class="nr lw in nn b gy nw nt l nu nv">  return ans.reverse();<br/>}</span></pre><p id="d290" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">时间复杂度:</strong> O(n)(每个树节点处理一次)</p><p id="bc93" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">空间复杂度:</strong> O(h) + O(n) ~= O(n) h是树的高度。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="3218" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">结论</h1><p id="3ba9" class="pw-post-body-paragraph ks kt in ku b kv mn jo kx ky mo jr la lb mp ld le lf mq lh li lj mr ll lm ln ig bi translated">我们已经看到了JavaScript中二叉树的实现及其递归和非递归方式的遍历前序、中序和后序。</p><p id="b070" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这篇文章的目的是一次性给你巩固的知识。从面试的角度来看，非递归遍历非常重要。</p><p id="4448" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">请跟我来！</p><p id="8414" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢您阅读文章！</p><p id="a16e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="nx">更多内容请看</em><a class="ae ny" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nx">plain English . io</em></strong></a><em class="nx">。报名参加我们的</em> <a class="ae ny" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="nx">免费周报</em> </strong> </a> <em class="nx">。在我们的</em> <a class="ae ny" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="nx">社区</em> </strong> </a> <em class="nx">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>