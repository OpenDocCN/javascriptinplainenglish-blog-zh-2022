<html>
<head>
<title>Advanced TypeScript: Type-Level Nested Object Paths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级类型脚本:类型级嵌套对象路径</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-typescript-type-level-nested-object-paths-7f3d8901f29a?source=collection_archive---------0-----------------------#2022-03-21">https://javascript.plainenglish.io/advanced-typescript-type-level-nested-object-paths-7f3d8901f29a?source=collection_archive---------0-----------------------#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9f64" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">条件类型、类型推理、模板文字类型和递归的真实用例。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a2d16bbd2085b6c3f2ff3aada0a9b3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPypx95OYL_Bm8OWadUU9A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Nested Object Paths</figcaption></figure><h1 id="77f4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">目录</h1><p id="a6f3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae mj" href="#7501" rel="noopener ugc nofollow"> ❓问题</a> <br/> <a class="ae mj" href="#4b40" rel="noopener ugc nofollow"> ✅结果</a> <br/> <a class="ae mj" href="#4d33" rel="noopener ugc nofollow">📝解释</a><br/>∘<a class="ae mj" href="#762c" rel="noopener ugc nofollow">nested paths</a><br/>∘<a class="ae mj" href="#0bdf" rel="noopener ugc nofollow">typefrompath</a><br/><a class="ae mj" href="#1915" rel="noopener ugc nofollow">💡用例</a> <br/> ∘ <a class="ae mj" href="#278a" rel="noopener ugc nofollow">翻译</a> <br/> ∘ <a class="ae mj" href="#65f9" rel="noopener ugc nofollow"> Redux选择器</a> <br/> <a class="ae mj" href="#6aac" rel="noopener ugc nofollow">👋结论</a> <br/> <a class="ae mj" href="#866a" rel="noopener ugc nofollow">🙆🏻‍♂️关于作者</a></p><h1 id="7501" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">❓的问题</h1><p id="6a12" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对于<em class="mk">对象路径</em>，我指的是一个<em class="mk">点格</em>字符串，它表示对象内部某个值的路径，例如:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="c893" class="mq kw iq mm b gy mr ms l mt mu">const object = {<br/>  a: {                     // &lt;-- 'a'<br/>    b: "My path is 'a.b'", // &lt;-- 'a.b'<br/>    c: "My path is 'a.c'", // &lt;-- 'a.c'<br/>  },<br/>  d: "My path is just 'd'" // &lt;-- 'd'<br/>}</span></pre><p id="5426" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">到<code class="fe na nb nc mm b">My path is ‘a.b’</code>的路径是<code class="fe na nb nc mm b">a.b</code>，这个对象所有可能路径的集合是:<code class="fe na nb nc mm b">'a', 'a.b', 'a.c' and ‘d’</code>。</p><p id="5d8e" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我经常需要一种方法来了解类型级对象的所有可能路径，例如，下面的例子有助于理解一个真实世界的场景，在这个场景中，了解类型级的所有可能路径可以帮助我们避免无用的情况或可能的错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f11f" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我如何知道<code class="fe na nb nc mm b"><em class="mk">homepage.header.title</em></code>路径是否存在？即使它存在，我怎么能确定它指的是一个字符串呢？</p><p id="eb15" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">当然，我可以简单地放一个<em class="mk"> if </em>语句，但是我想要更智能的<strong class="lp ir"/>、<strong class="lp ir">自动</strong>和<strong class="lp ir">类型检查</strong>！</p><p id="b27a" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我没有找到任何准备好的可以以适当的方式解决这个问题的东西，所以我决定自己来做，我会告诉你怎么做！</p><h1 id="4b40" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">✅结果</h1><p id="54d2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">下一章，我会给你一个我想出的解决方案的<strong class="lp ir">详细</strong> <strong class="lp ir">解释</strong>，但首先，我要给你看结果！— <em class="mk">如果你对解释不感兴趣，你可以在这里停下来，复制&amp;粘贴片段，你就可以开始了！</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/29a77af6f085201a7e414473c17a2b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XZK-idfauVNXMF38bZ4rUw.gif"/></div></div></figure><p id="8f36" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">引擎盖下使用的类型有:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f3aa" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">你没想到会这么复杂，是吗？<strong class="lp ir"> </strong>我也是，说实话——但是<strong class="lp ir">这样是有原因的！欲知缘由，且听下回分解。</strong></p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="4d33" class="kv kw iq bd kx ky nn la lb lc no le lf jw np jx lh jz nq ka lj kc nr kd ll lm bi translated">📝解释解决方案</h1><h2 id="762c" class="mq kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">嵌套路径</h2><p id="7d28" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们从类型<em class="mk">嵌套路径</em>开始——我不得不说<strong class="lp ir">可以用更简单的方式制作</strong>，比如这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="90e1" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">这种方法更短、更简洁，但是……这种方法有一个警告:</p><p id="04a2" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">两种解决方案都使用了<code class="fe na nb nc mm b"><a class="ae mj" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">Conditional Types</a></code>、<code class="fe na nb nc mm b"><a class="ae mj" href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html" rel="noopener ugc nofollow" target="_blank">Template Literal Types</a></code>和<code class="fe na nb nc mm b"><a class="ae mj" href="https://www.typescriptlang.org/play#example/recursive-type-references" rel="noopener ugc nofollow" target="_blank">Recursive Type Reference</a></code>——尽管有一点点但很关键的区别，这个更简单的版本不是<a class="ae mj" href="https://en.wikipedia.org/wiki/Tail_call" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">尾递归</strong> </a> <strong class="lp ir">。</strong></p><p id="a9ff" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">简而言之，一个函数(<em class="mk">或者，在这种情况下，一个类型</em>)是尾递归的<strong class="lp ir">，如果它通过返回递归调用</strong>的值而结束；<br/>在这个更简单的版本中，事实上，我们不是直接调用递归，而是在一个<em class="mk">模板文字类型</em>内调用一个<em class="mk">联合类型</em>内的递归:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3708" class="mq kw iq mm b gy mr ms l mt mu">K | `${K}.${<strong class="mm ir"><em class="mk">NestedPaths</em></strong>&lt;T[K]&gt;}`</span></pre><p id="3480" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">为什么类型是尾部递归的很重要？</p><p id="045c" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">因为Typescript对类型可以递归调用自身的次数设置了一个<strong class="lp ir">限制</strong>，如果不是尾递归的，这个限制相当小！</p><p id="678b" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><em class="mk">有多小？以前是9个，现在大概是20或50个，我不记得具体数字了，但不是很多；如果你知道，请发表评论，我会更新文章！</em></p><p id="ec0b" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">如果类型是<strong class="lp ir">尾递归</strong>而不是<strong class="lp ir">，这个限制就高多了！</strong>(<a class="ae mj" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#tail-recursion-elimination-on-conditional-types" rel="noopener ugc nofollow" target="_blank"><em class="mk">官方打字稿文档</em> </a> <em class="mk">他们只是说它“比较大方”</em>)。</p><p id="4470" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">现在一切都清楚了，让我们看看尾部递归版本。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="aff0" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><em class="mk">联合</em>和<em class="mk">连接</em>是实用程序类型，可以避免<em class="mk">字符串</em>和<em class="mk">未定义</em>之间不必要的联合或连接，并使类型更具可读性:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3bf4" class="mq kw iq mm b gy mr ms l mt mu">Union&lt;'a', 'b'&gt;;      // --&gt; 'a' | 'b'<br/>Union&lt;undefined, 'b'&gt; // --&gt; 'b'<br/>Union&lt;'a', undefined&gt; // --&gt; 'a'</span><span id="0c76" class="mq kw iq mm b gy od ms l mt mu">Join&lt;'a', 'b'&gt;        // --&gt; 'a.b'<br/>Join&lt;undefined, 'b'&gt;  // --&gt; 'b'<br/>Join&lt;'a', undefined&gt;  // --&gt; 'a'</span></pre><p id="b93a" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">知道了这一点，我将把它们从下一个代码片段中去掉，这样我们可以更好地关注<em class="mk"> NestedPaths </em>类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="040a" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">让我们通过一个例子来看看它是如何工作的:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="c08e" class="mq kw iq mm b gy mr ms l mt mu">type Paths = NestedPaths&lt;{<br/>  a: {            // &lt;-- a<br/>    b: {          // &lt;-- a.b<br/>      c: string;  // &lt;-- a.b.c<br/>    }<br/>    d: string;    // &lt;-- a.d<br/>  }<br/>}&gt;</span></pre><p id="e991" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我们预计该对象的可能路径是:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="b9d9" class="mq kw iq mm b gy mr ms l mt mu">"a" | "a.b" | "a.b.c" | "a.d"</span></pre><p id="6334" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir">第一轮</strong></p><p id="cbe8" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">在递归的第一个循环之后，这是该类型的样子:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="9c22" class="mq kw iq mm b gy mr ms l mt mu">type Paths = {<br/>  a: NestedPaths&lt;{<br/>   b: { c: string },<br/>   d: string<br/>  },  undefined, "a"&gt;<br/>}['a']</span></pre><p id="a580" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">这是因为<code class="fe na nb nc mm b">keyof T</code>在这种情况下，仅仅是<code class="fe na nb nc mm b">a</code>——对于键<code class="fe na nb nc mm b">a</code>我们有:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="c355" class="mq kw iq mm b gy mr ms l mt mu">T['a'] = { b: { c: string }, d: string }<br/>// Which means that<br/>T['a'] extends GenericObject ? <strong class="mm ir">yes</strong></span></pre><p id="e800" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我们在条件的第一个分支中，所以:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="efc8" class="mq kw iq mm b gy mr ms l mt mu">// Prev = undefined<br/>// Path = undefined</span><span id="819d" class="mq kw iq mm b gy od ms l mt mu">NestedPaths&lt;T['a'], Union&lt;Prev, Path&gt;, Join&lt;Path, 'a'&gt;&gt;</span><span id="54fa" class="mq kw iq mm b gy od ms l mt mu">// Is equal to:<br/>NestedPaths&lt;T['a'], Union&lt;undefined, undefined&gt;, Join&lt;undefined, 'a'&gt;&gt;</span><span id="d383" class="mq kw iq mm b gy od ms l mt mu">// Which is just:<br/>NestedPaths&lt;T['a'], undefined, 'a'&gt; // Prev = undefined, Path = 'a'</span></pre><p id="6db2" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir">第二轮</strong></p><p id="de59" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">在递归的第二个循环中，我们得到:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="6a9a" class="mq kw iq mm b gy mr ms l mt mu">type Paths = {<br/>  a: {<br/>   b: NestedPaths&lt;{ c: string },  "a", "a.b"&gt;,<br/>   d: "a" | "a.d",<br/>  }['b' | 'd']<br/>}['a']</span></pre><p id="46d4" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">在这个循环中，<code class="fe na nb nc mm b">keyof T</code>就是<code class="fe na nb nc mm b">b | d</code>。<br/>对于子对象<code class="fe na nb nc mm b">a</code>下的关键点<code class="fe na nb nc mm b">b</code>，我们可以重复之前的相同过程(我们在条件的第一个分支:<code class="fe na nb nc mm b">T['b'] extends GenericObject</code>)；<br/>对于键<code class="fe na nb nc mm b">d</code>相反，条件<code class="fe na nb nc mm b">T['d'] extends GenericObject</code>为<strong class="lp ir">假</strong>，所以我们有:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="5dd3" class="mq kw iq mm b gy mr ms l mt mu">// Prev = undefined<br/>// Path = 'a'</span><span id="a716" class="mq kw iq mm b gy od ms l mt mu">d: Union&lt;Union&lt;Prev, Path&gt;, Join&lt;Path, 'd'&gt;&gt;;</span><span id="8214" class="mq kw iq mm b gy od ms l mt mu">d: Union&lt;Union&lt;undefined, 'a'&gt;, Join&lt;'a', 'd'&gt;&gt;;</span><span id="4b65" class="mq kw iq mm b gy od ms l mt mu">d: Union&lt;'a', 'a.d'&gt; --&gt; 'a' | 'a.d'</span></pre><p id="9538" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir">第三轮</strong></p><p id="bbb9" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">现在事情开始变得有趣了…我们基本上拥有了所需的一切:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="ad07" class="mq kw iq mm b gy mr ms l mt mu">type Paths = {<br/>  a: {<br/>   b: { c: "a" | "a.b" | "a.b.c" }["c"],<br/>   d: "a" | "a.d",<br/>  }['b' | 'd']<br/>}['a']</span></pre><p id="d0ff" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><code class="fe na nb nc mm b">b</code>下的<code class="fe na nb nc mm b">c</code>键是这样解析的:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="8b77" class="mq kw iq mm b gy mr ms l mt mu">c: T['c'] extends GenericObject ? nope!</span><span id="bf5b" class="mq kw iq mm b gy od ms l mt mu">c: Union&lt;Union&lt;Prev, Path&gt;, Join&lt;Path, 'c'&gt;&gt;</span><span id="9d0a" class="mq kw iq mm b gy od ms l mt mu">// Where:<br/>// Prev = 'a'<br/>// Path = 'a.b'</span><span id="7d9e" class="mq kw iq mm b gy od ms l mt mu">c: Union&lt;Union&lt;'a', 'a.b'&gt;, Join&lt;'a.b', 'c'&gt;&gt;<br/>c: Union&lt;'a' | 'a.b', 'a.b.c'&gt;<br/>c: 'a' | 'a.b' | 'a.b.c'</span></pre><p id="2e14" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir">终于</strong></p><p id="6bc0" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">递归完成后，我们只需以不同的方式编写类型:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="cf63" class="mq kw iq mm b gy mr ms l mt mu">type Paths = {<br/>  a: {<br/>   b: { c: "a" | "a.b" | "a.b.c" }["c"],<br/>   d: "a" | "a.d",<br/>  }['b' | 'd']<br/>}['a']</span><span id="4594" class="mq kw iq mm b gy od ms l mt mu">// Is equal to:<br/>type Paths = {<br/>  a: {<br/>   b: "a" | "a.b" | "a.b.c",<br/>   d: "a" | "a.d",<br/>  }["b" | "d"]<br/>}['a']</span><span id="cad5" class="mq kw iq mm b gy od ms l mt mu">// Which is also equal to:<br/>type Paths = {<br/>  a: "a" | "a.b" | "a.b.c" | "a.d"<br/>}["a"]</span><span id="c2ca" class="mq kw iq mm b gy od ms l mt mu">// 🎉 Which is just what we expected 🎉:<br/>type Paths = "a" | "a.b" | "a.b.c" | "a.d"</span></pre><p id="b12e" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">使用类型<em class="mk"> NestedPaths，</em>我们可以获得任何对象的所有路径！</p><p id="a651" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">…但这只是我想解决的第一个问题！</p><h2 id="0bdf" class="mq kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">TypeFromPath</h2><p id="88a3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">事实上，除了获取一个对象的所有路径，我还想找到一种方法来获取这些路径引用的类型，我是这样做的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ef1b" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">让我们通过一个具体的例子来看看这种类型是如何工作的:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3579" class="mq kw iq mm b gy mr ms l mt mu">type Result = TypeFromPath&lt;{<br/>  <strong class="mm ir">a</strong>: {<br/>    <strong class="mm ir">b</strong>: {<br/>      <strong class="mm ir">c</strong>: { foo: 'bar' }; // &lt;-- 'a.b.c'<br/>    }<br/>    d: string;<br/>  }<br/>// We are asking for the type referred by the path 'a.b.c'<br/>}, <strong class="mm ir">'a.b.c'</strong>&gt;</span></pre><p id="82e6" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我们预计<code class="fe na nb nc mm b">type Result</code>将等于<code class="fe na nb nc mm b">{ foo: 'bar' }</code>。</p><p id="91d9" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir">第一轮</strong></p><p id="d55d" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">这是我们在第一轮递归中得到的结果:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="11fb" class="mq kw iq mm b gy mr ms l mt mu">type Result = {<br/> 'a.b.c': <em class="mk">TypeFromPath</em>&lt;{<br/>    b: {<br/>     c: { foo: 'bar' };<br/>    }<br/>    d: string;<br/>  }, 'b.c'&gt;<br/>}['a.b.c']</span></pre><p id="b156" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">让我们看看发生了什么:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="ea85" class="mq kw iq mm b gy mr ms l mt mu">// The generic type Path is equal to 'a.b.c' so<br/>// Path = 'a.b.c'</span><span id="0a5e" class="mq kw iq mm b gy od ms l mt mu">{<br/>  [K in Path]: ???<br/>}[Path]</span><span id="9295" class="mq kw iq mm b gy od ms l mt mu">// Is just<br/>{<br/> [K in 'a.b.c']: ???<br/>}['a.b.c']</span></pre><p id="5ff9" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我们有什么来代替<code class="fe na nb nc mm b">???</code>？<br/>知道<code class="fe na nb nc mm b">K</code>等于<em class="mk">‘a . b . c’，</em>我们有:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="846b" class="mq kw iq mm b gy mr ms l mt mu">// T = { a: { ... }, d: string }<br/>// Does <em class="mk">K</em> extends keyof <em class="mk">T</em>?<br/>// No it doesn't, the keys of T are '<em class="mk">a</em>' and '<em class="mk">d</em>' and <em class="mk">K</em> is '<em class="mk">a.b.c</em>'<br/>// so we are in the second branch of the condition</span><span id="3208" class="mq kw iq mm b gy od ms l mt mu">{<br/> [K in 'a.b.c']: K extends `${infer P}.${infer S}` ? TypeFromPath&lt;T[P], S&gt; : never<br/>}['a.b.c']</span></pre><p id="c6eb" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir"> <em class="mk"> K延伸什么` ${infer P}。${infer S}` </em> </strong>是什么意思？<br/>我们询问Typescript是否<em class="mk"> `a.b.c` </em>扩展了一个类似于<code class="fe na nb nc mm b">{Prefix}.{Suffix}</code>的字符串；<br/>在我们的例子中是<strong class="lp ir">真</strong>，事实上，K是` a.b.c `,我们可以把` a.b.c `看成<code class="fe na nb nc mm b">${'a'}.${'b.c'}</code>。</p><p id="cb6e" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">所以，最后，我们得到了:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="18d2" class="mq kw iq mm b gy mr ms l mt mu">{<br/> ['a.b.c']: TypeFromPath&lt;T['a'], 'b.c'&gt;;<br/>}['a.b.c']</span></pre><p id="c042" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir">第二轮</strong></p><p id="227e" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">在递归的第二个循环中，我们得到:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="ee32" class="mq kw iq mm b gy mr ms l mt mu">type Result = {<br/> 'a.b.c': {<br/>   'b.c': <em class="mk">TypeFromPath</em>&lt;{<br/>      c: { foo: 'bar' };<br/>   }, 'c'&gt;<br/> }['b.c']<br/>}['a.b.c'];</span></pre><p id="36d0" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">在这个周期中，我们拥有的东西与之前基本相同，因此:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3679" class="mq kw iq mm b gy mr ms l mt mu">// Path = 'b.c'<br/>// T = { b: { c: { foo: 'bar' } } }; </span><span id="8305" class="mq kw iq mm b gy od ms l mt mu">{<br/>  [K in 'b.c']: TypeFromPath&lt;T['b'], 'c'&gt;;<br/>}['b.c']</span><span id="b69c" class="mq kw iq mm b gy od ms l mt mu">// All together:<br/>{<br/>  ['a.b.c']: {<br/>    ['b.c']: TypeFromPath&lt;T['b'], 'c'&gt;;<br/>  }['b.c']<br/>}['a.b.c']</span></pre><p id="7e81" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir">第三轮</strong></p><p id="ff87" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">这里我们终于有了不同的东西:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="000d" class="mq kw iq mm b gy mr ms l mt mu">type Result = {<br/> 'a.b.c': {<br/>   'b.c': {<br/>      c: { foo: 'bar' };<br/>   }['c']<br/> }['b.c']<br/>}['a.b.c'];</span></pre><p id="9df8" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我们是这样得到它的:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="d494" class="mq kw iq mm b gy mr ms l mt mu">// Path = 'c'<br/>// T = { c: { foo: 'bar' } };</span><span id="9699" class="mq kw iq mm b gy od ms l mt mu">{<br/>  [K in 'c']: K extends keyof T ? <strong class="mm ir">yes!</strong><br/>}['b.c']</span><span id="6899" class="mq kw iq mm b gy od ms l mt mu">{<br/>  [K in 'c']: T['c'] --&gt; { foo: 'bar' }<br/>}</span><span id="08bf" class="mq kw iq mm b gy od ms l mt mu">// All together:<br/>{<br/>  ['a.b.c']: {<br/>    ['b.c']: {<br/>      ['c']: { foo: 'bar' }<br/>    }['c]<br/>  }['b.c']<br/>}['a.b.c']</span></pre><p id="5ce2" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><strong class="lp ir">第四轮</strong></p><p id="40b5" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我们现在已经拥有了获取“a.b.c”所引用的类型所需的一切:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="ced1" class="mq kw iq mm b gy mr ms l mt mu">type Result = {<br/> 'a.b.c': {<br/>   'b.c': { foo: 'bar' };<br/> }['b.c']<br/>}['a.b.c'];</span><span id="f8df" class="mq kw iq mm b gy od ms l mt mu"><strong class="mm ir">// Which is equal to</strong><br/>type Result = {<br/> 'a.b.c': { foo: 'bar' };<br/>}['a.b.c'];</span><span id="e839" class="mq kw iq mm b gy od ms l mt mu"><strong class="mm ir">// And finally</strong><br/>type Result = { foo: 'bar' };</span></pre><p id="2303" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">正如我们所料，<code class="fe na nb nc mm b">type Result = { foo: 'bar' };</code>！</p><h1 id="1915" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">💡用例</h1><p id="40d3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我认为这些类型在不同的场景中都很有用，例如，<strong class="lp ir">翻译</strong>和<strong class="lp ir">冗余选择器</strong>:</p><h2 id="278a" class="mq kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">翻译</h2><p id="12ef" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通常，我们将翻译存储在如下所示的对象中:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="0e08" class="mq kw iq mm b gy mr ms l mt mu">const translations = {<br/>  homePage: {<br/>    title: 'Hello!',<br/>    ...,<br/>  },<br/>  profilePage: {<br/>    menu: {<br/>      settings: 'Settings',<br/>      ...,<br/>    },<br/>  },<br/>  ...,<br/>}</span></pre><p id="3650" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">然后我们通常通过一个钩子来使用这个对象，比如下面的<code class="fe na nb nc mm b">useTranslations</code>，它返回<code class="fe na nb nc mm b">t</code>函数——这个函数以一个路径作为参数，并返回相应的翻译:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="8373" class="mq kw iq mm b gy mr ms l mt mu">const HomePageTitle = () =&gt; {<br/>  const { t } = useTranslation();<br/>  <br/>  return &lt;h1&gt;{t('homePage.title')}&lt;/h1&gt;;<br/>}</span></pre><p id="f412" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">这是大多数i18n库的工作方式，例如<code class="fe na nb nc mm b">i18next</code> ( <code class="fe na nb nc mm b">react-i18next</code>)或<code class="fe na nb nc mm b">react-intl</code>。</p><p id="d1e6" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">我们可以将<code class="fe na nb nc mm b">useTranslation</code>包装到一个自定义钩子中，并使用类型<em class="mk"> NestedPaths </em>和<em class="mk"> TypeFromPath </em>来正确地对传递给<em class="mk"> t函数的路径进行类型检查:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">useTranslations custom hook</figcaption></figure><p id="8237" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">就这样，通过使用这个新的钩子，我们将<strong class="lp ir">始终</strong>确保传递给t函数的路径是translations对象的<strong class="lp ir">有效路径</strong>，并且返回的类型是一个字符串:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="5a70" class="mq kw iq mm b gy mr ms l mt mu">const <strong class="mm ir"><em class="mk">HomePageTitle</em></strong> = () =&gt; {<br/>  const { t } = useTranslation();<br/>  <br/>  // Looks good<br/>  return &lt;h1&gt;{t('homePage.title')}&lt;/h1&gt;;<br/>}</span><span id="a52b" class="mq kw iq mm b gy od ms l mt mu">const <strong class="mm ir"><em class="mk">WrongHomePageTitle</em></strong> = () =&gt; {<br/>  const { t } = useTranslation();<br/>  <br/>  // We will have an error saying that <strong class="mm ir">homePage.wrongPath</strong><br/>  // is not a valid path<br/>  return &lt;h1&gt;{t('homePage.wrongPath')}&lt;/h1&gt;;<br/>}</span><span id="958e" class="mq kw iq mm b gy od ms l mt mu">const <strong class="mm ir"><em class="mk">AnotherWrongHomePageTitle</em></strong> = () =&gt; {<br/>  const { t } = useTranslation();<br/>  <br/>  // We will have an error saying that <strong class="mm ir">t('homePage')</strong><br/>  // is not a valid React child (<em class="mk">because is an object</em>)<br/>  return &lt;h1&gt;{t('homePage')}&lt;/h1&gt;;<br/>}</span></pre><h2 id="65f9" class="mq kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">冗余选择器</h2><p id="df84" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">另一个很好的用例是将这些类型与<code class="fe na nb nc mm b">react-redux</code>的钩子<code class="fe na nb nc mm b">useSelector</code>结合起来，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">usePathSelector custom hook</figcaption></figure><h1 id="6aac" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">👋结论</h1><p id="0a7d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">感谢你阅读这篇文章，我希望它对你有用。我对构建这些类型的其他方法很感兴趣，如果你知道其中一些，或者你认为它们可以改进，请留言告诉我你会怎么做。</p><h1 id="866a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">🙆🏻‍♂️关于作者</h1><p id="b8ef" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我是<a class="ae mj" href="https://www.linkedin.com/company/vlk-studio/?source=about_page----------------------------------------" rel="noopener ugc nofollow" target="_blank"> VLK工作室</a>的一名软件工程师，目前正在从事一个名为<a class="ae mj" href="https://morfeo.dev/?source=about_page----------------------------------------" rel="noopener ugc nofollow" target="_blank"> Morfeo的开源项目。</a></p><p id="5578" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">只要我能，我就在媒体上分享一些我知道的东西。</p><p id="85f9" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated">如果你喜欢我做的事情，请随时支持我的工作:<a class="ae mj" href="https://medium.com/@mauro.erta/membership?source=about_page----------------------------------------" rel="noopener">https://medium.com/@mauro.erta/membership</a></p><p id="9f31" class="pw-post-body-paragraph ln lo iq lp b lq mv jr ls lt mw ju lv lw mx ly lz ma my mc md me mz mg mh mi ij bi translated"><em class="mk">更多内容请看</em><a class="ae mj" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="mk">plain English . io</em></strong></a><em class="mk">。报名参加我们的</em> <a class="ae mj" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="mk">免费周报</em> </strong> </a> <em class="mk">。关注我们关于</em><a class="ae mj" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="mk">Twitter</em></strong></a><em class="mk">和</em><a class="ae mj" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="mk">LinkedIn</em></strong></a><em class="mk">。加入我们的</em> <a class="ae mj" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="mk">社区不和谐</em> </strong> </a> <em class="mk">。</em></p></div></div>    
</body>
</html>