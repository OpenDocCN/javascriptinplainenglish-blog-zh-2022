<html>
<head>
<title>What I Don’t Like About Node.js 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我不喜欢Node.js 18的地方</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/critic-on-node-18-3eda9e1a7644?source=collection_archive---------1-----------------------#2022-04-27">https://javascript.plainenglish.io/critic-on-node-18-3eda9e1a7644?source=collection_archive---------1-----------------------#2022-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="acf0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Node.js 18让我想起了Deno</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0fd5818cd8c1b4b88ed51ba06d033941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTVVQUW71CNf2ySo5h45zA.png"/></div></div></figure><p id="00ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Node.js 18于2022年4月19日发布。与前两个版本不同，Node.js 18提供了令人兴奋的创新，并展示了Node.js未来的发展方向。</p><h1 id="4a68" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">获取API</h1><p id="71a2" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Node.js 18的第一个重大变化是对Fetch API的原生支持。Node因此接收到一个<strong class="kt ir">标准化的HTTP客户端</strong>，这是我们已经从浏览器中知道的。</p><p id="f1b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能认为我们不再需要Axios或Request之类的外部模块了，但乍一看并非如此，因为Fetch API是基于NPM模块<a class="ae mk" href="https://www.npmjs.com/package/undici" rel="noopener ugc nofollow" target="_blank"> undici </a>的。这个模块<strong class="kt ir">既不支持HTTP 2也不支持HTTP 3。而不是</strong>，完全依赖<strong class="kt ir"> HTTP 1.1 only </strong>。</p><p id="fd68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到HTTP 2如今的流行程度，这有点令人失望。然而，您现在已经可以使用Fetch API了。但是你必须没有HTTP 2和HTTP 3的支持。</p><h1 id="1c6a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">网络流</h1><p id="18c9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">任何与Fetch API打过交道的人都知道，从服务器收到的响应不仅可以作为JSON或文本处理，还可以作为流处理。流是众多用例中的一个基本特性，因为流使您能够解析和处理响应，即使响应还没有完全加载。</p><p id="b57a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然Node.js一直都知道流，但是您可以认为流是开箱即用的。但是Fetch API不使用内置的流。他们使用为浏览器设计的网络流。这并不奇怪，因为Fetch API也来自浏览器。</p><p id="0b6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Web流与Node.js中的经典流做的一样，但是它们在技术上的结构不同。所以说，从技术角度来看，它们的工作方式有点不同。这意味着Node.js现在支持web流和我们已经知道的经典流。</p><p id="d615" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不确定我是否应该喜欢这样。实现经典流已经是在Node.js中正确实现流的第三次尝试。而网络流现在是第<strong class="kt ir">次尝试</strong>。</p><p id="5d47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在有两个根本不同的可读流，可写流和转换流。web流中不再存在双工流，我能理解这一点，因为双工流在Node.js中没有意义。但是所有其他类型的流现在都是重复的。</p><p id="ede0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这并不坏，但是它<strong class="kt ir">促进了Node.js开发者之间的不一致性</strong>，这是我经常批评的。这种促进的不一致性是我最近写了一篇关于为什么我更喜欢使用TypeScript或Node.js的文章的根本原因。</p><div class="ml mm gp gr mn mo"><a href="https://levelup.gitconnected.com/why-did-i-move-from-typescript-to-go-1d9f92ef882a" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">为什么我从打字稿转向Go</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">以及为什么我不会放弃使用TypeScript</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc kp mo"/></div></div></a></div><p id="fc02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从这样的特性可以看出Node.js不再是新的了，但它仍在不断发展。进一步发展，向标准靠拢，首先是一件积极的事情。但是如果标准本身没有被成功实施，整个事情就会变得有问题。</p><p id="4e7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们谈论的是一种不一定是好的进一步发展，而是一种从更坏的情况开始的改善。Fetch API和web流就是最好的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/d27f464e992f761470d2300e851a558f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Jn1QSSsTLM8fMtuaZyxBQ.jpeg"/></div></div></figure><h1 id="0c62" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">全局名称空间</h1><p id="4de0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这些新的API和特性将如何在Node中可用？在这种情况下，大概是出于与浏览器兼容的原因，我们决定采用我认为最糟糕的方法。这些新特性使<strong class="kt ir">成为全局变量。</strong></p><p id="d304" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着你不需要使用关键字如"<em class="ne">要求"</em>或"<em class="ne">导入"</em>来导入它们，你可以像这样调用Fetch API。</p><p id="5eb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">起初，<strong class="kt ir">您可能认为这可能非常实用</strong>，是的，这也是我最初的想法，但是这幅图的另一面是全局名称空间已经变得越来越杂乱。这在浏览器和Node中都不是一个好主意，尤其是因为它发生在Node <strong class="kt ir">而不需要任何</strong>。</p><p id="c1a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">过去，除了全局名称空间之外，浏览器中几乎没有其他选择，因为导入模块需要很长时间才能出现。但这个问题或需求在Node中并不存在。所以我想知道为什么Node必须将这些特性作为全局变量，因此<strong class="kt ir">保留了24个额外的变量名。</strong></p><p id="03b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有“ReadableStreamDefaultReader”等不常见的名称，也有“Request”、“Response”、“Headers”、“Blob”等日常用语。</p><p id="7f50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">底线是，我认为给这样的关键术语分配全局标识符是一个糟糕的想法，这已经在许多应用程序中使用了。在这个版本中，这些变量名被阻止，这意味着随着Node.js 18的升级，您将在多达24种不同的情况下出现<strong class="kt ir">冲突。</strong></p><p id="29a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不认为随机分配全局变量是个好主意。所有这些都归功于Node和web浏览器之间的兼容性，但Node不是web浏览器。为Node和web浏览器编写的99%的代码从来不会在其他平台上执行。</p><p id="ca76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这方面，肯定会有更好的解决方案，特别是因为，正如我所说，在浏览器中这不是一个好主意，但当时没有替代方案，它是出于需要而产生的，Node不是这种情况。</p><p id="3c08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的印象是<strong class="kt ir">节点与这里的Deno非常接近</strong>,因为Deno做了我刚刚批评过的事情。下一个特征也能观察到同样的效果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/5aa848c5ef89bca6f1fb415891443acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*PpJyapD86TaWkplOfQvT0Q.jpeg"/></div></figure><h1 id="ae51" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">测试框架</h1><p id="0e63" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Node.js 18的一个亮点是能够<strong class="kt ir">编写开箱即用的测试</strong>。首先，这是一个很好的特性，因为你摆脱了像Jest或Mocha这样的外部依赖。这个模块的名字叫做“测试”。这个API带来了许多有前途的创新。</p><p id="11f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以定义同步和异步测试。测试可以随意嵌套，可以跳过测试，可以并行运行测试，等等。</p><p id="ee90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以测试API附带了一些<strong class="kt ir">有用的特性</strong>，结合“assert”或者“assert/strict”模块，你真的<strong class="kt ir">在大多数情况下不需要依赖Jest </strong>。因此，我很好奇Jest、Mocha和其他人从长远来看将如何定位自己。</p><p id="2850" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是现在我们说到重点了<strong class="kt ir">我不明白</strong>。出于安全原因，Node中有一条规则，规定节点模块总是在同名的NPM模块之上加载。这条规则非常有道理。毕竟，Node一直受到NPM模块损坏的困扰。</p><p id="130d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为NPM模块的开发人员，您应该避免像Node自带的模块那样命名您的模块，因为那样您就无法加载这些NPM模块。</p><p id="3a4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，像“测试”这样的名字，它是预先编程的，在NPM上已经有一个同名的模块。快速浏览一下NPM <a class="ae mk" href="https://www.npmjs.com/package/test" rel="noopener ugc nofollow" target="_blank">可以确认</a>这个模块已经存在，但是<strong class="kt ir">已经将近十年没有收到更新了。</strong></p><p id="eb98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，您可以假设这个模块没有得到很好的维护，并且您可能认为如果您创建一个同名的集成节点模块，您不会破坏太多，因为这个NPM模块<strong class="kt ir">既没有广泛传播也没有得到很好的维护。</strong></p><p id="68ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，Node在这里采用了不同的方法。为了不与此NPM模块发生冲突，您不能用“test”加载节点测试模块。而是需要用节点协议导入，比如“node:test”。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="1c99" class="nl lo iq nh b gy nm nn l no np">import * from 'node:test'</span></pre><p id="38bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不理解这种方式。通过获取API和web流，Node创建了一个与24个变量名的<strong class="kt ir">冲突，您将来会阻止它，但是对于一个<strong class="kt ir">在10年</strong>内没有收到更新的模块，Node继续一个<strong class="kt ir">不一致的方式</strong>来创建不一致？</strong></p><p id="c4f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，从长远来看，指定一个协议来加载节点模块是有意义的。如果导入是在其他环境中加载的，则不能保证特定于节点的实现。因此，总是必须指定一个协议是有意义的，我怀疑将来也会是这样。</p><p id="6c54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但目前是不一致的，或者说这里故意打破了一致性。</p><h1 id="74c2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">JSON导入断言</h1><p id="9b2a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Node.js 18带来了所谓的JSON导入断言。这使得通过附加参数显式标记JSON文件导入成为可能。当加载文件时，Node可以检查它是否是一个JSON文件，而不是一个可执行代码，这可能会导致损坏。</p><p id="7d44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这弥补了潜在的安全漏洞。当考虑该版本的下一个功能(HTTPS进口)时，该功能的重要性会增加。</p><h1 id="443c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">HTTPS进口</h1><p id="0a43" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">以前，NPM模块只能从本地文件系统加载。有了Node.js 18，现在实验上有可能通过HTTPS在运行时<strong class="kt ir">加载NPM模块。</strong></p><p id="19c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是似乎受Deno启发的下一个功能，因为<strong class="kt ir"> Deno将该功能作为一项杰出的成就</strong>出售，不依赖于NPM这样的中央注册中心。</p><p id="dcb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实际上，这是否是个好主意还有待观察。试想一下检查导入模块的更新，这变得非常困难，最重要的是，如果没有来自中央注册中心的标准版本号，这将是不一致的。</p><p id="da14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，你可以争辩说Github标签可以用于此，但不是每个模块都在Github上。有些存储在Gitlab或Bitbucket等替代服务上。</p><h1 id="48b3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">摘要</h1><p id="a95b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我有点怀疑Node的发展方向。当然，乍一看，这些功能看起来很棒。但这些功能到底好不好，还有待观察。</p><p id="52ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为这些功能很多都让人想起了Deno，如果我想和Deno合作，我会和Deno合作。但是，我有意识地决定反对Deno，支持Node。我最不希望Node变成Deno的复制品。</p><p id="8281" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Node.js如何发展还有待观察，<strong class="kt ir">不要误会。我认为Node.js不断发展而不是停滞不前，这很好。但是我不知道我是否像现在这样喜欢这个发展的方向。</strong></p><p id="7f9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您阅读我关于Node.js 18的文章。关注更多。</p><p id="11bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干杯！</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="539a" class="ln lo iq bd lp lq nx ls lt lu ny lw lx jw nz jx lz jz oa ka mb kc ob kd md me bi translated">接下来阅读</h1><div class="ml mm gp gr mn mo"><a href="https://levelup.gitconnected.com/why-did-i-move-from-typescript-to-go-1d9f92ef882a" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">为什么我从打字稿转向Go</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">以及为什么我不会放弃使用TypeScript</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc kp mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a rel="noopener  ugc nofollow" target="_blank" href="/why-javascript-is-weird-eff1b4953579"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">JavaScript之所以怪异</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">JavaScript的历史</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mx l"><div class="oc l mz na nb mx nc kp mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://blog.bitsrc.io/node-js-event-loop-and-multi-threading-e42e5fd16a77" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">NodeJS &amp;事件循环:不是单线程的</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">Node.js、事件循环和多线程</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">blog.bitsrc.io</p></div></div><div class="mx l"><div class="od l mz na nb mx nc kp mo"/></div></div></a></div><p id="470f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ne">更多内容看</em> <strong class="kt ir"> <em class="ne"> </em> </strong> <a class="ae mk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ne">说白了. io </em> </strong> </a> <em class="ne">。报名参加我们的</em> <a class="ae mk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ne">免费周报</em> </strong> </a> <em class="ne">。关注我们关于</em><a class="ae mk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ne">Twitter</em></strong></a><em class="ne">和</em><a class="ae mk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ne">LinkedIn</em></strong></a><em class="ne">。加入我们的</em> <a class="ae mk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ne">社区</em> </strong> </a> <em class="ne">。</em></p></div></div>    
</body>
</html>