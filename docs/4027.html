<html>
<head>
<title>The Proxy API Is So Powerful That Every Web Developer Should Master It!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代理API如此强大，每个Web开发人员都应该掌握它！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-proxy-api-is-so-powerful-that-every-web-developer-should-master-it-9bdc71a4032c?source=collection_archive---------1-----------------------#2022-10-19">https://javascript.plainenglish.io/the-proxy-api-is-so-powerful-that-every-web-developer-should-master-it-9bdc71a4032c?source=collection_archive---------1-----------------------#2022-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="be1a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">80%的Web开发人员不应该知道的代理API的8个主要使用场景！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9ab35f27e5e180d69eee17a709fb25b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*51rQnAktqnhMl3nH"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@acharki95?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aziz Acharki</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="86d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a> API非常强大，非常有用。<strong class="ky ir">在本文中，我将介绍它的8种使用场景</strong>。</p><p id="6845" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在日常工作中，我相信很多开发者都使用过Web调试代理工具，比如Fiddler或者Charles。通过使用web调试代理工具，我们可以拦截HTTP/HTTPS协议请求，并手动修改请求参数和响应结果。不仅如此，在调试在线问题时，使用Web调试代理工具，<strong class="ky ir">还可以将在线压缩和混淆的JavaScript文件映射到本地未压缩和混淆的JavaScript文件</strong>。</p><p id="06d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在简单介绍了Web调试代理工具的基本功能之后，我们来看看使用Web调试代理工具的HTTP请求流程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/bb3c27ac92aacea31c52f0c16a2d1fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrFHdkiN2RkFo9qfG39Q3w.png"/></div></div></figure><p id="e7dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上图可以看出，使用Web代理工具后，我们发起的HTTP请求会通过Web代理进行转发和处理。Web Proxy代理层的增加使我们能够更好地控制HTTP请求流。对于单页面应用，从服务器获取数据后，我们会读取相应的数据并显示在页面上:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/5871e3009ec10d531bff08ac31ad0e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfEhlSxfikEZvXV6MdGSHw.png"/></div></div></figure><p id="570c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述过程类似于浏览器直接从服务器获取数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/0dbe99449673dfb76a0521e994095a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu9tJxNILq0DVWzeLqUhrQ.png"/></div></div></figure><p id="69fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了能够灵活地控制HTTP请求流，我们添加了一个Web代理层。那么我们能控制数据对象的读取过程吗？答案是肯定的，我们可以使用像<code class="fe lv lw lx ly b">Object.defineProperty</code>或者<code class="fe lv lw lx ly b">Proxy</code> API这样的Web API。引入Web API后，数据访问流程如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/caca5c3a6719188cd44dff2f72d502be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUSIx7zHYJ1t8VLC8qxjFg.png"/></div></div></figure><p id="15d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我将关注<code class="fe lv lw lx ly b">Proxy</code> API，它是Vue3实现data reactive背后的“英雄”。</p><h1 id="5256" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">1.代理对象简介</h1><p id="e6d9" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe lv lw lx ly b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">Proxy</a></code>对象用于创建对象的代理，实现基本操作(如属性查找、赋值、枚举、函数调用等)的拦截和定制。).</p><p id="84f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lv lw lx ly b">Proxy</code>的构造函数语法是:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="8d00" class="nb mb iq ly b gy nc nd l ne nf">const p = new Proxy(target, handler)</span></pre><ul class=""><li id="395d" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated"><code class="fe lv lw lx ly b">target</code>:要用代理包装的目标对象(可以是任何类型的对象，包括原生数组、函数，甚至是另一个代理)。</li><li id="6993" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe lv lw lx ly b">handler</code>:定义哪些操作将被拦截，以及如何重新定义被拦截的操作的对象。</li></ul><p id="9b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">介绍完代理构造函数之后，我们来看一个简单的例子:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="149d" class="nb mb iq ly b gy nc nd l ne nf">const man = {<br/>  name: "Bytefer",<br/>};</span><span id="c0be" class="nb mb iq ly b gy nu nd l ne nf">const proxy = new Proxy(man, {<br/>  get(target, property, receiver) {<br/>    console.log(`Accessing the ${property} property`);<br/>    return target[property];<br/>  },<br/>});</span><span id="877a" class="nb mb iq ly b gy nu nd l ne nf">console.log(proxy.name);<br/>console.log(proxy.age);</span></pre><p id="d741" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们使用了<code class="fe lv lw lx ly b">Proxy</code>构造函数为<code class="fe lv lw lx ly b">man</code>对象创建一个代理对象。<strong class="ky ir">在创建代理对象时，我们定义一个get陷阱来捕获属性读取操作。</strong>陷阱的作用是拦截用户对目标对象的相关操作。在这些操作传播到目标对象之前，会先调用相应的trap函数，从而拦截和修改相应的行为。</p><p id="f474" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述代码成功执行后，将输出以下结果:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="fad9" class="nb mb iq ly b gy nc nd l ne nf">Accessing the name property<br/>Bytefer<br/>Accessing the age property<br/>undefined</span></pre><p id="b4c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于上面的输出结果，我们可以发现get trap不仅可以拦截已知属性的读操作，还可以拦截未知属性的读操作。创建<code class="fe lv lw lx ly b">Proxy</code>对象时，除了定义get陷阱，我们还可以定义其他陷阱，比如<code class="fe lv lw lx ly b">has</code>、<code class="fe lv lw lx ly b">set</code>、<code class="fe lv lw lx ly b">delete</code>、<code class="fe lv lw lx ly b">apply</code>或<code class="fe lv lw lx ly b">ownKeys</code>等。</p><p id="6815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">handler对象支持13种陷阱，这里我只列出以下5种常用的陷阱:</p><ul class=""><li id="3f31" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated"><code class="fe lv lw lx ly b">handler.get</code>:是获取属性值的陷阱。</li><li id="d913" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe lv lw lx ly b">handler.set</code>:设置属性值的陷阱。</li><li id="1288" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe lv lw lx ly b">handler.has</code>:是<code class="fe lv lw lx ly b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in" rel="noopener ugc nofollow" target="_blank">in</a></code>操作符的陷阱。</li><li id="7b04" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe lv lw lx ly b">handler.deleteProperty</code>:删除操作符的陷阱。</li><li id="3878" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe lv lw lx ly b">handler.ownKeys</code>:是<code class="fe lv lw lx ly b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys" rel="noopener ugc nofollow" target="_blank">Reflect.ownKeys()</a></code>的陷阱。</li></ul><p id="666a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，所有陷阱都是可选的。如果没有定义陷印，将保留源对象的默认行为。看了上面陷阱的介绍，是不是觉得<code class="fe lv lw lx ly b">Proxy</code> API很厉害？</p><h1 id="0c36" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">2.代理API使用场景</h1><h2 id="3344" class="nb mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">2.1增强阵列</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="557f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，除了使用代理API，我们还使用了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" rel="noopener ugc nofollow" target="_blank">反射</a> API。一旦我们有了<code class="fe lv lw lx ly b">enhancedArray</code>函数，我们可以这样使用它:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="9721" class="nb mb iq ly b gy nc nd l ne nf">const arr = enhancedArray([10, 6, 8, 5, 2]);</span><span id="5c8b" class="nb mb iq ly b gy nu nd l ne nf">console.log(arr[-1]); // 2<br/>console.log(arr[[2, 4]]); // [ 8, 2 ]<br/>console.log(arr[[2, -2, 1]]); // [ 8, 5, 6 ]<br/>console.log(arr["2:4"]); // [ 8, 5 ]<br/>console.log(arr["-2:3"]); // [ 5, 2, 10, 6, 8 ]</span></pre><p id="24a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的输出结果可以看出，增强的数组对象可以支持<strong class="ky ir">负索引和碎片索引</strong>等函数。除了增强数组，我们还可以使用<code class="fe lv lw lx ly b">Proxy</code> API增强普通对象。</p><h2 id="8b16" class="nb mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">2.2增强对象</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="f2ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了<code class="fe lv lw lx ly b">enhancedObject</code>函数，我们可以这样使用它:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="cb99" class="nb mb iq ly b gy nc nd l ne nf">const data = enhancedObject({<br/>  user: {<br/>    name: "Bytefer",<br/>    settings: {<br/>      theme: "light",<br/>    },<br/>  },<br/>});</span><span id="8e77" class="nb mb iq ly b gy nu nd l ne nf">console.log(data.user.settings.theme); // light<br/>console.log(data.theme); // light<br/>console.log(data.address); // null</span></pre><p id="8918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的输出结果可以看出，通过使用<code class="fe lv lw lx ly b">enhancedObject</code>函数处理的对象，我们可以很容易地访问普通对象内部的深层属性。</p><h2 id="354b" class="nb mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">2.3冻结对象</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="6c0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义冻结功能后，让我们测试它的功能:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="3d2d" class="nb mb iq ly b gy nc nd l ne nf">console.log(freezedMan.name); // Bytefer<br/>freezedMan.name = "Lolo"; <br/>delete freezedMan.man; <br/>freezedMan.age = 30;<br/>console.log(freezedMan); // { name: 'Bytefer' }</span></pre><h2 id="ceaf" class="nb mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">2.4跟踪方法调用</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="febc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过<code class="fe lv lw lx ly b">traceMethodCall</code>函数，我们可以用它来跟踪指定对象的方法调用:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="7f05" class="nb mb iq ly b gy nc nd l ne nf">const man = {<br/>  name: "Bytefer",<br/>  say(msg) {<br/>    return `${this.name} says: ${msg}`;<br/>  },<br/>};</span><span id="8ca1" class="nb mb iq ly b gy nu nd l ne nf">const tracedObj = traceMethodCall(man);<br/>tracedObj.say("Hello Proxy API"); <br/>// Call say method -&gt; "Bytefer says: Hello Proxy API"</span></pre><p id="4dca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，除了能够跟踪方法调用，我们还可以跟踪对object中属性的访问。</p><h2 id="396b" class="nb mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">2.5跟踪属性访问</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8dd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过<code class="fe lv lw lx ly b">tracePropertyAccess</code>函数，我们可以用它来跟踪指定对象的属性访问:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="3e01" class="nb mb iq ly b gy nc nd l ne nf">const man = {<br/>  name: "Bytefer",<br/>};</span><span id="2dc0" class="nb mb iq ly b gy nu nd l ne nf">const tracedMan = tracePropertyAccess(man, ["name"]);</span><span id="a21d" class="nb mb iq ly b gy nu nd l ne nf">console.log(tracedMan.name); // GET name; Bytefer<br/>console.log(tracedMan.age); // undefined<br/>tracedMan.name = "Lolo"; // SET name=Lolo</span></pre><p id="bc94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们定义了一个<code class="fe lv lw lx ly b">tracePropertyAccess</code>函数，该函数接收两个参数:obj和propKeys，它们分别表示要跟踪的目标和要跟踪的属性列表。调用<code class="fe lv lw lx ly b">tracePropertyAccess</code>函数后，会返回一个代理对象，当我们访问被跟踪的属性时，控制台会输出相应的访问日志。</p><h2 id="ac2e" class="nb mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">2.6隐藏属性</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c1ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe lv lw lx ly b">hideProperty</code>函数，我们可以用它来隐藏以<code class="fe lv lw lx ly b">_</code>(下划线)开头的属性:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="5c3d" class="nb mb iq ly b gy nc nd l ne nf">const man = {<br/>  name: "Bytefer",<br/>  _pwd: "ProxyAPI",<br/>};</span><span id="641c" class="nb mb iq ly b gy nu nd l ne nf">const safeMan = hideProperty(man);</span><span id="0745" class="nb mb iq ly b gy nu nd l ne nf">console.log(safeMan._pwd); // undefined<br/>console.log("_pwd" in safeMan); // false<br/>console.log(Object.keys(safeMan)); // [ 'name' ]</span></pre><h2 id="56c1" class="nb mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">2.7沙盒</h2><p id="f8ca" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">对于JavaScript来说，沙箱不是传统意义上的沙箱，它只是一种安全机制，在沙箱中运行一些不可信的代码，使其无法访问沙箱外的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5411" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe lv lw lx ly b">sandbox</code>功能，让我们验证它的功能:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="9923" class="nb mb iq ly b gy nc nd l ne nf">const man = {<br/>  name: "Bytefer",<br/>  log() {<br/>    console.log("Hello Proxy API");<br/>  },<br/>};</span><span id="4c0a" class="nb mb iq ly b gy nu nd l ne nf">let code = "log();console.log(name)";<br/>sandbox(code)(man);</span></pre><p id="154c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当在浏览器中运行上述代码时，控制台将抛出以下错误消息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/9e583169680be8bd6b5b36e9323e44e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-EFHqhV6xZ7A27aUN95itg.png"/></div></div></figure><h2 id="c8b2" class="nb mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">2.8建造商</h2><p id="ce81" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">构建器模式将一个复杂的对象分解成相对简单的部分，然后根据不同的需求分别创建，最后构建复杂的对象。</p><p id="9252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe lv lw lx ly b">Proxy</code> API，我们可以实现一个<code class="fe lv lw lx ly b">Builder</code>函数，让它包装的对象支持builder模式来构造对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="20ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe lv lw lx ly b">Builder</code>函数，让我们看看它的两种用法。第一种方法是处理普通对象:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="c65d" class="nb mb iq ly b gy nc nd l ne nf">const defaultUserInfo = {<br/>  id: 1,<br/>  userName: "Bytefer",<br/>  email: "<a class="ae kv" href="mailto:bytefer@gmail.com" rel="noopener ugc nofollow" target="_blank">bytefer@gmail.com</a>",<br/>};</span><span id="8a59" class="nb mb iq ly b gy nu nd l ne nf">const bytefer = Builder(defaultUserInfo).id(2).build();<br/>console.log(bytefer);</span></pre><p id="d68f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方法是处理类:</p><pre class="kg kh ki kj gt mx ly my mz aw na bi"><span id="e75c" class="nb mb iq ly b gy nc nd l ne nf">class User {<br/>  constructor() {}<br/>}</span><span id="2193" class="nb mb iq ly b gy nu nd l ne nf">const lolo = Builder(User, defaultUserInfo);<br/>console.log(lolo.id(3).userName("Lolo").build());</span></pre><p id="5106" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你知道代理API的其他使用场景，可以给我留言。如果你想学习打字稿，那么就不要错过<strong class="ky ir">掌握打字稿</strong>系列。</p><div class="oj ok gp gr ol om"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">有了30+篇文章，学习TypeScript就不会迷茫了</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kp om"/></div></div></a></div><p id="479f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或<a class="ae kv" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，阅读更多关于TS和JS的内容！</p><h1 id="9148" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">资源</h1><div class="oj ok gp gr ol om"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">代理- JavaScript | MDN</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">代理对象允许您创建一个可以用来代替原始对象的对象，但是它可能…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">developer.mozilla.org</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa kp om"/></div></div></a></div><p id="c715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pc">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pc">说白了就是</em> </strong> </a> <em class="pc">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pc">免费周报</em> </strong> </a> <em class="pc">。关注我们关于</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pc">推特</em> </strong> </a>，<a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pc">领英</em> </strong> </a> <strong class="ky ir"> <em class="pc">，</em></strong><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pc">YouTube</em></strong></a><strong class="ky ir"><em class="pc">，以及</em></strong><em class="pc"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pc">不和</em> </strong> </a>  <em class="pc">对成长黑客感兴趣？检查出</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pc">电路</em> </strong> </a> <strong class="ky ir"> <em class="pc">。</em>T71】</strong></p></div></div>    
</body>
</html>