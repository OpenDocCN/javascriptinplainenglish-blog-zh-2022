<html>
<head>
<title>JavaScript Array Methods — Iteration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数组方法—迭代</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-array-methods-iteration-82241f681f4b?source=collection_archive---------12-----------------------#2022-01-04">https://javascript.plainenglish.io/javascript-array-methods-iteration-82241f681f4b?source=collection_archive---------12-----------------------#2022-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="67e8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">迭代数组，没有循环，变得简单！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a8e81f4228c75691b763af9effa264de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YYGCUA1eMUoSsQLNNDrGg.jpeg"/></div></div></figure><p id="15e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个人都或多或少地使用过<em class="lk"> for loops </em>来迭代一个数组，如果你刚刚开始使用JavaScript，很有可能你仍然是这样。虽然这没有什么错，但是数组类定义的方法有助于用<em class="lk">清理</em>，更<em class="lk">简洁的</em> &amp; <em class="lk">可读的</em>代码。</p><p id="3b47" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">迭代方法的主要前提是按顺序遍历数组元素，并将它们传递给我们提供的函数。这个函数可以是内联定义的，也可以是已经声明的，或者是一个箭头函数。</p><p id="f972" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">迭代方法</strong></p><ul class=""><li id="250d" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated"><strong class="kq io">地图()</strong></li></ul><p id="7152" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk"> map() </em>方法将每个数组元素传递给提供的函数，并返回一个<em class="lk">新数组</em>，其中包含该函数返回的值。</p><p id="d1eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果数组是<em class="lk">稀疏的</em>，将不会对缺少的元素调用该函数。然而，新数组也将是<strong class="kq io">稀疏的</strong>。</p><p id="2545" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里需要注意的一个<strong class="kq io">重要的</strong>事情是<em class="lk">而不是</em>使用返回的数组是一个<em class="lk">反模式</em>，在这种情况下，我们最好使用forEach()方法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/8fa123ace2a5216fb3dc859a9a96894f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGZov8B6DuMNqa8ZjuqYxA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Generating a new array, consisting of the original values, <strong class="bd lz">multiplied </strong>by 2.</figcaption></figure><ul class=""><li id="1988" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated"><strong class="kq io"> forEach() </strong></li></ul><p id="bcc7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用这种方法，我们可以遍历一个数组并为每个元素调用一个函数，<em class="lk">而不需要</em>返回一个新的数组。它最多接受三个<em class="lk">参数，数组元素是唯一需要的<em class="lk"/>——然而，我们可以将元素的索引和要迭代的数组作为可选参数传递。</em></p><p id="1e5b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">值得<strong class="kq io">注意</strong>的是，在为所有数组元素调用提供的函数之前终止迭代是不可行的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ma"><img src="../Images/b84460d292bd2c53cc0653472839c895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nlI-rzCgUMc_qGInVmIAw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Deriving the <strong class="bd lz">sum </strong>of all items’ prices.</figcaption></figure><ul class=""><li id="6cd1" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated"><strong class="kq io">过滤器()</strong></li></ul><p id="a7bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">顾名思义，<em class="lk"> filter() </em>创建一个<em class="lk">新数组</em>，包含通过指定条件的元素。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/13f017ccdbb8c62bbf9fbe71c3936651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5nbqiS9eHC4iUblXD0aFFw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Filtering the original array and getting back a new one, consisting of solely <strong class="bd lz">even </strong>numbers.</figcaption></figure><p id="4a4f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个方法的一个有趣的用例是，我们可以在<em class="lk">稀疏</em>数组上使用它来返回它们的<strong class="kq io">密集</strong>等价数组。</p><p id="7bf1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面的过滤基于JavaScript的<em class="lk">类型转换</em>，<em class="lk"> </em>作为稀疏数组索引——否则孔将是未定义的，因此默认为falsy。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/c6f7b72534b8d3d05dec642cb27fe6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKgy53cdbV9q3-egSX5tCg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Filtering based on whether each element is truthy — returns a <strong class="bd lz">dense </strong>array.</figcaption></figure><ul class=""><li id="5a13" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated"><strong class="kq io">reduce()&amp;reduce right()</strong></li></ul><p id="f1cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这两种方法都迭代数组&amp;根据提供的函数返回一个值。这里它们的关键区别是<strong class="kq io"> reduce() </strong>从左到右工作，意思是从第一个数组元素到最后一个，而<strong class="kq io"> reduceRight() </strong>走的是与相反的<em class="lk">路——从最后一个元素一直到第一个。</em></p><p id="373e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它们接受两个参数——一个<em class="lk">函数</em>指示数组将如何减少，以及一个函数的初始值，它是<em class="lk">可选的</em>。如果没有提供初始值，那么初始值将是第一个数组元素。</p><p id="d07a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">在函数</em>中，我们最多可以传递4个参数——前一个值、当前值、当前索引和要迭代的数组，最后两个参数是可选的<em class="lk"/>。<strong class="kq io">请记住</strong>，如果已经提供了初始值，<em class="lk">回调的前一个值将与第一次函数调用</em>时的初始值相同。</p><p id="50dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的例子中，你可以看到我们是如何把所有商品的价格加起来的。由于初始值为0，在第一次调用<em class="lk">时，</em>和将等于0。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/356222c06c80d64d788ea4fea4659d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJ2vGCRUVcA0OWRDyzPFtg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Reducing an array of objects to a single value, the <strong class="bd lz">sum </strong>of all objects’ prices.</figcaption></figure><p id="b73d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">基于同样的前提，我们也可以使用reduce()根据指定的条件派生出一个完整的对象——比如最昂贵的对象。</p><p id="22f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的例子中，我们将前一个商品的价格与当前价格进行比较，并返回最高价格。在第一次调用时，将7赋给initialValue.price，将5.5赋给currentValue.price，而在最后一次调用时，initialValue.price等于7.5，然后与current value . price(15)进行比较。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/844422f77f82b06714ce9cc8a9988482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuuAqHfQbxZReuwFjGIm2Q.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Reducing an array of objects by comparing each, to find the <strong class="bd lz">highest </strong>value.</figcaption></figure><p id="3b15" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了使我们的代码更具可读性和模块化，我们还可以向reduce方法传递一个预定义的函数:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/f5bc62d216599be2b3d96c1abb58880f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvPbp0R9pPGNrXkoyQFSHg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Passing a <strong class="bd lz">pre-defined</strong> function to reduce().</figcaption></figure><ul class=""><li id="2914" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated"><strong class="kq io">凡()&amp;有的()</strong></li></ul><p id="1f32" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这两种方法都迭代数组并返回一个布尔值，这取决于是否每个或某些元素都通过了指定的测试。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/92b35bf5b8489826f579a686d1684272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93ZauuP89T9umrTEet7vyw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Checking if every single array element is even — since they are not, <strong class="bd lz">false </strong>is returned.</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/4487774f3b93e0abee0e8ed4e7489402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41qEBJhoipxQgGZk4ZstOw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Checking if some array elements are even — since some are, <strong class="bd lz">true </strong>is returned.</figcaption></figure><ul class=""><li id="524a" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated"><strong class="kq io"> find() </strong>，<strong class="kq io">find index()&amp;lastIndexOf()</strong></li></ul><p id="3b33" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">三种非常相似的方法，但本质上不同。一旦满足指定的条件，所有这些函数<em class="lk">都停止迭代，find()返回匹配元素，而findIndex() &amp; lastIndexOf()返回匹配元素的索引。这两者之间的<em class="lk">差异</em>在于它们如何迭代数组——find index()从</em>开始的<em class="lk">开始，返回第一个出现的结果，而lastIndexOf()向后<em class="lk">搜索</em>，返回最后一个出现的结果。</em></p><p id="2296" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">值得<strong class="kq io">注意的是</strong>如果没有出现，<em class="lk">findIndex()和lastIndexOf()都将返回-1。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/e86e0acd71768107cc00e6945e2b6a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50doD5OudYSlVHPv3hQ_eQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">As soon as the condition is met, the iteration <strong class="bd lz">stops</strong>.</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/7c6ef2db3fa4643f40a302ca9ccddf41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpnCKKEB3EbHDBGTx0fIFQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Index 0 is returned, as findIndex is executed until the predicate function returns <strong class="bd lz">true</strong>.</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/a504417ee86d84029e0ab0fcc68f66b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6opTyD1DU2ICIyMZvJ5Og.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Index 4 is returned, as lastIndexOf() searches <strong class="bd lz">backwards</strong>.</figcaption></figure><p id="0ab8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要了解更多关于数组方法的信息，我强烈推荐以下内容:</p><ul class=""><li id="cb8f" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated"><a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></li><li id="8252" class="ll lm in kq b kr mc ku md kx me lb mf lf mg lj lq lr ls lt bi translated"><a class="ae mb" href="https://www.w3schools.com/js/js_array_methods.asp" rel="noopener ugc nofollow" target="_blank"> W3Schools </a></li></ul><p id="a4c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在你知道了！<strong class="kq io"> 9个JavaScript方法</strong>，迭代数组，有各种用例，不需要‘for<em class="lk">循环’</em>。感谢你花时间阅读这篇文章，我希望在下一篇文章中见到你！</p><p id="22c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容看</em> <a class="ae mb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lk">说白了。报名参加我们的</em> </a><a class="ae mb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lk">免费周报</em> </a> <em class="lk">。在我们的</em> <a class="ae mb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="lk">社区</em> </a> <em class="lk">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>