<html>
<head>
<title>Build a Sequence of Rooms in a JavaScript Roguelike</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript Roguelike构建一系列房间</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/arranging-adjacent-rooms-in-a-javascript-roguelike-a5c178772d31?source=collection_archive---------11-----------------------#2022-04-26">https://javascript.plainenglish.io/arranging-adjacent-rooms-in-a-javascript-roguelike-a5c178772d31?source=collection_archive---------11-----------------------#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/077994bb3ef9b8136450302c9bce54e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5a_tm3gB7zX1xFYdl7rTg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mlightbody?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Malcolm Lightbody</a> on <a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近我一直在探索如何开发rogue likes——有程序生成关卡的游戏。在五部分系列的第一篇教程中，我编写了随机放置房间的逻辑。该系列的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/making-all-rooms-reachable-in-a-javascript-roguelike-eb1265cadf99">最终教程</a>在一个<a class="ae kc" href="https://stellular-biscuit-6757a3.netlify.app/solution/index.html" rel="noopener ugc nofollow" target="_blank">游戏</a>中达到高潮，游戏中房间通过通道相连。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/f12b61a3864339c37e2f29b381b77758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tA4wReQ892MAgAFW-VhOXA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Roguelike with random room placement.</figcaption></figure><p id="1573" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这些关卡中发现的主要问题是，长通道需要一段时间才能通过，这降低了游戏的速度。因此，为了提高步调——以及为与项目相关的目标搭建舞台——我编写了新的逻辑，构建了没有长通道的房间序列。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/f5d77af7f748ada400ec702ec5211652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKeXldlfFLPz3X5n-ki-PA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A level produced with the new room sequence algorithm.</figcaption></figure><p id="df17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程将向您展示如何编写按顺序排列房间的逻辑。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="a40f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">入门指南</h1><p id="07ae" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在Github 上下载<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-sequence" rel="noopener ugc nofollow" target="_blank">启动代码的</a><a class="ae kc" href="https://github.com/nevkatz/js-roguelike-sequence/archive/refs/heads/main.zip" rel="noopener ugc nofollow" target="_blank">压缩文件</a>。提取之后，您会看到一个项目目录，其中有一个您可以使用的<code class="fe mq mr ms mt b">sequence.js</code>文件，以及每个阶段的解决方案目录。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="4cb0" class="my lo iq mt b gy mz na l nb nc">js-roguelike-sequence<br/>  |<br/>  *--project<br/>  |    |<br/>  |    *--sequence.js<br/>  |    |<br/>  |    *--index.html<br/>  |<br/>  *--phase-1-solution<br/>  |<br/>  *--phase-2-solution<br/>  |<br/>  *--phase-3-solution<br/>  |<br/>  *--phase-4-solution<br/>  |<br/>  *--index.html<br/>  |<br/>  *--css<br/>  |<br/>  *--js</span></pre><h2 id="0a76" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">支持文件</h2><p id="6d62" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">JavaScript目录中的文件包含现有的游戏逻辑。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="62a3" class="my lo iq mt b gy mz na l nb nc"> js<br/> |<br/> *--script.js<br/> |<br/> *--room.js<br/> |<br/> *--game.js<br/> |<br/> *--path.js</span></pre><h2 id="bc35" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">游戏课</h2><p id="c308" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">让我们看一下一些支持文件。<code class="fe mq mr ms mt b">game.js</code>文件存储了<code class="fe mq mr ms mt b">Game</code>类，如下所示。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fb58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">游戏的<code class="fe mq mr ms mt b">map</code>属性将地牢配置存储在一个2D数组中。例如，如果一个4x3的房间被添加到一个6x5的地图的中心，那么<code class="fe mq mr ms mt b">map</code>数组将如下图所示，其中<code class="fe mq mr ms mt b">1</code>是楼层代码，<code class="fe mq mr ms mt b">0</code>是墙壁代码。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="6d30" class="my lo iq mt b gy mz na l nb nc">[[0,0,0,0,0,0],<br/> [0,1,1,1,1,0],<br/> [0,1,1,1,1,0],<br/> [0,1,1,1,1,0],<br/> [0,0,0,0,0,0]]</span></pre><p id="bd47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe mq mr ms mt b">Game</code>对象还存储了对<code class="fe mq mr ms mt b">&lt;canvas&gt;</code>元素及其被称为<code class="fe mq mr ms mt b">context</code>的绘图方法包的引用。此外，它还是一个存储<code class="fe mq mr ms mt b">Room</code>对象的<code class="fe mq mr ms mt b">rooms</code>数组。</p><h2 id="f472" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">房间类</h2><p id="0923" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated"><code class="fe mq mr ms mt b">room.js</code>文件有一个<code class="fe mq mr ms mt b">Room</code>类，如下所示，以及它的方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f19f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文中最重要的属性是<code class="fe mq mr ms mt b">start</code>、<code class="fe mq mr ms mt b">center</code>和<code class="fe mq mr ms mt b">end</code>对象，每个对象存储<code class="fe mq mr ms mt b">x</code>和<code class="fe mq mr ms mt b">y</code>值。<code class="fe mq mr ms mt b">start</code>对应左上角，而<code class="fe mq mr ms mt b">end</code>坐标对应右下角。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c7985ee2934cf509e214f0118c092d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*qClbeS-cu0odqNfQqLhuBQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A Room’s start, center, and end properties.</figcaption></figure><h2 id="cd7a" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">其他JS文件</h2><ul class=""><li id="455f" class="nr ns iq kf b kg ml kk mm ko nt ks nu kw nv la nw nx ny nz bi translated">在<code class="fe mq mr ms mt b">script.js</code>中，你会发现生成关卡和运行游戏的函数。</li><li id="a313" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated"><code class="fe mq mr ms mt b">path.js</code>文件存储<code class="fe mq mr ms mt b">Path</code>类，用于连接房间。</li></ul><h2 id="ae68" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">在最高层</h2><ul class=""><li id="aca7" class="nr ns iq kf b kg ml kk mm ko nt ks nu kw nv la nw nx ny nz bi translated"><code class="fe mq mr ms mt b">css</code>目录包含一个<code class="fe mq mr ms mt b">style.css</code>文件，其中包含一些基本样式。</li><li id="e78b" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">一个<code class="fe mq mr ms mt b">index.html</code>文件包含项目和解决方案的链接。</li></ul><h2 id="25c7" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">sequence.js文件</h2><p id="f15f" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们来看看<code class="fe mq mr ms mt b">project</code>目录。</p><ul class=""><li id="d4c3" class="nr ns iq kf b kg kh kk kl ko of ks og kw oh la nw nx ny nz bi translated">在您的<code class="fe mq mr ms mt b">sequence.js</code>文件中，有一个<code class="fe mq mr ms mt b">generateSequence</code>函数的早期版本。</li><li id="2f58" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">到目前为止，它会重置游戏地图，并根据<code class="fe mq mr ms mt b">Game</code>对象的2D <code class="fe mq mr ms mt b">map</code>数组在<code class="fe mq mr ms mt b">&lt;canvas&gt;</code>元素上绘制图块。</li></ul><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ad397702fec88bb31ade11b359e68ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*4xZbJ_-Z6435MnWJKHPTqQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The initial sequentialRooms function.</figcaption></figure><ul class=""><li id="61d9" class="nr ns iq kf b kg kh kk kl ko of ks og kw oh la nw nx ny nz bi translated">下面是<code class="fe mq mr ms mt b">game.js</code>中的<code class="fe mq mr ms mt b">resetMap</code>方法，用墙代码填充2D地图。</li><li id="a204" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">结果，当<code class="fe mq mr ms mt b">drawMap</code>被调用时，只有墙砖被绘制在画布上。</li></ul><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The resetMap method in game.js.</figcaption></figure><p id="1031" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在浏览器中打开你的<code class="fe mq mr ms mt b">index.html</code>文件，你会看到一个灰色的空白地图，代表一堵墙。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/c6cb98f7e97c6a4bf368c9c6827d04c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BY4WTt3XuPnzAxgwMTfD7A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The initial game map before the coding begins.</figcaption></figure><p id="ce63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为除了墙砖之外什么都没有画，我让<code class="fe mq mr ms mt b">sequentialRooms</code>返回<code class="fe mq mr ms mt b">false</code>，这阻止了程序更新stat显示和添加玩家、敌人、武器和药剂。在<code class="fe mq mr ms mt b">script.js</code>中，<code class="fe mq mr ms mt b">sequentialRooms</code>的返回值在<code class="fe mq mr ms mt b">startGame</code>函数中起作用。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The startGame function that calls sequentialRooms in script.js.</figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="28e0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">阶段1:添加一个房间</h1><p id="099e" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在我们已经看了代码库，让我们开始编码吧！首先，我们将扩展<code class="fe mq mr ms mt b">sequentialRooms</code>功能，使其增加一个大房间。</p><p id="6ae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mt b">script.js</code>文件的顶部，你会注意到游戏网格尺寸是由两个常量决定的:<code class="fe mq mr ms mt b">ROWS</code>和<code class="fe mq mr ms mt b">COLS</code>。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8729" class="my lo iq mt b gy mz na l nb nc">const COLS = 80;<br/>const ROWS = 60;</span></pre><p id="5ed4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mt b">sequence.js</code>中，让我们用<code class="fe mq mr ms mt b">ROWS</code>和<code class="fe mq mr ms mt b">COLS</code>在地图的中心生成一个房间。首先，我们将定义一个名为<code class="fe mq mr ms mt b">center</code>的常数。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="a28a" class="my lo iq mt b gy mz na l nb nc">game.resetMap();</span><span id="182a" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">const center = {<br/>      x:Math.round(COLS/2),<br/>      y:Math.round(ROWS/2)<br/>};</strong></span></pre><p id="c661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mt b">center</code>内，你可以看到<code class="fe mq mr ms mt b">x</code>是<code class="fe mq mr ms mt b">COLS</code>的一半，<code class="fe mq mr ms mt b">y</code>是<code class="fe mq mr ms mt b">ROWS</code>的一半。</p><p id="0ffb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">中心位置确定后，我们来指定房间尺寸。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="86fc" class="my lo iq mt b gy mz na l nb nc">let width = 50, height = 40;</span></pre><p id="f998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们通过调用<code class="fe mq mr ms mt b">script.js</code>中一个名为<code class="fe mq mr ms mt b">generateRoom</code>的函数来添加一个以此为中心的房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="eaf0" class="my lo iq mt b gy mz na l nb nc">let baseRoom = generateRoom(center, width, height);</span></pre><p id="6ffc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们得到我们的<code class="fe mq mr ms mt b">baseRoom</code>之后，让我们把它添加到游戏中。首先，让我们增加游戏的<code class="fe mq mr ms mt b">curRoomId</code>，这样每个房间都有一个唯一的ID。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="3516" class="my lo iq mt b gy mz na l nb nc">game.curRoomId++;</span></pre><p id="cd37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们可以调用名为<code class="fe mq mr ms mt b">carveRoom</code>的方法，将房间添加到2D地图中。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="3bf2" class="my lo iq mt b gy mz na l nb nc">game.carveRoom(baseRoom);</span></pre><p id="fa0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们将<code class="fe mq mr ms mt b">baseRoom</code>对象推入游戏的<code class="fe mq mr ms mt b">rooms</code>数组。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="14c2" class="my lo iq mt b gy mz na l nb nc">game.rooms.push(baseRoom);</span></pre><p id="8ab4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们生成了一个实际的房间，有空间来放置玩家和其他游戏元素，所以让我们返回<code class="fe mq mr ms mt b">true</code>，这样我们在<code class="fe mq mr ms mt b">startGame</code>中的其他函数就可以运行了。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8655" class="my lo iq mt b gy mz na l nb nc">return true;</span></pre><p id="9c9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第1阶段结束时，整个功能应该是这样的。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">the sequentialRooms function at the end of phase 1.</figcaption></figure><p id="24a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意将您的作品与这个<a class="ae kc" href="https://roguelike-sequence.netlify.app/phase-1-solution/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>进行比较，下面是来自第一阶段游戏的一个级别。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/24b3f6bd1a55f6ef700e7afbd372f6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fknb_fBkomemQ1uykYTf5A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The one large room at the end of phase 1.</figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="e6c9" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">第二阶段:添加多个房间</strong></h1><p id="3b1c" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在进一步展开<code class="fe mq mr ms mt b">sequentialRooms</code>之前，让我们写下创建一个房间的逻辑，该房间与前面的房间相邻。在<code class="fe mq mr ms mt b">sequence.js</code>中，你会看到一个名为<code class="fe mq mr ms mt b">addAdjacentRoom</code>的空函数。</p><p id="6d91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们设定房间的尺寸。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="dbc1" class="my lo iq mt b gy mz na l nb nc">function addAdjacentRoom (room) {</span><span id="a362" class="my lo iq mt b gy ok na l nb nc">    let width = 11, height = 6;</span><span id="718d" class="my lo iq mt b gy ok na l nb nc">}</span></pre><p id="64d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们编写四个帮助函数来放置和测试具有这些尺寸的新房间。</p><h2 id="061d" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">寻找房间之间的距离</h2><p id="ecd6" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">首先，让我们写下<code class="fe mq mr ms mt b">distBetween</code>，它决定了现有房间的中心和一个新的相邻房间的中心之间的距离。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="4891" class="my lo iq mt b gy mz na l nb nc">const distBetween = (axis) =&gt; {</span><span id="fa9e" class="my lo iq mt b gy ok na l nb nc">}</span></pre><p id="14c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个参数，<code class="fe mq mr ms mt b">axis</code>。</p><ul class=""><li id="18b0" class="nr ns iq kf b kg kh kk kl ko of ks og kw oh la nw nx ny nz bi translated">如果新房间在上方或下方，则<code class="fe mq mr ms mt b">axis</code>为<code class="fe mq mr ms mt b">y</code>。</li><li id="ee03" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">如果房间在右边或左边，则<code class="fe mq mr ms mt b">axis</code>为<code class="fe mq mr ms mt b">x</code>。</li></ul><p id="74c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为房间之间的通道长度添加一条线，这将是一个瓷砖。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="1f0e" class="my lo iq mt b gy mz na l nb nc">const distBetween = (axis) =&gt; {<br/>      <br/>     let passageLength = 1;</span><span id="33a0" class="my lo iq mt b gy ok na l nb nc">}</span></pre><p id="ae4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果新房间在上面或者下面，我们来找由<code class="fe mq mr ms mt b">genDim</code>确定的<code class="fe mq mr ms mt b">height</code>。如果新房间在右边或左边，让我们得到它的<code class="fe mq mr ms mt b">width</code>。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="7a7b" class="my lo iq mt b gy mz na l nb nc">const distBetween = (axis) =&gt; {<br/>      <br/>     let passageLength = 1;</span><span id="9924" class="my lo iq mt b gy ok na l nb nc">     let newSize = (axis == 'y') ? height : width;</span><span id="4c14" class="my lo iq mt b gy ok na l nb nc">}</span></pre><p id="c490" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们使用<code class="fe mq mr ms mt b">start</code>和<code class="fe mq mr ms mt b">end</code>属性以及<code class="fe mq mr ms mt b">axis</code>来找出<em class="ol">现有</em>房间的高度或宽度。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="e004" class="my lo iq mt b gy mz na l nb nc">const distBetween = (axis) =&gt; {<br/>      <br/>     let passageLength = 1;</span><span id="ee01" class="my lo iq mt b gy ok na l nb nc">     let newSize = (axis == 'y') ? height : width;</span><span id="1763" class="my lo iq mt b gy ok na l nb nc">     let roomSize = room.end[axis] - room.start[axis] + 1;</span><span id="aea7" class="my lo iq mt b gy ok na l nb nc">}</span></pre><p id="71db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后再加上这条把每个房间的一半高度或宽度加在一起然后再加上通道长度的线。这给出了现有房间和新房间之间的距离。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="3668" class="my lo iq mt b gy mz na l nb nc">return Math.ceil(newSize/2) + Math.ceil(roomSize/2) + passageLength;</span></pre><p id="98b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的函数，返回总距离。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The distBetween function.</figcaption></figure><h2 id="0ef3" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">检查一个新房间是否适合地图</h2><p id="5904" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在我们将创建<code class="fe mq mr ms mt b">withinLimits</code>，它决定一个给定的房间是否在游戏地图的范围内。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The withinLimits function.</figcaption></figure><p id="e659" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数在<code class="fe mq mr ms mt b">script.js</code>中使用了一个名为<code class="fe mq mr ms mt b">OUTER_LIMIT</code>的常数，它决定了最外面可能的图块和地图边缘之间的距离。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8df7" class="my lo iq mt b gy mz na l nb nc">const OUTER_LIMIT = 3;</span></pre><h2 id="62fd" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">检查重叠</h2><p id="c4d7" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">接下来，让我们编写<code class="fe mq mr ms mt b">overlapsAny</code>，它检查一个新房间是否会与任何现有的房间重叠。该函数调用的<code class="fe mq mr ms mt b">overlaps</code>方法在<code class="fe mq mr ms mt b">room.js</code>中。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The overlapsAny function.</figcaption></figure><h2 id="3f06" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">生成可能的中心</h2><p id="e3fb" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">最后，我们将创建<code class="fe mq mr ms mt b">possibleCenters</code>，它返回一个新房间的四个可能中心坐标的数组。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The possibleCenters method.</figcaption></figure><p id="0e23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可选参数<code class="fe mq mr ms mt b">diff</code>是房间中心之间的差异。对于上面的房间，它将指定两个房间中心的<code class="fe mq mr ms mt b">x</code>坐标之间的差异。如果<code class="fe mq mr ms mt b">diff</code>为<code class="fe mq mr ms mt b">0</code>，则两个中心对齐。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="fb43" class="my lo iq mt b gy mz na l nb nc">// new room above<br/>{<br/>  x:room.center.x + diff,<br/>  y:room.center.y - distBetween('y')<br/>}</span></pre><p id="9fc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe mq mr ms mt b">distBetween</code>决定了新房间的高度。</p><h2 id="c51b" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">测试可能的中心</h2><p id="bd9c" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们的助手完成后，让我们实例化一个新的数组，<code class="fe mq mr ms mt b">possibleRooms</code>，我们将用任何适合地图并且不与其他房间重叠的房间来填充它。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="2fd1" class="my lo iq mt b gy mz na l nb nc">function addAdjacentRoom(room) {</span><span id="657c" class="my lo iq mt b gy ok na l nb nc">  let width = 11, height = 6;</span><span id="d91e" class="my lo iq mt b gy ok na l nb nc">  // four hidden helper functions</span><span id="f55b" class="my lo iq mt b gy ok na l nb nc">  l<strong class="mt ir">et possibleRooms = [];</strong><br/>}</span></pre><p id="b133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们在<code class="fe mq mr ms mt b">addAdjacentRoom</code>中编写逻辑，根据可能的中心生成新的房间。注意，当我建立下面的循环时，我正在调用<code class="fe mq mr ms mt b">possibleCenters()</code>。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="60cf" class="my lo iq mt b gy mz na l nb nc">let possibleRooms = [];</span><span id="0e99" class="my lo iq mt b gy ok na l nb nc">for (let center of <strong class="mt ir">possibleCenters()</strong>) {</span><span id="fd71" class="my lo iq mt b gy ok na l nb nc">}</span></pre><p id="a17f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个循环中，让我们调用<code class="fe mq mr ms mt b">generateRoom</code>函数。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="4c94" class="my lo iq mt b gy mz na l nb nc">let possibleRooms = [];</span><span id="1577" class="my lo iq mt b gy ok na l nb nc">for (let center of possibleCenters()) {</span><span id="de8e" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">   let r = generateRoom(center, width, height);</strong></span><span id="622e" class="my lo iq mt b gy ok na l nb nc">}</span></pre><p id="1cb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建房间后，我们测试它是否在地图的范围内，以及它是否与其他房间重叠。如果它通过了这些测试，它将被添加到<code class="fe mq mr ms mt b">possibleRooms</code>数组中。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="fed2" class="my lo iq mt b gy mz na l nb nc">let r = generateRoom(center, width, height);</span><span id="9639" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">if (withinLimits(r) &amp;&amp; !overlapsAny(r)) {</strong></span><span id="bc20" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">   possibleRooms.push(r);<br/>}</strong></span></pre><p id="9de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的循环。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Logic for creating and testing rooms based on centers.</figcaption></figure><h2 id="9954" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">选择房间</h2><p id="39a3" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在<code class="fe mq mr ms mt b">addAdjacentRoom</code>结束的时候，我们从<code class="fe mq mr ms mt b">possibleRooms</code>阵中随机挑选一个房间加入游戏。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The logic for selecting the room at random.</figcaption></figure><p id="9776" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果数组是空的，我们将没有空间，所以我们必须在调用<code class="fe mq mr ms mt b">addAdjacentRoom</code>时处理这种可能性。</p><p id="d297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在<code class="fe mq mr ms mt b">addAdjacentRoom</code>已经写好了，让我们更新一下<code class="fe mq mr ms mt b">sequentialRooms</code>函数。</p><p id="2961" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将我们的中心房间添加到游戏后，我们创建一个名为<code class="fe mq mr ms mt b">maxSeqLen</code>的常数，它代表一个序列中房间的最大数量(不包括第一个中心房间)。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="2679" class="my lo iq mt b gy mz na l nb nc"><strong class="mt ir">game.rooms.push(baseRoom);</strong></span><span id="3ce1" class="my lo iq mt b gy ok na l nb nc">const maxSeqLen = 20;</span></pre><p id="58b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们开始一个循环来构建这个序列。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8c21" class="my lo iq mt b gy mz na l nb nc">let baseRoom = addRoom(center, 6, 5, 'wide');</span><span id="216a" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">const maxSeqLen = 20;</strong></span><span id="da18" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">for (var i = 0; i &lt; maSeqLen; ++i) {</strong></span></pre><p id="f905" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在循环中，我们首先尝试调用<code class="fe mq mr ms mt b">addAdjacentRoom</code>。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="5b99" class="my lo iq mt b gy mz na l nb nc">for (var i = 0; i &lt; maxSeqLen; ++i) {</span><span id="4c9c" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">   let newRoom = addAdjacentRoom(baseRoom);</strong></span></pre><p id="ba9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有返回新房间，这意味着没有可行的房间选项，所以我们退出循环，房间生成结束。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="4862" class="my lo iq mt b gy mz na l nb nc">let newRoom = addAdjacentRoom(baseRoom);</span><span id="a70d" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">if (!newRoom) {<br/>      break;<br/>}</strong></span></pre><p id="d75f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个新的房间<em class="ol">被</em>返回，原始房间使用一种叫做<code class="fe mq mr ms mt b">directConnect</code>的方法连接到它，这在房间之间形成一条直线路径。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="6286" class="my lo iq mt b gy mz na l nb nc">if (!newRoom) {<br/>      break;<br/>}</span><span id="db35" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">baseRoom.directConnect(newRoom);</strong></span></pre><p id="f2f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe mq mr ms mt b">baseRoom</code>变成<code class="fe mq mr ms mt b">newRoom</code>，循环结束。因此，新房间成为添加的下一个房间的参考点。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="147e" class="my lo iq mt b gy mz na l nb nc">baseRoom.directConnect(newRoom);</span><span id="f2e6" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">baseRoom = newRoom;</strong></span></pre><p id="58c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">旁白:如果你想了解更多关于<code class="fe mq mr ms mt b">directConnect</code>的工作原理，你可以在<code class="fe mq mr ms mt b">Room.js</code>中探索它，并查看这个<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9">连接房间</a>教程。</p><p id="cd17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是第2阶段的完整<code class="fe mq mr ms mt b">sequentialRooms</code>功能。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The sequential rooms function for Phase 2</figcaption></figure><p id="02e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是游戏的截图，你可以查看这个<a class="ae kc" href="https://roguelike-sequence.netlify.app/phase-2-solution/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>进行比较。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/94a2c910b6c78a098b843275c043361d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNCXDAh5-RuWpLxn_ka5VA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A level produced from the completed phase 2 code.</figcaption></figure><p id="4f47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们来看看如何让房间尺寸和摆放更加多样化。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="6349" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第三阶段:使房间多样化</h1><p id="dd09" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">建立顺序逻辑后，让我们调整<code class="fe mq mr ms mt b">sequence.js</code>中的代码，这样房间的尺寸和位置会有更多变化。</p><p id="a778" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以快速改变尺寸。回想一下，在<code class="fe mq mr ms mt b">addAdjacentRooms</code>中，我们直接设置房间尺寸。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="61c7" class="my lo iq mt b gy mz na l nb nc">let width = 11, height = 6;</span></pre><p id="8660" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用一个使用<code class="fe mq mr ms mt b">script.js</code>中名为<code class="fe mq mr ms mt b">genDim</code>的函数随机生成尺寸的代码来替换这个代码行。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="4fef" class="my lo iq mt b gy mz na l nb nc">let { width, height } = genDim();</span></pre><p id="2c3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mt b">sequentialRooms</code>中，我们也可以通过换入<code class="fe mq mr ms mt b">genDim</code>随机生成第一个中心房间的尺寸。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8348" class="my lo iq mt b gy mz na l nb nc"><strong class="mt ir">let { width, height } = genDim();</strong></span><span id="c9ce" class="my lo iq mt b gy ok na l nb nc">let baseRoom = generateRoom(center, width, height);</span></pre><p id="4ed5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做了之后，你应该会得到类似下面这个级别的东西。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/cf4280bf2ce75ae439ea94d3d1d0bd35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBXMjG_-Y18f4YFT0V9OZw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">One sequence of rooms with varied dimensions that connect at the centers.</figcaption></figure><h2 id="f355" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">多样化的房间布置</h2><p id="fd29" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在，让我们添加一些逻辑，为房间的布置带来更多变化。与其让每一对相连的房间都在它们的中心对齐，不如让我们添加其他可能的中心，它们不会与前一个对齐。</p><p id="b0d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住在<code class="fe mq mr ms mt b">posssibleCenters</code>中我们有那个<code class="fe mq mr ms mt b">diff</code>参数。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/0c7d3d8a686ecfe9be6d752639fba60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*04FdrzwZWwpaSpStDK1L8g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The possibleCenters helper within addAdjacentRoom.</figcaption></figure><p id="9d46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将<code class="fe mq mr ms mt b">diff</code>设为非零，那么生成的四个中心将不会与原始房间的中心对齐。</p><p id="30da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mt b">addAdjacentRooms</code>中，在声明空的<code class="fe mq mr ms mt b">possibleRooms</code>数组后，让我们建立一个<code class="fe mq mr ms mt b">maxDiff</code>常数，它代表房间中心之间的最大可能差异。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="3b52" class="my lo iq mt b gy mz na l nb nc">let possibleRooms = [];</span><span id="4179" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">const maxDiff = 3;</strong></span></pre><p id="36fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们将我们的<code class="fe mq mr ms mt b">possibleCenters</code>循环嵌套在一个外部循环中，该循环遍历由<code class="fe mq mr ms mt b">maxDiff</code>限定的一系列负值和正值。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Adding an outer loop to handle a wider range of possible room centers.</figcaption></figure><p id="e19a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在新循环的开始，我们使用<code class="fe mq mr ms mt b">maxDiff</code>设置了可能的中心范围。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="be3d" class="my lo iq mt b gy mz na l nb nc">for (var diff = -1*maxDiff; diff &lt;= maxDiff; ++diff) {</span></pre><p id="ccef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们为<code class="fe mq mr ms mt b">diff</code>的每个值创建四个可能的中心，并立即遍历它们。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="0d27" class="my lo iq mt b gy mz na l nb nc">for (let center of possibleCenters(diff)) {</span></pre><p id="a317" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在循环中，我们基于该中心生成一个房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="9bfc" class="my lo iq mt b gy mz na l nb nc">let r = generateRoom(center, width, height);</span></pre><p id="53d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果房间通过测试，它将被添加到数组中。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="5b88" class="my lo iq mt b gy mz na l nb nc">if (withinLimits(r) &amp;&amp; !overlapsAny(r)) {<br/>       possibleRooms.push(r);<br/>}</span></pre><p id="4470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mt b">-3</code>和<code class="fe mq mr ms mt b">3</code>之间的<code class="fe mq mr ms mt b">maxDiff</code>范围内，外环运行7次。每次有四个可能的中心——上、下、左、右——我们现在有28种可能的房间排列方式。结果是完成了阶段3，如下所示。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/173bfe494d0dc7399ed61281b88c4a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8hHD0mcay6hlFNcdKudMw.png"/></div></div></figure><p id="0d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意将您的工作与这个<a class="ae kc" href="https://roguelike-sequence.netlify.app/phase-3-solution/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>和<code class="fe mq mr ms mt b">phase-3-solution</code>目录进行比较。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="ef95" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">阶段4:分支序列</h1><p id="e597" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在本教程的最后阶段，让我们为从现有序列分支的房间序列编写逻辑。</p><p id="4b54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe mq mr ms mt b">sequence.js</code>文件中，让我们将一个序列中房间的最大数量减少到10。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="3ff7" class="my lo iq mt b gy mz na l nb nc">const maxSeqLen = 10;</span></pre><p id="8f5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们再添加两个常量:</p><ul class=""><li id="46bf" class="nr ns iq kf b kg kh kk kl ko of ks og kw oh la nw nx ny nz bi translated"><code class="fe mq mr ms mt b">minTotalRooms</code>，为一个级别中的最小总房间数；</li><li id="b90e" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">和<code class="fe mq mr ms mt b">maxTries</code>，用于序列添加尝试的最大次数。</li></ul><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="9c20" class="my lo iq mt b gy mz na l nb nc">const maxSeqLen = 10;<br/><strong class="mt ir">const minTotalRooms = 20;<br/>const maxTries = 100;</strong></span></pre><p id="d2f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mq mr ms mt b">maxTries</code>可防止重复找不到好的房间位置时出现无限循环。我们将使用一个新变量<code class="fe mq mr ms mt b">tries</code>来跟踪我们的尝试。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8870" class="my lo iq mt b gy mz na l nb nc">let tries = 0;</span></pre><p id="f401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将在两个条件下将<code class="fe mq mr ms mt b">for</code>循环包装在<code class="fe mq mr ms mt b">while</code>循环中:我们还有尝试的机会，并且我们还没有达到最小房间总数。这个循环会一直循环下去，直到我们有了最少的房间数，或者尝试次数已经用完。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="c1d0" class="my lo iq mt b gy mz na l nb nc"><strong class="mt ir">while (game.rooms.length &lt; minTotalRooms &amp;&amp; tries &lt; maxTries) {</strong></span><span id="9a8e" class="my lo iq mt b gy ok na l nb nc">  for (var i = 0; i &lt; maxSeqLen; ++i) {</span></pre><p id="24d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在循环中，我们从<code class="fe mq mr ms mt b">game.rooms</code>数组中选择一个现有的房间。虽然第一次只有中间的房间可供选择，但在放置第一系列房间后，还有更多房间可供选择。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="39a4" class="my lo iq mt b gy mz na l nb nc">while (game.rooms.length &lt; minTotalRooms &amp;&amp; tries &lt; maxTries) {</span><span id="bb68" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">  let idx = Math.floor(Math.random()*game.rooms.length);</strong></span><span id="076a" class="my lo iq mt b gy ok na l nb nc">  for (var i = 0; i &lt; maxSeqLen; ++i) {</span></pre><p id="01b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们在生成的索引处从<code class="fe mq mr ms mt b">game.rooms</code>数组中选择我们分支的房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="9062" class="my lo iq mt b gy mz na l nb nc">while (game.rooms.length &lt; minTotalRooms &amp;&amp; tries &lt; maxTries) {</span><span id="be4f" class="my lo iq mt b gy ok na l nb nc">   let idx = Math.floor(Math.random()*game.rooms.length);</span><span id="3cf8" class="my lo iq mt b gy ok na l nb nc"><strong class="mt ir">   baseRoom = game.rooms[idx];</strong></span><span id="0f74" class="my lo iq mt b gy ok na l nb nc">   for (var i = 0; i &lt; maxSeqLen; ++i) {</span></pre><p id="1bf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加上循环的结尾，让我们递增<code class="fe mq mr ms mt b">tries</code>。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="c576" class="my lo iq mt b gy mz na l nb nc">for (var i = 0; i &lt; maxSeqLen; ++i) {</span><span id="fa16" class="my lo iq mt b gy ok na l nb nc">    // hidden code<br/>}<br/><strong class="mt ir">tries++;</strong></span></pre><p id="01e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是新的逻辑，带有常量以及嵌套在<code class="fe mq mr ms mt b">while</code>循环中的<code class="fe mq mr ms mt b">for</code>循环。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The phase 4 while loop</figcaption></figure><p id="a0f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经做到了这一步，祝贺你！您已经完成了教程。下面是一个第4阶段水平的截图。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/0e3018e681417ea797140830c9864112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5i9I8VRXsMzBBE767OQ2Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A phase 4 level.</figcaption></figure><h2 id="0f2d" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">建议的后续步骤</h2><ul class=""><li id="dfb8" class="nr ns iq kf b kg ml kk mm ko nt ks nu kw nv la nw nx ny nz bi translated">将您的代码与这个<a class="ae kc" href="https://roguelike-sequence.netlify.app/phase-4-solution/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>进行比较。</li><li id="eb9d" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">试验一下<code class="fe mq mr ms mt b">minTotalRooms</code>和<code class="fe mq mr ms mt b">maxSeqLen</code>的值，看看它是如何影响分支级别的。</li><li id="f894" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">尝试添加其他可收集的项目。</li><li id="4716" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">看看下面这篇文章，它用相同的游戏机制展示了不同的关卡生成算法。</li></ul><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-build-a-dungeon-crawler-game-with-javascript-57189bdd9f08"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">让我们用随机漫步算法建立一个Roguelike</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">我们可以用普通的JS来完成它。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd jw op"/></div></div></a></div><p id="2c1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇教程，并且你已经学到了一些新的JavaScript技术，你将会把它们带到其他项目中。下次见！</p><p id="88f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ol">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="ol">plain English . io</em></strong></a><em class="ol">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ol">免费周报</em> </strong> </a> <em class="ol">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="ol">Twitter</em></strong></a><em class="ol">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="ol">LinkedIn</em></strong></a><em class="ol">。加入我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ol">社区不和谐</em> </strong> </a> <em class="ol">。考虑</em> <a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"> <strong class="kf ir"> <em class="ol">加入介质</em> </strong> </a> <em class="ol">。</em></p></div></div>    
</body>
</html>