<html>
<head>
<title>How to Handle Multi-Tenant Front-Ends Sharing a Single Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理共享单个数据库的多租户前端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-handle-multi-tenant-front-ends-sharing-a-single-database-1db9c74c216e?source=collection_archive---------9-----------------------#2022-04-18">https://javascript.plainenglish.io/how-to-handle-multi-tenant-front-ends-sharing-a-single-database-1db9c74c216e?source=collection_archive---------9-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4651" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗨伙计们！在本文中，我们将探讨什么是多租户前端，以及我们如何为共享单个数据库的前端实现多租户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d70289df272cee034a75f7dc8e0bbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_FYTfuHWTjabH988.jpg"/></div></div></figure><h1 id="7cfe" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是软件开发中的多租户？</h1><p id="284e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">一个软件应用服务于多个不同的用户组，同时共享运行软件的单个实例，这被称为<a class="ae lx" href="https://techpearl.com/blog/building-a-multi-tenant-system-using-postgresql-and-django/" rel="noopener ugc nofollow" target="_blank">多租户</a>。从数据库的角度来看，这意味着多个应用程序使用一个数据库实例。</p><p id="1d38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lx" href="https://docs.microsoft.com/en-us/azure/architecture/guide/multitenant/considerations/tenancy-models" rel="noopener ugc nofollow" target="_blank">多租户</a>有三种类型:</p><p id="4d5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.共享一切:所有的资源，包括基础设施，数据库共享。</p><p id="13cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.单租户数据库:每个租户有一个不同的数据库。</p><p id="52eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.单租户应用程序:共享同一个数据库。</p><h1 id="56db" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">单租户应用程序</h1><p id="c3f4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">今天，我们将关注最简单但最方便的多租户形式:一个单租户应用程序，其中我们将共享同一个数据库以供以功能为中心的应用程序使用。</p><p id="8614" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们假设我们的应用程序运行在customer@appA.com。现在，我们需要显示/隐藏某些功能，并在不同的域(如customer@appB.com)运行该应用程序，因为两个域共享同一个数据库。让我们想象一下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/70490732863ebbd518aa6707417ba7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uKvjPfBfsHY7SHOywLNaQ.png"/></div></div></figure><h1 id="9003" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">识别应用程序</h1><p id="55d1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">因为我们的实现是以功能为中心的，定制是在运行时进行的，所以可以肯定地说，我们可以为运行在两个不同域的应用程序实例使用一个单一的构建。</p><p id="49f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在我们的第一个目标应该是识别哪个应用程序实例正在被服务。这可以通过以下一种或两种方法实现:</p><p id="f5d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.在运行时识别域名。</p><p id="9d28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.从响应头获取应用名称/域。</p><h1 id="42c4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在运行时识别域名</h1><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="1fae" class="me kv in ma b gy mf mg l mh mi">const hostName = window.location.hostname;</span><span id="a81d" class="me kv in ma b gy mj mg l mh mi">// remove any subdomains<br/>const domain = hostName.match(/^(?:.*?\.)?([a-zA-Z0-9\-_]{3,}\.(?:\w{2,8}|\w{2,4}\.\w{2,4}))$/)[1];</span><span id="0f21" class="me kv in ma b gy mj mg l mh mi">// validate the domain for security reasons<br/>if([&lt;domain list&gt;].includes(domain)) {<br/>   switch(domain) { <br/>    case 'appB':<br/>    default: <br/>  }<br/>}</span></pre><h1 id="3554" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">从标题中获取应用名称/域</h1><p id="6c40" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们还可以从标题下的<a class="ae lx" href="https://www.f5.com/services/resources/glossary/load-balancer#:~:text=A%20load%20balancer%20is%20a,users)%20and%20reliability%20of%20applications." rel="noopener ugc nofollow" target="_blank">负载平衡器</a>端设置应用程序名称。然后，我们也可以从服务器端读取应用程序/域名，并相应地编写逻辑。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="274b" class="me kv in ma b gy mf mg l mh mi">const appName = req?.headers?.appName</span></pre><p id="6bc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述方法的缺点是，为了进行功能定制，我们需要在每次进行更改时重新部署应用程序。<br/>这可以通过使用像<a class="ae lx" href="https://launchdarkly.com/" rel="noopener ugc nofollow" target="_blank">launch darky</a>这样的第三方特性管理工具来克服。</p><h1 id="7974" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">黑暗地使用launch</h1><ol class=""><li id="32ce" class="mk ml in jm b jn ls jr lt jv mm jz mn kd mo kh mp mq mr ms bi translated">当处理Node.js特性时</li></ol><p id="e953" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mt mu mv ma b">import as LD from 'launchdarkly-node-client-sdk'</code></p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="4261" class="me kv in ma b gy mf mg l mh mi"><em class="mw">const</em> client = LD.initialize(secretId, { key: '' });</span><span id="28ec" class="me kv in ma b gy mj mg l mh mi">await client.waitForInitialization();<br/><em class="mw">this</em>.allFeatures = ldClient.allFlags();</span></pre><p id="8e3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.处理JS特性时<br/> <code class="fe mt mu mv ma b">import { initialize } from 'launchdarkly-js-client-sdk'</code></p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="1fc8" class="me kv in ma b gy mf mg l mh mi">const client = initialize(secretId, {<br/>  custom: { <br/>    domain: window.location.hostname,<br/>  },<br/>});</span><span id="fb48" class="me kv in ma b gy mj mg l mh mi">client.waitForInitialization().then(() =&gt; {<br/>  this.featureFlags = client.allFlags();<br/>});</span></pre><p id="dff9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在launch crystally平台下，我们可以读取域名并将标志状态传输到我们的前端。好消息是，我们可以在运行时改变特性标志的状态，例如，当我们的应用程序正在运行时。</p><p id="ed36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这次到此为止。请在评论中提出你的任何建议。感谢阅读！</p><p id="e183" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mw">更多内容看</em> <a class="ae lx" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mw">说白了。报名参加我们的</em> <a class="ae lx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae lx" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mw">Twitter</em></strong></a><em class="mw">和</em><a class="ae lx" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mw">LinkedIn</em></strong></a><em class="mw">。加入我们的</em> <a class="ae lx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mw">社区</em> </strong> </a> <em class="mw">。</em></strong></a></p></div></div>    
</body>
</html>