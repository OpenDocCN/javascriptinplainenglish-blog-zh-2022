<html>
<head>
<title>JavaScript Shallow Copy — What is a Shallow Copy?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript浅拷贝——什么是浅拷贝？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-shallow-copy-what-is-a-shallow-copy-99c8a26acba2?source=collection_archive---------10-----------------------#2022-10-24">https://javascript.plainenglish.io/javascript-shallow-copy-what-is-a-shallow-copy-99c8a26acba2?source=collection_archive---------10-----------------------#2022-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2f8c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的浅拷贝是指向内存中相同引用的拷贝，因此是相同的值。让我们了解一下它们是如何工作的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e50691393d462b10abc228d6367e05fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHCwsOqbFjPN7KYa7f4hxw.png"/></div></div></figure><p id="2869" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">浅拷贝</strong>和<strong class="kt ir">深拷贝</strong>是Javascript中的术语，如果你以前从未听说过，可能会感到困惑。经常听说像<a class="ae ln" href="https://fjolt.com/article/javascript-slice" rel="noopener ugc nofollow" target="_blank">切片</a>或<a class="ae ln" href="https://fjolt.com/article/javascript-filter" rel="noopener ugc nofollow" target="_blank">过滤</a>这样的数组方法只是原始数组的一个简单拷贝。</p><h1 id="5b78" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">JavaScript中的浅拷贝是什么？</h1><p id="b0c3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><strong class="kt ir">数组或对象的浅拷贝</strong>是指它们在内存中都有相同的<a class="ae ln" href="https://fjolt.com/article/javascript-by-reference-by-value" rel="noopener ugc nofollow" target="_blank">引用</a>。这意味着如果你改变浅层拷贝，它<strong class="kt ir">也可能</strong>改变原始拷贝。我说<strong class="kt ir">可能是</strong>，因为情况并非总是如此。</p><p id="ac66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个使用<code class="fe ml mm mn mo b">slice</code>的例子:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="991e" class="mt lp iq mo b gy mu mv l mw mx">let arrayOne = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayOneSlice = arrayOne.slice(2, 3);  </span><span id="392b" class="mt lp iq mo b gy my mv l mw mx">console.log(arrayOne); // [ '⚡️', '🔎', '🔑', '🔩' ]<br/>console.log(arrayOneSlice); // [ '🔑' ]</span></pre><p id="fab6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们有一个数组，我们把它放在变量<code class="fe ml mm mn mo b">arrayOneSlice</code>中<code class="fe ml mm mn mo b">slice</code>。这两个数组在内存中有相同的引用，因为<code class="fe ml mm mn mo b">slice</code>对它们进行了浅层复制。所以如果我们试图更新<code class="fe ml mm mn mo b">arrayOneSlice</code>，它也会影响<code class="fe ml mm mn mo b">arrayOne</code>，对吗？</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="9c11" class="mt lp iq mo b gy mu mv l mw mx">let arrayOne = [ '⚡️', '🔎', '🔑', '🔩' ];<br/>let arrayOneSlice = arrayOne.slice(2, 3);  </span><span id="0c1d" class="mt lp iq mo b gy my mv l mw mx">// Update arrayOneSlice<br/>arrayOneSlice[2] = '⚡️'</span><span id="31af" class="mt lp iq mo b gy my mv l mw mx">console.log(arrayOne); // [ '⚡️', '🔎', '🔑', '🔩' ]<br/>console.log(arrayOneSlice); // [ '🔑', empty, '⚡️' ]</span></pre><p id="b523" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只是，它没有——因为我们使用了方括号符号，Javascript将其解释为将新值放入<code class="fe ml mm mn mo b">[2]</code>位置。所以只有<code class="fe ml mm mn mo b">arrayOneSlice</code>被更新——这也是有原因的。虽然'🔑处于<code class="fe ml mm mn mo b">arrayOne</code>中的<code class="fe ml mm mn mo b">[2]</code>位置，处于<code class="fe ml mm mn mo b">arrayOneSlice</code>中的<code class="fe ml mm mn mo b">[0]</code>位置。这可能会给人一种错觉，以为这两个数组是副本，彼此独立运行——但事实也并非如此。考虑下面的例子:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="6860" class="mt lp iq mo b gy mu mv l mw mx">let arrayOne = [ { items: [ '🔎' ]}, '🔎', '🔑', '🔩' ];<br/>let arrayOneSlice = arrayOne.slice(0, 3);  </span><span id="c5a6" class="mt lp iq mo b gy my mv l mw mx">// Update arrayOneSlice<br/>arrayOneSlice[0].items = [ '⚡️' ]</span><span id="6546" class="mt lp iq mo b gy my mv l mw mx">console.log(arrayOne); // [ { items: [ '⚡️' ]}, '🔎', '🔑', '🔩' ]<br/>console.log(arrayOneSlice); // [ { items: [ '⚡️' ]}, '🔎', '🔑' ]</span></pre><p id="9117" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们更新了<code class="fe ml mm mn mo b">arrayOneSlice[0].items</code>，它在两个数组上都被更新了，因为<code class="fe ml mm mn mo b">items</code>存在于两个数组的相同位置，我们没有分配新的值，而是使用点<code class="fe ml mm mn mo b">.</code>符号来更新现有的属性。在Javascript中，这更新了我们使用<code class="fe ml mm mn mo b">slice</code>制作的原件和副本。</p><p id="bc4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用浅层副本要记住的要点</strong>是，调整一个副本会影响你试图复制的原件——内存中的引用是相同的，引用指向数组的值——所以你必须更加小心。你不想做的是创建一个意外的行为，数组的原始和副本在你期望的时候没有同步更新。</p><h1 id="4e42" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">那么如何用Javascript做深度拷贝呢？</h1><p id="f79e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">历史上，Javascript在深度拷贝方面有一点问题。Javascript中的大多数方法，像<a class="ae ln" href="https://fjolt.com/article/javascript-three-dots-spread-operator" rel="noopener ugc nofollow" target="_blank">三点语法</a>、<code class="fe ml mm mn mo b">Object.create()</code>、<code class="fe ml mm mn mo b">Object.assign()</code>和<code class="fe ml mm mn mo b">Array.from()</code>都是浅拷贝。</p><p id="6b34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">深层副本</strong>在内存中有不同的引用，所以你不用担心在使用它们时会改变原始副本。当我们想要避免这种情况时，这使得它们非常有用。</p><p id="639b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">深度拷贝可以通过序列化来实现，或者通过定制脚本将对象或数组的每个部分复制到一个新的对象或数组中，从而在内存中创建一个新的引用。例如，这将在JavaScript中创建一个具有新引用的新数组:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="8cc9" class="mt lp iq mo b gy mu mv l mw mx">let myArray = [ 1, 2, 3, 4 ];<br/>let deepCopy = JSON.parse(JSON.stringify(myArray));</span></pre><p id="9e73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您也可以使用<code class="fe ml mm mn mo b">structuredClone()</code>功能进行深度复制:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="47d0" class="mt lp iq mo b gy mu mv l mw mx">let myArray = [ 1, 2, 3, 4 ];<br/>let deepCopy = structuredClone(myArray);</span></pre><p id="3045" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经创建了具有深层副本的新数组，我们不再需要担心在更改副本时会弄乱原始数组。</p><h1 id="5ff4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="9154" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">浅层复制非常令人困惑，是JavaScript的众多怪癖之一。了解它们是什么可以在将来调试时为您省去很多麻烦，使用深层副本是避免这些问题的好方法。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="d41a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ng">更多内容请看</em><a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">plain English . io</em></strong></a><em class="ng">。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们关于</em><a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">Twitter</em></strong></a><a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">LinkedIn</em></strong></a><em class="ng"/><a class="ae ln" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">YouTube</em></strong></a><em class="ng"/><a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">不和</em> </strong> </a> <em class="ng">。对增长黑客感兴趣？检查</em> <a class="ae ln" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ng">电路</em> </strong> </a> <em class="ng">。</em></p></div></div>    
</body>
</html>