<html>
<head>
<title>The Basics of Angular Component Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度元件继承的基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-component-inheritance-d5057ade463e?source=collection_archive---------1-----------------------#2022-05-26">https://javascript.plainenglish.io/angular-component-inheritance-d5057ade463e?source=collection_archive---------1-----------------------#2022-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0241" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">继承在任何编程语言中都是一个重要的工具。以下是您需要了解的角度分量继承的基础知识。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/68d37f63ff607e93cbdff12186cca3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5DMQlpqWrpZGgoW2X765A.png"/></div></div></figure><p id="2293" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在任何编程语言中，继承都是维护面向对象设计以及减少冗余代码的极好方式。刚开始学习Angular框架时可能不太明显，但是组件可以从其他组件继承，从而重用方法和属性。让我们通过一个例子来说明如何使用角度继承来构建一个更优雅的应用程序。</p><p id="80da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在深入我们的例子之前，让我们讨论一下组件继承<strong class="kt ir">可以</strong>和<strong class="kt ir">不能</strong>做什么。</p><p id="fada" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从父组件<strong class="kt ir">继承的组件可以:</strong></p><ul class=""><li id="c3de" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">使用父组件的方法和属性</li><li id="5977" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">使用父组件的<code class="fe mb mc md me b">@Input</code>和<code class="fe mb mc md me b">@Output</code>属性</li><li id="e083" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">调用父生命周期挂钩</li><li id="6ef1" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">从父级继承生命周期挂钩</li></ul><p id="3df6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从父组件<strong class="kt ir">继承的组件不能:</strong></p><ul class=""><li id="8db7" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">引用父级中的私有方法和属性</li><li id="8aa1" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">重用公开可用的父属性名</li><li id="74de" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">继承父代的装饰者</li></ul><p id="07ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么如何使用组件继承呢？</p><h2 id="b9f6" class="mf mg iq bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw mx bi translated">组件继承用例示例</h2><p id="bf7f" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">假设我们有一个应用程序需要三种不同类型的模态。当然，我们可以创建三个不同的组件，并在不同的时间实现逻辑。但是模态都共享一些可以重用的公共功能。例如，我们的三个模态都需要一个<code class="fe mb mc md me b">open()</code>和一个<code class="fe mb mc md me b">close()</code>方法。让我们假设每个模态都有一个布尔属性叫做<code class="fe mb mc md me b">isOpen</code>。如果没有组件继承，我们的三个模态中的每一个都需要单独实现这些东西。通过继承，我们可以在基本组件中实现一次这种通用功能，并在子组件中重用它。让我们看看怎么做。</p><p id="f966" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建一个名为<code class="fe mb mc md me b">BaseModalComponent</code>的新组件，我们可以实现如下所示的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="59e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里需要注意一些与其他组件不同的地方:我们没有在<code class="fe mb mc md me b">@Component</code>装饰器中指定一个<code class="fe mb mc md me b">selector</code>，我们将模板保留为空字符串。因为实际使用和呈现的是子组件，所以父组件既不需要选择器也不需要模板。有多种方法可以创建引用父模板的子组件，但是对于这个例子，我们将保持它的简单性。你可能想知道为什么我把<code class="fe mb mc md me b">styleUrls</code>留在了装饰器里。我更喜欢保持父样式表不变，并在这个样式表中存储所有模态共有的样式。</p><p id="21ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们设置一个子组件。对于这个例子，我简单地将孩子命名为<code class="fe mb mc md me b">ConfirmationModalComponent</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="96d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们的组件<code class="fe mb mc md me b">extends</code>我们的<code class="fe mb mc md me b">BaseModalComponent</code>必须在它<code class="fe mb mc md me b">implements</code>任何接口之前声明。因为我们正在扩展父组件，所以子组件中的构造函数必须包含一个<code class="fe mb mc md me b">super()</code>调用。这通过调用其构造函数来初始化父级。因为<code class="fe mb mc md me b">BaseModalComponent</code>构造函数需要一个<code class="fe mb mc md me b">ElementRef</code>，所以我们的子组件必须在<code class="fe mb mc md me b">super()</code>中传递它。注意不要将子节点的<code class="fe mb mc md me b">ElementRef</code>命名为与父节点相同的名称，否则会出现错误。</p><p id="eee8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如前所述，我们可以在子节点中调用父节点的方法，只要它是可公开访问的。在我们的子组件中，<code class="fe mb mc md me b">confirm()</code>方法调用父组件的<code class="fe mb mc md me b">closeModal()</code>方法。这允许我们为我们所有的孩子拥有相同的封闭逻辑，而不需要复制代码。</p><p id="1fef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">子组件也可以覆盖父方法。通过在<code class="fe mb mc md me b">ConfirmationModalComponent</code>中实现一个<code class="fe mb mc md me b">closeModal()</code>方法，我们可以重新定义这个方法做什么。这样做之后，在子节点的另一个方法中调用<code class="fe mb mc md me b">closeModal()</code>将调用子节点的方法而不是父节点的方法。</p><p id="5105" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用生命周期挂钩时要小心。我之前提到过，子组件<strong class="kt ir">可以</strong>调用父组件的生命周期钩子，并且它<strong class="kt ir">可以</strong>继承它。然而，如果子组件实现了<code class="fe mb mc md me b">ngOnInit</code>方法，父<code class="fe mb mc md me b">ngOnInit</code>方法将不会被调用，就像任何其他被覆盖的方法一样。换句话说，<code class="fe mb mc md me b">BaseModalComponent</code>中的<code class="fe mb mc md me b">ngOnInit()</code>在<code class="fe mb mc md me b">ConfirmationModalComponent</code>初始化时不会被调用。要在子组件中使用父组件的<code class="fe mb mc md me b">ngOnInit()</code>，可以像在构造函数中那样调用<code class="fe mb mc md me b">super.ngOnInit()</code>。</p><p id="93f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我提到过<code class="fe mb mc md me b">@Input</code>和<code class="fe mb mc md me b">@Output</code>修饰变量可以被子组件使用。让我们把<code class="fe mb mc md me b">BaseModalComponent</code>改成这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="277e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了模态关闭时的输出和文本的输入。通过这种添加，<code class="fe mb mc md me b">ConfirmationModalComponent</code>可以在模板中引用<code class="fe mb mc md me b">text</code>，例如:</p><pre class="kg kh ki kj gt nf me ng nh aw ni bi"><span id="4480" class="mf mg iq me b gy nj nk l nl nm">&lt;h1&gt;{{text}}&lt;/h1&gt;</span></pre><p id="ed62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，我们可以更改子组件来引用输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3f74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是减少重复功能和保持一致性的另一种简便方法。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="5b4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇文章为您提供了组件继承的基础概述，并希望您利用它来编写更简洁的代码。有许多更好的事情可以使用继承。为了进一步阅读:</p><div class="nu nv gp gr nw nx"><a href="https://angular.io/guide/component-overview" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">有角的</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">Angular是一个构建移动和桌面web应用程序的平台。加入数百万开发者的社区…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">angular.io</p></div></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://www.javatpoint.com/typescript-inheritance" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">类型脚本继承-Java point</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">typescript继承与typescript教程，typescript介绍，版本，TypeScript和javascript…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">www.javatpoint.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><p id="6748" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="om">更多内容请看</em><a class="ae on" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="om">plain English . io</em></strong></a><em class="om">。报名参加我们的</em> <a class="ae on" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">免费周报</em> </strong> </a> <em class="om">。关注我们关于</em><a class="ae on" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="om">Twitter</em></strong></a><em class="om">和</em><a class="ae on" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="om">LinkedIn</em></strong></a><em class="om">。查看我们的</em> <a class="ae on" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">社区不和谐</em> </strong> </a> <em class="om">加入我们的</em> <a class="ae on" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="om">人才集体</em> </strong> </a> <em class="om">。</em></p></div></div>    
</body>
</html>