<html>
<head>
<title>Angular Interceptors: The Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度截击机:完全指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-interceptors-a-complete-guide-7294e2317ecf?source=collection_archive---------0-----------------------#2022-07-25">https://javascript.plainenglish.io/angular-interceptors-a-complete-guide-7294e2317ecf?source=collection_archive---------0-----------------------#2022-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="303e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">角度拦截器</h2><div class=""/><div class=""><h2 id="d342" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">什么是角拦截器？它是如何工作的？如何创建一个并提供给应用程序？怎么绕过他们？阅读以了解更多信息。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/40a7343e084948dae1fe5130e67033d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8s2w1Fz9rjTu3FWMfXHcuw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by author</figcaption></figure><p id="a012" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma"> Angular拦截器</em>，也称为<em class="ma"> HTTP拦截器，</em>是Angular中我最喜欢的HTTP特性之一。我喜欢拦截器的原因是它们促进了干净的代码。您只需在一个地方编写几行代码，它们就可以全局地应用于每个HTTP请求和响应。</p><p id="8eaf" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在本文中，我们将研究:</p><ul class=""><li id="ea3c" class="mb mc iq lg b lh li lk ll ln md lr me lv mf lz mg mh mi mj bi translated">什么是<strong class="lg ja"> <em class="ma">角度拦截器</em> </strong>它是如何工作的</li><li id="41e6" class="mb mc iq lg b lh mk lk ml ln mm lr mn lv mo lz mg mh mi mj bi translated">如何实现并向我们的应用程序提供一个或多个拦截器</li><li id="7f2e" class="mb mc iq lg b lh mk lk ml ln mm lr mn lv mo lz mg mh mi mj bi translated">如何使用角度拦截器改变请求和响应</li><li id="fbbc" class="mb mc iq lg b lh mk lk ml ln mm lr mn lv mo lz mg mh mi mj bi translated">如果需要，如何绕过特定的或所有的拦截器</li><li id="c12d" class="mb mc iq lg b lh mk lk ml ln mm lr mn lv mo lz mg mh mi mj bi translated">作为演示应用程序一部分的其他用例</li></ul><p id="01cf" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">所以，让我们开始吧！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="771e" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">什么是角拦截器？</h1><p id="279b" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">简单地说，Angular中的拦截器是实现<code class="fe nt nu nv nw b">HttpInterceptor</code>接口的服务。它们是为拦截HTTP客户端-服务器通信而构建的。</p><p id="9bab" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe nt nu nv nw b"><a class="ae nx" href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener ugc nofollow" target="_blank">HttpInterceptor</a></code>接口的官方文档声明:</p><blockquote class="ny nz oa"><p id="4f3b" class="le lf ma lg b lh li ka lj lk ll kd lm ob lo lp lq oc ls lt lu od lw lx ly lz ij bi translated">拦截器位于<code class="fe nt nu nv nw b"><a class="ae nx" href="https://angular.io/api/common/http/HttpClient" rel="noopener ugc nofollow" target="_blank">HttpClient</a></code>接口和<code class="fe nt nu nv nw b"><a class="ae nx" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank">HttpBackend</a></code>之间。</p></blockquote><p id="94b5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们借助图表来解释这是什么意思。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/e0e309153ba7e9e37318f20eca969ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WL9fi0Qfv1S4K3DAArD-gQ.png"/></div></div></figure><p id="962d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一端是我们的应用程序(客户端),它使用<code class="fe nt nu nv nw b">HttpClient</code>来创建请求。另一端是后端(服务器),负责响应这些请求。在请求从我们的应用程序发出之前，它们会通过一系列拦截器。</p><p id="150f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这个链包含了我们提供给应用程序的所有拦截器(稍后会有更多内容)。在这个链的末端，总会有Angular添加的最后一个处理程序，即<code class="fe nt nu nv nw b">HttpBackend</code>。因此，这个链总是至少有一个处理程序。</p><p id="882b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe nt nu nv nw b">HttpBackend</code>将请求分派给服务器。在下一节中，我们将看到如何使用<code class="fe nt nu nv nw b">HttpBackend</code>来绕过前面的处理程序。</p><p id="30c2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在所有其他情况下，请求和响应通过整个拦截器链。这使得拦截器成为全局改变请求和响应的完美场所。</p><h1 id="4090" class="mw mx iq bd my mz of nb nc nd og nf ng kf oh kg ni ki oi kj nk kl oj km nm nn bi translated">制造角度拦截器</h1><p id="0f0c" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">要创建一个拦截器，我们只需要一个服务来实现<code class="fe nt nu nv nw b">HttpInterceptor</code>接口。这个接口只有一个我们需要实现的方法，即<code class="fe nt nu nv nw b">intercept</code>方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="2e0e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">类型为<code class="fe nt nu nv nw b">HttpRequest</code>的第一个参数<code class="fe nt nu nv nw b">req</code>表示实际的请求到达服务器的路径。</p><p id="5f19" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">第二个参数<code class="fe nt nu nv nw b">next</code>，类型为<code class="fe nt nu nv nw b">HttpHandler</code>，代表链中的下一个拦截器。</p><p id="408e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，返回的类型是一个<code class="fe nt nu nv nw b">HttpEvent</code>类型的<code class="fe nt nu nv nw b">Observable</code>。在大多数情况下，这表示对普通HTTP请求的响应。</p><blockquote class="ny nz oa"><p id="c782" class="le lf ma lg b lh li ka lj lk ll kd lm ob lo lp lq oc ls lt lu od lw lx ly lz ij bi translated"><strong class="lg ja">注意:</strong>我们说普通HTTP请求是因为有一个枚举叫做<code class="fe nt nu nv nw b"><a class="ae nx" href="https://angular.io/api/common/http/HttpEventType" rel="noopener ugc nofollow" target="_blank">HttpEventType</a></code>，它的值代表单独的事件，比如上传/下载进度事件等。</p></blockquote><h1 id="7e9f" class="mw mx iq bd my mz of nb nc nd og nf ng kf oh kg ni ki oi kj nk kl oj km nm nn bi translated">提供HTTP拦截器</h1><p id="0e79" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">像任何其他服务一样，我们不能使用拦截器，除非我们将它提供给应用程序。然而，拦截器的提供不同于普通服务。它们需要在<code class="fe nt nu nv nw b">NgModule</code>中提供。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d3e2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将<code class="fe nt nu nv nw b">HTTP_INTERCEPTORS</code>令牌传递给<code class="fe nt nu nv nw b">providers</code>数组中的<code class="fe nt nu nv nw b">provide</code>属性。尽管我们可能有多个拦截器，但我们对所有拦截器使用同一个令牌。</p><p id="97ec" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">接下来，我们将包含拦截器的类名传递给<code class="fe nt nu nv nw b">useClass</code>属性。</p><p id="b888" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，我们设置了<code class="fe nt nu nv nw b">multi</code>属性，对于拦截器，该属性应该设置为<code class="fe nt nu nv nw b">true</code>。这将依赖注入(DI)机制注入的<code class="fe nt nu nv nw b">provide</code>令牌配置为一个值数组。这个“值数组”包含我们提供的拦截器。</p><p id="f035" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一个重要的细节是<strong class="lg ja">拦截器是按照它们被提供的顺序应用的</strong>。换句话说，顺序很重要。现在，看看我们之前的图表，应该很容易看出请求是按照我们提供拦截器的顺序处理的，而响应是按照相反的顺序处理的。</p><p id="4ae9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">例如，在前面的代码片段中，处理请求的顺序是:<code class="fe nt nu nv nw b">LogInterceptor</code> &gt; <code class="fe nt nu nv nw b">CacheInterceptor</code> &gt; <code class="fe nt nu nv nw b">AuthInterceptor</code> &gt; <code class="fe nt nu nv nw b">MockInterceptor</code>，而处理响应的顺序正好相反:<code class="fe nt nu nv nw b">MockInterceptor</code> &gt; <code class="fe nt nu nv nw b">AuthInterceptor</code> &gt; <code class="fe nt nu nv nw b">CacheInterceptor</code> &gt; <code class="fe nt nu nv nw b">LogInterceptor</code>。</p><h1 id="ba5f" class="mw mx iq bd my mz of nb nc nd og nf ng kf oh kg ni ki oi kj nk kl oj km nm nn bi translated">变更请求和响应</h1><p id="a500" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">因为所有请求都将通过拦截器链，所以拦截器是对请求和响应进行全局变异的最佳场所。</p><p id="4b42" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">要改变请求，我们需要在<code class="fe nt nu nv nw b">intercept</code>方法中做的第一件事是克隆请求。我们必须这样做，因为请求对象是只读的<em class="ma"/>。因此，我们不能只是修改它。我们需要创建一个副本，对该副本进行变异，然后将变异后的副本传递给链中的下一个处理程序。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="bfc5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe nt nu nv nw b">intercept</code>方法返回的类型是<code class="fe nt nu nv nw b">Observable</code>。因此，我们可以通过使用RxJs管道操作符来改变响应，比如前面代码片段中所示的<code class="fe nt nu nv nw b">map</code>操作符。</p><p id="e20b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">与我们对响应所做的类似，我们需要克隆事件，变异副本，并返回变异后的副本。</p><h1 id="d73e" class="mw mx iq bd my mz of nb nc nd og nf ng kf oh kg ni ki oi kj nk kl oj km nm nn bi translated">将元数据传递给拦截器</h1><p id="81c8" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">在某些情况下，我们可能希望将一些信息传递给其中一个拦截器。一种方法是使用服务作为中介。但是有另一种方法可以用更少的代码开销做到这一点。</p><p id="d587" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在我们的演示中，<code class="fe nt nu nv nw b">AuthInterceptor</code>为所有请求设置了<code class="fe nt nu nv nw b">Authorization</code>头。登录到应用程序时，登录请求不需要在其头中设置授权令牌。此外，由于我们尚未登录，我们根本没有令牌。</p><p id="7b17" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们如何告诉<code class="fe nt nu nv nw b">AuthInterceptor</code>忽略登录请求？<br/>输入<code class="fe nt nu nv nw b">HttpContextToken</code>。</p><p id="27e0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们在同一个文件中定义了一个<code class="fe nt nu nv nw b">HttpContextToken</code>和<code class="fe nt nu nv nw b">AuthInterceptor</code>。我们将默认值设置为<code class="fe nt nu nv nw b">false</code>。我们还实现了拦截器将如何使用这个令牌。在我们的例子中，我们只想忽略任何将这个上下文令牌设置为<code class="fe nt nu nv nw b">true</code>的请求。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="380c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后，在登录方法中，我们将上下文令牌设置为<code class="fe nt nu nv nw b">true</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="73b1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe nt nu nv nw b">AuthInterceptor</code>将使用这个令牌并传递请求，而不对其进行修改。除非明确设置，否则其余请求的令牌将使用默认值<code class="fe nt nu nv nw b">false</code>。</p><p id="6e29" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这只是为了演示的目的。我们可以简单地检查一下<code class="fe nt nu nv nw b">token</code>来决定是否绕过拦截器。关键是我们可以用同样的方式使用一个<code class="fe nt nu nv nw b">HttpContextToken</code>来传递我们想要的任何信息。</p><blockquote class="ny nz oa"><p id="71e1" class="le lf ma lg b lh li ka lj lk ll kd lm ob lo lp lq oc ls lt lu od lw lx ly lz ij bi translated">注意:我们没有真正的后端。因此，在本文末尾的StackBlitz中，您会发现一个不同的实现，它不会忽略请求。相反，它创建一个模拟JWT令牌并返回它。</p></blockquote><h1 id="2a98" class="mw mx iq bd my mz of nb nc nd og nf ng kf oh kg ni ki oi kj nk kl oj km nm nn bi translated">绕过拦截链</h1><p id="7090" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">最后，在一些罕见的情况下，我们可能希望完全绕过拦截器链。</p><p id="6f3f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了绕过这个链，我们简单地注入<code class="fe nt nu nv nw b">HttpBackend</code>处理程序，并将其提供给一个本地<code class="fe nt nu nv nw b">HttpClient</code>实例。使用这个实例发出请求不会触发任何提供的拦截器。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h1 id="7f4a" class="mw mx iq bd my mz of nb nc nd og nf ng kf oh kg ni ki oi kj nk kl oj km nm nn bi translated">角度拦截器的使用案例</h1><p id="1158" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">我们已经涵盖了你需要知道的关于角度拦截器的所有内容。现在，让我们看一些用例。</p><h2 id="0a27" class="om mx iq bd my on oo dn nc op oq dp ng ln or os ni lr ot ou nk lv ov ow nm iw bi translated">记录</h2><p id="76da" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">对于拦截器，我们可以做的一件事是记录请求/响应元数据，比如请求的方法和URL、响应的状态代码和文本，等等。</p><p id="9c96" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在我们的演示中，我们记录了每个响应所用的时间。注意，这只是一个演示。我们想要强调缓存响应的好处，所以我们有意识地选择首先提供<code class="fe nt nu nv nw b">LogInterceptor</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="a10b" class="om mx iq bd my on oo dn nc op oq dp ng ln or os ni lr ot ou nk lv ov ow nm iw bi translated">贮藏</h2><p id="2d13" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">HTTP拦截器的另一个重要用途是缓存请求的响应。这可以带来许多好处，例如降低网络利用率、减少后端服务器的负载，以及提高响应能力和用户体验。</p><p id="e20e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以缓存的唯一响应是针对<code class="fe nt nu nv nw b">GET</code>请求的。<code class="fe nt nu nv nw b">CacheInterceptor</code>检查响应是否在缓存中。如果是，它将返回缓存的响应。否则，它将请求传递给下一个处理程序。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="cb99" class="om mx iq bd my on oo dn nc op oq dp ng ln or os ni lr ot ou nk lv ov ow nm iw bi translated">添加请求标题</h2><p id="0d3b" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">链中的第三个拦截器是<code class="fe nt nu nv nw b">AuthInterceptor</code>，它为所有通过的请求添加了<code class="fe nt nu nv nw b">Content-Type</code>和<code class="fe nt nu nv nw b">Authorization</code>头。</p><p id="b2e2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们没有为每个请求设置头，而是使用这个拦截器来拦截所有请求，并在将它们传递给下一个处理程序之前添加所需的头。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7f39" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们在<code class="fe nt nu nv nw b">CacheInterceptor</code>之后提供了<code class="fe nt nu nv nw b">AuthInterceptor</code>，因为如果响应已经被缓存，请求就不会被分派，因此不需要设置任何头。</p><h2 id="3269" class="om mx iq bd my on oo dn nc op oq dp ng ln or os ni lr ot ou nk lv ov ow nm iw bi translated">嘲弄的回应</h2><p id="5326" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">我们提供的最后一种拦截器是<code class="fe nt nu nv nw b">MockInterceptor</code>。因为我们没有后端服务器，所以我们用一些数据创建一个模拟响应。出于演示目的，我们还添加了一个模拟延迟。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h1 id="5c6c" class="mw mx iq bd my mz of nb nc nd og nf ng kf oh kg ni ki oi kj nk kl oj km nm nn bi translated">演示应用程序</h1><p id="fd8f" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">你可以在下面的StackBlitz中找到一个工作演示，或者只在这个GitHub库中找到代码。别忘了<a class="ae nx" href="https://vkagklis.medium.com/subscribe" rel="noopener">订阅我的简讯</a>来关注更多类似的内容。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox ol l"/></div></figure><p id="6143" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们第一次访问<code class="fe nt nu nv nw b">/pandas</code>页面时，它请求数据。控制台中会打印以下记录，数据会在模拟延迟后出现。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/a9d9037e5946a1fe91cc7bb01421066f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*b_N6aJl2PUuNVr_mDaVBjw.png"/></div></figure><p id="c986" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">下次我们访问页面时，将从缓存中检索响应。这个链在<code class="fe nt nu nv nw b">CacheInterceptor</code>处停止，所以我们看不到下一个拦截器的任何日志记录。最后，经过的时间下降到0毫秒，数据立即出现。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/18ed03bc96e625cdfef55a3ee77ee87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*n_iDqif7x9CvjYlvXa7bdQ.png"/></div></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="fe63" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">结论</h1><p id="4edf" class="pw-post-body-paragraph le lf iq lg b lh no ka lj lk np kd lm ln nq lp lq lr nr lt lu lv ns lx ly lz ij bi translated">在本文中，我们研究了Angular中的拦截器。我们解释了它们是什么以及它们是如何工作的。我们为我们的应用程序创建并提供了几个拦截器。</p><p id="562e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们还讨论了像将元数据传递给角度拦截器或用<code class="fe nt nu nv nw b">HttpBackend</code>绕过拦截器链这样的情况。最后，我们展示了一个演示应用程序来看看它们的运行情况。</p><p id="a7b6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">感谢您的阅读。我希望你喜欢这篇文章，并且你学到了一些新的东西。如果有，请考虑通过我的推荐链接注册Medium:</p><div class="pa pb gp gr pc pd"><a href="https://kagklis.medium.com/membership" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd ja gy z fp pi fr fs pj fu fw iz bi translated">通过我的推荐链接加入Medium—kakk lis Vasileios</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">阅读Kagklis Vasileios(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">kagklis.medium.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ky pd"/></div></div></a></div></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="9900" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">更多内容请看</em><a class="ae nx" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja"><em class="ma">plain English . io</em></strong></a><em class="ma">。报名参加我们的</em> <a class="ae nx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> <em class="ma">免费周报</em> </strong> </a> <em class="ma">。关注我们关于</em><a class="ae nx" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja"><em class="ma">Twitter</em></strong></a><strong class="lg ja"><em class="ma"/></strong><em class="ma">和</em><a class="ae nx" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja"><em class="ma">LinkedIn</em></strong></a><em class="ma">。查看我们的</em> <a class="ae nx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> <em class="ma">社区不和谐</em> </strong> </a> <em class="ma">加入我们的</em> <a class="ae nx" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> <em class="ma">人才集体</em> </strong> </a> <em class="ma">。</em></p></div></div>    
</body>
</html>