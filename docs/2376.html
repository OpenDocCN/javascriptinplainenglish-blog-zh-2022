<html>
<head>
<title>Everything You Need To Know About The React Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React生命周期您需要知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-you-need-to-know-about-the-react-lifecycle-9834019fb26f?source=collection_archive---------11-----------------------#2022-06-02">https://javascript.plainenglish.io/everything-you-need-to-know-about-the-react-lifecycle-9834019fb26f?source=collection_archive---------11-----------------------#2022-06-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8d9b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">下一次面试前你需要阅读的简单解释！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3405edac1081e4e1593e6dd1b2adca17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqpCPuuUb5xgMZVVWNoGGQ.png"/></div></div></figure><p id="8b82" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">嘿朋友们，</p><p id="3837" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你像我一样，你可能会在简历上吹嘘自己擅长反应。也许如果你正在开始你的职业生涯，你有一堆React项目列为你的经验。我就是这么做的。</p><p id="011c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">毫无疑问，我很擅长反应。我的GitHub有很多项目可以证明。但是有一件事我从来没有在我的任何项目中真正探索过——甚至直到现在——就是React生命周期。</p><p id="00b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">想象一下当我的面试官问我关于React生命周期方法的时候我有多惊讶。令人欣慰的是，尽管我从未在任何项目中实现过这些生命周期方法中的大部分，但我仍然通过阅读了解了它们的用途。</p><p id="1692" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不幸的是，在采访过程中，我无法回忆起这些方法的确切名称；但是我确实能够传达这些方法所扮演的角色——最终，由于更高权力的恩惠，我得到了这份工作。</p><p id="eb20" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天，我想帮助你做得比我更好。今天，我们将讨论您需要了解的生命周期方法、它们的作用以及您可能想要使用它们的场景。如果你声称你熟练于React，你绝对应该知道这些生命周期方法。</p><p id="311d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们开始吧。</p><h1 id="7f09" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">React的生命周期是什么？</h1><p id="4a7d" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">众所周知，React使我们能够创建单页面、基于组件的应用程序。因此，你的网站不是由多个HTML文件组成的，我们只是有一个HTML文件，当用户与网站交互时，我们会不断地动态重写这个文件。</p><p id="cf78" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通常，这些单页应用程序将由多个组件组成。因此，当用户发出请求，而不是加载一个全新的页面时，可能只有部分网站会重新呈现。例如，如果您使用电子邮件或脸书，您可能会注意到，当页面的其余部分加载新内容时，侧边栏和导航栏不会重新呈现。</p><p id="65e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，react生命周期完全是关于组件的。这些组件都有自己的生命周期。这个生命周期分为三个阶段:安装、更新和卸载。</p><p id="f171" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">挂载是组件第一次被创建并呈现到DOM的时候。</p><p id="cd89" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">更新是指组件将被强制再次呈现。这是因为状态或者道具变了。每当状态或道具发生变化时，UI必须更新以反映这些变化。</p><p id="8dbd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，当组件将要从DOM中删除时，就会发生卸载。也许您想用另一个组件替换这个组件(从而将它从DOM中移除)。或者，浏览器窗口或选项卡将被关闭(从而将其从DOM中移除)。如果有人登录到他们的银行账户，并简单地关闭标签而不是注销，这将非常有帮助。</p><p id="2a3b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">希望你能明白。</p><p id="04ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">总之，生命周期包括安装、更新和卸载(按此顺序)。进一步探索，每个阶段都有方法(或功能)。</p><p id="28b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">安装有以下方法:</p><ul class=""><li id="9d2a" class="mh mi in kq b kr ks ku kv kx mj lb mk lf ml lj mm mn mo mp bi translated">静态getDerivedStateFromProps(props，state)</li><li id="efa0" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">渲染()</li><li id="fc56" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">构造函数()</li><li id="859b" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">componentDidMount()</li></ul><p id="2de1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">更新的方法有:</p><ul class=""><li id="ae21" class="mh mi in kq b kr ks ku kv kx mj lb mk lf ml lj mm mn mo mp bi translated">静态getDerivedStateFromProps(props，state)</li><li id="f309" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">shouldComponentUpdate()</li><li id="fea6" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">渲染()</li><li id="a8a2" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">getsnapshotbeforupdate(previousProps，previousState)</li><li id="0d73" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">componentDidUpdate()</li></ul><p id="881c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">卸载的方法是:</p><ul class=""><li id="8fce" class="mh mi in kq b kr ks ku kv kx mj lb mk lf ml lj mm mn mo mp bi translated">componentWillUnmount()</li></ul><p id="3354" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们对此进行进一步的分析，并进一步了解这些方法。</p><h1 id="60c0" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">安装生命周期方法</h1><p id="4a9d" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们将从第一阶段开始:安装。安装有四种方法，我想看一下。</p><h2 id="76de" class="mv ll in bd lm mw mx dn lq my mz dp lu kx na nb lw lb nc nd ly lf ne nf ma ng bi translated">构造函数()</h2><p id="f77c" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">让我们从<code class="fe nh ni nj nk b">constructor()</code>开始。这个方法是创建新组件并呈现给DOM时调用的第一个方法。</p><p id="62ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据React官方文档，<a class="ae nl" href="https://reactjs.org/docs/react-component.html#constructor" rel="noopener ugc nofollow" target="_blank">构造函数方法</a>非常适合初始化状态和绑定事件处理程序。</p><h2 id="899b" class="mv ll in bd lm mw mx dn lq my mz dp lu kx na nb lw lb nc nd ly lf ne nf ma ng bi translated">静态getDerivedStateFromProps (props，state)</h2><p id="ead4" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">接下来，我们有方法<code class="fe nh ni nj nk b">static getDerivedStateFromProps (props, state)</code>。这个方法主要用于根据来自props的值更新状态。回想一下，props本质上是由父组件提供的值。</p><p id="b3f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，官方文档坚持认为应该少用这种方法。事实上，文档甚至发布了一篇名为<a class="ae nl" href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state" rel="noopener ugc nofollow" target="_blank">的博文，你可能不需要派生状态</a>。对于大多数情况，您可能只需忘记这个方法，并在构造函数中初始化组件的状态。文档坚持认为寻找替代解决方案更好，因为这种方法可能不可预测且难以维护，但它肯定有其用例。</p><h2 id="62a5" class="mv ll in bd lm mw mx dn lq my mz dp lu kx na nb lw lb nc nd ly lf ne nf ma ng bi translated">渲染()</h2><p id="92a1" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">接下来，我们有非常熟悉的方法<code class="fe nh ni nj nk b">render()</code>。Render是我们用来将JSX渲染到DOM中的方法。render方法是React类组件实际需要的唯一方法。</p><h2 id="e35f" class="mv ll in bd lm mw mx dn lq my mz dp lu kx na nb lw lb nc nd ly lf ne nf ma ng bi translated">componentDidMount()</h2><p id="e0a6" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">最后，我们有<code class="fe nh ni nj nk b">componentDidMount()</code>。首次完全呈现组件后，会自动调用此方法。</p><p id="da02" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">许多消息来源一致认为这是执行AJAX调用的最佳场所。如果你想和API交流，这是个好地方。为什么？我们的首要任务是将组件呈现给DOM。只有在这种情况下，我们才应该发出网络请求，请求数据，然后将数据提供给组件。</p><p id="3acb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">文件坚持认为这个过程是优越的。我们不应该在呈现DOM之前发出网络请求和请求数据。这是因为我们不知道AJAX调用需要多长时间，数据需要多长时间才能返回给我们。在数据检索时间比预期长的情况下，我们要么会在网站上看到错误，要么会看到更长的加载时间——这些都不是我们希望看到的。</p><p id="996c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也就是说，这个方法非常适合那些没有DOM就无法执行的操作。例如，这包括创建事件侦听器。当没有DOM元素与之连接时，如何创建一个事件监听器呢？</p><p id="1cb1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就结束了Moutning的生命周期。</p><h1 id="7ff4" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">更新生命周期方法</h1><p id="ecc1" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">与挂载阶段类似，更新阶段也有<code class="fe nh ni nj nk b">static getDerivedStateFromProps (props, state)</code>。它的用途完全相同，因此我们将快速跳过这一步。</p><p id="e663" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">并且更新生命周期阶段也有一个<code class="fe nh ni nj nk b">render()</code>方法。每次组件的状态和道具改变，组件都必须重新渲染。这就是<code class="fe nh ni nj nk b">render()</code>方法的用武之地。它与安装阶段的<code class="fe nh ni nj nk b">render()</code>方法用途完全相同，因此我们将跳过它。</p><h2 id="160e" class="mv ll in bd lm mw mx dn lq my mz dp lu kx na nb lw lb nc nd ly lf ne nf ma ng bi translated">shouldComponentUpdate()</h2><p id="ad0c" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">此方法返回true或false。并且它将确定组件是否应该更新和重新呈现。</p><p id="7360" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以执行任何你想要的操作。检查状态，添加数字，比较字符串。尽你所能。只要确保在最后，你返回一个true或false值，告诉React组件是否应该更新和重新渲染。</p><p id="c479" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者你也可以完全跳过这个方法。这不是必需的。同样，React类组件只需要render方法。</p><h2 id="29ac" class="mv ll in bd lm mw mx dn lq my mz dp lu kx na nb lw lb nc nd ly lf ne nf ma ng bi translated">getsnapshotbeforupdate(prev props，prevState)</h2><p id="d5b5" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">接下来，我们有了这个非常酷的方法:<code class="fe nh ni nj nk b">getSnapshotBeforeUpdate(prevProps, prevState)</code></p><p id="9c3e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个方法允许我们查看组件的先前属性和先前状态。也许你需要它来计算什么的。发疯吧。</p><h2 id="9a24" class="mv ll in bd lm mw mx dn lq my mz dp lu kx na nb lw lb nc nd ly lf ne nf ma ng bi translated">componentDidUpdate()</h2><p id="057a" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">最后，我们有了方法<code class="fe nh ni nj nk b">componentDidUpdate()</code></p><p id="5028" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在组件被更新并在DOM中重新呈现后，立即调用该方法。有些情况下，如果组件已经重新呈现，您可能希望执行某些操作。这是做这件事的地方。</p><h1 id="8a19" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">卸载生命周期方法</h1><p id="1d9a" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">卸载是组件生命周期的最后一个阶段。这是组件将要从DOM中移除的部分。如前所述，出于一些原因，组件可能会从DOM中删除。也许你会用另一个组件替换它。也许你正在关闭你的标签或浏览器窗口。不管怎样，想法是一样的:组件将从DOM中消失。</p><p id="a7b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个阶段只有一个方法。</p><h2 id="e0fa" class="mv ll in bd lm mw mx dn lq my mz dp lu kx na nb lw lb nc nd ly lf ne nf ma ng bi translated">componentWillUnmount()</h2><p id="5cd3" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这个方法在从DOM中移除之前被调用。</p><p id="5ff0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也许你正在开发一款安全的金融应用，比如PayPal、CashApp或银行应用。如果用户关闭选项卡，这是强制注销操作的机会。</p><p id="2a95" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者你正在做一个游戏。如果用户在游戏进行中关闭应用程序，这是保存玩家进度数据的机会。</p><p id="3514" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者，也许你可以完全跳过这个方法。这根本不是必需的。它只是你工具箱里的一个很酷的工具，用于某些情况。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="a441" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们对React生命周期的回顾到此结束。如果你想了解更多，查看由Meta维护的官方文档。</p><p id="bace" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你做进一步的研究，你一定会发现一些我没有提到的其他方法。其中一些已经被否决和放弃，所以要小心。</p><p id="55a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为我的开发者伙伴干杯。</p><p id="9e27" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nt">更多内容看</em> <a class="ae nl" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nt">说白了。报名参加我们的</em> <a class="ae nl" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nt">免费周报</em> </strong> </a> <em class="nt">。关注我们关于</em><a class="ae nl" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nt">Twitter</em></strong></a><em class="nt">和</em><a class="ae nl" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nt">LinkedIn</em></strong></a><em class="nt">。查看我们的</em> <a class="ae nl" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nt">社区不和谐</em> </strong> </a> <em class="nt">，加入我们的</em> <a class="ae nl" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nt">人才集体</em> </strong> </a> <em class="nt">。</em></strong></a></p></div></div>    
</body>
</html>