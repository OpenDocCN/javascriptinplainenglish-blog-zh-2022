<html>
<head>
<title>React Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回应面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-interview-questions-one-must-know-f8fcda7d23df?source=collection_archive---------8-----------------------#2022-08-23">https://javascript.plainenglish.io/react-interview-questions-one-must-know-f8fcda7d23df?source=collection_archive---------8-----------------------#2022-08-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c026" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1章:React必须知道的面试问题</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cd4329497f41791e6947393d1287e9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qG-HEGQKZWwlHJ9B"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/es/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c607" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React是一个<strong class="kv io">开源JavaScript库</strong>，主要用于设计和开发<strong class="kv io">可重用组件</strong>。具有JavaScript背景的开发人员可以很容易地学习React并动手操作。React是web开发人员和组织正在使用的最流行的前端技术。如果你正在准备React面试，下面是你必须知道的问题列表。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="bc92" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 1 </strong>。<strong class="kv io">什么是</strong> <code class="fe lw lx ly lz b"><strong class="kv io">getSnapshotBeforeUpdate()</strong></code> <strong class="kv io">法？</strong></p><pre class="kd ke kf kg gt ma lz mb mc aw md bi"><span id="2d6c" class="me mf in lz b gy mg mh l mi mj">getSnapshotBeforeUpdate(prevProps, prevState) :</span></pre><p id="793d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lw lx ly lz b">getSnapshotBeforeUpdate()</code>方法属于组件生命周期的更新阶段。当组件由于任何状态/属性更改而被重新呈现时，这个方法将在render()之后、dom用最近的更改更新之前被调用。该方法返回的值将作为参数传递给<code class="fe lw lx ly lz b">componentDidUpdate()</code>方法。<code class="fe lw lx ly lz b">componentDidUpdate()</code>以<code class="fe lw lx ly lz b">getSnapshotBeforeUpdate</code>命名。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="5e90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 2。React中的条件渲染是什么？</strong></p><p id="e119" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们不得不从不同的组件中选择要渲染的内容时，条件渲染就出现了。在以下情况下，我们可能需要应用条件渲染</p><ol class=""><li id="9fbf" class="mk ml in kv b kw kx kz la lc mm lg mn lk mo lo mp mq mr ms bi translated">从服务器获取数据并相应地设置变量。</li></ol><p id="e41f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.在按钮/图标上应用可视条件。</p><p id="14f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.处理用户事件</p><p id="8f17" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以使用像‘if’这样的JavaScript操作符，让React决定呈现哪个组件。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="dd6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 3。你将如何在功能组件中实现类似于</strong> <code class="fe lw lx ly lz b"><strong class="kv io">shouldComponentUpdate()</strong></code> <strong class="kv io">的功能？</strong></p><p id="168b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lw lx ly lz b">ShouldComponentUpdate</code>可以在类组件中使用生命周期方法来检查我们是否需要重新渲染组件。这个方法检查当前和下一个状态和道具，如果它们相同，它将返回false，如果它们不同，它将返回true。默认为真。</p><p id="c8a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以在功能组件中使用钩子来实现react生命周期方法。对于<code class="fe lw lx ly lz b">shouldComponentUpdate</code>，我们可以使用useEffect钩子。默认情况下，useEffect将在每次更新/刷新时呈现。我们可以通过在数组中传递值来防止这种情况。该值将是组件输出改变的值(值=状态/道具变量改变值)。该数组将作为第二个参数传递给useEffect。</p><p id="4751" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在下面的代码片段中，假设userId最初是100，在下一次重新呈现时，它仍然是100，React将比较prev和next值，因为它们相同，所以它将跳过useEffect。如果该值不是100，它将应用该效果。这就是如何实现类似<code class="fe lw lx ly lz b">shouldComponentUpdate</code>的功能。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React useEffect Hook</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="47b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 4。类组件和功能组件的区别是什么？</strong></p><p id="7c27" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在React中，组件是任何应用程序的构建块。组件是为代码可重用性而设计的。</p><h2 id="4b4e" class="me mf in bd mv mw mx dn my mz na dp nb lc nc nd ne lg nf ng nh lk ni nj nk nl bi translated">1.类别组件:</h2><p id="8902" class="pw-post-body-paragraph kt ku in kv b kw nm jo ky kz nn jr lb lc no le lf lg np li lj lk nq lm ln lo ig bi translated">在react中，类组件让我们使用React的生命周期方法。组件的安装、更新和卸载阶段可以在类组件中有效地处理。类组件在构造函数中声明了自己的状态变量。class组件的第一个字母必须始终大写。他们有一个返回HTML的render方法。对于React版本&lt; 16.8, class components were a must use if we need to manage the state and lifecycle methods in the components. Now with version 16.8, we have hooks that let us have state inside functional components also.</p><h2 id="dc0e" class="me mf in bd mv mw mx dn my mz na dp nb lc nc nd ne lg nf ng nh lk ni nj nk nl bi translated">2. Function Components:</h2><p id="5567" class="pw-post-body-paragraph kt ku in kv b kw nm jo ky kz nn jr lb lc no le lf lg np li lj lk nq lm ln lo ig bi translated">Functional components are comparatively easy to code and handle. They are nothing but the JavaScript functions which return JavaScript XML. The functional component name must start with an upper case letter. React version &gt; = 16.8已经引入了钩子，通过它我们可以在函数组件内部拥有状态。我们还可以使用钩子在功能组件中实现类似react生命周期的功能。</p><p id="5f0c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">区别:</strong></p><p id="797e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">类组件:</strong></p><ul class=""><li id="a7d2" class="mk ml in kv b kw kx kz la lc mm lg mn lk mo lo nr mq mr ms bi translated">他们有自己的国家。</li><li id="5add" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">它们从反应组分延伸。具有返回HTML的render方法。</li><li id="27ef" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">因为它们有自己的状态，所以也被称为有状态组件。</li></ul><p id="55a8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">功能组件:</strong></p><ul class=""><li id="5419" class="mk ml in kv b kw kx kz la lc mm lg mn lk mo lo nr mq mr ms bi translated">没有状态。(可通过使用挂钩实现)</li><li id="aeaa" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">它们是简单的JavaScript函数。没有呈现方法。</li><li id="7c9a" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">功能组件只是接受道具和渲染，因此它们也被称为无状态组件。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Class Component snippet</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Functional Component Snippet</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="75bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 5。什么是setState()方法，为什么使用它？</strong></p><p id="67aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在类组件中，我们在构造函数中声明了状态变量。我们可以通过<code class="fe lw lx ly lz b">this.state</code>访问它们。当涉及到更新状态变量时<code class="fe lw lx ly lz b">setState()</code>就出现了。<code class="fe lw lx ly lz b">setState()</code>方法更新状态值并重新呈现组件。它本质上是异步的。</p><p id="20a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以用<code class="fe lw lx ly lz b">this.state.variable_name = UpdatedValue</code>更新状态变量，但是使用setState更新状态总是更好，因为要重新渲染。这确保了组件将总是具有更新的值。</p><p id="115c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果在错误的生命周期方法中使用setState的重新呈现功能，可能会导致类似无限循环的问题。例如，如果我们试图在render()中使用setState，它将触发重新渲染，并将进入无限循环，导致服务器崩溃。</p><p id="e423" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如前所述，setState本质上是异步的，因此我们不能确定setState方法中使用的<code class="fe lw lx ly lz b">this.state</code>值。例如，如果我们有一个被频繁点击的like按钮，我们不能保证最近的like计数值。在这种情况下，我们可以向setState传递一个回调函数，该函数将在状态更新后被调用，我们将获得最新的likes计数值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">setState Example</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="9657" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 6。“==”和“===”有什么区别？</strong></p><ul class=""><li id="22f3" class="mk ml in kv b kw kx kz la lc mm lg mn lk mo lo nr mq mr ms bi translated">==被称为相等运算符，而===是严格的相等运算符。</li><li id="dd92" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">==运算符在比较之前进行类型转换。===运算符不会进行类型转换。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="024c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 7。</strong> <code class="fe lw lx ly lz b"><strong class="kv io">this.state.name = “abc”</strong></code> <strong class="kv io">与</strong> <code class="fe lw lx ly lz b"><strong class="kv io">this.setState({name:”Abc”})</strong></code> <strong class="kv io">的区别。什么时候使用这两种方法？</strong></p><p id="c550" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这两种情况下，我们都试图用值<strong class="kv io"> abc </strong>来更新状态变量<strong class="kv io"> name </strong>。根据两种情况下的代码，它会将状态变量更新为abc，但这里的关键区别是，当我们使用setState方法时，它会使组件<strong class="kv io">重新呈现</strong>。<br/> setState导致协调，即它将使用更新后的值重新渲染组件树。因此，如果我们试图在<code class="fe lw lx ly lz b">this.state</code>之前更新状态，组件将没有更新的状态，因此将导致状态不一致。使用<strong class="kv io"> setState </strong>进行状态更新始终是一个最佳实践。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="e36a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">8。状态和道具的区别？</p><p id="d944" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> State: </strong> State是一个保存组件内部数据的JavaScript对象。换句话说，可以说状态是一个在组件内部携带数据的变量。不能在组件外部访问它。通过使用<code class="fe lw lx ly lz b">this.state</code>可以访问状态变量。使用<code class="fe lw lx ly lz b"> this.setState()</code>可以修改状态变量。</p><p id="b27d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">道具:</strong>道具也是保存数据的对象，但是与状态不同，道具可以在不同的组件之间共享。在react中，一切都是一个组件，当我们想要在这些组件之间进行通信时，我们可以使用props。道具是只读的。道具是不可变的，所以我们不能修改组件内部的道具。</p><p id="3eea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">区别:</strong></p><p id="d451" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">状态:</strong></p><ul class=""><li id="99d1" class="mk ml in kv b kw kx kz la lc mm lg mn lk mo lo nr mq mr ms bi translated">状态是可变的。</li><li id="de1b" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">不能在组件外部访问状态。</li><li id="3186" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">状态可用于共享组件内部异步更新的数据。</li></ul><p id="9845" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">道具:</strong></p><ul class=""><li id="e9f0" class="mk ml in kv b kw kx kz la lc mm lg mn lk mo lo nr mq mr ms bi translated">道具是不可改变的</li><li id="9e87" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">可以在组件外部访问Props。</li><li id="31c9" class="mk ml in kv b kw ns kz nt lc nu lg nv lk nw lo nr mq mr ms bi translated">Props用于不同组件之间的数据共享。</li></ul></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="378f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文到此为止。如果你喜欢这篇文章，请不要忘记查看其他文章！</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="db9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nx">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nx">说白了就是</em> </strong> </a> <em class="nx">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nx">免费周报</em> </strong> </a> <em class="nx">。关注我们关于</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nx">推特</em> </strong> </a>，<a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nx">领英</em> </strong> </a> <em class="nx">，</em><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nx">YouTube</em></strong></a><em class="nx">，以及</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nx">不和</em> </strong> </a> <em class="nx">。对增长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nx">电路</em> </strong> </a> <em class="nx">。</em></p></div></div>    
</body>
</html>