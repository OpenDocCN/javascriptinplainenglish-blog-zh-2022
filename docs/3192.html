<html>
<head>
<title>Implement Concurrent Upload of Large Files in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript实现大文件的并发上传</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implement-concurrent-upload-of-large-files-in-javascript-53519a0d2eee?source=collection_archive---------2-----------------------#2022-08-08">https://javascript.plainenglish.io/implement-concurrent-upload-of-large-files-in-javascript-53519a0d2eee?source=collection_archive---------2-----------------------#2022-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4e65ee6bc84bdf7964ee81cb11e619e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUQYOFD_ZpDeKfKRHNGlSQ.jpeg"/></div></div></figure><p id="edf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想学习打字，那么不要错过<strong class="ka ir">掌握打字</strong>系列。本系列将以动画的形式介绍TypeScript的核心知识和技术。</p><div class="kw kx gp gr ky"><div role="button" tabindex="0" class="ab bv gv cb fp kz la bn lb jw ex"><div class="lc l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw ld le fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l ld le fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----53519a0d2eee--------------------------------" rel="noopener follow" target="_top"> Bytefer </a></p></div></div><div class="lh li gw l"><h2 class="bd ir ud ou fp ue fr fs mr fu fw ip bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi uf au ug uh ui qt uj an eh ei uk ul um el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----53519a0d2eee--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="un l fo"><span class="bd b dl z dk">47 stories</span></div></div></div><div class="lu dh lv fp ab lw fo di"><div class="di lm bv ln lo"><div class="dh l"><img alt="" class="dh" src="../Images/8fba4cad7ae795f6abed5234e33e0356.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*l87u8lL_MzD5n4z_"/></div></div><div class="di lm bv lp lq lr"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di bv ls lt lr"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div></div></div></div><p id="af67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/how-to-implement-concurrency-control-in-javascript-df4da29f81c4"> <strong class="ka ir">如何在JavaScript </strong> </a>中实现并发控制一文中，我详细分析了<a class="ae mb" href="https://github.com/rxaviers/async-pool" rel="noopener ugc nofollow" target="_blank"> async-pool </a>库如何使用<code class="fe mc md me mf b">Promise.all</code>和<code class="fe mc md me mf b">Promise.race</code>函数实现异步任务的并发控制。</p><p id="b8d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并发控制的流程如下图所示:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/e53f91ccc25238787466421b705f3b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bkuHJxvYvrNbs-Y3SCdmwg.gif"/></div></div></figure><p id="82a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我在下面的文章中介绍了<a class="ae mb" href="https://github.com/rxaviers/async-pool" rel="noopener ugc nofollow" target="_blank">异步池</a>库的实际应用:</p><div class="kw kx gp gr ky ml"><a href="https://blog.bitsrc.io/implement-concurrent-download-of-large-files-in-javascript-4e94202c5373" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">用JavaScript实现大文件的并发下载</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">如何用JavaScript从零开始一步步实现多线程下载器来提高下载…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">blog.bitsrc.io</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jw ml"/></div></div></a></div><p id="4cdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我将介绍如何使用async-pool库提供的<strong class="ka ir"> asyncPool </strong>函数来实现大文件的并发上传。</p><p id="cdfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许你也知道上传大文件的解决方案。为了提高上传的效率，我们一般使用<code class="fe mc md me mf b">Blob.slice</code>的方法将大文件按照指定的大小进行切片，然后并发上传文件块。<strong class="ka ir">所有组块上传成功后，通知服务器合并组块。</strong></p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/5386d39e05626cfe349286f96856c285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_rKablzlm9nHsDPElviHIw.gif"/></div></div></figure><p id="abb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看了上图，相信你已经对大文件上传方案有了一定的了解。接下来，我们简单介绍一下Blob和File对象。</p><h1 id="1ddc" class="na nb iq bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">Blob和文件对象</h1><h2 id="a402" class="ny nb iq bd nc nz oa dn ng ob oc dp nk kj od oe no kn of og ns kr oh oi nw oj bi translated">Blob对象</h2><p id="5f51" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">Blob(二进制大型对象)表示二进制类型的大型对象。在数据库管理系统中，二进制数据存储为单个实体的集合。Blobs通常是图像、声音或多媒体文件。JavaScript中Blob类型的对象表示不可变的、类似文件的原始数据。为了更直观地理解Blob对象，我们先用Blob构造函数创建一个<strong class="ka ir"> myBlob </strong>对象，如下图所示:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/2da4546b1b11f5a4a969bf591dcbbfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8K20_6t3tlfWC6ZVSgQ_Q.jpeg"/></div></div></figure><p id="77cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所示，<strong class="ka ir"> myBlob </strong>对象有两个属性:size和type。其中，size属性用于表示数据的大小(单位), type是MIME类型，单位为字节。Blob对象由可选类型和Blob部分组成:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/ffc0942694487cbc14b5e69b5afe8b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeuKtP3fQH9lt65apLIsEg.jpeg"/></div></div></figure><p id="2cf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，Blobs不一定以JavaScript的原生格式表示数据。例如，文件接口基于Blob，继承了Blob的功能，并对其进行了扩展，以支持用户系统上的文件。</p><h2 id="acfd" class="ny nb iq bd nc nz oa dn ng ob oc dp nk kj od oe no kn of og ns kr oh oi nw oj bi translated">文件对象</h2><p id="d183" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">文件对象通常从作为用户使用<code class="fe mc md me mf b">&lt;input&gt;</code>元素选择文件的结果而返回的文件列表对象中检索，或者从拖放操作的数据传输对象中检索。</p><p id="7fdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文件对象是一种特殊的Blob，可以在Blob可以使用的任何上下文中使用。特别是，<code class="fe mc md me mf b">FileReader</code>、<code class="fe mc md me mf b">URL.createObjectURL()</code>、<code class="fe mc md me mf b">createImageBitmap()</code>和<code class="fe mc md me mf b">XMLHttpRequest.send()</code>接受Blobs和文件。</p><p id="1682" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在大文件上传的场景中，我们会使用<code class="fe mc md me mf b">Blob.slice()</code>的方法，将大文件按照指定的大小进行切片，然后并行上传组块。接下来，我们来看看如何实现大文件上传。</p><h1 id="9014" class="na nb iq bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">如何实现大文件上传？</h1><p id="1284" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">为了更好地理解下面的内容，我们来看一下整体流程图:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/97237e90a58d140c2ce692d0721b7baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFaRfA2FzfmUQq8Kq4gojw.jpeg"/></div></div></figure><p id="98ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解了上传大文件的流程后，我们先来定义一下上述流程中涉及到的一些辅助功能。</p><h2 id="159f" class="ny nb iq bd nc nz oa dn ng ob oc dp nk kj od oe no kn of og ns kr oh oi nw oj bi translated">1.定义calcFileMd5函数</h2><p id="eb0c" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">此函数用于计算文件的MD5值(数字指纹)。在这个函数中，我们使用<code class="fe mc md me mf b">FileReader</code> API分块读取文件的内容，然后通过<a class="ae mb" href="https://github.com/satazor/js-spark-md5" rel="noopener ugc nofollow" target="_blank"> spark-md5 </a>库提供的方法计算文件的MD5值。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="b67a" class="ny nb iq bd nc nz oa dn ng ob oc dp nk kj od oe no kn of og ns kr oh oi nw oj bi translated">2.定义异步池函数</h2><p id="e528" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">asyncPool函数用于实现异步任务的并发控制。该函数接受3个参数:</p><ul class=""><li id="c159" class="ou ov iq ka b kb kc kf kg kj ow kn ox kr oy kv oz pa pb pc bi translated">并发性:并发限制数(&gt; = 1)</li><li id="392f" class="ou ov iq ka b kb pd kf pe kj pf kn pg kr ph kv oz pa pb pc bi translated">iterable:输入的可迭代对象，如String、Array、TypedArray、Map和Set。</li><li id="6b9a" class="ou ov iq ka b kb pd kf pe kj pf kn pg kr ph kv oz pa pb pc bi translated">iteratorFn:接受两个参数的迭代器函数:每次迭代的值和iterable对象本身。迭代器函数应该返回一个承诺或者是一个异步函数。</li></ul><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="29e2" class="ny nb iq bd nc nz oa dn ng ob oc dp nk kj od oe no kn of og ns kr oh oi nw oj bi translated">3.定义checkFileExist函数</h2><p id="1e3f" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">checkFileExist函数用于检测文件是否已经上传。如果它已经存在，它将返回文件的url，否则它将返回上传的块id列表:</p><pre class="mh mi mj mk gt pi mf pj pk aw ma bi"><span id="90a9" class="ny nb iq mf b gy pl pm l pn po">function checkFileExist(url, name, md5) {<br/>  return request<br/>    .get(url, {<br/>      params: {<br/>        name,<br/>        md5,<br/>      },<br/>    })<br/>    .then((response) =&gt; response.data);<br/>}</span></pre><p id="459d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">checkFileExist函数中使用的请求对象是由axios.create方法创建的Axios实例:</p><pre class="mh mi mj mk gt pi mf pj pk aw ma bi"><span id="6b97" class="ny nb iq mf b gy pl pm l pn po">const request = axios.create({<br/>  baseURL: "<a class="ae mb" href="http://localhost:3000/upload" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/upload</a>",<br/>  timeout: 10000,<br/>});</span></pre><p id="2e0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了请求对象，我们可以轻松地发送HTTP请求。在checkFileExist函数内部，我们会发起一个GET请求，携带的查询参数是文件名和文件的MD5值。</p><h2 id="f866" class="ny nb iq bd nc nz oa dn ng ob oc dp nk kj od oe no kn of og ns kr oh oi nw oj bi translated">4.定义上传功能</h2><p id="f504" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">调用checkFileExist函数后，如果发现文件没有上传或者只上传了文件的一部分，将继续调用upload函数执行上传任务。在upload函数中，我们使用前面介绍的asyncPool函数来实现异步任务的并发控制，如下所示:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="3e90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于切片文件块，实际的上传操作将通过uploadChunk函数执行:</p><pre class="mh mi mj mk gt pi mf pj pk aw ma bi"><span id="4e3e" class="ny nb iq mf b gy pl pm l pn po">function uploadChunk({ url, chunk, chunkIndex, fileMd5, fileName }) {<br/>  let formData = new FormData();<br/>  formData.set("file", chunk, fileMd5 + "-" + chunkIndex);<br/>  formData.set("name", fileName);<br/>  formData.set("timestamp", Date.now());<br/>  return request.post(url, formData);<br/>}</span></pre><h2 id="a9f0" class="ny nb iq bd nc nz oa dn ng ob oc dp nk kj od oe no kn of og ns kr oh oi nw oj bi translated">5.定义concatFiles函数</h2><p id="a443" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">所有的块上传到服务器后，我们需要通知服务器执行块合并操作。这里我们定义了concatFiles函数的功能:</p><pre class="mh mi mj mk gt pi mf pj pk aw ma bi"><span id="245a" class="ny nb iq mf b gy pl pm l pn po">function concatFiles(url, name, md5) {<br/>  return request.get(url, {<br/>    params: {<br/>      name,<br/>      md5,<br/>    },<br/>  });<br/>}</span></pre><h2 id="11d6" class="ny nb iq bd nc nz oa dn ng ob oc dp nk kj od oe no kn of og ns kr oh oi nw oj bi translated">6.定义uploadFile函数</h2><p id="20b8" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">基于上面定义的帮助器函数，我们可以根据上传大文件的总体流程图实现uploadFile函数:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="os ot l"/></div></figure><h1 id="1a2f" class="na nb iq bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">大文件并发上传完整示例</h1><p id="a67b" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">定义了uploadFile函数后，实现大文件并发上传的功能就非常简单了。具体代码如下:</p><pre class="mh mi mj mk gt pi mf pj pk aw ma bi"><span id="eccd" class="ny nb iq mf b gy pl pm l pn po">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;<br/>    &lt;title&gt;Concurrent Download Demo&lt;/title&gt;<br/>    &lt;script src="<a class="ae mb" href="https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js" rel="noopener ugc nofollow" target="_blank">https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js</a>"&gt;&lt;/script&gt;<br/>    &lt;script src="<a class="ae mb" href="https://cdn.bootcdn.net/ajax/libs/spark-md5/3.0.0/spark-md5.min.js" rel="noopener ugc nofollow" target="_blank">https://cdn.bootcdn.net/ajax/libs/spark-md5/3.0.0/spark-md5.min.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;input type="file" id="uploadFile" /&gt;<br/>    &lt;button id="submit" onclick="uploadFile()"&gt;Upload File&lt;/button&gt;<br/>    &lt;script&gt;<br/>      // Omit helper functions defined earlier<br/>    &lt;/script&gt; <br/> &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="786f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于完整的示例代码内容很多，这里就不放具体代码了。但是你可以在<a class="ae mb" href="https://gist.github.com/semlinker/6f65bfed7637ad50b2efd1ebeb3d6231" rel="noopener ugc nofollow" target="_blank">要点</a>上找到完整的代码。最后，让我们创建一个用于接收文件块和合并文件块的文件服务器。</p><h1 id="9753" class="na nb iq bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">创建文件服务器</h1><p id="8fc8" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">在客户端完成大文件并发上传的功能后，我们将使用Koa开发一个简单的文件服务器。关于Koa的相关知识这里就不介绍了，直接看代码吧:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="a26e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<code class="fe mc md me mf b">node simple-file-server.js</code>命令启动文件服务器后，我们可以在浏览器中上传指定的文件。当文件成功上传后，在服务器目录中，我们可以看到文件块和合并的文件，如下图所示</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pp"><img src="../Images/4a9d3453417b115aa03e8deee305b75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqFPRHDX2RpgoRdrplyceQ.jpeg"/></div></div></figure><p id="5c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文介绍了如何在JavaScript中使用async-pool库提供的<strong class="ka ir"> asyncPool </strong>函数来实现大文件的并发上传。此外，我们还使用spark-md5库来计算文件的数字指纹。如果你对数字指纹感兴趣，可以自己去了解一下。</p><h1 id="220f" class="na nb iq bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">资源</h1><div class="kw kx gp gr ky ml"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">blob-Web API | MDN</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">blob对象表示Blob，它是不可变的原始数据的类似文件的对象；它们可以作为文本阅读或…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">developer.mozilla.org</p></div></div><div class="mu l"><div class="pq l mw mx my mu mz jw ml"/></div></div></a></div><div class="kw kx gp gr ky ml"><a href="https://blog.bitsrc.io/implement-concurrent-download-of-large-files-in-javascript-4e94202c5373" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">用JavaScript实现大文件的并发下载</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">如何用JavaScript从零开始一步步实现多线程下载器来提高下载…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">blog.bitsrc.io</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jw ml"/></div></div></a></div><div class="kw kx gp gr ky ml"><a href="https://github.com/rxaviers/async-pool" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">GitHub - rxaviers/async-pool:用有限的资源运行多个承诺返回和异步函数…</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">这个库的目标是使用本地异步迭代器(ES9)，本地异步函数和本地承诺来实现…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="pr l mw mx my mu mz jw ml"/></div></div></a></div><p id="094d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ps">更多内容请看</em><a class="ae mb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ps">plain English . io</em></strong></a><em class="ps">。报名参加我们的</em> <a class="ae mb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ps">免费周报</em> </strong> </a> <em class="ps">。关注我们关于</em> <a class="ae mb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ps">推特</em></strong></a><a class="ae mb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ps">领英</em></strong></a><strong class="ka ir"><em class="ps"/></strong><em class="ps">和</em> <a class="ae mb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ps">不和</em> </strong> </a> <strong class="ka ir"> <em class="ps">。</em>T45】</strong></p></div></div>    
</body>
</html>