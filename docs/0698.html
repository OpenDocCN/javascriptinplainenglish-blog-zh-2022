<html>
<head>
<title>5 Mistakes that an Amateur Frontend Developer Would Make</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">业余前端开发人员会犯的5个错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-mistakes-that-an-amateur-frontend-developer-would-make-8a0ef4ad059?source=collection_archive---------4-----------------------#2022-02-08">https://javascript.plainenglish.io/5-mistakes-that-an-amateur-frontend-developer-would-make-8a0ef4ad059?source=collection_archive---------4-----------------------#2022-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="04b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你还在犯这些错误吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/32a1a28d41779b8c648a801f3cc1419a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zl5ffT5NHLzJm1-N"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@christinhumephoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christin Hume</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cbce" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.一致性</h1><p id="0ed2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一致性是开发中很常见的问题。每个人都有自己的偏好。如果公司没有一个<strong class="lq ir">代码风格</strong>，我相信开发人员可能每天都会陷入争论。为什么<strong class="lq ir">帕斯卡塞</strong>？为什么<strong class="lq ir">烤肉串案</strong>？为什么<strong class="lq ir">蛇_案</strong>？为什么会这样？为什么会这样？代码将变得很难阅读。</p><p id="3017" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是我喜欢的命名惯例:</p><ul class=""><li id="e295" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir">变量和函数名的驼峰</strong>。例:<code class="fe my mz na nb b">let firstName = "Oyster"</code></li><li id="3b12" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated">使用<code class="fe my mz na nb b">is</code>和<code class="fe my mz na nb b">has</code>进行布尔运算。例如:isDark、isBlur、isDirty、hasFooter等。</li><li id="c2a3" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated">当一个函数返回某些东西时，总是以<strong class="lq ir"> get </strong>为前缀。例如:getFullName()，getImages()</li><li id="db62" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated"><strong class="lq ir"> UPPER_SNAKE_CASE </strong>为常量或不可变对象。例如:API_URL，时区</li><li id="0cf7" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated">为事件处理程序在函数前加上<code class="fe my mz na nb b">handle</code>或<code class="fe my mz na nb b">on</code>(选择其中之一)。例如:handleFormSubmitted，onFormSubmitted</li><li id="3d41" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated">给只在同一个文件中使用的私有函数或私有变量加上前缀<code class="fe my mz na nb b">_</code>。例如:fooBar，_prefix</li></ul><h1 id="f49e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.冗余码</h1><p id="ee85" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我见过许多由不同开发人员编写的冗余代码，不管他们的资历如何</p><p id="6ca2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如:</p><pre class="kg kh ki kj gt nh nb ni nj aw nk bi"><span id="8a2e" class="nl kx iq nb b gy nm nn l no np">// bad<br/>const getFullName = (firstName, lastName) =&gt; {<br/>  let fullName = `${firstName} ${lastName}`<br/>  return fullName;<br/>}</span><span id="6359" class="nl kx iq nb b gy nq nn l no np">// good<br/>const getFullName = (firstName, lastName) =&gt; {<br/>  return `${firstName} ${lastName}`;<br/>}</span></pre><p id="3ef7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">问题:为什么声明一个额外的变量，除了return之外不使用它？</p><pre class="kg kh ki kj gt nh nb ni nj aw nk bi"><span id="4263" class="nl kx iq nb b gy nm nn l no np">// bad<br/>const isMoreThanFourty = foo &gt; 40 ? true : false;<br/>// bad<br/>const isMoreThanFourty = foo &lt; 40 ? false : true;<br/>// good<br/>const isMoreThanFourty = foo &gt; 40;</span><span id="8da7" class="nl kx iq nb b gy nq nn l no np">// bad<br/>if (value === true) {}<br/>// good<br/>if (value) {}</span></pre><p id="b700" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">比较运算符将返回带有<code class="fe my mz na nb b">true</code>或<code class="fe my mz na nb b">false</code>的布尔值。这意味着手动返回<code class="fe my mz na nb b">true</code>或<code class="fe my mz na nb b">false</code>没有意义。</p><h1 id="8838" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.重复代码</h1><p id="fa91" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有一个编程原理叫<strong class="lq ir">干</strong>(不重复)。当你从一个地方复制粘贴到另一个地方，这意味着你在复制代码。</p><p id="a43b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，开发人员在编写干代码时可能很容易违背另一个叫做<strong class="lq ir"> YAGNI </strong>(你不需要它)的原则。你不应该写你认为将来可能需要的东西。与将来删除逻辑相比，添加逻辑更容易。你认为你需要的逻辑通常会以不同的方式结束。是的，逻辑可能稍微有点团队想要的，但不完全是，最终，您仍然需要花费精力来修改它。“要聪明，不要自作聪明”</p><h1 id="dd24" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.导入整个库</h1><p id="a1cd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">不惜一切代价避免导入整个库！这将增加包的大小。我就以洛达什为例。不要<code class="fe my mz na nb b">import _ from "lodash"</code>。这将使您的包大小增加500kb以上。</p><p id="1312" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您应该导入您需要的唯一函数。例如<code class="fe my mz na nb b">import isEmpty from "lodash/isEmpty"</code>，你的捆绑者将<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking" rel="noopener ugc nofollow" target="_blank">摇树</a>它。</p><h1 id="e996" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.使用单个事件侦听器而不是事件委托</h1><p id="6357" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">事件委托可以简化代码，节省内存，不需要添加多个事件处理程序，添加或移除DOM元素时，不需要添加/移除处理程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/535a924714ac70d44e90387b92053999.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*iy-beLConMAbALGb9UETLw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Individual event listener</figcaption></figure><p id="89ca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上图显示每个<code class="fe my mz na nb b">li</code>都有自己的事件监听器，不同的事件监听器监听同一个处理程序。这将导致高内存消耗。然而，这是可以重构的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/18e469f4dea5c434ab89a1ea760923ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*VbYjfgHazT2aOOIxOkKwhw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Event Delegation</figcaption></figure><p id="caed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">与单个事件侦听器相比，事件委托获得了更好的性能，因为它只有一个事件侦听器。</p><p id="eb89" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我们所知，JavaScript在DOM树的层次结构中有一个冒泡(传播)的事件。当你点击<code class="fe my mz na nb b">li</code>元素时，最终<code class="fe my mz na nb b">ul</code>会收到<code class="fe my mz na nb b">click</code>的事件。</p><h1 id="2aa3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考资料:</h1><ul class=""><li id="e97d" class="mp mq iq lq b lr ls lu lv lx nt mb nu mf nv mj mu mv mw mx bi translated"><a class="ae kv" href="https://betterprogramming.pub/event-delegation-in-javascript-boost-your-app-performance-5f10f25cec96" rel="noopener ugc nofollow" target="_blank">JavaScript中的事件委托</a></li><li id="3904" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated"><a class="ae kv" href="https://dev.to/mohamadharith/comparing-memory-consumption-of-delegated-event-listeners-and-individual-event-listeners-in-javascript-1l3e" rel="noopener ugc nofollow" target="_blank">在Javascript中比较委托事件监听器和单个事件监听器的内存消耗</a></li><li id="73a3" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated"><a class="ae kv" href="https://www.syncfusion.com/blogs/post/10-javascript-naming-conventions-every-developer-should-know.aspx" rel="noopener ugc nofollow" target="_blank">每个开发人员都应该知道的10个JavaScript命名约定</a></li></ul><p id="baf8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nw">更多内容请看</em> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nw">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nw">免费周报</em> </strong> </a> <em class="nw">。在我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nw">社区不和谐</em> </strong> </a> <em class="nw">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>