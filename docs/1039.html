<html>
<head>
<title>How to Not Store the Same File Twice (using JavaScript and PouchDB)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何不存储同一个文件两次(使用JavaScript和PouchDB)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/de-duplicating-data-storage-i-3ed467afc528?source=collection_archive---------18-----------------------#2022-02-28">https://javascript.plainenglish.io/de-duplicating-data-storage-i-3ed467afc528?source=collection_archive---------18-----------------------#2022-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b34f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">消除重复数据存储</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/44879102d5fd9458cd62d49eaafeaddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JEvBDI4GS63rpNCh"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@unarchive?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jeremy Bezanger</a> on <a class="ae kv" href="https://unsplash.com/s/photos/repeating-lemons?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="647e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多年前，我读到一篇关于谷歌内部实验室设法在两个PDF文档之间创建<code class="fe ls lt lu lv b">sha1</code>哈希<a class="ae kv" href="https://shattered.io/" rel="noopener ugc nofollow" target="_blank">冲突的文章。这些文档是非常不同的文档，但是通过巧妙的位操作，产生了相同的<code class="fe ls lt lu lv b">sha1</code>代码。在周五下午，这是一篇引人入胜的阅读，但在周末，我开始问自己一个问题:谷歌为什么在乎？</a></p><p id="c6ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将影响谷歌的一个重要方面是他们的存储平台Google Drive。考虑到他们代表大量的人存储着大量的文件，很可能会有大量的重复文件。</p><p id="b32b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从逻辑上讲，我们可以通过它的用法看到这可能是真的。假设我正在从事一项房地产交易，交换带有扫描签名的电子邮件pdf并不少见。假设每个人都在使用Google Drive备份他们的文档，那么有四个人拥有完全相同文档的副本:买方、买方代理、卖方代理、卖方。不要忘记在这个过程的后面加上律师和贷款人。</p><p id="06fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我曾为主要业务涉及数据交换和存储(石油/天然气生产、电信或数据仓库)的组织工作过，在每种情况下，我们解决问题的方法都很简单:向客户收费。向客户收取每字节费用:他们占用的驱动器空间*复制空间*服务器成本*电费*租金*加价。向客户收费是抵消成本的一个好方法，谷歌也确实向客户收费，但通过重复数据删除，可以保持相同的收入，同时大幅减少物理存储量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/8749bffb920e0d9c4e16b50292a693fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tamgLyy9lZXSqe_gwVgHEw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Viral Memes were always a fun way to watch a poorly configured communication network burst into flames</figcaption></figure><p id="8d6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拿我参与的一个聊天服务来说。<a class="ae kv" href="https://www.gsma.com/futurenetworks/wp-content/uploads/2019/10/RCC.07-v11.0.pdf" rel="noopener ugc nofollow" target="_blank"> GSMA-RCC </a>规定图像可以在客户端设备之间互换；它还指定这些图像应该保留在服务器上，供以后提取。因此，如果一个迷因像病毒一样传播，成千上万的人可能会互相转发该图像，导致该图像的成千上万个副本在网络上传播，并存储在服务器驱动器上。</p><p id="e714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果这是一个好的迷因，人们会把它转发给他们认识的人；已经收到的人。图像如此周而复始，直到理论上它被发送到每一对人之间可能的通信中才会停止。</p><p id="0e55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://technative.io/digital-devices-are-the-backbone-of-every-organisation-are-you-managing-them-properly/#:~:text=Statista%20estimates%20that%20as%20of,us%20roughly%20three%20to%20one." rel="noopener ugc nofollow" target="_blank">这个星球上</a>有100亿个设备，这比<a class="ae kv" href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg" rel="noopener ugc nofollow" target="_blank">需要跨越的7座桥梁</a>还要多。</p><p id="5daa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果某个混蛋将该迷因作为<code class="fe ls lt lu lv b">bitmap</code>发送，每个图像实例将占用大约1079KB。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="409c" class="mb mc iq lv b gy md me l mf mg">assume<br/>- $1.00 per MB revenue<br/>- $0.90 per MB cost<br/>- 1,000,000 user interactions (transfer)<br/>- 1024KB file</span><span id="ceb0" class="mb mc iq lv b gy mh me l mf mg">= 1 MB * 1M transfers * ($1 - $0.9)<br/>= 1TB of storage<br/><strong class="lv ir">= $100,000 profit</strong></span></pre><p id="032b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以明智地要求所有内容都转换成PNG格式(注意Google要求Google Photos这样做),将大小减少到615KB (60%)。这在处理固定收入时是有用的，但不是承诺的数据存储的真实拷贝。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/28acc689ec158f83fb77a7982ccc2a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*B3JmidqmylhKM6RKD0-YTA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Storing the object once per person is how the users perceive a file system</figcaption></figure><p id="4a2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为每个接收图像的人存储一次图像是对资源的低效利用。另一方面，如果我们可以识别出它实际上是同一个图像，我们可以将成本降低到只存储一个实例的<strong class="ky ir">，但是对每次传输收费</strong>。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="7b8d" class="mb mc iq lv b gy md me l mf mg">= (1MB * 1M transfers * $1) - (1 unique file * 1MB * $0.9)<br/>= 1MB of storage<br/><strong class="lv ir">= $999,999.10 profit</strong></span></pre><p id="8c1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每笔交易的成本为90 <strong class="ky ir"> </strong>和90 <strong class="ky ir"> </strong>是有很大区别的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/3e949beaae8d3ed4799d677c818e63f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*tSKS4cfBCyQLXimTgZOvtA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Identifying that everyone is storing the same data, allows us to significantly reduce the amount of space we consume while giving the same level of service to our users.</figcaption></figure><p id="1183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，重复数据消除并不是一个容易解决的问题。</p><p id="4d77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们从不同的人那里以不同的名字接收彼此独立的文件。考虑到大量的大型文件，将这些文件与我们存储的所有其他文件进行逐字节比较将需要大量的处理能力。在大规模系统中，这是不可行的。</p><p id="2af7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我们回到了开始的地方:谷歌在实验室中设法引起了<code class="fe ls lt lu lv b">sha1</code>之间的碰撞。为什么他们会关注研究二进制文档中冲突的极端可能性？因为它们使用散列来帮助识别文件的唯一性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/9b05792640faf8e0938f09dbf32df376.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*MvZY_6RXMFYQLGhiwIDcKA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We can use large hashes as primary keys for the files.</figcaption></figure><h1 id="2b60" class="ml mc iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">一个工作实例</h1><p id="dfa0" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">借鉴过去使用CouchDB解决这个问题的经验，我们可以使用JavaScript和PouchDB实现一个浏览器内演示。如果你不熟悉PouchDB和使用它的DB接口，我建议阅读诺兰·劳森的<a class="ae kv" href="https://pouchdb.com/2014/05/01/secondary-indexes-have-landed-in-pouchdb.html" rel="noopener ugc nofollow" target="_blank">权威介绍。</a></p><p id="1fba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将创建一个简单的例子，三个用户(Alice、Bob和Carol)分享他们刚刚看过的<a class="ae kv" href="https://youtu.be/i1gt1yvUC-s?t=1850" rel="noopener ugc nofollow" target="_blank">新剧</a>中最喜欢的台词。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="a541" class="mb mc iq lv b gy md me l mf mg">let db = new PouchDB('filestore');</span><span id="5df0" class="mb mc iq lv b gy mh me l mf mg">async function main(){<br/>  await db.destroy();<br/>  db = new PouchDB('filestore');<br/>  await CreateIndex();</span><span id="02b6" class="mb mc iq lv b gy mh me l mf mg">await save(<br/>    'alice',<br/>    'gilbert.txt',<br/>    'I am the very model of a modern major general'<br/>  );<br/>  await save(<br/>    'bob',<br/>    'sullivan.txt',<br/>    'I am the very model of a modern major general'<br/>  );<br/>  await save(<br/>    'carol',<br/>    'gilbert.txt',<br/>    'I have knowledge of things animal, vegetable and mineral'<br/>  );<br/>  await save(<br/>    'alice',<br/>    'sullivan.txt',<br/>    'I have knowledge of things animal, vegetable and mineral'<br/>  );</span><span id="5102" class="mb mc iq lv b gy mh me l mf mg">  let data = await db.allDocs({include_docs:true});<br/>  console.log(`DB Size: ${JSON.stringify(data).length}`);<br/><br/>  console.log(await dload('alice'  ,'gilbert.txt'));<br/>  console.log(await dload('bob'    ,'sullivan.txt'));<br/>  console.log(await dload('carol','gilbert.txt'));</span><span id="51b9" class="mb mc iq lv b gy mh me l mf mg">  let peruser = await db.query('allfiles',{<br/>    reduce:true,<br/>    group:true,<br/>    group_level: 1<br/>  });<br/>  console.log(peruser);<br/>}</span><span id="1be6" class="mb mc iq lv b gy mh me l mf mg">main();</span></pre><p id="09df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个过程相对简单:三个人将两行文本中的一行存储到他们的帐户中，然后从数据库中检索它们。</p><p id="ec42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感兴趣的是存储的总大小，以及每用户大小(可计费大小)的使用情况:</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="bfc9" class="mb mc iq lv b gy md me l mf mg">DB Size: 1813 bytes</span><span id="a790" class="mb mc iq lv b gy mh me l mf mg">| User  | Files | Size |<br/>| ----- | ----- | ---- |<br/>| alice |     2 |  101 | <br/>| bob   |     1 |   45 |<br/>| carol |     1 |   56 |</span></pre><p id="65ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序的真正内容发生在<code class="fe ls lt lu lv b">save</code>和<code class="fe ls lt lu lv b">dload</code>中，它们抽象出了与数据库的交互。进一步的<code class="fe ls lt lu lv b">CreateIndex</code>定义了搜索和检索的机制。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="0398" class="mb mc iq lv b gy md me l mf mg">async function CreateIndex(){<br/>  return await db.put({<br/>    _id: '_design/allfiles',<br/>    views: {<br/>      'allfiles': {<br/>        map: function (doc) {<br/>          var userpath = [doc.user,doc.path];<br/>          emit(userpath,doc.size);<br/>        }.toString(),<br/>        reduce:'_stats'<br/>      }<br/>    }<br/>  });</span><span id="da4b" class="mb mc iq lv b gy mh me l mf mg">async function save(user,filename,blob){<br/>  return db.put({<br/>    _id: [user,filename].join('@'),<br/>    user:user,<br/>    path:filename,<br/>    size:blob.length,<br/>    _attachments: {<br/>      '0': {<br/>        content_type: 'text/plain',<br/>        data: window.btoa(blob)<br/>      }<br/>    }<br/>  });<br/>}</span><span id="a7de" class="mb mc iq lv b gy mh me l mf mg">async function dload(user,filename){<br/>  let recs = await db.query('allfiles',{<br/>    reduce: false,<br/>    include_docs: true,<br/>    attachments: true,<br/>    key: [user,filename]<br/>  });<br/>  let blob = recs.rows[0].doc._attachments['0'].data;<br/>  blob = window.atob(blob);<br/>  return blob;<br/>}</span></pre><p id="abd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保存和下载功能基于这样的假设，即我们将为每个人存储一份记录的副本，而索引管理用户及其文件的列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A JSFiddle giving an example of the working demonstration</figcaption></figure><h2 id="fe3b" class="mb mc iq bd mm nj nk dn mq nl nm dp mu lf nn no mw lj np nq my ln nr ns na nt bi translated">减少存储</h2><p id="bb01" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">要修改这个例子来减少我们的存储，我们必须首先修改save函数，不要盲目地为每个用户保存，而是将每个<code class="fe ls lt lu lv b">blob</code>保存为主要对象，并跟踪观察它的用户作为次要项。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="a4cc" class="mb mc iq lv b gy md me l mf mg">async function save(user, filename, blob) {<br/>  let hash = new TextEncoder().encode(blob);<br/>  hash = await crypto.subtle.digest('SHA-256', hash);<br/>  hash = Array.from(new Uint8Array(hash));<br/>  hash = hash<br/>    .map(b =&gt; b.toString(16).padStart(2, '0'))<br/>    .join('')<br/>    .substr(0,4);<br/>  let userpath = [user, filename].join('@');<br/>  let rec = null;<br/>  try {<br/>    rec = await db.get(hash);<br/>  } catch (e) {<br/>    if (e.status !== 404) throw e;<br/>    // create the object, with a list of user's using it<br/>    rec = {<br/>      _id: hash,<br/>      userpaths: [],<br/>      size: blob.length,<br/>      _attachments: {<br/>        '0': {<br/>          content_type: 'text/plain',<br/>          data: window.btoa(blob)<br/>        }<br/>      }<br/>    }<br/>  }<br/>  if (!rec.userpaths.includes(userpath)) {<br/>    rec.userpaths.push(userpath);<br/>  }<br/>  // finally save the record<br/>  return db.put(rec);<br/>}</span></pre><p id="bab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这确保了我们只存储一个blob一次。</p><p id="6538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用散列作为记录标识符意味着不管它被提交多少次，我们只是继续使用现有的记录。新用户只是被添加到使用该项目的用户列表中。用户甚至可以通过用不同的名字提交相同的项目来复制它；我们只是不断地添加注释，让用户知道记录的名称。</p><p id="efd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自然，这破坏了我们使用的查找索引。最初的索引使用记录的名称(用户名+路径)来查找文件，但是文件不再使用它作为它的记录名称。相反，我们需要创建一个查找索引，该索引由使用同一个文件的所有用户构成。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="eab7" class="mb mc iq lv b gy md me l mf mg">async function CreateIndex(){<br/>  return await db.put({<br/>    _id: '_design/allfiles',<br/>    views: {<br/>      'allfiles': {<br/>        map: function (doc) {<br/><strong class="lv ir">          for (let userpath of doc.userpaths) {<br/>            userpath = userpath.split('@');<br/>            emit(userpath, doc.size);<br/>          }</strong><br/>        }.toString(),<br/>        reduce:'_stats'<br/>      }<br/>    }<br/>  });<br/>}</span></pre><p id="aae8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过遍历每个用户路径，我们已经更新了索引，以便为文件的每次使用返回文件。这意味着我们的下载功能没有改变，因为视图的界面没有改变。</p><p id="cd7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们已经在视图中包含了文件大小，并使用了<code class="fe ls lt lu lv b">stats</code> reduce方法。这意味着，当需要计费时，我们可以简单地将用户引用的blobs数量相加，以及将它们的总大小相加。</p><p id="ca44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新运行<code class="fe ls lt lu lv b">main</code>为我们提供了新的总规模和计费数据:</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="ed11" class="mb mc iq lv b gy md me l mf mg">DB Size: 1109 bytes</span><span id="92d9" class="mb mc iq lv b gy mh me l mf mg">| User  | Files | Size |<br/>| ----- | ----- | ---- |<br/>| alice |     2 |  101 | <br/>| bob   |     1 |   45 |<br/>| carol |     1 |   56 |</span></pre><p id="3a2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使在我们的小例子中，由于内容非常小，我们的数据库大小(因此我们的业务费用)<strong class="ky ir">减少了39% </strong>。随着更多的数据结构被内容占用，而更少的被元数据占用(想想MP3、MP4和PNG)，可以看到更好的回报。</p><p id="dced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意，可计费的大小从未改变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The same example as previously presented but with the changes to make the storage smaller.</figcaption></figure><h2 id="cb0f" class="mb mc iq bd mm nj nk dn mq nl nm dp mu lf nn no mw lj np nq my ln nr ns na nt bi translated">完成解决方案</h2><p id="51e1" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">毕竟，我们不能忘记谷歌证明了冲突是恶意的，因此不能绝对信任。我们必须执行完整的逐字节比较。散列函数是确定二进制对象之间不相似性的有用工具，而不是确定相似性的有用工具。</p><blockquote class="nu"><p id="154d" class="nv nw iq bd nx ny nz oa ob oc od lr dk translated">散列函数是确定二进制对象之间不相似性的有用工具</p></blockquote><p id="f0b5" class="pw-post-body-paragraph kw kx iq ky b kz oe jr lb lc of ju le lf og lh li lj oh ll lm ln oi lp lq lr ij bi translated">这是一个非常有用的功能。通过使用一个大散列，我可以很快地将所需的比较缩小到几乎没有。有一个很好的机会，我将不会有超过一个匹配需要检查，这是少得多的努力比百万。一旦我缩小了范围，就必须用一个额外的标记来检查整个文件，以区别于我们已经有的文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/144c3530a9a747fd7bf3ddb19c32f8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/0*pOG1Qn9NXnluBpDC.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.buymeacoffee.com/jeffereycave" rel="noopener ugc nofollow" target="_blank">Found this useful or interesting? Consider leaving a tip … it helps.</a></figcaption></figure><p id="8a6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个问题是，我们需要在某个时候删除记录。在这种情况下，我们可以简单地删除用户对该对象的引用，尽管我们还必须观察没有用户引用该对象的时间。当对象的所有引用都被移除时，对象本身也应该被移除。类似地，如果记录被重命名，我们需要确保在创建新的引用之前删除旧的引用。</p><p id="9147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我把这些作为练习留给读者。</p><h1 id="0e9d" class="ml mc iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">进一步阅读</h1><p id="fd91" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这个演示使用了JavaScript和PouchDB。我喜欢浏览器内演示，因为它们是如此的可移植:你总是有一个可用的IDE和运行时环境。</p><p id="afb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PouchDB是CouchDB的一个JavaScript实现，为了将该解决方案扩展到企业级有用的东西，一个大规模的CouchDB实现将是一个良好的开端。</p><p id="dcd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样值得一提的是，这种技术并不局限于任何特定的系统。同样的技术可以在操作系统级别使用<a class="ae kv" href="https://www.howtogeek.com/287014/how-to-create-and-use-symbolic-links-aka-symlinks-on-linux/" rel="noopener ugc nofollow" target="_blank">符号或硬链接</a>来实现。事实上，数据库和FS存储的某些组合可能是一种优化的方式。</p><ul class=""><li id="25d8" class="ok ol iq ky b kz la lc ld lf om lj on ln oo lr op oq or os bi translated">手册:<a class="ae kv" href="https://docs.couchdb.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> Apache CouchDB </a>，<a class="ae kv" href="https://www.ibm.com/cloud/cloudant" rel="noopener ugc nofollow" target="_blank"> IBM CloudAnt </a>，<a class="ae kv" href="https://docs.couchbase.com/home/index.html" rel="noopener ugc nofollow" target="_blank"> CouchBase </a></li><li id="9ea2" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">创建索引:<a class="ae kv" href="https://pouchdb.com/2014/05/01/secondary-indexes-have-landed-in-pouchdb.html" rel="noopener ugc nofollow" target="_blank">二级索引已经在PouchDB </a>中登陆</li><li id="9616" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated"><a class="ae kv" href="https://www.howtogeek.com/287014/how-to-create-and-use-symbolic-links-aka-symlinks-on-linux/" rel="noopener ugc nofollow" target="_blank">如何在Linux上创建和使用符号链接</a></li><li id="8785" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated"><a class="ae kv" href="https://itsfoss.com/what-is-zfs/" rel="noopener ugc nofollow" target="_blank">什么是ZFS？</a>内置了重复数据删除功能的文件系统</li></ul></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><p id="b8bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">续集还讨论了随着时间的推移，如何有效地存储相同的数据集。</p><blockquote class="nu"><p id="069b" class="nv nw iq bd nx ny nz oa ob oc od lr dk translated"><a class="ae kv" href="https://jefferey-cave.medium.com/not-storing-almost-the-same-file-twice-9a44e3179a6a" rel="noopener">删除重复数据存储II:将(几乎)相同的文件存储两次</a></p></blockquote><p id="aacf" class="pw-post-body-paragraph kw kx iq ky b kz oe jr lb lc of ju le lf og lh li lj oh ll lm ln oi lp lq lr ij bi translated"><em class="pf">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pf">plain English . io</em></strong></a><em class="pf">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pf">免费周报</em> </strong> </a> <em class="pf">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pf">Twitter</em></strong></a><em class="pf">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pf">LinkedIn</em></strong></a><em class="pf">。加入我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="pf">社区不和谐</em> </strong> </a> <em class="pf">。</em></p></div></div>    
</body>
</html>