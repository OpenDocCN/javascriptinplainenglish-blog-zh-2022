<html>
<head>
<title>How to Fetch Data in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中获取数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-fetch-data-in-react-d59d6ee09aaf?source=collection_archive---------1-----------------------#2022-07-20">https://javascript.plainenglish.io/how-to-fetch-data-in-react-d59d6ee09aaf?source=collection_archive---------1-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1a98" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在React中从API获取数据的5种方法(附示例)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f7d66a13726abdf32132ee65827bac71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrqD0RYbgz26RJMbUAGPpQ.png"/></div></div></figure><p id="78ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将向您展示在React中从API获取数据的五种不同方式:</p><ol class=""><li id="3f41" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">获取API</li><li id="223d" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">异步等待语法</li><li id="daef" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">Axios库</li><li id="bd79" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">自定义挂钩(使用Fetch)</li><li id="d322" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">React查询库</li></ol><p id="b8f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在示例中，我们将使用随机数据生成器。API端点如下:<a class="ae mb" href="https://random-data-api.com/api/food/random_food" rel="noopener ugc nofollow" target="_blank">https://random-data-api.com/api/food/random_food</a>，它返回关于不同食物的随机数据😋。</p><h1 id="a20b" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">1.获取API</h1><p id="7561" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated"><strong class="kt ir">获取API </strong>可能是React中获取数据的最基本方式。<br/>这个工具内置在大多数现代浏览器的窗口对象(window.fetch)上，允许我们使用<code class="fe mz na nb nc b">GET</code>、<code class="fe mz na nb nc b">POST</code>和其他方法发出HTTP请求。</p><p id="1c78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们定义一个名为<code class="fe mz na nb nc b">getData()</code>的箭头函数，它使用fetch发出一个简单的<code class="fe mz na nb nc b">GET</code>请求。</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="6e03" class="nh md iq nc b gy ni nj l nk nl">const getData = () =&gt; {<br/> return fetch('<a class="ae mb" href="https://random-data-api.com/api/food/random_food" rel="noopener ugc nofollow" target="_blank">https://random-data-api.com/api/food/random_food</a>')<br/>  .then((response) =&gt; response.json())<br/>  .then((data) =&gt; console.log(data));<br/>};</span></pre><p id="9b7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数将URL端点传递给fetch方法，然后接受<code class="fe mz na nb nc b">Response</code>对象，将结果转换成JSON对象并打印到控制台。</p><p id="51ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们知道了它是如何工作的，让我们尝试使用<code class="fe mz na nb nc b">fetch()</code>来显示组件内部的一些数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Fetch API example</figcaption></figure><p id="c547" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个<code class="fe mz na nb nc b">App</code>组件中，我们定义了启动请求并返回承诺的<code class="fe mz na nb nc b">fetchFood()</code>函数。当请求完成时，用<code class="fe mz na nb nc b">Response</code>对象解析承诺。如果响应成功，(<code class="fe mz na nb nc b">response.ok</code>)，我们使用<code class="fe mz na nb nc b">json()</code>方法将响应转换成JSON数据。这将返回一个包含我们从随机食品API中获取的数据的承诺。在<code class="fe mz na nb nc b">then()</code>方法中，我们使用<code class="fe mz na nb nc b">setFood()</code>将食物的状态设置为新数据。</p><p id="3118" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果请求由于网络问题而失败，则承诺会被拒绝。<br/>使用fetch，我们需要自己处理错误，所以我们抛出<code class="fe mz na nb nc b">response</code>作为要由<code class="fe mz na nb nc b">catch</code>回调处理的错误，这里我们将状态中“error”的值设置为承诺的错误值。</p><p id="24f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当承诺兑现时，无论成功与否，我们都知道它不再装载。<br/>我们使用<code class="fe mz na nb nc b">.finally()</code>回调将<code class="fe mz na nb nc b">loading</code>设置为false，因此我们不再看到我们的加载文本。</p><p id="fadc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果请求成功，我们将在页面上看到数据。否则，将显示带有错误状态的“错误”字样。</p><p id="3c7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在我们的反应组件挂载后发出这个请求，我们在<code class="fe mz na nb nc b">useEffect()</code>中调用<code class="fe mz na nb nc b">fetchFood()</code>函数，并确保提供一个空的依赖数组作为第二个参数，这样我们的请求只发出一次。</p><p id="0782" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击“新盘”按钮，我们再次调用<code class="fe mz na nb nc b">fetchFood()</code>功能，提出新的请求，获取新的数据。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="7467" class="mc md iq bd me mf nz mh mi mj oa ml mm jw ob jx mo jz oc ka mq kc od kd ms mt bi translated">2.异步等待语法</h1><p id="b6b7" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated"><code class="fe mz na nb nc b">async/await</code>语法非常适合<code class="fe mz na nb nc b">fetch()</code>，因为它通过承诺简化了工作。</p><p id="63d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">主要的好处是，它允许我们删除<code class="fe mz na nb nc b">then()</code>回调，并简单地取回异步解析的数据。</p><p id="d920" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，<code class="fe mz na nb nc b">await</code>表达式通过暂停执行直到返回的承诺被实现或拒绝，使得承诺返回函数表现得好像它们是同步的。</p><p id="0385" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们提出请求时，我们可以在<code class="fe mz na nb nc b">fetch()</code>前面添加<code class="fe mz na nb nc b">await</code>，等待承诺与结果达成一致。</p><p id="31a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要使用这个语法，我们必须在<code class="fe mz na nb nc b">async</code>内部调用它，所以我们必须在<code class="fe mz na nb nc b">getchData()</code>函数前面添加<code class="fe mz na nb nc b">async </code>。</p><p id="ee3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们用这个新语法重写我们的<code class="fe mz na nb nc b">getData()</code>:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="4164" class="nh md iq nc b gy ni nj l nk nl"><em class="oe">async</em> function getData() {<br/> try { <br/>  const response = await fetch('<a class="ae mb" href="https://random-data-api.com/api/food/random_food" rel="noopener ugc nofollow" target="_blank">https://random-data-api.com/api/food/random_food</a>');<br/>  if (!response.ok) {<br/>   throw new Error(`HTTP error: ${response.status}`);<br/>  }<br/>  const data = await response.json();<br/>  console.log(data);<br/> } catch (error) {<br/>  console.error(`Something went wrong: ${error}`);<br/> }<br/>}</span></pre><p id="a099" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以对我们的<code class="fe mz na nb nc b">App</code>组件进行同样的重构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Async-await example</figcaption></figure><p id="8a38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">fetchFood()</code>现在是一个异步函数，因为它用<code class="fe mz na nb nc b">async</code>关键字标记，我们可以删除回调，简单地取回异步解析的数据。</p><p id="18e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的是，当我们使用<code class="fe mz na nb nc b">useEffect</code>钩子时，效果功能不能被<code class="fe mz na nb nc b">async</code>实现。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="9caa" class="mc md iq bd me mf nz mh mi mj oa ml mm jw ob jx mo jz oc ka mq kc od kd ms mt bi translated">3.Axios库</h1><p id="700f" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">Axios是一个基于承诺的Javascript库，用于执行HTTP请求。它的工作方式与Fetch API非常相似，但是主要的好处是它已经将结果作为JSON对象返回，所以我们不需要对其进行转换。</p><p id="4ca9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要使用这个库，我们必须用npm安装它:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="72cd" class="nh md iq nc b gy ni nj l nk nl">npm install axios</span></pre><p id="bab5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以将其导入到我们的项目中，并在相同的函数<code class="fe mz na nb nc b">getData()</code>中使用，而不是<code class="fe mz na nb nc b">fetch()</code>方法:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="427e" class="nh md iq nc b gy ni nj l nk nl">import axios from "axios"</span><span id="eac0" class="nh md iq nc b gy of nj l nk nl">const getData = () =&gt; {<br/> return <!-- -->axios.get<!-- -->('<a class="ae mb" href="https://random-data-api.com/api/food/random_food" rel="noopener ugc nofollow" target="_blank">https://random-data-api.com/api/food/random_food</a>')<br/>  .then((response) =&gt; console.log(response.data));<br/>};</span></pre><p id="9294" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Axios，我们可以编写更少的代码，此外，这个库包含了许多简单的Fetch所没有的工具和特性。</p><p id="8cca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们也使用Axios修改<code class="fe mz na nb nc b">App</code>组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Axios example</figcaption></figure><p id="e4c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与<code class="fe mz na nb nc b">fetch()</code>方法相比，这种方法更简单明了。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="12b0" class="mc md iq bd me mf nz mh mi mj oa ml mm jw ob jx mo jz oc ka mq kc od kd ms mt bi translated">4.自定义钩子(useFetch)</h1><p id="9fa0" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我们可以使用来自<code class="fe mz na nb nc b">react-fetch-hook</code>库的<code class="fe mz na nb nc b">useFetch</code>钩子来进一步简化数据获取。<br/>这已经包括了我们可以用来处理错误的属性，比如<code class="fe mz na nb nc b">isLoading</code>和<code class="fe mz na nb nc b">error</code>。</p><p id="49bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们必须用npm安装库:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="cdba" class="nh md iq nc b gy ni nj l nk nl">npm install react-fetch-hook</span></pre><p id="433f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们可以将它导入到组件中:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="edba" class="nh md iq nc b gy ni nj l nk nl">import useFetch from "react-fetch-hook";</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Custom hooks (useFetch) example</figcaption></figure><p id="4f28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以将端点URL传递给对象的<code class="fe mz na nb nc b">useFetch</code>钩子和析构函数<code class="fe mz na nb nc b">data, isLoading, error</code>，然后我们可以在渲染中使用它们。</p><p id="2520" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，我们不需要在本地状态中处理数据、加载和错误，而是直接从我们的请求中获取它们。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="0fd5" class="mc md iq bd me mf nz mh mi mj oa ml mm jw ob jx mo jz oc ka mq kc od kd ms mt bi translated">5.反应查询</h1><p id="eb0d" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我最喜欢在React中获取数据的方式是使用<code class="fe mz na nb nc b">react-query</code>库。它支持缓存和重新提取，帮助开发人员改善整体用户体验，并使我们的应用程序更快。</p><p id="7d85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们安装它:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="28af" class="nh md iq nc b gy ni nj l nk nl">npm i react-query</span></pre><p id="6716" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，在<code class="fe mz na nb nc b">index.js</code>文件中，我们必须用从<code class="fe mz na nb nc b">react-query</code>导入的<code class="fe mz na nb nc b">QueryClientProvider</code>包装我们的<code class="fe mz na nb nc b">App</code>组件，并将客户端实例传递给它:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="34d5" class="nh md iq nc b gy ni nj l nk nl">import { StrictMode } from "react";<br/>import { createRoot } from "react-dom/client";<br/>import { QueryClient, QueryClientProvider } from "react-query";<br/>import { ReactQueryDevtools } from "react-query/devtools";<br/>import App from "./App";</span><span id="911b" class="nh md iq nc b gy of nj l nk nl"><em class="oe">// Create a client<br/></em>const queryClient = new QueryClient();</span><span id="9de3" class="nh md iq nc b gy of nj l nk nl">const rootElement = document.getElementById("root");<br/>const root = createRoot(rootElement);</span><span id="f264" class="nh md iq nc b gy of nj l nk nl">root.render(<br/>  <em class="oe">// Provide the client to your App<br/>  </em>&lt;StrictMode&gt;<br/>    &lt;QueryClientProvider client={queryClient}&gt;<br/>      &lt;App /&gt;<br/>      &lt;ReactQueryDevtools initialIsOpen={false} /<br/>    &lt;/QueryClientProvider&gt;<br/>  &lt;/StrictMode&gt;<br/>);</span></pre><p id="3b15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React Query提供了一个定制的钩子，我们可以在组件之间重用它来获取数据。</p><p id="a2dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它还为我们提供了<code class="fe mz na nb nc b">ReactQueyDevtools</code>，一种控制何时、如何以及多久获取一次数据的好方法。</p><p id="adc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看这个库在我们的<code class="fe mz na nb nc b">App</code>组件中的运行情况。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9a3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了获取数据，我们从<code class="fe mz na nb nc b">react-query</code>调用<code class="fe mz na nb nc b">useQuery</code>钩子，并传递一个惟一的查询键(在本例中为“random-food”)和一个查询用来获取数据的函数:</p><p id="936f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以析构返回的对象，并在渲染中使用我们需要的信息。</p><p id="a1ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React Query，首先尝试从其缓存中提供我们的数据，然后，如果我们的API状态发生了变化，则在后台更新数据以显示变化。</p><p id="63ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，通过引用我们在钩子中传递的查询键，我们可以重新提取、验证或重置查询，如<code class="fe mz na nb nc b">refetchData</code>函数所示:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="c6dd" class="nh md iq nc b gy ni nj l nk nl">const refetchData = () =&gt; {<br/>  queryClient.invalidateQueries("random-food");<br/>};</span></pre><p id="3fdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React Query经常被描述为React缺少的数据获取库，因为它使React应用程序中的获取、缓存、同步和更新服务器状态变得轻而易举。你可以在这里读到它所有的优点<a class="ae mb" href="https://tanstack.com/query/v4/docs/overview?from=reactQueryV3&amp;original=https://react-query-v3.tanstack.com/overview" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="2151" class="nh md iq bd me og oh dn mi oi oj dp mm la ok ol mo le om on mq li oo op ms oq bi translated"><strong class="ak">结论</strong></h2><p id="14a8" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我希望这篇文章能教会你一些东西。如果你知道从API获取数据的其他方法，请在评论中添加！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="711f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="oe">考虑</em> <a class="ae mb" href="https://ebelinggianmarco.medium.com/membership" rel="noopener"> <strong class="kt ir"> <em class="oe">成为中等成员</em></strong></a><strong class="kt ir"><em class="oe"/></strong><em class="oe">如果你喜欢看这样的故事，并且想帮助我这个作家。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae mb" href="https://ebelinggianmarco.medium.com/membership" rel="noopener"> <strong class="kt ir"> <em class="oe">我的链接注册，我会得到一点佣金。</em> </strong> </a></p><p id="e94c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="oe">更多内容请看</em> <a class="ae mb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oe">说白了就是</em> </strong> </a> <em class="oe">。报名参加我们的</em> <a class="ae mb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oe">免费每周简讯</em> </strong> </a> <em class="oe">。关注我们</em><a class="ae mb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oe">Twitter</em></strong></a><em class="oe">和</em><a class="ae mb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oe">LinkedIn</em></strong></a><em class="oe">。查看我们的</em> <a class="ae mb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oe">社区不和谐</em> </strong> </a> <em class="oe">加入我们的</em> <a class="ae mb" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oe">人才集体</em> </strong> </a> <em class="oe">。</em></p></div></div>    
</body>
</html>