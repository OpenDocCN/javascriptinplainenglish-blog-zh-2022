<html>
<head>
<title>How to Make a JavaScript Roguelike Scroll</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作一个JavaScript Roguelike卷轴</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-scrolling-to-a-javascript-roguelike-c9f835d10537?source=collection_archive---------14-----------------------#2022-06-08">https://javascript.plainenglish.io/how-to-add-scrolling-to-a-javascript-roguelike-c9f835d10537?source=collection_archive---------14-----------------------#2022-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/484b40c9644b7ad43f6807de59d9bd0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOKAIYqFo2gO-e-_x0r_WQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mitchel3uo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mitchell Luo</a> on <a class="ae kc" href="https://unsplash.com/s/photos/maze?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1557" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你不知道拐角处有什么的时候，地牢会更有趣。在本教程中，我们将为一种叫做<em class="lb"> roguelike </em>的游戏添加滚动，这种游戏有机器生成的关卡。下面是<a class="ae kc" href="https://gregarious-paletas-7a58d5.netlify.app/project/index.html" rel="noopener ugc nofollow" target="_blank">初始游戏</a>的一个动画，展示了完整的地下城地图。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The initial game without scrolling</figcaption></figure><p id="1c10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一张<a class="ae kc" href="https://gregarious-paletas-7a58d5.netlify.app/phase-3-solution/index.html" rel="noopener ugc nofollow" target="_blank">成品版</a>的动画，带有一个滚动的小显示屏。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="li lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The finished solution with scrolling.</figcaption></figure><p id="0085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将分三个阶段添加我们的滚动逻辑。</p><ul class=""><li id="bab5" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated">1)让游戏一直滚动。</li><li id="9e84" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">2)只有当玩家离中心足够远时，才使游戏滚动。</li><li id="57ab" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">3)让游戏只显示部分地图。</li></ul></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="80e9" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">入门指南</h1><p id="c8fc" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">要构建这个特性，请从<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-scroll" rel="noopener ugc nofollow" target="_blank"> Github </a>下载<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-scroll/archive/refs/heads/main.zip" rel="noopener ugc nofollow" target="_blank">项目压缩文件</a>。在解压之后，您会发现一个<code class="fe nh ni nj nk b">project</code>目录和每个阶段的解决方案目录。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="b4bf" class="np mf iq nk b gy nq nr l ns nt">js-roguelike-scroll<br/>  |<br/>  *--project<br/>  |<br/>  *--phase-1-solution<br/>  |<br/>  *--phase-2-solution<br/>  |<br/>  *--phase-3-solution<br/>  |<br/>  *--challenge-solution<br/>  |<br/>  *--js<br/>  |<br/>  *--css</span></pre><p id="d244" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nh ni nj nk b">css</code>和<code class="fe nh ni nj nk b">js</code>目录下有所有游戏版本使用的文件，比如<code class="fe nh ni nj nk b">game.js</code>。</p><p id="b01e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nh ni nj nk b">project</code>目录中有一个显示游戏的<code class="fe nh ni nj nk b">index.html</code>和一个用于工作的<code class="fe nh ni nj nk b">script.js</code>文件。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="555d" class="np mf iq nk b gy nq nr l ns nt">project<br/>  |<br/>  *--index.html<br/>  |<br/>  *--script.js</span></pre><p id="b574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看与新的滚动特性相关的两个类:<code class="fe nh ni nj nk b">game</code>类和<code class="fe nh ni nj nk b">player</code>类。</p><h2 id="c00d" class="np mf iq bd mg nu nv dn mk nw nx dp mo ko ny nz ms ks oa ob mw kw oc od na oe bi translated">游戏课</h2><p id="0b30" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">从<code class="fe nh ni nj nk b">game.js</code>中的<a class="ae kc" href="https://gist.github.com/nevkatz/9329f6f243effbd801a21d5d661920bb#file-roguelike-game-with-offset-js" rel="noopener ugc nofollow" target="_blank">游戏类</a>创建的全局对象存储游戏的属性——包括用于滚动的<code class="fe nh ni nj nk b">offset</code>属性。<code class="fe nh ni nj nk b">canvas</code>属性引用了<code class="fe nh ni nj nk b">&lt;canvas&gt;</code>元素，而<code class="fe nh ni nj nk b">context</code>存储了一组绘图方法。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/31f92cebbe84b43809425ce7c6593983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*WZuha8PNeUg2Tl2dcMRpIw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A partial depiction of the game class.</figcaption></figure><p id="ef27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">游戏的<code class="fe nh ni nj nk b">map</code>属性将地牢地图存储在一个2D数组中。如果一个3x3的房间位于一个5x5地图的中心，那么<code class="fe nh ni nj nk b">map</code>阵列将类似于下图。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/278f0c961459c5cb7076187cf1e67ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*KC8qBNVLc4hSP5WxaSi4nA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A simple 2D map array.</figcaption></figure><h2 id="b50a" class="np mf iq bd mg nu nv dn mk nw nx dp mo ko ny nz ms ks oa ob mw kw oc od na oe bi translated">玩家阶层</h2><p id="f39c" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated"><code class="fe nh ni nj nk b">script.js</code>中的<a class="ae kc" href="https://gist.github.com/nevkatz/7058f2903e955e79a29b2a5a96b7dfcd#file-roguelike-player-with-relics-js" rel="noopener ugc nofollow" target="_blank">播放器类</a>用于创建一个<code class="fe nh ni nj nk b">player</code>对象。一个<code class="fe nh ni nj nk b">coords</code>属性存储了决定玩家位置的<code class="fe nh ni nj nk b">x</code>和<code class="fe nh ni nj nk b">y</code>坐标。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b9d7f1a669d4483e477872ef384f0643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*NuqZm3PF4hVReIANrGFBaA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The player class</figcaption></figure><p id="2da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经复习了这些课程，让我们开始第一阶段。随着您的进展，您可以检查每个已完成阶段的<a class="ae kc" href="https://roguelike-scroll.netlify.app/" rel="noopener ugc nofollow" target="_blank">演示</a>。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="d02d" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">阶段1:一直滚动</h1><p id="5d72" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我们的工作将在<code class="fe nh ni nj nk b">project</code>目录的<code class="fe nh ni nj nk b">script.js</code>中进行。让我们先来看看玩家移动是如何工作的，并添加一些基本的滚动。</p><h2 id="1642" class="np mf iq bd mg nu nv dn mk nw nx dp mo ko ny nz ms ks oa ob mw kw oc od na oe bi translated">开始游戏</h2><p id="ae24" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在<code class="fe nh ni nj nk b">script,js</code>中，<code class="fe nh ni nj nk b">init</code>函数准备好了<code class="fe nh ni nj nk b">&lt;canvas&gt;</code>元素并添加了一个键盘监听器。侦听器被绑定到一个名为<code class="fe nh ni nj nk b">checkDirection</code>的事件处理程序。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The init function</figcaption></figure><h2 id="a2e0" class="np mf iq bd mg nu nv dn mk nw nx dp mo ko ny nz ms ks oa ob mw kw oc od na oe bi translated">移动玩家</h2><p id="063b" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在<code class="fe nh ni nj nk b">checkDirection</code>开始时，我们将玩家的坐标存储在两个<code class="fe nh ni nj nk b">x</code>和<code class="fe nh ni nj nk b">y</code>变量中。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="91da" class="np mf iq nk b gy nq nr l ns nt">function checkDirection(e) {</span><span id="99ce" class="np mf iq nk b gy oj nr l ns nt">   e.preventDefault();</span><span id="cfb8" class="np mf iq nk b gy oj nr l ns nt"><strong class="nk ir">   let {x, y} = player.coords;</strong></span></pre><p id="93aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，使用下面的<code class="fe nh ni nj nk b">switch</code>块，我们根据按下的键的代码调整<code class="fe nh ni nj nk b">x</code>或<code class="fe nh ni nj nk b">y</code>变量。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Basic switch statement.</figcaption></figure><p id="0bd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果玩家最终移动，它的<code class="fe nh ni nj nk b">coords</code>属性会根据这些<code class="fe nh ni nj nk b">x</code>和<code class="fe nh ni nj nk b">y</code>坐标进行更新。</p><h2 id="3a2b" class="np mf iq bd mg nu nv dn mk nw nx dp mo ko ny nz ms ks oa ob mw kw oc od na oe bi translated">添加滚动行为</h2><p id="afd8" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">好了，我们开始工作吧。为了支持滚动，让我们在玩家每次移动时更改游戏的<code class="fe nh ni nj nk b">offset</code>属性。在<code class="fe nh ni nj nk b">checkDirection</code>中，初始化<code class="fe nh ni nj nk b">x</code>和<code class="fe nh ni nj nk b">y</code>后，我们将声明一个临时的<code class="fe nh ni nj nk b">offset</code>变量。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The start to checkDirection with the offset variable added.</figcaption></figure><p id="46a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe nh ni nj nk b">switch</code>语句中，我们将在每种情况下调整<code class="fe nh ni nj nk b">offset</code>,这样游戏地图就会向玩家移动的相反方向移动。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div></figure><p id="96af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nh ni nj nk b">switch</code>块下面，让我们添加两行，如果玩家移动，它们将调整游戏的<code class="fe nh ni nj nk b">offset</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Adding offset logic</figcaption></figure><h2 id="74a3" class="np mf iq bd mg nu nv dn mk nw nx dp mo ko ny nz ms ks oa ob mw kw oc od na oe bi translated">绘制地图</h2><p id="c8b3" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">一个名为<code class="fe nh ni nj nk b">movePlayer</code>的函数处理碰撞和玩家移动。在<code class="fe nh ni nj nk b">movePlayer</code>结束时，一个名为<code class="fe nh ni nj nk b">drawMap</code>的函数只重新渲染玩家磁贴及其周围的48。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/5b0ea7d1cd4742359579c778208d50e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*NI_-Rrsq4ciBjWBn1lINPg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The end of movePlayer.</figcaption></figure><p id="4349" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为游戏现在滚动了，所以让我们换一个<code class="fe nh ni nj nk b">drawMap</code>调用来重绘地图上的每一个方块。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="4c4d" class="np mf iq nk b gy nq nr l ns nt">// drawMap(left, top, right, bot);</span><span id="340c" class="np mf iq nk b gy oj nr l ns nt"><strong class="nk ir">drawMap(0, 0, COLS, ROWS);</strong></span></pre><p id="a8e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当玩家移动时，地图应该完全重新渲染。</p><p id="2786" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了渲染滚动效果，我们需要改变地图的绘制方式。当<code class="fe nh ni nj nk b">drawMap</code>被调用时，它使用一个嵌套循环来遍历瓦片。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The drawMap function.</figcaption></figure><p id="e47b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在上面看到，每次重新渲染一个图块，都会调用<code class="fe nh ni nj nk b">drawObject</code>，在<code class="fe nh ni nj nk b">&lt;canvas&gt;</code>元素上绘制一个图块。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The drawObject function.</figcaption></figure><p id="58c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们调整<code class="fe nh ni nj nk b">drawObject</code>,以便在绘制每个图块时考虑游戏对象的<code class="fe nh ni nj nk b">offset</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Our object drawing function with offset logic added.</figcaption></figure><p id="6da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，您应该已经有了基本的滚动功能。请随意将其与<a class="ae kc" href="https://roguelike-scroll.netlify.app/phase-1-solution/index.html" rel="noopener ugc nofollow" target="_blank">第一阶段解决方案</a>和下面的动画进行比较。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Solution 1 with basic scrolling.</figcaption></figure></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="5ae8" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">阶段2:条件滚动</h1><p id="67ac" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">通常没有必要让游戏一直滚动，所以让它只在玩家离画布中心足够远的时候滚动。换句话说，如果玩家正在触摸下面蓝框代表的区域的边界，游戏就会滚动；否则玩家移动，地图保持不动。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/465904babc882393645e917e59630877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmBF7bWcwoM8b5HzDrPq2A.png"/></div></div></figure><p id="f8da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nh ni nj nk b">script.js</code>的顶部，让我们添加一个名为<code class="fe nh ni nj nk b">CENTER_BOX</code>的常量，它将指定这个盒子的尺寸。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="50be" class="np mf iq nk b gy nq nr l ns nt">const CENTER_BOX = {<br/>    x: 12,<br/>    y: 12<br/>}</span></pre><p id="6ddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要知道玩家相对于地图上显示部分的假想方块的位置。所以回到<code class="fe nh ni nj nk b">checkDirection</code>，让我们添加一个名为<code class="fe nh ni nj nk b">absPos</code>的新temp对象，它捕获玩家在<code class="fe nh ni nj nk b">&lt;canvas&gt;</code>元素上的绝对位置。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="f2cf" class="np mf iq nk b gy nq nr l ns nt">let {x, y} = player.coords;</span><span id="9d6b" class="np mf iq nk b gy oj nr l ns nt">let offset = {<br/>    x: 0,<br/>    y: 0<br/>};</span><span id="46a3" class="np mf iq nk b gy oj nr l ns nt"><strong class="nk ir">let absPos = {<br/>     x: x + game.offset.x,<br/>     y: y + game.offset.y<br/>};</strong></span></pre><p id="e1a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在向左移动的情况下，让我们将中心框的左边缘存储在一个<code class="fe nh ni nj nk b">leftBounds</code>常量中。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="6509" class="np mf iq nk b gy nq nr l ns nt">case 37:<br/>  x--;<br/><strong class="nk ir">  const leftBounds = (COLS - CENTER_BOX.x) / 2;</strong></span></pre><p id="1629" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当玩家向左移动时，只有当玩家在<code class="fe nh ni nj nk b">leftBounds</code>时，让游戏向右移动。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="e192" class="np mf iq nk b gy nq nr l ns nt">case 37:<br/>    x--;</span><span id="09ae" class="np mf iq nk b gy oj nr l ns nt"><strong class="nk ir">    </strong>const leftBounds = (COLS - CENTER_BOX.x) / 2;</span><span id="eb77" class="np mf iq nk b gy oj nr l ns nt"> <strong class="nk ir">   if (absPos.x &lt;= leftBounds) {</strong><br/>         offset.x = 1;<br/>   <strong class="nk ir"> }</strong></span><span id="fb03" class="np mf iq nk b gy oj nr l ns nt">break;</span></pre><p id="8b68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为玩家用一个<code class="fe nh ni nj nk b">upperBounds</code>常量上移时添加类似的逻辑。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="58d1" class="np mf iq nk b gy nq nr l ns nt">case 38: // up<br/>    y--;</span><span id="2c37" class="np mf iq nk b gy oj nr l ns nt">    const upperBounds = (HEIGHT - CENTER_BOX.y) / 2;</span><span id="1e0b" class="np mf iq nk b gy oj nr l ns nt"><strong class="nk ir">  </strong>  if (absPos.y &lt;= upperBounds) {<br/>         offset.y = 1;<br/>    }<br/>break;</span></pre><p id="96be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们加上当玩家向右移动时的等价条件。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="b06e" class="np mf iq nk b gy nq nr l ns nt">case 37: // left<br/>   x--;</span><span id="6a72" class="np mf iq nk b gy oj nr l ns nt">   const rightBounds = (COLS + CENTER_BOX.x) / 2;</span><span id="10c5" class="np mf iq nk b gy oj nr l ns nt">   if (absPos.x &gt;= rightBounds) {<br/>       offset.x = -1;<br/>   }<br/>break;</span></pre><p id="ba14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们来处理玩家向下移动。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="4e88" class="np mf iq nk b gy nq nr l ns nt">case 40: // down</span><span id="6748" class="np mf iq nk b gy oj nr l ns nt">  y++;</span><span id="a58e" class="np mf iq nk b gy oj nr l ns nt">  const lowerBounds = (ROWS + CENTER_BOX.y) / 2;</span><span id="955c" class="np mf iq nk b gy oj nr l ns nt">  if (absPos.y &gt;= lowerBounds) {<br/>           offset.y = -1;<br/>  }</span><span id="d6dc" class="np mf iq nk b gy oj nr l ns nt">break;</span></pre><h2 id="39ec" class="np mf iq bd mg nu nv dn mk nw nx dp mo ko ny nz ms ks oa ob mw kw oc od na oe bi translated">移动玩家</h2><p id="6400" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在<code class="fe nh ni nj nk b">movePlayer</code>中，让我们添加一些控制地图更新方式的条件。</p><p id="1326" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果偏移量有变化，那就意味着地图在滚动，所以我们要重画整个地图。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="c18b" class="np mf iq nk b gy nq nr l ns nt">if (offset.x != 0 || offset.y != 0) {<br/>     drawMap(0, 0, COLS, ROWS);<br/>}</span></pre><p id="43e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果偏移量没有变化，我们就不滚动，所以我们只需要重画靠近玩家的瓷砖。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="bee4" class="np mf iq nk b gy nq nr l ns nt">else {<br/>    let left = oldX - 1;<br/>    let top = oldY - 1;<br/>    let right = x + 2;<br/>    let bot = y + 2;<br/>    drawMap(left, top, right, bot); <br/>}</span></pre><p id="89d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你的游戏应该只在玩家离游戏中心足够远的时候滚动。继续将它与<a class="ae kc" href="https://roguelike-scroll.netlify.app/phase-2-solution/index.html" rel="noopener ugc nofollow" target="_blank">第二阶段解决方案</a>和下面的动画进行比较。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="om lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Solution 2 with conditional scrolling.</figcaption></figure></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="fdc5" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">阶段3:改变游戏尺寸</h1><p id="3cb8" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我们现在的目标是只显示地图的一部分——所以在<code class="fe nh ni nj nk b">script.js</code>的顶部，让我们用两个常量指定可见部分的宽度和高度。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="3a0c" class="np mf iq nk b gy nq nr l ns nt">const WIDTH = 50;<br/>const HEIGHT = 30;</span></pre><p id="0874" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使可见部分具有这些尺寸，我们将在<code class="fe nh ni nj nk b">createDOM</code>函数中用<code class="fe nh ni nj nk b">WIDTH</code>替换<code class="fe nh ni nj nk b">COLS</code>，用<code class="fe nh ni nj nk b">HEIGHT</code>替换<code class="fe nh ni nj nk b">ROWS</code>，在这里我们设置<code class="fe nh ni nj nk b">&lt;canvas&gt;</code>尺寸。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="b107" class="np mf iq nk b gy nq nr l ns nt">canvas.height = <strong class="nk ir">HEIGHT</strong> * TILE_DIM;<br/>canvas.width = <strong class="nk ir">WIDTH</strong> * TILE_DIM;</span></pre><p id="0c25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nh ni nj nk b">checkDirection</code>中，我们将把<code class="fe nh ni nj nk b">WIDTH</code>或<code class="fe nh ni nj nk b">HEIGHT</code>换入<code class="fe nh ni nj nk b">switch</code>语句的每个案例中。例如，在下面的<code class="fe nh ni nj nk b">left</code>案例中，我们换入<code class="fe nh ni nj nk b">WIDTH</code>。</p><pre class="lc ld le lf gt nl nk nm nn aw no bi"><span id="00ef" class="np mf iq nk b gy nq nr l ns nt">case 37: // left<br/>let leftBounds = (<strong class="nk ir">WIDTH</strong> - STATIC_DIM.x) / 2;<br/>            <br/>if (absPos.x &lt;= leftBounds) {<br/>    offset.x = 1;<br/>}<br/>break;</span></pre><p id="52c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续并在<code class="fe nh ni nj nk b">up</code>、<code class="fe nh ni nj nk b">right</code>和<code class="fe nh ni nj nk b">down</code>情况下交换<code class="fe nh ni nj nk b">WIDTH</code>或<code class="fe nh ni nj nk b">HEIGHT</code>。</p><h2 id="e44c" class="np mf iq bd mg nu nv dn mk nw nx dp mo ko ny nz ms ks oa ob mw kw oc od na oe bi translated">以玩家为中心</h2><p id="0520" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">因为当我们开始时，玩家可能在我们的可视区域之外，所以让我们在开始时移动地图的位置，这样玩家就从显示的中心开始。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The function for centering the player at the game’s outset.</figcaption></figure><p id="fcdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在我们的<code class="fe nh ni nj nk b">startGame</code>函数中调用<code class="fe nh ni nj nk b">centerPlayer</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oi lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The startGame function with centerPlayer.</figcaption></figure><p id="074f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在显示屏应该比游戏地图小了。请随意将您的工作与<a class="ae kc" href="https://roguelike-scroll.netlify.app/phase-3-solution/index.html" rel="noopener ugc nofollow" target="_blank">第三阶段解决方案</a>和下面的动画进行比较。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="li lh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The phase 3 solution with a smaller display and conditional scrolling.</figcaption></figure><p id="9127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想继续吗？下一步可能是添加<a class="ae kc" href="https://roguelike-scroll.netlify.app/challenge-solution/index.html" rel="noopener ugc nofollow" target="_blank">挑战解决方案</a>中的“切换阴影”功能，将可见地牢限制在玩家周围的一个小方块内。</p><p id="8cf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这个教程。欢迎在下面提问，祝你愉快。</p><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-add-collectible-items-in-a-javascript-roguelike-93d934b499b8"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">如何在JavaScript Roguelike中添加遗迹</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">让我们用策略性放置的物品来鼓励探索吧！</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe jw oq"/></div></div></a></div><p id="15b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">plain English . io</em></strong></a><em class="lb">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">免费周报</em> </strong> </a> <em class="lb">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">Twitter</em></strong></a><em class="lb">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">LinkedIn</em></strong></a><em class="lb">。查看我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">社区不和谐</em> </strong> </a> <em class="lb">加入我们的</em> <a class="ae kc" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">人才集体</em> </strong> </a> <em class="lb">。考虑加入</em> <a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"> <strong class="kf ir"> <em class="lb">介质</em> </strong> </a> <em class="lb">。</em></p></div></div>    
</body>
</html>