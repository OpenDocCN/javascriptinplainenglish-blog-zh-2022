<html>
<head>
<title>DevOps JavaScript — Intro to Writing Scripts With zx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">devo PS JavaScript——用zx编写脚本简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/devops-javascript-intro-to-writing-scripts-with-zx-8246c05b6cff?source=collection_archive---------20-----------------------#2022-03-15">https://javascript.plainenglish.io/devops-javascript-intro-to-writing-scripts-with-zx-8246c05b6cff?source=collection_archive---------20-----------------------#2022-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6258" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过使用zx.js编写脚本成为一名JavaScript DevOps工程师。</h2></div><p id="109d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以你只是在同一个句子里读了DevOps和JavaScript。你是疯了还是极度好奇？无论如何，你不会经常把这两者放在一起。过去，JavaScript被用来给网页添加一些点缀。它不可能在DevOps有一席之地，对吧？哦，是的，它是。</p><p id="bc68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript(现在是TypeScript)已经渗透到软件工程的每一个角落。首先，它是一个前端的东西。然后，它变成了一个后端的东西(用Node.js)。然后是物联网。现在，我们终于带着我们的JS行李到达了DevOps火车站。从该死的火车上下来，打开行李。读完这篇文章后，你离成为JavaScript DevOps工程师又近了一步。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/4b7027a9ae98a9ed9e82a746a70c0661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42ohKSXST48QLi4GGA7mFQ.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk"><em class="lr">Photo by </em><a class="ae ls" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="lr">Markus Winkler</em></a><em class="lr"> on </em><a class="ae ls" href="https://unsplash.com/s/photos/script?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="lr">Unsplash</em></a></figcaption></figure><h1 id="fadb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">zx简介</h1><p id="f74b" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">首先，我给你介绍一下zx。这是一个让你使用JavaScript轻松编写脚本的库。要开始使用，您需要将它作为一个全局包安装到</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="8e7c" class="mv lu iq mr b gy mw mx l my mz">$ npm i -g zx</span></pre><p id="c5c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好，现在您已经在本地拥有了它，让我们编写第一个脚本来试用它。为了在脚本中使用JS，我们需要放一个头，表明我们将使用zx。因此，打开您最喜欢的编辑器，创建一个新文件<code class="fe na nb nc mr b">test.mjs</code>，并将它放在第一行:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="d031" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx</span></pre><p id="c3cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好，现在让我们添加一些JavaScript代码:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="ee6e" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>console.log("Hello from JS script")</span></pre><p id="148d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过在终端中运行以下命令来使它可执行:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="1f69" class="mv lu iq mr b gy mw mx l my mz">$ chmod +x test.mjs</span></pre><p id="8448" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，让我们运行脚本:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="7d2b" class="mv lu iq mr b gy mw mx l my mz">$ ./test.mjs</span></pre><p id="664f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的剧本问候你了吗？耶，我们成功了。如果您想将文件命名为<code class="fe na nb nc mr b">.js</code>，您需要使用不同的语法，如下所示:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="2ee2" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>;(async function () {<br/>  console.log("Hello from JS script")<br/>})()</span></pre><p id="cb62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe na nb nc mr b">.mjs</code>很方便，因为你可以使用顶级的<code class="fe na nb nc mr b">await</code>呼叫。但是使用<code class="fe na nb nc mr b">.js</code>，你需要创建一个<code class="fe na nb nc mr b">async</code>函数并使用<code class="fe na nb nc mr b">await there</code>。</p><p id="1bc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以使用以下命令运行脚本:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="101a" class="mv lu iq mr b gy mw mx l my mz">$ zx test.mjs<br/>$ zx test.js</span></pre><p id="96b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">酷，我们复习了使用zx的基本知识。让我们来看看一些复杂的例子，看看zx真正的闪光点在哪里。我的dotfiles中有一个安装脚本来设置我的环境。它主要处理我每天使用的程序的安装。前阵子用Ruby写的，下面用JavaScript重写一下吧。</p><h1 id="44e7" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">zx的真正用途</h1><p id="4950" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们将创建一个脚本，为我们安装一些东西:<code class="fe na nb nc mr b">vim-plug ripgrep zsh</code>和<code class="fe na nb nc mr b">oh-my-zsh</code>一个终端主题，它还将从我的<a class="ae ls" href="https://github.com/nikolalsvk/dotfiles" rel="noopener ugc nofollow" target="_blank">点文件库</a>中复制点文件到本地磁盘上的适当位置。而且，它会给<code class="fe na nb nc mr b">.zshrc</code>增加一行。“哇，哇，哇，慢点”——你一定在想。抱歉，我有点操之过急了。我们将从安装<code class="fe na nb nc mr b">ripgrep</code>开始，学习如何从zx脚本运行命令。</p><h2 id="68f5" class="mv lu iq bd lv nd ne dn lz nf ng dp md ko nh ni mf ks nj nk mh kw nl nm mj nn bi translated">运行命令</h2><p id="07ac" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">长话短说，<code class="fe na nb nc mr b"><a class="ae ls" href="https://github.com/BurntSushi/ripgrep" rel="noopener ugc nofollow" target="_blank">ripgrep</a></code>是你的文本/正则表达式搜索伙伴。速度超快，很好用。如果你不用的话，可以去看看。在安装之前，我们先检查一下<code class="fe na nb nc mr b">ripgrep</code>是否可用。显然，如果它已经存在，我们就不想安装它。我们可以从脚本<code class="fe na nb nc mr b">which rg</code>中运行一个命令，让我们知道<code class="fe na nb nc mr b">ripgrep</code>是否存在。让我们试一试:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="33d1" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>await $`which rg`</span></pre><p id="6bc1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将脚本保存为<code class="fe na nb nc mr b">install.mjs</code>并通过<code class="fe na nb nc mr b">zx install.mjs</code>运行。失败了吗？很好，这正是我们的目标。如果没有安装<code class="fe na nb nc mr b">rg</code>，命令<code class="fe na nb nc mr b">which rg</code>会导致脚本失败，提前退出。为什么？这就是zx的工作方式。你可以用<code class="fe na nb nc mr b">$\</code> some command”指定一个命令，它会返回一个承诺。基本上，它将产生一个子进程，并在那里运行指定的命令。如果命令失败，并且你没有处理失败的承诺，程序将会中断。很聪明，是吧？</p><p id="0e66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好，那么我们来处理一个没有安装<code class="fe na nb nc mr b">rg</code> ( <code class="fe na nb nc mr b">ripgrep</code>)的情况。我们将<code class="fe na nb nc mr b">try catch</code>命令<code class="fe na nb nc mr b">which rg</code>并将<code class="fe na nb nc mr b">ripgrep</code>安装到<code class="fe na nb nc mr b">catch</code>模块中。我在Mac上，用<code class="fe na nb nc mr b">brew</code>装东西。你可以使用你使用的任何软件包管理器，我不会告诉你该怎么做，废话。让我们看看如何以编程方式安装它:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="1ec2" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>console.log(chalk.blue("Checking if rg exists..."))<br/><br/>try {<br/>  await $`which rg`<br/>  console.log(chalk.green("You already have rg, awesome!"))<br/>} catch {<br/>  console.log(chalk.red("Nope, installing rg (rigrep)"))<br/><br/>  await $`brew install ripgrep`<br/>}</span></pre><p id="9540" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来很整洁，是吧？尝试将这段代码保存到<code class="fe na nb nc mr b">install.mjs</code>文件中，并使用<code class="fe na nb nc mr b">zx install.mjs</code>运行它。您注意到的第一件事将是一个蓝色文本，上面写着“正在检查rg是否存在……”。哇，颜色。是的，你可以使用zx自带的<code class="fe na nb nc mr b">chalk</code>,在旅途中给你的输出文本上色。</p><p id="6a01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你没有<code class="fe na nb nc mr b">rg</code>，你会在你的终端得到一个红色的文本，后面是负责安装<code class="fe na nb nc mr b">ripgrep</code>的命令输出。同样，如果你在Linux上，你可以用<code class="fe na nb nc mr b">apt</code>甚至<code class="fe na nb nc mr b">sudo apt</code>代替<code class="fe na nb nc mr b">brew</code>。你最了解你的系统。</p><p id="02d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有rg可执行文件，它会打印出“你已经有rg了，太棒了！”绿色文本，我们可以开始下一步了。</p><h2 id="8b96" class="mv lu iq bd lv nd ne dn lz nf ng dp md ko nh ni mf ks nj nk mh kw nl nm mj nn bi translated">不抛出异常</h2><p id="ee91" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们现在将从<code class="fe na nb nc mr b">zx</code>开始探索<code class="fe na nb nc mr b">nothrow</code>方法。为了展示我们如何做到这一点，让我们首先尝试实现将<code class="fe na nb nc mr b">.vimrc</code>从<a class="ae ls" href="https://github.com/nikolalsvk/dotfiles" rel="noopener ugc nofollow" target="_blank"> my dotfiles </a>复制到主目录中的系统<code class="fe na nb nc mr b">.vimrc</code>。</p><p id="b2ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想法是让<code class="fe na nb nc mr b">install.mjs</code>将<code class="fe na nb nc mr b">.vimrc</code>复制到<code class="fe na nb nc mr b">~/.vimrc</code>，但是它应该询问用户是否想要覆盖现有的<code class="fe na nb nc mr b">~/.vimrc</code>。我们可以用<code class="fe na nb nc mr b">cp -i</code>命令很容易地做到这一点，该命令将询问您是否希望覆盖您要复制到的目标。下面是对<code class="fe na nb nc mr b">-i</code>标志的解释:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="60bc" class="mv lu iq mr b gy mw mx l my mz">$ man cp<br/><br/>...<br/><br/>     -i    Cause cp to write a prompt to the standard error output before copying a file that would overwrite an existing file. If the<br/>           response from the standard input begins with the character ‘y’ or ‘Y’, the file copy is attempted. (The -i option overrides any<br/>           previous -n option.)<br/><br/>...</span></pre><p id="dc5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在<code class="fe na nb nc mr b">install.mjs</code>中这样做:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="3f1e" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>console.log(chalk.blue("Copying .vimrc to ~/.vimrc"))<br/>await $`cp -i .vimrc ~/.vimrc`</span></pre><p id="a60d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保存文件并运行<code class="fe na nb nc mr b">zx install.mjs</code>。如果第一次运行时没有文件，就不会得到覆盖提示。但是，如果您重新运行它，它会询问您是否要覆盖——输入<code class="fe na nb nc mr b">n</code>表示否将会停止脚本。为什么？嗯，<code class="fe na nb nc mr b">cp -i .vimrc ~/.vimrc</code>像这样返回退出代码1:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="b7ed" class="mv lu iq mr b gy mw mx l my mz">$ zx test.mjs<br/>Copying .vimrc to ~/.vimrc<br/>$ cp -i .vimrc ~/.vimrc<br/>overwrite ~/.vimrc? (y/n [n]) n<br/>not overwritten<br/>Error: overwrite ~/.vimrc? (y/n [n]) not overwritten<br/>    at file:///Users/.../test.mjs:4:8<br/>    exit code: 1</span></pre><p id="4814" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的第一个想法一定是——让我们做一个<code class="fe na nb nc mr b">try catch</code>阻塞，阻止该命令结束我们的脚本。你是对的，这是可行的。但是，我们想在这里尝试一下<code class="fe na nb nc mr b">nothrow</code>方法。让我们像这样包装我们的命令:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="fffb" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>console.log(chalk.blue("Copying .vimrc to ~/.vimrc"))<br/>await nothrow($`cp -i .vimrc ~/.vimrc`)</span></pre><p id="91d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们运行<code class="fe na nb nc mr b">zx install.mjs</code>时，我们得到:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="a2be" class="mv lu iq mr b gy mw mx l my mz">$ zx test.mjs<br/>Copying .vimrc to ~/.vimrc<br/>$ cp -i .vimrc ~/.vimrc<br/>overwrite /Users/nikolalsvk/.vimrc? (y/n [n]) n<br/>not overwritten</span></pre><p id="19c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe na nb nc mr b">nothrow</code>不会让我们的脚本戛然而止，它会默默忽略“失败”的命令。多整洁啊！我们能在这做点别的吗？你打赌我们能。准备好参加有奖游戏。</p><h2 id="6074" class="mv lu iq bd lv nd ne dn lz nf ng dp md ko nh ni mf ks nj nk mh kw nl nm mj nn bi translated">奖励回合:获得操作系统主目录</h2><p id="62d9" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在前面的例子中，我们大量使用了<code class="fe na nb nc mr b">~/</code>。我们怎样才能让它变得更不可知论和“正确”？幸运的是，我们可以使用<code class="fe na nb nc mr b">os.homedir()</code>来拯救我们，并确保我们的安全。对吗？没错。让我们稍微重构一下代码来使用它。</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="267a" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>const homeDir = os.homedir()<br/>console.log(chalk.blue(`Copying .vimrc to ${homeDir}/.vimrc`))<br/>await nothrow($`cp -i .vimrc ${homeDir}/.vimrc`)</span></pre><p id="f456" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦，哇，但是它会起作用吗？你知道这个练习，保存文件，然后运行<code class="fe na nb nc mr b">zx install.mjs</code>。您应该会得到类似下面的内容:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="ddad" class="mv lu iq mr b gy mw mx l my mz">$ zx test.mjs<br/>Copying .vimrc to /Users/nikolalsvk/.vimrc<br/>$ cp -i .vimrc /Users/nikolalsvk/.vimrc<br/>overwrite /Users/nikolalsvk/.vimrc? (y/n [n]) n<br/>not overwritten</span></pre><p id="90c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在每个阅读你的JS脚本的人都会——我很幸运认识/雇佣/工作/和这个人一起出去，因为你是如此的可爱和体贴。但是玩笑归玩笑，这里一个很好的事情是你不需要显式地导入<code class="fe na nb nc mr b">os</code>来使用它，<code class="fe na nb nc mr b">zx</code>已经为我们做了，这导致了一个干净简洁的脚本来复制文件。谢谢，<code class="fe na nb nc mr b">zx</code>，你摇滚了。</p><p id="4af9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试试<code class="fe na nb nc mr b">zx</code>的另一个特性——提问的能力。</p><h2 id="1700" class="mv lu iq bd lv nd ne dn lz nf ng dp md ko nh ni mf ks nj nk mh kw nl nm mj nn bi translated">问问题</h2><p id="6772" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">让我们使用之前复制文件的例子，但是让我们编写我们的逻辑，询问用户是否想要覆盖文件。感谢<code class="fe na nb nc mr b">zx</code>，我们有了可以使用的<code class="fe na nb nc mr b">question</code>方法。让我们这样试一下:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="e940" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>const homeDir = os.homedir()<br/><br/>console.log(chalk.blue(`Copying .vimrc to ${homeDir}/.vimrc`))<br/><br/>if (fs.exists(`${homeDir}/.vimrc`)) {<br/>  const overwrite = await question(<br/>    `Do you want to overwrite ${homeDir}/.vimrc? (y/n [n]) `<br/>  )<br/><br/>  if (overwrite.toLowerCase().startsWith("y")) {<br/>    console.log(chalk.green(`Overwriting ${homeDir}/.vimrc`))<br/>    await $`cp .vimrc ${homeDir}/.vimrc`<br/>  } else {<br/>    console.log(chalk.blue(`Not overwritting ${homeDir}/.vimrc`))<br/>  }<br/>} else {<br/>  await $`cp .vimrc ${homeDir}/.vimrc`<br/>}</span></pre><p id="6a0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里发生了很多事情。我们首先检查<code class="fe na nb nc mr b">${homeDir}/.vimrc</code>是否存在。如果是，我们会询问用户是否想要覆盖它。如果小写答案与“y”匹配，我们将覆盖文件。如果没有，我们打印出脚本不会覆盖文件。最后，如果没有<code class="fe na nb nc mr b">${homeDir}/.vimrc</code>，我们调用基本的<code class="fe na nb nc mr b">cp</code>命令，而没有之前的内置提示。</p><p id="15a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行脚本并说“y”，则输出如下:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="f6e7" class="mv lu iq mr b gy mw mx l my mz">$ zx test.mjs<br/>Copying .vimrc to /Users/nikolalsvk/.vimrc<br/>Do you want to overwrite /Users/nikolalsvk/.vimrc? (y/n [n]) y<br/>Overwriting /Users/nikolalsvk/.vimrc<br/>$ cp .vimrc /Users/nikolalsvk/.vimrc</span></pre><p id="d774" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们输入其他内容或按enter键，我们会得到以下结果:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="ed82" class="mv lu iq mr b gy mw mx l my mz">$ zx test.mjs<br/>Copying .vimrc to /Users/nikolalsvk/.vimrc<br/>Do you want to overwrite /Users/nikolalsvk/.vimrc? (y/n [n])<br/>Not overwritting /Users/nikolalsvk/.vimrc</span></pre><p id="ceb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">酷，我们现在已经完成了几乎所有的<code class="fe na nb nc mr b">zx</code>的基本功能，使用起来很容易。</p><h1 id="9135" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">其他功能</h1><p id="793f" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们在安装脚本中介绍了几个例子。让我们看看还有什么。</p><h2 id="188f" class="mv lu iq bd lv nd ne dn lz nf ng dp md ko nh ni mf ks nj nk mh kw nl nm mj nn bi translated">你能把那东西给我吗？</h2><p id="8715" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">您还可以使用<code class="fe na nb nc mr b">fetch</code>来获取任何URL。尝试使用:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="245f" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>const response = await fetch("https://api.github.com/octocat")<br/>console.log(await response.text())</span></pre><p id="bbab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行之后，我得到了以下结果:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="7224" class="mv lu iq mr b gy mw mx l my mz">$ zx fetch.mjs<br/>$ fetch https://api.github.com/octocat<br/><br/>               MMM.           .MMM<br/>               MMMMMMMMMMMMMMMMMMM<br/>               MMMMMMMMMMMMMMMMMMM      ____________________________<br/>              MMMMMMMMMMMMMMMMMMMMM    |                            |<br/>             MMMMMMMMMMMMMMMMMMMMMMM   | Keep it logically awesome. |<br/>            MMMMMMMMMMMMMMMMMMMMMMMM   |_   ________________________|<br/>            MMMM::- -:::::::- -::MMMM    |/<br/>             MM~:~ 00~:::::~ 00~:~MM<br/>        .. MMMMM::.00:::+:::.00::MMMMM ..<br/>              .MM::::: ._. :::::MM.<br/>                 MMMM;:::::;MMMM<br/>          -MM        MMMMMMM<br/>          ^  M+     MMMMMMMMM<br/>              MMMMMMM MM MM MM<br/>                   MM MM MM MM<br/>                   MM MM MM MM<br/>                .~~MM~MM~MM~MM~~.<br/>             ~~~~MM:~MM~~~MM~:MM~~~~<br/>            ~~~~~~==~==~~~==~==~~~~~~<br/>             ~~~~~~==~==~==~==~~~~~~<br/>                 :~==~==~==~==~~</span></pre><h2 id="6b99" class="mv lu iq bd lv nd ne dn lz nf ng dp md ko nh ni mf ks nj nk mh kw nl nm mj nn bi translated"><code class="fe na nb nc mr b">cd</code>你回家的路</h2><p id="4171" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">您可以使用<code class="fe na nb nc mr b">cd</code>命令轻松地在文件系统中移动。让我们打印出您(可能)不知道您的Unix系统上有《指环王》日历:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="451a" class="mv lu iq mr b gy mw mx l my mz">#!/usr/bin/env zx<br/><br/>cd("/usr/share/calendar")<br/><br/>await $`cat calendar.lotr`</span></pre><p id="f2f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你至少应该看到这一部分:</p><pre class="lc ld le lf gt mq mr ms mt aw mu bi"><span id="0eda" class="mv lu iq mr b gy mw mx l my mz">01/05   Fellowship enters Moria<br/>01/09   Fellowship reaches Lorien<br/>01/17   Passing of Gandalf<br/>02/07   Fellowship leaves Lorien<br/>02/17   Death of Boromir<br/>02/20   Meriadoc &amp; Pippin meet Treebeard<br/>02/22   Passing of King Elessar<br/>02/24   Ents destroy Isengard<br/>02/26   Aragorn takes the Paths of the Dead<br/>03/05   Frodo &amp; Samwise encounter Shelob<br/>03/08   Deaths of Denethor &amp; Theoden<br/>03/18   Destruction of the Ring<br/>03/29   Flowering of the Mallorn<br/>04/04   Gandalf visits Bilbo<br/>04/17   An unexpected party<br/>04/23   Crowning of King Elessar<br/>05/19   Arwen leaves Lorien to wed King Elessar<br/>06/11   Sauron attacks Osgiliath<br/>06/13   Bilbo returns to Bag End<br/>06/23   Wedding of Elessar &amp; Arwen<br/>07/04   Gandalf imprisoned by Saruman<br/>07/24   The ring comes to Bilbo<br/>07/26   Bilbo rescued from Wargs by Eagles<br/>08/03   Funeral of King Theoden<br/>08/29   Saruman enters the Shire<br/>09/10   Gandalf escapes from Orthanc<br/>09/14   Frodo &amp; Bilbo's birthday<br/>09/15   Black riders enter the Shire<br/>09/18   Frodo and company rescued by Bombadil<br/>09/28   Frodo wounded at Weathertop<br/>10/05   Frodo crosses bridge of Mitheithel<br/>10/16   Boromir reaches Rivendell<br/>10/17   Council of Elrond<br/>10/25   End of War of the Ring<br/>11/16   Bilbo reaches the Lonely Mountain<br/>12/05   Death of Smaug<br/>12/16   Fellowship begins Quest</span></pre><p id="2078" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有几个<code class="fe na nb nc mr b">zx</code>的特性，你可以在GitHub 的<a class="ae ls" href="https://github.com/google/zx" rel="noopener ugc nofollow" target="_blank">官方回购上查看。自述文件非常详细，无论您想要构建什么，它都能为您提供广泛的帮助。</a></p><h1 id="8174" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">总结</h1><p id="a20f" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">感谢你读到这里，这对我意义重大。今天我们学到了很多关于<code class="fe na nb nc mr b">zx</code>的知识。你现在离成为一名JavaScript DevOps工程师更近了一步，恭喜你🎉。你已经感到自豪和富有成效了吗？很好，很高兴我帮了忙。</p><p id="4cf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看了一下<code class="fe na nb nc mr b">zx</code>的几个特点:</p><ul class=""><li id="5644" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">用<code class="fe na nb nc mr b">$\</code>命令调用命令的能力` --它将产生一个你需要等待的进程。它还会抛出一个您需要捕捉的异常，所以要小心。</li><li id="4ab6" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">有<code class="fe na nb nc mr b">nothrow</code>可以确保命令不会破坏你的脚本。</li><li id="916d" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">我们学习了<code class="fe na nb nc mr b">questions</code>以及如何让你的脚本具有交互性。</li><li id="fcc3" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">有<code class="fe na nb nc mr b">fetch</code>从网上获取网址(也许是本地的？)</li><li id="9da3" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">可以用<code class="fe na nb nc mr b">cd</code>导航。</li></ul><p id="703e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是这篇博文的全部内容。加入<a class="ae ls" href="https://pragmaticpineapple.com/newsletter" rel="noopener ugc nofollow" target="_blank">时事通讯</a>，因为我计划以打字稿的形式完成所有这些工作。是的，每个人都在重写他们的代码库。另外，如果你喜欢DevOps JS的想法，请告诉我，我会写更多关于它的内容。</p><p id="60b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在GitHub上的<a class="ae ls" href="https://github.com/nikolalsvk/dotfiles" rel="noopener ugc nofollow" target="_blank">我的点文件</a>中找到我从Ruby转换成JavaScript的脚本。下面是<a class="ae ls" href="https://github.com/nikolalsvk/dotfiles/blob/master/install.mjs" rel="noopener ugc nofollow" target="_blank">完整的</a> <code class="fe na nb nc mr b"><a class="ae ls" href="https://github.com/nikolalsvk/dotfiles/blob/master/install.mjs" rel="noopener ugc nofollow" target="_blank">install.mjs</a></code> <a class="ae ls" href="https://github.com/nikolalsvk/dotfiles/blob/master/install.mjs" rel="noopener ugc nofollow" target="_blank">文件</a>。如果你喜欢，留下一颗星星。如果没有，请迅速关闭浏览器选项卡。</p><p id="3594" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑与你的朋友和同事分享这篇博文。也许有人只是在等待这种类型的内容。在Twitter上有一个快速的方法:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b66c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我今天给你的全部。下次再见。</p><p id="87b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="f545" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ol">原载于2022年3月15日https://pragmaticpineapple.com</em><em class="ol">的</em> <a class="ae ls" href="https://pragmaticpineapple.com/devops-javascript-intro-to-writing-scripts-with-zx/" rel="noopener ugc nofollow" target="_blank"> <em class="ol">。</em></a></p><p id="1c7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ol">更多内容请看</em><a class="ae ls" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ol">plain English . io</em></strong></a><em class="ol">。报名参加我们的</em> <a class="ae ls" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ol">免费周报</em> </strong> </a> <em class="ol">。关注我们关于</em><a class="ae ls" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ol">Twitter</em></strong></a><em class="ol">和</em><a class="ae ls" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ol">LinkedIn</em></strong></a><em class="ol">。加入我们的</em> <a class="ae ls" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ol">社区不和谐</em> </strong> </a> <em class="ol">。</em></p></div></div>    
</body>
</html>