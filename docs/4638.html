<html>
<head>
<title>How to Use The Spread Operator in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用Spread运算符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-the-spread-operator-in-javascript-3bcd757e664d?source=collection_archive---------4-----------------------#2022-12-20">https://javascript.plainenglish.io/how-to-use-the-spread-operator-in-javascript-3bcd757e664d?source=collection_archive---------4-----------------------#2022-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f79f551412ea90ab8f158b8f28b81c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xa0rbBWj5ZlEFqY7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@insungyoon?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">insung yoon</a> / <a class="ae kc" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fd70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript语言中最有用的操作符之一也是最难理解的。JavaScript中的spread操作符表示为<code class="fe lb lc ld le b">...</code>，它允许您<em class="lf">就地扩展</em>数组或可迭代对象的元素，并可以帮助您以几种不同的方式编写更干净、更简洁的代码。</p><p id="c983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管从概念上讲，spread运算符总是用于“扩展”数组或可迭代对象，但实际用法和行为会因上下文而有所不同。在这篇文章中，我们将看看JavaScript的spread操作符，以及它的许多不同用法。</p><h1 id="f754" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">JavaScript中的Spread运算符是什么？</h1><p id="d624" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">简单地说，JavaScript中的spread操作符扩展了数组或可迭代对象的元素。它可以用来解决几个不同的问题:</p><ul class=""><li id="47b5" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">从数组和对象中提取值</li><li id="bc5f" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">复制数组和对象</li><li id="3666" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">添加或删除元素</li><li id="54a2" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">用数组中的参数调用函数</li><li id="d5c9" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">用可变参数定义函数。</li></ul><p id="f455" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这些用例在概念上都是相似的，但是如何应用spread操作符的具体细节在不同的用例之间有所不同。</p><p id="809b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，spread操作符处理数组和<em class="lf">可迭代</em>对象。虽然JavaScript中可能遇到的大多数对象都是可迭代的(包括像<code class="fe lb lc ld le b">value = {a: 1, b: 2, c: 3}</code>这样的对象文字)，但是一些API可能会返回不可迭代的对象。在本文的其余部分，当我们提到<em class="lf">对象</em>并使用spread操作符时，我们特指<em class="lf">可迭代</em>对象。</p><p id="5d86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，让我们深入研究使用spread操作符的各种方法！</p><h2 id="2f57" class="mx lh iq bd li my mz dn lm na nb dp lq ko nc nd lu ks ne nf ly kw ng nh mc ni bi translated">从对象或数组中提取值</h2><p id="eae9" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">spread运算符通常与对象或数组<em class="lf">析构一起使用。</em>析构是指我们使用特殊的赋值语法来解包对象或数组的元素。</p><p id="94cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个简单的例子中，我们<em class="lf">将</em>一个5元素数组析构为3个变量:第一个值赋给<code class="fe lb lc ld le b">a</code>，第二个值赋给<code class="fe lb lc ld le b">b</code>，列表的其余部分赋给<code class="fe lb lc ld le b">rest</code>:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="38f2" class="nr lh iq le b be ns nt l nu nv">&gt; array = [10, 20, 30, 40, 50] <br/>&gt; let [a, b, ...rest] = array <br/>&gt; a <br/>10 <br/>&gt; b <br/>20 <br/>&gt; rest <br/>[ 30, 40, 50 ]</span></pre><p id="e347" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对对象做一些非常类似的事情:我们可以通过键提取特定的值，并将对象的剩余部分提取到不同的变量中:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="4f1e" class="nr lh iq le b be ns nt l nu nv">&gt; values = {x: 10, y: 20, z: 30} <br/>&gt; let { x: xValue, ...rest } = values <br/>&gt; xValue <br/>10 <br/>&gt; rest <br/>{ y: 20, z: 30 }</span></pre><p id="26cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意扩展操作符和“剩余”参数实际上并不是析构所需要的T21——但是它们很常见。如果您实际上不关心对象或数组的其余部分，您可以在没有spread运算符的情况下进行析构:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="558e" class="nr lh iq le b be ns nt l nu nv">&gt; array = [10, 20, 30] <br/>&gt; [a] = array <br/>&gt; a <br/>1 <br/><br/>&gt; values = {x: 10, y: 20, z: 30} <br/>&gt; let { x: xValue } = values <br/>&gt; xValue <br/>10</span></pre><p id="33d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用React，您可能会看到这种模式被用来从<code class="fe lb lc ld le b">props</code>对象中提取某些<em class="lf">属性</em>，并传递其余的属性。考虑一个简单的<code class="fe lb lc ld le b">WrappedImage</code>组件，它只是在<code class="fe lb lc ld le b">img</code>标签周围应用了一个<code class="fe lb lc ld le b">Wrapper</code>:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="39ff" class="nr lh iq le b be ns nt l nu nv">const WrappedImage = ({ backgroundColor, ...rest }) =&gt; { <br/>  return ( <br/>    &lt;Wrapper color={backgroundColor}&gt;<br/>      &lt;img {...rest} /&gt; <br/>    &lt;/Wrapper&gt; <br/>  ) <br/>}</span></pre><p id="628c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们提取<code class="fe lb lc ld le b">Wrapper</code>的<code class="fe lb lc ld le b">backgroundColor</code>道具，并将所有剩余的属性传递给<code class="fe lb lc ld le b">img</code>。我们不关心解开一个<code class="fe lb lc ld le b">img</code>标签可以接受的所有属性——除了<code class="fe lb lc ld le b">backgroundColor</code>之外，任何传入我们组件的内容都将原封不动地通过。</p><h1 id="5c8e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">从数组或对象中移除值</h1><p id="dfec" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">细心的读者会注意到，上面的代码通过用spread操作符提取“rest”值，也具有生成移除了元素的数组和对象的效果:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="199a" class="nr lh iq le b be ns nt l nu nv">&gt; let array = [1, 2, 3] <br/>&gt; let [ _value, ...rest ] = array <br/>&gt; rest<br/>[2, 3]</span></pre><p id="6648" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们将第一个参数提取到一个名为<code class="fe lb lc ld le b">_value</code>的变量中。下划线是约定俗成的用法，表示我们并不真正关心一个值——它只是一个占位符。</p><h1 id="15e2" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">向数组或对象添加值</h1><p id="8042" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">使用spread操作符的另一种方法是将<em class="lf">元素添加到一个对象或数组中。</em></p><p id="b095" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们在数组末尾添加一个值:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="2d2e" class="nr lh iq le b be ns nt l nu nv">&gt; let numbers = [1, 2, 3] <br/>&gt; newNumbers = [...numbers, 4] <br/>[ 1, 2, 3, 4 ]</span></pre><p id="c27b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在数组的开头或结尾都进行扩展——甚至可以同时在两个地方进行扩展！</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="54e0" class="nr lh iq le b be ns nt l nu nv">&gt; let numbers = [1, 2, 3] [ 1, 2, 3 ] <br/>&gt; newNumbers = [0, ...numbers, 4] <br/>[ 0, 1, 2, 3, 4 ]</span></pre><p id="2bf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">甚至可以使用多个扩展运算符来组合数组:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="6785" class="nr lh iq le b be ns nt l nu nv">&gt; let n1 = [ 1, 2, 3 ] <br/>&gt; let n2 = [ 4, 5, 6 ] <br/>&gt; [ ...n1, ...n2 ] <br/>[ 1, 2, 3, 4, 5, 6 ]</span></pre><p id="4790" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样的技术也适用于对象。我们可以通过应用spread操作符来扩展对象，然后提供附加的键和值:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="e5d0" class="nr lh iq le b be ns nt l nu nv">&gt; values = {x: 10, y: 20, z: 30} <br/>&gt; newValues = {...values, a: 10} <br/>{ x: 10, y: 20, z: 30, a: 10 }</span></pre><p id="6c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，对于对象，有一点需要注意，那就是重复键的顺序很重要。当密钥重复时，右边的优先:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="52e9" class="nr lh iq le b be ns nt l nu nv">&gt; values = {x: 10, y: 20, z: 30} <br/><br/>&gt; // The new value for x takes precedence: <br/>&gt; newValues = { ...values, x: 50} <br/>{ x: 50, y: 20, z: 30 } <br/><br/>&gt; // The old value for x takes precedence: <br/>&gt; newValues = { x: 50, ...values } <br/>{ x: 10, y: 20, z: 30 }</span></pre><p id="da89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像数组一样，我们可以使用spread操作符的多个实例来组合对象。如上所述，在出现重复键的情况下，键的最右边的值优先:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="3afd" class="nr lh iq le b be ns nt l nu nv">&gt; v1 = {x: 10, y: 20, z: 30} <br/>&gt; v2 = {w: 40, y: 50} <br/>&gt; { ...v1, ...v2 } <br/>{ x: 10, y: 50, z: 30, w: 40 }</span></pre><h1 id="afc5" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">复制数组或对象</h1><p id="2e26" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">以同样的方式，使用扩展操作符提取值的<em class="lf">可以有效地用于从数组或对象中移除元素，扩展操作符也可以用于<em class="lf">复制</em>数组或对象。这在你处理不应该被修改的不可变的T21数据时特别有用。</em></p><p id="29a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，状态管理库Redux指定:</p><blockquote class="nw nx ny"><p id="c42d" class="kd ke lf kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated"><em class="iq">【减速器】不允许修改已有的</em> <code class="fe lb lc ld le b"><em class="iq">state</em></code> <em class="iq">。相反，他们必须通过复制现有的</em> <code class="fe lb lc ld le b"><em class="iq">state</em></code> <em class="iq">并对复制的值“</em>”进行更改，来进行不可变更新<em class="iq"/></p></blockquote><p id="8b7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑一个函数，它被设计成以不可变的方式增加对象中的值。spread运算符可用于轻松复制和更新值，而不是修改它:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="cc98" class="nr lh iq le b be ns nt l nu nv">// 🚫 Don't modify the existing state <br/>const incrementValue = (state) =&gt; { state[value] += 1 return state } <br/><br/>// ✅ Use the spread operator to copy the state <br/>const incrementValue = (state) =&gt; { return {...state, state.value + 1} }</span></pre><h1 id="b4d6" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">使用数组中的参数调用函数</h1><p id="686f" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">spread运算符也可用于将参数从数组传递给函数。考虑这样一个场景，我们将想要传递给函数的参数存储在一个数组中:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="8ba6" class="nr lh iq le b be ns nt l nu nv">&gt; function add(x, y, z) { return x + y + z } <br/>&gt; numbers = [1, 2, 3] <br/>&gt; add(...numbers) <br/>6</span></pre><p id="a2b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像spread操作符的一些其他用法一样，这不是从数组中传递参数函数的唯一方法。我们可以手动解包这些值，或者我们可以在一个函数上使用<em class="lf"> apply </em>方法来完成同样的事情:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="5b95" class="nr lh iq le b be ns nt l nu nv">&gt; // manually unpack the values from an array <br/>&gt; add(numbers[0], numbers[1], numbers[2]) <br/><br/>&gt; // use apply() to pass in arguments from an Array <br/>&gt; add.apply(null, numbers)</span></pre><h1 id="fbde" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">定义具有可变参数的函数</h1><p id="ff99" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">最后，spread运算符可用于定义一个函数，该函数采用可变数量的参数。假设我们想要定义一个函数，它可以被称为<code class="fe lb lc ld le b">f(1)</code>、<code class="fe lb lc ld le b">f(1,2)</code>、<code class="fe lb lc ld le b">f(1,2,3)</code>，等等。在函数定义中使用spread运算符，将所有参数打包到一个数组中:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="71ba" class="nr lh iq le b be ns nt l nu nv">&gt; function f(...args) { console.log(args) } <br/>&gt; f(1, 2, 3) <br/>[ 1, 2, 3 ]</span></pre><p id="4112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与spread运算符的其他用法类似，它可以出现在其他参数列表的末尾:</p><pre class="nj nk nl nm gt nn le no bn np nq bi"><span id="cee2" class="nr lh iq le b be ns nt l nu nv">&gt; function f(x, ...args) { console.log(args) } <br/>&gt; f(1, 2, 3) <br/>[ 2, 3 ]</span></pre><p id="4bf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">spread运算符的这种用法不太常见，但是对于某些API非常有用。例如，JavaScript的<code class="fe lb lc ld le b">console.log()</code>函数接受可变数量的参数，让我们在一次调用中记录多个值。</p><p id="bf27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得注意的是，变量参数也可以使用函数内部可用的特殊的<code class="fe lb lc ld le b">arguments</code>对象来实现，所以并不是每个接受变量参数的函数都使用spread运算符。</p><h1 id="d8df" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">想了解更多？</h1><p id="0456" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">如果您想快速参考JavaScript中的spread操作符，请务必查看我们的<a class="ae kc" href="https://www.youtube.com/channel/UCOw1-AGy_tHnbjiwC4EdFVw" rel="noopener ugc nofollow" target="_blank"> JavaScript视频备忘单</a>主题:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><ul class=""><li id="c36a" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">查看我们关于JavaScript数组的 <code class="fe lb lc ld le b"><a class="ae kc" href="https://blixtdev.com/javascript-video-cheatsheets-map-and-reduce-with-arrays/" rel="noopener ugc nofollow" target="_blank">map()</a></code> <a class="ae kc" href="https://blixtdev.com/javascript-video-cheatsheets-map-and-reduce-with-arrays/" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe lb lc ld le b"><a class="ae kc" href="https://blixtdev.com/javascript-video-cheatsheets-map-and-reduce-with-arrays/" rel="noopener ugc nofollow" target="_blank">reduce()</a></code> <a class="ae kc" href="https://blixtdev.com/javascript-video-cheatsheets-map-and-reduce-with-arrays/" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae kc" href="https://blixtdev.com/javascript-video-cheatsheets-map-and-reduce-with-arrays/" rel="noopener ugc nofollow" target="_blank">视频备忘单</a></li><li id="af99" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">看看<a class="ae kc" href="https://amzn.to/3jgxPiD" rel="noopener ugc nofollow" target="_blank">我们最喜欢的JavaScript书籍之一</a></li><li id="f517" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">查看我们的一些<a class="ae kc" href="https://blixtdev.com/tag/javascript/" rel="noopener ugc nofollow" target="_blank">其他JavaScript文章</a></li></ul></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="922d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lf">原载于2022年12月20日</em><a class="ae kc" href="https://blixtdev.com/how-to-use-the-spread-operator-in-javascript/" rel="noopener ugc nofollow" target="_blank"><em class="lf"/></a><em class="lf">。这篇文章可能包含附属链接。</em></p><p id="3f08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lf">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lf">说白了。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lf">免费周报</em> </strong> </a> <em class="lf">。关注我们关于</em> <a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lf">推特</em> </strong> </a>，<a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lf">LinkedIn</em></strong></a><em class="lf">，</em><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lf">YouTube</em></strong></a><em class="lf">，以及</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lf">不和</em> </strong> </a> <strong class="kf ir"> <em class="lf">。</em> </strong></strong></a></p><p id="136f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lf">有兴趣缩放你的软件启动</em> </strong> <em class="lf">？检查出</em> <a class="ae kc" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lf">电路</em> </strong> </a> <em class="lf">。</em></p></div></div>    
</body>
</html>