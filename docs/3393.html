<html>
<head>
<title>How to Use an Async Function in the React useEffect() Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React useEffect()挂钩中使用异步函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-useeffect-async-bbae21889cc0?source=collection_archive---------11-----------------------#2022-08-24">https://javascript.plainenglish.io/react-useeffect-async-bbae21889cc0?source=collection_archive---------11-----------------------#2022-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5a79" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解在React useEffect()钩子中轻松调用异步函数的多种方法。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/85f1d92ad6e9299341dae2fba578ffd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KW1_OzttZODsFQIBK61X6g.png"/></div></div></figure><p id="b3e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们将看看在React <code class="fe lk ll lm ln b">useEffect()</code>钩子中轻松调用<code class="fe lk ll lm ln b">async</code>函数的不同方法，以及在使用<code class="fe lk ll lm ln b">async</code> / <code class="fe lk ll lm ln b">await</code>时要避免的陷阱。</p><h1 id="8f25" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">使用useEffect()中的then/catch调用异步函数</h1><p id="d7d4" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated"><code class="fe lk ll lm ln b">async</code>函数在JavaScript中执行异步操作。为了在React useEffect()钩子中等待<code class="fe lk ll lm ln b">Promise</code><code class="fe lk ll lm ln b">async</code>函数返回被解决(完成或拒绝),我们可以使用它的<code class="fe lk ll lm ln b">then()</code>和<code class="fe lk ll lm ln b">catch()</code>方法:</p><p id="c2e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的例子中，我们调用<code class="fe lk ll lm ln b">fetchBooks()</code>异步方法来获取和显示样本阅读应用程序中存储的书籍:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="92f4" class="mp lp in ln b gy mq mr l ms mt">export default function App() {<br/>  const [books, setBooks] = useState([]);</span><span id="919d" class="mp lp in ln b gy mu mr l ms mt">  useEffect(() =&gt; {<br/>    // await async "fetchBooks()" function<br/>    fetchBooks()<br/>      .then((books) =&gt; {<br/>        setBooks(books);<br/>      })<br/>      .catch(() =&gt; {<br/>        console.log('Error occured when fetching books');<br/>      });<br/>  }, []);</span><span id="ae80" class="mp lp in ln b gy mu mr l ms mt">  return (<br/>    &lt;div&gt;<br/>      {books.map((book) =&gt; (<br/>        &lt;div&gt;<br/>          &lt;h2&gt;{book.title}&lt;/h2&gt;<br/>        &lt;/div&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="3033" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">异步/等待问题:异步回调无法传递给useEffect()</h1><p id="8ddd" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">也许您更喜欢使用<code class="fe lk ll lm ln b">async/await</code>语法来代替<code class="fe lk ll lm ln b">then/catch</code>。您可以通过将回调传递给<code class="fe lk ll lm ln b">useEffect()</code> <code class="fe lk ll lm ln b">async</code>来尝试这样做。</p><p id="9776" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不是一个好主意，如果你使用的是棉绒，它会马上通知你。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="b371" class="mp lp in ln b gy mq mr l ms mt">// ❌ Your linter: don't do this!<br/>useEffect(async () =&gt; {<br/>  try {<br/>    const books = await fetchBooks();<br/>    setBooks(books);<br/>  } catch {<br/>    console.log('Error occured when fetching books');<br/>  }<br/>}, []);</span></pre><p id="8fbf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你的linter抱怨是因为<code class="fe lk ll lm ln b">useEffect()</code>的第一个参数应该是一个函数，要么不返回任何东西，要么返回一个函数来清除副作用。但是<code class="fe lk ll lm ln b">async</code>函数总是返回一个<code class="fe lk ll lm ln b">Promise</code>(隐式或显式)，并且<code class="fe lk ll lm ln b">Promise</code>对象不能作为函数调用。这可能会导致React应用程序出现真正的问题，比如内存泄漏。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="83d4" class="mp lp in ln b gy mq mr l ms mt">useEffect(async () =&gt; {<br/>  const observer = () =&gt; {<br/>    // do stuff<br/>  };</span><span id="2627" class="mp lp in ln b gy mu mr l ms mt">  await fetchData();</span><span id="ea29" class="mp lp in ln b gy mu mr l ms mt">  observable.subscribe(observer);</span><span id="a2a8" class="mp lp in ln b gy mu mr l ms mt">  // Memory leak!<br/>  return () =&gt; {<br/>    observable.unsubscribe(observer);<br/>  };<br/>}, []);</span></pre><p id="991e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个例子中，因为回调函数是<code class="fe lk ll lm ln b">async</code>，它实际上并不返回定义的清理函数，而是返回一个用清理函数解析的<code class="fe lk ll lm ln b">Promise</code>对象。因此，这个清除函数永远不会被调用，观察者永远不会从可观察对象中退订，从而导致内存泄漏。</p><p id="1f27" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么我们该如何解决这个问题呢？我们如何在<code class="fe lk ll lm ln b">useEffect()</code>钩子中使用带有<code class="fe lk ll lm ln b">async</code>功能的<code class="fe lk ll lm ln b">await</code>操作符？</p><h1 id="ef10" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">async/await解决方案1:在IIFE中调用异步函数</h1><p id="d074" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">解决这个问题的一个简单方法是将<a class="ae mv" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">中的<code class="fe lk ll lm ln b">async</code>函数<code class="fe lk ll lm ln b">await</code>立即调用函数表达式</a>(life):</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="d925" class="mp lp in ln b gy mq mr l ms mt">const [books, setBooks] = useState([]);</span><span id="50e2" class="mp lp in ln b gy mu mr l ms mt">useEffect(() =&gt; {<br/>  (async () =&gt; {<br/>    try {<br/>      const books = await fetchBooks();<br/>      setBooks(books);<br/>    } catch (err) {<br/>      console.log('Error occured when fetching books');<br/>    }<br/>  })();<br/>}, []);</span></pre><p id="961d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">顾名思义，生命是一个一旦被定义就运行的函数。它们用于避免污染全局命名空间，以及在尝试一个<code class="fe lk ll lm ln b">await</code>调用可能导致包含生命的作用域出现问题的场景中(例如在<code class="fe lk ll lm ln b">useEffect()</code>钩子中)。</p><h1 id="2a61" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">异步/等待解决方案2:在命名函数中调用异步函数</h1><p id="c03b" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">或者，您可以在一个命名函数中<code class="fe lk ll lm ln b">await</code>这个<code class="fe lk ll lm ln b">async</code>函数:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="838a" class="mp lp in ln b gy mq mr l ms mt">useEffect(() =&gt; {</span><span id="8954" class="mp lp in ln b gy mu mr l ms mt">  // Named function "getBooks"<br/>  async function getBooks() {<br/>    try {<br/>      const books = await fetchBooks();<br/>      setBooks(books);<br/>    } catch (err) {<br/>      console.log('Error occured when fetching books');<br/>    }<br/>  }</span><span id="0244" class="mp lp in ln b gy mu mr l ms mt">  // Call named function<br/>  getBooks();<br/>}, []);</span></pre><p id="a147" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还记得使用可观察模式的例子吗？下面是我们如何使用一个命名的<code class="fe lk ll lm ln b">async</code>函数来防止发生的内存泄漏:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="f27d" class="mp lp in ln b gy mq mr l ms mt">// ✅ Callback is not async<br/>useEffect(() =&gt; {<br/>  const observer = () =&gt; {<br/>    // do stuff<br/>  };</span><span id="e059" class="mp lp in ln b gy mu mr l ms mt">  // Named function "fetchDataAndSubscribe"<br/>  async function fetchDataAndSubscribe() {<br/>    await fetchData();<br/>    observable.subscribe(observer);<br/>  }</span><span id="caf8" class="mp lp in ln b gy mu mr l ms mt">  fetchDataAndSubscribe();</span><span id="6c2a" class="mp lp in ln b gy mu mr l ms mt">  // ✅ No memory leak<br/>  return () =&gt; {<br/>    observable.unsubscribe(observer);<br/>  };<br/>}, []);</span></pre><h1 id="f1fa" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">异步/等待解决方案3:创建自定义挂钩</h1><p id="740d" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">我们还可以创建一个自定义钩子，它的行为类似于<code class="fe lk ll lm ln b">useEffect()</code>，并且可以接受<code class="fe lk ll lm ln b">async</code>回调而不会导致任何问题。</p><p id="9a3d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">自定义挂钩可以这样定义:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="b8fe" class="mp lp in ln b gy mq mr l ms mt">export function useEffectAsync(effect, inputs) {<br/>  useEffect(() =&gt; {<br/>    return effect();<br/>  }, inputs);<br/>}</span></pre><p id="91a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以从代码中的多个地方调用它，就像这样:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="f671" class="mp lp in ln b gy mq mr l ms mt">const [books, setBooks] = useState([]);</span><span id="15ee" class="mp lp in ln b gy mu mr l ms mt">useEffectAsync(async () =&gt; {<br/>  try {<br/>    const books = await fetchBooks();<br/>    setBooks(books);<br/>  } catch (err) {<br/>    console.log('Error occured when fetching books');<br/>  }<br/>});</span></pre><p id="6d2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了这三种方法，我们现在可以很容易地在<code class="fe lk ll lm ln b">useEffect()</code>钩子中使用带有<code class="fe lk ll lm ln b">async</code>函数的<code class="fe lk ll lm ln b">await</code>操作符。</p><h1 id="84f3" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">在useEffect()外部定义异步函数</h1><p id="a48b" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">要在<code class="fe lk ll lm ln b">useEffect()</code>钩子之外定义一个命名的<code class="fe lk ll lm ln b">async</code>函数，可以用<a class="ae mv" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> useCallback() </a>钩子包装这个函数:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="2a87" class="mp lp in ln b gy mq mr l ms mt">const getBooks = useCallback(async () =&gt; {<br/>  try {<br/>    const books = await fetchBooks();<br/>    setBooks(books);<br/>  } catch (err) {<br/>    console.log('Error occured when fetching books');<br/>  }<br/>}, []);</span><span id="fac8" class="mp lp in ln b gy mu mr l ms mt">useEffect(() =&gt; {<br/>  getBooks();<br/>}, [getBooks]);</span></pre><p id="4993" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果没有<code class="fe lk ll lm ln b">useCallback()</code>，每次重新渲染时都会重新创建<code class="fe lk ll lm ln b">getBooks()</code>函数，不必要地触发<code class="fe lk ll lm ln b">useEffect()</code>并导致性能问题。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="a005" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">【codingbeautydev.com】原载于<a class="ae mv" href="https://cbdev.link/52f554" rel="noopener ugc nofollow" target="_blank"><em class="nd"/></a></p><h1 id="d124" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">JavaScript做的每一件疯狂的事情</h1><p id="e18c" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">一本关于JavaScript微妙的警告和鲜为人知的部分的迷人指南。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/143ee152ba78025ea8643ba5b9726a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*YS5Oub8REWy8vnOEqBnsyQ.png"/></div></figure><p id="7d6e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae mv" href="https://cbdev.link/d3c4eb" rel="noopener ugc nofollow" target="_blank">报名</a>立即免费领取一份。</p></div></div>    
</body>
</html>