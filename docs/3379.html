<html>
<head>
<title>Visualizing the Selection Sort Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化选择排序算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/visualize-selection-sort-algorithm-8823859edd09?source=collection_archive---------14-----------------------#2022-08-23">https://javascript.plainenglish.io/visualize-selection-sort-algorithm-8823859edd09?source=collection_archive---------14-----------------------#2022-08-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2093" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我总是着迷于想象一个算法。当我打开罗伯特·塞奇威克写的那本算法书时，很难错过他精美的分步插图，这样你就可以详细研究算法了。你有没有想过把这些插图做成动画，看看每个算法是如何用你自己的输入数据开发的？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e44cabc9472209a3f88b6c3b9a7183b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oudJpKVGpMY2UWsPzw42A.jpeg"/></div></div></figure><h2 id="ecaa" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">选择排序</h2><p id="ff38" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们以一个最简单的排序算法为例:找到数组中最小的元素并与第一个位置的一个交换，然后找到下一个最小的元素并与第二个位置的一个交换，继续下去直到数组排序完毕。这种方法被称为<strong class="jm io">选择排序</strong>。在每个外部循环后绘图将得到以下输出:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="a947" class="ku kv in lt b gy lx ly l lz ma">ASORTINGEXAMPLE<br/>AAORTINGEXSMPLE<br/>AAERTINGOXSMPLE<br/>AAEETINGOXSMPLR<br/>AAEEGINTOXSMPLR<br/>...</span></pre><p id="3dab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我们可以快速编写的程序:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="6694" class="ku kv in lt b gy lx ly l lz ma">function sort(arr) {<br/>  for (let i = 0; i &lt; n - 1; i++)<br/>    let m = i<br/>    for (let j = i + 1; j &lt; n; j++) {<br/>      if (arr[j] &lt; arr[m]) m = j<br/>    }<br/>    t = arr[m]; arr[m] = arr[i]; arr[i] = t; <br/><strong class="lt io">    console.log(arr);  </strong><br/>  }<br/>}</span></pre><p id="7f16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">算法并不太难写，实现的效率是<code class="fe mb mc md lt b">O(n^2)</code>。在每个外部循环的末尾添加一个<code class="fe mb mc md lt b">console.log</code>来生成我们的输出。</p><h2 id="e639" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">如何制作字母动画？</h2><p id="e055" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">现在让我们假设我们想要动画它。例如，每次我们交换两个元素时，我们可以期望看到两个元素彼此移动并最终在它们的新位置安顿下来的平稳过渡。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="f562" class="ku kv in lt b gy lx ly l lz ma"> S -&gt;       &lt;- A<br/> A             S</span></pre><p id="fb02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们使用HTML/CSS来实现它。假设数组中有14个字母:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="28bb" class="ku kv in lt b gy lx ly l lz ma">&lt;div class="canvas"&gt;<br/>  &lt;span class="letter"&gt;A&lt;/span&gt;<br/>  &lt;span class="letter"&gt;S&lt;/span&gt;<br/>  &lt;span class="letter"&gt;O&lt;/span&gt;<br/>  ...<br/>&lt;/div&gt;</span><span id="f8f1" class="ku kv in lt b gy me ly l lz ma">.canvas {<br/>  position: relative;<br/>}<br/>.letter {<br/>  position: absolute;<br/>  left: 0;  <strong class="lt io"><em class="mf">// different for each letter</em></strong><br/>  transition: all 1s ease;<br/>}</span></pre><p id="2f45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要将字母<code class="fe mb mc md lt b">S</code>移动到不同的位置，我们可以将其<code class="fe mb mc md lt b">absolute</code>位置从<code class="fe mb mc md lt b">32px</code>设置为<code class="fe mb mc md lt b">320px</code>，假设每个字母占据<code class="fe mb mc md lt b">32px</code>。为了让动画更流畅，我们可以添加<code class="fe mb mc md lt b">transition</code>来让动画有一秒钟的放松感。</p><h2 id="dd15" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">我们制作什么动画？</h2><p id="0535" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">好的，HTML和CSS是确保字母在屏幕上移动的基本要素。但是我们需要一种方法来创建与动画帧相关联的状态。然后，我们可以在新位置显示字母，以防状态发生变化。</p><p id="9427" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑保存数组内容的<code class="fe mb mc md lt b">initialArr</code>:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="0314" class="ku kv in lt b gy lx ly l lz ma">const initialArr = 'asortingexample'.split('')<br/>['a', 's', 'o', ...]</span></pre><p id="f4b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们想问以下问题。如果我们跟踪第一个字母<code class="fe mb mc md lt b">a</code>，它会移动到什么位置？同样，如果仔细观察第二个字母<code class="fe mb mc md lt b">s</code>，它会移动到什么位置？本质上，我们希望跟踪每个字母的位置。虽然听起来很直观，但当你在研究算法时，这可能是一种非常不同的体验，因为你可以跟踪任何其他东西，大部分时间都是派生的属性。</p><p id="0897" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们使用一个<code class="fe mb mc md lt b">index</code>数组来跟踪每个字母的位置。例如，最初，第一个字母的位置是<code class="fe mb mc md lt b">0</code>，第二个字母的位置是<code class="fe mb mc md lt b">1</code>。但是经过几次移动后，第二个字母可以移动到位置<code class="fe mb mc md lt b">10</code>。假设我们知道当前运行的<code class="fe mb mc md lt b">index</code>数组，我们可以使用下面的React代码显示每个字母:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="f12e" class="ku kv in lt b gy lx ly l lz ma">      &lt;div className="canvas"&gt;<br/>        {<strong class="lt io">index</strong>.map((v, i) =&gt; (<br/>          &lt;span <br/>            key={i.toString()}<br/>            className="letter"<br/>            style={{ left: v * 32 }}<br/>          &gt;<br/>            {<strong class="lt io">initialArr</strong>[i]}<br/>          &lt;/span&gt;<br/>        ))}<br/>      &lt;/div&gt;</span></pre><p id="f852" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们从14个字母开始，以14个字母结束，因为它们是唯一的对象(尽管它们可以有重复的符号)。因此，我们不打算改变对象的列表；相反，我们只想算出他们当前的位置，然后乘以32，就像在<code class="fe mb mc md lt b">left: v * 32</code>中一样。</p><p id="21a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如何生成头寸？</strong></p><p id="4849" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好，现在给定一个位置列表，我们可以在屏幕上显示它们。但是谁会给我们每一帧的所有位置呢？当然，这是我们正在研究的算法。让我们在JavaScript生成器函数的帮助下创建一个:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="c1e2" class="ku kv in lt b gy lx ly l lz ma">function* <strong class="lt io">gen</strong>(array) {<br/>  const arr = [...array]<br/>  const index = arr.map((_, i) =&gt; i)<br/>  const n = arr.length<br/>  <br/>  for (let i = 0; i &lt; n - 1; i++) {<br/>    let m = i<br/>    for (let j = i + 1; j &lt; n; j++) {<br/>      if (arr[j] &lt; arr[m]) {<br/>        m = j<br/>      }<br/>    }</span><span id="8076" class="ku kv in lt b gy me ly l lz ma">    ii = index.indexOf(i)<br/>    mm = index.indexOf(m)<br/><br/>    t = index[mm]<br/>    index[mm] = index[ii]<br/>    index[ii] = t<br/><br/>    <strong class="lt io">yield</strong> { index: [...index] }<br/>  }<br/>};</span></pre><p id="9f2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我相信你可以从上面的代码中看到我们的算法。有两个循环，每个内部循环后都有一个交换。这比算法本身要复杂一点，但总体来说是直接翻译。开销是我们想要跟踪每个字母在<code class="fe mb mc md lt b">index</code>中的位置，而不是最终排序的数组<code class="fe mb mc md lt b">arr</code>。</p><p id="b853" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最重要的一行是<code class="fe mb mc md lt b">yield { index }</code>，在这里我们暂停算法并输出<code class="fe mb mc md lt b">index</code>。这就是我们如何得到当前状态的。将所有内容放在一起，我们得到以下组件<code class="fe mb mc md lt b">App</code>:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="cab0" class="ku kv in lt b gy lx ly l lz ma">const App = () =&gt; {<br/>  const [index, setIndex] = useState(initialIndex)<br/>  <br/>  useEffect(() =&gt; {<br/>    const g = <strong class="lt io">gen</strong>(initialArr)<br/>    const h = setInterval(() =&gt; {<br/>      const run = g.next()<br/>      if (!run.value) {<br/>        clearInterval(h)<br/>      } else {<br/>        setIndex(index)<br/>      }<br/>    }, 1000)<br/>    return () =&gt; { clearInterval(h) }<br/>  }, [])<br/>  <br/>  return (<br/>    &lt;&gt;<br/>      &lt;div className="canvas"&gt;<br/>        {index.map((v, i) =&gt; (<br/>          &lt;span <br/>            key={i.toString()}<br/>            className="letter"<br/>            style={{ left: v * 50 }}<br/>          &gt;<br/>            {initialArr[i]}<br/>          &lt;/span&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="caa5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本质上，我们设置了一个一次性的<code class="fe mb mc md lt b">useEffect</code>来运行一个动画循环，一旦<code class="fe mb mc md lt b">App</code>被加载，我们首先组装一个生成器<code class="fe mb mc md lt b">g=gen(initialArr)</code>。此后，对于每一秒<code class="fe mb mc md lt b">1000ms</code>，我们调用<code class="fe mb mc md lt b">g.next()</code>来获取下一个位置列表。React将确保<code class="fe mb mc md lt b">setIndex(index)</code>的每次更新都会触发屏幕渲染，以更新所有字母。</p><h2 id="168a" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">播放演示</h2><p id="5071" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">如果您错过了任何细节，请在这里随意体验现场演示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h2 id="4ae0" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">想要更多的动画？</h2><p id="648b" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">从这一刻起，你要做的只是添加更多的动画元素。例如，在交换之前，我们想首先识别我们正在比较的字母，这个字母是由变量<code class="fe mb mc md lt b">i</code>跟踪的。</p><p id="2425" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们需要修改生成器函数:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="bd9f" class="ku kv in lt b gy lx ly l lz ma">function* gen(array) {<br/>  const arr = [...array]<br/>  const index = arr.map((_, i) =&gt; i)<br/>  const n = arr.length<br/>  <br/>  for (let i = 0; i &lt; n - 1; i++) {<br/>    ii = index.indexOf(i)<br/>    <strong class="lt io">yield { index, ii, mm: -1, action: 'loop' }</strong><br/>    let m = i<br/>    for (let j = i + 1; j &lt; n; j++) {<br/>      if (arr[j] &lt; arr[m]) {<br/>        m = j<br/>      }<br/>    }</span></pre><p id="1d97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以再添加一行输出，谁说我们只能生成一种类型的项目，谁说我们只能生成同一类型的数据。在这里，我们可以通过<code class="fe mb mc md lt b">ii</code>跟踪字母的位置。而且我们还把这个动作命名为<code class="fe mb mc md lt b">loop</code>。所有这些都可以根据自己的目的进行修改。当我们开始使用这个生成器时，我们可以利用新的数据集做更多的事情:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="b3ff" class="ku kv in lt b gy lx ly l lz ma">const App = () =&gt; {<br/>  const [index, setIndex] = useState(initialIndex)<br/>  const [outterId, setOutterId] = useState(0) <br/>  <br/>  useEffect(() =&gt; {<br/>    const g = gen(initialArr)<br/>    const h = setInterval(() =&gt; {<br/>      const run = g.next()<br/>      if (!run.value) {<br/>        clearInterval(h)<br/>        setOutterId(-1)<br/>      } else {<br/>        const { index, ii, mm, action } = run.value<br/>        if (action === 'loop') {<br/>          setOutterId(ii)<br/>        } else {<br/>          setIndex(index)<br/>        }<br/>      }<br/>    }, 1000)<br/>    return () =&gt; { clearInterval(h) }<br/>  }, [])<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;div className="canvas"&gt;<br/>        {index.map((v, i) =&gt; (<br/>          &lt;span <br/>            key={i.toString()}<br/>            className={<br/>              "letter " +<br/>              (i === outterId ? 'highlight ' : '')<br/>            }<br/>            style={{ left: v * 50 }}<br/>          &gt;<br/>            {initialArr[i]}<br/>          &lt;/span&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="a989" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建新的状态变量<code class="fe mb mc md lt b">outterId</code>来跟踪<code class="fe mb mc md lt b">ii</code>位置。如果它匹配任何一个字母，它就会附加一个<code class="fe mb mc md lt b">highlight</code> CSS类，所以你可以用不同的方式显示它。</p><p id="f872" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mf">更多内容看</em> <a class="ae mi" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mf">说白了就是io </em> </strong> </a> <em class="mf">。报名参加我们的</em> <a class="ae mi" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mf">免费周报</em> </strong> </a> <em class="mf">。关注我们关于</em><a class="ae mi" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mf">Twitter</em></strong></a>，<a class="ae mi" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mf">LinkedIn</em></strong></a><em class="mf">，</em><a class="ae mi" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mf">YouTube</em></strong></a><em class="mf">，</em> <a class="ae mi" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mf">不和</em> </strong> </a> <em class="mf">。</em></p></div></div>    
</body>
</html>