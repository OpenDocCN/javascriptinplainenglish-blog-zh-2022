<html>
<head>
<title>When To Use React.memo() — And When Not To</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时使用React.memo() —何时不使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/when-and-when-not-to-use-react-memo-e050d3cb1ffc?source=collection_archive---------5-----------------------#2022-01-10">https://javascript.plainenglish.io/when-and-when-not-to-use-react-memo-e050d3cb1ffc?source=collection_archive---------5-----------------------#2022-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/db4a902b8d1ad6452b1e7a5b2ec5953c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YAWV0ku3f65i8WK5MExfQ.jpeg"/></div></div></figure><div class=""/><p id="fdb0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在计算中，记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。</p><p id="35d5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">React . memo()</em>—React 16 . 8 . 0中引入，类似于类组件的<em class="kt"> PureComponent </em>，提供了一种帮助我们控制组件何时重新渲染的方法。通过限制React组件的重新呈现，UI性能得到了提高。因此，通过快速响应的UI、平滑导航和无缝加载，增强了用户体验和与系统的交互。</p><p id="611d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<em class="kt"> React.memo() </em>是一个高阶组件，它可以围绕常规React功能组件包装自己。当React组件用<em class="kt"> React.memo() </em>包装时，React呈现组件并记忆结果。如果组件的属性在下一次渲染之前是相同的，那么React将重用已记忆的结果。通过这样做，可以跳过重新渲染，React不会更新DOM，从而实现性能提升。通过<em class="kt"> PureComponent可以在类组件中实现相同的功能。</em></p><p id="82d0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，在哪些情况下我们应该使用，或者避免使用React.memo()？</p><h2 id="ea57" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">何时使用:</h2><ol class=""><li id="ed7b" class="ln lo iy jx b jy lp kc lq kg lr kk ls ko lt ks lu lv lw lx bi translated">当我们期望一个功能组件经常会在第一次渲染之后进行渲染，通常使用相同的道具。发生这种情况的情况是，父组件强制子组件进行呈现。在这种情况下，在组件上应用记忆是合适的。</li><li id="3b1b" class="ln lo iy jx b jy ly kc lz kg ma kk mb ko mc ks lu lv lw lx bi translated">当我们拥有<strong class="jx iz">纯功能组件</strong>时。给定相同的道具，这样的组件将保持不变—总是呈现相同的输出。</li><li id="21f6" class="ln lo iy jx b jy ly kc lz kg ma kk mb ko mc ks lu lv lw lx bi translated">当我们的组件很大，并且包含大量的UI元素，以至于重新呈现会导致用户可察觉的响应延迟时。</li></ol><h2 id="1360" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">何时不使用:</h2><ol class=""><li id="2099" class="ln lo iy jx b jy lp kc lq kg lr kk ls ko lt ks lu lv lw lx bi translated">我们应该避免使用<em class="kt"> React.memo() </em>的第一个也是最明显的情况是当我们无法量化从中获得的性能收益时。如果我们的组件重新渲染的计算时间——有和没有这个高阶组件——可以忽略或不存在，那么使用<em class="kt"> React.memo() </em>将是无用的。</li><li id="67e8" class="ln lo iy jx b jy ly kc lz kg ma kk mb ko mc ks lu lv lw lx bi translated">在某些情况下，我们希望一个组件用不同的道具重新渲染。默认情况下，React.memo() 执行属性相等检查，以确定组件的渲染属性是否相等。只有前一个属性等于后一个属性，等式才会返回true。如果我们的组件使用不同的道具重新渲染，那么这个等式检查将返回false，强制React执行上一个和下一个道具的差异。由于这种无用的道具比较，以及React将总是在每个渲染上执行2个任务的事实，这样一个“易变”组件不应该被包装在<em class="kt"> React.memo() </em>中。这样不仅没有性能增益，还会损害性能！</li><li id="bb1e" class="ln lo iy jx b jy ly kc lz kg ma kk mb ko mc ks lu lv lw lx bi translated">尽管在<em class="kt"> React.memo() </em>中包装类组件是可能的，但它被认为是(也确实如此)不好的实践，并且是非常不鼓励的。相反，在处理类组件时，扩展一个PureComponent类更可取，也是一种更干净的处理内存化的方式。</li></ol><p id="2844" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> React.memo() </em>的用例及回避情况包括但不限于上述实例。</p><p id="6fee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">严格使用<em class="kt"> React.memo() </em>作为具有经常重新渲染的组件的应用程序的性能提升。但是，请记住，如果状态改变，React组件将总是重新呈现——不管组件是否被包装在<em class="kt"> React.memo() </em>中。</p><p id="edfe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容看</em> <a class="ae md" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> <em class="kt">说白了就是</em> </strong> </a> <em class="kt">。报名参加我们的</em> <a class="ae md" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> <em class="kt">免费周报</em> </strong> </a> <em class="kt">。在我们的</em> <a class="ae md" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> <em class="kt">社区不和谐</em> </strong> </a> <em class="kt">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>