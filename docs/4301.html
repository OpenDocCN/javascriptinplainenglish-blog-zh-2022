<html>
<head>
<title>Using Different Layout Frames For Different Routes In Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在角度上对不同的路线使用不同的布局框架</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-different-layout-frames-for-different-routes-in-angular-d96ed096c633?source=collection_archive---------2-----------------------#2022-11-18">https://javascript.plainenglish.io/using-different-layout-frames-for-different-routes-in-angular-d96ed096c633?source=collection_archive---------2-----------------------#2022-11-18</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/3dc220e7953ae5d1f90fe7826233b2ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9h5XTT05IKLOkA52EbqHeQ.jpeg"/></div></div></figure><p id="e534" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">假设你有一个很好的角度应用。主页有一个非常简洁的外观，透明的页眉和一个大页脚。登录和注册页面根本没有页眉和页脚，表单在页面上居中。登录的仪表板视图有一个侧边栏，一个黑色的导航栏和一个不同的页脚，只包含版权和版本信息。这些都是框架的例子。</p><p id="b236" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">你知道Angular呈现应用程序代替了<code class="fe kx ky kz la b">&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>标签。您的根组件(通常是<code class="fe kx ky kz la b">app.component.ts</code>)如下:</p><pre class="lb lc ld le gu lf la lg bn lh li bi"><span id="dcce" class="lj lk ir la b be ll lm l ln lo">&lt;main&gt;<br/>  &lt;header&gt;My App&lt;/header&gt;<br/><br/>  &lt;div class="container"&gt;<br/>    &lt;router-outlet&gt;&lt;/router-outlet&gt;<br/>  &lt;/div&gt;<br/><br/>  &lt;footer&gt;<br/>    Footer content<br/>  &lt;/footer&gt;<br/>&lt;/main&gt;</span></pre><p id="61c0" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">如果是这样的话，那么你所有的页面都会显示页眉和页脚。那你是如何在不同的框架中显示不同的页面的呢？</p><h1 id="1fcd" class="lp lk ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤1:定义布局</h1><p id="cb20" class="pw-post-body-paragraph jz ka ir kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw ik bi translated">首先，制作一个<code class="fe kx ky kz la b">enum AppLayoutType</code>,保存我们的应用程序需要的布局框架类型。</p><pre class="lb lc ld le gu lf la lg bn lh li bi"><span id="8ea0" class="lj lk ir la b be ll lm l ln lo">export enum AppLayoutType {<br/>    Default = 'default',<br/>    Sidebar = 'sidebar', // with sidebar<br/>    Center = 'center', // centered content, no frame<br/>    Blank = 'blank', // no frame<br/>    Admin = 'admin', // admin layout<br/>}</span></pre><h1 id="dc70" class="lp lk ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤2:添加到路线数据</h1><p id="25d8" class="pw-post-body-paragraph jz ka ir kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw ik bi translated">在routes配置中，添加一个数据对象。当路由被解析时，该数据将通过<code class="fe kx ky kz la b">ActivatedRoute</code>类作为静态值可用。这个数据对象应该保存布局框架的信息。在下面的例子中，我们使用<code class="fe kx ky kz la b">Center</code>布局作为登录页面(1)，使用<code class="fe kx ky kz la b">Admin</code>布局作为管理路径(2)。</p><pre class="lb lc ld le gu lf la lg bn lh li bi"><span id="465b" class="lj lk ir la b be ll lm l ln lo">const routes: Routes = [<br/>  // ... other routes<br/>  {<br/>     path: 'login',<br/>     data: { <br/>       layout: AppLayoutType.Center // 1<br/>     }, <br/>     loadComponent: () =&gt; import('./pages/login-page.component')<br/>                          .then((m) =&gt; m.LoginPageComponent),<br/>  },<br/>  {<br/>    path: 'admin',<br/>    data: { <br/>      layout: AppLayoutType.Admin // 2<br/>    }, <br/>    loadChildren: () =&gt; import('./admin/admin.routes')<br/>                        .then((m) =&gt; m.ADMIN_ROUTES),<br/>  },<br/>];</span></pre><h1 id="8f2c" class="lp lk ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤3:布局组件</h1><p id="0f96" class="pw-post-body-paragraph jz ka ir kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw ik bi translated">定义各种布局组件，例如，默认、侧边栏、管理、空白、居中等。确保您在适当的地方使用了<code class="fe kx ky kz la b">&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>标签。</p><pre class="lb lc ld le gu lf la lg bn lh li bi"><span id="33c7" class="lj lk ir la b be ll lm l ln lo">@Component({<br/>  selector: 'app-layout-centered',<br/>  standalone: true,<br/>  imports: [CommonModule, RouterModule],<br/>  template: `<br/>&lt;div class="flex h-screen w-full items-center justify-center"&gt;<br/><br/>    &lt;router-outlet&gt;&lt;/router-outlet&gt;<br/><br/>&lt;/div&gt;<br/>  `,<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>})<br/>export class LayoutCenteredComponent {}</span></pre><pre class="mr lf la lg bn lh li bi"><span id="42ce" class="lj lk ir la b be ll lm l ln lo">@Component({<br/>  selector: 'app-layout-sidebar',<br/>  standalone: true,<br/>  imports: [CommonModule, RouterModule, MaterialModules, HeaderOneComponent, FooterOneComponent],<br/>  template: `<br/>&lt;mat-sidenav-container class="sidenav-container"&gt;<br/>  &lt;mat-sidenav&gt;<br/>    &lt;!-- sidenav items --&gt;<br/>  &lt;/mat-sidenav&gt;<br/><br/>  &lt;mat-sidenav-content&gt;<br/>    &lt;app-header-one class="sticky top-0 z-50"&gt;&lt;/app-header-one&gt;<br/>    &lt;main class="container px-2 pt-4 md:px-6"&gt;<br/><br/>        &lt;router-outlet&gt;&lt;/router-outlet&gt;<br/><br/>    &lt;/main&gt;<br/>    &lt;app-footer-one&gt;&lt;/app-footer-one&gt;<br/>  &lt;/mat-sidenav-content&gt;<br/>&lt;/mat-sidenav-container&gt;<br/>  `,<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>})<br/>export class LayoutSidebarComponent {}</span></pre><h1 id="0b37" class="lp lk ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤4:应用程序组件</h1><p id="bd23" class="pw-post-body-paragraph jz ka ir kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw ik bi translated">现在，在app组件中定义框架组件。应用程序组件应该作为一个切换面板。</p><pre class="lb lc ld le gu lf la lg bn lh li bi"><span id="b32e" class="lj lk ir la b be ll lm l ln lo">&lt;ng-container [ngSwitch]="layout$ | async"&gt;<br/>  &lt;app-layout-default <br/>    *ngSwitchCase="AppLayoutType.Default"&gt;<br/>  &lt;/app-layout-default&gt;<br/><br/>  &lt;app-layout-centered <br/>    *ngSwitchCase="AppLayoutType.Center"&gt;<br/>  &lt;/app-layout-centered&gt;<br/><br/>  &lt;app-layout-sidebar <br/>    *ngSwitchCase="AppLayoutType.Sidebar"&gt;<br/>  &lt;/app-layout-sidebar&gt;<br/><br/>  &lt;router-outlet <br/>    *ngSwitchCase="AppLayoutType.Blank"&gt;<br/>  &lt;/router-outlet&gt;<br/><br/>  &lt;app-layout-default <br/>    *ngSwitchDefault&gt;<br/>  &lt;/app-layout-default&gt;<br/>&lt;/ng-container&gt;</span></pre><p id="39d5" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">对于每个导航，我们将递归地到达它的父<code class="fe kx ky kz la b">ActivatedRoute</code>实例，直到我们得到第一个实例，因为基本路由配置保存了布局类型。为此，我们将使用一些由<a class="ae ms" href="https://ultimatecourses.com/author/toddmotto" rel="noopener ugc nofollow" target="_blank">托德格言</a>建议的代码。</p><pre class="lb lc ld le gu lf la lg bn lh li bi"><span id="d1fe" class="lj lk ir la b be ll lm l ln lo">return this.router.events.pipe(<br/>  filter((event) =&gt; event instanceof NavigationEnd), // 1<br/>  map(() =&gt; this.activatedRoute),     // 2<br/>  map((route) =&gt; {                    // 3<br/>    while (route.firstChild) {<br/>      route = route.firstChild<br/>    }<br/>    return route<br/>  }),<br/>  filter((route) =&gt; route.outlet === 'primary'), // 4<br/>  mergeMap((route) =&gt; route.data),    // 5<br/>  map((data) =&gt; data.layout),         // 6<br/>)</span></pre><h2 id="0395" class="mt lk ir bd lq mu mv dn lu mw mx dp ly kk my mz mc ko na nb mg ks nc nd mk ne bi translated">发生了什么事？</h2><ol class=""><li id="8092" class="nf ng ir kb b kc mm kg mn kk nh ko ni ks nj kw nk nl nm nn bi translated">等待路由器的<code class="fe kx ky kz la b">NavigationEnd</code>事件，因为它意味着刚刚导航到一条路由。</li><li id="e41e" class="nf ng ir kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated">以那一刻的<code class="fe kx ky kz la b">ActivatedRoute</code>为例。</li><li id="5af7" class="nf ng ir kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated">到达<code class="fe kx ky kz la b">ActivatedRoute</code>树的根部。根实例没有<code class="fe kx ky kz la b">.firstChild</code>属性。</li><li id="6c94" class="nf ng ir kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated">确保路线将在主<code class="fe kx ky kz la b">router-outlet</code>中呈现，而不是在命名的路径中呈现。</li><li id="aca5" class="nf ng ir kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated">从包含布局信息的路线中提取<code class="fe kx ky kz la b">data</code>。</li><li id="ed66" class="nf ng ir kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated">仅选择<code class="fe kx ky kz la b">layout</code>值。</li></ol><p id="fbf8" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated">您最终的应用程序组件应该如下所示:</p><pre class="lb lc ld le gu lf la lg bn lh li bi"><span id="ba60" class="lj lk ir la b be ll lm l ln lo">@Component({<br/>  standalone: true,<br/>  selector: 'app-root',<br/>  template: `<br/>&lt;ng-container [ngSwitch]="layout$ | async"&gt;<br/>  &lt;app-layout-default *ngSwitchCase="AppLayoutType.Default"&gt;&lt;/app-layout-default&gt;<br/>  &lt;app-layout-centered *ngSwitchCase="AppLayoutType.Center"&gt;&lt;/app-layout-centered&gt;<br/>  &lt;app-layout-sidebar *ngSwitchCase="AppLayoutType.Sidebar"&gt;&lt;/app-layout-sidebar&gt;<br/>  &lt;router-outlet *ngSwitchCase="AppLayoutType.Blank"&gt;&lt;/router-outlet&gt;<br/>  &lt;app-layout-default *ngSwitchDefault&gt;&lt;/app-layout-default&gt;<br/>&lt;/ng-container&gt;<br/>  `,<br/>  imports: [CommonModule, RouterModule, LayoutCenteredComponent, LayoutDefaultComponent, LayoutSidebarComponent],<br/>})<br/>export class AppComponent {<br/>  layout$ = this.getLayoutType$()<br/><br/>  readonly AppLayoutType = AppLayoutType<br/><br/>  constructor(<br/>    private activatedRoute: ActivatedRoute,<br/>    private router: Router,<br/>  ) {}<br/><br/>  private getLayoutType$(): Observable&lt;AppLayoutType&gt; {<br/>    return this.router.events.pipe(<br/>      filter((event) =&gt; event instanceof NavigationEnd),<br/>      map(() =&gt; this.activatedRoute),<br/>      map((route) =&gt; {<br/>        while (route.firstChild) {<br/>          route = route.firstChild<br/>        }<br/>        return route<br/>      }),<br/>      filter((route) =&gt; route.outlet === 'primary'),<br/>      mergeMap((route) =&gt; route.data),<br/>      map(({ layout }) =&gt; layout),<br/>    )<br/>  }<br/>}</span></pre><h1 id="64fe" class="lp lk ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">第五步:跑步</h1><p id="853c" class="pw-post-body-paragraph jz ka ir kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw ik bi translated">就是这样！现在运行应用程序，导航到应用程序的各种路线。如果您已经为路径指定了特定的框架，您将会看到组件使用该布局进行渲染。如果没有指定，那么它将使用默认的大小写。</p><h1 id="a778" class="lp lk ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="5ee3" class="pw-post-body-paragraph jz ka ir kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw ik bi translated">Angular以声明的方式做的事情令人惊讶。大多数情况下，棱角分明有助于你和你的团队以协调的方式快速前进。确保您充分利用它所提供的优势！</p><p id="473b" class="pw-post-body-paragraph jz ka ir kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ik bi translated"><em class="nt">更多内容请看</em><a class="ae ms" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb is"><em class="nt">plain English . io</em></strong></a><em class="nt">。报名参加我们的</em> <a class="ae ms" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb is"> <em class="nt">免费周报</em> </strong> </a> <em class="nt">。关注我们关于</em><a class="ae ms" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kb is"><em class="nt">Twitter</em></strong></a><a class="ae ms" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kb is"><em class="nt">LinkedIn</em></strong></a><em class="nt"/><a class="ae ms" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kb is"><em class="nt">YouTube</em></strong></a><em class="nt"/><a class="ae ms" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kb is"><em class="nt">不和</em> </strong> </a> <em class="nt">。对增长黑客感兴趣？检查</em> <a class="ae ms" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb is"> <em class="nt">电路</em> </strong> </a> <em class="nt">。</em></p></div></div>    
</body>
</html>