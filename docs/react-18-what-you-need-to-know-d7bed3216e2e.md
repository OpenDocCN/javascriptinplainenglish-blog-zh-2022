# 反应 18:你需要知道的

> 原文：<https://javascript.plainenglish.io/react-18-what-you-need-to-know-d7bed3216e2e?source=collection_archive---------7----------------------->

## 你应该升级你的代码吗？

![](img/3312ee47101b9836de5fdccc8f2936d8.png)

React 18 终于出来了。这个新版本有什么新特点？你应该现在更新你的代码吗？应该怎么做，可能会遇到哪些问题？

先说最后一个问题……

# 在实践中升级到 React 18

让我们先把手弄脏。我有一个旧的存储库，是我第一次做 React 教程时建立的。这个库可以追溯到 React 16 的 Hooks 之前的版本。这感觉像是最坏的情况。这将允许我们看到当我们将 React 从版本 16 更新到版本 18 时会发生什么。

剧透提醒:很快而且无痛。这就是 React 17“无特色更新”的全部内容。

让我们看看实践中会发生什么。首先，如果我们在 NPM 下面，我们会运行:

```
npm install react@18.0.0 react-dom@18.0.0
```

如果我们使用纱线，我们将运行:

```
yarn add react@18.0.0 react-dom@18.0.0
```

当我启动这个项目时，一切似乎都很好。但是，如果我们打开控制台，我们会看到以下消息:

> React 18 中不再支持 ReactDOM.render。请改用 createRoot。在您切换到新的 API 之前，您的应用程序将表现得像运行 React 17 一样”

这是什么意思？这意味着两件事。

第一件事是 React 团队已经弃用了初始化 React 的代码。如果你想利用 React 的新特性，代码不再是正确的做事方式。

第二件事是 React 很好地处理了反对*的问题。*

当然，我的初始化并不理想。但是反应不会给我带来任何痛苦。如你所见，我的代码仍然工作正常，没有任何问题。那么，我该如何解决这个问题呢？如果我查看我的代码，导入和初始化部分显示:

```
import ReactDOM from “react-dom”;
//…. and then 
const root = document.getElementById(“root”);
ReactDOM.render(<App />, root); 
```

初始化方法已更改，导入也已更改。现在，在 React 18 中，我们需要导入客户端版本的 React-dom，方法是:

```
import ReactDOM from “react-dom/client”;
```

这是因为存在该代码的服务器端版本。现在初始化分两步完成:

```
// first 
const root = ReactDOM.createRoot(rootElement);
root.render(<App/>);
```

设置现在分为两步，以区分客户端和服务器端的操作，或者允许我们在根上做水合物，而不是渲染。现在，如果只做这两处修改，我的编辑器会抛出一个打字错误。如果您正在使用 typescript，您还需要通过执行以下操作来更新类型:

```
yarn add [@types/react](http://twitter.com/types/react)@18.0.0 [@types/react-dom](http://twitter.com/types/react-dom)@18.0.0
```

一旦这些小的修复完成，一切都运行…没有任何问题。因此，您可以将 React 更新到版本 18，而无需特别担心。但是这样做有意义吗？让我们来谈谈 React 18 带来了什么。

# React 18 的新特性

而现实是几乎没有什么看得见的变化。比 React 17 的“无特色更新”更是如此。但还是。在这里，在版本 18 中，我们看到 React 团队正在与下一个 JS 团队携手工作。以及在较小程度上的混音。因为说实话，你和我不会在我们的代码中使用大部分新特性。相反，我们将使用调用它们的第三方库或框架。但是，让我们来谈谈可能会产生重大影响的改进。首先，有一个概念…

## 自动渲染批处理

现在，让我们想象我们正在管理两个状态。例如，一个表示分数，第二个表示可用的操作。采取行动的用户将增加分数并减少可用的行动。因此，在我们的代码中，我们应该这样写:

```
setScore(score +1);
setActions(actions — 1);
```

换句话说，我们正在更新状态两次。到目前为止，React 将检测两个独立的状态更新并触发两个渲染。但是 React 18 引入了自动“批处理”的概念，即渲染任务的分组。尽管有两个独立的状态更新，应用程序将重新呈现一次。

它值得充分利用。虽然我不知道你们中有多少人遇到过性能问题。从理论上来说，这种缺乏有用性的情况对于其他新特性来说更是如此。

让我们快速浏览一下。首先，我们有…

## 并发模式

用简单的话来说，就是打破渲染的单一性。

这就是说:“看看这个计算，对于 UI 的那一部分。我们可以把它推迟到我们有计算能力的时候。那块 UI 在等待的时候可以用一个旧值。”为此，有一个“过渡”的概念，它体现了一种非紧急的变化。

让我们以过滤列表为例。用户开始在过滤器中键入文本。他们希望界面能立即显示输入的文本。以及显示正在进行过滤的列表。

但是如果显示过滤后的结果需要几秒钟，用户会理解的。所以对于同一个动作，我们有两种截然不同的反应。一个紧急反应和一个非紧急反应。这种非紧急反应就是 React 团队所说的“过渡”。

所以我们现在可以使用一个钩子(称为 *useTransition* )和函数(称为 *startTransition* )来实现它。

但是正如宣布 React 发布的博文所说:

> “我们预计，向应用添加并发性的主要方式是使用支持并发的库或框架。在大多数情况下，您不会直接与并发 API 交互。例如，不再是开发人员每次导航到新屏幕时都调用 startTransition，路由器库将自动在 startTransition 中包装导航

对于我们的下一个话题来说更是如此…

## 服务器端渲染

服务器端渲染和流(仍在开发中)是为 NextJS 或 Remix 这样的框架设计的。您可能不会直接使用这个特性。当然，除非您正在构建自己的服务器端框架。

但是这个特性给 NextJS 或 Remix 带来了很大的希望。

这就引出了我的下一点

# 最后

是否应该升级到 React 18？答案是肯定的。不是因为它会彻底改变我们的代码。而是因为没有好的理由不这样做，因为它是如此的无痛。

如果您的应用程序是计算密集型的，这些新特性将会非常有用。即使简单的应用程序也能从优化中获益。

真正好处是通过像 React Router 这样的库和像 NextJS 或 Remix 这样的框架。他们将利用 React 18 的新功能。通过这样做，他们将提供用户和开发人员体验的改进，错过这些将是一种耻辱！

因此，为了利用 React 18，我建议您使用 NextJS 或 Remix 框架。

*更多内容请看*[***plain English . io***](https://plainenglish.io/)*。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。关注我们关于*[***Twitter***](https://twitter.com/inPlainEngHQ)*和*[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*。查看我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *加入我们的* [***人才集体***](https://inplainenglish.pallet.com/talent/welcome) *。*