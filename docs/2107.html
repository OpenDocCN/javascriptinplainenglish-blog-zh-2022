<html>
<head>
<title>Access the Previous &amp; Current URLs in the Parent, Child &amp; Grandchild Components in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular中访问父组件、子组件和孙组件中以前和当前的URL</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-accessing-the-previous-and-current-url-in-the-parent-child-and-grandchild-components-99b899505042?source=collection_archive---------0-----------------------#2022-05-15">https://javascript.plainenglish.io/angular-accessing-the-previous-and-current-url-in-the-parent-child-and-grandchild-components-99b899505042?source=collection_archive---------0-----------------------#2022-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="995d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何在Angular中访问父组件、子组件和孙组件中的以前和当前URL的全面指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6225eafbd861b2bdbb579e3e1a65c1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l-hvjsge13LHdoHm"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5142" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，能够访问应用程序以前的URL非常有用。想象一下，你登录到你的谷歌帐户，并在谷歌驱动器的一些文件上工作。然后，您意识到您需要存储在您拥有的另一个帐户的驱动器存储器中的一些信息。显然，你登录到另一个帐户，然后你会被自动重定向到同一个Google drive页面。</p><p id="9b77" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我不知道谷歌是如何做到这一点的，但这是我能想到的访问之前的URL的最佳用例:)</p><p id="5f8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我用来演示的例子并不复杂。就像下面的截图一样简单:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/95d9e9291e2292a707d0aa5b50e91dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSIOF9FzdDT3you1LZCBbA.png"/></div></div></figure><p id="e6e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我使用了4个组件来展示应用程序中不同级别的组件如何访问以前和当前的URL。</p><ol class=""><li id="1256" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated"><strong class="kv io"> AppComponent </strong>是托管<strong class="kv io"> CommonComponent、TestComponent和Test2Component的引导组件。</strong></li></ol><p id="a42e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">CommonComponent的一个例子是在整个应用程序中可见的应用程序标题。</p><p id="2fca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TestComponent和Test2Component是通过按钮导航的，正如您在上面的截图中所看到的。</p><p id="9c03" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> AppComponent模板</strong>如下图所示:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="f5f6" class="me mf in ma b gy mg mh l mi mj">&lt;div class=”appContainer”&gt;</span><span id="7f0c" class="me mf in ma b gy mk mh l mi mj">&lt;h4&gt;I am App Component&lt;/h4&gt;</span><span id="d105" class="me mf in ma b gy mk mh l mi mj"><strong class="ma io">&lt;app-common&gt;&lt;/app-common&gt;</strong></span><span id="4c0e" class="me mf in ma b gy mk mh l mi mj"><strong class="ma io">&lt;router-outlet&gt;&lt;/router-outlet&gt;</strong></span><span id="2f54" class="me mf in ma b gy mk mh l mi mj">&lt;button <strong class="ma io">routerLink=”/test"</strong>&gt;<strong class="ma io">TestComponent</strong>&lt;/button&gt;</span><span id="4892" class="me mf in ma b gy mk mh l mi mj">&lt;button <strong class="ma io">routerLink=”/test2"</strong>&gt;<strong class="ma io">Test2Component</strong>&lt;/button&gt;</span><span id="98f7" class="me mf in ma b gy mk mh l mi mj">&lt;/div&gt;</span></pre><p id="5e46" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> AppComponent </strong>类执行检索当前和先前URL的全部逻辑。当前和以前的URL存储在一个对象中，而<strong class="kv io">设置在TestService </strong>的主题中。</p><p id="8f4c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其他子组件简单地<strong class="kv io">订阅这个subject来接收应用程序的当前和以前的URL。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="795f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很简单的逻辑。</p><p id="a111" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;我们首先将由<strong class="kv io"> router.events </strong>发出的值过滤为类型为<strong class="kv io"> RoutesRecognized </strong>的值。</p><p id="42b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;当我们第一次在浏览器中加载应用程序或刷新浏览器选项卡时，应用程序不知道以前的URL。因此，我们使用了<strong class="kv io"> rx.js startWith() </strong>操作符将初始值设置为一个<strong class="kv io">空对象</strong>。</p><p id="cac7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;接下来，我们应用<strong class="kv io"> rx.js pairwise() </strong>操作符来捕获数组中<strong class="kv io"> RoutesRecognized </strong>类型发出的先前和当前值。数组的第一个元素包含前一个值，第二个元素包含当前值。</p><p id="e396" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果没有先前的发射，则<strong class="kv io"> pairwise() </strong>操作符不发射任何值。这是添加<strong class="kv io"> startWith() </strong>操作符来设置初始值的另一个原因，这样可以解决“没有先前发射”的问题。</p><p id="d271" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;我们添加了tap操作符来捕获pairwise()操作符的输入和输出。</p><p id="dea1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;在subscribe块中，我们创建了一个具有两个属性<strong class="kv io"> previous和current </strong>的对象。previous属性将包含前一个URL，current属性将包含当前URL。</p><p id="a9ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们首先检查数组的第一个元素是否有属性<strong class="kv io">urlaftredirects。</strong>如果不是，则暗示第一个元素是空对象。因此，我们将<strong class="kv io">属性previous </strong>设置为字符串<strong class="kv io">“要么选项卡被刷新，要么这是该应用程序中加载的第一个url”。</strong></p><p id="a6ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果<strong class="kv io">urlaftredirects</strong>属性存在，那么我们将<strong class="kv io">先前属性</strong>设置为<strong class="kv io">urlaftredirects</strong>属性值<strong class="kv io">。</strong></p><p id="f891" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">数组的第二个元素在任何时候都有一个值。我们直接将<strong class="kv io">当前属性</strong>设置为<strong class="kv io"> urlAfterRedirects </strong>属性值<strong class="kv io">。</strong></p><p id="1b20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.<strong class="kv io"> GrandChildAComponent </strong>是test 2组件的子组件，通过一个按钮导航。我们很快就会看到这一点。</p><p id="9bee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是最终的路由结构:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="54db" class="me mf in ma b gy mg mh l mi mj">const routes: Routes = [<br/>{<br/>path: ‘test’,<br/>component: TestComponent,<br/>},<br/>{<br/>path: ‘test2’,<br/>component: Test2Component,<br/>children:[<br/>{<br/>path:’grandChildA’,<br/>component:GrandChildAComponent<br/>}<br/>]<br/>},<br/>];</span></pre><p id="5202" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.最后，在<strong class="kv io">测试服务</strong>中，</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c7b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有的子组件都有相同的订阅逻辑。因此，我将在一节课中展示这个逻辑。</p><p id="3b3f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">通用组件类</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="80d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们检查所有的场景。</p><p id="224a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;假设我刚刚加载了应用程序。</p><p id="e692" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">当前URL将为“/”</strong>，并且<strong class="kv io">之前的URL将无法访问</strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/a77907051b321976de916a09602852bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_EbWwayQ0evUISuwMb3Vw.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/f9ce40a2b770b1048340edbcc888cd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrIJfTbFq7ESBC1Bnorjnw.png"/></div></div></figure><p id="1c1f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二个屏幕截图显示了tap()操作符的日志。第一个日志是router.events 发出的<strong class="kv io">当前值，第二个日志是pairwise()操作符发出的数组。如您所见，数组的第一个元素是{}，第二个元素是router.events发出的当前值</strong></p><p id="4eaf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;点击TestComponent按钮时，<strong class="kv io">当前URL将为“/test”</strong>，而<strong class="kv io">之前的URL为“/”。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/4f8d3f7bfd320a133d0d26fc7d645f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFdPvXiEaDtiOrZEIUGgxw.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/d6dc23de19efd7a020bfad728187b696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6C0t1gGSkBuVZgft8IQQA.png"/></div></div></figure><p id="8c36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;点击test2组件按钮时，<strong class="kv io">当前URL将是“/test 2”</strong>，而<strong class="kv io">以前的URL将是“/test”</strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/735bc5af4c292292fc48875c715e0ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QfuWM8qzfbmVnlKjP3wXFg.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/b847f425a7e40c0321ee761649248c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EI0tBLibu1o-6LF0ENNF1A.png"/></div></div></figure><p id="2f2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;点击GrandChildAComponent按钮时，<strong class="kv io">当前URL将为“/test2/grandChildA”，之前的URL将为“/test2”</strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mt"><img src="../Images/a5e0ae4d46274422ed5f79c83819060c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWSOKkzTvROE2OwE8AZ_gQ.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/faf45dfaa999d60677974842c6b1296b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOJGaIMjAoAYlSs9G6IGuw.png"/></div></div></figure><p id="5372" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;如果我现在刷新浏览器选项卡，<strong class="kv io">当前URL将会是“/test2/grand childa”</strong>并且不能访问<strong class="kv io">以前的URL</strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/d56089506a5ec838d18b23bd52b98368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahOfaGAYp2Mji2fBzajUFw.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/5edb92eb85b609abbb3d1ee8ab03a10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHNPcQoW1F3ta5-jt0KJzw.png"/></div></div></figure><p id="5ec0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以查看下面的完整工作示例:</p><div class="mw mx gp gr my mz"><a href="https://stackblitz.com/edit/angular-mzyyit?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">角形(叉形)堆叠</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">stackblitz.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn km mz"/></div></div></a></div><p id="3a1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="no">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="no">plain English . io</em></strong></a><em class="no">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="no">免费周报</em> </strong> </a> <em class="no">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="no">Twitter</em></strong></a><em class="no">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="no">LinkedIn</em></strong></a><em class="no">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="no">社区不和谐</em> </strong> </a> <em class="no">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="no">人才集体</em> </strong> </a> <em class="no">。</em></p></div></div>    
</body>
</html>