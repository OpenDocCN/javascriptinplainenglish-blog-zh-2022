<html>
<head>
<title>React Query Pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React查询分页</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-query-pagination-4681af0e6c83?source=collection_archive---------8-----------------------#2022-10-19">https://javascript.plainenglish.io/react-query-pagination-4681af0e6c83?source=collection_archive---------8-----------------------#2022-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2449" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">易于添加的分页</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a0490ab42b20a650687070f1dca90b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0xmKLP7XWqa1dBdl"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b0fb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">页码</h1><p id="f1e7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">分页是一种以更智能的方式处理网站性能的常用技术。现在，我们经常提供无限滚动分页，这意味着一旦用户滚动到底部，新的数据就会被获取或分页。</p><p id="b9dd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我在我的网站<a class="ae kv" href="https://ihatereading.in/" rel="noopener ugc nofollow" target="_blank"> iHateReading </a>上添加了这种分页技术。我使用的技术栈是用于API调用和数据缓存的react-query。</p><p id="ee59" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我也使用过<a class="ae kv" href="https://dev.to/shreyvijayvargiya/intersection-observer-api-1901" rel="noopener ugc nofollow" target="_blank">浏览器接口API </a>。这个API主要帮助浏览器跟踪和检测独占的DOM元素位置。交叉点API有助于跟踪DOM元素的位置，并在超过阈值时调用回调方法。</p><h1 id="76b6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">真实世界的例子</h1><ul class=""><li id="19d3" class="mp mq iq lq b lr ls lu lv lx mr mb ms mf mt mj mu mv mw mx bi translated">假设我们在长长的博客列表的最底部有一个“加载更多”按钮。</li><li id="b328" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">“加载更多”按钮被按下或出现在视图中，我们将使用API获取新数据</li></ul><p id="53ea" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">交集API基本上帮助我们跟踪load more按钮视图，并在交集时调用回调方法。</p><h1 id="f76b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">反应查询</h1><p id="78c4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">React query是一个钩子的集合，有助于在前端缓存和获取数据。我不会深入研究react-query的细节，因为我已经讲述了很多关于它的故事。</p><p id="86df" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://studio.youtube.com/video/QW9514m5dlI/edit" rel="noopener ugc nofollow" target="_blank"> React查询短裤介绍</a></p><p id="7ce7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://medium.com/codex/3-steps-to-quickly-start-with-react-query-a3012c62b18b" rel="noopener"> React查询文章</a></p><h1 id="a703" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">如何添加分页</h1><p id="ebe3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们将方法分为两个阶段，一个是API调用，另一个是分页或页码。</p><p id="fb72" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">获取数据的API调用</strong> <br/> API调用将从数据库中获取元素的页码。例如，第一页将获取10个项目，然后页码= 2将从第11个项目到第20个项目获取项目，依此类推。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d600" class="ni kx iq ne b gy nj nk l nl nm">const {data, isLoading } = useQuery(["blogs"], <br/> async() =&gt; { <br/>  const data = await fetchBlogs(pageNumber);<br/>  return data;<br/> }<br/>);</span></pre><p id="6017" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">页码</strong> <br/>页码由UI跟踪维护。一旦用户到达load more按钮，intersection API将调用回调方法，并将页码增加1。这种情况一直持续到页码达到最后一个值。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f66c" class="ni kx iq ne b gy nj nk l nl nm">const [pageNumber, setPageNumber] = useState(0);<br/>const [isIntersecting, setIntersecting] = useState(false);<br/>const observer = new IntersectionObserver(([entry]) =&gt;<br/> setIntersecting(entry.isIntersecting));</span><span id="fad5" class="ni kx iq ne b gy nn nk l nl nm">useEffect(() =&gt; {<br/> observer.observe(ref.current);<br/>   return () =&gt; observer.disconnect();<br/>}, []);</span></pre><p id="6bb3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> API获取分页数据</strong></p><ul class=""><li id="56dd" class="mp mq iq lq b lr mk lu ml lx no mb np mf nq mj mu mv mw mx bi translated">一旦我们点击“加载更多”按钮,<code class="fe nr ns nt ne b">isIntersection</code>状态将变为真</li><li id="ee6b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">交叉点API的回调函数将得到，并且页码值将增加1。</li><li id="2c9a" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><code class="fe nr ns nt ne b">useQuery</code>将再次调用通过传递更新的pageNumber值来调用<code class="fe nr ns nt ne b">fetchBlogs</code>方法的API调用。因此，我们的分页数据或接下来的10个项目将被提取。React query将自动缓存这些新数据，以提供更好的用户体验并减少API调用的数量。</li></ul><h1 id="b243" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="3ed8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这很容易使用react-query和intersection API来实现。否则，我们将不得不在每次用户滚动网页时跟踪load more按钮的位置，然后增加页码并再次调用API来获取接下来的10个项目。<br/>变得有点混乱，性能也会受到阻碍，但通过使用反应查询和交集API，我们避免了不必要的重新渲染，提高了应用程序的性能。</p><p id="e8e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">继续发展<br/>Shrey<br/></strong><a class="ae kv" href="https://ihatereading.in/" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">IHA tereading</strong></a></p><p id="e5e3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nu">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nu">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nu">免费周报</em> </strong> </a> <em class="nu">。关注我们关于</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nu">推特</em> </strong> </a>，<a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="nu">LinkedIn</em></strong></a><em class="nu">，</em><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="nu">YouTube</em></strong></a><em class="nu">，以及</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nu">不和</em> </strong> </a> <em class="nu">。对增长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nu">电路</em> </strong> </a> <em class="nu">。</em></strong></a></p></div></div>    
</body>
</html>