<html>
<head>
<title>JavaScript: Polyfills for Promise</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript: Polyfills for Promise</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-polyfills-for-promise-877e5f1e6c0a?source=collection_archive---------0-----------------------#2022-01-07">https://javascript.plainenglish.io/javascript-polyfills-for-promise-877e5f1e6c0a?source=collection_archive---------0-----------------------#2022-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e62" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习所有你需要知道的关于承诺的知识，以应对下一次JavaScript面试。</h2></div><p id="5121" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Promise </strong>是我们在任何生产级应用中日常使用的一个概念。而且大部分浏览器都支持使用承诺。然而，在面试中，候选人经常被如何重写承诺功能的问题所困扰。</p><p id="5700" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，让我们来学习你需要知道的关于承诺的所有知识，以应对你的下一次JavaScript面试。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/1cfbbf8b6dfefa03f662cdeee0145dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2IdmDZkc-S3SoM71J-v2w.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">We all make Promises. From Pixabay.</figcaption></figure><h1 id="f8d7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">承诺，什么是真正的交易？</h1><p id="05ad" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">承诺只不过是一个代理，它代表一个将在接下来的几分钟或几小时内变得可用的值(如果你的后端API特别慢的话😜).</p><p id="90e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺一般用来把自己从<strong class="kh ir">回调地狱</strong>中解救出来👹".如果你正在与<strong class="kh ir">异步代码</strong>斗争，那么<strong class="kh ir">承诺</strong>是处理这个问题的最好方法之一。</p><p id="eb7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过从<strong class="kh ir">异步</strong>代码同步返回一个对象<strong class="kh ir">，Promise解决了上述问题。在承诺返回一个对象之前，它将处于三种状态。</strong></p><ol class=""><li id="4f94" class="mo mp iq kh b ki kj kl km ko mq ks mr kw ms la mt mu mv mw bi translated"><strong class="kh ir">履行</strong>，如果承诺得到解决。</li><li id="abce" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated"><strong class="kh ir">拒绝</strong>，如果承诺被拒绝。</li><li id="569a" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated"><strong class="kh ir"> Pending </strong>，该状态直到它达到履行或拒绝。</li></ol><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nc"><img src="../Images/e54c61fe892c6237d13d39e0661e470b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HkVc-_Zqq4K6O13h.png"/></div></div></figure><p id="f9f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当承诺处于待定状态时，您将处于黑盒中。在创建承诺的功能获得“已解决/已拒绝”状态之前，您不会知道结果。从程序上讲，您的承诺可以是以下内容之一:</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="37b1" class="ni ls iq ne b gy nj nk l nl nm">const p1 = new Promise((resolve, reject) =&gt; {  resolve("Success");});</span><span id="3266" class="ni ls iq ne b gy nn nk l nl nm"><strong class="ne ir">or</strong></span><span id="83b3" class="ni ls iq ne b gy nn nk l nl nm">const p1 = new Promise((resolve, reject) =&gt; {  reject("Error");});</span></pre><p id="28b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行过程中，必须有一个<strong class="kh ir">enable</strong>组件，它有助于处理承诺一旦实现后的响应。并且，需要有一个<strong class="kh ir">捕捉</strong>块来处理拒绝。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="6000" class="ni ls iq ne b gy nj nk l nl nm">p1.then((response)=&gt;console.log(response)).catch((err)=&gt;{console.log(err)});</span></pre><p id="14aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，这就是承诺的核心有多简单。</p><p id="b04c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在现实世界的场景中，你不会只做一个承诺。相反，在达到最终状态之前，你将不得不面对十几个承诺。这就是像<strong class="kh ir"> Promise.all </strong>和<strong class="kh ir"> Promise.allSettled </strong>这样的概念变得有用的时候。</p><p id="7fa6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们理解这些概念中的每一个，并编写我们自己的聚合填充，以<strong class="kh ir">确认</strong>😇我们对这些理论的理解程度。</p><h1 id="6812" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">承诺。所有</h1><p id="3f37" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">Promise.all将<strong class="kh ir">返回单个承诺</strong>当<strong class="kh ir">所有承诺都成功履行，</strong>或<strong class="kh ir">其中一个承诺被拒绝。</strong></p><p id="8a77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据上述定义，我们对某些要素相当确定:</p><p id="8418" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">无极</strong>是一个函数</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="3d75" class="ni ls iq ne b gy nj nk l nl nm">Promises.all = function(){}</span></pre><p id="cdaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">必须将一组承诺传递给<strong class="kh ir"> Promise.all </strong></p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="ccf4" class="ni ls iq ne b gy nj nk l nl nm">Promises.all = function(arrayOfPromises){}</span></pre><p id="0d51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数必须返回一个<strong class="kh ir">单个承诺</strong></p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="34eb" class="ni ls iq ne b gy nj nk l nl nm">Promises.all = function(arrayOfPromises){</span><span id="56de" class="ni ls iq ne b gy nn nk l nl nm">return new Promise((resolve, reject) =&gt; {})</span><span id="ed67" class="ni ls iq ne b gy nn nk l nl nm">}</span></pre><p id="390f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你知道了<strong class="kh ir"> promise.all. </strong>的骨架，接下来，你需要执行每一个承诺，并且要么解决要么拒绝输出。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="e38a" class="ni ls iq ne b gy nj nk l nl nm">Promise.<strong class="ne ir">letsBuildAnAll</strong> = function (promises) {<br/>  var count = promises.length<br/>  var result = new Array(count).fill(false)<br/>  return new Promise((resolve, reject) =&gt; {<br/>     var checkIfDone = () =&gt; {<br/>      if (--count === 0) resolve(result)<br/>     }<br/>    promises.forEach((promise, index) =&gt; {<br/>     promise.then( (x) =&gt; {<br/>       result[index] = x<br/>      }, reject).then(checkIfDone)<br/>    })<br/> })<br/>}</span><span id="7614" class="ni ls iq ne b gy nn nk l nl nm">For Example:<br/>var a = new Promise((resolve) =&gt; setTimeout(()=&gt;{resolve(3)},200));<br/>var b= new Promise((resolve,reject)=&gt;reject(9));<br/>var c= new Promise((resolve) =&gt; resolve(5));<br/>var d= Promise.<strong class="ne ir">letsBuildAnAll</strong>([a,b,c]);<br/>c.then(res=&gt;console.log(res))</span><span id="0b13" class="ni ls iq ne b gy nn nk l nl nm">The output is:<strong class="ne ir"> Promise&lt;rejected&gt;:9</strong></span></pre><h1 id="8fb0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">承诺。都解决了</h1><p id="888f" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated"><strong class="kh ir"> Promise.allSettled </strong>会在<strong class="kh ir">所有承诺成功执行后<strong class="kh ir">返回单个承诺</strong>。这不取决于承诺是被解决还是被拒绝。</strong></p><p id="dda5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们再一次解码这个定义。</p><ol class=""><li id="a42c" class="mo mp iq kh b ki kj kl km ko mq ks mr kw ms la mt mu mv mw bi translated"><strong class="kh ir"> Promise.allSettled </strong>是一个函数。</li><li id="ea8b" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">一组承诺作为参数传递给函数。</li><li id="bb6b" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">该函数返回一个承诺。</li><li id="2722" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">每一个承诺，作为一个论点，被执行。执行的结果存储在一个数组中。这个数组最终被解析并作为一个成功的承诺返回。</li><li id="69e7" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">对于每一个承诺，执行状态将被保存，如已完成或已拒绝。</li></ol><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="8a54" class="ni ls iq ne b gy nj nk l nl nm">Promise.<strong class="ne ir">letsBuildAnAllSettled</strong> = function (<!-- -->arrayOfPromises<!-- --> = []) {<br/>  return new <strong class="ne ir">Promise</strong>(function promiseIterator(resolve, reject) {<br/>    let result = [];<br/>    <!-- -->arrayOfPromises<!-- -->.forEach((item) =&gt; {<br/>      item<br/>        .then((value) =&gt; {<br/>          result.push({ status: "fulfilled", value: value });<br/>          if (<!-- -->arrayOfPromises<!-- -->.length === result.length) resolve(result);<br/>        })<br/>        .catch((err) =&gt; {<br/>          result.push({ status: "rejected", reason: `${err}` });<br/>          if (<!-- -->arrayOfPromises<!-- -->.length === result.length) resolve(result);<br/>        });<br/>    });<br/>  });<br/>};</span><span id="c21b" class="ni ls iq ne b gy nn nk l nl nm">For Example:<br/>var a = new Promise((resolve) =&gt; setTimeout(()=&gt;{resolve(3)},200));<br/>var b = new Promise((resolve,reject)=&gt;reject(9));<br/>var c= new Promise((resolve) =&gt; resolve(5));<br/><br/>var d= Promise.<strong class="ne ir">letsBuildAnAllSettled</strong>([a,b,c]);<br/>d.then(result=&gt;console.log(result))</span><span id="7e81" class="ni ls iq ne b gy nn nk l nl nm">The output is:<strong class="ne ir"> 5</strong></span></pre><h1 id="322c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">承诺。任何</h1><p id="27d1" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated"><strong class="kh ir">承诺. any </strong>等待<strong class="kh ir">任何一个承诺成功解析</strong>。<strong class="kh ir">如果所有的承诺都被拒绝，它会拒绝承诺，或者成功发送一个错误。</strong></p><p id="3b87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何承诺的定义都很简单。</p><ol class=""><li id="faab" class="mo mp iq kh b ki kj kl km ko mq ks mr kw ms la mt mu mv mw bi translated">any是一个函数，它接受一组承诺</li><li id="5f81" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">该函数返回一个承诺。</li><li id="c38f" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">当其中一个承诺被解决时，执行停止并返回一个结果承诺。</li><li id="f293" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">当所有承诺都被拒绝时，将返回一个包含所有错误的数组。</li></ol><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="843c" class="ni ls iq ne b gy nj nk l nl nm">Promise.<strong class="ne ir">letsBuildAnAny</strong> = function(arrayOfPromises){<br/>let errors = [];<br/><strong class="ne ir">return new Promise</strong>((<strong class="ne ir">resolve, reject</strong>) =&gt; {<br/>arrayOfPromises.forEach((promise, index)=&gt;{<br/><strong class="ne ir">Promise.resolve</strong>(promise)<br/>.then(<strong class="ne ir">resolve</strong>)<br/>.catch((error)=&gt;{<br/>errors.push(error);<br/>if(errors.length == arrayOfPromises.length)<br/><strong class="ne ir">reject</strong>(errors);<br/>})<br/>})<br/>})<br/>}</span><span id="7fe3" class="ni ls iq ne b gy nn nk l nl nm">For Example:<br/>var a = new Promise((resolve) =&gt; setTimeout(()=&gt;{resolve(3)},200));<br/>var b = new Promise((resolve,reject)=&gt;reject(9));<br/>var c= new Promise((resolve) =&gt; resolve(5));<br/><br/>var d= Promise.<strong class="ne ir">letsBuildAnAny</strong>([a,b,c]);<br/>d.then(result=&gt;console.log(result))</span><span id="4ca7" class="ni ls iq ne b gy nn nk l nl nm">The output is:<strong class="ne ir"> 5</strong></span></pre><h1 id="916a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">承诺.比赛</h1><p id="48c7" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">Promise.race与Promise.any有很大不同<strong class="kh ir"> Promise.race是关于理解哪个承诺先完成的。在这里，我们寻找成功或被拒绝的承诺。这意味着，第一个被拒绝或成功完成的<strong class="kh ir">承诺将作为结果</strong>返回。这意味着:</strong></p><ol class=""><li id="416e" class="mo mp iq kh b ki kj kl km ko mq ks mr kw ms la mt mu mv mw bi translated">竞赛是一个函数，它接受一系列的承诺。</li><li id="25a4" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">该函数返回一个承诺。</li><li id="c5e3" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">当其中一个函数成功解析或被拒绝时，该函数终止。</li></ol><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="b264" class="ni ls iq ne b gy nj nk l nl nm">Promise.<strong class="ne ir">letsBuildARace</strong> = function(arrayOfPromises){<br/>return new Promise((resolve, reject) =&gt; {<br/>arrayOfPromises.forEach((promise) =&gt; {<br/>Promise.resolve(promise).then(resolve, reject);<br/>})<br/>})<br/>}</span><span id="caca" class="ni ls iq ne b gy nn nk l nl nm">For Example:<br/>var a = new Promise((resolve) =&gt; setTimeout(()=&gt;{resolve(3)},200));<br/>var b = new Promise((resolve,reject)=&gt;reject(9));<br/>var c= new Promise((resolve) =&gt; resolve(5));<br/><br/>var d= Promise.<strong class="ne ir">letsBuildARace</strong>([a,b,c]);<br/>d.then(result=&gt;console.log(result))</span><span id="8501" class="ni ls iq ne b gy nn nk l nl nm">The output is:<strong class="ne ir"> Promise&lt;rejected&gt;:9</strong></span></pre><blockquote class="no np nq"><p id="2c46" class="kf kg nr kh b ki kj jr kk kl km ju kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">记住，<strong class="kh ir">无极.竞</strong>不同于<strong class="kh ir">无极</strong>。Promise.all按顺序执行每个承诺，并等待其中一个承诺被拒绝，或者所有承诺都被解决。另一方面，一旦其中一个承诺被拒绝或解决，Promise.race就会终止。</p></blockquote><h1 id="3e1d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="8663" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们都做出承诺，这些是简单的填充，帮助你理解在Javascript中使用承诺可以实现什么。当你开始使用承诺的时候，你会使用其中之一:<strong class="kh ir"> all，race，any或allsettled。每一种都不同，可以用来满足您的业务需求。</strong></p><blockquote class="no np nq"><p id="0037" class="kf kg nr kh b ki kj jr kk kl km ju kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">如果你喜欢我的话，请跟随并继续学习。</p></blockquote><p id="f63d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nr">更多内容看</em> <a class="ae nv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nr">说白了. io </em> </a> <em class="nr">。报名参加我们的</em> <a class="ae nv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nr">免费每周简讯</em> </a> <em class="nr">。在我们的</em> <a class="ae nv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nr">社区</em> </a> <em class="nr">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>