<html>
<head>
<title>State of the Web: Bundlers &amp; Build Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络现状:捆绑器和构建工具</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/state-of-the-web-bundlers-build-tools-f67cf57759a4?source=collection_archive---------5-----------------------#2022-01-23">https://javascript.plainenglish.io/state-of-the-web-bundlers-build-tools-f67cf57759a4?source=collection_archive---------5-----------------------#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9198" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解有关Webpack、Rollup和Vite等捆扎机的过去、现在和未来的更多信息</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/73563bc2db6998fd8abab1dc706d2bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BIOiXeFiMVgBFk1x"/></div></div></figure><p id="01b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自从Browserify以来，bundlers在网络生态系统中一直非常重要。它们提供了自动处理代码的能力，这为性能优化和非本地语言提供了机会。本文着眼于捆绑器的背景，为什么他们是必不可少的，以及他们的现状。</p><h1 id="d37b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">捆扎机背景</h1><h1 id="8bdd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">捆扎机之前的网络</h1><p id="6a78" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">对于网络的很大一部分来说，捆绑器并不存在。为了包含脚本，大多数人只是链接到CDN上的库，如<a class="ae mk" href="https://cdnjs.com/" rel="noopener ugc nofollow" target="_blank"> CDNJS </a>或<a class="ae mk" href="https://developers.google.com/speed/libraries" rel="noopener ugc nofollow" target="_blank">谷歌托管库</a>。这种情况将在2009年Node.js发布时开始改变。Node.js没有使用cdn，而是附带了它的包管理器npm。npm很容易使用，因为每个库都在一个<code class="fe ml mm mn mo b">npm install</code>之外，并且更新很容易。因为易于使用，许多人想在web上使用npm。然而，这是不可能的，直到<a class="ae mk" href="https://browserify.org/" rel="noopener ugc nofollow" target="_blank"> Browserify </a>出现。</p><h1 id="5c34" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">浏览</h1><p id="c0b7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Browserify的标语描述得很好。</p><blockquote class="mp mq mr"><p id="ebed" class="kr ks ms kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated"><em class="iq"> Browserify通过捆绑所有的依赖项，让您在浏览器中使用</em> <code class="fe ml mm mn mo b"><em class="iq">require('modules')</em></code> <em class="iq">。</em></p></blockquote><p id="ad26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Browserify是第一个JavaScript“bundler”如果您不知道bundler是什么，它是一个将多个脚本捆绑到一个脚本中的工具，并且经常对它捆绑的脚本执行转换。这意味着您可以通过解析代码中的<code class="fe ml mm mn mo b">require()</code>语句，将来自NPM的不同脚本与您的代码捆绑在一起。捆绑还意味着您的站点通常会更快，因为发送出去的HTTP请求不多，这减少了开销(在现代浏览器中这种情况较少，因为HTTP/2增加了在单个连接上下载多个资源的能力)。由于这些优势，Browserify很快被采用。同样重要的是要注意在网络上使用模块的其他方式，如Require.js，它使用AMD而不是CommonJS，以及Bower，它完全取代了浏览器的NPM。</p><h1 id="f9db" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">咕噜&amp;吞咽</h1><p id="5b13" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">虽然Browserify非常擅长将脚本捆绑在一起，但它在转换代码方面却不太擅长。假设您希望将咖啡脚本代码编译为JavaScript。您可以使用普通的Browserify来实现这一点。然而，它是笨重和相对不灵活的。为了解决这个问题，一组新的web工具诞生了，它专注于运行代码转换。这些人通常被称为任务跑步者，最受欢迎的是<a class="ae mk" href="https://gruntjs.com/" rel="noopener ugc nofollow" target="_blank"> Grunt </a>和<a class="ae mk" href="https://gulpjs.com/" rel="noopener ugc nofollow" target="_blank">glunt</a>。Grunt是第一个任务管理器，2012年1月首次发布。在使用Browserify之类捆绑器或没有捆绑器的情况下，它允许更灵活的代码转换。不过，Grunt仍然存在一些问题，这些问题都由glugh解决了。growth更快，因为它使用Node流而不是临时文件，并并行运行任务，还允许人们使用脚本而不是JSON配置文件。然而，这仍然不是完美的，因为使用两个独立的工具是令人讨厌的。这是由Webpack修复的</p><h1 id="6e7d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Webpack</h1><p id="2693" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated"><a class="ae mk" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>将捆绑和编译结合在一起，比之前的标准grave+Browserify更容易实现。Webpack最早开始流行是在2016年，至今仍然流行。Webpack还有其他一些优势。首先，它支持绑定和转换非JavaScript资产，如HTML、CSS和图像。其次，API通常更易于使用(尽管相对于最新的bundlers，它仍然比较复杂)。许多工具，比如Create-reaction-App、Next.js和Vuepress，都使用了Webpack。</p><h1 id="3d44" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">为什么打包工具/构建工具很重要</h1><blockquote class="mp mq mr"><p id="a31a" class="kr ks ms kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated"><em class="iq">如果已经知道使用打捆机的原因，可以跳过本节</em></p></blockquote><h1 id="adb4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">最佳化</h1><p id="fa93" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一般来说，大多数人不会像这样编写他们的代码:</p><p id="dd57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相反，为了使东西可读，他们可能会写下如下内容:</p><p id="1dda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，第一个示例较小，因此传输速度较快。现在，您可能认为必须牺牲大小来提高可读性，但有一个解决方案，即缩小。Minifiers会自动将源代码转换为更小的形式。实际上，第一个代码示例是由<a class="ae mk" href="https://terser.org/" rel="noopener ugc nofollow" target="_blank"> Terser </a>生成的，它是最好的缩小程序之一。打包程序通过插件使使用小型过滤器变得很容易。此外，bundlers还有助于执行其他优化，例如树摇动，它可以删除未使用的代码。最后，绑定脚本本身可以通过减少所需的HTTP请求来提高性能。</p><h1 id="3405" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">非网络原生语言</h1><p id="bc85" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">通常，使用像<a class="ae mk" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank"> Sass </a>或<a class="ae mk" href="https://stylus-lang.com/" rel="noopener ugc nofollow" target="_blank"> Stylus </a>这样的语言比普通的CSS更有效。或者，也许你正试图使用<a class="ae mk" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>在你的代码中强制静态类型。不管是哪种情况，使用web本身不支持的语言通常更好。捆扎机可以在这方面提供帮助。不用自己运行一堆不同的命令来编译所有的东西，你通常只需要在你的bundler配置文件中添加插件并运行bundler。</p><h1 id="77dd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">发展特征</h1><p id="c273" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">大多数现代捆绑机都有加快迭代速度的功能，比如热模块重装(HMR)。HMR自动重新加载特定的模块，而不是整个页面发生了变化，使重新加载速度更快。此外，如果您使用React这样的框架，React状态可以保留，这意味着页面数据不会每次都重置。</p><h1 id="ef84" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">轻松包含模块</h1><p id="357f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">将模块捆绑在一起是制造捆扎机的最初原因。即使现在有许多其他功能，这仍然很重要。即使有ESM的原生支持，不需要编写完整的导入路径就能够对<code class="fe ml mm mn mo b">import</code>或<code class="fe ml mm mn mo b">require</code>模块进行操作仍然是有帮助的(尽管<a class="ae mk" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank">导入映射</a>可以在这方面提供帮助)。</p><h1 id="8f09" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">构建工具的状态</h1><h1 id="dd1b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">采用</h1><p id="30ef" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如今，几乎每个web开发人员都使用这样或那样的bundler。Webpack是目前最受欢迎的，Rollup和Vite分别位居第二和第三。目前，Vite是发展最快的主要捆绑包，已经被Vitepress、SvelteKit、Astro等框架所采用。</p><h1 id="9071" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">ECMAScript模块(ESM)</h1><p id="72cc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">大多数现代捆绑机都支持ESM。虽然Browserify等工具不支持ESM，但大多数新工具或比Webpack更新的工具都支持ESM。此外，ESM通常是受支持的捆绑商的推荐做法，因为它比CommonJS或AMD更面向未来，并且更容易静态分析树抖动的导入。ESM还为非捆绑开发提供了机会，我们将在下面进行介绍。</p><h1 id="fc0c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">非捆绑发展</h1><p id="a5e9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">非捆绑开发利用浏览器中的原生ESM支持来提供超快的开发体验。与捆绑开发中所有内容的传统捆绑器不同，非捆绑开发会转换代码，并将导入路径重写为符合ESM的文件路径，而不会捆绑您的代码。此外，大多数这样做的捆绑器会预先捆绑依赖项，因为这减少了所需的导入次数，并且依赖项不太可能经常改变。利用非捆绑开发的两个最著名的捆绑软件是<a class="ae mk" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank"> Vite </a>和<a class="ae mk" href="https://www.snowpack.dev/" rel="noopener ugc nofollow" target="_blank"> Snowpack </a>。Snowpack创建于2019年，是第一个拥有非捆绑开发经验的捆绑商。然而，虽然Snowpack流行了一段时间，但这并没有永远持续下去。2020年，Vue背后的团队创造了Vite。与Snowpack相比，Vite有很多优势，比如易用性、速度、更好的优化等等。此外，像SvelteKit这样的流行项目采用了Vite而不是Snowpack。所有这些都帮助Vite在下载量上超过了Snowpack，与Snowpack相比，它现在的<a class="ae mk" href="https://www.npmtrends.com/snowpack-vs-vite" rel="noopener ugc nofollow" target="_blank">下载量超过了10倍</a>。事实上，就连Snowpack背后的团队创建的项目<a class="ae mk" href="https://astro.build/" rel="noopener ugc nofollow" target="_blank"> Astro </a>(请留意一篇关于Astro的文章)现在也在使用Vite。总的来说，如果你想要快速、无捆绑的开发，我推荐Vite。</p><h1 id="a6e7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">更快的语言</h1><p id="ad79" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">许多人试图加速捆绑和代码转换的另一种方式是通过使用更优化的语言，如Go或Rust。目前，两个最著名的工具是<a class="ae mk" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> esbuild </a>和<a class="ae mk" href="https://swc.rs/" rel="noopener ugc nofollow" target="_blank"> SWC </a>。esbuild是Evan Wallace在2016年使用Go创建的。esbuild扮演了Babel的角色，将现代JavaScript、TypeScript编译器、Terser和基本捆绑包都整合到一个包中，这在当时比其他任何工具都要快得多。SWC是2017年由kdy1使用Rust创建的。SWC甚至比esbuild更快，尽管只是略微快一些。esbuild目前比SWC更受欢迎，被Vite等项目使用，尽管Deno和Next.js已经采用了SWC。</p><h1 id="6153" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">低至零配置</h1><p id="7de5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Webpack有一个非常复杂的插件系统。虽然它非常强大，但对于初学者来说可能会很可怕。幸运的是，有新的捆扎机专注于此。<a class="ae mk" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank"> Parcel </a>由Devon Govett于2017年创建，旨在实现简单的零配置捆绑。Parcel支持Webpack插件提供的许多功能，如Sass、TypeScript和JSX，而不需要您做任何事情。此外，由于缓存和Rust使用的增加，Parcel v2可能比Webpack更快。Vite是另一个低配置捆绑器，尽管它在开箱即用时做的不多。</p><h1 id="c87e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Webpack呢？</h1><p id="69f2" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Webpack仍然是最受欢迎的捆绑软件。虽然它没有利用上面指定的大规模速度改进的能力，但它仍然在最新版本Webpack 5中添加了新功能。Webpack 5中增加的最大的东西是<a class="ae mk" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank">模块联盟</a>，或微前端。模块联合分离了一个网站的不同元素，使得像组件库一样共享代码片段变得更加容易。版本5中Webpack增加的另一件大事是更好的缓存，这可以改善开发中的重新加载时间。总体而言，Webpack仍在进步，尽管它在某些功能上落后于一些捆绑商。</p><h1 id="f95c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="5013" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">网络捆绑商的世界正在快速发展。希望这篇文章能让你对捆扎机的现状有一个大致的了解。如果您喜欢这篇文章，请注册下面的ByteofDev邮件列表(或者不注册，但我希望您注册🙃)，也感谢你的阅读。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="86ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ms">原载于2022年1月23日https://byteofdev.com</em><a class="ae mk" href="https://byteofdev.com/posts/bundlers/" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">。</em></p><p id="8e12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ms">更多内容看</em> <a class="ae mk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ms">说白了。报名参加我们的</em> <a class="ae mk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ms">免费周报</em> </strong> </a> <em class="ms">。在我们的</em> <a class="ae mk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ms">社区不和谐</em> </strong> </a> <em class="ms">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>