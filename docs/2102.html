<html>
<head>
<title>How to Add Relics in a JavaScript Roguelike</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript Roguelike中添加遗迹</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-collectible-items-in-a-javascript-roguelike-93d934b499b8?source=collection_archive---------9-----------------------#2022-05-13">https://javascript.plainenglish.io/how-to-add-collectible-items-in-a-javascript-roguelike-93d934b499b8?source=collection_archive---------9-----------------------#2022-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/73737e7bfda2fd89b972ddba634e87b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1prDQ5aLgcbeAQWdxm-Tew.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@farreal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Dan Farrell</a> on <a class="ae kc" href="https://unsplash.com/s/photos/crystals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="060d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在冒险游戏中，知道新的物品可能在某个地方会鼓励你去探索不寻常的地方。因为roguelike使用程序生成的关卡，所以由关卡生成算法在激发探索的地方放置物品。在本教程中，我们将从一个工作的地牢爬虫开始，并编写逻辑将可收集的遗物放在每个房间序列的末尾。下面是这种级别的一个例子，其中有三个紫色的遗迹。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/8237e92815c564bef59d879d71f79a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZfFC8Z79kr_-z1SkK8Cnw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">See if you can find the four purple relics!</figcaption></figure><p id="e35f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">游戏是这样运作的:你用光标键控制玩家，当你碰到敌人时就和他们战斗。你可以拿起绿色的生命药剂来恢复生命，如果你移动到橙色的武器上，它就会变成你所使用的武器。当你收集一件遗物时，玩家的经验值会随机增加。而在这个游戏的最终版本中，需要收集所有的遗物才能完成关卡。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="33a5" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">入门指南</h1><p id="c238" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">要获取启动代码，请从<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-relics" rel="noopener ugc nofollow" target="_blank"> Github </a>下载<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-relics/archive/refs/heads/main.zip" rel="noopener ugc nofollow" target="_blank"> zip文件</a>。解压后，您会看到一个<code class="fe mq mr ms mt b">project</code>目录，以及两个解决方案目录，您可以在工作过程中查看。<code class="fe mq mr ms mt b">css</code>和<code class="fe mq mr ms mt b">js</code>目录各有一个文件供所有三个游戏版本使用。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="eef7" class="my lo iq mt b gy mz na l nb nc">js-roguelike-relics<br/>  |<br/>  *--project<br/>  |<br/>  *--phase-1-solution<br/>  |<br/>  *--phase-2-solution<br/>  |<br/>  *--js<br/>  |<br/>  *--css</span></pre><p id="1e49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mt b">project</code>目录中有一个显示游戏的<code class="fe mq mr ms mt b">index.html</code>文件。还有一个包含四个JavaScript文件的<code class="fe mq mr ms mt b">js</code>目录，我们将在这里进行编码。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="120d" class="my lo iq mt b gy mz na l nb nc">project<br/>  |<br/>  *--index.html<br/>  |<br/>  *--js<br/>      |<br/>      *--game.js<br/>      |<br/>      *--room.js<br/>      |<br/>      *--script.js<br/>      |<br/>      *--sequence.js</span></pre><h2 id="2cbd" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">游戏地图</h2><p id="d946" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">和很多roguelikes一样，这是一款基于磁贴的游戏。每种类型的牌都有自己的数字代码，见<code class="fe mq mr ms mt b">script.js</code>。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/fab63d3d53d75c9221f0cfe5edab2b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*tw8JvO-MJsWr9RDEwBK3uQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The tile codes used in the game.</figcaption></figure><p id="dfd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mt b">game.js</code>文件存储了<code class="fe mq mr ms mt b">Game</code>类及其方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The game class</figcaption></figure><p id="16d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦地图生成，它就被绘制在一个<code class="fe mq mr ms mt b">&lt;canvas&gt;</code>元素上。<code class="fe mq mr ms mt b">Game</code>对象存储了对一个<code class="fe mq mr ms mt b">&lt;canvas&gt;</code>元素的引用及其被称为<code class="fe mq mr ms mt b">context</code>的绘图方法包。</p><h2 id="750a" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">地图</h2><p id="136c" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">游戏的<code class="fe mq mr ms mt b">map</code>属性将地牢地图存储在一个2D数组中。如果一个3x3的房间被添加到一个5x5地图的中心，那么<code class="fe mq mr ms mt b">map</code>阵列将类似于下图。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0901f29eb1417573050caca31df5d733.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*xaYQ9UGIa2UDU88jgzM-Pg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A small 2D map array with a 3x3 room.</figcaption></figure><p id="a414" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个遗迹被添加到房间的中央，一个代码<code class="fe mq mr ms mt b">6</code>、<code class="fe mq mr ms mt b">RELIC_CODE</code>将被交换到第三行的第三个位置。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/77bef52129a5a68452f36300a1bca904.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*X8n7-o4XYBkKDwl_bGpwsg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The map with a relic placed in the center.</figcaption></figure><p id="a6de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，这个游戏有一个<code class="fe mq mr ms mt b">enemies</code>数组，用来记录还有多少敌人。在最初的游戏中，如果数组是空的，玩家就赢了这一关。</p><h2 id="346b" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">房间</h2><p id="7aa6" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">游戏地图是使用每个房间的一个对象创建的。每个房间对象都是由位于<code class="fe mq mr ms mt b">room.js</code>的<code class="fe mq mr ms mt b">Room</code>类构建的。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The Room class.</figcaption></figure><p id="d781" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最重要的房间属性是<code class="fe mq mr ms mt b">start</code>、<code class="fe mq mr ms mt b">center</code>和<code class="fe mq mr ms mt b">end</code>对象。每一个都存储<code class="fe mq mr ms mt b">x</code>和<code class="fe mq mr ms mt b">y</code>值。<code class="fe mq mr ms mt b">start</code>对应于左上角，而<code class="fe mq mr ms mt b">end</code>坐标对应于右下角。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ae612823b11bfd6d8899d56b7635baba.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*VhEUr4m2Ps_f_CDAvs-vLA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A room’s start, center, and end properties</figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="3f87" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">任务1:添加房间和游戏方法</h1><p id="1bf0" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">让我们从添加一些新方法到<code class="fe mq mr ms mt b">Room</code>和<code class="fe mq mr ms mt b">Game</code>类来放置遗迹开始。</p><h2 id="234a" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">A.寻找免费的磁贴</h2><p id="3845" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">要放置遗迹，我们需要找到房间里没有被玩家、敌人或其他物品占据的地砖。</p><p id="dcc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mt b">room.js</code>中有一个名为<code class="fe mq mr ms mt b">selectFreeCoords</code>的空方法。在该方法中，让我们初始化一个名为<code class="fe mq mr ms mt b">validCoordSets</code>的数组，它将存储每个地砖的坐标。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="db3b" class="my lo iq mt b gy mz na l nb nc">Room.prototype.selectFreeCoords = function() { <br/>                                                                <br/>    let validCoordSets = [];<br/>}</span></pre><p id="2043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们添加一个助手函数来测试一个坐标是否有效。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="ee9d" class="my lo iq mt b gy mz na l nb nc">const valid = (x,y) =&gt; game.map[y][x] == FLOOR_CODE;</span></pre><p id="1fee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们添加一个循环，该循环遍历地图的每个瓷砖，如果是地砖，则将它的坐标推入数组。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="9b97" class="my lo iq mt b gy mz na l nb nc">for (let y = this.start.y; y &lt; this.end.y; ++y) {                                                                <br/>  for (let x = this.start.x; x &lt; this.end.x; ++x) {                                                                    <br/>    if (valid(x,y)) {                                         <br/>      validCoordSets.push({x,y})                                       <br/>    }                 <br/>  }        <br/>}</span></pre><p id="53f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们从数组中随机选择一个索引。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="d953" class="my lo iq mt b gy mz na l nb nc">let idx = Math.floor(Math.random()*validCoordSets.length);</span></pre><p id="6dd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们返回在该索引处选择的坐标，并使用三元运算符来处理空数组的情况。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8dec" class="my lo iq mt b gy mz na l nb nc">return validCoordSets.length &gt; 0 ? validCoordSets[idx] : null;</span></pre><p id="28c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是在<code class="fe mq mr ms mt b">room.js</code>中寻找空闲图块的完整方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The selectFreeCoords method.</figcaption></figure><h2 id="02ef" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">B.计算房间中某一类型的瓷砖</h2><p id="a6a2" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在决定在一个房间里放置一个遗迹之前，我们也想让游戏检查一个遗迹是否存在。为了处理这个问题，让我们编写一个<code class="fe mq mr ms mt b">tileCount</code>方法来计算一个房间中的遗物数量。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5f6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的方法计算房间中与传入的<code class="fe mq mr ms mt b">tileCode</code>相匹配的瓷砖数量。我们调用的时候会传入<code class="fe mq mr ms mt b">RELIC_CODE</code>，也就是<code class="fe mq mr ms mt b">6</code>。</p><h2 id="b3fd" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">C.检查剩余的遗迹</h2><p id="c59b" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">因为完成这一关需要收集所有的遗物，所以让我们去<code class="fe mq mr ms mt b">game.js</code>写一个<code class="fe mq mr ms mt b">itemsLeft</code>方法来返回还剩多少遗物。为此，我们将遍历所有房间，让每个房间调用它的新<code class="fe mq mr ms mt b">tileCount</code>方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Counting the number of items left.</figcaption></figure><p id="922e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在本文的后面看到这些方法发挥作用。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="1fc3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">任务2:检查序列构建功能</h1><p id="f720" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在<code class="fe mq mr ms mt b">script.js</code>文件中，有一个<code class="fe mq mr ms mt b">startGame</code>函数，当一个新的关卡开始时，它就会启动。我隐藏了大部分逻辑，以突出被称为<code class="fe mq mr ms mt b">sequentialRooms</code>的神秘功能。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/8db33285fd30b516a043e5dd3c4aca28.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*faWj3_H6mG-jsqTAdBeRqw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The startGame function</figcaption></figure><p id="b8e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们打开<code class="fe mq mr ms mt b">sequence.js</code>，仔细看看生成游戏地图的<code class="fe mq mr ms mt b">sequentialRooms</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先调用<code class="fe mq mr ms mt b">resetMap</code>方法，用墙砖填充关卡贴图。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="a844" class="my lo iq mt b gy mz na l nb nc">game.resetMap();</span></pre><p id="123b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用<code class="fe mq mr ms mt b">addCenterRoom</code>在中间加一个房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="d150" class="my lo iq mt b gy mz na l nb nc">let baseRoom = addCenterRoom();</span></pre><p id="837b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，在一个<code class="fe mq mr ms mt b">while</code>循环中，从<code class="fe mq mr ms mt b">Game</code>对象的<code class="fe mq mr ms mt b">rooms</code>数组中选择一个随机房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="fd86" class="my lo iq mt b gy mz na l nb nc">let idx = Math.floor(Math.random()*game.rooms.length);                                  baseRoom = game.rooms[idx];</span></pre><p id="bd0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，调用<code class="fe mq mr ms mt b">buildSequence</code>函数，该函数使用<code class="fe mq mr ms mt b">baseRoom</code>开始一个新的房间序列。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="69ca" class="my lo iq mt b gy mz na l nb nc">buildSequence(baseRoom);</span></pre><p id="bb83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">循环继续，直到我们达到最小房间数或最大尝试数。</p><h2 id="3b11" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">添加中心房间</h2><p id="f70d" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">让我们检查一下<code class="fe mq mr ms mt b">sequentialRooms</code>调用的<code class="fe mq mr ms mt b">addCenterRoom</code>方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e84a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是发生的事情的快速分解。</p><ul class=""><li id="4743" class="nv nw iq kf b kg kh kk kl ko nx ks ny kw nz la oa ob oc od bi translated">使用地图尺寸<code class="fe mq mr ms mt b">ROWS</code>和<code class="fe mq mr ms mt b">COLS</code>确定<code class="fe mq mr ms mt b">center</code>。</li><li id="e23e" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated"><code class="fe mq mr ms mt b">genDim</code>用于生成房间尺寸。</li><li id="e241" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated"><code class="fe mq mr ms mt b">generateRoom</code>创建房间对象。</li><li id="81cf" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">一个<code class="fe mq mr ms mt b">roomToMap</code>方法将房间添加到2D <code class="fe mq mr ms mt b">map</code>数组中。</li><li id="b20b" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">游戏还将房间推成了1D <code class="fe mq mr ms mt b">rooms</code>阵列。</li></ul><h2 id="6c33" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">构建房间序列</h2><p id="0cee" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在让我们看一下<code class="fe mq mr ms mt b">buildSequence</code>方法，我们的大部分工作将在这里进行。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="56ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看如何创建一个线性系列的房间。</p><ul class=""><li id="3db1" class="nv nw iq kf b kg kh kk kl ko nx ks ny kw nz la oa ob oc od bi translated"><code class="fe mq mr ms mt b">maxSeqLen</code>已声明，这是一个序列中的最大房间数。</li><li id="00a2" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">在循环中，<code class="fe mq mr ms mt b">addAdjacentRoom</code>被调用，它创建了一个与初始<code class="fe mq mr ms mt b">baseRoom</code>相邻的房间。</li><li id="9d4f" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">如果不能添加新房间，我们就退出循环并返回。</li><li id="3c83" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">否则，<code class="fe mq mr ms mt b">baseRoom</code>连接到<code class="fe mq mr ms mt b">newRoom</code>。</li><li id="5ba3" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">只要一个<code class="fe mq mr ms mt b">newRoom</code>存在，那么<em class="oj">就变成</em>的<code class="fe mq mr ms mt b">baseRoom</code>用于循环的下一个回合。</li></ul><p id="1a99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/arranging-adjacent-rooms-in-a-javascript-roguelike-a5c178772d31">构建序列</a>教程中详细介绍了<code class="fe mq mr ms mt b">addAdjacentRoom</code>功能。</p><p id="2b5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe mq mr ms mt b">buildSequence</code>被调用一次后一系列房间的样子。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c4e4a77a08c939a767618f6276e21cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*5f5d5sTKnqPIx7wlp4H-8g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">One room sequence.</figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="23fb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">任务3:给每个房间序列添加一个遗迹</h1><p id="687b" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">既然我们已经查看了关键代码，让我们添加删除遗物的逻辑，从一个叫做<code class="fe mq mr ms mt b">placeRelic</code>的助手函数开始，它可以放在<code class="fe mq mr ms mt b">buildSequence</code>中。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Logic for placing a relic.</figcaption></figure><p id="c0b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们分解<code class="fe mq mr ms mt b">placeRelic</code>,并探索它如何使用其他函数工作。</p><ul class=""><li id="86fd" class="nv nw iq kf b kg kh kk kl ko nx ks ny kw nz la oa ob oc od bi translated">我们首先调用我们的<code class="fe mq mr ms mt b">tileCount</code>方法来确保房间里没有遗物。</li><li id="fa32" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">如果没有遗迹，我们调用我们写的<code class="fe mq mr ms mt b">selectFreeCoords</code>方法在房间里找一个空闲的瓷砖。</li><li id="ba78" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">然后我们调用<code class="fe mq mr ms mt b">placeItem</code>，这是<code class="fe mq mr ms mt b">script.js</code>中的一个函数，它将文物添加到2D <code class="fe mq mr ms mt b">map</code>数组中，如果它可见，就将其呈现在画布上。</li></ul><h2 id="41a0" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">检查一个项目是如何放置的</h2><p id="feab" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">下面是完整的<code class="fe mq mr ms mt b">placeItem</code>功能。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The full placeItem function.</figcaption></figure><p id="68ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始时，它调用<code class="fe mq mr ms mt b">addObjToMap</code>，将遗迹瓦片代码添加到地图的指定坐标处。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="0549" class="my lo iq mt b gy mz na l nb nc">function addObjToMap(coords, tileCode) {<br/>   game.map[coords.y][coords.x] = tileCode;<br/>}</span></pre><p id="a38d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mq mr ms mt b">drawObject</code>方法呈现项目，该方法使用<code class="fe mq mr ms mt b">&lt;canvas&gt;</code>元素的<code class="fe mq mr ms mt b">context</code>属性绘制图块。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a95d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们回到<code class="fe mq mr ms mt b">buildSequence</code>并弄清楚如何使用<code class="fe mq mr ms mt b">placeRelic</code>。</p><p id="dd4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回想一下，如果我们没有得到一个新的房间，我们就会打破循环。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="a931" class="my lo iq mt b gy mz na l nb nc">let newRoom = addAdjacentRoom(baseRoom);    <br/>                                                                     if (!newRoom) { <br/>  break;<br/>}<br/>baseRoom.directConnect(newRoom);</span></pre><p id="d324" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们休息之前，让我们调用<code class="fe mq mr ms mt b">placeRelic</code>以便我们在这个序列的最后一个房间添加一个。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="d86f" class="my lo iq mt b gy mz na l nb nc">if (!newRoom) {<strong class="mt ir"><br/>  placeRelic(baseRoom);</strong><br/>  break;<br/>}<br/>  <br/>baseRoom.directConnect(newRoom);</span></pre><p id="1da7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再往下，让我们检查一下是否到达了序列中的最后一个房间。如果是这样的话，我们从来没有打破循环，所以让我们添加一个遗迹到这个最后的房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="ec17" class="my lo iq mt b gy mz na l nb nc">if (!newRoom) {</span><span id="9645" class="my lo iq mt b gy ol na l nb nc">  placeRelic(baseRoom);<br/>    break;<br/>}<br/>  <br/>baseRoom.directConnect(newRoom);</span><span id="bc33" class="my lo iq mt b gy ol na l nb nc"><strong class="mt ir">if (i == maxSeqLen -1) {<br/>   placeRelic(baseRoom);<br/>}</strong></span><span id="52f3" class="my lo iq mt b gy ol na l nb nc">baseRoom = newRoom;</span></pre><p id="22d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在浏览器中打开你的项目，你应该能够在不同的地方看到紫色遗迹，类似于下面显示的等级。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/6c3883740a0c493e3d53845fb0e2a84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*PXawljkjpe1qjWYe0Mc0Zg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Here relics are placed, but they are not at the end of the room sequences.</figcaption></figure><p id="8a5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，还是有一些问题。</p><ul class=""><li id="24bd" class="nv nw iq kf b kg kh kk kl ko nx ks ny kw nz la oa ob oc od bi translated">当你收集一件遗物时，什么都不会发生——它只会消失。</li><li id="cf1d" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">收集遗物不需要完成关卡。</li><li id="c560" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">遗迹不一定出现在可见房间序列的最后一个房间。</li></ul><p id="ec7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来让我们解决这些问题。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="2ebd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">任务4:处理遗物的收集</h1><p id="4592" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们先去<code class="fe mq mr ms mt b">script.js</code>看看<code class="fe mq mr ms mt b">addKeyBoardListener</code>，它处理的是玩家和其他瓷砖类型可能发生的碰撞。在<code class="fe mq mr ms mt b">if</code>树上，在<code class="fe mq mr ms mt b">WEAPON</code>条件下，让我们添加一个处理遗迹的新条件。在这个条件下，我们会将玩家的<code class="fe mq mr ms mt b">relics</code>计数加1。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="275f" class="my lo iq mt b gy mz na l nb nc">else if (game.map[y][x] == RELIC_CODE) {<br/>   player.relics++;<br/>}</span></pre><h2 id="fdf8" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">增加经验值</h2><p id="e1b7" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在让我们设定一个获得这件遗物的经验值的最大值。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="620b" class="my lo iq mt b gy mz na l nb nc">else if (game.map[y][x] == RELIC_CODE) {<br/>   player.relics++;<br/><strong class="mt ir">   const maxValue = 10;</strong><br/>}</span></pre><p id="513e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在零和<code class="fe mq mr ms mt b">maxValue</code>之间选择一个随机数。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="ba81" class="my lo iq mt b gy mz na l nb nc">else if (game.map[y][x] == RELIC_CODE) {<br/>   player.relics++;<br/>   const maxValue = 10;<strong class="mt ir"><br/>   player.xp += Math.round(Math.random()*maxValue);</strong><br/>}</span></pre><h2 id="c5a5" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">移走遗迹</h2><p id="5e50" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在让我们从地图上移除遗迹。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="b4cb" class="my lo iq mt b gy mz na l nb nc">else if (game.map[y][x] == RELIC_CODE) {<br/>   player.relics++;<br/>   const maxValue = 10;<strong class="mt ir"><br/></strong>   player.xp += Math.round(Math.random()*maxValue);<br/> <strong class="mt ir">  removeObjFromMap(x,y);</strong><br/>}</span></pre><p id="1d10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe mq mr ms mt b">roomObjFromMap</code>功能。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="353c" class="my lo iq mt b gy mz na l nb nc">function removeObjFromMap(x, y) {<br/>   game.map[y][x] = FLOOR_CODE;<br/>};</span></pre><h2 id="821a" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">制造获胜所需的遗迹</h2><p id="2667" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">让我们首先收集赢得游戏所需的所有遗物。当一个遗迹被收集时，让我们添加一个对名为<code class="fe mq mr ms mt b">checkForWin()</code>的函数的调用。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="26b4" class="my lo iq mt b gy mz na l nb nc">else if (game.map[y][x] == RELIC_CODE) {<br/>   player.relics++;<br/>   const maxValue = 10;<strong class="mt ir"><br/></strong>   player.xp += Math.round(Math.random()*maxValue);<br/> <strong class="mt ir"> </strong> removeObjFromMap(x,y);<strong class="mt ir"><br/></strong>  <strong class="mt ir"> checkForWin();<br/></strong>}</span></pre><p id="9b2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的初始<code class="fe mq mr ms mt b">checkForWin()</code>函数以前只在击败敌人时调用。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="f09d" class="my lo iq mt b gy mz na l nb nc">function checkForWin() {<br/>   if (game.enemies.length == 0) {</span><span id="6b7d" class="my lo iq mt b gy ol na l nb nc">      userWins();<br/>   }<br/>}</span></pre><p id="2c84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了制造所需的遗迹，我们必须改变<code class="fe mq mr ms mt b">checkForWin</code>中的条件。让我们用之前写的<code class="fe mq mr ms mt b">itemsLeft</code>方法来统计关卡中剩余的遗迹数量。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="ec93" class="my lo iq mt b gy mz na l nb nc">function checkForWin() {<br/>   if (game.enemies.length == 0 &amp;&amp; <br/>  <strong class="mt ir">    game.itemsLeft(RELIC_CODE)==0)</strong> {</span><span id="7494" class="my lo iq mt b gy ol na l nb nc">      userWins();<br/>   }<br/>}</span></pre><p id="f7c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，您的项目应该与<code class="fe mq mr ms mt b">phase-1-solution</code>相同或相似。继续在浏览器中打开两个<code class="fe mq mr ms mt b">index.html</code>文件进行比较。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/b98d565b9412ef4b22723ae92697a6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyfxPa8uKqlJcTKllA7KMg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.freepik.com/vectors/castle-interior" rel="noopener ugc nofollow" target="_blank">Castle interior vector</a> created by vectorpouch at <a class="ae kc" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">freepik.com</a></figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="eab4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">任务5:优化遗迹的放置</h1><p id="cc28" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">尽管我们在任务2中做出了努力，但遗物并没有出现在房间序列的结尾。这有两个原因:</p><ul class=""><li id="b377" class="nv nw iq kf b kg kh kk kl ko nx ks ny kw nz la oa ob oc od bi translated">房间序列可以从先前序列的最后一个房间开始，有效地扩展了序列。结果，有圣物的房间不再是最后的房间。</li><li id="c400" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">在一个失败的序列的情况下，一个遗迹被放置在现有的房间里，新的序列将会分支。</li></ul><p id="1d96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们为我们的算法添加一些新规则:</p><ul class=""><li id="5382" class="nv nw iq kf b kg kh kk kl ko nx ks ny kw nz la oa ob oc od bi translated">新的房间序列不能从序列中的最后一个房间分支出来。</li><li id="a748" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">如果一个新的序列不能开始，遗物将不被放置。</li></ul><p id="2d7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了给实现这些规则打下基础，现在让我们让游戏知道它创建的序列。</p><h2 id="0e41" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">从序列中选择房间</h2><p id="5ee4" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">让我们回到<code class="fe mq mr ms mt b">sequence.js</code>并修改<code class="fe mq mr ms mt b">sequentialRooms</code>。在我们创建了第一个<code class="fe mq mr ms mt b">baseRoom</code>之后，让它成为我们第一个场景的第一个房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="d116" class="my lo iq mt b gy mz na l nb nc">function sequentialRooms() {</span><span id="fe16" class="my lo iq mt b gy ol na l nb nc">   game.resetMap();</span><span id="4e8b" class="my lo iq mt b gy ol na l nb nc">   let baseRoom = addCenterRoom();<br/>  <br/> <strong class="mt ir">  let roomSequence = [baseRoom];</strong></span></pre><p id="cef2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们将这个新的房间序列作为序列数组中的第一个。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="aec0" class="my lo iq mt b gy mz na l nb nc">let sequences = [roomSequence];</span></pre><h2 id="1873" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">避开最后一个房间</h2><p id="7d57" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在我们的<code class="fe mq mr ms mt b">while</code>循环中，我们从<code class="fe mq mr ms mt b">game.rooms</code>数组中选择一个随机的房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="5a39" class="my lo iq mt b gy mz na l nb nc">let idx = Math.floor(Math.random()*<strong class="mt ir">game.rooms.length</strong>);</span></pre><p id="2387" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着任何房间都可以被选为起点，包括前面序列中的最后一个房间！</p><p id="8312" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，与其从整个地图中选择一个房间，不如让我们随机选择一个房间序列来处理。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="af02" class="my lo iq mt b gy mz na l nb nc">let seqIdx= Math.floor(Math.random()*sequences.length);</span></pre><p id="fc42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们抓住选择的序列，并使其成为新的<code class="fe mq mr ms mt b">roomSequence</code>。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="0d3b" class="my lo iq mt b gy mz na l nb nc">roomSequence = sequences[seqIdx];</span></pre><p id="58c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后让我们得到一个随机选择的房间的索引。为了避开最后一个房间，我们将使用一个比<code class="fe mq mr ms mt b">roomSequence</code>数组长度少<em class="oj">一个</em>的范围。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="f4fa" class="my lo iq mt b gy mz na l nb nc">let roomIdx = Math.floor(Math.random()*(roomSequence.length-1));</span></pre><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/292af0a59ced9dc5f85b09e1e7fcccef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*IVtjjuu_7iDFlUPItqPG2g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">With our new logic, the last room cannot be chosen.</figcaption></figure><p id="186d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们修改一下<code class="fe mq mr ms mt b">baseRoom</code>的分配，这样我们就可以从<code class="fe mq mr ms mt b">roomSequence</code>而不是<code class="fe mq mr ms mt b">game.rooms</code>那里获得选择的房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="c27c" class="my lo iq mt b gy mz na l nb nc">baseRoom = roomSequence[roomIdx];</span></pre><h2 id="b6a6" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">构建序列</h2><p id="d789" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们已经有了<code class="fe mq mr ms mt b">buildSequence</code>调用，它现在使用序列中的新<code class="fe mq mr ms mt b">baseRoom</code>——但是现在让我们捕获一个返回值，因为我们想要存储每个序列。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8cda" class="my lo iq mt b gy mz na l nb nc"><strong class="mt ir">roomSequence</strong> = buildSequence(baseRoom);</span></pre><p id="ee62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是两个序列调用<code class="fe mq mr ms mt b">buildSequence</code>后两个序列的示意图。在地图上，第一个序列的索引<code class="fe mq mr ms mt b">1</code>处的房间连接到第二个序列的第一个房间。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/c02c24c6e1f2599ae616414c8da8e7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*nauNenlGtsSH99ha9tI5wA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A new sequence of rooms emerges!</figcaption></figure><p id="5dc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要返回的序列不为空，我们就将其添加到我们的<code class="fe mq mr ms mt b">sequences</code>数组中。这样以后可能会随机选择。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="d9b5" class="my lo iq mt b gy mz na l nb nc">baseRoom = roomSequence[roomIdx];</span><span id="b618" class="my lo iq mt b gy ol na l nb nc">roomSequence = buildSequence(baseRoom);</span><span id="b167" class="my lo iq mt b gy ol na l nb nc"><strong class="mt ir">if (roomSequence.length &gt; 0) { <br/>    <br/>   sequences.push(roomSequence); <br/>}</strong></span></pre><p id="5730" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们的2D <code class="fe mq mr ms mt b">sequences</code>阵列，有两个长度相同的序列。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/13cd6bef44d39cd1f367275580b2314e.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*Eiw74s5uadiR8uxUOiS1lQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Each number corresponds to the index of the room in its array.</figcaption></figure><p id="61f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样——<code class="fe mq mr ms mt b">sequentialRooms</code>函数现在是“序列感知的”让我们对它的助手函数<code class="fe mq mr ms mt b">buildSequence</code>做一些修改，以避免在新序列失败时放置遗迹。</p><h2 id="5ddd" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">追踪我们构建的序列</h2><p id="bd25" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">就在<code class="fe mq mr ms mt b">maxSeqLen</code>赋值下面，让我们初始化一个我们将要返回的<code class="fe mq mr ms mt b">roomSequence</code>数组。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="05ec" class="my lo iq mt b gy mz na l nb nc">const maxSeqLen = 8;</span><span id="7479" class="my lo iq mt b gy ol na l nb nc"><strong class="mt ir">roomSequence = [];</strong></span></pre><p id="d790" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得我们下面的循环吗？</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="7e0d" class="my lo iq mt b gy mz na l nb nc">for (var i = 0; i &lt; maxSeqLen; ++i) {</span><span id="b7ef" class="my lo iq mt b gy ol na l nb nc"> let newRoom = addAdjacentRoom(baseRoom);</span></pre><p id="2112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回想一下，当没有新房间时，我们跳出循环，调用<code class="fe mq mr ms mt b">addRelic</code>。然而，如果一个新的序列无法开始，遗迹将被添加到先前序列中的<code class="fe mq mr ms mt b">baseRoom</code>中——因此，让我们只添加一个遗迹，如果我们正在完成的新序列有一个或多个房间。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="910c" class="my lo iq mt b gy mz na l nb nc">let newRoom = addAdjacentRoom(baseRoom);</span><span id="110e" class="my lo iq mt b gy ol na l nb nc">if (!newRoom) {</span><span id="6e9b" class="my lo iq mt b gy ol na l nb nc"><strong class="mt ir">    if (roomSequence.length &gt; 0) {</strong><br/>        placeRelic(baseRoom);<br/>  <strong class="mt ir">  }</strong><br/>    break;<br/>}<br/>baseRoom.directConnect(newRoom);</span></pre><p id="2ff0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再往下，在第二次调用<code class="fe mq mr ms mt b">placeRelic</code>之后，让我们将新房间添加到当前序列中。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="e469" class="my lo iq mt b gy mz na l nb nc">    break;<br/>}<br/>baseRoom.directConnect(newRoom);</span><span id="e26f" class="my lo iq mt b gy ol na l nb nc">if (i == maxSeqLen -1) {<br/>     placeRelic(newRoom);<br/>}<br/><br/><strong class="mt ir">roomSequence.push(newRoom);</strong></span><span id="179e" class="my lo iq mt b gy ol na l nb nc">baseRoom = newRoom;</span></pre><p id="e24b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们返回<code class="fe mq mr ms mt b">roomSequence</code>，这样就可以将它添加到<code class="fe mq mr ms mt b">sequentialRooms</code>中的序列数组中。</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="153d" class="my lo iq mt b gy mz na l nb nc">return roomSequence;</span></pre><p id="5872" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你应该有一个游戏，只在每个房间序列的结尾放置遗物。此外，所有新序列都应该从现有序列中分支出来，而不是无意中扩展它们。因为遗迹现在需要完成水平，玩家必须探索所有的房间。</p><p id="7d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个第二阶段的例子，在每个序列的结尾都有一个紫色的遗迹。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/b1aeb8c6f61206b847a5673a091bbdec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3WoEm2hp9v2Wx_h4vwVwbg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A Phase 2 level.</figcaption></figure><p id="2e42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝贺您，您已经完成了本教程！您可以将您的代码与<code class="fe mq mr ms mt b">phase-2-solution</code>中的<code class="fe mq mr ms mt b">sequence.js</code>文件进行比较，该文件也可以作为<a class="ae kc" href="https://gist.github.com/nevkatz/a9dd070238fd0d531dc7337000605487" rel="noopener ugc nofollow" target="_blank">要点</a>获得。你也可以把你的游戏比作这个<a class="ae kc" href="https://roguelike-relics.netlify.app/phase-2-solution/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>。</p><h2 id="7a7d" class="my lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni mb ks nj nk mf kw nl nm mj nn bi translated">建议的后续步骤</h2><ul class=""><li id="9b69" class="nv nw iq kf b kg ml kk mm ko or ks os kw ot la oa ob oc od bi translated">添加其他类型的收藏品，如开门的钥匙。</li><li id="5a2a" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">考虑让敌人移动。</li><li id="50cd" class="nv nw iq kf b kg oe kk of ko og ks oh kw oi la oa ob oc od bi translated">设定每一关的最小遗迹数量。</li></ul><p id="41a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这个教程。有关这里使用的房间顺序逻辑的更多背景信息，请查看下面的文章。</p><div class="ou ov gp gr ow ox"><a rel="noopener  ugc nofollow" target="_blank" href="/arranging-adjacent-rooms-in-a-javascript-roguelike-a5c178772d31"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">用JavaScript Roguelike构建一系列房间</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">让我们用相邻房间的序列来生成地牢等级。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl jw ox"/></div></div></a></div><p id="f733" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oj">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="oj">说白了就是io </em> </strong> </a> <em class="oj">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="oj">免费周报</em> </strong> </a> <em class="oj">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="oj">Twitter</em></strong></a><em class="oj">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="oj">LinkedIn</em></strong></a><em class="oj">。查看我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="oj">社区不和谐</em> </strong> </a> <em class="oj">加入我们的</em> <a class="ae kc" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="oj">人才集体</em> </strong> </a> <em class="oj">。考虑</em> <a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"> <strong class="kf ir"> <em class="oj">加入介质</em> </strong> </a> <em class="oj">。</em></p></div></div>    
</body>
</html>