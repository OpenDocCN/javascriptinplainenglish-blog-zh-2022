<html>
<head>
<title>Introduction to Parameter Decorators in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的参数修饰符简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-parameter-decorators-in-typescript-b0042b5474ed?source=collection_archive---------9-----------------------#2022-02-24">https://javascript.plainenglish.io/introduction-to-parameter-decorators-in-typescript-b0042b5474ed?source=collection_archive---------9-----------------------#2022-02-24</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="bd83" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">探索参数装饰器的使用和发展，为方法装饰器做准备</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/dce26d23d7f5570eca6dd74b05cd63c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q6O6hAJVHIFBrW-B.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Image by Author using corresponding project logos</figcaption></figure><p id="23b2" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">Decorators允许我们向TypeScript中的类或方法添加附加信息，类似于Java中的注释。参数修饰符应用于TypeScript中的方法参数定义。通过它们，我们可以记录有关参数的信息，包括在其他特征中使用该数据的定制信息。</p><p id="cd05" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在本文中，我们将探索在TypeScript中为方法参数开发装饰器。这就是参数装饰器在实践中的样子:</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="692d" class="lx ly ir lt b gz lz ma l mb mc">@ClassDecorator() <br/>class A { <br/>    ...<br/>    @MethodDecorator()<br/>    fly(<br/>         @ParameterDecorator(?? optional parameters)<br/>         meters: number<br/>    ) {<br/>         // code<br/>    }<br/> ...<br/>}</span></pre><p id="3c28" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">正如我们将看到的，我们不能对参数装饰器本身做太多，因为装饰器函数接收的信息很少。这使得在参数装饰器和其他代码(比如方法装饰器)之间共享数据变得非常重要。</p><p id="46c1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要使用decorator，必须在TypeScript中启用两个特性，所以请务必<a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">阅读本系列的decorator介绍文章</a>。</p><p id="a162" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文是系列文章的一部分:</p><ul class=""><li id="f366" class="me mf ir ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">装修工入门</a></li><li id="f3b0" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae md" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装修工</a></li><li id="8373" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">物业装修工</a></li><li id="c035" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">访问器装饰器</a></li><li id="0240" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><strong class="ky is">参数装饰者</strong> <em class="ms">本条</em></li><li id="8d45" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">方法装饰者</a></li><li id="e242" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0">混合装修工</a></li><li id="c934" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7">用装饰器使用反射和反射API</a></li><li id="b077" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5">运行时使用装饰器进行数据验证</a></li></ul><h1 id="cf17" class="mt ly ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">探索TypeScript中的参数修饰符</h1><p id="f5c6" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">参数装饰器附加到类构造函数或类成员方法的参数上。它们不能和一个独立的函数一起使用，因为你会得到<em class="ms">decorator在这里无效</em>的错误。它们只能与作为类定义一部分的函数的参数一起使用，如上所示。</p><p id="e8ea" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">参数装饰函数的签名是:</p><ol class=""><li id="c344" class="me mf ir ky b kz la lc ld lf mg lj mh ln mi lr np mk ml mm bi translated">静态成员的类的构造函数或实例成员的类的原型。</li><li id="571f" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr np mk ml mm bi translated">给出属性名称的字符串</li><li id="2e0c" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr np mk ml mm bi translated">函数的参数列表中参数的序号索引</li></ol><p id="c5cb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">前两个参数类似于提供给属性和访问器装饰函数的参数。第三个引用类方法的参数列表中的位置:</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="5c80" class="lx ly ir lt b gz lz ma l mb mc">class ClassName {<br/>     method(param0, param1, param2, param3, ...) {<br/>        ..<br/>     }<br/>}</span></pre><p id="ef3f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">参数以从0开始的索引进行编号，如下所示。第三个参数只是一个给出索引的整数，比如<code class="fe nq nr ns lt b">0</code>、<code class="fe nq nr ns lt b">1</code>、<code class="fe nq nr ns lt b">2</code>等。</p><p id="ce05" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于其他decorators，一个名为PropertyDescriptor的对象出现在第三个参数中。人们可以用这个描述符做很多有趣的事情，但是它不能用于参数装饰器。</p><h1 id="8e0e" class="mt ly ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">TypeScript中参数修饰符的简单示例</h1><p id="34cd" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">为了了解它是如何工作的，让我们尝试一个简单的例子来打印我们收到的值:</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="6bf1" class="lx ly ir lt b gz lz ma l mb mc">import * as util from 'util';  </span><span id="73e9" class="lx ly ir lt b gz nt ma l mb mc">function logParameter(target: Object, <br/>                      propertyKey: string | symbol,<br/>                      parameterIndex: number) {<br/>      console.log(`logParameter ${target} ${util.inspect(target)} ${String(propertyKey)} ${parameterIndex}`);<br/>}</span><span id="4bca" class="lx ly ir lt b gz nt ma l mb mc">class ParameterExample {<br/>      member(@logParameter x: number,<br/>             @logParameter y: number) {<br/>         console.log(`member ${x} ${y}`);<br/>      }<br/>}</span><span id="c039" class="lx ly ir lt b gz nt ma l mb mc">const pex = new ParameterExample();</span><span id="125c" class="lx ly ir lt b gz nt ma l mb mc">pex.member(2, 3); <br/>pex.member(3, 5); <br/>pex.member(5, 8);</span></pre><p id="ab04" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe nq nr ns lt b">target</code>的类型被指定为通用<code class="fe nq nr ns lt b">Object</code>。<code class="fe nq nr ns lt b">propertyKey</code>是函数的名称，在本例中是<code class="fe nq nr ns lt b">member</code>。<code class="fe nq nr ns lt b">parameterIndex</code>是一个整数，从<code class="fe nq nr ns lt b">0</code>开始，枚举这个装饰器所附加的参数。</p><p id="cbeb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">运行这个脚本，我们得到以下输出:</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="efc7" class="lx ly ir lt b gz lz ma l mb mc">$ npx ts-node lib/parameters/parameters.ts  <br/>logParameter [object Object] {} member 1 <br/>logParameter [object Object] {} member 0 <br/>member 2 3 <br/>member 3 5<br/> member 5 8</span></pre><p id="f548" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe nq nr ns lt b">target</code>原来是一个匿名对象。否则，键和索引值是预期的。</p><p id="8894" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">注意，参数装饰器没有机会对包含参数的对象实例执行代码。相反，它的影响范围是在创建类对象期间。与其他decorators不同，我们没有被赋予任何可以被修改来影响类实例行为的对象。</p><p id="b76a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">相反，参数装饰器主要用作向方法参数添加信息的标记。官方文件明确指出:</p><blockquote class="nu nv nw"><p id="23ec" class="kw kx ms ky b kz la js lb lc ld jv le nx lg lh li ny lk ll lm nz lo lp lq lr ik bi translated"><em class="ir">参数装饰器只能用于观察一个参数已经在一个方法上声明。</em></p></blockquote><p id="65f6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在大多数情况下，使用参数装饰器做任何有意义的事情都需要与其他装饰器合作。例如，参数装饰器可以使用反射和反射元数据API存储数据，其他装饰器可以在实现其他功能时使用这些数据。</p><h1 id="856c" class="mt ly ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">深入了解参数修饰者可用的数据</h1><p id="e421" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">深入检查<code class="fe nq nr ns lt b">target</code>对象有潜在的价值。我们从TypeScript文档中看到它是类对象，所以让我们验证一下这是什么意思。</p><p id="18e4" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在<code class="fe nq nr ns lt b"><a class="ae md" href="https://www.npmjs.com/package/decorator-inspectors" rel="noopener ugc nofollow" target="_blank">decorator-inspectors</a></code>包中，有一个我们可以使用的装饰器。这个例子来自于那个装饰器:</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="b7e8" class="lx ly ir lt b gz lz ma l mb mc">export function ParameterInspector(target: Object,<br/>                                   propertyKey: string | symbol,<br/>                                   parameterIndex: number) {<br/>      const ret = {<br/>         target, propertyKey, parameterIndex,<br/>         ownKeys: Object.getOwnPropertyNames(target),<br/>         members: {}<br/>      };<br/>      for (const key of Object.getOwnPropertyNames(target)) {<br/>         ret.members[key] = {<br/>             obj: target[key],<br/>             descriptor: util.inspect(<br/>                 Object.getOwnPropertyDescriptor(target, key)<br/>             )<br/>         };<br/>     }<br/>     console.log(ret);<br/>}</span></pre><p id="f101" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">它检索属性名列表，然后获取这些属性的更多细节。</p><p id="8ed6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如果我们用<code class="fe nq nr ns lt b">@ParameterInspector</code>代替上面例子中的<code class="fe nq nr ns lt b">@logInspector</code>，我们会得到这样的输出:</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="2728" class="lx ly ir lt b gz lz ma l mb mc">{<br/>   target: {},<br/>   propertyKey: 'member',<br/>   parameterIndex: 0,<br/>   ownKeys: [ 'constructor', 'member' ],<br/>   members: {<br/>     constructor: {<br/>       obj: [class ParameterExample],<br/>       descriptor: '{\n' +<br/>         '  value: [class ParameterExample],\n' +<br/>         '  writable: true,\n' +<br/>         '  enumerable: false,\n' +<br/>         '  configurable: true\n' +<br/>         '}'<br/>     },<br/>     member: {<br/>       obj: [Function: member],<br/>       descriptor: '{\n' +<br/>         '  value: [Function: member],\n' +<br/>         '  writable: true,\n' +<br/>         '  enumerable: false,\n' +<br/>         '  configurable: true\n' +<br/>         '}'<br/>     }<br/>   }<br/>}</span></pre><p id="4484" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">事实上，这清楚地表明<code class="fe nq nr ns lt b">target</code>就是上面显示的类。由<code class="fe nq nr ns lt b">getOwnPropertyNames</code>返回的列表是方法名——包括作为方法的<code class="fe nq nr ns lt b">constructor</code>,即使我们没有显式地创建一个构造函数。甚至还有一个可用的PropertyDescriptor。</p><h1 id="de76" class="mt ly ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">向框架注册参数装饰器</h1><p id="b58e" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">我们刚刚讨论了将参数装饰器数据保存在某个地方是如何有益的，以便其他装饰器可以使用该数据做一些事情。正如我们对<a class="ae md" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装饰者</a>和<a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">属性装饰者</a>所说的，你的装饰者可以是一个“框架”的一部分，在这个框架中，每一个装饰者为了一个更大的目标而一起工作。</p><p id="74c2" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">一个例子可能是在像Express这样的web框架中表示路由器的类中的路由处理方法。我们可能希望将它注入到从URL中的查询字符串捕获的参数值中，或者注入到POST请求的主体参数中。</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="5ee6" class="lx ly ir lt b gz lz ma l mb mc">@Router('/blog') <br/>class BlogRouter {<br/>     @Get('/view/:id')<br/>     viewPost(req, res, next,<br/>         @URLParam('id') id: string<br/>     ) {<br/>         // handle route<br/>     } <br/>}</span></pre><p id="0f4b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">Reflet decorator library for Express有这样的参数装饰器，以及这里显示的其他装饰器。对于这个例子，让我们只实现<code class="fe nq nr ns lt b">URLParam</code>中记录一些数据的部分。当我们使用<a class="ae md" href="https://techsparx.com/nodejs/typescript/decorators/methods.html" rel="noopener ugc nofollow" target="_blank">方法装饰器</a>时，我们将创建一个更完整的例子，其中方法和参数装饰器一起工作。</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="561f" class="lx ly ir lt b gz lz ma l mb mc">const registered = [];  </span><span id="82b4" class="lx ly ir lt b gz nt ma l mb mc">function URLParam(id: string) {<br/>     return (target: Object,<br/>         propertyKey: string | symbol,<br/>         parameterIndex: number) =&gt; {<br/>          const topush = {<br/>             target, propertyKey, parameterIndex, urlparam: id,<br/>             ownKeys: Object.getOwnPropertyNames(target),<br/>             function: target[propertyKey],<br/>             // funcDescriptor: Object.getOwnPropertyDescriptor(target, propertyKey)<br/>         };<br/>         registered.push(topush);<br/>     } <br/>}  </span><span id="f02e" class="lx ly ir lt b gz nt ma l mb mc">class BlogRouter {<br/>      viewPost(req, res, next,<br/>         @URLParam('id') id: string<br/>     ) {<br/>         console.log(`viewPost`);<br/>     }</span><span id="fab9" class="lx ly ir lt b gz nt ma l mb mc">      viewComments(req, res, next,<br/>                 @URLParam('id') id: string,<br/>                 @URLParam('commentID') commentID: string<br/>     ) {<br/>         console.log(`viewComments`);<br/>     } <br/>}  </span><span id="0644" class="lx ly ir lt b gz nt ma l mb mc">console.log(registered);</span></pre><p id="a9c1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe nq nr ns lt b">URLParam</code>是一个参数描述符函数，它收集一些关于参数装饰器和包含参数的方法的数据。它将这些数据保存到一个数组中，目的是让其他装饰者或框架使用这些数据来构造有用的东西。当讨论<a class="ae md" href="https://techsparx.com/nodejs/typescript/decorators/reflection.html" rel="noopener ugc nofollow" target="_blank">反射和元数据API</a>时，我们将看到一种更实用的方法来存储这些数据。</p><p id="e28f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在<code class="fe nq nr ns lt b">BlogRouter</code>类中，我们有两个方法，它们之间有一些参数，一些参数有<code class="fe nq nr ns lt b">@URLParam</code>装饰器。</p><p id="9e3e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们可以这样运行脚本:</p><pre class="kh ki kj kk gu ls lt lu lv aw lw bi"><span id="5ee0" class="lx ly ir lt b gz lz ma l mb mc">$ npx ts-node lib/parameters/urlparam.ts <br/>[<br/>   { <br/>     target: {},<br/>     propertyKey: 'viewPost',<br/>     parameterIndex: 3,<br/>     urlparam: 'id',<br/>     ownKeys: [ 'constructor', 'viewPost', 'viewComments' ],<br/>     function: [Function: viewPost]<br/>   },<br/>   {<br/>     target: {},<br/>     propertyKey: 'viewComments',<br/>     parameterIndex: 4,<br/>     urlparam: 'commentID',<br/>     ownKeys: [ 'constructor', 'viewPost', 'viewComments' ],<br/>     function: [Function: viewComments]<br/>   },<br/>   {<br/>     target: {},<br/>     propertyKey: 'viewComments',<br/>     parameterIndex: 3,<br/>     urlparam: 'id',<br/>     ownKeys: [ 'constructor', 'viewPost', 'viewComments' ],<br/>     function: [Function: viewComments]<br/>   } <br/>]</span></pre><p id="2b7e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这给了我们三个相应的数据对象。<code class="fe nq nr ns lt b">propertyKey</code>字段包含包含参数的方法名，而<code class="fe nq nr ns lt b">parameterIndex</code>包含其在参数列表中的索引。然后我们在<code class="fe nq nr ns lt b">urlparam</code>中记录从URL中获取哪个项目。然后我们记录函数名列表，以及方法的函数对象，因为这些可能会有用。</p><p id="ebfe" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们已经证明，在另一个地方记录任何我们喜欢的关于房产的数据是非常容易的。</p><h1 id="6940" class="mt ly ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">摘要</h1><p id="f278" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated">我们能够将装饰器附加到方法参数上。这意味着我们可以记录关于附加到每个参数的装饰者的信息，然后用这些数据做一些事情。</p><p id="c7c9" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">提供给装饰函数的数据的性质限制了该函数的能力。这意味着我们将期待一个方法装饰器函数利用关于参数装饰器的数据来做一些有用的事情。</p><h1 id="c9cd" class="mt ly ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">关于作者</h1><p id="fe1f" class="pw-post-body-paragraph kw kx ir ky b kz nk js lb lc nl jv le lf nm lh li lj nn ll lm ln no lp lq lr ik bi translated"><a class="ae md" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"><strong class="ky is"><em class="ms">David Herron</em></strong></a><em class="ms">:David Herron是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl oa ob hv oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ik il im in io"><p id="7efb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ms">原载于</em><a class="ae md" href="https://techsparx.com/nodejs/typescript/decorators/parameters.html" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">。</em></p><p id="9736" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ms">更多内容看</em> <strong class="ky is"> <em class="ms"> </em> </strong> <a class="ae md" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ms">说白了. io </em> </strong> </a> <em class="ms">。报名参加我们的</em> <a class="ae md" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ms">免费周报</em> </strong> </a> <em class="ms">。在我们的</em> <a class="ae md" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ms">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="ms">。</em></p></div></div>    
</body>
</html>