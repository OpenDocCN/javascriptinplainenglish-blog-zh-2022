<html>
<head>
<title>Rebases in Git and Why You Shouldn’t Be Afraid of Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git中的Rebases以及为什么不应该害怕它们</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rebases-in-git-and-why-you-shouldnt-be-afraid-of-them-b36a1bdccadf?source=collection_archive---------7-----------------------#2022-12-12">https://javascript.plainenglish.io/rebases-in-git-and-why-you-shouldnt-be-afraid-of-them-b36a1bdccadf?source=collection_archive---------7-----------------------#2022-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/992a7b2f486d0d928577bdf0250eadb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*053eF8rStUAwEIwy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Illustration by the author</figcaption></figure><p id="6716" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">初学者在使用Git时经常会对rebases有几点困惑:</p><p id="d51a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我将提供这些问题的答案。其间，TL；DR:rebase是一种将你的原始提交历史变成你想与你的团队其他成员分享的东西的方法。</p><h1 id="d9a4" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何做一个rebase</h1><p id="77dc" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">要执行重定基础，您可以运行<code class="fe md me mf mg b">git rebase &lt;commit-reference&gt;</code>。提交引用可以是任何内容，例如:</p><ul class=""><li id="5ebc" class="mh mi iq ke b kf kg kj kk kn mj kr mk kv ml kz mm mn mo mp bi translated">分行名称，</li><li id="28d4" class="mh mi iq ke b kf mq kj mr kn ms kr mt kv mu kz mm mn mo mp bi translated">标签，或者</li><li id="ac52" class="mh mi iq ke b kf mq kj mr kn ms kr mt kv mu kz mm mn mo mp bi translated">提交id。</li></ul><p id="0d51" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">重定基础是一个相当复杂的操作，所以让我们来看一下它的各个方面。</p><h1 id="edc4" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">简单重置基础</h1><p id="74c9" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在其最简单的形式中，重定基础从一个地方(一个基础)取得变化，并将它们移动到另一个地方。它改变了历史分叉的地方。因此，对于我之前<a class="ae mv" href="https://how-to.dev/how-to-display-git-branches-as-a-tree-in-cli" rel="noopener ugc nofollow" target="_blank">所写的树别名</a>，我们从这样的分支图开始:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="a447" class="ne lb iq mg b be nf ng l nh ni">$ git tree<br/>* 293b722 (HEAD -&gt; test) add test.txt file<br/>| * abc01e7 (origin/main, origin/HEAD, main) Add lorem ipsum to readme<br/>|/<br/>* edd3504 Add readme</span></pre><p id="9920" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们移动我们的分支从不同的地方开始——主分支的顶部:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="458e" class="ne lb iq mg b be nf ng l nh ni">$ git rebase main<br/>Successfully rebased and updated refs/heads/test.</span></pre><p id="9ed5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果，我们得到了这样一棵树:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="a623" class="ne lb iq mg b be nf ng l nh ni">$ git tree<br/>* fe4254e (HEAD -&gt; test) add test.txt file<br/>* abc01e7 (origin/main, origin/HEAD, main) Add lorem ipsum to readme<br/>* edd3504 Add readme</span></pre><p id="afd8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的<code class="fe md me mf mg b">test</code>分公司以前是从<code class="fe md me mf mg b">edd3504 Add readme</code>开始，现在是从<code class="fe md me mf mg b">abc01e7 Add lorem ipsum to readme</code>开始。</p><h1 id="67c1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">重定基础正在进行中</h1><p id="3861" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">即使是简单的重定基数也可能需要你方的额外投入。例如，您可能需要解决一些冲突:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="f316" class="ne lb iq mg b be nf ng l nh ni">$ git rebase main<br/>Auto-merging test.txt<br/>CONFLICT (add/add): Merge conflict in test.txt<br/>error: could not apply 293b722... add test.txt file<br/>hint: Resolve all conflicts manually, mark them as resolved with<br/>hint: "git add/rm &lt;conflicted_files&gt;", then run "git rebase --continue".<br/>hint: You can instead skip this commit: run "git rebase --skip".<br/>hint: To abort and get back to the state before "git rebase", run "git rebase --abort".<br/>Could not apply 293b722... add test.txt file</span></pre><p id="0bf1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下检查状态时，您将从Git获得如何继续的指示:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="2ee2" class="ne lb iq mg b be nf ng l nh ni">$ git status<br/>interactive rebase in progress; onto a03989b<br/>Last command done (1 command done):<br/>   pick 293b722 add test.txt file<br/>No commands remaining.<br/>You are currently rebasing branch 'test' on 'a03989b'.<br/>  (fix conflicts and then run "git rebase --continue")<br/>  (use "git rebase --skip" to skip this patch)<br/>  (use "git rebase --abort" to check out the original branch)<br/><br/>Unmerged paths:<br/>  (use "git restore --staged &lt;file&gt;..." to unstage)<br/>  (use "git add &lt;file&gt;..." to mark resolution)<br/>        both added:      test.txt<br/><br/>no changes added to commit (use "git add" and/or "git commit -a")</span></pre><p id="56e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您需要编辑该文件来解决冲突。完成后，将更改添加到暂存中:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="677b" class="ne lb iq mg b be nf ng l nh ni">$ git add test.txt<br/>(no output)</span></pre><p id="c91c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你继续重定基数:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="f69f" class="ne lb iq mg b be nf ng l nh ni">$ git rebase --continue<br/>[detached HEAD b81cad4] add test.txt file<br/> 1 file changed, 1 insertion(+)<br/>Successfully rebased and updated refs/heads/test.</span></pre><p id="8328" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随后，Git将继续rebase:它可以顺利完成，就像我的情况一样，或者您可能会遇到更多需要手动解决的冲突。</p><h1 id="650a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Rebase交互式</h1><p id="3d3f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">rebase的一个更高级的选项是rebase interactive。它允许你在树枝上做非常精确的改变——不仅仅是把它从一个地方移到另一个地方。下面我们来看几个例子。</p><h2 id="2415" class="nj lb iq bd lc nk nl dn lg nm nn dp lk kn no np lo kr nq nr ls kv ns nt lw nu bi translated">改写提交</h2><p id="5e9f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">您可以做的最简单的事情就是更改提交消息。好的一面是没有冲突的机会，因为文件保持不变。</p><h2 id="6ef0" class="nj lb iq bd lc nk nl dn lg nm nn dp lk kn no np lo kr nq nr ls kv ns nt lw nu bi translated">挤压提交</h2><p id="32ea" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">你可以选择几个提交，把它们变成一个。它保留了文件的更改——它只是将一连串的更改合并到一次提交中。它需要为新的提交写一个新的提交消息，但是它本身不会引起冲突。</p><h2 id="9e7d" class="nj lb iq bd lc nk nl dn lg nm nn dp lk kn no np lo kr nq nr ls kv ns nt lw nu bi translated">编辑提交</h2><p id="6d78" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">您也可以在提交中编辑文件更改。这允许您确保提交包含所有相关的更改。如果稍后在分支中对相同的位置进行了更改，那么您将需要手动解决冲突。</p><h2 id="89f3" class="nj lb iq bd lc nk nl dn lg nm nn dp lk kn no np lo kr nq nr ls kv ns nt lw nu bi translated">删除提交</h2><p id="ed3f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">另一个操作是从分支中删除提交——提交及其更改。如果稍后在分支中对相同的代码进行了额外的修改，删除提交将导致一些冲突。最基本的用例是当你意识到一些改变是不需要的，你想从历史中删除它们。除此之外，当我意识到我的分支变得太大时，我经常使用它，我打算让它更集中，并尽快合并它。</p><h2 id="124d" class="nj lb iq bd lc nk nl dn lg nm nn dp lk kn no np lo kr nq nr ls kv ns nt lw nu bi translated">重新排序提交</h2><p id="e57e" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">您也可以对提交进行重新排序。在某些情况下，这可能是有意义的，但是如果您试图重新排序一个更改了相同代码区域的提交，它会很快变得复杂。</p><h1 id="a55f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">文件接口</h1><p id="1428" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">正如你所看到的，交互式重定基础需要很多微妙的输入。Git以文本文件的形式获取这个输入。当我运行<code class="fe md me mf mg b">git rebase main -i</code>时，我得到了包含以下内容的编辑器:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="6691" class="ne lb iq mg b be nf ng l nv ni">pick a03989b add test.txt<br/><br/># Rebase abc01e7..a03989b onto abc01e7 (1 command)<br/>#<br/># Commands:<br/># p, pick &lt;commit&gt; = use commit<br/># r, reword &lt;commit&gt; = use commit, but edit the commit message<br/># e, edit &lt;commit&gt; = use commit, but stop for amending<br/># s, squash &lt;commit&gt; = use commit, but meld into previous commit<br/># f, fixup [-C | -c] &lt;commit&gt; = like "squash" but keep only the previous<br/>#                    commit's log message, unless -C is used, in which case<br/>#                    keep only this commit's message; -c is same as -C but<br/>#                    opens the editor<br/># x, exec &lt;command&gt; = run command (the rest of the line) using shell<br/># b, break = stop here (continue rebase later with 'git rebase --continue')<br/># d, drop &lt;commit&gt; = remove commit<br/># l, label &lt;label&gt; = label current HEAD with a name<br/># t, reset &lt;label&gt; = reset HEAD to a label<br/># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]<br/># .       create a merge commit using the original merge commit's<br/># .       message (or the oneline, if no original merge commit was<br/># .       specified); use -c &lt;commit&gt; to reword the commit message<br/>#<br/># These lines can be re-ordered; they are executed from top to bottom.<br/>#<br/># If you remove a line here THAT COMMIT WILL BE LOST.<br/>#<br/># However, if you remove everything, the rebase will be aborted.<br/>#</span></pre><p id="6798" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您保存文件并退出编辑器时，Git将遵循您在那里提供的说明。这是一个界面，一开始可能会觉得很笨拙，但你可以很快习惯它。唯一的“问题”是您需要知道您的默认编辑器，并知道如何使用它。我已经在<a class="ae mv" href="https://how-to.dev/how-to-keep-your-sanity-while-working-with-git#heading-check-what-your-default-editor-is" rel="noopener ugc nofollow" target="_blank">的另一篇文章</a>中写了更多。</p><h1 id="44b5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实用技巧</h1><p id="a566" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在做交互重基础的时候，尽量一次做一件事。Git可以在一个rebase中完成以下工作:<br/>更改分支起点</p><ul class=""><li id="e874" class="mh mi iq ke b kf kg kj kk kn mj kr mk kv ml kz mm mn mo mp bi translated">重新排序一些提交</li><li id="ad40" class="mh mi iq ke b kf mq kj mr kn ms kr mt kv mu kz mm mn mo mp bi translated">压扁别人</li><li id="61c9" class="mh mi iq ke b kf mq kj mr kn ms kr mt kv mu kz mm mn mo mp bi translated">等等。</li></ul><p id="79ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，你可能会迷失在所有同时发生的冲突中。一次只做一件事，保持以下顺序更容易:</p><ul class=""><li id="0d15" class="mh mi iq ke b kf kg kj kk kn mj kr mk kv ml kz mm mn mo mp bi translated">首先删除多余的提交，</li><li id="ffc6" class="mh mi iq ke b kf mq kj mr kn ms kr mt kv mu kz mm mn mo mp bi translated">挤压相关的提交，然后</li><li id="7956" class="mh mi iq ke b kf mq kj mr kn ms kr mt kv mu kz mm mn mo mp bi translated">把树枝移到另一个基地。</li></ul><p id="907c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过这种方式，您减少了必须来回移动的提交数量——从而减少了必须解决的冲突数量。</p><h1 id="ee33" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">历史在改变</h1><p id="5984" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">重置基础会改变存储库的历史。这意味着相同的更改将作为不同分支上的不同提交出现。这不是一个错误，但当您第一次看到以下日志时，可能会感到困惑:</p><pre class="mw mx my mz gt na mg nb bn nc nd bi"><span id="3599" class="ne lb iq mg b be nf ng l nh ni">$ git push origin test<br/>To github.com:how-to-js/git.md.git<br/> ! [rejected]        test -&gt; test (non-fast-forward)<br/>error: failed to push some refs to 'github.com:how-to-js/git.md.git'<br/>hint: Updates were rejected because the tip of your current branch is behind<br/>hint: its remote counterpart. Integrate the remote changes (e.g.<br/>hint: 'git pull ...') before pushing again.<br/>hint: See the 'Note about fast-forwards' in 'git push --help' for details</span></pre><p id="9d15" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe md me mf mg b">non-fast-forward</code>表示从存储库历史中的一点到另一点没有直接的路径。在这种情况下，您需要自己集成远程和本地更改。同步分支有一些微妙之处，这是另一篇文章的主题。</p><p id="10d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据项目中的工作流，可以禁止或要求覆盖某些分支的历史记录。我使用的工作流禁止对master/main分支进行历史更改，并且它需要所有其他分支的rebases。重定基础的方法没有对错之分:每种策略都有其利弊，但很可能您的团队会坚持您与所选方法保持一致。</p><h1 id="0254" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">可能的副作用</h1><p id="da1a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">除了rebases固有的复杂性之外，它们还在团队环境中引入了一些挑战:</p><h1 id="085e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">仅限本地的分支机构</h1><p id="98b9" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">当你的工作只在你的电脑上时，以任何其他方式改变历史总是安全的。这是一个很好的做法，因为它总是能帮助你在别人看到你的工作之前清理干净。如果您在一个月前开始了一些工作，并且从那时起，您已经定期地对main进行了更改——不值得用像<code class="fe md me mf mg b">Merge remote-tracking branch 'origin/main' into test</code>这样的提交来保存信息。相反，你可以定期调整基数，将历史记录保持为一条直线。</p><h1 id="670b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">上传到远程的分支</h1><p id="b3ee" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">一旦你分享了你的分支，对它的历史的任何改变都可能破坏东西。例如，您的持续集成(CI)将记住提交的测试运行的结果，但是提交将会消失。我遇到过一些人，他们对改变已经共享的历史非常谨慎，所以我想有些团队可能不鼓励这样做。</p><h1 id="9312" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">其他人工作的远程分支</h1><p id="f580" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">最复杂的情况是改变其他人正在处理的分支的历史。为此，我建议:</p><ul class=""><li id="5158" class="mh mi iq ke b kf kg kj kk kn mj kr mk kv ml kz mm mn mo mp bi translated">当变更发生时，确保每个人都是最新的——没有两个人同时向分支引入变更；</li><li id="c719" class="mh mi iq ke b kf mq kj mr kn ms kr mt kv mu kz mm mn mo mp bi translated">在开始新的工作之前，让每个人都更新到新的、重新确定基础的分支。</li></ul><p id="0cef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个微妙的情况，因为它破坏了Git使用的许多自动化冲突解决方案。在这种情况下，最好小心谨慎，确保每个人都知道发生了什么。</p><h1 id="83bb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">坚持学习</h1><p id="03df" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">如果你有兴趣学习更多关于Git分支的知识，可以在<a class="ae mv" href="https://learngitbranching.js.org/" rel="noopener ugc nofollow" target="_blank"> Learn Git Branching </a>找到一个很棒(也很漂亮)的资源。如果你有兴趣了解更多关于Git的知识，在这里注册<a class="ae mv" href="https://how-to-dev.ck.page/e92d2eb5d7" rel="noopener ugc nofollow" target="_blank">来获取我的Git相关内容的更新。</a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="1556" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="od">原发布于</em><a class="ae mv" href="https://how-to.dev/rebases-in-git-and-why-you-shouldnt-be-afraid-of-them" rel="noopener ugc nofollow" target="_blank"><em class="od">https://how-to . dev</em></a><em class="od">。</em></p><p id="0b44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="od">更多内容请看</em> <a class="ae mv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="od">说白了。</em></strong></a></p><p id="05dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="od">报名参加我们的</em> <a class="ae mv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="od">免费周报</em> </strong> </a> <em class="od">。关注我们关于</em><a class="ae mv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="od">Twitter</em></strong></a>，<a class="ae mv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="od">LinkedIn</em></strong></a><em class="od">，</em><a class="ae mv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="od">YouTube</em></strong></a><em class="od">，以及</em> <a class="ae mv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="od">不和</em> </strong> </a> <strong class="ke ir"> <em class="od">。</em>T41】</strong></p><p id="e44d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="od">有兴趣缩放你的软件启动</em> </strong> <em class="od">？检查</em> <a class="ae mv" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="od">电路</em> </strong> </a> <em class="od">。</em></p></div></div>    
</body>
</html>