<html>
<head>
<title>Create a Simple React Custom Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个简单的React自定义挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-simple-react-custom-hook-fc733d7b977a?source=collection_archive---------13-----------------------#2022-09-05">https://javascript.plainenglish.io/create-a-simple-react-custom-hook-fc733d7b977a?source=collection_archive---------13-----------------------#2022-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a33e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何创建一个简单的React自定义钩子的教程</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6fb040af088fd64e49aa398ca5ba780c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MX5FNwNh_E86u7gwEg4SSQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">学而时习之，不亦说乎 — learn from time to time</figcaption></figure><p id="e5ce" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在编写React功能组件时，如果想重用组件的部分逻辑，可以考虑编写<strong class="ku io"> <em class="lo">自定义钩子</em> </strong>。</p><p id="2032" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">首先，我们来看看React钩子。钩子只是JavaScript函数，但是在React中使用它们时，您需要遵循<a class="ae lp" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">规则</a>:</p><ul class=""><li id="7986" class="lq lr in ku b kv kw ky kz lb ls lf lt lj lu ln lv lw lx ly bi translated">只调用顶层的钩子</li><li id="a4c4" class="lq lr in ku b kv lz ky ma lb mb lf mc lj md ln lv lw lx ly bi translated">仅从React函数调用挂钩</li></ul><p id="540b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">👉第一点和React Hook的实现原理有关。第一次执行函数组件时，react分配一个对象，逐个调用钩子时，将得到的结果依次放入一个有序表中，然后存储在对象中。</p><p id="d3cb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于后续的执行，这些钩子的执行顺序必须是相同的，以便比较依赖关系，并与先前渲染的状态进行比较。</p><p id="4d87" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果钩子出现在循环、条件或嵌套函数中…不能保证钩子的执行顺序保持不变。</p><p id="32ce" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">👉第二点意味着你应该总是从<strong class="ku io"> React函数组件</strong>而不是<strong class="ku io">类组件</strong>或者<strong class="ku io">常规JavaScript函数</strong>中调用钩子，但是如果是<strong class="ku io">自定义钩子</strong>，<em class="lo">从其中调用钩子也是合法的</em>。</p><p id="67c4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">自定义钩子是一个JavaScript函数，具有唯一的命名约定，要求函数名以</em> <code class="fe me mf mg mh b"><em class="lo">use</em></code> <em class="lo">开头，并且能够调用其他钩子。</em></p><p id="033b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这听起来很麻烦，我会用一个简单的React例子来解释清楚。在下面的代码示例中，我们将在组件中获取并显示image/gif。🎈</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="22e4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">首先，让我们看看这个简单的应用程序的最终结果，我们有两个组件，顶部的组件名为<strong class="ku io"> RandomGif </strong>和<strong class="ku io"> </strong>，底部的组件名为<strong class="ku io"> SearchImg。* </strong> <em class="lo">既然本文的目的是介绍自定义钩子，就不做太多造型了。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/e6bd7424d61b9468bb28f11aa11b9a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYO0H2hVGjtqRdlU9Z5kfA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">end result</figcaption></figure><p id="7cc0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这两个组件都在App.js中:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/0bbd6c719755d626e1904451330587d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvte_vKw5tnUYqXrs43rZg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">RandomGif and SearchImg components</figcaption></figure><p id="4e48" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">组件名称说明了一切，<strong class="ku io"> RandomGif </strong>显示随机Gif，<strong class="ku io"> SearchImg </strong>让用户可以使用输入字段值搜索图像。<strong class="ku io"> </strong>我们将使用两个API端点(<a class="ae lp" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io">gi phy</strong></a><strong class="ku io"/>和<strong class="ku io"/><a class="ae lp" href="https://pixabay.com/de/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io">pix abay</strong></a>)，访问密钥将在我们注册时自动生成。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="e82f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，从<strong class="ku io"> RandomGif </strong>组件开始，<em class="lo">*下面的API_KEY存储在。环境文件。</em></p><pre class="kd ke kf kg gt mr mh ms mt aw mu bi"><span id="0b6f" class="mv mw in mh b gy mx my l mz na">import { useState, useEffect } from "react";<br/><br/>const RandomGif = () =&gt; {<br/>   const [gif, setGif] = useState(null);</span><span id="50d0" class="mv mw in mh b gy nb my l mz na">👉 const <strong class="mh io">fetchGif</strong> = () =&gt;<br/>    fetch(<br/>      `https://api.giphy.com/v1/gifs/random?  api_key=${RANDOM_API_KEY}&amp;tag=&amp;rating=g`<br/>    )<br/>      .then((res) =&gt; res.json())<br/>      .then((data) =&gt; setGif(data))<br/>      .catch((e) =&gt; console.error(e));<br/><br/>  useEffect(() =&gt; {<br/>      fetchGif();<br/>    }, []);<br/><br/>  const <strong class="mh io">getRandomGif</strong> = () =&gt; fetchGif();<br/><br/>return (<br/>    &lt;&gt;<br/>      &lt;button onClick={<strong class="mh io">getRandomGif</strong>}&gt;Get random Gifs&lt;/button&gt;<br/>      {gif ? (<br/>        &lt;img src={gif?.data?.images?.preview_gif?.url} alt={`${gif?.data?.username}`} /&gt;<br/>      ) : (<br/>        "Oops, no GIF found"<br/>      )}<br/>    &lt;/&gt;<br/>  );<br/>};<br/>export default RandomGif;</span></pre><p id="c21e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">搜索</strong>组件:</p><pre class="kd ke kf kg gt mr mh ms mt aw mu bi"><span id="6417" class="mv mw in mh b gy mx my l mz na">import { useState, useEffect } from "react";</span><span id="d559" class="mv mw in mh b gy nb my l mz na">const SearchImg = () =&gt; {<br/>    const [searchText, setSearchText] = useState("dog");<br/>    const [img, setImg] = useState(null);<br/>    <br/>  👉 const <strong class="mh io">fetchImg</strong> = () =&gt;<br/>       fetch(<br/>`https://pixabay.com/api/key=${SEARCH_API_KEY}&amp;q=${searchText}&amp;image_type=photo`<br/>    )<br/>      .then((res) =&gt; res.json())<br/>      .then((data) =&gt; setImg(data))<br/>      .catch((e) =&gt; console.error(e));<br/><br/>useEffect(() =&gt; {<br/>    fetchImg();<br/>  }, []);<br/><br/>const <strong class="mh io">getQueryImage</strong>= () =&gt; <strong class="mh io">fetchImg</strong>();<br/><br/> const hit = gif?.hits[Math.floor(Math.random() * gif?.hits?.length)];<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;input<br/>        type="text"<br/>        value={searchText}<br/>        onChange={(e) =&gt; setSearchText(e.target.value)}<br/>      /&gt;<br/>      &lt;button onClick={<strong class="mh io">getQueryImage</strong>}&gt;Search&lt;/button&gt;<br/>      &lt;p&gt;{search text}&lt;/p&gt;<br/>      {match?.previewURL ? (<br/>        &lt;img src={hit?.previewURL} alt={`${hit?.id}`} /&gt;<br/>      ) : (<br/>        "Oops, no image found"<br/>      )}<br/>    &lt;/&gt;<br/>  );<br/>};<br/>export default SearchImg;</span></pre><p id="73c6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如我们所见，<strong class="ku io"> RandomGif </strong>和<strong class="ku io"> SearchImg </strong>之间的逻辑基本相同，唯一的区别是我们使用了两个不同的端点，并且在<strong class="ku io"> SearchImg </strong>组件中有一个<strong class="ku io">输入</strong>字段和一个<strong class="ku io"> onChange </strong>事件处理程序，该事件处理程序针对输入值并为用户提供了通过值查询来搜索图像的能力，更容易解释的是，内有不同的<strong class="ku io">参数</strong></p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="6d79" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">创建这样的组件很简单，但是如果我们有更多的组件，其中我们使用不同的参数进行相同的API调用，我们不希望复制相同的代码并将其粘贴到每个组件中，对吗？</p><p id="166c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">一个好的解决方案是<em class="lo">定制</em>一个钩子来封装和共享组件之间相同的逻辑，如<a class="ae lp" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank"> React钩子介绍</a>所示:</p><p id="e7e2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="lo">自定义钩子是一个JavaScript函数，名字以“use”开头，可能会调用其他钩子。</em> </strong> <em class="lo">(例如:</em> <code class="fe me mf mg mh b"><em class="lo">useFetch</em></code> <em class="lo"> ) </em></p><p id="8301" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们为上面的例子创建一个自定义钩子，我将它命名为<strong class="ku io"> useFetch👐</strong></p><pre class="kd ke kf kg gt mr mh ms mt aw mu bi"><span id="11b1" class="mv mw in mh b gy mx my l mz na">// <strong class="mh io">useFetch</strong> custom Hook<br/>import { useState } from "react";<br/><br/>const useFetch = (url) =&gt; {<br/>  const [img, setImg] = useState(null);<br/>  const <strong class="mh io">fetchImg</strong> = () =&gt;<br/>    fetch (url)<br/>      .then((res) =&gt; res.json())<br/>      .then((data) =&gt; setImg(data))<br/>      .catch((e) =&gt; console.error(e));<br/>  return <strong class="mh io">[{ img }, fetchImg]</strong>;<br/>};<br/>export default useFetch;</span></pre><p id="a710" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在上面的代码中，我们创建了一个名为<code class="fe me mf mg mh b">useFetch.js</code>的新文件，其中包含一个函数<code class="fe me mf mg mh b">useFetch</code>，该函数包含了获取数据所需的所有逻辑。逻辑是从组件(<strong class="ku io"> fetchGif / fetchImg </strong>)中复制的，我们只是移除了硬编码的URL，并用一个可以传递给自定义钩子的<code class="fe me mf mg mh b">url</code>变量来替换它们。</p><p id="22a7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">自定义钩子不需要有特定的签名，我们可以决定它接受什么作为<strong class="ku io">参数</strong>，如果有的话，它应该<strong class="ku io">返回什么</strong>，在本例中:<strong class="ku io"> (url) </strong>和<code class="fe me mf mg mh b"><strong class="ku io">return</strong> <strong class="ku io">[{ img }, fetchImg]</strong></code></p><ul class=""><li id="8b20" class="lq lr in ku b kv kw ky kz lb ls lf lt lj lu ln lv lw lx ly bi translated">返回值{ <strong class="ku io"> img </strong> }是初始化为null的img状态，将被导入并在组件内部使用</li><li id="75c2" class="lq lr in ku b kv lz ky ma lb mb lf mc lj md ln lv lw lx ly bi translated">函数<strong class="ku io"> fetchImg </strong>将被导入并在组件内部使用</li></ul><p id="2e15" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">同样如钩子介绍中所示，<em class="lo">从自定义钩子中调用预定义的React库钩子是合法的，</em>所以<em class="lo"> </em>我们在这里使用了<strong class="ku io"> useState </strong>钩子，这两个组件中的钩子是完全相同的。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="5459" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在我们可以更新这两个组件，并使用这个自定义挂钩:</p><pre class="kd ke kf kg gt mr mh ms mt aw mu bi"><span id="0449" class="mv mw in mh b gy mx my l mz na">// <strong class="mh io">RandomGif </strong><br/>import { useEffect } from "react";<br/><strong class="mh io">import useFetch from "../useFetch";</strong> =&gt; <strong class="mh io"><em class="lo">import custom hook</em></strong><br/><br/>const RandomGif = () =&gt; {<br/><br/>  👉 const <strong class="mh io">[{ img }, fetchImg]</strong> = <strong class="mh io">useFetch</strong>(<br/>       "https://api.giphy.com/v1/gifs/random<br/>api_key=${RANDOM_API_KEY}&amp;tag=&amp;rating=g"<br/>       );<br/><br/>    useEffect(() =&gt; {<br/>      fetchImg();<br/>    }, []);<br/><br/>  const getRandomGif = () =&gt; <strong class="mh io">fetchImg</strong>();<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={getRandomGif}&gt;Get random gifs&lt;/button&gt;<br/>          {img? (<br/>        &lt;img src={<strong class="mh io">img</strong>?.data?.images?.preview_gif?.url}<br/>             alt={`${img?.data?.username}`} /&gt;<br/>           ) : (<br/>             "Oops, no GIF found"<br/>           )}<br/>    &lt;/&gt;<br/>  );<br/>};<br/>export default RandomGif;</span><span id="001e" class="mv mw in mh b gy nb my l mz na">// <strong class="mh io">SearchImg </strong><br/>import { useState, useEffect } from "react";<br/><strong class="mh io">import useFetch from "../useFetch";<br/></strong><br/>const SearchImg = () =&gt; {<br/>  const [searchText, setSearchText] = useState("dog");<br/>  const<strong class="mh io"> [{ img }, fetchImg]</strong> = <strong class="mh io">useFetch</strong>(<br/>    `https://pixabay.com/api/?key=${SEARCH_API_KEY}&amp;q=${searchText}&amp;image_type=photo`<br/>  );<br/><br/>  useEffect(() =&gt; {<br/>    fetchImg();<br/>  }, []);<br/><br/>  const SearchImg = () =&gt; <strong class="mh io">fetchImg</strong>();<br/>  const hit = <strong class="mh io">img</strong>?.hits[Math.floor(Math.random() * gif?.hits?.length)];<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;input<br/>        type="text"<br/>        value={searchText}<br/>        onChange={(e) =&gt; setSearchText(e.target.value)}<br/>      /&gt;<br/>      &lt;button onClick={SearchImg}&gt;Search&lt;/button&gt;<br/>      &lt;p&gt;{search text}&lt;/p&gt;<br/>      {hit?.previewURL ? (<br/>        &lt;img src={hit?.previewURL} alt={`${hit?.tags}`} /&gt;<br/>      ) : (<br/>        "Oops, no image found"<br/>      )}<br/>    &lt;/&gt;<br/>  );<br/>};<br/>export default SearchImg;</span></pre><p id="5105" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上面的代码解释道:</p><ul class=""><li id="dd2d" class="lq lr in ku b kv kw ky kz lb ls lf lt lj lu ln lv lw lx ly bi translated">我们进口我们的定制挂钩</li></ul><pre class="kd ke kf kg gt mr mh ms mt aw mu bi"><span id="ffac" class="mv mw in mh b gy mx my l mz na"><strong class="mh io">import useFetch from "../useFetch";</strong></span></pre><ul class=""><li id="67f5" class="lq lr in ku b kv kw ky kz lb ls lf lt lj lu ln lv lw lx ly bi translated">使用从我们的自定义钩子返回的状态和获取函数</li></ul><pre class="kd ke kf kg gt mr mh ms mt aw mu bi"><span id="08fa" class="mv mw in mh b gy mx my l mz na"><strong class="mh io">const [{ img }, fetchImg]</strong> = <strong class="mh io">useFetch</strong>(...)</span></pre><p id="0e86" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">注意这里的<strong class="ku io"> fetchImg </strong>函数不是用来更新“Img”状态的，它是来自useFetch自定义钩子的fetch函数，可以在另一个函数内部调用，在本例中为"<em class="lo">const search img =()=&gt;</em><strong class="ku io">fetchImg</strong><em class="lo">()"</em>" const getRandomGif =()=&gt;<strong class="ku io">fetchImg</strong><em class="lo">()"【T35】</em></p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="745b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">到目前为止，应用程序中没有任何变化，但是现在我们可以在任何组件中重用这个自定义钩子来从任何URL获取数据，只要它们使用相同的逻辑。通过定制钩子，我们可以将组件逻辑提取到可重用的功能中。</p><p id="f50e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就是这样！感谢您的宝贵时间！⏰</p><p id="0821" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你也对我的其他文章感兴趣，这里有一些链接:</p><div class="nc nd gp gr ne nf"><a rel="noopener  ugc nofollow" target="_blank" href="/create-a-simple-express-server-node-js-for-react-application-e2b2bd0c7e93"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd io gy z fp nk fr fs nl fu fw im bi translated">为React应用程序创建一个简单的Express服务器(Node.js)</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">关于如何创建一个简单的Express服务器(Node.js)、将其连接到React应用程序以及解决错误的教程…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="no l"><div class="np l nq nr ns no nt km nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a rel="noopener  ugc nofollow" target="_blank" href="/use-session-storage-to-persist-state-within-a-react-component-206867ef2269"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd io gy z fp nk fr fs nl fu fw im bi translated">使用会话存储来保持React组件中的状态</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">当页面会话结束时，sessionStorage中的数据将被清除。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="no l"><div class="nu l nq nr ns no nt km nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a rel="noopener  ugc nofollow" target="_blank" href="/use-session-storage-to-persist-state-within-a-react-component-206867ef2269"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd io gy z fp nk fr fs nl fu fw im bi translated">使用会话存储来保持React组件中的状态</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">当页面会话结束时，sessionStorage中的数据将被清除。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="no l"><div class="nu l nq nr ns no nt km nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://medium.com/geekculture/hide-and-replace-sticky-element-on-scrolling-in-a-react-way-8bc3f04e2a81" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd io gy z fp nk fr fs nl fu fw im bi translated">以反应方式隐藏和替换滚动时的粘性元素</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">—棘手但有趣🍡</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="nv l nq nr ns no nt km nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://enlear.academy/create-responsive-iframe-embed-in-a-react-way-f52075bf3b04" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd io gy z fp nk fr fs nl fu fw im bi translated">创建以反应方式嵌入的响应iframe</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">—令人惊讶的是，YouTube没有相应的嵌入代码🦄，我们来玩css吧…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">enlear .学院</p></div></div><div class="no l"><div class="nw l nq nr ns no nt km nf"/></div></div></a></div></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="db2b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">更多内容请看</em><a class="ae lp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">plain English . io</em></strong></a><em class="lo">。报名参加我们的</em> <a class="ae lp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lo">免费周报</em> </strong> </a> <em class="lo">。关注我们关于</em><a class="ae lp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">Twitter</em></strong></a><a class="ae lp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">LinkedIn</em></strong></a><em class="lo"/><a class="ae lp" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">YouTube</em></strong></a><em class="lo"/><a class="ae lp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">不和</em> </strong> </a> <em class="lo">。</em></p></div></div>    
</body>
</html>