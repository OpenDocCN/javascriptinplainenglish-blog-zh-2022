<html>
<head>
<title>JavaScript: A Deep Dive into Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:对集合的深入探究</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-a-deep-dive-into-sets-489b7a3dc06d?source=collection_archive---------11-----------------------#2022-01-28">https://javascript.plainenglish.io/javascript-a-deep-dive-into-sets-489b7a3dc06d?source=collection_archive---------11-----------------------#2022-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/4108a5df7cb559529e8e11ec41a613b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3qD2dAWyo9NdbY5oemssA.jpeg"/></div></figure><h1 id="ddc4" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">布景太棒了</h1><p id="2ae1" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">前段时间偶然发现<strong class="ku ir"> <em class="lq"> JavaScript集合</em> </strong>开始喜欢上了。我也发现自己不只在一个场合需要它。在这篇文章中，我将尝试涵盖为什么我认为<strong class="ku ir"> <em class="lq">集</em> </strong>很棒，以及如何利用它们。</p><p id="09c6" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我将介绍:</p><ul class=""><li id="6d94" class="lw lx iq ku b kv lr kz ls ld ly lh lz ll ma lp mb mc md me bi translated">什么是集合以及如何创建集合</li><li id="30b4" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">用集合查找特定元素</li><li id="bf11" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">获取集合的大小</li><li id="d2e5" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">用集合过滤掉数组中的重复值</li><li id="3b6a" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">环</li><li id="b614" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">集合与阵列的性能</li></ul><h1 id="7778" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是集合</h1><p id="47a6" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe mk ml mm mn b"><em class="lq">Sets </em></code>是一种新的对象类型，可以在ES6中使用。集合允许您创建唯一值的集合，并且像数组一样是可迭代的。集合可以保存简单的原语、字符串等值，也可以保存对象文字或数组。</p><p id="65d1" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><strong class="ku ir">官方对集合的描述是:<br/> </strong> <code class="fe mk ml mm mn b"><em class="lq">Set</em></code> <em class="lq">对象是值的集合。您可以按插入顺序循环访问集合中的元素。</em> <code class="fe mk ml mm mn b"><em class="lq">Set</em></code> <em class="lq"> </em> <strong class="ku ir"> <em class="lq">中的一个值可能只出现一次</em></strong><em class="lq">；在</em> <code class="fe mk ml mm mn b"><em class="lq">Set</em></code> <em class="lq">的收藏</em>中独一无二</p><h1 id="c739" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何创建集合</h1><p id="90cc" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">创建一个<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>非常简单。我们简单地创建一个<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>的<code class="fe mk ml mm mn b"><em class="lq">new</em></code>实例，如下所示:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="4227" class="mw jv iq mn b gy mx my l mz na">let mySet = new Set();</span></pre><p id="b4d6" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">简单吧？做一个没有值的<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>其实没什么意义。您可以使用几种不同的方法轻松地将值添加到<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>中。要么通过添加一个<code class="fe mk ml mm mn b"><em class="lq">iterable</em></code>对象作为参数，要么通过使用位于<code class="fe mk ml mm mn b"><em class="lq">Sets</em></code>原型上的<code class="fe mk ml mm mn b"><em class="lq">add()</em></code>方法。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="8e1f" class="mw jv iq mn b gy mx my l mz na">//Adding data from array<br/>let mySet = new Set(someArray)</span><span id="3ffa" class="mw jv iq mn b gy nb my l mz na">//Add two simple values<br/>let mySet = new Set();<br/>mySet.add(‘Donatello’).add(‘Leonardo’);</span></pre><p id="88dd" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">一个<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>只能存储唯一的值，这意味着如果你将“<strong class="ku ir"> <em class="lq">莱昂纳多</em> </strong>”添加两次，它将只为“<strong class="ku ir"> <em class="lq">莱昂纳多</em> </strong>”保存一个值。</p><p id="f741" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">集合包含其他方法，如</p><ul class=""><li id="697f" class="lw lx iq ku b kv lr kz ls ld ly lh lz ll ma lp mb mc md me bi translated">有()</li><li id="241b" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">大小()</li><li id="be3a" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">删除()</li><li id="6710" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">大小()</li><li id="2850" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">等等</li></ul><p id="fefb" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">您可以通过查看文档了解更多信息:<br/><a class="ae nc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#Methods" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Set # Methods</a></p><p id="565c" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">允许您创建唯一值的集合，那么这实际上意味着什么呢？基本上，这意味着对<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>中的值进行相等性测试，就像使用= = =(JavaScript中的相等运算符)一样。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="7bf2" class="mw jv iq mn b gy mx my l mz na">100 === 100 // true  <br/>'Leonardo' === ''Leonardo' // true<br/>100 === ‘100’ // false</span></pre><h1 id="1f6d" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">寻找特定元素</h1><p id="ec8c" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了检查一个元素是否存在于一个<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>中，我们必须使用<code class="fe mk ml mm mn b"><em class="lq">has()</em></code>方法。这将返回一个真/假值，很像<code class="fe mk ml mm mn b"><em class="lq">array.prototype.includes()</em></code>方法。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="c5a7" class="mw jv iq mn b gy mx my l mz na">console.log(mySet.has(1)); //true<br/>console.log(myArray.includes(1)); //true<br/>console.log(myArray.indexOf(1)); //0</span></pre><p id="6e15" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">但是，与数组不同，集合不支持获取特定值，因此如果您尝试:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="fdd7" class="mw jv iq mn b gy mx my l mz na">console.log(mySet[0]); //undefined<br/>console.log(myArray[0]); //1</span></pre><blockquote class="nd ne nf"><p id="6573" class="ks kt lq ku b kv lr kx ky kz ls lb lc ng lt lf lg nh lu lj lk ni lv ln lo lp ij bi translated"><strong class="ku ir">我个人觉得Set.has()比array.indexOf()更容易使用<br/>还要注意，如果你发现自己在使用array.includes()，它在Internet Explorer中不受支持</strong></p></blockquote><h1 id="40af" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">获取集合的大小</h1><p id="d6ed" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当我们有一个唯一的<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>时，我们经常需要获得一个大小的大小，就像处理数组时使用<code class="fe mk ml mm mn b"><em class="lq">array.length</em></code>一样。</p><p id="87d1" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><code class="fe mk ml mm mn b"><em class="lq">Set</em></code>持有一个可以让我们非常容易得到尺寸的方法，叫做size()……(Go figure；) )</p><p id="0d06" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">size方法返回一个<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>对象中元素的数量。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5988" class="mw jv iq mn b gy mx my l mz na">const number_of_different_companies = new Set(arrayOfData.map(item =&gt; item.getCompany().id)).size; // Will return a number, ex: 10</span></pre><h1 id="3e5d" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">过滤掉数组中的重复项</h1><p id="f9be" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">使用<code class="fe mk ml mm mn b"><em class="lq">Sets</em></code>时，有可能通过一个<code class="fe mk ml mm mn b"><em class="lq">array</em></code>。这将从数组中创建一组唯一的值，这意味着它将从数组中删除任何重复的值。</p><p id="d69e" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">让我们仔细看看。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="6abc" class="mw jv iq mn b gy mx my l mz na">// Create array<br/>const myArray = ['<strong class="mn ir">Splinter</strong>', 'Rafael', 'Donatello', 'Michelangelo', 'Shredder', '<strong class="mn ir">Splinter</strong>'];</span><span id="8f32" class="mw jv iq mn b gy nb my l mz na">//Convert to unique set of values<br/>const myUniqueSet = new Set(myArray); // returns: "Splinter", "Rafael", "Donatello", "Michelangelo", "Shredder"<br/> <br/>// Convert back to array<br/>const myUniqueArray = [...myUniqueSet]; //returns "Splinter", "Rafael", "Donatello", "Michelangelo", "Shredder"</span></pre><p id="56df" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我们要做的第一件事是用我们的值创建一个数组，然后将它传递给一个集合，这将删除数组中所有重复的值(数组中有两次的分段值)。</p><p id="25d6" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我们正在做的最后一件事是将它转换回一个数组。主要原因是<code class="fe mk ml mm mn b"><em class="lq">Sets</em></code>不支持数组方法，比如:</p><ul class=""><li id="01c2" class="lw lx iq ku b kv lr kz ls ld ly lh lz ll ma lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">array.map()</em></code></li><li id="6281" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">array.reduce()</em></code></li><li id="4f7e" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">array.filter()</em></code></li><li id="0a49" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">等等</li></ul><blockquote class="nd ne nf"><p id="fc74" class="ks kt lq ku b kv lr kx ky kz ls lb lc ng lt lf lg nh lu lj lk ni lv ln lo lp ij bi translated"><strong class="ku ir">请注意，当您处理对象时可能会很棘手，因为只有当集合测试的对象具有相同的对象引用时，等式才会返回true。</strong></p><p id="10ce" class="ks kt lq ku b kv lr kx ky kz ls lb lc ng lt lf lg nh lu lj lk ni lv ln lo lp ij bi translated">我个人也遇到过这样的问题，我有两个看起来相同的对象，但被认为是不相等的，因为它们有不同的对象引用。</p></blockquote><p id="203e" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在本文中了解更多关于对象引用的信息:<a class="ae nc" href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0" rel="noopener" target="_blank">https://code burst . io/explaining-value-vs-reference-in-JavaScript-647 a 975 E12 a 0</a></p><h1 id="3aba" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">循环集</h1><p id="b39c" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">然而，集合在其原型上包含一个<code class="fe mk ml mm mn b"><em class="lq">forEach</em></code>方法，这意味着我们可以循环集合中的所有值，而不必将其转换回数组。<br/>也可以使用<code class="fe mk ml mm mn b"><em class="lq">for of</em></code> …循环来循环所有值</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="dd45" class="mw jv iq mn b gy mx my l mz na">//ForEach<br/>myUniqueSet.forEach(value =&gt; console.log(value)); // Logs each value <br/> <br/> //For of<br/> for (let value of myUniqueSet) {<br/>     console.log(value) // Logs each value<br/> }</span></pre><p id="f8e9" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">你可以在这里了解更多关于你使用的可用方法:<a class="ae nc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#Methods" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Set # Methods</a></p><h1 id="1629" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">布景很快，非常快。</h1><p id="b908" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果您已经在JavaScript领域工作了一段时间，并且以前处理过数据，那么您可能也在某个时候遇到过数组。<br/>在数组中，我们可以添加/删除数据，查找特定元素等。</p><ul class=""><li id="f6d6" class="lw lx iq ku b kv lr kz ls ld ly lh lz ll ma lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">array.push()</em></code></li><li id="2909" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">array.splice()</em></code></li><li id="a029" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">array.indexOf()</em></code></li></ul><p id="d81c" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">通过使用一些可用的原型方法，您可以对集合做同样的事情。</p><p id="d4a7" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在这里，您可以找到如下方法:</p><ul class=""><li id="b806" class="lw lx iq ku b kv lr kz ls ld ly lh lz ll ma lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">set.add()</em></code></li><li id="5573" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">set.remove()</em></code></li><li id="d0df" class="lw lx iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated"><code class="fe mk ml mm mn b"><em class="lq">array.has()</em></code></li></ul><p id="53fd" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">你可以在这篇文章中了解更多:<a class="ae nc" href="https://alligator.io/js/sets-introduction/" rel="noopener ugc nofollow" target="_blank">https://alligator.io/js/sets-introduction</a></p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="16b5" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在听说并阅读了<code class="fe mk ml mm mn b"><em class="lq">Sets</em></code>如何提高JavaScript应用程序的速度之后，我产生了自己做一些测试的兴趣。令我惊讶的是，<code class="fe mk ml mm mn b"><em class="lq">Sets</em></code>不仅仅是快，与数组相比，它们快得惊人。</p><p id="a9d9" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">如今，浏览器通常都非常快，解析和执行JavaScript代码也非常快，所以我们需要创建一个包含足够多项的数组，这将给我们带来一定的延迟，以便我们可以测量操作之间的性能。</p><p id="f2e3" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我尝试在一个50，000个项目的<code class="fe mk ml mm mn b"><em class="lq">array</em></code>上比较上述方法。</p><p id="521f" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">为了测量性能，我们将使用浏览器自带的控制台，使用<strong class="ku ir"><em class="lq"/></strong></p><p id="8eae" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">首先创建一个默认为50.000项的数组:</p><p id="1c73" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><strong class="ku ir">注意:注意fill()只能在支持ES6的浏览器中工作。</strong></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="268e" class="mw jv iq mn b gy mx my l mz na">const arraySize = 50000;</span><span id="e19e" class="mw jv iq mn b gy nb my l mz na">let array = new Array(arraySize).fill(arraySize);</span><span id="6ad6" class="mw jv iq mn b gy nb my l mz na">console.log( array.length ); // 50000</span></pre><p id="0d9d" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><strong class="ku ir">比较Array.push和Set.add() </strong></p><p id="e84a" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">让我们试着比较一下上面的方法，看看它们的表现如何。</p><p id="e589" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在本例中，我们将50001添加到现有的<code class="fe mk ml mm mn b"><em class="lq">array</em></code>和<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>中。<br/> <br/>数组测试:<strong class="ku ir">0.36181640625毫秒</strong> <br/>设置测试:<strong class="ku ir">0.010009765625毫秒</strong></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="0740" class="mw jv iq mn b gy mx my l mz na">//Add values<br/>console.time( 'arrayTest' );<br/>array.push( arraySize + 1 );<br/>console.timeEnd( 'arrayTest' );</span><span id="da19" class="mw jv iq mn b gy nb my l mz na">let set = new Set( array );</span><span id="71a4" class="mw jv iq mn b gy nb my l mz na">console.time( 'setTest' );<br/>set.add( arraySize + 1 );<br/>console.timeEnd( 'setTest' );</span><span id="5ffa" class="mw jv iq mn b gy nb my l mz na">console.log( "array length", array.length ); // 50001<br/>console.log( "setsize", set.size ); // 500001*/</span></pre><p id="a377" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">正如你所看到的，set要快得多——实际上<strong class="ku ir">比</strong>快了189%。</p><p id="a5ad" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><strong class="ku ir">比较Array.splice和Set.delete() </strong></p><p id="0875" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">让我们试着从数组和集合中删除40，000个项目，看看它们的性能如何比较:</p><p id="ffcc" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">array delete:<strong class="ku ir">0.147216796875毫秒</strong><br/>set delete:<strong class="ku ir">0.011962890625毫秒</strong></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="73b4" class="mw jv iq mn b gy mx my l mz na">/Delete values<br/>let deleteFromArray = ( arr, item ) =&gt; {<br/>    var i = array.indexOf( item );<br/>    i !== -1 &amp;&amp; array.splice( i, 1 );<br/>};</span><span id="4461" class="mw jv iq mn b gy nb my l mz na">console.time( 'arrayDelete' );<br/>deleteFromArray( array, 40000 );<br/>console.timeEnd( 'arrayDelete' );</span><span id="3d93" class="mw jv iq mn b gy nb my l mz na">let set = new Set( array );</span><span id="65e2" class="mw jv iq mn b gy nb my l mz na">console.time( 'setDelete' );<br/>set.delete( 40000 );<br/>console.timeEnd( 'setDelete' );</span></pre><p id="e647" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">再说一次，电视节目的表现要好得多。这次<strong class="ku ir">好了169%</strong>。</p><p id="ab73" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><strong class="ku ir">找到收藏中的特定物品</strong></p><p id="bd70" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">让我们试着找到一个特定的项目——我们可以通过使用<code class="fe mk ml mm mn b"><em class="lq">array.indexOf()</em></code>和<code class="fe mk ml mm mn b"><em class="lq">set.has()</em></code>来完成</p><p id="39d7" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">array find:<strong class="ku ir">0.1728515625毫秒</strong><br/>set find:<strong class="ku ir">0.0859375毫秒</strong></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="894d" class="mw jv iq mn b gy mx my l mz na">// Helpers<br/>let checkArr = ( array, item ) =&gt; array.indexOf( item ) !== -1;<br/>let checkSet = ( set, item ) =&gt; set.has( item );</span><span id="eeb1" class="mw jv iq mn b gy nb my l mz na">// set variables<br/>let set, result;</span><span id="a1ac" class="mw jv iq mn b gy nb my l mz na">console.time( 'arrayFind' );<br/>result = checkArr( array, 40000 );<br/>console.timeEnd( 'arrayFind' );</span><span id="cb2d" class="mw jv iq mn b gy nb my l mz na">set = new Set( array );</span><span id="231a" class="mw jv iq mn b gy nb my l mz na">console.time( 'setFind' );<br/>checkSet( set, 40000 );<br/>console.timeEnd( 'setFind' );</span></pre><p id="e8be" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">电视再次证明了自己的速度更快，性能提高了67%。</p><blockquote class="nd ne nf"><p id="d172" class="ks kt lq ku b kv lr kx ky kz ls lb lc ng lt lf lg nh lu lj lk ni lv ln lo lp ij bi translated">您的结果可能会显示一些其他数字。结果可能因设备、操作系统、浏览器等而异。</p><p id="9fa2" class="ks kt lq ku b kv lr kx ky kz ls lb lc ng lt lf lg nh lu lj lk ni lv ln lo lp ij bi translated">我在一台装有Win10和Chrome73的笔记本电脑上做了测试</p><p id="5e17" class="ks kt lq ku b kv lr kx ky kz ls lb lc ng lt lf lg nh lu lj lk ni lv ln lo lp ij bi translated"><strong class="ku ir">看看我在Codepen和Fork上的测试吧，如果你喜欢自己做测试的话:</strong><a class="ae nc" href="https://codepen.io/NickyCDK/pen/bJOWBj" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">https://codepen.io/NickyCDK/pen/bJOWBj</strong></a></p></blockquote><h1 id="8cfc" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">最后的想法</h1><p id="150e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我不是使用<code class="fe mk ml mm mn b"><em class="lq">Sets</em></code>的专家，但是在我看过之后，它们看起来很棒。</p><p id="a8c8" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">看起来<code class="fe mk ml mm mn b"><em class="lq">Sets</em></code>通常比数组表现得更好。这是不是意味着你不应该再使用数组了？我会说不。它不是数组的替代品，因为数组可以做很多集合不能做的事情，反之亦然。<strong class="ku ir">例如，在集合中，你不能访问一个特定的索引，并获取那个索引的值。</strong></p><p id="bfc4" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">最大的区别是<code class="fe mk ml mm mn b"><em class="lq">arrays</em></code>可以保存值的副本而<code class="fe mk ml mm mn b"><em class="lq">Sets</em></code>不能<strong class="ku ir">(无论你做什么)</strong>。另外，数组是索引集合，集合是键控集合。<br/> <br/>性能的提升让我感到惊讶，就我个人而言，我可能会更频繁地使用<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>，因为与数组相比，它们在定位元素和添加/删除元素时表现得更好。</p><p id="e4d6" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">同样，如果你记得…在集合中我们不能使用数组方法。然而，这可以通过将<code class="fe mk ml mm mn b"><em class="lq">Set</em></code>转换回<code class="fe mk ml mm mn b"><em class="lq">array</em></code>来解决:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="31c6" class="mw jv iq mn b gy mx my l mz na">// Example on convert set to an array and using the array.map() method.<br/>let myArray = […mySetOfNames].map(name =&gt; {firstname: name.firstname});</span></pre><p id="35f3" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">当您将集合转换回数组时，所有数组方法都可以再次使用，因为它现在是一个数组。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="ba77" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">总的来说，在我看来，这两者的结合似乎是一种依赖于场景的方式，但我很想听听你的意见，你会如何使用它，你用它来做什么？</p><p id="69bd" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">感谢阅读，我希望你喜欢这篇文章，如果是的话，请点击按钮或订阅来支持我。</p><p id="a22e" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">如果你还不是中等会员，考虑成为一名吧！你可以接触到很棒的内容，并有机会与他人分享你自己的知识。在这里注册每月只需5美元。 </p><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-interfaces-explained-in-2-minutes-af1637b88bd4"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">两分钟解释的类型脚本接口</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">在这篇小文章中，您将学习什么是接口，以及如何在您自己的项目中创建和使用接口。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oc l"><div class="od l oe of og oc oh js nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-generics-explained-in-2-minutes-c95e49783347"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">用2分钟的时间用例子解释了类型脚本泛型</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">深入探究类型脚本泛型</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oc l"><div class="oi l oe of og oc oh js nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://medium.com/js-dojo/vuejs-tips-best-practices-39d9962bb255" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">VueJS —技巧和最佳实践</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">在构建Vue应用时，你应该做什么，应该避免什么，通常只是一些简单的好建议</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="oj l oe of og oc oh js nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://medium.com/js-dojo/build-a-website-using-nuxt-contentful-a-step-by-step-guide-b75217ccdfa" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">使用Nuxt &amp; Contentful建立网站——一步一步的指南</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">了解如何使用Vue/NuxtJS构建一个简单的网站Contentful——还包括一个Vuex示例。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="ok l oe of og oc oh js nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://medium.com/front-end-weekly/a-closer-look-on-array-reduce-with-useful-examples-34f222664e66" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">通过有用的示例进一步了解array.reduce()</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">提高您的javascript技能，并通过一些有用的示例学习如何使用Array.prototype.reduce()</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="ol l oe of og oc oh js nt"/></div></div></a></div></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="631b" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><strong class="ku ir"> <em class="lq">如果你想找个时间和我聊聊，请关注我的</em></strong><a class="ae nc" href="https://twitter.com/nickycdk" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"><em class="lq">Twitter</em></strong></a><strong class="ku ir"><em class="lq">|</em></strong><a class="ae nc" href="https://www.linkedin.com/in/dknickychristensen/" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"><em class="lq">LinkedIn</em></strong></a><strong class="ku ir"><em class="lq">或者直接访问我的</em> </strong> <a class="ae nc" href="https://nickychristensen.dk/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="lq">网站</em> </strong> </a> <strong class="ku ir"> <em class="lq">(不过是丹麦文)</em></strong></p><p id="c643" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><em class="lq">更多内容请看</em><a class="ae nc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"><em class="lq">plain English . io</em></strong></a><em class="lq">。报名参加我们的</em> <a class="ae nc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="lq">免费每周简讯</em> </strong> </a> <em class="lq">。在我们的</em> <a class="ae nc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="lq">社区不和谐</em> </strong> </a> <em class="lq">中获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>