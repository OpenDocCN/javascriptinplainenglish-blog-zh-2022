<html>
<head>
<title>How to Create Custom ESLint Rules in 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在5分钟内创建自定义ESLint规则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-custom-eslint-rules-in-5-minutes-763f14cb9b5?source=collection_archive---------4-----------------------#2022-02-10">https://javascript.plainenglish.io/how-to-create-custom-eslint-rules-in-5-minutes-763f14cb9b5?source=collection_archive---------4-----------------------#2022-02-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7f8ba26e3ced0c5b31258998f5c4064a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Du6GuYqZt0Gv5ZwsUcoe_A.png"/></div></div></figure><p id="4a88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">静态分析是软件开发的一个很好的工具。我们不需要等待运行的代码来发现是否有不好的事情发生。通常，我们可以在开发过程的早期发现错误。此外，静态分析工具总是用在CI/CD管道中(我希望😁).</p><p id="0d19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ESLint是一个开源项目，帮助我们自动检测JavaScript项目中的问题。它由Nicholas C. Zakas和来自世界各地的贡献者创建和维护。ESLint规则也是开源的，所以您可以在项目中使用它们来创建规则约定。此外，最常见的方法是安装社区支持的预定义规则集，例如Airbnb、StandartJS和其他应用程序。但是，如果您有一个独特的案例，或者需要扩展ESLint的功能，您可以创建自己的自定义规则。</p><p id="530a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ESLint有一个插件系统，我们可以编写自己的规则，并在项目中使用。但是插件架构好像很复杂，在不太了解NodeJS和ESLint API的情况下，开始编写ESLint的规则并不容易。</p><p id="c100" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将在5分钟内了解如何添加定制的ESLint规则，而无需编写任何特殊的模块、文件和脚本。</p><h1 id="773d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在您决定创建自己的规则之前</h1><p id="9753" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">许多开发人员创建自定义规则来实施他们自己的编码标准。然而，并不是每个人都知道社区已经创建了一个庞大的规则集，并且通常这些规则已经默认包含在ESLint中。在您决定创建自己的规则之前，首先搜索规则列表和任何其他可用的ESLint插件。其他人可能已经创建了您正在寻找的规则。</p><p id="3ca4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是帮助您查找规则和配置的链接:</p><ul class=""><li id="bfc7" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated"><a class="ae mf" href="https://eslint.org/docs/rules/" rel="noopener ugc nofollow" target="_blank">官方ESLint规则</a></li><li id="1100" class="lw lx in jx b jy mg kc mh kg mi kk mj ko mk ks mb mc md me bi translated"><a class="ae mf" href="https://github.com/dustinspecker/awesome-eslint" rel="noopener ugc nofollow" target="_blank">awesome-eslint</a>—eslint预置、配置、插件和规则的集合</li></ul><h1 id="89c1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建自定义规则</h1><p id="534b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">一般来说，创建与不寻常的语法连接的自定义规则。例如，当您开发一个项目时，您的个人方法可能是:</p><ul class=""><li id="785b" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">您不想使用的遗留模块或方法</li><li id="38f0" class="lw lx in jx b jy mg kc mh kg mi kk mj ko mk ks mb mc md me bi translated">你只是想限制使用一些方法或模块。</li></ul><p id="bb0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于所有这些情况，我们不需要通过编写新的模块来开发新的规则。我们可以使用一个特殊的统一内置规则<code class="fe ml mm mn mo b">no-restricted-syntax</code></p><h2 id="d708" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">使用<code class="fe ml mm mn mo b">no-restricted-syntax</code></h2><p id="c8c4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这条规则允许我们限制JavaScript语法的任何部分。</p><p id="9c36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，我们的JS代码部分或元素由抽象语法树(AST)中的ESTree节点表示。当解析器分析我们的代码时，它们创建AST，并且代码的每个部分都用一个特殊的节点名标记。</p><p id="a18d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对我们来说，这种代码很常见，我们每天都会遇到:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="9a1f" class="mp ku in mo b gy nj nk l nl nm">const arrowSum = (a,b) =&gt; {<br/>  return a + b <br/>};</span></pre><p id="2d28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是对于解析器来说，它表示为:</p><ul class=""><li id="e691" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated"><code class="fe ml mm mn mo b">const arrowSum</code> -变量说明</li><li id="01de" class="lw lx in jx b jy mg kc mh kg mi kk mj ko mk ks mb mc md me bi translated"><code class="fe ml mm mn mo b">(a, b) =&gt; {...}</code> -箭头函数表达式</li></ul><p id="18fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，每个节点都包含属性并描述所有语句和值。该示例的抽象语法树如下所示:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/11892aef16bda6184dc904acc787f5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6ISwy3tJbmepmP_3vDZDQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Abstract Syntax Tree</figcaption></figure><p id="a21c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里你可以看到<strong class="jx io">变量声明</strong>有“init”值<strong class="jx io">箭头函数表达式</strong>。该函数包含参数“a”和“b”以及作为<strong class="jx io"> BlockStatement </strong>的主体，其中我们有带表达式的<strong class="jx io"> ReturnStatement </strong>节点。这就是我们的捆绑器、编译器如何看待我们的代码以及ESLint。</p><h2 id="4972" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">基本用法</h2><p id="6d98" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">回到我们的<code class="fe ml mm mn mo b">no-restricted-syntax</code>规则，我们可以通过指定节点名和条件来配置它，以定义新的限制。所有配置都可以在<code class="fe ml mm mn mo b">.eslintrc.json</code>文件中应用。让我们试着在我们的项目中限制使用箭头函数:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="f0e1" class="mp ku in mo b gy nj nk l nl nm">"rules": {<br/>     "no-restricted-syntax": [<br/>       "error",<br/>       {<br/>         "selector": "ArrowFunctionExpression",<br/>         "message": "Arrow function expressions are not allowed."<br/>       }<br/>     ]<br/>}</span></pre><p id="3b62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该规则接受对象，其中指定了选择器和可选的自定义消息。让我们看看结果— IDE将我们的函数标记为错误，并显示一条消息:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/e38c83fb5e97707b3c8f228e8f376a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mh-CnItFCnH1onSfKEpIbQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">VSCode with ESLint extension</figcaption></figure><p id="598b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个非常简单的例子，我们实际上不想限制使用箭头函数，但是我们可以指定复杂的条件，让我们试着创建一些更复杂的例子。在选择器中的节点名称之后，我们可以指定条件:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="1481" class="mp ku in mo b gy nj nk l nl nm">"selector": "ArrowFunctionExpression[params.length&lt;2]",</span></pre><p id="3fd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该示例将查找少于2个参数的箭头函数:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/321d7323dc70621d74dc19747a81ee1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CUFy9LvzOY2Qrpsb7algQ.png"/></div></div></figure><p id="1bdf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照这种方式，我们将能够限制使用语法的任何部分。</p><h2 id="4f6c" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">避免在React组件中使用道具</h2><p id="3d59" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们试着避免在React组件中使用一些道具。通过这个例子，我将向您展示查找节点名和其他属性是多么容易。</p><p id="c7c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有一个简单的组件:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="3fe4" class="mp ku in mo b gy nj nk l nl nm">const BlogPage = () =&gt; {<br/>   return (<br/>     &lt;main style={{ position: "absolute" }}&gt;<br/>       &lt;h1 className="text-5xl font-bold"&gt;Blog&lt;/h1&gt;<br/>     &lt;/main&gt;<br/>   );<br/>};</span></pre><p id="3749" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们试着限制在<code class="fe ml mm mn mo b">main</code>组件中使用<code class="fe ml mm mn mo b">style</code>道具。为此，我们需要知道AST节点名。AST节点名称的完整列表可以在<a class="ae mf" href="https://github.com/eslint/espree/blob/main/lib/ast-node-types.js" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得，并且<a class="ae mf" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>可以用来识别您的代码包含什么类型的节点。我建议使用AST Explorer，下面是我们组件的样子:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/ee57ceb1d2304bb2077c002ff1d82e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKBgfUVhbKgQjehRYwPAgg.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">AST Explorer</figcaption></figure><p id="e692" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们需要点击<code class="fe ml mm mn mo b">style</code> prop，你会看到包含另一个属性节点的<strong class="jx io"> JSXAttribute </strong>节点。我们可以通过<code class="fe ml mm mn mo b">name.name</code>参数找到的<code class="fe ml mm mn mo b">styles</code>属性节点名。在我们规则的选择器配置中，我们可以添加嵌套选择，只需用空格将它们分开。</p><p id="4780" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的配置将会是什么样子:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="d59c" class="mp ku in mo b gy nj nk l nl nm">"no-restricted-syntax": [<br/>       "error",<br/>       {<br/>         "selector": "JSXOpeningElement[name.name='main'] JSXAttribute[name.name='style']",<br/>         "message": "Style prop is not allowed."<br/>       }  <br/>]</span></pre><p id="e1ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选择器向ESLint提供了一个规则，它说——任何名为<code class="fe ml mm mn mo b">main</code>的JSX元素和名为<code class="fe ml mm mn mo b">style</code>的JSX属性都应该用提供的消息标记为错误。</p><p id="6fff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们规则的结果:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/e911a5413fc64f6050400f2ece9d56ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYTQGzNiTKZq6E6_A0FtsA.png"/></div></div></figure><p id="e50c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！这就是你如何用一行配置创建规则并限制代码的任何部分。</p><p id="4f44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nw">更多内容看</em> <a class="ae mf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nw">说白了。报名参加我们的</em> <a class="ae mf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nw">免费周报</em> </strong> </a> <em class="nw">。在我们的</em> <a class="ae mf" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nw">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="nw">。</em></strong></a></p></div></div>    
</body>
</html>