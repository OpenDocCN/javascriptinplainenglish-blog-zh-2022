<html>
<head>
<title>Use RxJS in React with Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在用钩子反应中使用RxJS</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-rxjs-in-react-with-hooks-da0226a00f1f?source=collection_archive---------0-----------------------#2022-03-25">https://javascript.plainenglish.io/use-rxjs-in-react-with-hooks-da0226a00f1f?source=collection_archive---------0-----------------------#2022-03-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="81b7" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/rxjs-39bc4f4110ec" rel="noopener"> RxJS </a></h2><div class=""/><p id="3551" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">使用JavaScript的反应式扩展处理数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/85f3322fa64aa762543209aec5d8a146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbZMo9TJh6FRwvxST9Lbrg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">RxJS is suitable to work with React</figcaption></figure><p id="1d35" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">RxJS代表JavaScript的反应式扩展。</p><p id="0620" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">Reactive Extensions库最初是由微软开发的，从那时起，它已经被用于其他几种语言，如Java (RxJava)和Python (RxPy)。</p><h1 id="ec90" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">RxJS是什么？</h1><p id="5672" class="pw-post-body-paragraph jt ju in jv b jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq ig bi translated">根据<a class="ae mk" href="https://rxjs.dev/guide/overview" rel="noopener ugc nofollow" target="_blank">官方文档</a>“<em class="ml">RxJS是一个利用可观察序列</em>来组成异步的、基于事件的程序的库”。</p><p id="375e" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">换句话说，RxJS是一个帮助我们管理和操作数据的库。</p><p id="8704" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">用RxJS代替promises 有几个<a class="ae mk" href="https://www.vitainbeta.org/2022/01/25/why-rxjs-rxjs-vs-promises/" rel="noopener ugc nofollow" target="_blank">原因。然而，我们可以简单地说，与其他库不同，RxJS可以随时间产生多个值，并且当特定事件发生时，它使用推送模型来通知应用程序。这是反应式编程的核心。</a></p><h1 id="9aac" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">在React中使用RxJS</h1><p id="50ca" class="pw-post-body-paragraph jt ju in jv b jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq ig bi translated">在本帖中，我将展示React中RxJS的一个例子。</p><p id="5746" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">在前进之前，确保你已经很好地掌握了<a class="ae mk" href="https://www.vitainbeta.org/2022/02/01/what-are-observables/" rel="noopener ugc nofollow" target="_blank">可观察到的</a>。可观测量是RxJS的组成部分，因此理解它们非常重要。</p><p id="6a5c" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">在下面的例子中，我将使用内置的<code class="fe mm mn mo mp b">interval</code>函数，因为它是现成的，易于使用。也有可能<a class="ae mk" href="https://www.vitainbeta.org/2022/02/15/hands-on-1-create-an-observable/" rel="noopener ugc nofollow" target="_blank">从头开始创建一个observable</a>但是在这篇文章中，我想去掉一些复杂性来展示如何在React中使用RxJS和observables。</p><p id="0405" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">让我们来看一种处理可观察对象的方法，以及React中的<em class="ml"> subscribe </em>和<em class="ml"> unsubscribe </em>方法。</p><h2 id="cc21" class="mq li in bd lj mr ms dn ln mt mu dp lr ke mv mw lv ki mx my lz km mz na md it bi translated">内置的区间函数</h2><p id="97db" class="pw-post-body-paragraph jt ju in jv b jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq ig bi translated">如<a class="ae mk" href="https://rxjs.dev/api/index/function/interval" rel="noopener ugc nofollow" target="_blank"> rxjs.dev </a>上所报告的那样，<code class="fe mm mn mo mp b">interval</code>内置函数“<em class="ml">创建一个可观察对象，该可观察对象每隔指定的时间间隔</em>发出连续的数字。</p><p id="8d1d" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">换句话说，多亏了<code class="fe mm mn mo mp b">interval</code>，我们将获得一系列(可观察到的)上升数字。</p><p id="4156" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">可观测的将发射整数，“在这些发射之间有一个你选择的恒定时间间隔”。</p><h2 id="fa63" class="mq li in bd lj mr ms dn ln mt mu dp lr ke mv mw lv ki mx my lz km mz na md it bi translated">创建一个反应组件</h2><p id="d3ec" class="pw-post-body-paragraph jt ju in jv b jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq ig bi translated">为了在React中使用RxJS interval，我们从一个非常通用的React组件开始。</p><p id="3e6d" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">我导入了useState和useEffect。我假设你熟悉React钩子。然而，如果不是这样，我鼓励你复习一下<a class="ae mk" href="https://www.vitainbeta.org/2021/05/03/learn-react-from-scratch-usestate-react-state-hook/" rel="noopener ugc nofollow" target="_blank">状态挂钩</a>和<a class="ae mk" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">效果挂钩</a>。</p><p id="5ff7" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">我还从rxjs库导入了<code class="fe mm mn mo mp b">interval</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk"><a class="ae mk" href="https://gist.github.com/lorenzojkrl/29715c917b925113bf5ee6b51833786f" rel="noopener ugc nofollow" target="_blank">Initial React component</a></figcaption></figure><p id="e538" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">最终的应用程序将显示一个计数器，从零开始，每秒增加一个单位。</p><p id="198e" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">在这个函数组件中，我使用了useState钩子。state将存储由observable发出的值，setState将在必要时设置新值。</p><p id="f8a5" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">因此，通过在HTML代码中使用<code class="fe mm mn mo mp b">{state}</code>，我们将始终显示每秒更新的<code class="fe mm mn mo mp b">state</code>的当前值。</p><p id="c75c" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">我们可以在组件中创建一个rxjs可观察对象，如下所示:</p><pre class="ks kt ku kv gt nd mp ne nf aw ng bi"><span id="3ace" class="mq li in mp b gy nh ni l nj nk">const observable$ = interval(1000);</span></pre><p id="8058" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">美元符号是一种约定，表示变量observable$确实是rxjs可观测的。它代表一段时间内的数据流。</p><p id="e637" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">我们把1000交给<code class="fe mm mn mo mp b">interval()</code>。这是一次发射和下一次发射之间的指定时间量，以毫秒为单位。</p><h2 id="1158" class="mq li in bd lj mr ms dn ln mt mu dp lr ke mv mw lv ki mx my lz km mz na md it bi translated">连接RxJS并通过useEffect做出反应</h2><p id="9722" class="pw-post-body-paragraph jt ju in jv b jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq ig bi translated">我们可以说RxJS和React之间的链接就是效果钩子。</p><p id="50dc" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">尽管我们在React中只看到了一个<code class="fe mm mn mo mp b">interval</code>的例子，但这种模式对其他RxJS函数也很有用。</p><p id="d22e" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated"><code class="fe mm mn mo mp b">useEffect()</code>接受一个函数，在这个函数中，我们可以有副作用。在我们的例子中，副作用是通过使用<code class="fe mm mn mo mp b">subscribe()</code>方法订阅observable$。</p><p id="4a74" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">我们向subscribe方法传递一个观察器。<a class="ae mk" href="https://www.vitainbeta.org/2022/02/08/what-are-observers/#next-error-complete" rel="noopener ugc nofollow" target="_blank">观察器可以是一个带有next、error和complete </a>的对象，也可以是一个函数。</p><p id="51a5" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">在这种情况下，我们将函数<code class="fe mm mn mo mp b">(value) =&gt; setState(value)</code>传递给setState，该函数将由observable发出的值传递给重新呈现组件的setState。</p><p id="c58a" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">每次效果挂钩重新渲染组件时，它都会取消订阅可观察对象，并订阅新的可观察对象。</p><p id="5f6d" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">注意，我们传递的是一个空的依赖数组，所以我们没有与任何状态同步。换句话说，我们是在说“继续重新渲染”。</p><pre class="ks kt ku kv gt nd mp ne nf aw ng bi"><span id="80ee" class="mq li in mp b gy nh ni l nj nk">useEffect(() =&gt; {<br/>    observable$.subscribe((value) =&gt; setState(value));<br/>  }, []);</span></pre><p id="8c46" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">此时，我们的代码如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d630" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">而且app会有计数器！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nl"><img src="../Images/97c9ef40443a5c865c34cc58a2ecec17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BK-wYLwLJs0odJeC2dHA0g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">React app using RxJS and the interval function</figcaption></figure><p id="e971" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">这个应用程序看起来运行良好，但是缺少了一些东西。</p><h1 id="9ee8" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">记得打扫卫生</h1><p id="6981" class="pw-post-body-paragraph jt ju in jv b jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq ig bi translated">为了避免内存泄漏，我们应该在结束时停止可观察到的内容。由于<code class="fe mm mn mo mp b">interval</code>永远不会完成，我们需要手动取消订阅。</p><p id="ecb4" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">在React effect hook中，如果我们订阅了某个数据源，我们应该返回一个清理函数。</p><p id="f7f2" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">这并不总是必要的！你可以在React文档中阅读更多关于不清理的<a class="ae mk" href="https://reactjs.org/docs/hooks-effect.html#effects-without-cleanup" rel="noopener ugc nofollow" target="_blank">效果。简而言之，“<em class="ml">网络请求、手动DOM突变和日志记录是不需要清理的常见影响示例。</em>”</a></p><p id="9c9f" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">订阅确实需要清理。</p><p id="d0bd" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">幸运的是，添加和删除订阅的"<em class="ml">代码是如此紧密地联系在一起，以至于useEffect被设计成将它们结合在一起。如果你的效果返回一个函数，React会在清理</em>的时候运行它。</p><p id="c992" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">这对我们来说是个好消息，因为它简化了清理工作！</p><p id="ba16" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">换句话说，使用效果</p><ol class=""><li id="6f3f" class="nm nn in jv b jw jx ka kb ke no ki np km nq kq nr ns nt nu bi translated">运行效果</li><li id="f374" class="nm nn in jv b jw nv ka nw ke nx ki ny km nz kq nr ns nt nu bi translated">当它完成效果时，它返回并运行我们提供的清理功能</li></ol><p id="2fde" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">让我们来看看这段新代码:</p><pre class="ks kt ku kv gt nd mp ne nf aw ng bi"><span id="6162" class="mq li in mp b gy nh ni l nj nk">useEffect(() =&gt; {<br/>    const subscription = observable$.subscribe(setState);<br/>    return () =&gt; subscription.unsubscribe();<br/>  }, []);</span></pre><p id="80ef" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">首先，我们订阅了<code class="fe mm mn mo mp b">observable$</code>，这将返回一个订阅。</p><p id="6819" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">注意，将<code class="fe mm mn mo mp b">setState</code>传递给<code class="fe mm mn mo mp b">subscribe</code>方法类似于传递<code class="fe mm mn mo mp b">(value) =&gt; setState(value)</code>。</p><p id="d6e2" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">我们保存对<code class="fe mm mn mo mp b">subscription</code>变量的订阅。</p><p id="aeb9" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">effects钩子通过使用<code class="fe mm mn mo mp b">unsubscribe()</code>方法返回一个取消订阅的函数。</p><p id="d8f7" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">通过这样做，在必要的时候进行清理，我们不会引入内存泄漏。</p><p id="52b9" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">在GitHub 上找到完整的<a class="ae mk" href="https://github.com/lorenzojkrl/rxjs-primer/blob/main/hands-on/hands-on-2/App.js" rel="noopener ugc nofollow" target="_blank">代码，在RxJS </a>上找到其他<a class="ae mk" href="https://www.vitainbeta.org/2022/03/06/rxjs-primer/" rel="noopener ugc nofollow" target="_blank">帖子。</a></p><h1 id="1d88" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="98ad" class="pw-post-body-paragraph jt ju in jv b jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq ig bi translated">RxJS不简单也不直白。</p><p id="9caa" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">理解“可观察”的概念需要从承诺的传统观念中转移思维。</p><p id="4921" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">然而，随着时间的推移处理数据而不是在单一时刻获取数据的概念可能是一个强大的概念。有些框架，比如Angular，广泛采用RxJS。</p><p id="ba46" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated">RxJS被定义为事件的Lodash。与Lodash的情况一样，您并不一定需要使用它。然而，熟悉它的程序员可以获得一些主要的好处。</p><h2 id="0e05" class="mq li in bd lj mr ms dn ln mt mu dp lr ke mv mw lv ki mx my lz km mz na md it bi translated">感谢你花时间在我的帖子上！</h2><p id="9b0e" class="pw-post-body-paragraph jt ju in jv b jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq ig bi translated">如果你对RxJS有一些经验，好的坏的，都留下评论吧！我个人主要是用RxJS搭配Angular。</p><p id="580e" class="pw-post-body-paragraph jt ju in jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ig bi translated"><em class="ml">更多内容请看</em><a class="ae mk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jv ix"><em class="ml">plain English . io</em></strong></a><em class="ml">。报名参加我们的</em> <a class="ae mk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jv ix"> <em class="ml">免费周报</em> </strong> </a> <em class="ml">。关注我们关于</em><a class="ae mk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jv ix"><em class="ml">Twitter</em></strong></a><em class="ml">和</em><a class="ae mk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jv ix"><em class="ml">LinkedIn</em></strong></a><em class="ml">。加入我们的</em> <a class="ae mk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jv ix"> <em class="ml">社区不和谐</em> </strong> </a> <em class="ml">。</em></p></div></div>    
</body>
</html>