<html>
<head>
<title>Understand JavaScript’s Event Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript的事件循环</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-javascripts-event-loop-36c021f850f7?source=collection_archive---------9-----------------------#2022-06-09">https://javascript.plainenglish.io/understand-javascripts-event-loop-36c021f850f7?source=collection_archive---------9-----------------------#2022-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bc86" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">进入圈子</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/926f077e4a6f43114f78458c68a627bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_fxXQrlfN07TYJwXfQmDQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@supergios?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jonny Gios</a> on <a class="ae ks" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4a70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我最近看了<a class="ae ks" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">菲利普·罗伯茨</a>和<a class="ae ks" href="https://www.youtube.com/watch?v=u1kqx6AenYw" rel="noopener ugc nofollow" target="_blank">艾琳·齐默</a>来自JSConf EU的关于JavaScript事件循环的精彩演讲，这启发我阅读<a class="ae ks" href="https://www.w3.org/TR/2016/CR-html51-20160621/webappapis.html#event-loops" rel="noopener ugc nofollow" target="_blank"> HTML5规范</a>本身，并确保我真正理解它。我现在认为我已经很好地理解了什么是事件循环，我想在这里总结一下。</p><h1 id="0fc7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">调用堆栈</h1><p id="27bb" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">调用堆栈是一种数据结构，它记住了我们在代码中的位置。每当我们进入一个新的函数时，一个执行上下文被推到堆栈上，当我们从函数返回时，执行上下文被弹出，这样我们就可以在函数调用后继续运行代码。</p><p id="3468" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript是单线程的，这意味着它一次只能执行一个任务——只有一个线程，只有一个调用堆栈。如果堆栈上有“慢”代码，它会阻止其余代码的运行，还会导致UI看起来没有响应。正因为如此，我们希望这些“慢”代码(例如，网络调用)尽可能远离堆栈。</p><h1 id="eab3" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">任务队列和事件循环</h1><p id="64d1" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">阻塞代码是通过使用异步回调来解决的——将函数传递给另一个函数，后者在后台执行代码，然后运行我们传递的函数。当实际运行这些回调时，我们不能将它们直接放回调用堆栈，所以我们将它们放在一个单独的数据结构中，在那里它们可以等待——任务队列<strong class="kv io"/>。为了执行队列中正在等待的任务，我们有了<strong class="kv io">事件循环</strong>，这是一个无限循环，负责(除了其他事情之外)从队列中取出第一个任务并将其推送到堆栈上。一旦调用堆栈为空，事件循环就会运行。</p><p id="579a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">展示任务队列和事件循环如何工作的一个基本例子是使用<code class="fe mm mn mo mp b">setTimeout</code>。让我们看看下面的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="7658" class="mu lq in mp b gy mv mw l mx my">console.log('Hello');<br/>setTimeout(() =&gt; console.log('World!'), 2000);</span></pre><p id="b7d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">运行该代码时，将执行以下步骤:</p><ol class=""><li id="8fcd" class="mz na in kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated"><code class="fe mm mn mo mp b">console.log('Hello')</code>被放入调用堆栈。它被执行，并且“hello”被打印到控制台。</li><li id="c454" class="mz na in kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated"><code class="fe mm mn mo mp b">setTimeout(() =&gt; console.log('World'), 2000)</code>被放在调用堆栈上。方法<code class="fe mm mn mo mp b">setTimeout</code>被执行，它将回调和定时器发送到由浏览器提供的setTimeout API。</li><li id="680e" class="mz na in kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated">2秒钟后，是回调<code class="fe mm mn mo mp b">() =&gt; console.log('World')</code>运行的时候了，所以web API把它推到任务队列中。</li><li id="0e89" class="mz na in kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated">调用堆栈是空的，因此事件循环可以将回调从任务队列中取出，并将其推送到调用堆栈中，在那里运行并将“World”打印到控制台。</li></ol><p id="01ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个重要的附带说明是，我们可以从这些步骤中理解到<code class="fe mm mn mo mp b">setTimeout(cb, 0)</code>并不立即运行回调，而是web API将回调直接放到任务队列中。因为队列中的任务需要等待调用堆栈为空，所以在回调真正运行之前，可能还需要更多的时间。这使得超时实际上是在回调被执行之前经过的<em class="nn">最小</em>时间量，而不是确切的时间。</p><h1 id="9ecf" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">翻译</h1><p id="d339" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">每次任务执行后，浏览器可以决定是否运行渲染管道。大多数浏览器每秒渲染窗口约60次，大约每16毫秒一次，但浏览器可以选择延迟渲染并优先处理其他任务。需要注意的是，因为渲染管道直到任务完成后才运行，所以非常长的任务会延迟窗口的渲染。</p><p id="e596" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">到目前为止，我们已经描述了一个基本的事件循环，由一个任务队列和一个渲染管道组成。所以逻辑是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="fc3c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">多个任务队列</h1><p id="edcd" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">HTML5规范规定一个事件循环可以有不止一个任务队列，只要所有的任务都来自一个特定的源(比如鼠标点击、定时器等。)去同一个队列。浏览器可以为每个队列设置不同的优先级。在每个时钟周期，事件循环选择它想要从哪个队列中取出一个任务，这个任务被放在调用堆栈中。就像单个队列一样，渲染管道只能在选择的任务完成后运行。</p><p id="653c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用多个任务队列的一个缺点是，您对事件计时的控制较少，例如，如果有一个超时队列和另一个鼠标事件队列，事件循环可以决定在运行超时队列上的事件之前完全清空鼠标事件队列，从而导致超时事件的延迟比预期的长。</p><p id="4195" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们的事件循环看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="ac3a" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">微任务队列</h1><p id="c745" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">事件循环还可以有一个微任务队列(一般来说，微任务是承诺)，它在从“常规”队列中选择的任务完成之后被处理。该队列的独特之处在于，在事件循环的每个节拍，在循环移动到渲染管道之前，它被完全清空。</p><p id="9163" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当将微任务队列添加到事件循环中时，我们得到以下结果:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="7637" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">动画帧回调队列</h1><p id="8354" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">最后，事件循环还可以有一个动画帧回调队列，所有的<code class="fe mm mn mo mp b">requestAnimationFrame</code>回调都放在那里。这些任务仅在浏览器决定运行渲染管道时运行，并在重画之前执行，以更新动画。只有重画时队列中的任务才会运行，任何进入队列的新任务都会在事件循环的下一个节拍执行。这样，如果代码正在设置动画，它会一次更新一帧动画。</p><h1 id="9487" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">把所有的放在一起</h1><p id="5c52" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">就是这样！我们已经讨论了事件循环可以拥有的所有不同类型的队列，现在我们对事件循环是如何工作的有了一个完整的理解。当我们把所有东西放在一起时，我们得到以下逻辑:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9efd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望你和我一样对这个解释感兴趣，我很高兴听到你的任何评论或见解。下次见！</p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="23b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nn">更多内容尽在</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nn">说白了. io </em> </strong> </a> <em class="nn">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nn">免费周报</em> </strong> </a> <em class="nn">。关注我们关于</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nn">推特</em> </strong> </a> <em class="nn">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nn">LinkedIn</em></strong></a><em class="nn">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nn">社区不和谐</em> </strong> </a> <em class="nn">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nn">人才集体</em> </strong> </a> <em class="nn">。</em></p></div></div>    
</body>
</html>