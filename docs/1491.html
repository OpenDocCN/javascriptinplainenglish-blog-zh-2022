<html>
<head>
<title>The Difference Between var, let, and const in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中var、let和const的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-difference-between-var-let-and-const-in-javascript-4ef3b4307fb3?source=collection_archive---------13-----------------------#2022-03-28">https://javascript.plainenglish.io/the-difference-between-var-let-and-const-in-javascript-4ef3b4307fb3?source=collection_archive---------13-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3575c01edb9a6173f68946072ae7a73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*NXG9hpPzr1T2QtEBUL_fJw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Variable declaration keywords in JavaScript can seem like the Spider-Man meme.</figcaption></figure><h1 id="8455" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="cfa7" class="kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">JavaScript有着独特的历史，这导致了它令人困惑的特性和结构。</li><li id="c9ed" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">当考虑何时使用<code class="fe lt lu lv lw b">var</code>、<code class="fe lt lu lv lw b">let</code>或<code class="fe lt lu lv lw b">const</code>时，必须考虑范围、吊装、重新声明和其他环境因素。</li><li id="f3ad" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">我更喜欢用<code class="fe lt lu lv lw b">const</code>表示常量值，用<code class="fe lt lu lv lw b">let</code>表示其他值。</li></ul><h1 id="7ffb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">所有背景的程序员都觉得JavaScript令人困惑</h1><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lx"><img src="../Images/962e21bd6c4b10fc70b5cf16f6ead197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IYNJd1Vn8uDDP1vl"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Photo by <a class="ae mg" href="https://unsplash.com/@cdd20?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">愚木混株 cdd20</a> on <a class="ae mg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="18e2" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">在没有任何JavaScript知识的情况下，像声明变量这样简单的事情可能会令人困惑。或者至少这是我在为以前公司的另一个部门做内部咨询时发现的。我与一位经验丰富的专业人士共事，他的电子邮件签名是“首席顾问”，负责为外部客户设计完整的、全栈的、独立的解决方案，这些解决方案需要与我们现有的产品无缝集成。</p><p id="8d17" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">我们偶尔会打电话讨论项目的各个方面，我们经常通过电子邮件交流。然后有一天，我打开我的电子邮件客户端，看到了一封来自他的邮件。我喜欢在早上第一件事就解决他的问题，因为他住在东海岸，我想确保我没有妨碍他完成工作。我读了他的邮件，最终读到了这样一段话，“T5、<code class="fe lt lu lv lw b">const</code>和T7有什么不同？”一开始我有点吃惊，因为这样一个简单的问题，由一个经验可能是我两倍的工程师来问，实在令人震惊。</p><p id="56cc" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">后来我意识到这其实很有道理。JavaScript令人困惑，用三种不同的方式声明变量似乎有些过分(很可能是这样)。这种模式直到最近5年左右才随着<a class="ae mg" href="https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_%E2%80%93_ECMAScript_2015" rel="noopener ugc nofollow" target="_blank"> ES6 </a>成为主流，对于最近没有积极开发JavaScript的人来说，ES6的变化会使JavaScript看起来像是一种与之前版本完全不同的语言。JavaScript有着复杂的历史，所以要理解事情“为什么”是这样做的，理解我们是如何走到这一步的会很有帮助。</p><h1 id="93b3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">JavaScript简史</h1><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi my"><img src="../Images/7585b26be02d4f125a514df540be0f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KATF-waDHCbAgj3t"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Photo by <a class="ae mg" href="https://unsplash.com/@foxfox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Natalia Yakovleva</a> on <a class="ae mg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3552" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">早期的网络以一种只有在科幻电影中才有可能的方式将人们联系起来。也就是说，它是由缓慢加载的静态页面组成的，这些页面在今天是无法识别的。1993年，Mosaic网络浏览器诞生了，它允许用户在网页上浏览图片和文本(而不是在另一个窗口)。</p><p id="666f" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">马赛克的主要开发者创建了网景，它引入了非常受欢迎的网景导航器。他们开始致力于增加对脚本语言的支持，他们将脚本语言命名为JavaScript，以利用当时热门的编程语言Java的优势。</p><p id="693a" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">微软在1995年进入这一领域，推出了互联网浏览器，并有效地引发了“浏览器战争”两种网络浏览器都开始支持自己的脚本语言，为最终用户提供更丰富、更动态的网络浏览体验。</p><p id="5a4f" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">拥有两种主要浏览器和两种独立的脚本语言意味着网页通常只能在一种浏览器或另一种浏览器中完全运行。这种碎片化导致了1997年的ECMAScript标准化。随着互联网的爆炸式增长，ECMAScript(即JavaScript)成为事实上的浏览器语言，并变得令人难以置信的流行。</p><blockquote class="mz"><p id="d09d" class="na nb iq bd nc nd ne nf ng nh ni lj dk translated">由于其复杂的历史和不断的演变，JavaScript仍然是最受欢迎但令人困惑的编程语言之一</p></blockquote><p id="07aa" class="pw-post-body-paragraph mh mi iq ky b kz nj mk ml lb nk mn mo ld nl mq mr lf nm mt mu lh nn mw mx lj ij bi translated">作为一种灵活的脚本语言，同时又出生在Java的阴影下，这使得JavaScript成为一种独特的令人困惑的语言。JavaScript是弱的动态类型，但是您可以使用JavaScript的TypeScript超集来添加严格的类型。您可以在同一应用程序中轻松使用<a class="ae mg" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程(OOP) </a>和<a class="ae mg" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">功能编程</a>范例。由于其复杂的历史和不断的演变，JavaScript仍然是一种更受欢迎但令人困惑的编程语言。</p><h1 id="e3ba" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><code class="fe lt lu lv lw b">var</code>关键字</h1><p id="48aa" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated"><code class="fe lt lu lv lw b">var</code>关键字是三个关键字中最古老的，因此，可以认为有点过时。它有一些奇怪的行为，在没有适当的知识或开发环境配置的情况下会产生错误。</p><h2 id="15a2" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">范围</h2><p id="4148" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated">使用<code class="fe lt lu lv lw b">var</code>关键字声明的变量是函数作用域，除非在函数外声明，否则它是全局作用域。请看下图，了解功能范围。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/f30c61e2fc947f7c6a6d2c71e3b26efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQO36w-jGgW9gqCHwZg6JA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">var declarations are scoped to their immediate containing function</figcaption></figure><p id="6132" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">上面的<code class="fe lt lu lv lw b">var</code>变量的作用域是<code class="fe lt lu lv lw b">foo</code>函数，因此，它对其周围的全局作用域是不“可见”的。</p><h2 id="7918" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">提升</h2><p id="c199" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated"><code class="fe lt lu lv lw b">var</code>申报被悬挂，最初<code class="fe lt lu lv lw b">undefined</code>后最终被分配。JavaScript解释器将提升函数、变量和类的声明，并将它们初始化为<code class="fe lt lu lv lw b">undefined</code>(有一些例外——继续阅读)。因此，我们可以运行下面的代码而不会抛出异常。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/16126b94ff5d00da1ea14d0790c0c63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-1qLQTbvVMh7gkkjmfIbw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">var declarations are hoisted and initialized to undefined</figcaption></figure><p id="9f8f" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">这可能有点令人困惑，所以让我们解释一下JavaScript解释器实际上在做什么。在执行您的JavaScript代码之前，解释器将扫描并创建您的声明的映射，以优化代码执行。对于所有这些声明，解释器都不会分配正确的值，因为这需要执行代码。相反，它创建映射，将所有这些声明分配给<code class="fe lt lu lv lw b">undefined</code>(同样，有一些例外)。让我们用代码来说明这个概念:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/d0b8b5c19d54c9152b02f79e2c52557e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPQwO6AUEpu-Lg6rD_Cx7Q.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">var declarations hoisting can be visualized as undefined, initially</figcaption></figure><h2 id="56be" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">申报</h2><p id="388f" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated"><code class="fe lt lu lv lw b">var</code>申报可以重新申报。这是一个微妙但非常危险的概念，不应该被忽略，因为这个特性允许您在代码中引入命名冲突。看看下面的例子:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/2cf4123f3877b1ac427af6e561cbef4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgzeMp8gBZzdza58DN0Bjw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">An example of a naming collision using the var keyword</figcaption></figure><p id="5bba" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">这是一个微不足道的例子，但是您可以想象在一个更大的代码库中意外地重新声明一个变量是多么容易。现代开发环境将允许您配置一个“linter ”,在您可能不小心重新分配了一个现有变量时向您发出警告。</p><h1 id="3f88" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">字母关键字</h1><p id="7f77" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated">关键字<code class="fe lt lu lv lw b">let</code>是在ES6中引入的，随着这个最新的ECMAScript标准被广泛采用，<code class="fe lt lu lv lw b">let</code>开始取代<code class="fe lt lu lv lw b">var</code>成为声明变量的首选关键字。有一些主要的不同使得<code class="fe lt lu lv lw b">let</code>比<code class="fe lt lu lv lw b">var</code>稍微宽松一点，因此“更安全”。</p><h2 id="2503" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">范围</h2><p id="a001" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated"><code class="fe lt lu lv lw b">let</code>是块范围的，也就是说，它的范围是最近的包含块。因此，<code class="fe lt lu lv lw b">let</code>声明不是像<code class="fe lt lu lv lw b">var </code>声明那样只作用于包含函数块，而是作用于所有变体的第一个包含块。JavaScript中的block语句是一对有效的“花括号”(即<code class="fe lt lu lv lw b">{</code>和<code class="fe lt lu lv lw b">}</code>)之间的任何代码。因此，这包括<code class="fe lt lu lv lw b">if</code>语句、<code class="fe lt lu lv lw b">for</code>和<code class="fe lt lu lv lw b">while</code>循环、<code class="fe lt lu lv lw b">function</code>声明，甚至是其他用例中的一组独立的花括号。让我们来说明我在这里所说的:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/42f1ca0af1caa8baf76ea8b2ba6f0679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L7bpj-8upItCWt-kGLDmfw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">let declarations are block-scoped</figcaption></figure><h2 id="373c" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">提升</h2><p id="b4fa" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated">虽然所有的声明都是提升的，<code class="fe lt lu lv lw b">let</code>声明的行为与前面描述的<code class="fe lt lu lv lw b">var</code>关键字的提升略有不同。即使<code class="fe lt lu lv lw b">let</code>声明被提升，它们也不会像被提升的<code class="fe lt lu lv lw b">var</code>声明一样被初始化为<code class="fe lt lu lv lw b">undefined</code>。这意味着你不能引用一个在初始化之前使用<code class="fe lt lu lv lw b">let</code>关键字声明的变量。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/aeb43e82c547297f9e37796fd7736443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuUjvF1jiA2QXIKHv2B6gw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">let declarations are hoisted but not initialized to undefined</figcaption></figure><p id="27d4" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">这个场景展示了一个被称为“<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz" rel="noopener ugc nofollow" target="_blank">时间死区(TDZ) </a>的奇怪现象这是一个时间问题，因为它与时间有关。由于变量在运行时直到第一次赋值时才被初始化，如果您试图过早地引用它，将会抛出一个错误。</p><h2 id="8fc0" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">申报</h2><p id="ee57" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated">关键字<code class="fe lt lu lv lw b">let</code>不如<code class="fe lt lu lv lw b">var</code>宽松的另一个原因是它不能被重声明。总的来说，重新声明是JavaScript的一个奇怪的特性，将它从关键字<code class="fe lt lu lv lw b">let</code>中设计出来是一个重大的胜利。这里有一个例子来说明我所说的。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/83a5239b7cf3f6e2f93b108aef08a777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7iNFggESOAKCD7EYW9QmA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Redeclarations of let variables are not allowed</figcaption></figure><p id="f87c" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">需要明确的是，重新声明和重新分配是两回事。您肯定可以像通常预期的那样重新分配<code class="fe lt lu lv lw b">let</code>变量。如果不能变化，它们就不是很好的变量。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/3aa2b103a63ab30b65a26fd2fbdf22c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9Cn3ACVDqL3UeOtUI3GVg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">You can still reassign let variables</figcaption></figure><h1 id="54e5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">const关键字</h1><p id="ea29" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated"><code class="fe lt lu lv lw b">const</code>关键字是声明变量的另一种方式。顾名思义，<code class="fe lt lu lv lw b">const</code>声明可以有效地称为“常量”我们来分解一下他们的行为。</p><h2 id="2e35" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">范围</h2><p id="67d8" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated">与关键字<code class="fe lt lu lv lw b">let</code>非常相似，<code class="fe lt lu lv lw b">const</code>声明是块范围的。</p><h2 id="ae38" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">提升</h2><p id="aca7" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated"><code class="fe lt lu lv lw b">const</code>关键字的提升方式与<code class="fe lt lu lv lw b">let </code>关键字完全相同。它已被提升但未初始化，因此将会遇到相同的临时死区问题。</p><h2 id="19dd" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">申报</h2><p id="0092" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated">一旦你已经声明了一个<code class="fe lt lu lv lw b">const</code>声明，你就不能重新声明它。同样，这与<code class="fe lt lu lv lw b">let</code>声明的行为完全相同。然而，因为<code class="fe lt lu lv lw b">let</code>和<code class="fe lt lu lv lw b">const</code>是块范围的，所以有时看起来它们被重新声明了，而实际上它们不是。看一下这个例子:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/08bcdb149e9c99b9e7eb8fb4fc744105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1iJmVKQfY38GUBhwzgQMA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Block scoping can create the illusion of redeclaration</figcaption></figure><p id="7d6c" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">您会注意到我们声明并赋值了两次<code class="fe lt lu lv lw b">foo</code>常量，但是代码的执行不会抛出异常。同样，这是因为<code class="fe lt lu lv lw b">const</code>声明的块范围性质。</p><h2 id="2578" class="nr jz iq bd ka ns nt dn ke nu nv dp ki ld nw nx km lf ny nz kq lh oa ob ku oc bi translated">分配</h2><p id="250e" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated"><code class="fe lt lu lv lw b">const</code>关键字的主要特点是它不能被重新分配。因此，您必须立即为该常数赋值，否则，该常数将保持未定义状态。下面可以看到一个明显的“漏洞”:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi od"><img src="../Images/8070da12b0ef8ddb1fc97c62bd921620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ba7ZuJQeFPYCVXMVItWEtA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">A “loophole” to change the value of a constant</figcaption></figure><p id="47bb" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">即使<code class="fe lt lu lv lw b">foo</code>是一个常量，上面的代码也不会产生异常。你能看出这是怎么回事吗？花点时间考虑一下。</p><p id="1cd4" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">虽然看起来我们违反了关键字<code class="fe lt lu lv lw b">const</code>的主要特性，但严格来说，我们实际上并没有重新分配<code class="fe lt lu lv lw b">foo</code>常量。这是因为我们使用了<code class="fe lt lu lv lw b">Object</code>数据结构。所以我们将<code class="fe lt lu lv lw b">foo</code>初始化为<code class="fe lt lu lv lw b">Object</code>实例，并且在过程的每一步，<code class="fe lt lu lv lw b">foo</code>总是引用同一个<code class="fe lt lu lv lw b">Object</code>实例。我们只是向该对象添加另一个属性，而不是重新分配<code class="fe lt lu lv lw b">foo</code>。</p><h1 id="eb89" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">何时使用它们</h1><p id="cfb3" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated">你应该使用你觉得舒服的任何东西，但是我喜欢只在需要的时候使用。如果您的值永远不需要重新分配，请使用<code class="fe lt lu lv lw b">const</code>，否则，请使用<code class="fe lt lu lv lw b">let</code>。我再也不用<code class="fe lt lu lv lw b">var</code> s了，因为它们太放纵了。如果我需要引用其作用域之外的变量，我只需将变量声明移动到一个更高的公共作用域。我也从来没有理由利用<code class="fe lt lu lv lw b">var</code>没有时间死区的优势，事实上，我认为这个属性更像是一个bug，而不是一个特性。</p><h1 id="d02c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="92b8" class="pw-post-body-paragraph mh mi iq ky b kz la mk ml lb lc mn mo ld no mq mr lf np mt mu lh nq mw mx lj ij bi translated">即使是有经验的开发人员有时也会发现JavaScript令人困惑。它不寻常的历史使它成为当今最受欢迎的语言之一，但也是最难掌握的语言之一。彻底理解<code class="fe lt lu lv lw b">var</code>、<code class="fe lt lu lv lw b">let</code>和<code class="fe lt lu lv lw b">const</code>是构建强大JavaScript基础的重要一步。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="b545" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated">如果你正在学习JavaScript基础知识以成为一名软件工程师，请查看我写的这篇关于我的编码训练营之旅的文章。</p><p id="8185" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated"><em class="ol">最初发表于</em><a class="ae mg" href="https://codingbootcampguides.com" rel="noopener ugc nofollow" target="_blank"><em class="ol">【https://codingbootcampguides.com】</em></a><em class="ol">。</em></p><p id="4f3c" class="pw-post-body-paragraph mh mi iq ky b kz mj mk ml lb mm mn mo ld mp mq mr lf ms mt mu lh mv mw mx lj ij bi translated"><em class="ol">更多内容看</em> <a class="ae mg" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ol">说白了。报名参加我们的</em> <a class="ae mg" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ol">免费周报</em> </strong> </a> <em class="ol">。关注我们关于</em><a class="ae mg" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ol">Twitter</em></strong></a><em class="ol">和</em><a class="ae mg" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ol">LinkedIn</em></strong></a><em class="ol">。加入我们的</em> <a class="ae mg" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ol">社区</em> </strong> </a> <em class="ol">。</em></strong></a></p></div></div>    
</body>
</html>