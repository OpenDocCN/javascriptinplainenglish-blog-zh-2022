<html>
<head>
<title>How to Work With Web Client Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Web客户端存储</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-better-way-to-work-with-web-client-storage-70387443b4cb?source=collection_archive---------15-----------------------#2022-06-22">https://javascript.plainenglish.io/a-better-way-to-work-with-web-client-storage-70387443b4cb?source=collection_archive---------15-----------------------#2022-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a0e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用web客户端存储的更好方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/af0cef0d9eae9a53f409240d3190ff6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gNdjy6fJ6tznFvK_"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@art_maltsev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Maltsev</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器配备了存储选项，可以帮助您管理客户端上的数据，以最大限度地减少对服务器的调用，甚至在您的应用程序中提供离线体验。有些应用程序甚至会先从服务器加载数据，然后不需要调用服务器就可以运行。</p><p id="90aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题不在于您是否需要处理客户端存储选项，而在于何时处理。然而，当你跳入这个世界时，一些问题出现了:</p><ul class=""><li id="edc4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">每个都有自己的API，有些很冗长；</li><li id="3088" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每一种都有其数据类型限制，这意味着不是所有的数据类型都可以存储；</li><li id="0c29" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">您可能需要使用不同的选项，因为并非所有的浏览器类型和版本都支持所有的存储选项；</li><li id="3346" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">您可能需要管理数据格式、验证和类型，以确保数据以一致的方式存储，从而防止应用程序级别的数据检查。</li><li id="a39d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">你很可能需要一个库来帮助你，但是找到一个能解决你所有或大部分问题的库可能是一项艰巨的任务。</li></ul><h2 id="5194" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">进入“客户端-网络-存储”包</h2><p id="662f" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">“<a class="ae kv" href="https://github.com/beforesemicolon/client-web-storage" rel="noopener ugc nofollow" target="_blank"> <em class="ne">客户端-网络-存储</em> </a>”是一个很有前途的解决方案，因为:</p><ul class=""><li id="a0b8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">它提供了一个简单的API来处理所有的客户端存储选项:<em class="ne"> IndexedDb、WebSQL、LocalStorage，以及in Memory</em>；</li><li id="361a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它自动回退到不同的选项，保证您的数据将被正确地存储在客户端；</li><li id="578a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">支持一长串数据类型:<code class="fe nf ng nh ni b">Date, Number, String, Boolean, Array, <strong class="ky ir">ArrayBuffer</strong>, <strong class="ky ir">Blob</strong>, Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array</code>；</li><li id="a1b5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它为你做基本的数据验证；</li><li id="1a7d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">提供模式支持，保证数据格式。它会自动为您创建具有默认值的字段；</li><li id="abeb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为您的服务器API通信提供挂钩，以便您只与数据存储进行交互，而所有API通信都在后台进行；</li><li id="fca2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它提供了一个难以置信的简单的API来做所有的事情；</li><li id="ca68" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">允许架构嵌套创建复杂的存储区；</li></ul><h2 id="11f8" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">它是如何工作的？</h2><p id="210b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">它允许您通过模式定义来定义具有特定数据格式的小文档。这是你告诉它数据是什么样子的，以及它应该如何进行验证的方式。让我展示给你看:</p><p id="5e4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我有一个TypeScript项目，所以我需要为我的数据定义类型:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="8e90" class="mg mh iq ni b gy nn no l np nq">interface User extends <strong class="ni ir">Schema.DefaultValue</strong> {<br/>    name: string;<br/>}<br/><br/>interface ToDo extends <strong class="ni ir">Schema.DefaultValue</strong> {<br/>    name: string;<br/>    description: string;<br/>    complete: boolean;<br/>    user: User;<br/>}</span></pre><p id="16d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面我定义了一个<code class="fe nf ng nh ni b">User</code>和一个<code class="fe nf ng nh ni b">ToDo</code>，它们扩展了定义字段<code class="fe nf ng nh ni b">id</code>、<code class="fe nf ng nh ni b">createdDate</code>和<code class="fe nf ng nh ni b">lastUpdatedDate</code>的<code class="fe nf ng nh ni b">Schema.DefaultValue</code>，这些字段是自动为您处理的重要数据字段。它将为您生成<code class="fe nf ng nh ni b">uuid</code>,并在您做出更改时更新<code class="fe nf ng nh ni b">lastUpdatedDate</code>字段。</p><h2 id="330b" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">定义模式</h2><p id="910f" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">由此我可以定义我的模式，我还可以向它添加类型:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="2497" class="mg mh iq ni b gy nn no l np nq">const <strong class="ni ir">userSchema</strong> = new <strong class="ni ir">Schema</strong>&lt;<strong class="ni ir">User</strong>&gt;("user", {<br/>   name: new <strong class="ni ir">SchemaValue</strong>(String, true),<br/>});</span><span id="53e1" class="mg mh iq ni b gy nr no l np nq">const <strong class="ni ir">todoShema</strong> = new <strong class="ni ir">Schema</strong>&lt;<strong class="ni ir">ToDo</strong>&gt;("todo", {<br/>   name: new <strong class="ni ir">SchemaValue</strong>(String, true),<br/>   description: new <strong class="ni ir">SchemaValue</strong>(String, false, "No Description"),<br/>   complete: new <strong class="ni ir">SchemaValue</strong>(Boolean),<br/>})</span></pre><p id="d346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面我定义了一个带有必填名称字段的用户模式:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="f12e" class="mg mh iq ni b gy nn no l np nq"><strong class="ni ir">new SchemaValue(type, isRequired, defaultValue)</strong></span></pre><p id="e9f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我定义了一个todo模式，其中还包含一个必需的name字段和一个可选的description字段，当没有提供值时，description字段将具有默认值<code class="fe nf ng nh ni b">No Description</code>，最后是一个boolean <code class="fe nf ng nh ni b">complete</code>字段，用于指示todo项是否已完成。</p><p id="aab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以用模式做的一件很酷的事情是自动生成一个带有默认值的基本数据对象:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="3c28" class="mg mh iq ni b gy nn no l np nq"><strong class="ni ir">const todo1 = todoShema.toValue();</strong></span><span id="f215" class="mg mh iq ni b gy nr no l np nq"><em class="ne">/* </em><strong class="ni ir">todo1</strong><em class="ne"><br/>{<br/>  id: "123e4567-e89b-12d3-a456-426614174000",<br/>  name: "",<br/>  description: "No Description",<br/>  complete: false,<br/>  createdDate: "January, 4th 2022",<br/>  lastUpdatedDate: "January, 4th 2022",<br/>}<br/> */</em></span></pre><p id="81f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将创建一个<code class="fe nf ng nh ni b">uuid</code>，为我在模式中定义的字段添加日期并使用默认值。</p><h2 id="9556" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">创建数据存储</h2><p id="3800" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">当你创建自己的商店时，奇迹就发生了。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="6de6" class="mg mh iq ni b gy nn no l np nq">const <strong class="ni ir">todoStore</strong> = new <strong class="ni ir">ClientStore</strong>&lt;ToDo&gt;("todos", <strong class="ni ir">todoSchema</strong>)</span></pre><p id="0e9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是创建接受所有默认值的商店的最简单形式。这意味着它处理版本控制、存储类型、回退、创建、优化等。</p><p id="5b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也可以选择提供我的配置，有4个选项:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="a465" class="mg mh iq ni b gy nn no l np nq">const <strong class="ni ir">todoStore</strong> = new <strong class="ni ir">ClientStore</strong>&lt;ToDo&gt;("todos", <strong class="ni ir">todoSchema</strong>, {<br/>    <strong class="ni ir">appName</strong>: "My Todo App",<br/>    <strong class="ni ir">version</strong>: 1, <em class="ne">// changes when configuration or schema changes</em><br/>    <strong class="ni ir">type</strong>: <strong class="ni ir">ClientStore.Type.LOCALSTORAGE</strong>,<br/>    <strong class="ni ir">description</strong>: "manages user todos"<br/>})</span></pre><p id="b177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面我正在创建我的todo存储的第一个版本，我将它定义为一个<code class="fe nf ng nh ni b">LOCALSTORAGE</code> <strong class="ky ir"> </strong>类型。</p><p id="1e99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还可以提供一个类型列表，作为它的备用类型:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="07c9" class="mg mh iq ni b gy nn no l np nq"><strong class="ni ir">type</strong>: [<br/>  <strong class="ni ir">ClientStore.Type.</strong>INDEXEDDB<strong class="ni ir">,<br/>  ClientStore.Type.</strong>LOCALSTORAGE<strong class="ni ir">,<br/>  ClientStore.Type.</strong>MEMORY_STORAGE<strong class="ni ir"><br/></strong>],</span></pre><p id="b3fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上意思是，根据浏览器支持从<code class="fe nf ng nh ni b">INDEXEDDB</code>到<code class="fe nf ng nh ni b">MEMORY_STORAGE</code>开始尝试这些存储选项。</p><p id="9a9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">商店为你做了很多。它将在加载时读取客户端存储(如果它们存在)，填充所有内容并准备好供您与之交互。该存储是100%异步的，这很有帮助。</p><h2 id="943e" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">弄脏商店</h2><p id="666a" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">创建一个项目非常简单。我不必提供所有的值。我可以只提供默认值，其余的是自动填充的:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="b6e8" class="mg mh iq ni b gy nn no l np nq">const <strong class="ni ir">todo1</strong> = await <strong class="ni ir">todoStore</strong>.<strong class="ni ir">createItem</strong>({<br/>    name: "Go Shopping", // name is required<br/>});<br/><br/><em class="ne">/* Will create item<br/>{<br/>  id: "123e4567-e89b-12d3-a456-426614174000",<br/>  name: "Go shopping",<br/>  description: "No Description",<br/>  complete: false,<br/>  createdDate: "January, 4th 2022",<br/>  lastUpdatedDate: "January, 4th 2022",<br/>}<br/> */</em></span></pre><p id="d93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还将根据我定义的类型和模式数据类型来验证数据。例如，执行以下操作将会失败:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="b7bd" class="mg mh iq ni b gy nn no l np nq"><strong class="ni ir">todoStore</strong>.<strong class="ni ir">createItem</strong>({});<br/><strong class="ni ir">todoStore</strong>.<strong class="ni ir">createItem</strong>({name: 12});<br/><strong class="ni ir">todoStore</strong>.<strong class="ni ir">createItem</strong>({<em class="ne">complete</em>: "yes"});</span></pre><p id="6d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它为我做类型检查和字段需求检查。它还尽可能地为我过滤和映射数据。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="629f" class="mg mh iq ni b gy nn no l np nq">const todo = fetchSingleTodo("984728374834");</span><span id="28b4" class="mg mh iq ni b gy nr no l np nq"><strong class="ni ir">todoStore</strong>.<strong class="ni ir">createItem</strong>(todo);</span></pre><p id="6ac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果从API返回的数据有更多或更少它需要的字段，它将总是只添加它需要的字段，当字段名在您提供的数据中不存在时，将返回默认值。</p><p id="0116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新商店是一个类似的过程:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="3c8c" class="mg mh iq ni b gy nn no l np nq">const <strong class="ni ir">todo1</strong> = await <strong class="ni ir">todoStore</strong>.<strong class="ni ir">createItem</strong>({<br/>    name: "Go Shopping",<br/>});</span><span id="e51b" class="mg mh iq ni b gy nr no l np nq">await <strong class="ni ir">todoStore</strong>.<strong class="ni ir">updateItem(todo1.id, {<br/>  complete: true<br/>})</strong></span></pre><p id="4d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，它只支持下面的CRUD和搜索<strong class="ky ir">异步</strong>动作:<code class="fe nf ng nh ni b">createItem, updateItem, getItem, getItems, loadItems, removeItem, clear, findItem, findItems</code>。</p><h2 id="ed7a" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">商店挂钩</h2><p id="441c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">有可能知道并拦截对商店所做的一切。</p><p id="fd3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以向商店订阅更新:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="56a3" class="mg mh iq ni b gy nn no l np nq">const <strong class="ni ir">unsub</strong> = <strong class="ni ir">todoStore</strong>.<strong class="ni ir">subscribe</strong>((eventType, details) =&gt; {<br/>    switch (eventType) {<br/>      case <strong class="ni ir">ClientStore.EventType.READY</strong>: <br/>        // handle event type here<br/>        break;<br/>      case <strong class="ni ir">ClientStore.EventType.CREATED</strong>: <br/>        // handle event type here<br/>        break;<br/>      case <strong class="ni ir">ClientStore.EventType.UPDATED</strong>: <br/>        // handle event type here<br/>        break;<br/>      case <strong class="ni ir">ClientStore.EventType.ABORTED</strong>: <br/>        // handle event type here<br/>        break;<br/>      case <strong class="ni ir">ClientStore.EventType.CLEARED</strong>: <br/>        // handle event type here<br/>        break;<br/>      case <strong class="ni ir">ClientStore.EventType.DELETED</strong>: <br/>        // handle event type here<br/>        break;<br/>      case <strong class="ni ir">ClientStore.EventType.ERROR</strong>: <br/>        // handle event type here<br/>        break;<br/>      default:<br/>    }<br/>})<br/><br/><strong class="ni ir">unsub()</strong> // call to unsubscribe from the store</span></pre><p id="8592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您提供的订阅处理程序是用事件类型和该操作类型产生的数据调用的。</p><p id="c057" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以在存储发生之前拦截操作，甚至中止它们，使它们不会发生。对于您的服务器API处理来说，这是一个完美的钩子。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="4f71" class="mg mh iq ni b gy nn no l np nq">const <strong class="ni ir">unsub</strong> = <strong class="ni ir">todoStore</strong>.<strong class="ni ir">beforeChange</strong>(async (eventType, data) =&gt; {<br/>    switch (eventType) {<br/>        case <strong class="ni ir">ClientStore.EventType.CREATED</strong>:<br/>            <em class="ne">await todoService.</em><strong class="ni ir"><em class="ne">createTodo</em></strong><em class="ne">(data);</em><br/>            break;<br/>        case <strong class="ni ir">ClientStore.EventType.UPDATED</strong>:<br/>            <em class="ne">await todoService.</em><strong class="ni ir"><em class="ne">updateTodo</em></strong><em class="ne">(data.id, data);</em><br/>            break;<br/>        case <strong class="ni ir">ClientStore.EventType.DELETED</strong>:<br/>            <em class="ne">await todoService.</em><strong class="ni ir"><em class="ne">updateTodo</em></strong><em class="ne">(data);</em><br/>            break;<br/>        case <strong class="ni ir">ClientStore.EventType.CLEARED</strong>:<br/>            <em class="ne">await todoService.</em><strong class="ni ir"><em class="ne">deleteAllByIds</em></strong><em class="ne">(data);</em><br/>            break;<br/>        default:<br/>    };<br/>    <br/>    <strong class="ni ir">return true;</strong><br/>});<br/><br/><strong class="ni ir">unsub</strong>();</span></pre><p id="45a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以返回true或false来决定是否更新存储，这将发送一个可以在订阅处理程序中捕获的<code class="fe nf ng nh ni b">ABORT</code>事件。</p><p id="2880" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以抛出错误或者让您的API失败，商店将捕获并广播一个<code class="fe nf ng nh ni b">ERROR</code>事件，您也可以在订阅处理程序中捕获该事件。</p><h2 id="3b8e" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">更复杂的数据</h2><p id="c296" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">该模式的一个优点是，您可以嵌套它们以形成复杂的存储。</p><p id="aa2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们可以将用户模式嵌套到todo模式中。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="0f92" class="mg mh iq ni b gy nn no l np nq">// Schema TS type<br/>interface <strong class="ni ir">User</strong> extends Schema.DefaultValue {<br/>    name: string;<br/>}<br/><br/>interface <strong class="ni ir">ToDo</strong> extends Schema.DefaultValue {<br/>    name: string;<br/>    description: string;<br/>    complete: boolean;<br/>    <strong class="ni ir">user: User;</strong><br/>}<br/><br/>// denife schemas<br/>const userSchema = new Schema&lt;User&gt;("user");<br/>const todoSchema = new Schema&lt;ToDo&gt;("todo");<br/><br/>userSchema.defineField("name", String, {required: true});<br/><br/>todoShema.defineField("name", String, {required: true});<br/>todoShema.defineField("description", String);<br/>todoShema.defineField("complete", Boolean);<br/><strong class="ni ir">todoShema.defineField("user", userSchema, {required: true});</strong><br/><br/>// create stores<br/>const userStore = new ClientStore&lt;User&gt;("users", userSchema);<br/>const todoStore = new ClientStore&lt;ToDo&gt;("todos", todoSchema);</span></pre><p id="8b98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么创建一个项目看起来应该是这样的:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="0163" class="mg mh iq ni b gy nn no l np nq">// you can create a new on or get it from the store<br/>const <strong class="ni ir">AdminUser</strong> = await userStore.createItem({<br/>    name: "John Doe"<br/>});<br/><br/>const todo1 = await todoStore.createItem({<br/>    name: "Go Shopping",<br/>    <strong class="ni ir">user: AdminUser</strong><br/>});<br/><br/><em class="ne">/* Will create item<br/>{<br/>  id: "123e4567-e89b-12d3-a456-426614174000",<br/>  name: "Go shopping",<br/>  description: "No Description",<br/>  complete: false,<br/>  </em><strong class="ni ir"><em class="ne">user: {<br/>    id: 3483748929e82382,<br/>    name: "John Doe",<br/>    createdDate: "January, 4th 2022",<br/>    lastUpdatedDate: "January, 4th 2022",<br/>  } </em></strong><em class="ne"><br/>  createdDate: "January, 4th 2022",<br/>  lastUpdatedDate: "January, 4th 2022",<br/>}<br/> */</em></span></pre><p id="e636" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储将根据架构定义对数据进行深度评估，因此以下操作将失败:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="9389" class="mg mh iq ni b gy nn no l np nq"><em class="ne">// missing </em><strong class="ni ir"><em class="ne">required</em></strong><em class="ne"> user</em><br/><strong class="ni ir">await todoStore.createItem({name: "Buy shoes"});</strong></span><span id="5f23" class="mg mh iq ni b gy nr no l np nq"><em class="ne">// missing </em><strong class="ni ir"><em class="ne">required</em></strong><em class="ne"> user name<br/></em><strong class="ni ir">await todoStore.createItem({name: "Buy shoes", user: {}});</strong></span></pre><h2 id="5097" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">减去</h2><p id="b251" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这个解决方案省去了您在客户端处理数据的所有麻烦。它用相同的API接口处理许多存储选项，这是一个巨大的优势。在数据之上，它支持从简单到复杂的数据类型、数据格式，并通过惊人的挂钩进行验证，以真正做到最好。</p><p id="c42d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/beforesemicolon/client-web-storage" rel="noopener ugc nofollow" target="_blank">看看吧</a>，在评论中告诉我你的想法:</p><div class="ns nt gp gr nu nv"><a href="https://github.com/beforesemicolon/client-web-storage" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">GitHub-before分号/client-we B- storage:indexed db、WebSQL的浏览器存储接口…</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">用于IndexedDB、WebSQL、LocalStorage的浏览器存储接口，以及带有模式和数据验证器的内存数据。…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/79122679204c8ac0aa65ca22857737ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kKfpitAbaRbqRAXx0-YqTw.gif"/></div></div></figure><p id="bf8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> YouTube频道</strong> : <a class="ae kv" href="https://www.youtube.com/channel/UCrU33aw1k9BqTIq2yKXrmBw" rel="noopener ugc nofollow" target="_blank">分号前</a> <br/> <strong class="ky ir">网站</strong>:<a class="ae kv" href="https://beforesemicolon.com/" rel="noopener ugc nofollow" target="_blank">beforesemicolon.com</a></p></div></div>    
</body>
</html>