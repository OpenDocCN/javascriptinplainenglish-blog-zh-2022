<html>
<head>
<title>Why is the React Official Website So Fast?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React官网为什么这么快？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-is-the-react-official-website-so-fast-bf90a2168e62?source=collection_archive---------3-----------------------#2022-08-22">https://javascript.plainenglish.io/why-is-the-react-official-website-so-fast-bf90a2168e62?source=collection_archive---------3-----------------------#2022-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a90e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们来看看React官网上有哪些优化工具。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dade787563b01ff2980ae4e4a39f309f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wSgwl4CfFPAILScH"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@bencehalmosi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bence Halmosi</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="783f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们打开React网站时，发现从在浏览器上输入网址到显示页面首屏所用的时间非常短，点击页面中的链接切换路线的操作非常流畅。</p><p id="3190" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">页面很容易达到“秒切”的效果，没有延迟和等待。所以，带着“React网站到底是做什么的？”铭记，这个探索开始了，发现主要使用了以下优化手段。</p><h2 id="0423" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">SSG</h2><p id="9100" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">以下是React官方文档主页截图。你会注意到下面的红色区域，这将在后面用作推理的理由。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/276a7ad48eea422b93553672bfbf244c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzY6RqmHvVUpGUTVoA1WtQ.png"/></div></div></figure><p id="341f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们打开控制台，点击network，选择DOC document request，我们会发现一个GET请求，请求路径为<a class="ae kv" href="https://zh-hans.reactjs.org/," rel="noopener ugc nofollow" target="_blank">https://reactjs.org/,</a>，响应结果是一个HTML文档，在这个文档中我们正好可以找到上图中红色区域的文本对应的文本。这也证实了对应的HTML文档就是React官方主页，页面的渲染方式只有两种:一种是服务器端渲染SSR，另一种是静态站点生成SSG——这和React官网上使用的技术是一样的，和SSR一样的是对应的服务器端也是直接将合并后的HTML文档返回给客户端，所以客户端仍然不需要下载JavaScript文件来渲染整个页面。</p><p id="a4b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对这两种渲染方式不是很清楚，可以看<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/front-end-csr-ssr-ssg-can-you-really-tell-the-difference-8ddedc9c05d6">本文末尾的另一篇文章</a>专门介绍三种前端渲染方式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/f2e2657f635ea009380f7fcad62b2b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehk64W6EFDvM3e8mgZPL2g.png"/></div></div></figure><h2 id="cd8d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">问题已回答:现在我们可以回答为什么React网站使用SSG技术来做到这一点</h2><p id="0857" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">因为与客户端渲染相反，服务器端渲染和静态点生成是浏览器请求URL后带有数据的HTML文本，而不是空的HTML外壳。浏览器只需要解析HTML并直接构建DOM树。而客户端渲染则需要先获取一个空的HTML页面，这个时候页面已经进入白屏，之后需要经历加载执行JavaScript、请求后端服务器获取数据、JavaScript渲染页面几个过程才能看到最终页面。尤其是在复杂的应用中，由于需要加载JavaScript脚本，所以应用越复杂，需要加载的JavaScript脚本越多，越大，导致应用首屏加载时间非常长，降低了体验。</p><p id="7e38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于SSR和SSG的选择，还得从应用场景说起——用户是在服务器端为每个请求重新组装一个HTML文档，还是在项目构建时生成一个唯一的HTML文档？</p><p id="aadd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React团队成员在开发官网的时候一定也想到了这个问题。既然是官网，权限肯定没有区别，所有进入网站的人看到的内容应该都是一样的，那么对于每个请求，在服务器端组装一模一样的HTML有什么意义呢？为什么不在服务器端提前渲染并发送给大家，让N次渲染变成1次渲染，大大减少客户端和服务器的通信时间，从而提高用户体验？</p><h2 id="dc06" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">预加载/预处理资源的一些方法</h2><p id="f316" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">研究完首屏渲染，再来看路由跳转后的内容切换。经常阅读React文档的人可能已经注意到，路由跳转非常平滑，感觉就像一个静态页面，没有发送网络请求的痕迹。举个例子，我在钩子介绍部分，当我点击钩子规则目录时。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/143408199612209a030a23955aea9e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prCnd8XEOmTRHwg7JSWXXQ.png"/></div></div></figure><p id="10e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发现页面瞬间秒切，内容立刻显示，没有一点滞后，用户体验直接提升。这最后是怎么做到的？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/884cfe5db8aeb5a0bd8711593bcb7abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBao-EEsys23977WjYjZ9A.png"/></div></div></figure><p id="1ab5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一点一点地分析它的每个优化工具:</p><h2 id="1bc9" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">事先装好</h2><blockquote class="ms mt mu"><p id="6a09" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">&lt;link&gt;</code>元素的<code class="fe mz na nb nc b">rel</code>属性的<code class="fe mz na nb nc b">preload</code>值允许您在HTML的<code class="fe mz na nb nc b">&lt;head&gt;</code>中声明获取请求，指定您的页面将很快需要的资源，您希望在页面生命周期的早期，在浏览器的主要呈现机制启动之前开始加载这些资源。这确保它们更早可用，并且不太可能阻塞页面的呈现，从而提高性能。尽管名称中包含术语<em class="iq"> load </em>，但它并不加载和执行脚本，而只是调度它以更高的优先级下载和缓存。点击<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多信息。</p></blockquote><p id="e826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键字preload是元素<link/>的属性rel的值，表示用户很可能需要在当前浏览器中加载目标资源，因此浏览器必须预取并缓存相应的资源。这样做的好处是允许在当前页面上可以访问的资源被更早地加载，而不会阻塞页面的初始呈现，从而提高性能。</p><p id="9304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是React文档中preload关键字的用法，它告诉浏览器它可能需要资源等。，并希望尽快下载。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/3d126f7b8ccb97048c885500fc41a402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omUVwjuBLxYfgc0tEX26kA.png"/></div></div></figure><p id="3caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以预加载的资源有很多。现在浏览器支持的主要有</p><ul class=""><li id="2572" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">音频:音频文件，通常用于音频标签。</li><li id="f090" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">文档:HTML文档旨在通过框架或</li><li id="4539" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">嵌入:嵌入元素中要嵌入的资源</li><li id="2615" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">fetch:通过fetch或XHR请求访问的资源，例如</li><li id="648c" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">ArrayBuffer或JSON文件。</li><li id="ed88" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">字体:字体文件</li><li id="c789" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">图像:图像文件</li><li id="c04e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">object:要嵌入到object元素中的资源</li><li id="d78c" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">脚本:JavaScript文件</li><li id="2015" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">样式:CSS样式表</li><li id="dfb6" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">轨道:WebVTT文件</li><li id="d5b1" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">worker:JavaScript web worker或共享worker</li><li id="af20" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">视频:视频文件通常用在视频标签中。</li></ul><h2 id="3373" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">预连接</h2><blockquote class="ms mt mu"><p id="86db" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><code class="fe mz na nb nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" rel="noopener ugc nofollow" target="_blank">&lt;link&gt;</a></code>元素的<code class="fe mz na nb nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel" rel="noopener ugc nofollow" target="_blank">rel</a></code>属性的<code class="fe mz na nb nc b">preconnect</code>关键字是对浏览器的一个提示，用户可能需要来自目标资源源的资源，因此浏览器可以通过抢先启动到该源的连接来改善用户体验。点击<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preconnect" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多信息。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/b9e2f21b5fa560acd6cc33ec9cb115dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhUwAEdJ5SElRNmQR98sjg.png"/></div></div></figure><p id="e511" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说，你可以提前告诉浏览器，你可能会在后面的JS代码中请求这个域下的相应资源，这样你就可以先行一步，建立好网络连接，然后发送相应的请求会更快。</p><h2 id="8a48" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">dns预取</h2><blockquote class="ms mt mu"><p id="e291" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><code class="fe mz na nb nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" rel="noopener ugc nofollow" target="_blank">&lt;link&gt;</a></code>元素的<code class="fe mz na nb nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel" rel="noopener ugc nofollow" target="_blank">rel</a></code>属性的<code class="fe mz na nb nc b">dns-prefetch</code>关键字是对浏览器的一个暗示，即用户可能需要来自目标资源来源的资源，因此浏览器可能通过抢先执行该来源的DNS解析来改善用户体验。点击<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/dns-prefetch" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多信息。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/d773198f815cd04db6432bd96ef98ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrVcV2Q_-EeIDT52Rzvc9g.png"/></div></div></figure><p id="c114" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们为什么需要做域名预解析呢？这里实际上涉及到一些网络请求的东西，下面简要描述一下。</p><p id="9138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当浏览器向(第三方)服务器请求资源时，必须首先将跨域域名解析为IP地址，然后浏览器才能发出请求。这个过程称为DNS解析。DNS缓存有助于减少这种延迟，而DNS解析会导致请求显著增加延迟。对于连接到许多开放的第三方的站点，这种延迟会显著降低加载性能。预先解析域名旨在减少实际发出请求时的延迟，从而在一定程度上提高性能。</p><p id="32ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通俗地说，dns-prefetch的作用就是告诉浏览器在向第三方服务器发送请求之前先做指定域名的解析，而这种优化方法通常是和上面的preconnect一起使用的，都是一些性能优化的手段，我们也可以在自己的项目中适当的使用。</p><h2 id="e005" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">预取</h2><blockquote class="ms mt mu"><p id="8207" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">预取是指在后台下载内容，这是基于内容可能会被请求的假设，如果用户请求内容，就可以立即加载内容。该内容被下载并缓存以供预期的未来使用，而无需用户对其做出明确的请求。点击<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Prefetch" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多。</p></blockquote><p id="5d4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到React文档大量使用预取来优化项目</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/6804e8376728ef0a1ef1e7ffd33ef9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s22z1_QETzKeN15UladWmw.png"/></div></div></figure><p id="e302" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们什么时候使用预取比较合适呢？</p><p id="3d21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像React文档中一样，当您的页面有可能跳转到其他页面的路由链接时，您可以使用prefetch来预先请求相应页面的资源。但是如果一个页面上有很多这样的路由链接呢？那会发送很多网络请求，即使现在流量很便宜，你也不能那样玩！(Doge)</p><p id="5e7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React当然考虑到了这一点，但是由于其文档中包含了大量的路由链接，不可能发送所有的请求，不利于性能优化，那么React是如何做到的呢？</p><p id="717b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过监听link元素，并在HTML文档出现在可视区域时动态插入一个带有预取属性值的Link标签，从而预加载相应路由页面的一些资源，这样当用户点击路由链接跳转时，页面会因为资源已经被请求而加载得特别快。</p><p id="c9d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如不点击红线目录时，页面上没有对应的标签，因为其子目录没有暴露在查看窗口中；但是当目录被点击时，它的子目录会显示在视图窗口中，React会通过预取自动请求预先暴露的路由对应的数据，这样当用户点击一个子目录时，由于已经有了对应的数据，就可以直接取出内容进行显示。我们能感觉到用这种方法速度不是更快吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/132b3bc87a1e9cd63cb4ae8f28e342a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8l0PeJ00iUpIaCnNdNxQsw.png"/></div></div></figure><h2 id="4c04" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">补充的</h2><p id="dbf0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir">React网站其实并不完全是React框架开发的，上面提到的性能优化之所以能做到，多亏了Gatsby库。</strong></p><blockquote class="ms mt mu"><p id="9be7" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">Gatsby是一个基于React的免费开源框架，帮助开发人员构建速度极快的网站和应用程序。它将动态呈现站点的控制和可伸缩性与静态站点生成的速度结合起来，创造了一个全新的可能性网络。</p></blockquote><p id="ecd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它在打包的时候会生成页面对应的所有HTML文件和数据文件，这样当你访问一个页面的时候，服务器可以直接返回HTML。另一方面，当有页面使用Link时，会提前加载这个页面对应的数据，这样在点击跳转后页面加载速度会非常快。所以实现上述优化需要盖茨比。感兴趣的朋友可以去它的官网详细了解一下。</p><p id="e775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">至于监听链接元素是如何实现的？</strong></p><p id="9b3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是使用交叉点观察器实现的。</p><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/front-end-csr-ssr-ssg-can-you-really-tell-the-difference-8ddedc9c05d6"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">前端CSR、SSR、SSG——你真的能区分它们吗？</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">许多人无法区分客户端渲染(CSR)、服务器端渲染(SSR)和静态站点…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="55f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv">欢迎关注我上</em></strong><a class="ae kv" href="https://twitter.com/yanghui0324" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mv">Twitter</em></strong></a><strong class="ky ir"><em class="mv"/></strong><a class="ae kv" href="https://www.linkedin.com/in/hui-yang-075076245/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mv">LinkedIn</em></strong></a><strong class="ky ir"><em class="mv">，以及</em></strong><a class="ae kv" href="https://github.com/guchen-yh" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mv">GitHub</em></strong></a><strong class="ky ir"><em class="mv">！</em> </strong></p><p id="bb40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写作一直是我的激情所在，它给了我帮助和激励他人的快乐。如果您有任何问题，请随时联系我们！T41】</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="58c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mv">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mv">plain English . io</em></strong></a><em class="mv">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mv">免费周报</em> </strong> </a> <em class="mv">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mv">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mv">LinkedIn</em></strong></a><em class="mv"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mv">YouTube</em></strong></a><em class="mv"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mv">不和</em> </strong> </a> <em class="mv">。</em></p></div></div>    
</body>
</html>