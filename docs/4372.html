<html>
<head>
<title>How To Set Up a GraphQL Server With Node.js &amp; Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js &amp; Express设置GraphQL服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-set-up-a-graphql-server-with-node-js-express-8638a068b609?source=collection_archive---------8-----------------------#2022-11-25">https://javascript.plainenglish.io/how-to-set-up-a-graphql-server-with-node-js-express-8638a068b609?source=collection_archive---------8-----------------------#2022-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d5335b4135b7fe4f17c28186ff3eebba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjVr87nTkybfJLmZM8QFfg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://codersociety.com/blog/articles/graphql-reasons" rel="noopener ugc nofollow" target="_blank">https://codersociety.com/blog/articles/graphql-reasons</a></figcaption></figure><p id="7ec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将浏览一下使用<strong class="kf ir">node . js</strong>&amp;<strong class="kf ir">Express</strong>设置<strong class="kf ir"> GraphQL </strong>服务器的整个过程。我们将使用<strong class="kf ir"> Express的</strong>中间件库<strong class="kf ir"> express-graphql </strong>来帮助我们完成这个过程。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="e4b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="li">本文原载</em> <a class="ae kc" href="https://upmostly.com/web-development/how-to-set-up-a-graphql-server-with-node-js" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="li">此处</em> </strong> </a> <em class="li">。</em></p><h1 id="f85c" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">介绍</h1><p id="e669" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">如果您还不熟悉<strong class="kf ir"> GraphQL </strong>以及我们使用它的目的，请务必查看<a class="ae kc" href="https://medium.com/javascript-in-plain-english/why-you-should-be-using-graphql-if-you-arent-already-7f5deb4333a8" rel="noopener"> <strong class="kf ir">这篇文章</strong> </a>，其中我们深入讨论了什么是<strong class="kf ir"> GraphQL </strong>以及为什么我们应该在我们的应用程序中使用它。</p><p id="6cb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经熟悉了它，你可能想看看文章<a class="ae kc" href="http://upmostly.com/tutorials/how-to-setup-graphql-in-react" rel="noopener ugc nofollow" target="_blank">中的</a>，在那里我们用<strong class="kf ir"> React </strong>实现<strong class="kf ir"> Apollo客户端</strong>来连接到我们现在要创建的服务器。</p><blockquote class="mm mn mo"><p id="d6d0" class="kd ke li kf b kg kh ki kj kk kl km kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated"><strong class="kf ir"> <em class="iq">包含本文中介绍的代码的库可以在这里</em> </strong>  <strong class="kf ir"> <em class="iq">找到</em> </strong> <a class="ae kc" href="https://github.com/upmostly/nodejs-graphql-server" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="iq">。</em>T50】</strong></a></p><p id="1bd5" class="kd ke li kf b kg kh ki kj kk kl km kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated"><strong class="kf ir"> <em class="iq">还会有一个包含使用该服务器的前端的存储库；这里可以找到</em></strong><a class="ae kc" href="https://github.com/upmostly/react-apollo-integration" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="iq"/></strong></a><strong class="kf ir"><em class="iq">。</em> </strong></p></blockquote><p id="6605" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，事不宜迟，我们开始吧！</p><h1 id="d3ec" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">GraphQL服务器配置设置</h1><p id="13ed" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">首先，我们可能想先创建一个新目录，通过<code class="fe ms mt mu mv b">npm init</code>命令设置npm，然后创建我们的<strong class="kf ir"> <em class="li"> server.js </em> </strong>文件，它将托管我们的<strong class="kf ir"> GraphQL </strong>服务器。</p><p id="b1cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们做好了准备，我们就要安装下面的库:</p><ul class=""><li id="a786" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe ms mt mu mv b"><strong class="kf ir"><em class="li">express</em></strong></code></li><li id="6be2" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe ms mt mu mv b"><strong class="kf ir"><em class="li">express-graphql</em></strong></code></li><li id="7025" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe ms mt mu mv b"><strong class="kf ir"><em class="li">graphql</em></strong></code></li><li id="8d2c" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe ms mt mu mv b"><strong class="kf ir"><em class="li">cors</em></strong></code></li></ul><p id="17ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mv b">server.js</code>文件应该是这样的:</p><pre class="nk nl nm nn gt no mv np bn nq nr bi"><span id="c20d" class="ns lk iq mv b be nt nu l nv nw">const app = require("express")();<br/>const cors = require('cors');<br/>const { graphqlHTTP } = require("express-graphql");<br/>const { buildSchema } = require("graphql");<br/><br/>const schema = buildSchema('');<br/>const root = {};<br/><br/>app.use(cors());<br/><br/>app.use(<br/>  "/graphql",<br/>  graphqlHTTP({<br/>    schema,<br/>    rootValue: root,<br/>    graphiql: true,<br/>  })<br/>);<br/><br/>app.listen(8080, () =&gt; {<br/>  console.log('GraphQL server running on port 8080');<br/>});</span></pre><p id="3671" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一下配置过程的每一步，以便更好地了解实际发生了什么:</p><ul class=""><li id="71ab" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">首先，导入<code class="fe ms mt mu mv b">express</code>库并调用它导出的主函数，这样我们就可以在<code class="fe ms mt mu mv b">app</code>变量中设置我们的应用服务器</li><li id="83d9" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">导入<code class="fe ms mt mu mv b">cors</code>库的main函数来帮助我们解决在不同的域上运行服务器的问题(本地主机有不同的端口)</li><li id="6795" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">从<code class="fe ms mt mu mv b">express-graphql</code>库中导入<code class="fe ms mt mu mv b">graphqlHTTP</code>方法来帮助我们设置GraphQL模式</li><li id="a3ff" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">从<code class="fe ms mt mu mv b">graphql</code>库中导入<code class="fe ms mt mu mv b">buildSchema</code>方法来定义数据模式(我们允许客户端访问哪些数据)</li><li id="a793" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">现在定义一个空的数据模式</li><li id="9def" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">现在定义一个空的根，但是它将用于定义我们的<strong class="kf ir"> <em class="li">解析器</em> </strong>或者我们选择如何处理发送给客户端的数据。</li><li id="e411" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">没有附加配置的设置<strong class="kf ir"> CORS </strong></li><li id="16d6" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">定义我们将用于<strong class="kf ir"> "/graphql" </strong>端点的配置，它将使用我们之前定义的模式、根解析器对象以及我们将用于测试和以可视方式与我们的数据交互的运动场。</li></ul><p id="b638" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要启动服务器，您需要做的就是执行<code class="fe ms mt mu mv b">node server.js </code>命令。</p><p id="2c1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您可以在浏览器中查看“<strong class="kf ir">localhost:8080</strong>”URL，在那里您会看到<a class="ae kc" href="https://www.npmjs.com/package/graphiql" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">GraphiQL</strong></a>playground running，这是一种与您的数据/模式进行交互的<strong class="kf ir">可视化方式。</strong></p><p id="1a9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该是这样的:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/3330324316395974932a38f803b2fd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dcw2XCEo5VXIRnOz.png"/></div></div></figure><h1 id="2901" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">定义模式</h1><p id="9feb" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">现在我们已经设置好了<strong class="kf ir"> GraphQL </strong>，让我们看看如何用一些数据填充我们的<strong class="kf ir"> GraphQL模式</strong>。</p><p id="a42a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，我们将使用一些更基本的模型，并定义这些模型之间的基本关系。</p><p id="b97e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将有一个<code class="fe ms mt mu mv b">Author</code>模型和一个<code class="fe ms mt mu mv b">Book</code>模型，模式如下:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c17e3605662b167c4223c73b6d1240bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/0*5DwUXY_jQTSZu4UQ.png"/></div></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1bd7c8cb1a51f4bc7d357b7998d34caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/0*pghrqnIj00jNS4Sp.png"/></div></figure><p id="3db8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您从所附图片中看到的，我们将有两个基本模型，分别有三个、四个字段，其中我们还定义了一个<strong class="kf ir">一对多关系(一个作者可能有许多本书)</strong>。</p><p id="b70b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着一个作者可以写很多本书，而一本书只能有一个作者。</p><p id="f0ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们如何在代码中定义这些模型模式:</p><pre class="nk nl nm nn gt no mv np bn nq nr bi"><span id="4fe3" class="ns lk iq mv b be nt nu l nv nw">const schema = buildSchema(<br/>  `<br/>    type Query {<br/>      authors: [Author]<br/>      books: [Book] <br/>    }<br/><br/>    type Author {<br/>      id: String<br/>      firstName: String!<br/>      lastName: String!<br/>      books: [Book]<br/>    }<br/>    type Book {<br/>      id: String<br/>      title: String!<br/>      author: Author<br/>    }<br/>  `<br/>);</span></pre><p id="2118" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还必须定义我们的父类<code class="fe ms mt mu mv b">Query</code>类型，它承载所有检索数据的查询。在定义了父查询之后，我们必须定义<code class="fe ms mt mu mv b">Author</code>和<code class="fe ms mt mu mv b">Book</code>模型的模式。</p><p id="1768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以注意到“<strong class="kf ir">！</strong>“在某些字段类型后的符号，表示某个字段不可为空。类型周围的方括号("[]")表示它是一个数组。</p><h1 id="8532" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">嘲笑我们的数据</h1><p id="5c9f" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">我们现在已经定义了模式，但是还缺少两样东西:数据和解析查询数据的解析器。</p><p id="9775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们首先根据我们之前定义的模式模拟我们的数据:</p><pre class="nk nl nm nn gt no mv np bn nq nr bi"><span id="6eb9" class="ns lk iq mv b be nt nu l nv nw">const mockedAuthors = [<br/>  {<br/>    id: '1',<br/>    firstName: "Mike",<br/>    lastName: "Ross",<br/>  },<br/>  {<br/>    id: '2',<br/>    firstName: "John",<br/>    lastName: "Miles",<br/>    books: [<br/>      {<br/>        id: '1',<br/>        title: "Book 1",<br/>        author: {<br/>          id: '2',<br/>          firstName: "John",<br/>          lastName: "Miles",<br/>        },<br/>      },<br/>      {<br/>        id: '2',<br/>        title: "Book 2",<br/>        author: {<br/>          id: '2',<br/>          firstName: "John",<br/>          lastName: "Miles",<br/>        },<br/>      },<br/>    ],<br/>  },<br/>];<br/><br/>const mockedBooks = {<br/>  '1': {<br/>    title: "Book 1",<br/>    author: mockedAuthors["2"],<br/>  },<br/>  '2': {<br/>    title: "Book 2",<br/>    author: mockedAuthors["2"],<br/>  },<br/>};</span></pre><p id="e1b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经注意到，“Mike Ross”还没有写任何书，这不是问题，因为Author模式不需要在其数组中包含任何书。</p><p id="7f5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">此外，没有必要定义书籍数组，因为模式不需要它。</strong></p><p id="0c83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以通过将<strong class="kf ir"> books </strong>字段的类型更改为<code class="fe ms mt mu mv b">Author</code> to <code class="fe ms mt mu mv b">[Book]!</code>来改变这种情况，这样至少需要一个数组，空的或不空的。</p><h1 id="35ae" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">定义解析器</h1><p id="ffab" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">现在我们已经定义了模式和数据，我们可以通过定义解析器来完成，我们将使用解析器来处理如何将数据交付给客户端。</p><p id="52ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们只需要两个解析器:</p><ul class=""><li id="9fc9" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><strong class="kf ir">一个用于解析作者数据</strong></li><li id="86a4" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir">一个用于解析书籍数据</strong></li></ul><p id="c7e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将把<strong class="kf ir">根</strong>中的解析器定义如下:</p><pre class="nk nl nm nn gt no mv np bn nq nr bi"><span id="70a7" class="ns lk iq mv b be nt nu l nv nw">const root = {<br/>  authors: () =&gt; mockedAuthors,<br/>  books: () =&gt; mockedBooks,<br/>};</span></pre><p id="30c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在上面的代码片段中看到的，定义解析器的过程相对简单。</p><p id="ae3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将有一个作为查询名的<strong class="kf ir">属性，这意味着通过查询“authors ”(全部小写),您将获得“mockedAuthors”数据。</strong></p><p id="c43c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意，我们也将函数作为值传递给属性；这是至关重要的。</strong></p><p id="3913" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们测试一切，这样我们就可以确保它按预期工作:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/1b3add09e954543d07af1d1e0ff4f49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HSszBkTVQ5T0VwnX.png"/></div></div></figure><p id="847d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，正如预期的那样，一切正常。</p><p id="7b3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="li">我们使用GraphQL的特定术语，通过提到我们正在进行查询，使用“</em><strong class="kf ir"><em class="li">query</em></strong><em class="li">”关键字，后跟我们希望查询的属性/类型/条目。</em></p><p id="77a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们希望查询作者类型的所有属性，但只查询图书类型的id和标题；我们已经跳过了作者字段。</p><p id="532c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们已经模拟了数据，将作者包含在书籍中，所以我们可能会执行如下循环查询:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/0cde7d6c4bf21f4526c4cd2974020a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bZmhGY8ZGxJgaaD_.png"/></div></div></figure><p id="2a4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，你有它。您可以看到设置GraphQL服务器并为其定义模式和解析器是多么容易。</p><p id="50fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过定义类型，您不仅可以进行验证，还可以从您选择的平台访问文档。</p><p id="dc32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphiQL提供了一个右上角的小Docs菜单，它会弹出并向您显示模式中定义的所有类型的文档:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/80c0aa78910d5560afc010c4ee7f4fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LBI-mpbhnNzgPRu0.png"/></div></div></figure><p id="3523" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经建立了使用<strong class="kf ir">查询</strong>检索数据的工作流，我们还将看看如何使用<strong class="kf ir">变异</strong>修改现有数据。</p><h1 id="6766" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">定义突变</h1><p id="d171" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">当我们使用查询来检索数据时，我们使用突变来创建、修改或删除现有数据。</p><p id="0948" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们试图创建一个新的作者条目，我们将通过定义一个新的父类型<code class="fe ms mt mu mv b">Mutation</code>来实现，这个父类型将把我们可能在整个系统中使用的突变作为字段。</p><p id="d467" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我们必须定义解析器，瞧！这就是我们所需要做的。</p><p id="5368" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的代码片段应该说明最终的<code class="fe ms mt mu mv b"><strong class="kf ir">server.js</strong></code> <strong class="kf ir"> </strong>文件能够创建一个新的<code class="fe ms mt mu mv b">Author</code>条目:</p><pre class="nk nl nm nn gt no mv np bn nq nr bi"><span id="565e" class="ns lk iq mv b be nt nu l nv nw">const app = require("express")();<br/>const cors = require('cors');<br/>const { graphqlHTTP } = require("express-graphql");<br/>const { buildSchema } = require("graphql");<br/><br/>const schema = buildSchema(<br/>  `<br/>    type Query {<br/>      authors: [Author]<br/>      books: [Book] <br/>    }<br/>    type Mutation {<br/>      createAuthor(<br/>        firstName: String!,<br/>        lastName: String!<br/>      ): Author<br/>    }<br/>    type Author {<br/>      id: String<br/>      firstName: String!<br/>      lastName: String!<br/>      books: [Book]<br/>    }<br/>    type Book {<br/>      id: String<br/>      title: String!<br/>      author: Author<br/>    }<br/>  `<br/>);<br/><br/>const mockedAuthors = [<br/>  {<br/>    id: '1',<br/>    firstName: "Mike",<br/>    lastName: "Ross",<br/>  },<br/>  {<br/>    id: '2',<br/>    firstName: "John",<br/>    lastName: "Miles",<br/>    books: [<br/>      {<br/>        id: '1',<br/>        title: "Book 1",<br/>        author: {<br/>          id: '2',<br/>          firstName: "John",<br/>          lastName: "Miles",<br/>        },<br/>      },<br/>      {<br/>        id: '2',<br/>        title: "Book 2",<br/>        author: {<br/>          id: '2',<br/>          firstName: "John",<br/>          lastName: "Miles",<br/>        },<br/>      },<br/>    ],<br/>  },<br/>];<br/><br/>const mockedBooks = {<br/>  '1': {<br/>    title: "Book 1",<br/>    author: mockedAuthors["2"],<br/>  },<br/>  '2': {<br/>    title: "Book 2",<br/>    author: mockedAuthors["2"],<br/>  },<br/>};<br/><br/>const root = {<br/>  authors: () =&gt; mockedAuthors,<br/>  books: () =&gt; mockedBooks,<br/>  createAuthor: ({ firstName, lastName }) =&gt; {<br/>    const id = String(mockedAuthors.length + 1);<br/>    const createdAuthor = {<br/>      id,<br/>      firstName,<br/>      lastName<br/>    };<br/>    mockedAuthors.push(createdAuthor);<br/>    return createdAuthor;<br/>  }<br/>};<br/><br/>app.use(cors());<br/><br/>app.use(<br/>  "/graphql",<br/>  graphqlHTTP({<br/>    schema,<br/>    rootValue: root,<br/>    graphiql: true,<br/>  })<br/>);<br/><br/>app.listen(8080);</span></pre><p id="75b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以你有它。您应该有一个工作的<strong class="kf ir"> GraphQL服务器</strong>与之交互，以便<strong class="kf ir">检索</strong>、<strong class="kf ir">修改</strong>或<strong class="kf ir">删除</strong>数据。</p><p id="9bce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会选择开始研究将解析器和模式类型分离到单独的目录和文件中，并将它们聚集在<strong class="kf ir"> server.js </strong>文件中，等等；当考虑扩展GraphQL应用程序时，选择是无穷无尽的。</p><p id="d82a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">毕竟，这也是当初建造它的原因之一。</p><p id="9d33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢阅读这篇文章，并且它能帮助你理解使用<strong class="kf ir">node . js</strong>&amp;<strong class="kf ir">Express</strong>设置你的<strong class="kf ir"> GraphQL </strong>服务器的基本原理。如果你觉得我错过了什么，请在下面的评论中告诉我。</p><p id="0d54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次见。干杯！</p><h1 id="328c" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">有用的资源</h1><ul class=""><li id="371e" class="mw mx iq kf b kg mh kk mi ko oa ks ob kw oc la nb nc nd ne bi translated"><a class="ae kc" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">模式&amp;类型</a></li><li id="bb28" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://graphql.org/graphql-js/express-graphql/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">express-graph QL</strong>库</a></li><li id="43fa" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://graphql.org/graphql-js/graphql/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">graph QL</strong>库</a></li></ul><p id="adc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="li">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="li">plain English . io</em></strong></a><em class="li">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="li">免费周报</em> </strong> </a> <em class="li">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="li">Twitter</em></strong></a><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="li">LinkedIn</em></strong></a><em class="li"/><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="li">YouTube</em></strong></a><em class="li"/><a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="li">不和</em> </strong> </a> <em class="li">。对增长黑客感兴趣？检查</em> <a class="ae kc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="li">电路</em> </strong> </a> <em class="li">。</em></p></div></div>    
</body>
</html>