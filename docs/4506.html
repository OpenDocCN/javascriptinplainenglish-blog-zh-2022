<html>
<head>
<title>How To Write Efficient Unit Tests with Prisma ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Prisma ORM编写高效的单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-write-efficient-unit-tests-with-prisma-orm-e9d8fdf43f5f?source=collection_archive---------5-----------------------#2022-12-09">https://javascript.plainenglish.io/how-to-write-efficient-unit-tests-with-prisma-orm-e9d8fdf43f5f?source=collection_archive---------5-----------------------#2022-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0d85" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Express &amp; Prisma的一个例子</h2></div><p id="406f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的全栈开发生涯中，我尝试了很多ORM、ODM和查询构建器。有些太棒了，而有些仍然让我做噩梦(我们看到你<a class="ae lb" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"><em class="lc"/></a>)。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/daec96a3512ba923e78ebc3cd9bef10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GNS8wo-hAcWv2AHpRNA4Q.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/fr/@roman_lazygeek" rel="noopener ugc nofollow" target="_blank">Roman Mager</a> on <a class="ae lb" href="https://unsplash.com/fr/s/photos/test" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a87a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">初速电流状态</h1><p id="1fbb" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在这些神奇的工具中，有<a class="ae lb" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>。它工作完美，有一个伟大的DX，文件，等等。我在使用它的时候遇到了一个问题，单元测试。</p><p id="9806" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然他们有一个关于单元测试的文档页面，有一个很好的介绍，但是他们嘲笑的方法并不令人满意。</p><div class="mq mr gp gr ms mt"><a href="https://www.prisma.io/docs/guides/testing/unit-testing" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">使用Prisma进行单元测试</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">将Jest添加到您的项目Prisma使用TypeScript，Jest可以在软件包的帮助下设置为使用TypeScript…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.prisma.io</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh ln mt"/></div></div></a></div><p id="3d58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好的情况是，这允许您一个接一个地模拟您认为将被调用的请求的响应。我认为这是低效的，原因如下:</p><ul class=""><li id="2550" class="ni nj iq kh b ki kj kl km ko nk ks nl kw nm la nn no np nq bi translated">每次测试都需要太多的设置。</li><li id="69d4" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">在您定义的模拟中，信任度非常低，因为您不确定Prisma是否会返回相同的数据。</li><li id="1aa3" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">通过自己定义这些模拟，您可以远离测试您的应用程序行为，而更接近测试实现细节。</li><li id="a9a3" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">有了Prisma的新版本，你有可能看到你的测试被淘汰。</li></ul><div class="mq mr gp gr ms mt"><a href="https://kentcdodds.com/blog/testing-implementation-details" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">测试实施细节</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">回到我使用enzyme的时候(就像当时的其他人一样)，我小心翼翼地绕开enzyme中的某些API。我…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">kentcdodds.com</p></div></div><div class="nc l"><div class="nw l ne nf ng nc nh ln mt"/></div></div></a></div><p id="b924" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看我们要测试什么应用程序，要写哪些测试，然后定义如何写单元测试。</p><h1 id="a7da" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">应用程序结构</h1><p id="7469" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我的后端应用程序通常分为几层。如果我们以一个基本的ExpressJS应用程序为例，它至少有3层:模块、控制器和服务。</p><p id="73a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每组功能被分成一个专用的<strong class="kh ir">模块</strong>，它处理路由、验证，并将请求传递给控制器。</p><p id="f88d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">控制器</strong>是发现业务逻辑的地方，并且经常使用服务。</p><p id="2353" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kh ir">服务</strong>提供向数据库发出请求的高级功能。这就是我使用ORM比如<strong class="kh ir"> Prisma </strong>的地方。</p><h1 id="4224" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">应该测试什么</h1><p id="3ca7" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">当我在后端应用程序上工作时，我通常有两种主要的测试类型(根据上下文，还有更多类型！).它们是<strong class="kh ir">单元</strong>和<strong class="kh ir">端到端</strong>测试。</p><div class="mq mr gp gr ms mt"><a href="https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">软件测试的不同类型</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">区分手动测试和自动测试是很重要的。手动测试由…亲自完成</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.atlassian.com</p></div></div><div class="nc l"><div class="nx l ne nf ng nc nh ln mt"/></div></div></a></div><p id="88de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我尽可能避免编写e2e测试，因为它们有一些限制，比如速度慢、成本高、反馈晚。我通常为中间件等低级功能编写<strong class="kh ir">单元</strong>测试。</p><p id="330e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，我不会完全孤立地测试我的服务或控制器。在那些情况下，我觉得它没有给我足够的时间来写测试。相反，我想从整体上测试我的端点行为。</p><p id="f530" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我使用我的后端应用程序的<strong class="kh ir">测试版本</strong>来编写我的测试。像Prisma这样的外部依赖被模拟(以一种有效的方式),这允许我使用像<a class="ae lb" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank"> SuperTest </a>这样的工具单独模拟查询。</p><p id="9cab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我为大多数用例编写单元测试。它包括验证(如参数)、授权(确保您有正确的访问权限)，但我也使用Prisma的模拟版本验证我收到了正确的响应。根据我的应用程序，甚至有更多的用例。</p><p id="287f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我还要编写e2e测试，以确保在真实环境中，我的成功响应和与数据库相关的错误是意料之中的。</p><p id="bc33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些测试可能与我的单元测试部分重叠，但是这次使用的是真实的数据库。它给了我单元测试的快速和早期的反馈，同时具有e2e测试的高可信度。</p><h1 id="107c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">如何编写那些测试</h1><p id="fbd8" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在下面的例子中，我希望你理解测试的基础。这包括Jest，它被用作示例的一部分。</p><div class="mq mr gp gr ms mt"><a rel="noopener  ugc nofollow" target="_blank" href="/testing-with-node-js-understand-and-choose-the-right-tools-98c0a33fb59a"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">用Node.js测试:理解并选择正确的工具</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">用Node.js测试需要哪些工具，根据自己的目的选择哪些？</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nc l"><div class="ny l ne nf ng nc nh ln mt"/></div></div></a></div><h2 id="8400" class="nz lu iq bd lv oa ob dn lz oc od dp md ko oe of mf ks og oh mh kw oi oj mj ok bi translated">中间件</h2><p id="63f9" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">中间件不需要特殊的测试环境，它们可以像其他功能一样被考虑。</p><p id="e0de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的问题是，他们有一个明确的格式。对于Express，它们必须返回一个接受<strong class="kh ir">请求</strong>、<strong class="kh ir">响应</strong>和<strong class="kh ir">下一个函数</strong>的函数。让我们来看看下面的片段:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="2a10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Validator接受一个函数，该函数通过基于接收到的请求返回一个布尔值来确定请求是否有效。它返回一个中间件，如果接收到的请求被确定为无效，该中间件将抛出一个错误。</p><p id="a7fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了Jest，这个中间件可以很容易地通过用不同的参数调用它来测试，并验证next是用正确的元素调用的。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="7421" class="nz lu iq bd lv oa ob dn lz oc od dp md ko oe of mf ks og oh mh kw oi oj mj ok bi translated">端点(单位)</h2><p id="fd11" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我已经解释过我使用<a class="ae lb" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank"> SuperTest </a>作为我的端点。我还谈到了使用我的后端应用程序的测试版本。更准确地说，我有几个助手函数，专门用于在测试期间引导我的后端和管理模拟数据。</p><p id="4d32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的代码片段是单元测试的一个很好的例子。我们演示了如何测试一个致力于创建文章的端点。</p><p id="ff45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用助手来引导我们的应用程序，生成用例所需的令牌，并使用SuperTest发送请求。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="9c88" class="nz lu iq bd lv oa ob dn lz oc od dp md ko oe of mf ks og oh mh kw oi oj mj ok bi translated">和Prisma一起嘲笑</h2><p id="ce77" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">但是我们仍然没有解决Prisma带来的问题。在上面的片段中，看起来没有什么是嘲笑。</p><p id="730a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想编写不依赖于数据库或<a class="ae lb" href="https://www.prisma.io/docs/guides/testing/unit-testing" rel="noopener ugc nofollow" target="_blank">大量模仿</a>的测试，有一个简单的解决方案:使用Prisma的内存实现。</p><p id="260d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">介绍<a class="ae lb" href="https://www.npmjs.com/package/prismock" rel="noopener ugc nofollow" target="_blank">普里莫克</a>。<em class="lc">声明:我的确是它的创造者</em>。</p><div class="mq mr gp gr ms mt"><a href="https://www.npmjs.com/package/prismock" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">普里莫克</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">这是对PrismaClient的嘲弄。它完美地模拟了Prisma的API，并将所有内容存储在内存中，以便快速、隔离地…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.npmjs.com</p></div></div><div class="nc l"><div class="on l ne nf ng nc nh ln mt"/></div></div></a></div><p id="bc03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于没有令人满意的解决方案来有效地用Prisma编写单元测试，我决定编写自己的解决方案。</p><p id="a3d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它实际上会读取你的<code class="fe oo op oq or b">schema.prisma</code>，并基于它生成模型。它完美地模拟了Prisma的API，并将所有内容存储在内存中，以便进行快速、隔离和可重试的单元测试。</p><p id="79d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得我如何使用助手来构建我的后端应用程序的测试版本吗？</p><p id="b82c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在生产中，我使用真正的<strong class="kh ir"> PrismaClient </strong>构建我的应用程序，然后进行引导。在我的测试中，我使用<a class="ae lb" href="https://www.npmjs.com/package/prismock#dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>替换<strong class="kh ir"> PrismaClient </strong>。</p><p id="d6a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码片段中，它是作为<code class="fe oo op oq or b">ServerMock.createApp()</code>的一部分完成的，这使得它在我编写测试时几乎不可见。</p><h2 id="5e29" class="nz lu iq bd lv oa ob dn lz oc od dp md ko oe of mf ks og oh mh kw oi oj mj ok bi translated">端点(E2E)</h2><p id="bf82" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在我们的文章端点和授权过程已经过测试的情况下，我们可以说，在e2e测试期间，在每个端点上测试认证并不是强制性的。</p><p id="beb0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以以下面的测试结束:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e541" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试必须在一个不同的环境中编写，在这个环境中，我们可以访问一个种子数据库，并且我们的端点已经在一个接近生产的环境中构建和运行。</p><h1 id="9933" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="65b6" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在这种情况下，我们应该用单元测试覆盖我们的整个代码库，给我们快速和早期的反馈，对我们的测试结果有强烈的信任。</p><p id="b447" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Prisma的内存实现代替<a class="ae lb" href="https://www.prisma.io/docs/guides/testing/unit-testing" rel="noopener ugc nofollow" target="_blank">手动模拟</a>进一步增加了我们的信心。连同我们的测试策略(定义在<strong class="kh ir">什么应该被测试</strong>中)，我们也以惊人的生产力结束。</p><p id="7b8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们专门为向我们的数据库发出请求的用例编写E2E测试。它确实与一些单元测试重叠，速度较慢，后期反馈更昂贵，但是它消除了剩余的灰色区域。</p><p id="c95b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们能够回答:</p><blockquote class="os ot ou"><p id="1a7b" class="kf kg lc kh b ki kj jr kk kl km ju kn ov kp kq kr ow kt ku kv ox kx ky kz la ij bi translated">您有信心将您的应用交付生产吗？</p></blockquote></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><p id="bb51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">寻找使用Node创建后端应用程序的完整课程。JS？</strong></p><div class="mq mr gp gr ms mt"><a href="https://www.scalablebackend.com" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">使用NodeJS的企业级后端开发</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">采取正确的技术选择是必要的，但还不够。实施应该是最高质量的，并且…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.scalablebackend.com</p></div></div><div class="nc l"><div class="pf l ne nf ng nc nh ln mt"/></div></div></a></div><p id="f46c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">更多内容看</em> <a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">说白了。</em></strong></a></p><p id="d94b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">免费每周简讯</em> </strong> </a> <em class="lc">。关注我们关于</em> <a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">推特</em> </strong> </a>，<a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">领英</em> </strong> </a> <strong class="kh ir"> <em class="lc">，</em></strong><a class="ae lb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">YouTube</em></strong></a><strong class="kh ir"><em class="lc">，以及</em></strong><em class="lc"/><a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">不和</em> </strong> </a>T59】</p><p id="e359" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lc">想扩大你的软件创业规模</em> </strong> <em class="lc">？检查出</em> <a class="ae lb" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">电路</em> </strong> </a> <em class="lc">。</em></p></div></div>    
</body>
</html>