<html>
<head>
<title>How to Test a Node.js Command-Line Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试Node.js命令行工具</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-test-a-node-js-command-line-tool-2735ea7dc041?source=collection_archive---------5-----------------------#2022-03-03">https://javascript.plainenglish.io/how-to-test-a-node-js-command-line-tool-2735ea7dc041?source=collection_archive---------5-----------------------#2022-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/342547c7c2ce9c07251c3848f7938201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5uBsvD88Yr6KtStf"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3917" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以使用Jest来测试命令行工具。</p><p id="b6ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文主要关注前端测试的一些高级技术，以及大量演示代码，展示如何对更复杂的命令行工具进行集成测试。</p><h1 id="8391" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么需要测试用例</h1><h1 id="c1d6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">优势</h1><h2 id="5e05" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">1.代码质量保证和增加信任</h2><p id="c410" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">纵观Github整体，一个成熟的工具库必须具备:</p><p id="c547" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">开发良好的测试案例(Jest/Mocha)</p><p id="76af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">友好的文档(官方网站/演示)</p><p id="1136" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类型声明文件d.ts</p><p id="bf52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">持续集成环境(git action/circleci)</p><p id="3ec3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有这些要素，用户在使用产品时可能会遇到各种各样的bug，显然他们肯定不希望看到这种情况发生，最终导致用户很难接受你的产品。</p><p id="c0b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">测试用例最重要的一点是提高代码质量，让别人有信心使用你开发的工具(信心产生的信任关系对软件工程师来说至关重要)。</p><p id="37e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，测试用例可以直接看作是现成的调试环境，在编写测试用例时会逐渐弥补需求分析中没有想到的情况。</p><h2 id="6825" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">2.担保重组</h2><p id="c34f" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">当代码需要针对主要版本进行更新时，拥有开发良好的测试用例可以在重构中发挥关键作用。</p><p id="bc93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">选择黑盒测试的测试用例设计方法，只关心输入输出，不需要关心测试用例内部做什么。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/0525db63063acafdd1d351d00bbfccf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*oBrt--ZJyONi9L9Sjx7PVA.png"/></div></figure><p id="e515" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于重构，<strong class="kc io">如果最终暴露给用户的api没有改变，</strong>那么几乎不需要做任何改变，直接重用之前的测试用例。</p><p id="47d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，如果代码有好的测试用例，可以大大增强重构的信心，而不用担心原来的功能会因为代码的改变而失效。</p><h2 id="b485" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">3.提高代码可读性</h2><p id="3b02" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">对于想要理解项目源代码的开发人员来说，阅读测试用例是一种有效的方式。</p><p id="938f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">测试用例为工具在各种情况下的功能和行为提供了非常直观的表示。</p><p id="64cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">换句话说，<strong class="kc io">测试用例是软件开发者阅读的“文档”。</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c850" class="lw kz in mt b gy mx my l mz na">// Vue.js test cases<br/>// <a class="ae jz" href="https://github.com/vuejs/core/blob/main/packages/reactivity/__tests__/computed.spec.ts#L24" rel="noopener ugc nofollow" target="_blank">https://github.com/vuejs/core/blob/main/packages/reactivity/__tests__/computed.spec.ts#L24</a><br/>it('should compute lazily', () =&gt; {<br/>  const value = reactive&lt;{ foo?: number }&gt;({})<br/>  const getter = jest.fn(() =&gt; value.foo)<br/>  const cValue = computed(getter)</span><span id="1a6c" class="lw kz in mt b gy nb my l mz na">  // lazy<br/>  expect(getter).not.toHaveBeenCalled()</span><span id="d010" class="lw kz in mt b gy nb my l mz na">expect(cValue.value).toBe(undefined)<br/>  expect(getter).toHaveBeenCalledTimes(1)</span><span id="1569" class="lw kz in mt b gy nb my l mz na">  // should not compute again<br/>  cValue.value<br/>  expect(getter).toHaveBeenCalledTimes(1)</span><span id="9aa5" class="lw kz in mt b gy nb my l mz na">  // should not compute until needed<br/>  value.foo = 1<br/>  expect(getter).toHaveBeenCalledTimes(1)</span><span id="50a5" class="lw kz in mt b gy nb my l mz na">  // now it should compute<br/>  expect(cValue.value).toBe(1)<br/>  expect(getter).toHaveBeenCalledTimes(2)</span><span id="d559" class="lw kz in mt b gy nb my l mz na">  // should not compute again<br/>  cValue.value<br/>  expect(getter).toHaveBeenCalledTimes(2)<br/>})</span></pre><h1 id="b0fe" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">不足之处</h1><p id="6a37" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">任何事情都有两面性，所以在谈完优点之后，我们来谈谈缺点，以帮助你更好地确定是否应该为你的项目编写测试用例。</p><h2 id="26c2" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">一会儿工夫</h2><p id="1c54" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">开发人员一般不写测试用例的时候，最常见的一点就是太繁琐。</p><p id="994b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="nc">我写测试用例的时候，代码早就写好了，你说测试？交给QA，那是他们的责任。</em>T9】</strong></p><p id="6570" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种情况是完全可以理解的，通常情况下，开发时间来不及，怎么能抽出时间来写测试用例呢？</p><p id="381b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以你需要根据项目的类型来判断编写测试用例的价值。</p><p id="6e34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于UI修改频繁、生命周期短的项目，比如官网、活动页面，<strong class="kc io">我不建议写测试用例。</strong></p><p id="4e31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为它们一般都是时间敏感的，页面结构的频繁变化会直接导致测试用例的频繁变化，另外这类项目一般都配备了QA资源，一定程度上保证了项目的质量(自测还是很有必要的)。</p><p id="3cf6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，对于工具库和组件库，由于功能变化少，一般没有QA资源，如果已经有一定的用户规模，建议<strong class="kc io">补充测试用例</strong>。</p><h2 id="a8d6" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">不会写</h2><p id="acbb" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">写测试用例需要学习测试框架的语法，所以需要一定的学习成本(没时间学习也是不会写的原因)</p><p id="a680" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的方面是市面上主流的测试框架大同小异，整体思路趋于一致，而突破性的改变本身并不多。普通开发商一周就能上手，要提前两周。学会后能够在任何前端项目中使用(学一次，到处写)。</p><p id="3532" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对比Vue.js和React的学习成本，再结合前面的优势，是不是很划算？</p><p id="fc8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">优缺点之后，再来分享一些为复杂命令行工具编写测试用例的经验。</p><h1 id="3806" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">命令行工具的集成测试</h1><p id="fd1c" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">集成测试和单元测试的区别在于，前者更宽泛，后者更细粒度，集成测试也可以由多个单元测试组合而成。</p><p id="1d7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然是命令行工具，首先要考虑的是如何模拟用户使用命令行的行为。</p><h2 id="1c5c" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">直接运行命令行</h2><p id="fe8c" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">起初，我对测试用例的理解是尽可能模拟原始的用户输入。所以我的想法是直接在测试用例中运行命令行工具。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d873" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在子进程中运行命令行工具，然后将子进程的输出打印到父进程，最后确定打印结果是否如预期。</p><p id="4883" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点:</strong>更符合用户使用命令行的方式。</p><p id="946c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点:</strong>当你需要调试测试用例时，由于对子进程的依赖，调试器启动时性能非常差，测试用例经常超时甚至吞错或者输出一些与测试用例本身无关的系统错误。</p><h2 id="87df" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">功能运行</h2><p id="78b0" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">上一个方案滞后太厉害，被迫想其他方案。</p><p id="eb84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我使用<a class="ae jz" href="https://www.npmjs.com/package/commander" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> commander </em> </a>来实现Node.js的命令行工具，测试用例本质上只需要获得命令背后的动作来执行。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/824e2ec24d3d2cd6643ab74fd078b984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uuNOU8pRIYgHz4KB.jpg"/></div></div></figure><p id="5958" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">commander文档提到用命令行参数调用<a class="ae jz" href="https://www.npmjs.com/package/commander#parse-and-parseasync" rel="noopener ugc nofollow" target="_blank"> parse </a>方法将触发动作回调。</p><p id="5e71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们公开了一个引导启动函数，它接受命令行参数并将其传递给parse。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7eaf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点:</strong>不依赖子进程，直接在当前进程中运行测试用例，调试器也没问题，成功解决了性能瓶颈。</p><p id="3e4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点:</strong>代码有副作用，所有测试用例共享同一个程序实例，测试用例可以单独使用没有问题，但是多个测试用例可能会互相干扰。</p><h2 id="91bd" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">工厂功能操作</h2><p id="a06f" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">有了上次的经验，我们公开一个直接生成命令行工具的工厂函数。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a928" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，每当你运行一个测试用例时，你就创建了一个单独的程序，使得测试用例相互隔离。</p><p id="ec54" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在解决了命令行工具的初始化之后，让我们来看几个针对命令行的特殊测试用例。</p><h2 id="4bb4" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">测试帮助命令</h2><p id="de09" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">当测试帮助命令(— help，-h)或测试命令行参数的有效性时，commander将提示文本作为错误日志输出到进程，并调用<code class="fe ng nh ni mt b">process.exit</code>退出当前进程。</p><p id="d711" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将导致测试用例<strong class="kc io">提前退出，</strong>因此这个行为需要重写。</p><p id="9bb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Commander内部提供了一个被覆盖的函数<code class="fe ng nh ni mt b">exitOverride</code>，它抛出一个JavaScript错误，而不是原来的进程退出。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6cd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在覆盖退出行为之后，为了验证帮助命令文本，您还需要使用commander提供的<a class="ae jz" href="https://www.npmjs.com/package/commander#display-help-from-code" rel="noopener ugc nofollow" target="_blank"> configureOutput </a>。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/2fffae2b9e40c5d55d14798ee8ea1733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L-IOaiiquaT1ABR3.jpg"/></div></div></figure><p id="364c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后修改测试用例:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="3d72" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">测试异步用例</h2><p id="c92f" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">命令行工具可能有异步回调，测试用例需要支持异步用例。</p><p id="998c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的一面是Jest对于异步测试用例是现成的，所以让我们以help命令为例。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a323" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于异步测试用例，建议设置一个<strong class="kc io">超时</strong>，防止因代码编写错误而等待测试结果。</p><p id="6938" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Jest的默认超时为5000毫秒，也可以通过配置文件/测试用例来覆盖。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f124" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了超时，增加的<strong class="kc io">断言数量</strong>也是保证异步测试用例成功的一个点。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/d96ee2bcf1778e5dffe8f9b609cc39c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2wBCyG-UGV1DxQ5E.jpg"/></div></div></figure><p id="bb15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ng nh ni mt b">expect.assertions</code>可以指定单个测试用例触发断言的次数，这对测试异常捕获场景很有用。</p><p id="addd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">超时和预期的次数不匹配都会使测试用例失败。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="17d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">测试运行中的变量</strong></p><p id="5c6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在正常的测试场景中，可以通过运行导出函数的返回值来验证变量值。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8b52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，命令行工具可能依赖于上下文信息(参数、选项)，不太适合在内部反汇编和导出单个函数，那么如何在运行时测试变量值呢？</p><p id="f773" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我用<a class="ae jz" href="https://www.npmjs.com/package/debug" rel="noopener ugc nofollow" target="_blank">debug</a>+<a class="ae jz" href="https://jestjs.io/docs/jest-object#jestdomockmodulename-factory-options" rel="noopener ugc nofollow" target="_blank">jest . do mock</a>+<a class="ae jz" href="https://jestjs.io/docs/expect#tohavebeencalled" rel="noopener ugc nofollow" target="_blank">调用了</a></p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bbac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1.使用<code class="fe ng nh ni mt b">debug</code>模块打印需要验证的参数(在代码中有些侵入性，但是调试模块也可以用于日志记录)。</p><p id="13ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.测试用例运行时用jest.doMock劫持调试模块，以便调试执行返回<code class="fe ng nh ni mt b">jest.fn</code>。</p><p id="59e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.用<code class="fe ng nh ni mt b">toHaveBeenCalled</code>确认<code class="fe ng nh ni mt b">jest.fn</code>的输入。</p><blockquote class="nl nm nn"><p id="3ef2" class="ka kb nc kc b kd ke kf kg kh ki kj kk no km kn ko np kq kr ks nq ku kv kw kx ig bi translated">为什么用<code class="fe ng nh ni mt b">jest.doMock</code>而不用<code class="fe ng nh ni mt b">jest.mock</code>？</p><p id="c831" class="ka kb nc kc b kd ke kf kg kh ki kj kk no km kn ko np kq kr ks nq ku kv kw kx ig bi translated"><code class="fe ng nh ni mt b">jest.mock</code>在运行时声明提升，使得不能使用外部变量f</p><p id="7782" class="ka kb nc kc b kd ke kf kg kh ki kj kk no km kn ko np kq kr ks nq ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/facebook/jest/issues/2567" rel="noopener ugc nofollow" target="_blank"><em class="in">https://github.com/facebook/jest/issues/2567</em></a></p></blockquote><h2 id="8ea2" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">模拟命令行交互</h2><p id="a82d" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">具有命令行交互的命令行工具是一种非常常见的场景。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9e64b17a023df0f39b0404b0c1f30e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*gLIKC3wsy6XZ4-oE.jpg"/></div></figure><p id="cdde" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">受<a class="ae jz" href="https://github.com/vuejs/vue-cli/blob/dev/__mocks__/inquirer.js" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> vue-cli </em> </a>的启发，在测试用例中模拟用户输入变得非常简单，不会侵入任何代码。</p><p id="f400" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1.创建__mock__/inquirer.js，劫持并代理prompt模块，将Jest的断言语句添加到重新实现的prompt函数中。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d83b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.在运行测试用例之前，通过<code class="fe ng nh ni mt b">expectPrompts</code>模拟用户的问题和答案(创建断言的条件)。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e6d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.代码运行inquirer.prompt时，代理跳转到__mock__/inquirer.js自定义提示，提示会根据前面<code class="fe ng nh ni mt b">expectPrompts</code>创建的问题和答案按顺序匹配(消耗数据)。</p><p id="3952" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.最终的代理提示将返回与真实提示相同的answers对象，使最终行为保持一致。</p><h2 id="924b" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">摘要</h2><p id="7823" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">保证测试用例彼此独立编写<strong class="kc io">，互不影响，没有副作用，具有幂等性。</strong></p><p id="f515" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可以从以下角度进行:</p><p id="ce44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次运行测试用例时，创建一个新的commander实例。</p><p id="30fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">允许单个测试用例使用单一模式，不允许多个测试用例使用同一个单一模式。</p><p id="5731" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">文件系统隔离。</p><h1 id="b902" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">其他测试技巧</h1><h2 id="05b5" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">模拟作业目录</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8fb4" class="lw kz in mt b gy mx my l mz na">jest.spyOn(process, ‘cwd’).mockImplementation(() =&gt; mockPath))</span></pre><p id="ffa4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://jestjs.io/docs/jest-object#jestspyonobject-methodname" rel="noopener ugc nofollow" target="_blank"> jest.spyOn </a>跟踪对process.cwd的调用，<a class="ae jz" href="https://jestjs.io/docs/mock-function-api#mockfnmockimplementationfn" rel="noopener ugc nofollow" target="_blank"> jest.mockImplementation </a>重写process.cwd的行为，以模拟工作目录。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fec1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果不依赖Jest API，也可以将模拟工作目录作为参数传递给<code class="fe ng nh ni mt b">createProgram</code>工厂函数。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="29e8" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">文件系统的模拟</h2><p id="a49e" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">文件读写也是包含副作用的操作，并且由于命令行工具可能涉及文件修改，所以不能保证每次运行测试用例时都有一个干净的环境。为了确保测试用例相互独立，需要模拟一个真实的文件系统。</p><p id="170d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里选择<a class="ae jz" href="https://www.npmjs.com/package/memfs" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> memory-fs </em> </a>，将真实的文件系统操作转换为内存中的虚拟文件。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/45c85f2d56c1ea97d9be2b488c318215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vgmDsKable0Q12Kv.jpg"/></div></div></figure><p id="9757" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在项目根目录下创建一个新的__mocks__文件夹。</p><p id="29aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将fs.js添加到__mocks__文件夹中以导出memfs模块。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ccf5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Jest将__mocks__文件夹中的文件视为默认情况下可以<a class="ae jz" href="https://jestjs.io/docs/next/manual-mocks#mocking-user-modules" rel="noopener ugc nofollow" target="_blank"> <em class="nc">模拟</em> </a>的<a class="ae jz" href="https://jestjs.io/docs/next/manual-mocks#mocking-user-modules" rel="noopener ugc nofollow" target="_blank"> <em class="nc">模块</em> </a>。</p><p id="3271" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在测试用例中运行<code class="fe ng nh ni mt b">jest.mock(fs)</code>劫持fs模块并代理到__mocks__/fs.js下。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/d26a5d46da6e1fbf828ac6397429fed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YVx7eZkDKbOPuUd0.jpg"/></div></div></figure><p id="0a43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">文件系统副作用问题通过将fs代理到memfs来解决。</p><h2 id="a921" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">无声错误日志</h2><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5787" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ng nh ni mt b">jest.mockImplementation</code>不传递任何参数，并在模仿后静默处理函数。</p><p id="7072" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实现测试运行时不输出错误日志的功能，使测试用例运行更加干净。</p><p id="648a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不输出错误日志并不意味着接受错误，您仍然可以使用try/catch来验证错误场景。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b83e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，还可以使用program.configureOutput重写错误日志。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="aacd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用前。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/a7a1ad8eb750ed57e95fc8f04637e6ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aBgRHxZfu3-Wp50d.jpg"/></div></div></figure><p id="fc74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用后。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/17ebdc422d5b91db13e58ac5f046089e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RmVu0l9dkDVDVDzY.jpg"/></div></div></figure><h2 id="7fc1" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">测试用例生命周期挂钩</h2><p id="42d3" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">Jest提供了以下挂钩</p><p id="d77f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先</p><p id="bdda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次之前</p><p id="d38b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次之后</p><p id="58e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">毕竟</p><p id="69d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生命周期挂钩在每个/所有测试用例之前/之后触发，通过向挂钩添加公共代码，可以在一定程度上减少代码量。</p><p id="70b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比如用<code class="fe ng nh ni mt b">beforeEach</code>钩子，在每个测试用例运行之前，代码都被嘲讽，结束之后，用<code class="fe ng nh ni mt b">jest.retoreAllMock</code>恢复。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="e78a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">类型脚本支持</h1><p id="f050" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">向测试用例添加TypeScript支持允许更强的类型提示，并允许在运行测试用例之前预先检查代码类型。</p><ol class=""><li id="e985" class="nw nx in kc b kd ke kh ki kl ny kp nz kt oa kx ob oc od oe bi translated">添加<code class="fe ng nh ni mt b">ts-jest</code>、<code class="fe ng nh ni mt b">typescript</code>、<code class="fe ng nh ni mt b">@types/jest</code>类型的申报文件。</li></ol><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d1d2" class="lw kz in mt b gy mx my l mz na">npm i ts-jest typescript @types/jest -D</span></pre><p id="fed7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.添加tsconfig.json文件，并将之前安装的@types/jest添加到声明文件列表中。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a0f2" class="lw kz in mt b gy mx my l mz na">{<br/> “compilerOptions”: {<br/>   “types”: [ “jest” ],<br/> }<br/>}</span></pre><p id="a85a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.修改测试用例文件名后缀index.spec.js → index.spec.ts，并将CommonJS简介改为ESM。</p><h1 id="99a8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试覆盖率</h1><p id="7080" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">测试用例运行、代码未运行、行数的可视化表示。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/d9105c4dbdec53db2de99f4193b5f67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M1fdXQZs0cy28fbQ.jpg"/></div></div></figure><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/0ca568598867528132878bb8abacd84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YjEq8WY4ekJ7n0uW.jpg"/></div></div></figure><p id="6d92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将<code class="fe ng nh ni mt b">coverage</code>参数添加到测试命令的末尾。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6331" class="lw kz in mt b gy mx my l mz na">jest --coverage</span></pre><p id="de2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行后生成覆盖率的文件夹包含测试覆盖率报告。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/eec0a6640e09cef64cd708fe3bb53f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7CxG-03eMxUhf798.jpg"/></div></div></figure><p id="17df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，测试覆盖可以与CI/CD平台集成，生成测试覆盖报告，并在每次工具发布后上传到CDN。</p><p id="8661" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实现每个工具版本测试覆盖率的增长趋势。</p><h1 id="83a9" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="1e64" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">编写测试用例是一种前期投入更多时间(学习测试用例语法)和后期收获很多(持续的代码质量保证和提高重构信心)的方式。</p><p id="0ff5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">适合改动少，QA资源少的产品，比如命令行工具，工具库。</p><p id="a6d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">写测试用例的一个小技巧就是参考相应工具的Github上的测试用例，往往官方的测试用例更完整。</p><p id="39f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">命令行工具的集成测试要求测试用例相互隔离，以确保等幂性。</p><p id="78d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">公开一个创建commander实例的工厂函数，每次运行测试用例时都创建一个全新的实例。</p><p id="590c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用Jest的内置api，如<code class="fe ng nh ni mt b">jest.spyOn</code>、<code class="fe ng nh ni mt b">mockImplementation</code>、<code class="fe ng nh ni mt b">jest.doMock</code>，代理npm模块或内置函数，对代码的侵入性较小。</p><h1 id="7df8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><p id="525b" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">博客。</p><p id="5925" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/tj/commander.js/issues/1565" rel="noopener ugc nofollow" target="_blank"> <em class="nc">对commander cli进行单元测试的最好方法是什么？</em>T12】</a></p><p id="f1d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://itnext.io/testing-with-jest-in-typescript-cc1cd0095421" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://it next . io/testing-with-jest-in-typescript-cc1cd 0095421</em></a></p><p id="a148" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">斯塔科弗洛。</p><p id="bddc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://stackoverflow.com/questions/58096872/react-jest-test-fails-to-run-with-ts-jest-unexpected-token-on-imported-file" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://stack overflow . com/questions/58096872/react-jest-test-fails-to-run-with-ts-jest-unexpected-token-on-imported-file</em></a></p><p id="1aa2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Github。</p><p id="259f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/shadowspawn/forest-arborist/blob/fca5ffcc5b300660ae9e1f6c4a8667d72feb0822/src/command.ts#L48" rel="noopener ugc nofollow" target="_blank">T5】https://github . com/shadow spawn/forest-arborist/blob/fc a5 ffcc 5b 300660 AE 9 E1 f 6 C4 a 8667d 72 feb 0822/src/command . ts # L48T7】</a></p><p id="f9bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/tj/commander.js/blob/master/tests/command.action.test.js" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://github . com/TJ/commander . js/blob/master/tests/command . action . test . js</em></a></p><p id="1f36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nc">更多内容看</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nc">说白了。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。关注我们</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nc">Twitter</em></strong></a><em class="nc">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nc">LinkedIn</em></strong></a><em class="nc">。加入我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nc">社区</em> </strong> </a> <em class="nc">。</em></strong></a></p></div></div>    
</body>
</html>