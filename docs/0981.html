<html>
<head>
<title>Merge Two Sorted Linked Lists in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中合并两个排序的链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/merge-two-sorted-linked-lists-3431ab9a778f?source=collection_archive---------5-----------------------#2022-02-24">https://javascript.plainenglish.io/merge-two-sorted-linked-lists-3431ab9a778f?source=collection_archive---------5-----------------------#2022-02-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9bd1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在JavaScript中合并两个排序链表(LeetCode Challenge)。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9e86d5f4eeb156fa45e196dab88b06ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCv2t1XNBybSrcO9RMRnKg.jpeg"/></div></div></figure><p id="7519" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将是一个简单易懂的递归方法来合并两个排序链表。虽然LeetCode把这个问题归类为容易，但实际上我发现它比他们的一些中级挑战更有挑战性。</p><p id="a4d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于对数据结构比较陌生，我对链表的看法是:<strong class="kq io"> <em class="lk">它们很奇怪。</em>T3】</strong></p><p id="aeb1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作为如此简单的结构，在它们被图形化地描绘和它们实际嵌套的自我之间有一种违反直觉的脱节。</p><h2 id="c6a4" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> <em class="me">想通了</em> </strong></h2><p id="c394" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">一句话:</p><p id="ba70" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我需要在两个列表中移动，比较值，并将它们拼接成一个结果列表。</p><p id="fff8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我想到的第一个挑战是，如果列表是两个不同的长度会怎么样？或者一个中的值都小于另一个中的值？基本上，我应该如何处理不均匀遍历？</p><p id="5837" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是两种潜在情况的示意图。一个可能看起来不如另一个直观:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mk"><img src="../Images/b363306c0b409628a12dfdf6cf2bea22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3XvsmU9lIXMUkTLJsb8Fw.jpeg"/></div></div></figure><p id="f34b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在左边的场景中，这似乎是以平衡/交替的方式进行的。几乎就像两个列表被“压缩”成一个列表。</p><p id="1a38" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在右边的场景中，一个列表完全在另一个之前。这也是对我来说最具挑战性的部分——不平坦的遍历。</p><p id="6e5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先是伪代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ml"><img src="../Images/d56de95778bc2531e66f7a88030908c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3bWy-e_YqzV8aRi5k-QkA.png"/></div></div></figure><p id="7966" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您会注意到两个主要的条件块。</p><p id="ab60" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最上面的程序块正在检查我们是否到达了列表的末尾。如果我们有，那么这意味着结果的余数必须是列表的余数。</p><p id="2195" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">底部的块比较每个列表的当前节点中的值。将较小的一个加到结果中。我只会在这个列表上更进一步。我这样做只是因为这种认识让整个过程对我来说变得更加直观。</p><p id="fef1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7c67" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">瞧！</em></p><p id="0322" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的两个列表已经按照期望的顺序编织在一起。</p><p id="b9e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容请看</em><a class="ae mo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a><em class="lk">。报名参加我们的</em> <a class="ae mo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。关注我们关于</em><a class="ae mo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">Twitter</em></strong></a><em class="lk">和</em><a class="ae mo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">。加入我们的</em> <a class="ae mo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">社区不和谐</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>