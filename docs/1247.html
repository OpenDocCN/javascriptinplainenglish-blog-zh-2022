<html>
<head>
<title>The Most Common Mistake in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应中最常见的错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-most-common-mistake-in-react-144603145248?source=collection_archive---------3-----------------------#2022-03-11">https://javascript.plainenglish.io/the-most-common-mistake-in-react-144603145248?source=collection_archive---------3-----------------------#2022-03-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d224a6e901faaa470df717cce835dce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uuL4eU50_E_tOPaL"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">CHUTTERSNAP</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8bd4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在React应用程序中需要解决的最常见的问题之一是获取外部数据。一般来说，这是你要学习如何解决的第一个问题，但是大多数实现都犯了一个简单的错误，<strong class="kc io">更新一个卸载组件的状态</strong>。</p><p id="fb80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将从一个非常简单的例子开始，一个博客组件获取与文章相关的数据，在获取过程中显示加载消息，在出现错误时显示错误，在另一种情况下显示文章列表。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c4f7" class="lh li in ld b gy lj lk l ll lm">const Blog = () =&gt; {<br/>  const [posts, setPosts] = useState([]);<br/>  const [status, setStatus] = useState('idle');<br/>  const [error, setStatus] = useState(null);</span><span id="f08c" class="lh li in ld b gy ln lk l ll lm">  useEffect(() =&gt; {<br/>    const fetchData = async () =&gt; {<br/>      setStatus('loading');<br/>      try{<br/>        setStatus('loading');<br/>        const posts = await getAllPosts();<br/>        setPosts(posts);<br/>        setStatus('finished');<br/>       } catch(e) {<br/>         setStatus('error');<br/>         setError(e);<br/>       }<br/>    }</span><span id="82ea" class="lh li in ld b gy ln lk l ll lm">    fetchData();<br/>  }, []);</span><span id="6e2b" class="lh li in ld b gy ln lk l ll lm">  if(status == 'error') return &lt;p&gt;Error while loading data&lt;/p&gt;;<br/>  if(status == 'loading') return &lt;p&gt;Loading...&lt;p&gt;;<br/>  return &lt;PostGrid posts={posts} /&gt;<br/>};</span></pre><p id="1470" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是可以的，在大多数情况下有效，但是存在一个问题…</p><p id="d56f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lo lp lq ld b">getAllPosts</code>函数是一个正在等待的异步函数，这个函数可能需要几秒钟才能返回，当它返回时，代码试图调用<code class="fe lo lp lq ld b">setPosts</code>函数，但是当组件在此之前被卸载时会发生什么呢？。您会收到警告，因为您无法设置已卸载组件的状态。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5f18" class="lh li in ld b gy lj lk l ll lm">const posts = await getAllPosts();<br/>setPosts(posts);  <strong class="ld io"># Warning: Can't perform a React state update on an unmounted component.</strong><br/>setStatus('finished');</span></pre><p id="0bc1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">如何修复问题？</strong></p><p id="8783" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关键是只有当组件被挂载时才设置状态，在这种情况下，你需要确保组件在<code class="fe lo lp lq ld b">getAllPosts</code>被调用后被挂载。为此，我们将使用一个抽象机制的钩子来检查当前组件是否已安装。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1cff" class="lh li in ld b gy lj lk l ll lm">const useIsMounted = () =&gt; {<br/>  const isMounted = <strong class="ld io">React.useRef(false)</strong>;     // <strong class="ld io">(1)<br/>  </strong>React.useEffect(() =&gt; {<br/>    <strong class="ld io">isMounted.current = true;                // (2)</strong><br/>    return <strong class="ld io">() =&gt; isMounted.current = false;</strong>  // <strong class="ld io">(3)</strong><br/>  }, <strong class="ld io">[]</strong>);                                    // <strong class="ld io">(4)</strong><br/>  return isMounted.current;<br/>}</span></pre><p id="3600" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用一个<code class="fe lo lp lq ld b">useRef</code>钩子(1)，以确保当值<code class="fe lo lp lq ld b">isMounted</code>改变时，使用它的组件中不会触发重新呈现器。之后，我们使用<code class="fe lo lp lq ld b">useEffect</code>第一次渲染组件时，它将ref的值设置为<code class="fe lo lp lq ld b">true</code> (2)，换句话说，当前组件现在被挂载。之后，<code class="fe lo lp lq ld b">useEffect</code>钩子定义了一个清理函数(3)和一个空数组(4)作为依赖项，这意味着一旦组件被卸载，清理函数才会被触发。</p><p id="94c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以将它与您的原始组件一起使用</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d460" class="lh li in ld b gy lj lk l ll lm">const Blog = () =&gt; {<br/>  const [posts, setPosts] = useState([]);<br/>  const [status, setStatus] = useState('idle');<br/>  const [error, setStatus] = useState(null);<br/><strong class="ld io">  const isMounted = useIsMounted();</strong></span><span id="67aa" class="lh li in ld b gy ln lk l ll lm">useEffect(() =&gt; {<br/>    const fetchData = async () =&gt; {<br/>      setStatus('loading');<br/>      try{<br/>        const posts = await getAllPosts();<br/><strong class="ld io">        if(isMounted) {<br/>          setPosts(posts);                    // 1<br/>          setStatus('finished');<br/>        }</strong></span><span id="bd3e" class="lh li in ld b gy ln lk l ll lm">       } catch(e) {<br/>          <strong class="ld io">if(isMounted) {<br/>            setStatus('error');               // 2<br/>            setError(e);<br/>          }<br/>       </strong>}<br/>    }</span><span id="61a8" class="lh li in ld b gy ln lk l ll lm">    fetchData();<br/>  }, []);</span><span id="2071" class="lh li in ld b gy ln lk l ll lm">  if(status == 'error') return &lt;p&gt;Error while loading data&lt;/p&gt;;<br/>  if(status == 'finished') return &lt;PostList posts={posts} /&gt;<br/>  return &lt;p&gt;Loading...&lt;p&gt;;<br/>};</span></pre><p id="523f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个重要的注意事项是，您需要确保组件不仅在异步函数成功完成(1)时挂载，而且在它失败(2)时挂载，换句话说，在catch块中挂载。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h2 id="da69" class="lh li in bd ly lz ma dn mb mc md dp me kl mf mg mh kp mi mj mk kt ml mm mn mo bi translated"><strong class="ak">结论</strong></h2><p id="cfdf" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">试图更新一个卸载组件的状态是react应用中一个非常常见的问题，这个问题通常出现在你获取一些外部数据的时候，但是当你使用任何异步事件来触发完成后状态的一些变化的时候，同样的问题也会出现。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="da51" class="mu li in bd ly mv mw mx mb my mz na me nb nc nd mh ne nf ng mk nh ni nj mn nk bi translated">感谢阅读！</h1><p id="5beb" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">这就是这篇帖子的全部内容，希望内容已经合你意，下期见。</p><p id="ba06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nl">plain English . io</em></strong></a><em class="nl">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nl">免费周报</em> </strong> </a> <em class="nl">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nl">Twitter</em></strong></a><em class="nl">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nl">LinkedIn</em></strong></a><em class="nl">。加入我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nl">社区不和谐</em> </strong> </a> <em class="nl">。</em></p></div></div>    
</body>
</html>