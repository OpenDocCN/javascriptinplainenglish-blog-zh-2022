<html>
<head>
<title>How We Build a Component Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何构建组件库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-we-build-a-component-library-12735d09e131?source=collection_archive---------4-----------------------#2022-05-26">https://javascript.plainenglish.io/how-we-build-a-component-library-12735d09e131?source=collection_archive---------4-----------------------#2022-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ba6e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我们如何在我们的web设计系统中使用React、TypeScript、Bit和Design标记实现web UI组件库</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c6922cfd3ded31b42d564f1a30442c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-_wmttjI4P4yS2qnmhfSQ.png"/></div></div></figure><p id="9bc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">视觉一致性通常被认为是数字产品的“外观和感觉”。然而，在web应用的现代世界中，用户界面和UX之间的界限是模糊的，组件是视觉语言和用户体验的关键。</p><p id="9118" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当用户遇到不一致的设计或用户体验时，他们会感到困惑，这反过来会损害他们期望的目标完成率。简而言之，UI/UX的一致性对商业有益。它还能建立你的品牌，鼓励用户对你的产品和应用的热爱和忠诚。</p><p id="ca76" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了培养这种一致性，组织致力于建立一个设计系统。</p><p id="d25f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">传统上，设计系统是作为Figma等设计工具上的一组可视元素、风格指南以及React和TypeScript等技术实现的组件库来构建的。但那不是设计系统。</p><p id="77ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">设计系统远不止这些。这是组织中的组件经济，有助于每个人——设计师、开发人员、组件构建人员、产品构建人员——更快、更一致地协作和构建。</p><p id="1452" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这篇文章中，我将分享我们自己的团队是如何构建一个共享组件系统，并以此为基础来构建和设计我们的产品。</p><h1 id="c136" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">开发库:从单个包到可组合的组件系统</h1><p id="4866" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">在构建组件库时，您将构建一组组件，这些组件将随着时间的推移而变化和发展，并将分发给其他开发人员和团队，供他们在产品和应用程序中使用。</p><p id="7929" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对大多数人来说，它始于创建一个新的回购协议，并在其中构建一些组件。几乎瞬间，这就变成了“单一回购”，具有讽刺意味的是，它主要用于解决其他回购之间的代码共享。</p><p id="a66f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这篇文章讲述了我们如何构建一个共享组件系统。我们使用开源工具链<a class="ae mh" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank"> Bit </a>来构建和使用它。</p><p id="f65f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们采用了一种不同的范式，将组件而不是回购放在第一位。我们利用<a class="ae mh" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">可组合性</strong> </a>和<a class="ae mh" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank">开源工具链位</a>来开发和共享作为独立实体的组件。</p><p id="ac57" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着，开发人员不会因为不想放弃对产品路线图和开发的控制而采用包含一系列组件的包，他们将拥有一个组件市场，可以在他们的应用程序中找到、使用和扩展这些组件。</p><p id="0cac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于大约1000种不同的原因，一个可组合的范例更好；模块化软件更好，更易维护，更容易理解和修复，构建更快，测试更简单，扩展更快，协作更顺畅，等等。</p><p id="e845" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是在设计系统的背景下，它有一个更大的优势:更容易被采用。对于设计系统来说，采用就是一切。</p><p id="e8e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">可组合性还开启了许多伟大的工作流，以解决和改进各种领域，如主题化、标记和样式化；我们用标记创建主题，这些标记可以用“无样式”的组件组合来创建任何东西。</p><p id="50bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有一个例子:</p><p id="cf30" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看看我们的可组合组件的“基本反应”范围。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/base-react"><div class="gh gi kc"><img src="../Images/c6922cfd3ded31b42d564f1a30442c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-_wmttjI4P4yS2qnmhfSQ.png"/></div></a></figure><div class="mi mj gp gr mk ml"><a href="https://bit.cloud/teambit/base-react" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">teambit / base-react:用于可组合应用程序的非风格化、共享的react基础组件</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">用于模块化web的无样式、通用的React基础组件。实验性的。组件:主题提供者，图像，网格…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">bit.cloud</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz km ml"/></div></div></a></div><p id="bbc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些是我们共享的基本ui组件，但是没有样式。为了对它们进行样式化，我们使用了来自“设计”范围的主题和标记。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/design"><div class="gh gi na"><img src="../Images/66ab555573834290f58c99d2bf0f2cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kM3Dus3_WJuyfEg-u0D8vw.png"/></div></a></figure><div class="mi mj gp gr mk ml"><a href="https://bit.cloud/teambit/design" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">teambit / design: Bit的设计组件，用于跨产品设计我们的UI元素</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">Bit的设计组件，用于构建bit.dev和bit.cloud。组件:复选框-项目，按钮，颜色选择器，反应…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">比特云</p></div></div><div class="mu l"><div class="nb l mw mx my mu mz km ml"/></div></div></a></div><p id="7fcc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过可组合性，我们创建了一个共享组件的系统，我们可以跨产品使用它来更快地开发并确保一致性。</p><p id="94d7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">甚至依赖它们的具体功能也可以在许多不同的应用程序中共享和使用，因为它们都只是(经过验证、发布的)组合。</p><p id="7870" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的图书馆更像“iTunes ”,而不是一个硬包装的CD-Rom，这意味着我们的组织享受着一个活跃的、不断增长的、协作的组件经济，这些组件被快乐开发的跨组织采用。</p><h1 id="c8c3" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们如何开发和版本化组件</h1><p id="e288" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们不会讨论如何<a class="ae mh" href="https://bit.dev/docs/getting-started/installing-bit/installing-bit" rel="noopener ugc nofollow" target="_blank">开始使用组件工作空间</a>，而是向您展示当您以模块化方式构建组件时，开发、共享和协作组件是多么容易。</p><p id="6efc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Bit的工作空间让我们可以动态地创建和获取我们想要开发的组件。它可以在任何文件夹中生成，不管您正在处理哪个repo。这对开发组件非常有用。</p><p id="3bca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">简而言之:我们建造像乐高一样的组件，我们不会在一个回购中把它们粘在一起，除非有一个好的理由。</p><p id="b303" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">可以使用<code class="fe nc nd ne nf b">bit create</code>开发新组件，或者可以使用<code class="fe nc nd ne nf b">bit fork</code>派生和修改现有组件，如下所示:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="630c" class="nk ll in nf b gy nl nm l nn no">$ bit fork teambit.base-react/buttons/button</span></pre><p id="6169" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个工作空间都会跟踪bit.map文件中的组件:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="b9a8" class="nk ll in nf b gy nl nm l nn no">{<br/>    "buttons/button": {<br/>        "scope": "",<br/>        "version": "",<br/>        "mainFile": "index.ts",<br/>        "rootDir": "component-library/buttons/button"<br/>    },</span></pre><p id="53b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">任何时候你都可以运行<code class="fe nc nd ne nf b">bit start</code>来打开工作区UI并可视化组件，查看代码、文档、版本、测试、例子等等。</p><p id="bdd8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您还可以运行<code class="fe nc nd ne nf b">bit status</code>来查看工作区中所有组件的状态。这里有一个虚构的例子，显示了对这样一个工作区的快速状态检查:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="973c" class="nk ll in nf b gy nl nm l nn no">$ bit status</span><span id="0547" class="nk ll in nf b gy np nm l nn no">staged components<br/> (use "bit export &lt;remote_collection&gt; to push these components to a remote Collection")</span><span id="67d0" class="nk ll in nf b gy np nm l nn no"> &gt; buttons/button. versions: 0.0.1, 0.0.2, 0.0.3 ... ok<br/> &gt; layout/grid. versions: 0.0.1 ... ok<br/> &gt; pages/page. versions: 0.0.1, 0.0.2 ... ok</span><span id="d343" class="nk ll in nf b gy np nm l nn no">modified components<br/> (use "bit tag --all [version]" to lock a version with all your changes)<br/> (use "bit diff" to compare changes)</span><span id="0b83" class="nk ll in nf b gy np nm l nn no">&gt; navigation/link ... ok</span></pre><p id="d9ff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以在任何时候运行<a class="ae mh" href="https://bit.dev/docs/workspace/workspace-status" rel="noopener ugc nofollow" target="_blank">位状态</a>来获得您的工作空间的概述:哪些组件已经被修改并且正在等待标记，哪些组件已经暂存并且正在等待导出，以及是否遇到了任何错误。</p><p id="535c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">是时候给<a class="ae mh" href="https://bit.dev/docs/components/tags" rel="noopener ugc nofollow" target="_blank">贴上</a>我们按钮的第一个版本了。键入以下命令:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="7449" class="nk ll in nf b gy nl nm l nn no">$ bit tag buttons/button -m "first version"</span></pre><p id="ea85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在没有指定组件的情况下运行<code class="fe nc nd ne nf b">tag</code>命令将标记工作区中所有修改的组件。</p><p id="b778" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当标记一个组件时，编译、测试和构建就完成了。这不仅适用于您编辑和标记的组件；依赖于该组件每个组件也将被标记为新版本。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/base-react/buttons/button"><div class="gh gi nq"><img src="../Images/9b2b4abc52e9490927d69d2f19f389c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lMqAjBPbtX5DQ1cDz2pkA.png"/></div></a><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Travel back to older versions of any component; Rollback in production!</figcaption></figure><p id="54d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个组件的版本控制对于设计系统非常有用。更多<a class="ae mh" href="https://medium.com/eightshapes-llc/versioning-design-systems-48cceb5ace4d" rel="noopener">此处</a>和<a class="ae mh" href="https://blog.bitsrc.io/versioning-independent-ui-components-why-and-how-7ea60d8be5f2" rel="noopener ugc nofollow" target="_blank">此处</a>阅读。你能希望的最好的事情是组织中的其他团队采用你的组件；如果所有的组件都被一起版本化，那么这就不会发生，安装lib的人将会在每一个不相关的变更上获得版本更新(触发他们项目的CI)。</p><p id="e7ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意:要在项目/开发人员之间共享组件，您需要在远程范围内托管它们。你可以在自己的服务器上设置一个，或者免费使用<a class="ae mh" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> bit.cloud </a>。你的选择。</p><h1 id="204e" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们如何处理组件依赖关系</h1><p id="c056" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><a class="ae mh" href="https://bit.dev/docs/dependencies/dependencies-overview" rel="noopener ugc nofollow" target="_blank">依赖关系</a>是组件(最终是应用程序)组合和集成的方式。</p><p id="5ea1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Bit简化了定义和更新工作空间中组件之间的依赖关系的过程。</p><p id="452a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是按钮组件的例子，这一次是在单击“依赖项”选项卡视图时。如您所见，它导入了“link”组件，该组件又使用了“compare-url”组件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/df8e63eb256899a4c052de84fe83791c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqFTyUbk25CTQliyBaq-8g.png"/></div></div></figure><p id="a170" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每当您修改一个组件并用新版本对其进行位标记时，所有依赖于它的组件(工作区)也将被测试、构建和更新。这意味着“增量”图驱动构建将触发所有组件，这些组件受到它们所依赖的组件的任何变化的影响。</p><p id="98d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，在上面的例子中，如果您分叉并修改“link”组件，然后运行<code class="fe nc nd ne nf b">bit status</code>，您将看到“button”也将挂起一个新版本:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="1b0b" class="nk ll in nf b gy nl nm l nn no">modified components<br/>(use "bit tag --all [version]" to lock a version)<br/>(use "bit diff" to compare changes)<br/><br/>     &gt; navigation/link ... ok<br/><br/>components pending to be tagged automatically (when their dependencies are tagged) &gt; buttons/button ... ok</span></pre><p id="1e9e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您正在使用bit.cloud，那么很快您就可以使用Ripple CI(现在处于封闭测试阶段),它将这一传播过程扩展到组织中的所有组件和团队，以持续集成一切。</p><p id="408c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经使用它来更新我们不同项目的共享组件。下面先睹为快:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/b3b31d7a7fcccf25b7ed0fbb52a5e2db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVncX4iCUy3KlZ6bFm-xTQ.png"/></div></div></figure><h1 id="ecb2" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们如何主题化和样式化组件</h1><p id="19c2" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这里有些很酷的东西。使用主题化和标记以模块化的方式设计组件，就像乐高积木一样。这意味着我们的组件(参见上面的base-react范围)基本上没有样式(无意冒犯，组件)，我们的<a class="ae mh" href="https://bit.cloud/blog/design-tokens-in-components-with-react-and-bit-l28qlxq6" rel="noopener ugc nofollow" target="_blank">使用设计令牌的主题化组件</a>为它们提供了可以跨许多组件、页面和应用程序轻松更改或替换的样式。</p><div class="mi mj gp gr mk ml"><a href="https://bit.cloud/teambit/design/themes/base-theme" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">设计/主题/基础主题</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">钻头设计语言的标准主题。标上位，主题，设计，底座。属性:覆盖，子级…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">比特云</p></div></div><div class="mu l"><div class="nx l mw mx my mu mz km ml"/></div></div></a></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/design/themes/base-theme"><div class="gh gi ny"><img src="../Images/4b4e8d76169ca300c68a4fee0bd3140c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b48IE-lruG5dzTGLPiengA.png"/></div></a></figure><p id="8605" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用这样的主题，我们可以随心所欲地“即插即用”主题和风格，这使得设计师也很容易成为积极的贡献者(感谢我们的主题中的<a class="ae mh" href="https://blog.bitsrc.io/how-we-use-design-tokens-in-react-5396dd897ace?gi=8e35db851566" rel="noopener ugc nofollow" target="_blank">设计标志)。让我们看看如何使用一个主题！</a></p><p id="f542" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在一个工作区中(有一些像上面的按钮一样的组件),克隆主题和主题提供者:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="1b87" class="nk ll in nf b gy nl nm l nn no">$ bit fork teambit.base-react/theme/theme-provider</span><span id="375a" class="nk ll in nf b gy np nm l nn no">$ bit fork teambit.design/themes/base-theme</span></pre><p id="8dc4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后只需将主题导入主题提供程序，并更改标记以匹配您的风格！可组合性使一切变得非常简单。</p><h1 id="c25d" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们如何构建和测试组件</h1><p id="7a38" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这是一个非常有趣的问题。</p><p id="de80" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在Bit中，每个组件都是在一个“<a class="ae mh" href="https://bit.dev/docs/envs/envs-overview" rel="noopener ugc nofollow" target="_blank">开发环境</a>中开发的，这个开发环境也是一个组件。这听起来很复杂，但实际上非常简单。</p><p id="1b77" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着你可以定义你希望组件如何被编译、测试等等，然后很容易地重用这些配置。</p><p id="dbed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个组件都是在各自的环境中独立开发、构建和测试的。因此，当某个东西失败时，您可以准确地了解它是在哪里以及是什么原因造成的。而且，您只构建了发生变化的组件——其他什么都没有。)因此，在avg项目上，构建可以快10倍。</p><p id="ec58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">构建在标签上运行。由于Bit知道组件之间所有依赖关系的图，它可以确保当一个组件被标记上新版本时，该组件及其所有依赖组件(沿着图向上传播)也将被标记并被构建和测试。</p><p id="35d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回头看看上面的按钮示例:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="a84a" class="nk ll in nf b gy nl nm l nn no">$ bit build --list-tasks buttons/button</span><span id="76bf" class="nk ll in nf b gy np nm l nn no">Tasks List<br/>id: nitsan770.component-library/buttons/button@0.0.5<br/>envId: teambit.react/react<br/><br/>Build Pipeline Tasks:<br/>teambit.harmony/aspect:CoreExporter<br/>teambit.compilation/compiler:TSCompiler<br/>teambit.defender/tester:TestComponents<br/>teambit.pkg/pkg:PreparePackages<br/>teambit.harmony/application:build_application<br/>teambit.preview/preview:GenerateEnvTemplate<br/>teambit.preview/preview:GeneratePreview<br/><br/>Tag Pipeline Tasks:<br/>teambit.pkg/pkg:PackComponents<br/>teambit.pkg/pkg:PublishComponents<br/>teambit.harmony/application:deploy_application<br/><br/>Snap Pipeline Tasks:<br/>teambit.pkg/pkg:PackComponents<br/>teambit.harmony/application:deploy_application</span></pre><p id="69ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">测试组件的<a class="ae mh" href="https://bit.dev/docs/dev-services/tester/tester-overview" rel="noopener ugc nofollow" target="_blank">也是如此。</a></p><p id="cf6a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以使用任何您喜欢的工具(例如Jest)来测试组件，并将测试定义为标记过程的一部分，这样，无论何时您对组件进行更改，依赖关系图中所有受影响的组件都将被单独测试。</p><p id="aa49" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事实上，您可以使用:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="b9b1" class="nk ll in nf b gy nl nm l nn no">bit test --watch</span></pre><p id="3bcd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让测试在本地工作区中对您的组件所做的每一个更改上运行，并在工作区UI中看到它，这样您就可以总是知道哪些组件(在图中)可能会在您所做的每一个更改上中断——在开发时间期间<strong class="kq io">！赋予了TDD新的含义，不是吗？</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/base-react/buttons/button/~tests"><div class="gh gi nz"><img src="../Images/38925609039611f5e0372e9d05282ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKPHIn9kArG8zCkYNwbNLw.png"/></div></a></figure><h1 id="79f4" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">保持更新的可定制文档</h1><p id="21f9" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">所以接下来的部分被广泛忽视了，因为大多数人认为添加视觉例子或故事就可以了，仅此而已。诚然，可视化的例子和故事是开发和记录组件的好方法，但是文档实际上远不止这些。</p><ol class=""><li id="5669" class="oa ob in kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">文档必须是组件的一部分，而不是外部的，应该包括道具、测试和返回旧版本的选项</li><li id="eb9d" class="oa ob in kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">它们必须根据需要随组件的每个新版本(在Bit中进行版本控制)进行更新</li><li id="e52e" class="oa ob in kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">它们应该是可定制的和可扩展的，由于MDX，它们可以包含任何特性或其他组件。</li></ol><p id="3283" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那个；这正是Bit的作用——当您在本地工作区开发组件并运行“bit start”打开工作区UI时，您可以查看在您编码时实时生成和更新的文档。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/base-react/buttons/button"><div class="gh gi oo"><img src="../Images/fe99fad44b8f856cdd3a8d977d4d27c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pCgIiIUUfm-m1rqyD4Obqg.gif"/></div></a></figure><p id="2f72" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以在文档本身中添加可视示例、道具表、描述或任何其他类型的文档特性/组件。</p><p id="1959" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，在您将您的组件共享到一个范围后，这些文档提供了组件的可见性和可用性，而无需创建和维护任何外部或额外的文档网站。而且，它们将随着每个新组件版本的发布而更新。太好了。</p><p id="bb14" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是React中真正的基本UI组件集，我们将其用作基础。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/base-react"><div class="gh gi op"><img src="../Images/04e9a35054f00d207117539b9f0560fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-NIyu7LpYi2mOAkl7E3Zg.png"/></div></a></figure><h1 id="6c2b" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们如何分发和共享组件</h1><p id="02af" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这里事情变得更加有趣。</p><p id="64c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们不仅仅是构建和发布一个组件库。</p><p id="9592" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">说实话，我们用组件构建一切，前端和后端都一样。团队拥有业务职责(“搜索”、“ui”、“计费”等)，并使用Bit将它们构建在组件中，而每个团队在“范围”中共享其组件——我们所有的范围<a class="ae mh" href="https://bit.cloud/teambit/~scopes" rel="noopener ugc nofollow" target="_blank">都托管在bit.cloud </a>上，但也可以放在任何其他服务器上，就像Git一样。如果你看一下我们的范围，你会清楚地看到我们构建了什么特性，以及哪些团队构建了它们。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/~scopes"><div class="gh gi oq"><img src="../Images/26fcd752a3d69f57d19797d9f7a8e5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zg2oz0m8laYoRbhCIDd97A.png"/></div></a></figure><p id="adb0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，您可以通过在图表上查看谁在使用谁的组件来可视化所有范围(和团队)之间的依赖关系。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/~scope-graph"><div class="gh gi or"><img src="../Images/a397f58f14fdbc0a267850e84757d11c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAJUsElnv_NFnYgb9P6hbg.png"/></div></a></figure><p id="ffa7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们看一下<a class="ae mh" href="https://bit.cloud/teambit/base-react" rel="noopener ugc nofollow" target="_blank">base-react scope</a>——我们的样式UI组件“库”——你可以看到它与“设计”有着密切的联系，这是有意义的，这是所有主题的所在，并且与其他UI密集型项目有着密切的联系。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/~scope-graph"><div class="gh gi os"><img src="../Images/18a054907621c2d3c437a06f60b67970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oq9gWZ6XhXJRY2ZVD_3H0Q.png"/></div></a></figure><p id="5e52" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有几个非常酷的望远镜。这两种产品都使用我们的设计系统(base-react + design)中的组件作为依赖项来创建集成和协作。</p><ol class=""><li id="ad52" class="oa ob in kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">社区范围——我们用来在bit.dev上构建开源社区网站的组件。自然，这个范围使用了base-react和design scopes中的一些组件。</li></ol><div class="mi mj gp gr mk ml"><a href="https://bit.cloud/teambit/community" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">teambit / community:开发者社区开源网站。</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">开发者社区开源网站。组件:文本工具提示，创建部分，功能，github-明星。72…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">比特云</p></div></div><div class="mu l"><div class="ot l mw mx my mu mz km ml"/></div></div></a></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/community"><div class="gh gi ou"><img src="../Images/acff07ef1346c04daf71d9b21a423dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Qq2qOSGnLl5MB5o7Takng.png"/></div></a></figure><p id="c18a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.博客范围，我们主机的所有组件用于建立在bit.cloud/blog.的博客，我们也使用从那里的设计系统组件。</p><div class="mi mj gp gr mk ml"><a href="https://bit.cloud/teambit/blog" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">teambit /博客</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">组件:英雄，组件可扩展性，引入组件驱动软件，后列表。52个组件和3个…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">比特云</p></div></div><div class="mu l"><div class="ov l mw mx my mu mz km ml"/></div></div></a></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://bit.cloud/teambit/community"><div class="gh gi ow"><img src="../Images/fe2f8aafbdcf93060b678798db9d91b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZZmdrdcY1PTzeeApUfPPg.png"/></div></a></figure><p id="92dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">范围是组件所在的位置:</p><ol class=""><li id="4b53" class="oa ob in kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">款待</li><li id="1ed1" class="oa ob in kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">共享的</li><li id="4235" class="oa ob in kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">版本化和更新</li><li id="2a77" class="oa ob in kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">使可见成为可发现的</li><li id="dde3" class="oa ob in kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">消费和使用自</li></ol><p id="038b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以使用“位导出”将组件直接共享到远程作用域，然后在许多不同的项目和人员之间共享和访问它们。</p><p id="2020" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以<a class="ae mh" href="https://bit.dev/docs/getting-started/collaborate/remote-scope" rel="noopener ugc nofollow" target="_blank">在bit.cloud(免费)上创建一个远程作用域，并在您工作区的workspace.json文件中配置它</a>，如下所示:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="c8cc" class="nk ll in nf b gy nl nm l nn no">{<br/>  "teambit.workspace/workspace": {<br/>    "defaultScope": "your-username.demo-scope"<br/>  }<br/>}</span></pre><p id="ba26" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">后来，在改变作用域时，“位链接”可以派上用场。</p><p id="9f7d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在创建并定义了一个范围之后，这里有一个将上述组件从您的本地工作区导出到您创建的范围的示例</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="9390" class="nk ll in nf b gy nl nm l nn no">$ bit export</span><span id="3772" class="nk ll in nf b gy np nm l nn no">exported the following 4 component(s):<br/>nitsan770.component-library/navigation/link<br/>nitsan770.component-library/themes/base-theme<br/>nitsan770.component-library/theme/theme-provider<br/>nitsan770.component-library/buttons/button=</span></pre><p id="8505" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦在范围内，组件可以在许多不同的项目中使用——并且可以用范围内的新版本进行更新！</p><h1 id="7904" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们如何发现、消费和使用组件</h1><p id="980b" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">云上的每个组件都有一个“使用”按钮。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/97d6e983d3c8f03d1e1d264195020e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUsiwN_VD-lEpp4aPjLc-w.png"/></div></div></figure><p id="1338" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“使用”按钮为开发人员提供了多种使用组件的方式。例如，他们可以从免费的bit.cloud注册表或任何其他注册表中将它作为一个包安装。他们还可以使用“bit fork”将组件分支到他们的工作区中，并对其进行编辑，然后标记一个新版本。</p><div class="kd ke kf kg gt ab cb"><figure class="oy kh oz pa pb pc pd paragraph-image"><img src="../Images/b2bb31a20a0d619bfabef766ef37c92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*X73H8oLKko0UXo51azpvkg.png"/></figure><figure class="oy kh pe pa pb pc pd paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/1ea26bb0d2896b2f8ea5c84fcc16345d.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*OIs0q97iP1IGwprG5Wg9TQ.png"/></div></figure></div><p id="cdea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将一个组件提取到您的工作区之后，您也可以从任何其他组件导入并使用它。)—创建无限量的不同组件扩展并放在一起的组合。</p><p id="a339" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个非常酷的例子(拖放组件):</p><div class="mi mj gp gr mk ml"><a href="https://bit.cloud/blog/extendable-uis-how-to-build-better-uis-for-developers-l1jkl1pc" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">可扩展的UI组件</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">我最近受命为bit.cloud平台构建一个用户卡组件。我还负责建造…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">比特云</p></div></div><div class="mu l"><div class="pf l mw mx my mu mz km ml"/></div></div></a></div><h2 id="e8b6" class="nk ll in bd lm pg ph dn lq pi pj dp lu kx pk pl lw lb pm pn ly lf po pp ma pq bi translated">收养收养收养</h2><p id="3d42" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">当你告诉人们“嗨，用这个包吧！”—他们愿意，但他们真的不能。为什么？因为他们不能放弃对产品开发的控制权。</p><p id="0719" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">他们中的一些人甚至想使用设计系统组件；但是，如果他们产品的PM需要改变，会发生什么呢？</p><p id="8944" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，DSs努力争取被采用。</p><p id="9d3c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Bit对我们帮助创建共享组件的采用大有帮助:</p><p id="28ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">A.通过使使用任何包管理器或位来安装组件变得容易，这也提供了将组件“分支”到本地工作区以供使用和根据需要进行编辑的选项——这确实有助于采用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/d41301bf698ae350c00fd55efd7838e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*OIs0q97iP1IGwprG5Wg9TQ.png"/></div></figure><p id="6540" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">b.当人们只安装一个组件时，他们不会给他们的项目增加多余的重量，也不会得到他们不使用的代码的更新(触发CI)。而且，他们不必添加多余的依赖项。</p><h1 id="f591" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">组件更新</h1><p id="b2f1" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">每当设计系统团队想要发布更新时，他们可以简单地将组件分支到他们的工作区，并对代码进行更改。</p><p id="8f67" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，他们所要做的就是标记一个新版本(注意，bit也会自动标记所有受影响的依赖组件)并将其导出到范围中。</p><p id="7cef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，当团队和开发人员使用该组件时——仍然在旧版本上——将运行“位安装”,他们将获得所有最新版本的更新！</p><p id="bf3f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">简单吧？然而，大规模的工作流程可能会很累。因此，我们目前正在使用我们开发的一个新工具，名为“Ripple CI”，它将更新跨范围传播到组件，持续集成组织…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/b3b31d7a7fcccf25b7ed0fbb52a5e2db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVncX4iCUy3KlZ6bFm-xTQ.png"/></div></div></figure><p id="a6cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Ripple目前正处于封闭测试阶段，由我们自己的团队和一些选定的组织使用它在全球范围内进行构建。它应该会在2022年晚些时候发布，同时还有一个免费版本。</p><h1 id="e1a6" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">治理和协作</h1><p id="599e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">组件经济意味着你“民主化”,鼓励组件的采用和协作，同时提供监管工具。</p><p id="c985" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在Bit Cloud上，我们可以“验证”我们信任的组件，并推荐开发人员在他们的项目中使用:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/97d6e983d3c8f03d1e1d264195020e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUsiwN_VD-lEpp4aPjLc-w.png"/></div></div></figure><p id="afa9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Bit还提供了一些工具，如称为“开发环境”的可重用模板，帮助开发人员标准化组件的开发、构建、测试、链接、文档化、发布等方式(和工具)。</p><p id="f1e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们使用许多这样的工具和工作流，但是现在我想分享两个:一个用于治理组件，另一个用于协作。</p><p id="3f3f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一个特性是“经过验证的组件”——这非常简单，它让组织中的管理员可以验证哪些组件可以使用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oo"><img src="../Images/54487f8f627474dd7d37b2bb589edf4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rkLtVh6lnV9odDQVfcqISQ.gif"/></div></div></figure><p id="c3e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二个特性是建议改变和协作，它被称为:“<a class="ae mh" href="https://bit.dev/docs/lanes/lanes-overview" rel="noopener ugc nofollow" target="_blank"> Lanes </a>”。</p><p id="0ccf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Lanes基本上类似于Git分支，只是对于组件图而言。</p><p id="1c43" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，如果“按钮”依赖于“链接”,而你想改变两者，把它们分支到你的工作区，打开一个通道，<a class="ae mh" href="https://bit.dev/docs/lanes/switching-lanes" rel="noopener ugc nofollow" target="_blank">捕捉</a>这些改变，<a class="ae mh" href="https://bit.dev/docs/lanes/export-lane" rel="noopener ugc nofollow" target="_blank">导出改变</a>。</p><p id="bcb0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这听起来很容易也很简单——如果你有许可的话。</p><p id="d8bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果没有，您可以捕捉并发送建议的更改，而不发送版本以供审阅。</p><p id="d338" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这比去另一个库，一头扎进一个巨大复杂的代码库，最终制作一个PR然后等待要容易得多。</p><h1 id="d85b" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">结论</h1><p id="84ad" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">设计系统不是一个内部实现了一堆组件和一个匹配包的仓库。</p><p id="ba51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它是一个活的、振动的、协作的、变化的、高度可组合的组件集，您最终希望您组织中的人们去发现、理解、选择、使用，甚至理想地为之做出贡献。</p><p id="b6b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着你不仅仅是在构建一个组件库；你正在建立一个组件经济。你越早意识到这一点并致力于构建它，你的共享组件系统就越有用。</p><p id="7acf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对我们来说，这意味着在React中构建一组基本的UI组件，它们都是无样式的，同时为主题(带有设计符号)和样式构建一组类似的组件。当人们可以将两者结合在一起，并使用他们自己的组件时，对他们来说，采用共享组件系统并更快地构建新东西，同时确保设计和体验的一致性，变得有趣而简单。</p><p id="07b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读，请随时评论或询问任何事情！</p><p id="35fb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi">🍻 🍺 💁‍♂</p></div><div class="ab cl ps pt hr pu" role="separator"><span class="pv bw bk pw px py"/><span class="pv bw bk pw px py"/><span class="pv bw bk pw px"/></div><div class="ig ih ii ij ik"><h2 id="2a07" class="nk ll in bd lm pg ph dn lq pi pj dp lu kx pk pl lw lb pm pn ly lf po pp ma pq bi translated">进一步阅读</h2><div class="mi mj gp gr mk ml"><a href="https://bit.cloud/blog/how-to-build-a-composable-blog-l1jkl9f4" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">如何建立一个可组合的博客</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">从头开始创建一个博客需要很多。有许多移动的部件组合在一起形成一个…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">比特云</p></div></div><div class="mu l"><div class="pz l mw mx my mu mz km ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://bit.cloud/blog/meet-component-driven-content-applicable-composable-l24cw7ku" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">满足组件驱动的内容:适用的、可组合的</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">自从React和Angular等技术出现以来，我们经常将术语“组件”与…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">比特云</p></div></div><div class="mu l"><div class="qa l mw mx my mu mz km ml"/></div></div></a></div><p id="9d8f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="qb">更多内容看</em><strong class="kq io"><em class="qb"/></strong><a class="ae mh" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="qb">说白了。报名参加我们的</em><strong class="kq io"><em class="qb"/></strong><a class="ae mh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="qb">免费周报</em> </strong> </a> <em class="qb">。关注我们</em><a class="ae mh" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="qb">Twitter</em></strong></a><em class="qb">和</em><a class="ae mh" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="qb">LinkedIn</em></strong></a><em class="qb">。</em></strong></a></p></div></div>    
</body>
</html>