<html>
<head>
<title>How to Implement Binary Heap in JavaScript in 2022?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年如何用JavaScript实现二进制堆？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-binary-heap-in-javascript-in-2022-6069402351d1?source=collection_archive---------10-----------------------#2022-04-28">https://javascript.plainenglish.io/how-to-implement-binary-heap-in-javascript-in-2022-6069402351d1?source=collection_archive---------10-----------------------#2022-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b7d9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">二进制堆数据结构完全指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/66807356293dc4b9d0af450999c83db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DyrEJ_iUYrwCA3UHY7u4Bg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">image by weekendtutorial.com</figcaption></figure><h2 id="a440" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">二元堆</h2><p id="116a" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">二进制堆是一种树形数据结构，它有两个属性</p><ol class=""><li id="7739" class="mh mi in lq b lr mj lu mk lb ml lf mm lj mn mg mo mp mq mr bi translated">应该是一棵<em class="ms">完美二叉树</em> <strong class="lq io"> <em class="ms">(又名结构-属性)</em> </strong></li><li id="237a" class="mh mi in lq b lr mt lu mu lb mv lf mw lj mx mg mo mp mq mr bi translated">树的每个节点应该≥或≤其子节点。换句话说，应该是<strong class="lq io">不是最小堆就是最大堆。</strong> ( <strong class="lq io"> <em class="ms">又名堆属性</em> </strong>)</li></ol><h2 id="7286" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">完美二叉树</h2><p id="6fda" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">一个几乎完成的二叉树，树的最后一层从左到右填充。</p><p id="244a" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">例如，在最大堆和最小堆中给出的树是一个完美的二叉树的例子。</p><p id="9b75" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io"> <em class="ms">注意:如果你之前没有看过二叉树，请查看</em> </strong></p><ol class=""><li id="cd95" class="mh mi in lq b lr mj lu mk lb ml lf mm lj mn mg mo mp mq mr bi translated"><a class="ae nb" href="https://weekendtutorial.com/binary-tree-and-its-traversal-in-javascript/" rel="noopener ugc nofollow" target="_blank">如何用JavaScript实现二叉树？</a></li><li id="6e9a" class="mh mi in lq b lr mt lu mu lb mv lf mw lj mx mg mo mp mq mr bi translated"><a class="ae nb" href="https://weekendtutorial.com/binary-tree-the-best-5-coding-questions-you-must-solve/" rel="noopener ugc nofollow" target="_blank">二叉树中的前5个基本必答题</a></li></ol><h2 id="5456" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">二进制堆的类型</h2><p id="5f99" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">二进制堆有两种类型—</p><ol class=""><li id="4924" class="mh mi in lq b lr mj lu mk lb ml lf mm lj mn mg mo mp mq mr bi translated">最大堆</li><li id="ca99" class="mh mi in lq b lr mt lu mu lb mv lf mw lj mx mg mo mp mq mr bi translated">最小堆</li></ol><h2 id="60eb" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">最大堆</h2><p id="a6bb" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">一种二进制堆，其中树的每个节点都大于或等于它的两个子节点。因此，树的根在所有节点中是最大的。</p><p id="3ea8" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">例如，下面的树是最大堆的示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f803e271e71bc40a30e0c9deb3f47b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*RvItG3S67zOm-dIfIOGB9A.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Binary Max Heap</figcaption></figure><h2 id="1edd" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">最小堆</h2><p id="df5d" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">一种二进制堆，其中树的每个节点都小于它的两个子节点。因此，树的根将是所有节点中最小的。</p><p id="8db6" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">例如，下面的树是一个最小堆的例子:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1832cc3bb9c5416552454ae64b94e488.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*dTuVseEh_SwYzImQDHBgXw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Binary Min Heap</figcaption></figure><h2 id="5f80" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">二元堆的表示</h2><p id="c81e" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">二进制堆可以由树节点列表和数组来表示。在本文中，我们将只关注二进制堆的数组表示。</p><p id="61c3" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">这里需要注意的要点是—</p><ol class=""><li id="2668" class="mh mi in lq b lr mj lu mk lb ml lf mm lj mn mg mo mp mq mr bi translated">树的根是Arr[0]</li><li id="1f2e" class="mh mi in lq b lr mt lu mu lb mv lf mw lj mx mg mo mp mq mr bi translated">对于任何指数I，</li></ol><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="7233" class="ks kt in ne b gy ni nj l nk nl">Parent index = (i-1)/2</span><span id="a462" class="ks kt in ne b gy nm nj l nk nl">Left child index = 2 * i + 1</span><span id="48ce" class="ks kt in ne b gy nm nj l nk nl">Right Child index = 2 * i + 2</span></pre><h2 id="898e" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">二元堆的应用</h2><ol class=""><li id="7182" class="mh mi in lq b lr ls lu lv lb nn lf no lj np mg mo mp mq mr bi translated">堆排序</li><li id="f4b6" class="mh mi in lq b lr mt lu mu lb mv lf mw lj mx mg mo mp mq mr bi translated">优先队列</li><li id="aac7" class="mh mi in lq b lr mt lu mu lb mv lf mw lj mx mg mo mp mq mr bi translated">图形算法(Dijkstra—最短路径算法，Prims — MST)</li><li id="5f42" class="mh mi in lq b lr mt lu mu lb mv lf mw lj mx mg mo mp mq mr bi translated">你需要在每次迭代后寻找最小值的问题，例如</li></ol><p id="d203" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">a) <a class="ae nb" href="https://leetcode.com/problems/kth-largest-element-in-an-array" rel="noopener ugc nofollow" target="_blank">数组中第k个最大的元素</a></p><p id="54d6" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">b) <a class="ae nb" href="https://leetcode.com/problems/task-scheduler" rel="noopener ugc nofollow" target="_blank">任务调度器</a></p><p id="cd2e" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">c) <a class="ae nb" href="https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array" rel="noopener ugc nofollow" target="_blank">数组中两个元素的最大乘积</a></p><p id="50f9" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">这是完整的列表— <a class="ae nb" href="https://leetcode.com/tag/heap-priority-queue/" rel="noopener ugc nofollow" target="_blank">堆问题</a></p><h2 id="969c" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">JavaScript中的二进制最小堆实现</h2><p id="5868" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated"><script src="”&lt;a" class="ae nb" href="https://gist.github.com/ajayv1/82bea3c569b80fc4c8cbb82b65505d7a.js" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ajay v1/82 bea 3c 569 b 80 fc 4c 8 cbb 82b 65505 d7a . js&lt;/a&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/root&gt;</script></p><p id="19f7" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io">用法(</strong>两种方法都产生有效的二进制最小堆<strong class="lq io"> ) </strong></p><p id="6e2f" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io">方法1: </strong>在堆中逐个插入数组元素。Heap <strong class="lq io"> insert </strong>函数内部调用函数<strong class="lq io"> heapifyUp </strong>。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="3c30" class="ks kt in ne b gy ni nj l nk nl">let pq = new PriorityQueue();</span><span id="fa47" class="ks kt in ne b gy nm nj l nk nl">let arr = [80,70,40,20,10,60,50,30];</span><span id="beb2" class="ks kt in ne b gy nm nj l nk nl">for (let i = 0; i &lt; arr.length; i++) {<br/>    pq.insert(arr[i]);<br/>}</span><span id="4a30" class="ks kt in ne b gy nm nj l nk nl">console.log('Heap using approach 1', pq);</span></pre><p id="05f7" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io">方法2: </strong>在堆中插入完整的数组元素(通过调用<strong class="lq io"> build_heap </strong>函数)。堆函数<strong class="lq io"> Build_heap </strong>调用函数<strong class="lq io"> heapify </strong>将堆整个堆。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="e2da" class="ks kt in ne b gy ni nj l nk nl">let pr = new PriorityQueue();</span><span id="d85a" class="ks kt in ne b gy nm nj l nk nl">pr.build_heap(arr);</span><span id="780f" class="ks kt in ne b gy nm nj l nk nl">console.log('Heap using approach 2', pr);</span></pre><p id="56b6" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io">结果</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/6a5508b33b762e55ab3ec72fffe49ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMwie7X3oKVamayepdz3MQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Binary Min Heap</figcaption></figure><h2 id="3eb1" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">JavaScript中的二进制最大堆实现</h2><p id="eaee" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated"><script src="”&lt;a" class="ae nb" href="https://gist.github.com/ajayv1/11fb38ca7c53e0979fcbcf14501684dc.js" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ajay v1/11 FB 38 ca 7c 53 e 0979 fcbf 14501684 DC . js&lt;/a&gt;"&amp;gt;&amp;lt;/script&amp;gt;&lt;/root&gt;</script></p><p id="aea9" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io">用法(</strong>两种方法都会产生有效的二进制最大堆<strong class="lq io"> ) </strong></p><p id="f9c3" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io">方法一:</strong>将数组元素逐个插入堆中。Heap <strong class="lq io"> insert </strong>函数内部调用函数<strong class="lq io"> heapifyUp </strong>。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="2c96" class="ks kt in ne b gy ni nj l nk nl">let pq = new BinaryMaxHeap();</span><span id="8810" class="ks kt in ne b gy nm nj l nk nl">let arr = [80,70,40,20,10,60,50,30];</span><span id="da4f" class="ks kt in ne b gy nm nj l nk nl">for (let i = 0; i &lt; arr.length; i++) {<br/>    pq.insert(arr[i]);<br/>}</span><span id="caaf" class="ks kt in ne b gy nm nj l nk nl">console.log('Heap using approach 1', pq);</span></pre><p id="be13" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io">方法2: </strong>在堆中插入完整的数组元素(通过调用<strong class="lq io"> build_heap </strong>函数)。堆函数<strong class="lq io"> Build_heap </strong>调用函数<strong class="lq io"> heapify </strong>将堆整个堆。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="8c6a" class="ks kt in ne b gy ni nj l nk nl">let pr = new BinaryMaxHeap();</span><span id="408b" class="ks kt in ne b gy nm nj l nk nl">pr.build_heap(arr);</span><span id="7a46" class="ks kt in ne b gy nm nj l nk nl">console.log('Heap using approach 2', pr);</span></pre><p id="d53e" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><strong class="lq io">结果</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/3c071b97b40a190ed70ad4161734bdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Q6Ib09KbZdqnMNny2kiuQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using Binary Max Heap</figcaption></figure><h2 id="a9fe" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">摘要</h2><p id="f5c8" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">有许多实际问题可以通过二进制堆数据结构轻松解决。这是所有计算机科学毕业生的必修课。</p><p id="59f6" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">在许多编程语言中，二进制堆是本机提供的，但了解核心实现并构建一个自定义实现是真正的学习。</p><p id="4098" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">本文中的代码(用JavaScript编写)可以导入到您选择的其他编程语言中。</p><p id="4e9b" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">试着用你喜欢的编程语言来构建它。</p><p id="6e4a" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">所有最新的帖子和文章，请访问网站<a class="ae nb" href="https://weekendtutorial.com/" rel="noopener ugc nofollow" target="_blank">https://weekendtutorial.com/</a></p><p id="7583" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated">继续学习，保持安全。</p><p id="213f" class="pw-post-body-paragraph lo lp in lq b lr mj jo lt lu mk jr lw lb my ly lz lf mz mb mc lj na me mf mg ig bi translated"><em class="ms">更多内容看</em> <strong class="lq io"> <em class="ms"> </em> </strong> <a class="ae nb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq io"> <em class="ms">说白了. io </em> </strong> </a> <em class="ms">。报名参加我们的</em> <a class="ae nb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq io"> <em class="ms">免费周报</em> </strong> </a> <em class="ms">。关注我们关于</em><a class="ae nb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lq io"><em class="ms">Twitter</em></strong></a><em class="ms">和</em><a class="ae nb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lq io"><em class="ms">LinkedIn</em></strong></a><em class="ms">。加入我们的</em> <a class="ae nb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lq io"> <em class="ms">社区</em> </strong> </a> <em class="ms">。</em></p></div></div>    
</body>
</html>