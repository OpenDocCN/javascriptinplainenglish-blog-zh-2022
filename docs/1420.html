<html>
<head>
<title>Replace React HOCs with Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用钩子替换反作用hoc</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/replace-react-hocs-with-hooks-401824eb7903?source=collection_archive---------3-----------------------#2022-03-23">https://javascript.plainenglish.io/replace-react-hocs-with-hooks-401824eb7903?source=collection_archive---------3-----------------------#2022-03-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4005" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">有必要吗？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3d7331b549714c707418cfce60b75cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rskr_eJIFLeoTyWo1oglKg.jpeg"/></div></div></figure><p id="9f8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React实施了一种声明式编程范式，这使它变得如此强大和伟大。由于React与DOM的交互方式(我们只描述JSX，React呈现我们想要看到的内容)，应用这种范式也使React以快速著称。</p><h2 id="32de" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">高阶函数</strong></h2><p id="a6cb" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">HOF是函数式编程的一个重要概念。</p><p id="3e0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在JavaScript中，函数是一级对象，这意味着它们可以赋给变量，可以作为参数传递给其他函数，并从它们返回。</p><p id="efdc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mi"> HOF是一个以函数为参数和/或返回函数的函数(通常用特殊行为增强)。</em></p><p id="5814" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看一个简单的例子:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mj"><img src="../Images/48953641b5cc57c4a55f4d8758865e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vDQH6S2Hya5_xJCjFfSAQ.png"/></div></div></figure><p id="4f54" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们在前面的代码中看到的，map()方法接受一个函数作为参数，因此它是一个高阶函数。同理，数组filter()、find()、reduce()的内置函数都是高阶函数。</p><h2 id="f8dc" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">高阶元件</strong></h2><p id="36e9" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><em class="mi">hoc是纯函数，接受一个组件并返回一个新的增强组件。</em></p><p id="258f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">换句话说:如果我们将HOF概念应用于反应组件，我们将得到HOC。</p><blockquote class="mk ml mm"><p id="bdb3" class="ko kp mi kq b kr ks jo kt ku kv jr kw mn ky kz la mo lc ld le mp lg lh li lj ig bi translated">“高阶组件(HOC)是React中重用组件逻辑的一种高级技术。本质上，hoc不是React API的一部分。它们是从React的组合性质中显现出来的一种模式。~ reactjs.org</p></blockquote><p id="711e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们深入一个现实世界的例子。假设我们在一个表和输入字段中列出了用户，其目的是查找具有指定值的用户。同样，我们的应用程序中也有带有搜索功能的工作和公司列表。</p><p id="8521" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们有多个具有相同搜索功能的组件。</p><p id="eb0e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我们必须创建一个函数，它接受一个列表组件作为参数，并用搜索功能增强它:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/6f1f936419918911c36e746a8a16c26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C6X28tejpPuxbudWz1EXFw.png"/></div></div></figure><p id="c1fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“用户列表”组件如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/d23dbd61715e30bf99a53258cf7e835f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h66aD64xx_4NV8o6W44U2w.png"/></div></div></figure><p id="2cb7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦HOC准备就绪，我们就可以将“UsersList”组件包装到“withFilter”函数中:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/7fbf481948d134adb41acb954250d6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2grx9CD8Ah3hdrKEJEVpqw.png"/></div></div></figure><p id="8cbc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">很好，现在我们可以用“CompaniesList”和“JobsList”组件做同样的事情了。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="5b6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一个众所周知的例子是Redux的“连接”。</p><h2 id="7cbf" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">挂钩</strong></h2><blockquote class="mk ml mm"><p id="cf00" class="ko kp mi kq b kr ks jo kt ku kv jr kw mn ky kz la mo lc ld le mp lg lh li lj ig bi translated"><em class="in"> " </em>钩子是React 16.8中新增的。它们让你不用写类就能使用状态和其他React特性。”~ reactjs.org</p></blockquote><p id="7ba7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是什么意思？</p><p id="a354" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用React钩子，我们可以添加一个本地状态，并在功能组件中使用生命周期特性。它们帮助我们避免对类使用React，并且只遵循函数式编程风格。</p><p id="7484" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React钩子只是JavaScript函数。在前面的“with filter”HOC示例中，我们已经体验了用于在本地状态中存储过滤列表的“useState”挂钩。</p><p id="2ef0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">除了React内置钩子(useState、useEffect、…)之外，我们可以创建自己的定制钩子来在组件之间共享有状态逻辑。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="2ca6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，让我们在不使用HOC的情况下编写前面的示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/1cbff8b6a0b032ea850879d06485da54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3enZ2iGLHJ4UTF4S_B31A.png"/></div></div></figure><p id="fe4f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们所看到的，本地状态和输入字段及其onChange函数从HOC移到了组件中。如果我们对“JobsList”和“CompaniesList”组件做同样的事情，我们将开始在整个应用程序中复制代码。</p><p id="1ee8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看React钩子如何帮助我们避免这种情况。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/86671fba560a504d9ab3b481aaf2f4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mup_7oX2v8513VCcoK5otA.png"/></div></div></figure><p id="5f8e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">太好了,“使用过滤器”挂钩准备好了。现在，让我们修改组件，如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/2626d689eabb0bc1a7016156c753dfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMJYnpXJngJ7Be-GSe75Hg.png"/></div></div></figure><p id="226a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不错！我们也可以在“JobsList”和“CompaniesList”组件中使用自定义挂钩。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="c6fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">到目前为止，我们看到了React钩子和hoc对于在组件之间共享有状态逻辑是如何有用的。但是当我们决定使用一种或另一种技术时，也有一些不同之处需要注意。例如:</p><ul class=""><li id="dd23" class="nd ne in kq b kr ks ku kv kx nf lb ng lf nh lj ni nj nk nl bi translated">HOC是一个独立于React的模式，但是钩子是React的一部分。</li><li id="acb5" class="nd ne in kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">我们可以像函数一样组合钩子，但是React钩子是不可组合的。</li><li id="c6e5" class="nd ne in kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">HOC在组件层次结构中增加了一个组件(我们可以在DevTools中检查它)。</li></ul><p id="9ac9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，在开始用React钩子替换所有hoc之前，我们必须回答下面的问题——这有必要吗？<br/>首先，重要的是要清楚地了解每一个的利弊，找到最适合项目的最佳方案。</p><p id="eada" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mi">作者Mariam Kochumian。</em></p><p id="9025" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mi">更多内容尽在</em> <a class="ae nr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mi">说白了. io </em> </strong> </a> <em class="mi">。报名参加我们的</em> <a class="ae nr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mi">免费周报</em> </strong> </a> <em class="mi">。关注我们关于</em> <a class="ae nr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mi">推特</em> </strong> </a> <em class="mi">和</em><strong class="kq io"><em class="mi"/></strong><a class="ae nr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mi">LinkedIn</em></strong></a><em class="mi">。加入我们的</em> <a class="ae nr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mi">社区</em> </strong> </a> <em class="mi">。</em></p></div></div>    
</body>
</html>