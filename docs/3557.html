<html>
<head>
<title>Let’s Understand Chrome V8: Compiler Workflow: Token, AST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来了解一下Chrome V8:编译器工作流程:Token，AST</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-understand-chrome-v8-compiler-workflow-token-ast-8f629bd79803?source=collection_archive---------7-----------------------#2022-09-07">https://javascript.plainenglish.io/lets-understand-chrome-v8-compiler-workflow-token-ast-8f629bd79803?source=collection_archive---------7-----------------------#2022-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1226" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第21章:DoParseProgram函数和AST生成</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2229cb027639f57877eb360bf75cd927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCFNVeb4ds9hl7WF-NP-kw.png"/></div></div></figure><p id="25d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">欢迎来到</em> <a class="ae ll" href="https://medium.com/@huidou" rel="noopener"> <em class="lk">其他章节让我们来了解一下Chrome V8 </em> </a></p><p id="17b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上一篇文章中，我们谈到了解析器，我们知道扫描器是被动的，需要被解析器唤醒。在这里，我将带您详细了解编译器工作流、观察标记和AST。</p><h1 id="ce0c" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated"><strong class="ak"> 1。扫描仪和令牌</strong></h1><p id="ec21" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">下面的函数负责生成AST，它包含扫描器初始化、扫描器执行和解析器令牌，在这里你可以详细观察编译器的工作流程。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="24f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第3行是扫描仪初始化，下面是源代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2a93" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第3行，Init()初始化扫描器。在第5行中，Scan()只生成一个令牌，记住扫描器是由解析器驱动的，这个令牌首先用来唤醒解析器，然后很快触发令牌缓存缺失，最终启动编译器管道。让我们更深入地研究一下Init()。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0925" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第2行，Advance()从JavaScript代码中获取一个字符，这是开发人员实际编写的。</p><p id="057c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第11行显示了Advance()源代码。在第15行，关键字c0_指向Advance()将取出的下一个字符。source_-&gt;Advance的定义在第18行。请看第24行，Peek()是从JavaScript中获取字符的实际函数，因为在第25–28行，它读取保存JavaScript的缓冲流。</p><p id="f29b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回到void Scanner::Initialize()，让我们深入扫描()。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6b7b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第4行，ScanSingleToken()使用Advance()一个接一个地取出字符，直到遇到一个终止符。</p><p id="f588" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的例子中，起始字符是一个<code class="fe ml mm mn mo b">f</code>，我们知道<code class="fe ml mm mn mo b">f</code>可能意味着关键字函数或者一个普通的用户定义的变量，这取决于后面的字符。因为我们的例子是关键字函数，所以进入第16–17行。</p><p id="4e0b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">扫描器的基础是有限状态自动机，V8使用预定义的宏模板和开关盒来扫描字符，然后将相关字符组织在一起作为令牌，并填充到缓存中。</p><p id="e87d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看一下ScanIdentifierOrKeyword():</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="dbe9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">ScanIdentifierOrKeywordInner()在一次执行中生成一个令牌。</p><h1 id="2e93" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated"><strong class="ak"> 2。生成AST </strong></h1><p id="4825" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">DoParseProgram()负责生成AST树。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ad05" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第2行get out lazy选项，默认情况下，lazy为真，在<em class="lk"> flag-definitions.h </em>中定义。第8行创建了一个空的AST主体。</p><p id="437b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第16行，ParseStatementList()解析令牌并生成AST。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d380" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第4行，peek()获取当前令牌的类型。在我们的例子中，第一个令牌是Token::FUNCTION，它既不是Token::STRING，也不是end_token，所以进入ParseStatementListItem()。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="43e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在ParseStatementListItem中，根据令牌类型，执行下面的操作。确切地说，ParseStatementListItem也是一个有限状态自动机，它使用预定义的宏模板和大小写转换来匹配和分析字符。</p><p id="5e75" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">图1显示了调用栈。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/3e221c30dd6547b8e75e5e2d1cbc6566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTegkkdMJG3AlHhaRw8MzA.png"/></div></div></figure><p id="3de7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在JavaScript中，一个语句可能是一个变量定义、一个函数或者一个语句块，所以ParseStatementListItem()经常递归调用自己。</p><h1 id="1847" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated"><strong class="ak">外卖</strong></h1><p id="489c" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated"><strong class="kq io"> (1) </strong>编译器的基本原理是用有限状态自动机来分析字符。具体来说，V8使用宏模板和开关盒。</p><p id="4be3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> (2) </strong>编译器的最小粒度是一个JavaScript函数。</p><p id="e786" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> (3) </strong>既然懒编译在这里，那么一个函数在即将执行的时候编译。</p><p id="0278" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">(4)</strong>function literal保存代表您的JavaScript函数的AST树。</p><p id="c507" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> (5) </strong>下面是定义Token的宏模板:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="64ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">好了，本次分享到此结束。下次再见，保重！</em></p><p id="d376" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何问题，请联系我。<strong class="kq io">微信</strong> : qq9123013 <strong class="kq io">邮箱</strong>:<a class="ae ll" href="mailto:v8blink@outlook.com" rel="noopener ugc nofollow" target="_blank">v8blink@outlook.com</a></p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="5449" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容请看</em> <a class="ae ll" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">说白了就是</em> </strong> </a> <em class="lk">。报名参加我们的</em> <a class="ae ll" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费每周简讯</em> </strong> </a> <em class="lk">。关注我们关于</em><a class="ae ll" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">Twitter</em></strong></a>，<a class="ae ll" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">，</em><a class="ae ll" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">YouTube</em></strong></a><em class="lk">，以及</em> <a class="ae ll" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">不和</em></strong></a><em class="lk"><em class="lk">。</em></em></p></div></div>    
</body>
</html>