<html>
<head>
<title>Why I Prefer Axios in Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我更喜欢在Web应用程序中使用Axios</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-i-prefer-axios-in-web-app-9a78d655fd1d?source=collection_archive---------10-----------------------#2022-07-12">https://javascript.plainenglish.io/why-i-prefer-axios-in-web-app-9a78d655fd1d?source=collection_archive---------10-----------------------#2022-07-12</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><div class=""><h2 id="415a" class="pw-subtitle-paragraph jl in io bd b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dk translated">同构和基于承诺的代码使开发更加高效</h2></div><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj kd"><img src="../Images/c948cdb5875b695f2eaa1d2b024b2dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1_MpxTvxzp3S_Flx"/></div></div><figcaption class="kp kq gk gi gj kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@campaign_creators?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Campaign Creators</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c265" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">前言</h1><p id="ec6e" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">在过去的8年里，我为三家公司工作过，并为每家公司开发了许多web应用程序。创建新项目时，我总是喜欢用axios作为HTTP请求库。<a class="ae kt" href="https://axios-http.com/docs/intro" rel="noopener ugc nofollow" target="_blank"> axios网站</a>介绍了许多功能:</p><p id="a5ff" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">从浏览器发出<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequests </a></p><p id="936d" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">从Node.js发出<a class="ae kt" href="http://nodejs.org/api/http.html" rel="noopener ugc nofollow" target="_blank"> HTTP </a>请求</p><p id="46e1" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">支持<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a> API</p><p id="acac" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">拦截请求和响应</p><p id="d82e" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">转换请求和响应数据</p><p id="8d61" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">取消请求</p><p id="bf1e" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">JSON数据的自动转换</p><p id="5079" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">客户端支持防止<a class="ae kt" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank"> XSRF </a></p><p id="d116" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">但我认为我喜欢使用axios有三个主要原因:</p><ol class=""><li id="4600" class="mn mo io lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">它是基于承诺的，易于编写异步代码。</li><li id="7aae" class="mn mo io lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">它是同构的，可以用相同的代码库在浏览器和Node.js中运行。</li><li id="f4e0" class="mn mo io lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">支持拦截器可以拦截请求和响应。</li></ol><h1 id="b728" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">基于承诺的</h1><p id="2732" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">当我刚开始工作时，没有承诺，需要回调来处理响应。如果我们想从不同的API中顺序获取数据，我们必须将请求放入回调中。就像这样:</p><pre class="ke kf kg kh gu nb nc nd ne aw nf bi"><span id="aa9d" class="ng kv io nc b gz nh ni l nj nk">// this function request data from server<br/>function ajax(url: string, successCallback: Function, errorCallback:Function): void {<br/>}</span><span id="9861" class="ng kv io nc b gz nl ni l nj nk">// fetch data sequentially<br/>ajax('/url1', function success() {<br/>    ajax('/url2', function() {<br/>        // fetch more data;<br/>        ...<br/>    }, function() {});<br/>}, function error() {})</span></pre><p id="a0a4" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果我们想从更多不同的API获取数据，就会有更多嵌套的回调。代码变得越来越深，越来越难以管理，特别是如果我们有真正的代码，而不是可能包含循环、条件语句等等的<code class="fe nm nn no nc b">...</code>。</p><p id="d5c4" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">这被称为“回调地狱”或“末日金字塔”</p><p id="14b9" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">感谢上帝，承诺很快就出现了，提供连锁电话，以避免这样的金字塔。</p><p id="b531" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">通过使用promise，代码将如下所示:</p><pre class="ke kf kg kh gu nb nc nd ne aw nf bi"><span id="065c" class="ng kv io nc b gz nh ni l nj nk">function ajax(url: string): Promise {<br/>}</span><span id="cd94" class="ng kv io nc b gz nl ni l nj nk">ajax('/url1').then(function() {<br/>    return ajax('/url2');<br/>}).then(function() {<br/>    return ajax('/url3');<br/>})</span></pre><p id="3e99" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">我们可以在承诺上调用<code class="fe nm nn no nc b">.then</code>任意多次，与回调相反，承诺给了代码更多的流程和灵活性。</p><h1 id="e7c7" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">同形的</h1><p id="4f0e" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">在我的web应用程序中，我经常需要使用Node.js来提供来自不同API的数据聚合。所以需要发送HTTP请求来获取Node.js中的数据，如果没有axios，就这样在Node.js中取一个JSON数据(演示来自<a class="ae kt" href="https://nodejs.org/dist/latest-v16.x/docs/api/http.html#httpgetoptions-callback" rel="noopener ugc nofollow" target="_blank"> Node.js网站</a>):</p><pre class="ke kf kg kh gu nb nc nd ne aw nf bi"><span id="09e7" class="ng kv io nc b gz nh ni l nj nk">const http = require('http');</span><span id="a949" class="ng kv io nc b gz nl ni l nj nk">http.get('<a class="ae kt" href="http://localhost:8000/'" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/'</a>, (res) =&gt; {<br/>  const { statusCode } = res;<br/>  if (statusCode !== 200) {<br/>    error = new Error('Request Failed.\n' +<br/>                      `Status Code: ${statusCode}`);<br/>  } else if (!/^application\/json/.test(contentType)) {<br/>    error = new Error('Invalid content-type.\n' +<br/>                      `Expected application/json but received ${contentType}`);<br/>  }<br/>  if (error) {<br/>    console.error(error.message);<br/>    // Consume response data to free up memory<br/>    res.resume();<br/>    return;<br/>  }</span><span id="30aa" class="ng kv io nc b gz nl ni l nj nk">res.setEncoding('utf8');<br/>  let rawData = '';<br/>  res.on('data', (chunk) =&gt; { rawData += chunk; });<br/>  res.on('end', () =&gt; {<br/>    try {<br/>      const parsedData = JSON.parse(rawData);<br/>      console.log(parsedData);<br/>    } catch (e) {<br/>      console.error(e.message);<br/>    }<br/>  });<br/>}).on('error', (e) =&gt; {<br/>  console.error(`Got error: ${e.message}`);<br/>});</span></pre><p id="8988" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">要使用HTTP模块发送请求，您需要侦听许多事件，处理数据块，然后将数据解析为JSON格式。而且不是基于承诺的，我们多半会遇到“回调地狱”。</p><p id="b6fe" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">幸运的是，axios支持Node.js。我们可以像在浏览器中一样获取数据。不仅代码风格相同，而且我们还可以重用请求逻辑，只需编写一次代码，就可以在browser和Node.js中运行。重用代码片段非常重要，因为随着项目变得越来越复杂，如果同一请求有许多不同的实现，维护可能会是一场灾难。如果需要修改，很容易漏掉一些，效率非常低。</p><h1 id="7c3b" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">拦截机</h1><p id="e696" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">这是我最喜欢的axios特性，我们可以在请求或响应被<code class="fe nm nn no nc b">then</code>或<code class="fe nm nn no nc b">catch</code>处理之前拦截它们。无论是浏览器还是Node.js提供的请求方法，都只是最原始的请求函数实现，缺乏对web apps的适配。在web app开发过程中，需要注意开发效率和代码可维护性，所以代码最好是高内聚低耦合的。axios的拦截器使得与请求相关的代码更具内聚性。</p><p id="0949" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">如果没有拦截器，我们可以在每个请求动作之前使用utils来处理请求参数。可能是:</p><pre class="ke kf kg kh gu nb nc nd ne aw nf bi"><span id="e50f" class="ng kv io nc b gz nh ni l nj nk">// processParams method use to serialization params<br/>ajax('/url1', processParams(params1));</span><span id="127e" class="ng kv io nc b gz nl ni l nj nk">ajax('/url2', processParams(params2));</span></pre><p id="e21a" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">有了拦截器，我们可以这样做:</p><pre class="ke kf kg kh gu nb nc nd ne aw nf bi"><span id="eb59" class="ng kv io nc b gz nh ni l nj nk">axios.interceptors.request.use(function (config) {     <br/>  // Do something before request is sent<br/>  processParams(config.params);    <br/>  return config;   <br/>});<br/>axios.get('/urlX', paramsX);</span></pre><p id="3dc6" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">使用拦截器可以很容易地实现定制的动作，比如参数序列化、参数验证、异常处理等等。</p><h1 id="f14d" class="ku kv io bd kw kx ky kz la lb lc ld le ju lf jv lg jx lh jy li ka lj kb lk ll bi translated">结论</h1><p id="7c54" class="pw-post-body-paragraph lm ln io lo b lp lq jp lr ls lt js lu lv lw lx ly lz ma mb mc md me mf mg mh ih bi translated">在开发web应用时，使用axios作为HTTP请求库可以使我们的开发更高效，代码更易于维护。在这篇文章中，我分享了我喜欢axios的三个原因:</p><ol class=""><li id="6e98" class="mn mo io lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">基于承诺的</li><li id="f25f" class="mn mo io lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">同形的</li><li id="8d94" class="mn mo io lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">拦截机</li></ol><p id="848d" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated">你也这么认为吗？期待你关注我，我会分享更多的开发技巧，帮助你成为更好的程序员。</p><p id="f6db" class="pw-post-body-paragraph lm ln io lo b lp mi jp lr ls mj js lu lv mk lx ly lz ml mb mc md mm mf mg mh ih bi translated"><em class="np">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="np">plain English . io</em></strong></a><em class="np">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ip"> <em class="np">免费周报</em> </strong> </a> <em class="np">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="np">Twitter</em></strong></a><em class="np">和</em><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lo ip"><em class="np">LinkedIn</em></strong></a><em class="np">。查看我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ip"> <em class="np">社区不和谐</em> </strong> </a> <em class="np">加入我们的</em> <a class="ae kt" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="lo ip"> <em class="np">人才集体</em> </strong> </a> <em class="np">。</em></p></div></div>    
</body>
</html>