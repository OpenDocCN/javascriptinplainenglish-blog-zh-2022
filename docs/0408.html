<html>
<head>
<title>Create a REST API with Azure Serverless Functions and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Azure无服务器函数和Node.js创建REST API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-rest-api-with-azure-serverless-functions-and-node-js-6bd39739492e?source=collection_archive---------9-----------------------#2022-01-24">https://javascript.plainenglish.io/create-a-rest-api-with-azure-serverless-functions-and-node-js-6bd39739492e?source=collection_archive---------9-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba9d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分—重构、增强和部署</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/d09fcb0e724762d7443cd0aeef810a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oh4XgZJiz8aSfTHyTn2ZAw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Azure Functions with Node.js and Azure Table Storage</figcaption></figure><p id="e766" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当开发任何应用程序时，我的哲学一直是让它工作，然后优化/增强/重构代码。正如他们所说，“过早优化是万恶之源”。但是，既然我们已经完成了所有的CRUD功能，是时候回去重构我们的代码，使它更干净，更可重用。</p><h1 id="b913" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">端点</h1><p id="2dd9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在我之前的文章中，当提到端点的命名时，我们使用默认的Azure函数约定。在典型的REST API中，大多数端点看起来非常相似，甚至完全相同。区别在于传递的HTTP动词(GET、POST、PUT、DELETE等。).</p><p id="b426" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了遵循这一约定，我们将把function.json文件中的路由重命名为:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="a4b2" class="mp lo iq ml b gy mq mr l ms mt">//CreatePost/function.json<br/>"route": "blog-posts"</span><span id="d538" class="mp lo iq ml b gy mu mr l ms mt">// GetPosts/function.json<br/>"route": "blog-posts/{blog}"</span><span id="97a8" class="mp lo iq ml b gy mu mr l ms mt">// GetPost/function.json<br/>"route": "blog-posts/{blog}/{id}"</span><span id="b841" class="mp lo iq ml b gy mu mr l ms mt">// UpdatePost/function.json<br/>"route": "blog-posts/{blog}/{id}"</span><span id="387a" class="mp lo iq ml b gy mu mr l ms mt">// DeletePost/function.json<br/>"route": "blog-posts/{blog}/{id}"</span></pre><h1 id="d404" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">中间件</h1><p id="79d5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">REST API中的许多代码将在不同的方法间共享。在请求的开始或结束时尤其如此。这就是中间件概念发挥作用的地方。Express是一个广泛使用中间件的框架。他们将其定义为:</p><blockquote class="mv mw mx"><p id="238e" class="kr ks my kt b ku kv jr kw kx ky ju kz mz lb lc ld na lf lg lh nb lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">中间件</em> </strong>函数是访问请求对象(<code class="fe nc nd ne ml b">req</code>)、响应对象(<code class="fe nc nd ne ml b">res</code>)以及应用程序的请求-响应周期中的下一个中间件函数的函数。下一个中间件功能通常用一个名为<code class="fe nc nd ne ml b">next</code>的变量来表示。</p></blockquote><p id="4ff0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，Azure Functions没有内置中间件，它们会主动让你使用它们的<a class="ae nf" href="https://azure.microsoft.com/en-us/services/api-management/" rel="noopener ugc nofollow" target="_blank"> API管理</a>服务。幸运的是，有一个名为<a class="ae nf" href="https://www.npmjs.com/package/azure-middleware" rel="noopener ugc nofollow" target="_blank">azure-middleware</a><em class="my"/>的包，我们可以通过运行以下命令将它添加到项目中:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="71f2" class="mp lo iq ml b gy mq mr l ms mt">npm install azure-middleware joi</span></pre><h2 id="6d8b" class="mp lo iq bd lp ng nh dn lt ni nj dp lx la nk nl lz le nm nn mb li no np md nq bi translated">数据有效性</h2><p id="8bc7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在我们已经安装了这个包，我们可以使用一些中间件来验证CreatePost端点的主体。为此，我们将在CreatePost文件夹中创建一个名为handler.js的新文件，并将所有业务逻辑移到其中。我们可以去掉我们自己的验证，因为我们将制作我们自己的中间件。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="e62f" class="mp lo iq ml b gy mq mr l ms mt">const<em class="my"> </em>{<em class="my"> insertEntity </em>}<em class="my"> </em>=<em class="my"> require</em>("../services/tableService");</span><span id="1b52" class="mp lo iq ml b gy mu mr l ms mt">exports<em class="my">.createPostHandler</em> = <em class="my">async</em> (context) =&gt; {<br/> const<em class="my"> </em>{<em class="my"> blog</em>,<em class="my"> title</em>,<em class="my"> content </em>}<em class="my"> </em>=<em class="my"> context.req.body</em>;<br/> <br/> const<em class="my"> entity </em>=<em class="my"> </em>{<br/>  <em class="my">PartitionKey</em>:<em class="my"> </em>{<em class="my"> _</em>:<em class="my"> </em>blog<em class="my"> </em>},<br/>  <em class="my">RowKey</em>:<em class="my"> </em>{<em class="my"> _</em>:<em class="my"> </em>new<em class="my"> Date</em>()<em class="my">.getTime</em>()<em class="my">.toString</em>()<em class="my"> </em>},<br/>  <em class="my">title</em>:<em class="my"> </em>{<em class="my"> _</em>:<em class="my"> </em>title<em class="my"> </em>},<br/>  <em class="my">content</em>:<em class="my"> </em>{<em class="my"> _</em>:<em class="my"> </em>content<em class="my"> </em>},<br/> };</span><span id="944d" class="mp lo iq ml b gy mu mr l ms mt"> const<em class="my"> result </em>=<em class="my"> await insertEntity</em>("Posts",<em class="my"> </em>entity);</span><span id="5782" class="mp lo iq ml b gy mu mr l ms mt"><em class="my"> context.</em>res = {<br/>  body: result,<br/> };</span><span id="a241" class="mp lo iq ml b gy mu mr l ms mt"><em class="my"> context.done</em>();<br/>};</span></pre><p id="0840" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们需要创建我们的中间件方法。为此，在项目的根目录下创建一个名为<em class="my">middleware的新文件夹。</em>在该文件夹中创建一个名为<em class="my"> validators.js的文件。</em>在该文件中，我们将创建一个方法来确保一个主体被传递并且Joi模式是有效的:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="d2c9" class="mp lo iq ml b gy mq mr l ms mt">exports<em class="my">.validateBody</em> = <em class="my">async</em> (ctx, body, schema) =&gt; {<br/> <em class="my">try</em> {<br/>  if (!body) {<br/>   <em class="my">ctx.</em>res = {<br/>    status: 400,<br/>    body: "A request body must be passed!",<br/>   };</span><span id="e85e" class="mp lo iq ml b gy mu mr l ms mt"><em class="my">  ctx.done</em>();<br/>  <em class="my">return</em>;<br/>  }<br/>  <br/>  <em class="my">await</em> <em class="my">schema.validateAsync</em>(body);<br/> } <em class="my">catch</em> (err) {<br/>   <em class="my">ctx.</em>res = {<br/>    status: 400,<br/>    body: <em class="my">err.</em>message,<br/>  };</span><span id="98d4" class="mp lo iq ml b gy mu mr l ms mt"><em class="my">  ctx.done</em>();<br/> }<br/>};</span></pre><p id="a2fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到我们的index.js，我们需要导入所需的包。创建我们的Joi模式，将我们的功能更改为中间件处理器，然后</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="50e6" class="mp lo iq ml b gy mq mr l ms mt">const<em class="my"> Joi </em>=<em class="my"> require</em>("joi");<br/>const<em class="my"> MiddlewareHandler </em>=<em class="my"> require</em>("azure-middleware");<br/>const<em class="my"> </em>{<em class="my"> createPostHandler </em>}<em class="my"> </em>=<em class="my"> require</em>("./handler");<br/>const<em class="my"> </em>{<em class="my"> validateBody </em>}<em class="my"> </em>=<em class="my"> require</em>("../middlewares/validator");</span><span id="c46b" class="mp lo iq ml b gy mu mr l ms mt">const<em class="my"> schema </em>=<em class="my"> Joi.object</em>({<br/> <em class="my">blog</em>:<em class="my"> Joi.string</em>()<em class="my">.min</em>(1)<em class="my">.required</em>(),<br/> <em class="my">title</em>:<em class="my"> Joi.string</em>()<em class="my">.min</em>(1)<em class="my">.required</em>(),<br/> <em class="my">content</em>:<em class="my"> Joi.string</em>()<em class="my">.min</em>(1)<em class="my">.required</em>(),<br/>});</span><span id="1928" class="mp lo iq ml b gy mu mr l ms mt">const<em class="my"> createPost </em>=<em class="my"> </em>new<em class="my"> MiddlewareHandler</em>()<br/><em class="my">.use</em>((ctx) =&gt; {<br/><em class="my">//where you can run your middleware<br/>validateBody</em>(ctx, <em class="my">ctx.req.</em>body, schema);<br/> <em class="my">ctx.next</em>();<br/>})<br/><em class="my">.use</em>(createPostHandler) //our handler.js method<br/><em class="my">.catch</em>((err, ctx) =&gt; {<br/> <em class="my">ctx.</em>res = {<br/> status: 500, <br/> body: <em class="my">err.</em>message,<br/> };</span><span id="c1e7" class="mp lo iq ml b gy mu mr l ms mt"><em class="my">ctx.done</em>();<br/>})<br/><em class="my">.listen</em>();</span><span id="3cae" class="mp lo iq ml b gy mu mr l ms mt">module<em class="my">.</em>exports = createPost;</span></pre><h1 id="4b41" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">部署</h1><h2 id="1e9f" class="mp lo iq bd lp ng nh dn lt ni nj dp lx la nk nl lz le nm nn mb li no np md nq bi translated">设置</h2><p id="0a4c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">为了部署我们的功能，我们需要前往Azure门户。登录后，搜索功能应用并点击它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/53c8f79d13ce40903ca048dadb4e5c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URcpl2hqUJktsJ8oZoIPJg.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Azure Portal — Function App</figcaption></figure><p id="8e0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，选择你的订阅，资源组，命名你的函数app，选择Node.js作为运行时栈，最新的稳定版本，区域。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/c599cd3fe99c3c5dde4b2575369f0f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pPTQs4OH_yJQVDnUZk7KQ.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Create Function App</figcaption></figure><p id="c4c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我做的下一件事是点击下一步:托管，并确保我在消费计划下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nx"><img src="../Images/9b20eada92932f1620aeec4bf887c6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aiEbA1mHueRwQTj3JAZ3fQ.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Hosting Settings</figcaption></figure><p id="e049" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，单击底部的“查看和创建”。然后，单击创建。</p><h2 id="a9eb" class="mp lo iq bd lp ng nh dn lt ni nj dp lx la nk nl lz le nm nn mb li no np md nq bi translated">基于Git的自动部署</h2><p id="e761" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一旦你的功能应用已经部署好了，就去吧。接下来在左上角搜索“部署”,然后单击部署中心:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/a582cecb0925a1e8b8bb265de9a75883.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*vp2ueewzmTwEWpgFvDEY6w.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Deployment Center</figcaption></figure><p id="dfad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在source下拉列表中，选择您的git存储库提供者。选择它后，系统会提示您授权Azure进行访问。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nz"><img src="../Images/73aa3b3fe684976e32ad9fb371b85976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWrAumf-Li5fYMYBM7pz-Q.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Code Source</figcaption></figure><p id="dd0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦获得授权，您只需要选择组织、存储库和分支，然后单击右上角的Save。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/700138310d9f2ce023a529d3c01e4c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*koYEw3NeYo9fp5VIS_rQ1Q.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Org, Repo, and Branch</figcaption></figure><p id="34ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">部署运行后，您可以单击功能菜单图标来查看您的所有功能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ob"><img src="../Images/f7b50ff76e4a48a00d3feb0c1ca92d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fo0RGvk7Os2jWr7W0dw-mw.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Functions</figcaption></figure><p id="0004" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要获取函数的Azure端点，请单击列表中的函数。在下一页上，单击“获取函数URL”按钮并复制它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oc"><img src="../Images/5437c0792e5277dca76d4efa2a7049e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2iGECc1FZy6EP6UOkozZBg.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Get Function URL</figcaption></figure><p id="a05e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">视频教程</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Video Tutorial</figcaption></figure><h1 id="a883" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="5b14" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">就是这样！我们现在已经创建了一个完整的CRUD API，并利用Node.js的Azure函数部署了它。请在下面的评论区告诉我你的想法。下次再见，祝编码愉快。</p><p id="b8d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="my">更多内容请看</em><a class="ae nf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae nf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="my">免费周报</em> </strong> </a> <em class="my">。在我们的</em> <a class="ae nf" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="my">社区</em> </strong> </a> <em class="my">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>