<html>
<head>
<title>Angular Component Communication: 6 Ways to Choose From</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角分量通信:6种方式可供选择</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-component-communication-81e5e02c6cbe?source=collection_archive---------1-----------------------#2022-07-06">https://javascript.plainenglish.io/angular-component-communication-81e5e02c6cbe?source=collection_archive---------1-----------------------#2022-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5371" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解Angular中数据共享和组件通信的6种不同方式。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/191da313887a9cde269350b10ceaa77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tearl8RsUuX9jDN8"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Annie Spratt</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b24f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">良好的沟通是任何关系成功的关键因素。应用程序中的关系也不例外。应用程序的组件和其他部分需要协同工作才能完成任务。他们需要能够清晰有效地交流。</p><p id="e164" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将介绍6种在Angular  中实现<strong class="kv io"> <em class="lp">组件通信的方法:</em></strong></p><ol class=""><li id="649e" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">使用<code class="fe lz ma mb mc b">@Input</code>装饰器来定义输入属性并将数据从父节点传递给子节点</li><li id="5781" class="lq lr in kv b kw md kz me lc mf lg mg lk mh lo lv lw lx ly bi translated">使用<code class="fe lz ma mb mc b">@Output</code>装饰器来定义输出属性，并将响应从子节点发送回父节点</li><li id="88ba" class="lq lr in kv b kw md kz me lc mf lg mg lk mh lo lv lw lx ly bi translated">使用<code class="fe lz ma mb mc b">@ViewChild</code>或<code class="fe lz ma mb mc b">@ViewChildren</code>装饰器从父组件中设置或读取子组件的属性</li><li id="3a12" class="lq lr in kv b kw md kz me lc mf lg mg lk mh lo lv lw lx ly bi translated">使用服务作为中介在应用程序中不相关的组件之间进行通信</li><li id="a0da" class="lq lr in kv b kw md kz me lc mf lg mg lk mh lo lv lw lx ly bi translated">使用NgRx的存储作为事实的单一来源，从应用程序中不相关的组件创建或读取应用程序状态</li><li id="a270" class="lq lr in kv b kw md kz me lc mf lg mg lk mh lo lv lw lx ly bi translated">使用布线参数将数据从当前元件传递到下一个布线元件</li></ol><p id="d537" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看起来我们有很多要讲的！</p><p id="0e5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，让我们开始吧！</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="8a01" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak">目录</strong></h1><pre class="kd ke kf kg gt nh mc ni nj aw nk bi"><span id="0664" class="nl mq in mc b gy nm nn l no np"><a class="ae ks" href="#4219" rel="noopener ugc nofollow">1. The @Input Decorator (Parent-to-Child)</a><br/><a class="ae ks" href="#f5ed" rel="noopener ugc nofollow">2. The @Output Decorator (Child-to-Parent)</a><br/><a class="ae ks" href="#a09b" rel="noopener ugc nofollow">3. The @ViewChild Decorator</a><br/><a class="ae ks" href="#4cfd" rel="noopener ugc nofollow">4. Service as an Intermediary</a><br/><a class="ae ks" href="#a3fe" rel="noopener ugc nofollow">5. NgRx</a><br/><a class="ae ks" href="#c877" rel="noopener ugc nofollow">6. Route Parameters</a><br/><a class="ae ks" href="#f185" rel="noopener ugc nofollow">Conclusions</a></span></pre></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="4219" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">1.@Input Decorator(父到子)</h1><p id="8cef" class="pw-post-body-paragraph kt ku in kv b kw nq jo ky kz nr jr lb lc ns le lf lg nt li lj lk nu lm ln lo ig bi translated">如果两个组件有父子关系，在大多数情况下，使用输入属性是将数据从父组件传递给子组件的最佳选择。</p><p id="a847" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了定义一个输入属性，我们将<code class="fe lz ma mb mc b">@Input</code>装饰器添加到属性中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5e9c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，该属性可用于绑定。父节点可以使用它将值、变量或表达式绑定到输入属性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8e9d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输入属性<code class="fe lz ma mb mc b">[checked]</code>是绑定目标，而<code class="fe lz ma mb mc b">isChecked</code>是绑定源。由于使用了属性绑定，这意味着如果父节点修改了其端的源属性，子节点将接收到更改后的值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nx nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Angular component communication demo using the @Input() decorator</figcaption></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="f5ed" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">2.@Output Decorator(子到父)</h1><p id="8323" class="pw-post-body-paragraph kt ku in kv b kw nq jo ky kz nr jr lb lc ns le lf lg nt li lj lk nu lm ln lo ig bi translated">如果子组件需要与父组件进行通信，我们可以在子组件中定义输出属性。但是，与使用属性绑定的输入属性不同，输出属性通过发出事件来工作，这些事件是通过事件绑定来捕获的。</p><p id="6391" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了定义输出属性，我们将<code class="fe lz ma mb mc b">@Output</code>装饰器添加到属性中。然后，子组件可以使用该属性发出事件。或者，它可以将一些数据(称为事件负载)附加到发出的事件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="279e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">父级可以在她的模板中使用事件绑定来捕获这些事件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c693" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后它可以调用一个方法来对事件做出反应。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nx nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Angular component communication demo using the @Output() decorator</figcaption></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="bc1e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你知道吗？</p><p id="c6f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可以组合<code class="fe lz ma mb mc b">@Input</code>和<code class="fe lz ma mb mc b">@Output</code>装饰器来实现父属性和子属性之间的双向绑定。</p><p id="a1a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在子组件类中，我们定义了一个输入和输出属性。输出属性名必须是输入属性名，并以后缀<code class="fe lz ma mb mc b">Change</code>结尾。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nx nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Angular component communication demo using @Input() and @Output() decorators for two-way binding</figcaption></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="a09b" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">3.@ViewChild装饰器</h1><p id="b69c" class="pw-post-body-paragraph kt ku in kv b kw nq jo ky kz nr jr lb lc ns le lf lg nt li lj lk nu lm ln lo ig bi translated">不用通过输入属性传递数据或通过输出属性发出事件，父节点可以使用<code class="fe lz ma mb mc b">@ViewChild</code>或<code class="fe lz ma mb mc b">@ViewChilden</code>装饰器直接访问子节点的属性和方法。</p><p id="21ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lz ma mb mc b">@ViewChild</code>装饰器允许我们获得对模板中任何元素、指令或子组件的引用。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8db5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要获得引用，我们可以使用模板引用变量:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="59e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">或子组件类型:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ab79" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我们可以使用该引用来访问子组件的属性和方法。但是，这种交流方式有局限性。</p><p id="b5b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，在<code class="fe lz ma mb mc b">AfterViewInit</code>生命周期挂钩之前，用<code class="fe lz ma mb mc b">@ViewChild</code>装饰器获取引用是不可靠的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6e97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最重要的是，父组件不会收到子组件对属性所做的任何更改。如果子节点修改了它的<code class="fe lz ma mb mc b">filter</code>属性的值，父节点的<code class="fe lz ma mb mc b">filterTerm</code>属性将不会被更新。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="4cfd" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">4.中介服务</h1><p id="a0f5" class="pw-post-body-paragraph kt ku in kv b kw nq jo ky kz nr jr lb lc ns le lf lg nt li lj lk nu lm ln lo ig bi translated">组件不会总是有父子关系。它们可能是不相关的，出现在应用程序的不同位置。但是如果我们需要这样的组件来通信呢？输入服务。</p><p id="96bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可以通过用<code class="fe lz ma mb mc b">@Injectable</code> decorator注释一个类来定义服务。如果我们将<code class="fe lz ma mb mc b">providedIn</code>属性设置为<code class="fe lz ma mb mc b">'root'</code>，该服务将被注册为单例服务。Angular将在依赖注入链中维护服务的单个实例。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fcfd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着依赖于该服务的所有组件将接收同一个实例。因此，我们可以使用这样的服务将数据存储在内存中，并从相同或不同的组件中检索存储的数据。</p><p id="bbe1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">注意:</em> </strong> <em class="lp">我们说的数据存储在内存中，也就是说刷新页面就不会保存数据了！</em></p><p id="937b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了在内存中存储一些数据或状态，我们通常使用带有主题的服务，更常见的是<code class="fe lz ma mb mc b">BehaviorSubject</code>。</p><p id="89cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用<code class="fe lz ma mb mc b">BehaviorSubject</code>而不是普通的<code class="fe lz ma mb mc b">Subject</code>有两个原因:</p><ol class=""><li id="5fe7" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">不像<code class="fe lz ma mb mc b">Subject</code>没有初始值，<code class="fe lz ma mb mc b">BehaviorSubject</code>有初始值。</li><li id="b96a" class="lq lr in kv b kw md kz me lc mf lg mg lk mh lo lv lw lx ly bi translated">如果我们在一个值发出后订阅了一个<code class="fe lz ma mb mc b">Subject</code>，我们将不会收到任何东西。使用<code class="fe lz ma mb mc b">BehaviorSubject</code>，我们将总是接收最后发出的值，因为它有一个初始值，我们将总是接收一个值。</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1905" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以从一个组件发出新的值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="88dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在其他一些组件中，我们可以订阅接收最后发出的值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nx nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Angular component communication demo using a service as an intermediary</figcaption></figure><p id="edf5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">注意:</em> </strong> <em class="lp">这看起来可能和我们之前的一个例子一样，其实不然。注意到</em>组件在本例<em class="lp">中没有父子关系。他们是兄弟姐妹。</em></p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="a3fe" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">5.NgRx</h1><p id="4413" class="pw-post-body-paragraph kt ku in kv b kw nq jo ky kz nr jr lb lc ns le lf lg nt li lj lk nu lm ln lo ig bi translated">如果我们的应用程序的状态是小而简单的，使用带有主题的服务就可以了。对于现实生活中的应用程序，这种情况很少发生。我们如何管理一个庞大复杂的国家？输入NgRx。</p><p id="412e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，如果我们要讨论关于NgRx的一切，我们会以一篇很长的文章结束。这也超出了本文的范围。如果你想了解更多关于NgRx的信息，我们建议你查看<a class="ae ks" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank">官方网站</a>。你也可以在媒体上阅读关于NgRx的内容。</p><p id="4b55" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是NgRx工作原理的一个非常简单的描述。</p><p id="8b25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们定义了一个<code class="fe lz ma mb mc b">State</code>，它代表了将保存在<code class="fe lz ma mb mc b">Store</code>中的数据格式。我们还用一些初始值定义了一个初始状态。<code class="fe lz ma mb mc b">Store</code>被用作真实的单一来源。存储的状态是只读的和不可变的，这意味着它不能被直接修改。相反，当我们想要更新状态时，我们创建一个新的状态。</p><p id="cd61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了创建一个新的状态，我们需要定义并调度<code class="fe lz ma mb mc b">Actions</code>。对于每组动作，我们需要定义一个<code class="fe lz ma mb mc b">Reducer</code>来处理它们。reducer是一个纯粹的函数，给定当前状态加上来自相应调度动作的数据，它会创建一个新状态。新状态再次存储在<code class="fe lz ma mb mc b">Store</code>中。</p><p id="6b94" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们定义选择器来订阅和监听<code class="fe lz ma mb mc b">State</code>中的特定变化。例如，一个组件可以订阅一个选择器来监听由另一个组件内的调度动作所引起的变化。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="c877" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">6.路线参数</h1><p id="49a8" class="pw-post-body-paragraph kt ku in kv b kw nq jo ky kz nr jr lb lc ns le lf lg nt li lj lk nu lm ln lo ig bi translated">如果我们只需要将一点数据从一个路由组件传递到下一个组件，那么创建一个新的服务可能不值得付出代码开销。<code class="fe lz ma mb mc b">Router</code>提供了一种简单的方法。</p><p id="00b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们如何通过路由传递数据？输入<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/angular-route-parameters-a-simple-guide-88c69d54102c">路线参数</a>。</p><p id="fec8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Angular提供了三种类型的管线参数:必需参数、可选参数和查询参数。因为这不是一篇关于路由的文章，所以我们不打算深入细节。如果您想了解关于路由参数的更多信息，我们已经在另一篇文章中讨论了这三个参数。</p><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-route-parameters-a-simple-guide-88c69d54102c"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">角度布线参数:简单指南</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">角度布线参数概述。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ok l"><div class="ol l om on oo ok op km ob"/></div></div></a></div><p id="84dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可以说，使用路由参数是传递小块数据的一种简单而有效的方法。此外，产生的网址是书签和共享的。</p><p id="6c2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，请记住，指定的路由参数将出现在URL中。所以，不要用它们来传递用户不应该看到的复杂数据或敏感信息。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="f185" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">结论</h1><p id="b566" class="pw-post-body-paragraph kt ku in kv b kw nq jo ky kz nr jr lb lc ns le lf lg nt li lj lk nu lm ln lo ig bi translated">在本文中，我们深入探讨了角度组件通信，并给出了6种不同的实现方式。</p><p id="ebbd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果组件有父子关系，使用<code class="fe lz ma mb mc b">@Input</code>和<code class="fe lz ma mb mc b">@Output</code>装饰器。如果对变化的反应不感兴趣，你可以偶尔考虑一下<code class="fe lz ma mb mc b">@ViewChild</code> / <code class="fe lz ma mb mc b">@ViewChildren</code>装饰者。</p><p id="b9a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果组件是不相关的，使用带有一两个<code class="fe lz ma mb mc b">BehavioSubject</code>的服务作为中介。相反，如果应用程序状态太大或太复杂，并且使用它证明设置它的代码开销是合理的，则使用NgRx进行状态管理。</p><p id="5853" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，如果只需要将少量数据传递给下一个路由组件，请使用路由参数。</p><p id="33e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望你喜欢这篇文章，并且你学到了一些新的东西。如果你有，请<a class="ae ks" href="https://vkagklis.medium.com/subscribe" rel="noopener">订阅我的时事通讯</a>获取更多类似的内容。</p><p id="6f2a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编码快乐！</p><p id="7894" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">plain English . io</em></strong></a><em class="lp">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">免费周报</em> </strong> </a> <em class="lp">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">Twitter</em></strong></a><strong class="kv io"><em class="lp"/></strong><em class="lp">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">LinkedIn</em></strong></a><em class="lp">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">社区不和谐</em> </strong> </a> <em class="lp">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">人才集体</em> </strong> </a> <em class="lp">。</em></p><p id="1e05" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">进一步阅读:</em> </strong></p><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-zone-js-3b5e2347b7"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">关于Angular你应该知道的10件事</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">Zone.js是什么？如何有角度地使用它？本问答指南将回答这些问题以及更多问题。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ok l"><div class="oq l om on oo ok op km ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-elementref-templateref-viewcontainerref-8517b7ce3274"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">角度DOM操作:ElementRef、TemplateRef和ViewContainerRef</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">概述Angular中的元素、模板、视图和视图容器，以及如何以编程方式修改DOM。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ok l"><div class="or l om on oo ok op km ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/custom-pipes-in-angular-the-ultimate-guide-e54bb400e3ce"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">角形定制管道——终极指南</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">如何在Angular中创建自定义管道，什么是纯管道和不纯管道，以及如何使用纯管道来改善</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ok l"><div class="os l om on oo ok op km ob"/></div></div></a></div></div></div>    
</body>
</html>