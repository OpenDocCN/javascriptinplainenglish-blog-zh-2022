<html>
<head>
<title>Electron RPC using the Magic of TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript魔法的电子RPC</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/electron-rpc-using-the-magic-of-typescript-9d24530ea8f1?source=collection_archive---------8-----------------------#2022-04-18">https://javascript.plainenglish.io/electron-rpc-using-the-magic-of-typescript-9d24530ea8f1?source=collection_archive---------8-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0c5a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用于构建RPC库的TypeScript功能概述</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/88fd4327645fcf210fdae9e19ff5778c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnDMXEtLBAtr5U5-j3s53Q.png"/></div></div></figure><p id="f9a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript很神奇。它的类型和对象灵活性使我能够在<a class="ae lk" href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子跨平台框架</a>中为进程间通信(IPC)开发远程过程调用(RPC)。我称这个解决方案为<a class="ae lk" href="https://github.com/jtlapp/electron-affinity" rel="noopener ugc nofollow" target="_blank">电子亲和势</a>。</p><p id="880e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Electron Affinity是一个开源库，它使得使用Electron IPC就像调用本地函数一样无缝。利用TypeScript和普通JavaScript的神奇特性，该库从远程定义的函数的类型签名中动态构造可调用的客户端函数。本文解释了这些神奇的特性，并试图传达TypeScript的一些强大功能。</p><h1 id="dce9" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">什么是进程间通信(IPC)？</h1><p id="70fd" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">作为web开发人员，我们熟悉使用HTTP <code class="fe mi mj mk ml b">get</code>或<code class="fe mi mj mk ml b">post</code>在浏览器和web服务器之间交换信息。一个进程在浏览器上运行，另一个在服务器上运行，当它们共享数据时——瞧！—我们有进程间通信。在这种情况下，这两个进程通常驻留在不同的计算机上，但是它们也可以在同一台计算机上。</p><p id="1402" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<a class="ae lk" href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子</a>中，两个进程<em class="mm">都在同一个电脑上</em>。Electron是一个框架，它允许我们将浏览器和网站捆绑到一个桌面应用程序中，该应用程序由一个可执行文件组成。由于前端使用Chrome浏览器，后端使用Node.js，Electron将web开发变成了跨平台的桌面应用程序开发。</p><p id="019e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是Electron在浏览器和Node.js之间不使用HTTP，这可能是因为HTTP对于驻留在同一台计算机上的进程之间的IPC来说是一个低效的解决方案。相反，电子提供了一种通过命名的IPC通道监听和发送消息的机制。</p><h1 id="edc4" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">电子工控机的改进</h1><p id="f1a0" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">不幸的是，Electron的IPC机制需要编写大量样板代码，并且在共享IPC数据上强制类型的简单方法都需要在前端代码中复制后端类型声明。当我使用electronic时，我发现IPC是一个常见的错误来源，我希望我使用的是远程过程调用(RPC)机制。在RPC中，一个进程调用一个调用相应远程函数的函数，而调用者或远程函数都没有意识到调用是在进程之间进行的。</p><p id="309f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是我开始用<a class="ae lk" href="https://github.com/jtlapp/electron-affinity" rel="noopener ugc nofollow" target="_blank">电子亲和能</a>做的事情——为在电子中使用IPC提供简单的RPC机制。电子允许浏览器向Node.js发送IPC消息，Node.js向浏览器发送IPC消息，所以任何一方都可以是调用者或被调用者。在RPC的说法中，调用者是“客户”,被调用者是“服务器”,不管哪一方进行调用，所以我们将这样称呼他们。每个浏览器窗口都运行自己的进程，所以我们将它们称为“窗口进程”，而Electron将Node.js进程称为“主进程”，所以这也是我们要做的。</p><h1 id="4685" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">远程过程调用</h1><p id="136b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在标准的RPC体系结构下，开发人员创建可远程调用的函数，包括它们的类型签名，然后运行一个特殊的程序从类型签名生成存根。这些存根被链接到客户端和服务器程序中，以便可以远程访问这些功能。</p><p id="a774" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一个存根是客户端存根，另一个是服务器存根。它们分别使远程函数调用在客户机和服务器看来是本地的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/2f5b732173b1267ee87659f1abb81aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ez78BrSgO4sGp_egV-Useg.png"/></div></div></figure><p id="0610" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">客户端存根是远程函数的代理。它将函数的参数打包，通过一个低级IPC层传输到服务器进程。服务器存根是调用者的代理。它对从IPC层接收的数据进行解包，并将参数传递给预期的远程函数。这些函数的返回值遵循相反的过程，从服务器存根到IPC层到客户端存根，最后返回到调用对象。</p><p id="33ff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的例子中，函数实际上是对象上的方法，所以我实现了一种称为远程方法调用(RMI)的RPC形式。在RMI中，客户机存根暴露具有远程对象上的方法签名的函数。调用这些函数会将方法名、方法参数和目标对象传递给IPC层。接收到这些数据后，服务器存根将调用指向目标对象的预期方法。通常生成客户端和服务器存根来表示对象的整个类。</p><h1 id="c5f3" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">第二十二条军规</h1><p id="1141" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在我们的例子中，我们不希望在使用它们之前产生和链接存根的额外步骤；我们希望这一切都是无缝的，这样，当我们编写可远程调用的服务器端方法时，客户端中的一两行代码就可以立即让我们访问这些方法及其类型签名。但是这意味着在服务器上创建一个对象也应该在客户机上创建一个对象(客户机存根)，这是一个完全不同的过程。我们如何做到这一点？我们不能将远程对象导入到客户端来转换它，因为那样也会导入该对象所依赖的所有服务器端代码。</p><p id="a5e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看来我们有一个第二十二条军规。</p><p id="e6cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可能还记得，TypeScript有一个特殊的<code class="fe mi mj mk ml b">import type</code>指令，它在不拉入可执行代码的情况下拉入类型数据。该类型数据包含了我们构建客户端存根所需的所有信息——方法名、它们的参数以及它们的返回值——因此我们可以使用它来完成这项工作，这似乎是合理的。但是我们不能。此类型信息仅在编译时可用于类型检查；当需要构造客户机存根的代码实际运行时，它在运行时不可用。</p><h1 id="706d" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">远程绑定协议</h1><p id="fcb7" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">摆脱第22条军规的方法是，除了使用<code class="fe mi mj mk ml b">import type</code>获取类型信息之外，还要实现一个远程绑定协议。在远程绑定协议中，客户端使用准系统IPC从服务器获取关于远程可调用对象的信息。它从接收到的信息中构造客户端存根，从而将每个客户端存根“绑定”到其远程对象。该解决方案使用<code class="fe mi mj mk ml b">import type</code>信息对客户端进程随后在这些绑定的客户端存根上进行的函数调用进行类型检查。</p><p id="0e3b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">电子亲和为窗口到主进程的调用实现了一个远程绑定协议，为主进程到窗口的调用实现了一个略有不同的绑定协议。该库将每个可远程调用的对象称为“API”，意思是“应用程序接口”每个API实际上是实现API的类的一个实例，类的名称就是API的名称。API的方法是可远程调用的函数。当进行远程调用时，客户端指示API和方法。</p><p id="0263" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下图说明了电子亲和用于公开主流程API，然后从窗口远程绑定到它们的协议:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/effb5786e8a9329c1c19bc296579e979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7FHjezvWijW1aWbi7Pp2w.png"/></div></div></figure><p id="d63b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个<a class="ae lk" href="https://developer.ibm.com/articles/the-sequence-diagram/" rel="noopener ugc nofollow" target="_blank"> UML序列图</a>。绿框代表进程或对象。它们下面的虚线是代表时间流逝的‘生命线’。黄色方框表示过程或对象激活。箭头显示对象之间发送的消息，破折号表示返回值。</p><p id="413e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该图显示了从类<code class="fe mi mj mk ml b">MainApi1</code>创建API并使其对窗口进程可用的主进程。它为API的每个方法创建了一个单独的服务器端存根，尽管图中只显示了<code class="fe mi mj mk ml b">methodA</code>的存根。只有在公开了所有必需的API之后，主进程才会创建任何可能需要使用这些API的窗口。然后，为了绑定到API，窗口请求API的方法列表。在接收到该列表后，窗口创建一个客户机存根，作为API的代理。</p><p id="4ae1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于主进程希望对窗口进程进行的调用，绑定协议略有不同。这个序列图说明了这一点:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/976950fbd76928ef09f150c2ce502415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tngG1XgJw7CC2SP71Gc6tg.png"/></div></div></figure><p id="4891" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下，当主进程试图绑定到一个窗口时，它使用一个超时来重复尝试绑定。这是必要的，因为主进程必须在窗口可以展示API之前创建窗口，要求主进程等待窗口使API可用。即便如此，如果束缚的时间太长，电子亲和力还是会出错。</p><p id="d7c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这两个协议的另一个区别是电子亲和不支持从窗口API返回值。</p><h1 id="4f5e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">定义远程API</h1><p id="e6a4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">如果一个可远程调用的方法的签名在客户机和服务器上都相同，那么它就不能是任何一个函数。虽然方法可以在服务器上快速运行并返回，但客户端必须等待参数到达服务器，然后等待返回值返回给客户端。幸运的是，如果我们要求远程方法返回<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>，相同的签名允许方法在服务器上同步，在客户端异步。</p><p id="8619" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是一个带有异步方法的主流程API的示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4764" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些方法返回承诺是很重要的，所以我们希望TypeScript强制执行这一点。但是如果我们扩展了一个库提供的类或者实现了一个库提供的接口，这个类或者接口也将指定方法的名字。我们将无法定义自定义API。因此，我们将调用我们的第一个打字稿魔术:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5aa7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>是约束主流程API签名的类型。这取决于类型<code class="fe mi mj mk ml b">PublicProperty&lt;keyof T&gt;</code>，它产生提供给<code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>的任何类型<code class="fe mi mj mk ml b">T</code>的公共属性。<code class="fe mi mj mk ml b">T</code>是API类。我们一会儿将更仔细地检查<code class="fe mi mj mk ml b">PublicProperty</code>。现在，让我们关注一下<code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>的结构:</p><pre class="kd ke kf kg gt ms ml mt mu aw mv bi"><span id="f365" class="mw lm in ml b gy mx my l mz na">{ [property_name]: property_type }</span></pre><p id="892f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">外面的花括号<code class="fe mi mj mk ml b">{}</code>表示我们正在定义一个对象。方括号<code class="fe mi mj mk ml b">[]</code>提供了这个对象的属性，一次评估一个属性。每个属性都被赋予冒号<code class="fe mi mj mk ml b">:</code>后面的类型。回头参考<code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>的定义，我们看到每个属性都是<code class="fe mi mj mk ml b">K in PublicProperty&lt;keyof T&gt;</code>，每个属性的类型都是<code class="fe mi mj mk ml b">(...args: any[]) =&gt; Promise&lt;any&gt;</code>。让我们把这些分解一下。</p><p id="0cbd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们首先需要了解类型<code class="fe mi mj mk ml b">PublicProperty&lt;P&gt;</code>。这个名字告诉我们，这种类型以某种方式产生了一个公共属性，但是到底什么是公共属性呢？TypeScript允许我们将属性声明为<code class="fe mi mj mk ml b">private</code>或<code class="fe mi mj mk ml b">protected</code>，因此所有缺少这些声明的属性都是潜在的公共属性。但是从ES2022开始，JavaScript也支持<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" rel="noopener ugc nofollow" target="_blank">私有属性</a>，特别是名称以<code class="fe mi mj mk ml b">#</code>开头的属性。此外，给属性加上前缀<code class="fe mi mj mk ml b">_</code>表示它们被视为私有的，这是长期以来的惯例，因此这些属性也应该算作私有的。因此，出于我们的目的，非公共属性是那些声明为<code class="fe mi mj mk ml b">private</code>的属性、那些声明为<code class="fe mi mj mk ml b">protected</code>的属性以及那些以<code class="fe mi mj mk ml b">#</code>或<code class="fe mi mj mk ml b">_</code>为前缀的属性；所有其他属性都是公共的。</p><p id="c2ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">类型<code class="fe mi mj mk ml b">PublicProperty&lt;P&gt;</code>包含以下形式的两个表达式，一个嵌套在另一个中:</p><pre class="kd ke kf kg gt ms ml mt mu aw mv bi"><span id="2010" class="mw lm in ml b gy mx my l mz na">A extends B ? C : D</span></pre><p id="a858" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a>的类型模拟。我们可以这样理解，“如果<code class="fe mi mj mk ml b">A</code>的类型是<code class="fe mi mj mk ml b">B</code>，那么求值为<code class="fe mi mj mk ml b">C</code>；否则评估为<code class="fe mi mj mk ml b">D</code>。”检查上面的<code class="fe mi mj mk ml b">PublicProperty&lt;P&gt;</code>的定义，我们看到如果<code class="fe mi mj mk ml b">P</code>是以<code class="fe mi mj mk ml b">_</code>或<code class="fe mi mj mk ml b">#</code>开头的字符串文字，那么它的值为类型<code class="fe mi mj mk ml b">never</code>，否则它的值为<code class="fe mi mj mk ml b">P</code>本身。类型<code class="fe mi mj mk ml b">never</code>表示“从不发生”，因此<code class="fe mi mj mk ml b">PublicProperty&lt;P&gt;</code>过滤掉带有前缀的<code class="fe mi mj mk ml b">P</code>。TypeScript可以计算编译时已知的字符串值，这是一件很神奇的事情。在我们的例子中，字符串将是方法名——TypeScript在编译时当然知道这些名称。</p><p id="50f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">实际的属性表达式是<code class="fe mi mj mk ml b">K in PublicProperty&lt;keyof T&gt;</code>。这里，<code class="fe mi mj mk ml b">keyof T</code>产生API类<code class="fe mi mj mk ml b">T</code>的所有公开声明的<em class="mm">属性</em>(“键】)；如果TypeScript声明了任何属性<code class="fe mi mj mk ml b">private</code>或<code class="fe mi mj mk ml b">protected</code>，<code class="fe mi mj mk ml b">keyof T</code>不会产生该属性。这是一件好事，因为<code class="fe mi mj mk ml b">PublicProperty</code>类型只查看属性名前缀，而不查看声明。当我们将集合<code class="fe mi mj mk ml b">keyof T</code>传递给<code class="fe mi mj mk ml b">PublicProperty&lt;keyof T&gt;</code>时，<code class="fe mi mj mk ml b">PublicProperty</code>类型产生了一组属性，该集合是对<code class="fe mi mj mk ml b">keyof T</code>的公共属性的进一步限制，只限于没有前缀<code class="fe mi mj mk ml b">_</code>或<code class="fe mi mj mk ml b">#</code>的公共属性。表达式<code class="fe mi mj mk ml b">K in PublicProperty&lt;keyof T&gt;</code>将<code class="fe mi mj mk ml b">K</code>分配给这个集合中的一个公共属性。当我们将这个表达式放在方括号<code class="fe mi mj mk ml b">[]</code>中时，我们枚举属性<code class="fe mi mj mk ml b">K</code>的所有可能值，并为每个值分配一个类型。</p><p id="d319" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">(技术上，<code class="fe mi mj mk ml b">keyof</code>也不会产生以<code class="fe mi mj mk ml b">#</code>开头的ES202私有属性；我只是想让<code class="fe mi mj mk ml b">PublicProperty&lt;P&gt;</code>在没有<code class="fe mi mj mk ml b">keyof</code>的情况下仍然有用。)</p><p id="8a7c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">API类型<code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>因此定义了<code class="fe mi mj mk ml b">T</code>的公共属性，约束了API对象的所有公共属性的类型。因为这种类型没有声明非公共属性，所以API对象(及其类)可以随意使用私有属性。例如，API类可以自由地将内部资源保存在私有成员中，并且可以自由地定义支持该类的API方法的私有方法。</p><p id="693d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>将每个公共属性限制为以下类型:</p><pre class="kd ke kf kg gt ms ml mt mu aw mv bi"><span id="5d1d" class="mw lm in ml b gy mx my l mz na">(...args: any[]) =&gt; Promise&lt;any&gt;</span></pre><p id="59be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个类型定义了一个函数签名。这里我们使用了普通JavaScript的魔力:参数。rest参数收集传递给该方法的参数位置及其之后的所有参数，将它们收集到一个给定名称的数组中，在本例中为<code class="fe mi mj mk ml b">args</code>。如果从那时起没有参数，数组为空。因此，该签名接受任意数量的参数，包括零个参数。它返回一个承诺，因此也定义了一个异步函数。</p><p id="05b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们把它们放在一起。表达式<code class="fe mi mj mk ml b">K in PublicProperty&lt;keyof T&gt;</code>一次给<code class="fe mi mj mk ml b">K</code>分配一个公共属性，所以每个<code class="fe mi mj mk ml b">K</code>都是API的公共属性，每个<code class="fe mi mj mk ml b">K</code>都有上面的类型签名。<code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>因此表示一个由<code class="fe mi mj mk ml b">T</code>的公共异步方法组成的对象。</p><p id="468d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在可以强制API类的所有公共属性成为返回承诺的方法，而不限制它们的名称或参数:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="648a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们见证了更多的类型脚本魔术:类型可以循环引用它自己，正如你在<code class="fe mi mj mk ml b">class MainApi1 implements ElectronMainApi&lt;MainApi1&gt;</code>中看到的。循环引用允许类型只约束方法返回值，而不约束方法名。使用<code class="fe mi mj mk ml b">implements</code>使TypeScript能够准确地标记API中出现问题的地方。</p><p id="44c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是库不能相信开发人员已经对API类应用了这种限制，所以用于公开API的函数也将API限制为这种类型:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="df8f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript从<code class="fe mi mj mk ml b">mainApi</code>推断泛型类型<code class="fe mi mj mk ml b">T</code>，所以调用者不需要单独提供<code class="fe mi mj mk ml b">T</code>。暴露<code class="fe mi mj mk ml b">MainApi1</code>的调用看起来像这样:</p><pre class="kd ke kf kg gt ms ml mt mu aw mv bi"><span id="4e97" class="mw lm in ml b gy mx my l mz na">exposeMainApi(MainApi1);</span></pre><p id="340a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果函数定义如下，<code class="fe mi mj mk ml b">T</code>将被推断为符合类型<code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>的<code class="fe mi mj mk ml b">mainApi</code>的任何子集，如果有的话，并且<code class="fe mi mj mk ml b">mainApi</code>根本不会被约束:</p><pre class="kd ke kf kg gt ms ml mt mu aw mv bi"><span id="eada" class="mw lm in ml b gy mx my l mz na">// incorrect<br/>function exposeMainApi&lt;T&gt;(mainApi: ElectronMainApi&lt;T&gt;): void</span></pre><h1 id="2819" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">构建服务器存根</h1><p id="55d9" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">函数<code class="fe mi mj mk ml b">exposeMainApi(mainApi)</code>构建服务器存根，使客户端可以使用<code class="fe mi mj mk ml b">mainApi</code>的方法。它通过迭代<code class="fe mi mj mk ml b">mainApi</code>的公共属性来实现这一点，这些属性必须是异步方法，并对每个方法执行以下操作:</p><ul class=""><li id="f818" class="nb nc in kq b kr ks ku kv kx nd lb ne lf nf lj ng nh ni nj bi translated">创建一个服务器存根，在调用方法本身时调用该方法。</li><li id="edf9" class="nb nc in kq b kr nk ku nl kx nm lb nn lf no lj ng nh ni nj bi translated">在IPC通道上注册服务器存根，以便当客户端通过通道发送方法参数时，存根可以接收这些参数。</li><li id="b373" class="nb nc in kq b kr nk ku nl kx nm lb nn lf no lj ng nh ni nj bi translated">跟踪与API相关联的方法，以便当客户端请求绑定到API时，可以将它们发送到客户端。</li></ul><p id="ca13" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不需要太多的代码，但是很复杂。为了实现这一点，我们必须从普通的JavaScript调用一些魔法:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7845" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数<code class="fe mi mj mk ml b"><a class="ae lk" href="https://github.com/jtlapp/electron-affinity/blob/6e8be9019bee5a7e98a5ac24a3cdd6cc25f475e7/src/lib/shared_lib.ts#L83" rel="noopener ugc nofollow" target="_blank">getPropertyNames</a></code>是一个定制函数，它返回一个<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank"> iterable </a>，迭代一个对象的所有属性，包括从超类继承的属性，但有一些例外。<code class="fe mi mj mk ml b">registerIpcHandler</code>是将函数参数附加到IPC通道的函数的替代。该函数参数是单个API方法的服务器存根。</p><p id="d374" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这段代码的神奇之处在于:</p><ul class=""><li id="376f" class="nb nc in kq b kr ks ku kv kx nd lb ne lf nf lj ng nh ni nj bi translated">JavaScript允许我们在运行时迭代对象的属性。</li><li id="7e15" class="nb nc in kq b kr nk ku nl kx nm lb nn lf no lj ng nh ni nj bi translated">给定对象的任何方法的名称，我们可以得到方法本身。在这种情况下，我们从<code class="fe mi mj mk ml b">mainApi[methodName]</code>得到函数<code class="fe mi mj mk ml b">method</code>。</li><li id="0326" class="nb nc in kq b kr nk ku nl kx nm lb nn lf no lj ng nh ni nj bi translated">JavaScript的<code class="fe mi mj mk ml b">bind</code>方法允许我们分配函数被调用时使用的<code class="fe mi mj mk ml b">this</code>值。<code class="fe mi mj mk ml b">method.bind(mainApi)</code>将<code class="fe mi mj mk ml b">this</code>设置为<code class="fe mi mj mk ml b">mainApi</code>，允许该函数访问<code class="fe mi mj mk ml b">mainApi</code>的私有属性。</li><li id="cab0" class="nb nc in kq b kr nk ku nl kx nm lb nn lf no lj ng nh ni nj bi translated">我们已经看到了使用<code class="fe mi mj mk ml b">...args</code>作为参数，但是这里我们把它作为一个参数。在本例中，<code class="fe mi mj mk ml b">...</code>是一个<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>，它将数组<code class="fe mi mj mk ml b">args</code>的内容扩展成一系列独立的参数。</li></ul><p id="6e1d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可能已经注意到，上面的代码只过滤掉了带有<code class="fe mi mj mk ml b">_</code>或<code class="fe mi mj mk ml b">#</code>前缀的私有属性。这是因为<code class="fe mi mj mk ml b">private</code>和<code class="fe mi mj mk ml b">protected</code>声明只在编译时存在；在运行时，我们使用纯JavaScript。因此，代码为缺少这些前缀的非公共属性生成存根。这不是问题，因为正如我们将看到的，我们在客户端使用的类型不会使这些属性可用。</p><p id="1f79" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设服务器也处理客户端对方法名的请求，那么服务器端就完成了，API方法可以远程调用。</p><h1 id="e867" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">客户端API绑定</h1><p id="682e" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在窗口可以使用主进程API之前，它必须首先将一个存根绑定到API。这个存根(客户机存根)是一个对象，它拥有远程API的所有公共方法，并使API看起来好像是客户机本地的。电子亲和将这些存根称为“API绑定”或简称为“绑定”以下是该库创建和使用绑定的方式:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bd41" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数<code class="fe mi mj mk ml b">bindMainApi</code>创建每个绑定。我们之前用方法<code class="fe mi mj mk ml b">methodA</code>、<code class="fe mi mj mk ml b">methodB</code>等定义了服务器端类<code class="fe mi mj mk ml b">MainApi1</code>。在客户机中，绑定<code class="fe mi mj mk ml b">mainApi1</code>有这些相同的方法，客户机正在调用它们。调用这些方法之一最终会导致调用同名的远程方法，然后检索其返回值(如果有返回值的话)。</p><p id="b114" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个绑定符合类型<code class="fe mi mj mk ml b">MainApiBinding</code>，定义如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d364" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种类型简单但有效。客户端提供远程API类的类型作为通用参数<code class="fe mi mj mk ml b">T</code>。表达式<code class="fe mi mj mk ml b">keyof T</code>产生API类的所有公开声明的属性名的集合。<code class="fe mi mj mk ml b">PublicProperty</code>进一步将这个集合限制为那些没有前缀<code class="fe mi mj mk ml b">_</code>或<code class="fe mi mj mk ml b">#</code>的集合，所以我们将<code class="fe mi mj mk ml b">MainApiBinding&lt;T&gt;</code>定义为一个只具有<code class="fe mi mj mk ml b">T</code>属性的对象，用于公共用途。回想一下，服务器端类型<code class="fe mi mj mk ml b">ElectronMainApi&lt;T&gt;</code>将<code class="fe mi mj mk ml b">T</code>的所有公共属性限制为异步方法；<code class="fe mi mj mk ml b">MainApiBinding&lt;T&gt;</code>因此正是由这些方法组成的。如果已经在服务器上为没有前缀<code class="fe mi mj mk ml b">_</code>或<code class="fe mi mj mk ml b">#</code>的非公共属性生成了存根，<code class="fe mi mj mk ml b">MainApiBinding&lt;T&gt;</code>将不会使该属性对客户端可用。</p><p id="c6cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的示例代码中，客户端绑定<code class="fe mi mj mk ml b">mainApi1</code>具有类型<code class="fe mi mj mk ml b">MainApiBinding&lt;MainApi1&gt;</code>，为其提供了远程服务器类<code class="fe mi mj mk ml b">MainApi1</code>的所有公共方法。虽然客户端和服务器方法具有相同的类型签名，但它们的实现却大不相同。</p><p id="573d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种解决方案使得在TypeScript中维护API变得容易，特别是在电子应用程序中，客户端和服务器代码属于同一个源代码库。将方法添加到API(服务器端)可以让客户端立即使用它们，而在API中更改方法签名会阻止客户端进行编译，直到客户端的调用得到适当的修改。看到<a class="ae lk" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>为服务器上的API所做的每一个改变而立即改变客户端中的代码自动完成和代码帮助是很神奇的。</p><h1 id="a291" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">构造API绑定</h1><p id="195d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们已经看到函数<code class="fe mi mj mk ml b">bindMainApi</code>负责构建客户端存根API绑定——但是我们还没有看到它是如何做的。幸运的是，这非常简单。该函数从主进程中检索API的方法名，并为每个方法名构造一个函数，该函数执行以下操作:</p><ul class=""><li id="1e24" class="nb nc in kq b kr ks ku kv kx nd lb ne lf nf lj ng nh ni nj bi translated">接收传递给该方法的任何参数。</li><li id="23e2" class="nb nc in kq b kr nk ku nl kx nm lb nn lf no lj ng nh ni nj bi translated">通过IPC将参数发送到专用于该方法的通道上的主进程。</li><li id="db1e" class="nb nc in kq b kr nk ku nl kx nm lb nn lf no lj ng nh ni nj bi translated">等待主进程的响应。</li><li id="103f" class="nb nc in kq b kr nk ku nl kx nm lb nn lf no lj ng nh ni nj bi translated">将结果返回给调用者。</li></ul><p id="c6a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mi mj mk ml b">bindMainApi</code>将这个函数附加到客户机存根上，赋予它相同的方法名，这样在存根上调用这个方法就会调用这个函数。</p><p id="b7e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是来自<code class="fe mi mj mk ml b">bindMainApi</code>的相关代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8684" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数<code class="fe mi mj mk ml b">requestApiMethods</code>和<code class="fe mi mj mk ml b">sendIpcAndGetResponse</code>都是实际代码的替身。<code class="fe mi mj mk ml b">requestApiMethods</code>使用基本的IPC向主进程发送消息，并检索提供给它的类的方法名。<code class="fe mi mj mk ml b">sendIpcAndGetResponse</code>使用为特定API类/方法对指定的IPC通道来调用远程API类上的方法。</p><p id="6987" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们使用了一点JavaScript魔法来构造将作为API绑定的对象。代码通过一次附加一个方法在<code class="fe mi mj mk ml b">boundApi</code>中构建绑定。它附加的每个方法都是一个接受rest参数<code class="fe mi mj mk ml b">...args</code>的函数，因此该函数可以有任意数量的参数。该函数将这些参数和一个方法标识符传递给<code class="fe mi mj mk ml b">sendIpcAndGetResponse</code>，然后等待响应。响应的返回值作为函数的返回值返回。当远程方法不返回值时，函数返回<code class="fe mi mj mk ml b">undefined</code>。</p><p id="a836" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript在这里也贡献了一些魔力。考虑这个客户端调用<code class="fe mi mj mk ml b">bindMainApi</code>来获取API绑定的演示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="37ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当调用<code class="fe mi mj mk ml b">bindMainApi</code>时，客户端提供通用参数<code class="fe mi mj mk ml b">T</code>，为其指定类型<code class="fe mi mj mk ml b">MainApi1</code>。因此，TypeScript将返回值的类型指定为<code class="fe mi mj mk ml b">MainApiBinding&lt;MainApi1&gt;</code>，这为绑定<code class="fe mi mj mk ml b">mainApi1</code>提供了<code class="fe mi mj mk ml b">MainApi1</code>的所有公共方法，包括它们各自的类型签名。这就是为什么在服务器端代码中对<code class="fe mi mj mk ml b">MainApi1</code>所做的更改会立即影响客户端代码——也许这是最神奇的事情。</p><h1 id="b03c" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">神奇冰山的一角</h1><p id="f16e" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们已经看到TypeScript及其JavaScript子集做了一些神奇的事情，但这只是冰山一角。作为一种原型语言，JavaScript在它所能表达的方面有着非凡的表现力。微软的人试图让TypeScript能够捕捉这种表现力中发现的所有类型，令人惊讶的是，他们似乎已经成功了。</p><p id="5a68" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript不断地扩展我对类型可能性的想象，你会在<a class="ae lk" href="https://github.com/jtlapp/electron-affinity" rel="noopener ugc nofollow" target="_blank">电子亲和力</a>中发现比我在这里描述的更多的类型魔力。例如，电子亲合性可以自动恢复IPC传递的对象的类，当API认为调用方应对错误负责时，可以诱导它们的远程调用方抛出异常。</p><p id="29c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您还没有踏上使用TypeScript的旅程，我希望您能加入我的行列。</p><p id="b9f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mm">更多内容看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mm">说白了。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mm">免费周报</em> </strong> </a> <em class="mm">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mm">Twitter</em></strong></a><em class="mm">和</em><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mm">LinkedIn</em></strong></a><em class="mm">。加入我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mm">社区</em> </strong> </a> <em class="mm">。</em></strong></a></p></div></div>    
</body>
</html>