<html>
<head>
<title>Let’s Discover Svelte: A Comprehensive Beginner-Friendly Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们发现苗条:一个全面的初学者友好的介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-discover-svelte-a-comprehensive-beginner-friendly-introduction-67eb57f36127?source=collection_archive---------15-----------------------#2022-03-03">https://javascript.plainenglish.io/lets-discover-svelte-a-comprehensive-beginner-friendly-introduction-67eb57f36127?source=collection_archive---------15-----------------------#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd69" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Svelte是否足够成熟，可以开始一个新的项目？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/85c6b7801f4d648af873408ba2ff1ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3RXStPb5cKpqrKTHxP07Q.png"/></div></div></figure><p id="902a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能已经听说过这个新的前端框架——另一个？！—它开始为自己命名，并被证明与竞争对手一样有前途，它被命名为:<strong class="kt ir"> Svelte </strong>。如果你还没听说过，现在是时候澄清事实了。但是别担心，我会一直保护你的！</p><h1 id="a99c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">但事实上，什么是苗条呢？</h1><p id="5e8a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated"><strong class="kt ir">纤薄</strong>是前端技术领域逐渐形成的新趋势。它以其<em class="mk">“编写更少的代码”</em>的概念而闻名，这一概念包括编写更少的代码以获得同样高效的结果。这是其创造者<a class="ae ml" href="https://twitter.com/rich_harris" rel="noopener ugc nofollow" target="_blank"> Rich Harris </a>的承诺之一，他是《纽约时报》的平面编辑，也是<a class="ae ml" href="https://ractive.js.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> Ractive.js </em> </a>的作者。</p><p id="7a84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我写这篇文章的时候，Svelte已经是第3版了。是的，自2016年发布以来，这个很少受到关注的框架取得了巨大的成功，并成功应对了我们今天都知道的市场巨兽。它在GitHub上有近57000颗星。自己看:<a class="ae ml" href="https://github.com/sveltejs/svelte" rel="noopener ugc nofollow" target="_blank"> Svelte的GitHub </a>。</p><h1 id="b624" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">好吧！但是为什么要苗条呢？</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">G<a class="ae ml" href="https://media.giphy.com/media/QmDgpAv8JKrxXtrnmR/giphy.gif" rel="noopener ugc nofollow" target="_blank">iphy</a></figcaption></figure><p id="a71e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来是存在主义问题:“<em class="mk">当其他人做得很好的时候，我为什么要费心学习一个新的框架呢？</em>“正如我之前提到的，<strong class="kt ir"/>从一个非常简单的想法开始:编写更少的代码——但这不是它提供的唯一好处。</p><p id="1d9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在构建阶段，将你的组件编译成命令式代码，换句话说，编译成你的网络浏览器可以理解的代码。这允许您在页面中加载单个bundle . js——顺便也加载bundle.css以便浏览器只负责呈现您的应用程序。这不需要在运行时加载框架，甚至不需要虚拟DOM，因为后者被认为太慢了。</p><h1 id="9874" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">在用法上，它是什么样子的？</h1><h2 id="eb69" class="ms lo iq bd lp mt mu dn lt mv mw dp lx la mx my lz le mz na mb li nb nc md nd bi translated">初学者友好的语法</h2><p id="6286" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">谁说代码越少，维护的样板文件就越少，语法就越容易使用。系好你的安全带，我们一起去看。如果你从未见过用Svelte编写的组件，这里有一个非常基本的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne mn l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6984" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">身材苗条</strong>对吧？如果我们与React进行比较，您可能应该写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4800" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并带有棱角:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="da2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果是没有上诉！分别计算125、207和240个字符的苗条、反应和角度。如你所见，用Svelte:我们直奔主题。使用熟悉的<style>和&lt;script&gt;标签来定义组件。&lt;/root&gt;</style></p><p id="83af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个组件纯粹是由<strong class="kt ir"> HTML </strong>、<strong class="kt ir"> CSS </strong>和<strong class="kt ir"> JavaScript </strong>组成。请注意，您在<strong class="kt ir"> <em class="mk"> &lt;脚本&gt; </em> </strong>标签中定义的所有内容都可以从您的HTML模板中访问，并且组件中包含的CSS被封装。</p><p id="6c16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">换句话说，您不可能影响其他组件。指定每个组件的声明必须使用<code class="fe nf ng nh ni b">.svelte</code>扩展名是很重要的。</p><h1 id="6735" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">输入/输出管理</h1><p id="cb02" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Svelte是一个面向组件的框架。与大多数同行一样，有一些反复出现的概念，如组件之间的交互和确保通信。让我们从创建一个<code class="fe nf ng nh ni b">User.svelte</code>组件开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2c2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，export关键字用于指示要评估的属性，以便与我们的组件进行交互。这是您声明组件输入的唯一方式。一旦它被创建，从我们的<code class="fe nf ng nh ni b">App.svelte</code>你只需要像这样导入它:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="946c" class="ms lo iq ni b gy nn no l np nq">&lt;script&gt;<br/>import User from ‘./User.svelte’;<br/>&lt;/script&gt;</span></pre><p id="3488" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能已经注意到，我们的组件的定义不包含任何命名的概念，并且出于很好的原因，<strong class="kt ir">您的组件的命名仅使用import关键字</strong>来完成。所以它们可以像普通的HTML元素一样使用。现在让我们继续下一步，这包括用所需的值来评估id、用户名和个人信息属性:<code class="fe nf ng nh ni b">&lt;User {...user} /&gt;</code>。</p><p id="e80c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这一评级应持保留态度。滥用它会极大地降低对代码的理解。特别是因为不建议分解，因为很难优化苗条。<br/>这一切中的输出是什么？！从DOM或组件订阅事件是通过使用<strong class="kt ir"> on，</strong>指令来完成的。然而，发出一个事件意味着它之前已经使用<strong class="kt ir"> createEventDispatcher </strong>方法定义过了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f3fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">允许您创建事件调度程序的<strong class="kt ir"> createEventDispatcher </strong>方法是带有两个参数的函数:一个名称和一个有效负载。在上面的例子中，已经创建了<strong class="kt ir">选择的</strong>事件，剩下的就是从我们的<code class="fe nf ng nh ni b">App.svelte</code>订阅它，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6b1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的是，传输的有效载荷实现了JavaScript API的<strong class="kt ir"> CustomEvent </strong>接口。所以当它发出时，我们的<strong class="kt ir"> <em class="mk"> id </em> </strong>和<strong class="kt ir"> <em class="mk">用户名</em> </strong>数据可以通过我们的事件对象的详细属性来访问。最后，当我们单击我们的用户组件时，我们会得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/08d9d8a50d9316731ae79681c8aaaff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mlbRP71CaMcMSO2Kc_q7A.png"/></div></div></figure><h1 id="3ada" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak"> $:像命运运算符</strong></h1><p id="1a6c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果现在，我跟你谈谈<strong class="kt ir">命运操作员</strong>！这让你想起什么了吗？下面的例子应该有助于你更清楚地看到这一点:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="be67" class="ms lo iq ni b gy nn no l np nq">var x = 5;<br/>var y &lt;= x + 1;<br/> x = 10;<br/>Assert.AreEqual(11, y);</span></pre><p id="53e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总是一无所获？！上面的例子可以翻译成JavaScript，如下所示:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="9908" class="ms lo iq ni b gy nn no l np nq">var x = 5;<br/>var y = x + 1;<br/>x = 10;<br/>y = x + 1;<br/>Assert.AreEqual(11, y);</span></pre><p id="d61a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那应该更清楚一点吧！事实上，第一个例子说明了<strong class="kt ir">命运概念</strong>运算符。这表示变量不需要在每次它所依赖的值改变时被重新分配。</p><p id="1836" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是和苗条有什么关系呢？Svelte建立在这一概念的基础上，并结合了所谓的“<strong class="kt ir">反应式报告</strong>”。因此，对于Svelte，通过在指令前面加上<strong class="kt ir"> $: </strong>这样的前缀，指令就变得具有反应性了:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="46ce" class="ms lo iq ni b gy nn no l np nq">let x = 5;<br/>$: y = x + 1;<br/>x = 10;<br/>Assert.AreEqual(11, y);</span></pre><p id="f06c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，使用<strong class="kt ir"> $: </strong>前缀有一些限制，这是有充分理由的:语句响应只由赋值触发。让我们仔细看看！这一次，让我们处理一组<strong class="kt ir">用户。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e6b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们再举一个例子，声明“反应”变量<code class="fe nf ng nh ni b">usernames</code>，它包含一个姓名列表并显示所有这些漂亮的人:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8a22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当按钮被单击时，我们不会得到预期的效果，原因很简单:pop、shift、unshift和splice等数组对象方法不会导致自动更新，因为对象引用保持不变。这就是为什么我们在添加新元素时必须重新分配<strong class="kt ir"> users </strong>变量:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="c227" class="ms lo iq ni b gy nn no l np nq">&lt;script&gt;<br/>[…]</span><span id="9c5d" class="ms lo iq ni b gy ns no l np nq">function addUser() {<br/>[…]</span><span id="8510" class="ms lo iq ni b gy ns no l np nq">users = users;<br/>}<br/>&lt;/script&gt;</span></pre><p id="c669" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更简洁的语法是使用分解并只进行一次赋值:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="82e8" class="ms lo iq ni b gy nn no l np nq">&lt;script&gt;<br/>[…]</span><span id="f581" class="ms lo iq ni b gy ns no l np nq">function addUser() {<br/>[…]</span><span id="b163" class="ms lo iq ni b gy ns no l np nq"> users = [<br/>   …users,<br/>   newUser<br/> ];<br/>}<br/>&lt;/script&gt;</span></pre><h1 id="efbf" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">这一切的表现在哪里？</h1><p id="a6b6" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">造物主做出的另一个承诺与性能直接相关。谁说命令式代码，谁说直接操纵DOM的低级代码，所有这些都没有技巧。证明就是，下面是Svelte，Vue.js，React，Angular的对比。</p><blockquote class="nt nu nv"><p id="9fce" class="kr ks mk kt b ku kv jr kw kx ky ju kz nw lb lc ld nx lf lg lh ny lj lk ll lm ij bi translated">我将使用这个<a class="ae ml" href="https://krausest.github.io/js-framework-benchmark/2022/table_chrome_98.0.4758.80.html" rel="noopener ugc nofollow" target="_blank">网站</a>来比较所有框架的性能。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/2eb6cef3fe2d88a45f02fa2c3eb79e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0r4w0r_aJG6-idKZM-6eAA.png"/></div></div></figure><h1 id="25cd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">所以，最后呢？</h1><p id="e9fa" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">总之，你应该已经明白:<strong class="kt ir"> Svelte </strong>是自给自足的，不需要框架或第三方库来工作。随着前端领域中存在过多的技术，下面的问题必然会被提出:“<em class="mk">Svelte是否足够成熟来启动一个新项目？</em>“我会回答你，框架的第3版是一个相当重要的可靠性指标，而不是无关紧要的指标。</p><p id="d4a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特别要记住，Svelte也有一个很棒的社区。锦上添花，苗条还兼容<a class="ae ml" href="https://github.com/rspieker/jest-transform-svelte" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk"> Jest </em> </strong> </a>和<a class="ae ml" href="https://storybook.js.org/tutorials/intro-to-storybook/svelte/en/get-started/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">story book</em></strong></a>，分别运行你的单元测试和构建你的组件库。有趣的是，它与<a class="ae ml" href="https://github.com/sveltejs/template-webpack" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">web pack</em></strong></a>进行了简单的集成，以便于应用程序的开发和部署。</p><p id="9262" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这最终表明，苗条引起了用户的很大兴趣。此外，创建者表现出想要去除其他框架经常遇到的令人畏惧的任务，比如初始化一个新项目。</p><p id="572a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样一来，学习时间就大大减少了。我建议你一件事:你自己试试，你会被争取过来的。</p><p id="fce8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mk">更多内容看</em> <a class="ae ml" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">说白了就是</em> </strong> </a> <em class="mk">。报名参加我们的</em> <a class="ae ml" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">免费每周简讯</em> </strong> </a> <em class="mk">。关注我们</em> <a class="ae ml" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">推特</em> </strong> </a> <em class="mk">和</em><a class="ae ml" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">LinkedIn</em></strong></a><em class="mk">。加入我们的</em> <a class="ae ml" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">社区不和谐</em> </strong> </a> <em class="mk">。</em></p></div></div>    
</body>
</html>