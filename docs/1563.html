<html>
<head>
<title>Build Passages with Corners in a JavaScript Roguelike</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript脚本中构建带角的段落</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-roguelikes-connecting-diagonal-dungeon-rooms-using-corners-79f460f96615?source=collection_archive---------4-----------------------#2022-04-02">https://javascript.plainenglish.io/javascript-roguelikes-connecting-diagonal-dungeon-rooms-using-corners-79f460f96615?source=collection_archive---------4-----------------------#2022-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8532dbf7914945b09f08970f6ff6a2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3MrieMAOwAcFOyYvnC0Dw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by Author</figcaption></figure><p id="4ef9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想要一个可视化的有挑战性的编程任务，试着写一个自动生成关卡的冒险游戏。有时候，我正在写逻辑，把房间和通道连接起来，我发现自己拿起一张纸，画了许多图表来检查我的想法。</p><p id="b3d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在过去的几周里，我一直在用JavaScript为rogue likes——涉及过程级生成的2D冒险游戏——写房间生成算法。</p><p id="515e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在之前的教程中，我讲述了如何只用直走廊连接房间。虽然这对于彼此面对的房间很有效，但是成对的彼此对角的房间却被忽略了！结果，我们最终得到的是不相连的房间网络，如下图所示。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/b4b15c3fac26c4d8ea841c79ad7b2916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqmcyirZJuHBatMqC1J67w.png"/></div></div></figure><p id="ccfa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本教程中，我们将编写逻辑，使用两个在拐角处相交的通道连接两个对角放置的房间。结果将会是一个看起来像下面的游戏关卡。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/b9387860fe09146f5421bcc1cd2e7754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUi5yca3npz0pUFiyJ9gyA.png"/></div></div></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="bc63" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请随意阅读这篇文章或完成部分或全部项目，这取决于您在旅程中所处的位置。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="5893" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">项目文件</h1><p id="63b2" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">虽然本文涵盖了一个更大的游戏项目的一部分，但是每个阶段都有自己的起始代码目录，因此您可以直接进入第4阶段，而无需任何前期工作。</p><p id="18e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要下载项目目录，可以去这个<a class="ae la" href="https://github.com/nevkatz/js-roguelike-rooms" rel="noopener ugc nofollow" target="_blank"> Git repo </a>，点击<em class="mr">代码</em>，点击<em class="mr">下载ZIP。</em>或者，您可以从命令行克隆它:</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="97d1" class="mx lp iq mt b gy my mz l na nb">git clone https://github.com/nevkatz/js-roguelike-rooms.git</span></pre><p id="79d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下载的repo中，有一个<code class="fe nc nd ne mt b">phase-4-corners</code>目录，您可以使用下面的结构在其中工作。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="19b4" class="mx lp iq mt b gy my mz l na nb">phase-4-corners<br/>  |<br/>  *--index.html<br/>  |<br/>  *--css <br/>  |   |<br/>  |   *--style.css<br/>  |<br/>  |<br/>  *--js <br/>      |<br/>      *--<strong class="mt ir">script.js</strong><br/>      |<br/>      *--game.js<br/>      |<br/>      *--<strong class="mt ir">room.js</strong><br/>      |<br/>      *--path.js</span></pre><p id="51e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个阶段4目录中，先前阶段的所有方法都已经完成。这可以让您腾出手来完成手头的任务，这些任务出现在两个JavaScript文件中:</p><ul class=""><li id="871e" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated"><code class="fe nc nd ne mt b">script.js</code>，运行游戏</li><li id="28db" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated"><code class="fe nc nd ne mt b">room.js</code>，其中包含了<code class="fe nc nd ne mt b">Room</code>类</li></ul><p id="788a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果有帮助的话，您可以查看一下<code class="fe nc nd ne mt b">phase-5-recursion</code>目录中的完整代码，这是下一篇教程要用到的，还有<code class="fe nc nd ne mt b">solutions</code>目录。</p><h1 id="7acb" class="lo lp iq bd lq lr nt lt lu lv nu lx ly lz nv mb mc md nw mf mg mh nx mj mk ml bi translated">概观</h1><p id="19cf" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">我们将在<code class="fe nc nd ne mt b">room.js</code>中编写实现以下功能的方法:</p><ul class=""><li id="1afe" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated">查找附近的房间</li><li id="2860" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">用一对垂直的路径连接对角的一对房间</li></ul><p id="282d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe nc nd ne mt b">room.js</code>中写入上述逻辑后，我们将在<code class="fe nc nd ne mt b">script.js</code>中激活它。如果完成的算法运行在两个房间的对角线上，它将尝试用相交于一个角的两条线将它们连接起来。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e1eda2f125af63c917e3b9bcf28669c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*MnCYqhlB8_UHDeOuAzlhGg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Diagonal rooms can still connect</figcaption></figure><p id="b735" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nc nd ne mt b">script.js</code>中处理等级生成的功能是<code class="fe nc nd ne mt b">generateMapRooms</code>。到目前为止，它看起来像下面的函数。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">generateMapRooms function.</figcaption></figure><p id="e696" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，房间生成后，我们将遍历所有房间。在下面的代码中，每个房间都试图连接到直接面对它的一个房间。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="e966" class="mx lp iq mt b gy my mz l na nb">for (var room of game.rooms) {       <br/> <br/>      success = room.findFacingRooms(min); </span><span id="ccfc" class="mx lp iq mt b gy ob mz l na nb">}</span></pre><p id="6353" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个循环中，我们将最终添加一个额外的功能，<code class="fe nc nd ne mt b">nearestNeighbor</code>，它根据中心之间的距离找到最近的可用房间，并尝试与之连接。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="4864" class="mx lp iq mt b gy my mz l na nb">for (var room of game.rooms) {       <br/> <br/>      success = room.findFacingRooms(min);</span><span id="d8e9" class="mx lp iq mt b gy ob mz l na nb">     <strong class="mt ir"> success = nearestNeighbor();<br/></strong>}</span></pre><p id="968f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果房间是斜向的，我们将编写额外的逻辑来处理这个问题，通过建立两个在一个角落相交的垂直走廊。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="01a5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">查找附近的邻居</h1><p id="2987" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">在我们连接到一个房间之前，我们必须找到一个——<code class="fe nc nd ne mt b">nearestNeighbor</code>的目标是找到最近的可用房间。它是这样工作的:</p><ul class=""><li id="b842" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated">通过过滤掉方法调用(MC)房间和它已经连接到的房间，制作一个可用测试房间的列表。</li><li id="7cfe" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">从最近到最远对房间进行排序。</li><li id="b72b" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">首先尝试连接到最近的房间。</li><li id="09d3" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">如果不起作用，尝试下一个最接近的。</li><li id="9f7c" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">重复，直到我们找到一个房间或到达列表的末尾。</li></ul><p id="aa0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">过程就是这样。让我们打开<code class="fe nc nd ne mt b">room.js</code>文件，并在现有的<code class="fe nc nd ne mt b">nearestNeighbor</code>方法中声明一个<code class="fe nc nd ne mt b">success</code>变量。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="747f" class="mx lp iq mt b gy my mz l na nb">Room.prototype.nearestNeighbor = function(rooms) {</span><span id="a304" class="mx lp iq mt b gy ob mz l na nb"><strong class="mt ir">   let success = false;</strong></span><span id="18ea" class="mx lp iq mt b gy ob mz l na nb">}</span></pre><h2 id="c617" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">过滤室</h2><p id="1970" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">在这个方法中，让我们找到潜在的房间——要么从传入的参数中，要么从上一篇教程中的<code class="fe nc nd ne mt b">findPotentialRooms()</code>函数中，</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="664e" class="mx lp iq mt b gy my mz l na nb">let success = false;</span><span id="a188" class="mx lp iq mt b gy ob mz l na nb"><strong class="mt ir">rooms = rooms || this.findPotentialRooms();</strong></span></pre><p id="6e92" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是<code class="fe nc nd ne mt b">findPotentialRooms</code>，一个<code class="fe nc nd ne mt b">Room</code>对象用它从游戏范围的<code class="fe nc nd ne mt b">rooms</code>数组中过滤掉它自己和它的邻居。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4905" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们使用另一种自定义方法过滤掉被中间房间阻挡的那些，这种方法已经在我们的<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9">之前的教程</a> : <code class="fe nc nd ne mt b">roomBetween</code>中编写和介绍过。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="bb6e" class="mx lp iq mt b gy my mz l na nb">rooms = rooms.filter(x =&gt; !this.roomBetween(x));</span></pre><h2 id="f2ee" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">查找房间的邻近度</h2><p id="c435" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">为了评估一个给定的房间有多近，我们需要一点数学知识。让我们看看下面的两个房间，中心之间的距离是一个直角三角形的斜边。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/e3b2b3d697865fdec9c841783162c250.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Uzh2x6IlLyAZ1TKEOhA3OA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The distance between centers</figcaption></figure><p id="b870" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要求距离，我们可以减去坐标，得到三角形的两条“腿”。然后我们可以把它们加在一起，求出平方根。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/5449cae44a910e98616191af5b7001f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jo64_l74kszCG4ATVcSJBQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image from Google search results.</figcaption></figure><p id="8364" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">辅助函数<code class="fe nc nd ne mt b">distanceTo</code>使用这个距离公式找到两个房间中心之间的距离。下面是完整的功能。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The distanceTo method.</figcaption></figure><p id="58f1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看当紫色房间调用方法时，函数是如何与图连接的。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/fc9c4ba37feedb61d6965c4386548b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*EsxEThdaFiU1fa_qwVXnfg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">In the code, the purple room calling the method is known as “this.” The other one is “room.”</figcaption></figure><ul class=""><li id="f76d" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated"><em class="mr"> x1 </em>和<em class="mr"> x2 </em>写成<code class="fe nc nd ne mt b">this.center.x</code>和<code class="fe nc nd ne mt b">room.center.x</code>。</li><li id="d384" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">同时，<em class="mr"> y1 </em>和<em class="mr"> y2 </em>分别是<code class="fe nc nd ne mt b">this.center.y</code>和<code class="fe nc nd ne mt b">room.center.y</code>。</li><li id="74bf" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated"><code class="fe nc nd ne mt b">x</code>值之差为<code class="fe nc nd ne mt b">diffX</code>。</li></ul><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="abdf" class="mx lp iq mt b gy my mz l na nb">let diffX = this.center.x - room.center.x;</span></pre><ul class=""><li id="4ab8" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated"><code class="fe nc nd ne mt b">y</code>值之差为<code class="fe nc nd ne mt b">diffY</code>。</li></ul><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="7b7e" class="mx lp iq mt b gy my mz l na nb">let diffY = this.center.y - room.center.y;</span></pre><ul class=""><li id="da82" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated">在下面的行中，<code class="fe nc nd ne mt b">Math.pow()</code>计算每个距离的平方，<code class="fe nc nd ne mt b">Math.sqrt()</code>计算总和的平方根。</li></ul><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="e613" class="mx lp iq mt b gy my mz l na nb">let d = <strong class="mt ir">Math.sqrt</strong>(<strong class="mt ir">Math.pow</strong>(diffX, 2) + <strong class="mt ir">Math.pow</strong>(diffY, 2));</span></pre><h2 id="a3df" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">根据距离对房间进行分类</h2><p id="b0d7" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">现在<code class="fe nc nd ne mt b">distanceTo</code>已经完成，让我们编写第二个助手，我们可以用它来根据房间离方法调用房间的远近对它们进行排序。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="10bf" class="mx lp iq mt b gy my mz l na nb">const compareDist = (room1,room2) =&gt; {<br/>      return distanceTo(room1) - distanceTo(room2);<br/>};</span></pre><p id="8787" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的助手就位后，让我们将房间从近到远排序。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="8fb5" class="mx lp iq mt b gy my mz l na nb">let sorted = rooms.sort(compareDist);</span></pre><h2 id="534a" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">尝试连接到可能的房间</h2><p id="be2c" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">最后，让我们循环遍历各个房间，并在房间成功连接一个房间时返回。最近的房间有优先权，但是如果一个不行，我们就去下一个最近的房间。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="469b" class="mx lp iq mt b gy my mz l na nb">for (let room of sorted) {</span><span id="7cb2" class="mx lp iq mt b gy ob mz l na nb">  success = this.connectRoom(room);</span><span id="4782" class="mx lp iq mt b gy ob mz l na nb">  if (success) { break; }<br/>}<br/>return success;</span></pre><p id="08db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意，在循环中，我们调用了<code class="fe nc nd ne mt b">connectRoom</code>方法，它连接了对面的房间，但还没有连接对角的房间。</p><p id="6b85" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是完整的<code class="fe nc nd ne mt b">nearestNeighbor</code>方法，包括<code class="fe nc nd ne mt b">distanceTo</code>、<code class="fe nc nd ne mt b">compareDist</code>和<code class="fe nc nd ne mt b">connectRoom</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c19f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">回到<code class="fe nc nd ne mt b">script.js</code>，我们现在可以将<code class="fe nc nd ne mt b">nearestNeighbor()</code>添加到<code class="fe nc nd ne mt b">generateMapRooms</code>函数的循环中。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="6ee6" class="mx lp iq mt b gy my mz l na nb">for (var room of game.rooms) {</span><span id="7a8a" class="mx lp iq mt b gy ob mz l na nb">  success = room.findFacingRooms(min);</span><span id="1784" class="mx lp iq mt b gy ob mz l na nb"><strong class="mt ir">  success = room.nearestNeighbor();</strong></span><span id="eba1" class="mx lp iq mt b gy ob mz l na nb">}</span></pre><p id="663c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码运行时应该没有错误，但是对角线房间还不能连接。为了实现这一点，我们需要加强<code class="fe nc nd ne mt b">connectRoom</code>方法，它看起来像下面这样。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The initial method only connects facing rooms.</figcaption></figure><p id="c608" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就把我们带到了教程的第二部分，它涉及到对角方向房间的连接。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="3a67" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">用转角连接房间</h1><p id="d74c" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">如果最近的邻居在斜对面，我们希望使用两个在拐角处相遇的通道来连接房间。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c423d0e5aa46a7082e7d913b3549b8c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*-Oo1TEzXvMmuY4LCnZIMSg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The basic idea.</figcaption></figure><p id="539a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了弄清楚我们将在哪里实现这一点，让我们仔细看看<code class="fe nc nd ne mt b">connectRoom</code>中的现有代码，到目前为止，只有当面对的房间有足够多的<code class="fe nc nd ne mt b">x</code>或<code class="fe nc nd ne mt b">y</code>坐标时，这些代码才会连接它们。(最小坐标数<code class="fe nc nd ne mt b">min</code>设置为<code class="fe nc nd ne mt b">3</code>。)</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The connect room function.</figcaption></figure><p id="7324" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为此，它调用<code class="fe nc nd ne mt b">directConnect</code>，这在<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9">之前的教程</a>中有所介绍，并用一条直线连接面对的房间。</p><p id="a16c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果尝试直接连接失败，<code class="fe nc nd ne mt b">success</code>将在<code class="fe nc nd ne mt b">directConnect</code>之后<code class="fe nc nd ne mt b">false</code>。如果是这种情况，我们希望尝试连接两条在拐角处相交的路径。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="8a5a" class="mx lp iq mt b gy my mz l na nb">if (this.sharesCoordsWith(room, 'x', min) || <br/>    this.sharesCoordsWith(room, 'y', min)) {</span><span id="0605" class="mx lp iq mt b gy ob mz l na nb">    success = this.directConnect(room, min);</span><span id="e85b" class="mx lp iq mt b gy ob mz l na nb">}<br/><strong class="mt ir">if (!success) {</strong></span><span id="6f50" class="mx lp iq mt b gy ob mz l na nb"><strong class="mt ir">// try a corner!<br/>}</strong></span></pre><p id="e1b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是我们可以在<code class="fe nc nd ne mt b">!success</code>条件中添加的内容:两个辅助方法，<code class="fe nc nd ne mt b">vertCorner</code>和<code class="fe nc nd ne mt b">horizCorner</code>，它们将尝试构建这两条拐角形成线。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="85fa" class="mx lp iq mt b gy my mz l na nb">if (!success) {<br/>    <br/> <strong class="mt ir">     let vertCorner = {x:this.center.x,y:room.center.y};</strong></span><span id="8980" class="mx lp iq mt b gy ob mz l na nb"><strong class="mt ir">      let horizCorner = {x:room.center.x, y:this.center.y};</strong><br/>}</span></pre><h2 id="1db9" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">形成拐角路径的两种方式</h2><p id="88bf" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">如果房间使用第一种方法<code class="fe nc nd ne mt b">cornerVert</code>，一条垂直路径连接到其顶部或底部。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi or"><img src="../Images/550fce32c4f8fea8c1030350c8927534.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*G479Izf8fgyU3HsaF2IklA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The cornerVert method makes a vertical line touch the method-calling room.</figcaption></figure><p id="7803" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果房间使用另一种方法<code class="fe nc nd ne mt b">cornerHoriz</code>，路径将连接到它的左边或右边。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/7390485936a108f351109d22cb35a238.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*PxIYjvpjL8bSrLU2cJ-kfw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The cornerHoriz method makes a horizontal line touch the method-calling room.</figcaption></figure><h2 id="7b8b" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">决定哪种转角类型</h2><p id="0f17" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">我们采用的方法取决于两件事:</p><ul class=""><li id="df3f" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated">随机值，存储在新变量<code class="fe nc nd ne mt b">vert</code>中，介于0和1之间；</li><li id="793c" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">不管这个角落是否在另一个房间</li></ul><p id="4525" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是决定角类型的代码，您可以将它直接添加到定义角的逻辑的下面。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1ffd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们首先做一件相当于抛硬币的事情，看看我们是否希望原始路径垂直或水平地连接到方法调用室。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="1afb" class="mx lp iq mt b gy my mz l na nb">let vert = Math.random() &lt; 0.5;</span></pre><p id="a92a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">布尔值<code class="fe nc nd ne mt b">vert</code>在决定这一点上有一定作用，但并没有全部权力。</p><p id="40f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样通过调用<code class="fe nc nd ne mt b">inRoom</code>获得水平角，看看其他方法是否会失败，即使<code class="fe nc nd ne mt b">vert</code>是<code class="fe nc nd ne mt b">false</code>，我们仍然可以尝试<code class="fe nc nd ne mt b">cornerVert</code>。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="4f2b" class="mx lp iq mt b gy my mz l na nb">if ((vert || <strong class="mt ir">game.inRoom(horizCorner</strong>)) &amp;&amp; !game.inRoom(vertCorner)) {<br/>         success = this.cornerVert(room, vertCorner);<br/>}</span></pre><h2 id="d99b" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">一系列用于检查角砖的一行程序</h2><p id="fac0" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">现在让我们快速绕到<code class="fe nc nd ne mt b">game.js</code>并编写<code class="fe nc nd ne mt b">inRoom</code>方法，一个<code class="fe nc nd ne mt b">Game</code>对象用它来测试一个可能的角落是否会在任何一个房间里。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="da89" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该方法在<code class="fe nc nd ne mt b">game.rooms</code>上调用<code class="fe nc nd ne mt b">find</code>来查看是否有房间<code class="fe nc nd ne mt b">encloses</code>角落瓷砖的<code class="fe nc nd ne mt b">x</code>和<code class="fe nc nd ne mt b">y</code>坐标。</p><h2 id="e1a9" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">房间里有瓷砖吗？</h2><p id="a6bf" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated"><code class="fe nc nd ne mt b">encloses</code>方法通过在<code class="fe nc nd ne mt b">x</code>和<code class="fe nc nd ne mt b">y</code>坐标上调用另一个方法<code class="fe nc nd ne mt b">contains</code>来测试一个点是否在一个房间中。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="6dd8" class="mx lp iq mt b gy my mz l na nb">Room.prototype.encloses = function(x,y) {<br/>   return this.contains(x,'x') &amp;&amp; this.contains(y,'y');<br/>}</span></pre><h2 id="8a2e" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">直线包含坐标吗？</h2><p id="86bb" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated"><code class="fe nc nd ne mt b">contains</code>方法测试坐标<code class="fe nc nd ne mt b">c</code>(或者是<code class="fe nc nd ne mt b">x</code>或者是<code class="fe nc nd ne mt b">y</code>)是否分别位于房间水平或垂直边的起点和终点之间。我们可以这样写。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="9784" class="mx lp iq mt b gy my mz l na nb">Room.prototype.contains = function(c, prop) {<br/>   return c &gt;= this.start[prop] &amp;&amp; c &lt;= this.end[prop];<br/>}</span></pre><p id="c066" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了<code class="fe nc nd ne mt b">inRoom</code>和它的助手，我们可以避免绘制一个落在房间里的角。现在，我们来看看如何用转角连接房间。</p><h2 id="48ee" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">形成一个角落</h2><p id="d77f" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">在<code class="fe nc nd ne mt b">cornerVert</code>方法中，方法调用室(<code class="fe nc nd ne mt b">this</code>)以垂直线到达拐角。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d71666f44efd027a3e51761a8b7c276f.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*je-soN03bk6fHtqjqtgW1A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">An example of how a room would connect with cornerVert.</figcaption></figure><p id="06e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">回到<code class="fe nc nd ne mt b">connectRoom</code>，我们用下面的线定义了这个角。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="190d" class="mx lp iq mt b gy my mz l na nb">let vertCorner = {x:this.center.x,y:room.center.y};</span></pre><p id="a099" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">角落，以及目标房间，然后被传入<code class="fe nc nd ne mt b">cornerVert</code>。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="582c" class="mx lp iq mt b gy my mz l na nb">success = this.cornerVert(room, vertCorner);</span></pre><h2 id="68d6" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">拐角倒置法</h2><p id="103c" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">现在让我们开始<code class="fe nc nd ne mt b">cornerVert</code>方法并初始化我们的垂直和水平路径。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="3bc5" class="mx lp iq mt b gy my mz l na nb">Room.prototype.cornerVert = function(room, corner) {</span><span id="ceb1" class="mx lp iq mt b gy ob mz l na nb">let vert = new Path(), horiz = new Path();<br/>}</span></pre><h2 id="10cb" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">上述案例</h2><p id="665f" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">先说垂直路径。如果调用方法的房间(紫色)在目标房间(蓝色)的上面，那么路径就从它的下面开始，一直延伸到角落。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/00b7897ed2dae4eebfc94f9b2db70ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*BtXYeHuDpXZOpHlRoHryTQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The case in cornerVert where the room calling the method is above.</figcaption></figure><p id="121d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个场景在这里的代码中被检查和处理，其中<code class="fe nc nd ne mt b">this</code>是方法调用房间，<code class="fe nc nd ne mt b">room</code>是目标房间。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="343e" class="mx lp iq mt b gy my mz l na nb">if (this.end.y &lt; room.center.y) {<br/>      vert.start = {x:this.center.x, y:this.end.y + 1};<br/>      vert.end = corner;<br/>}</span></pre><h2 id="5b19" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">下例</h2><p id="590b" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">如果方法调用(MC)房间在下面，路径从角落开始，向下，在MC房间的顶部结束。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/38bd38682cb764939aa9f68941a5e478.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*_VLteVTXKaoTXIce8ebULA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The case in cornerVert where the room calling the method is below.</figcaption></figure><p id="9a7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的代码以同样的方式处理这种情况。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="f2ad" class="mx lp iq mt b gy my mz l na nb">else if (this.start.y &gt; room.center.y)  {</span><span id="4fa0" class="mx lp iq mt b gy ob mz l na nb">       vert.start = corner;<br/>       vert.end = {x:this.center.x, y:this.start.y - 1};<br/>}</span></pre><p id="bc31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果两种情况都不成立，这意味着目标房间的垂直中心在MC房间的顶部和底部之间，所以我们必须返回<code class="fe nc nd ne mt b">false</code>。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="b938" class="mx lp iq mt b gy my mz l na nb">else { return false; }</span></pre><h2 id="5fa1" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">左边的箱子</h2><p id="6d2c" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">现在，让我们创建水平路径。如果MC房间在左侧，则该线从角落开始，一直延伸到目标房间。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/32ef3d80726e4a49a46c763da5fa0c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*UFRMItFrC3yJdly8Sg8Z-Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The case in cornerVert where the room calling the method is on the left.</figcaption></figure><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="6798" class="mx lp iq mt b gy my mz l na nb">if (this.onLeft(room)) {<br/>   horiz.start = corner;<br/>   horiz.end = {x:room.start.x - 1, y:room.center.y};<br/> }</span></pre><h2 id="afcb" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">正确的案例</h2><p id="1af7" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">如果尝试连接的房间在右边，则水平路径从目标房间向右画到角落。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ea3a85acbe3cf346975dda6329f4e8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*NwLFKf6FcJ2aBcsnMyEYPg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The case in cornerVert where the method-calling room is on the right.</figcaption></figure><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="9512" class="mx lp iq mt b gy my mz l na nb">else if (this.center.x &gt; room.end.x) {<br/>      horiz.start = {x:room.end.x + 1, y:room.center.y};<br/>      horiz.end = corner;<br/>}</span></pre><h2 id="84ea" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">连接房间</h2><p id="b4ba" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">如果生成的路径不与其他路径相邻，我们就绘制它们，使房间成为邻居。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="0f10" class="mx lp iq mt b gy my mz l na nb">if (!vert.isAdjacentVert() &amp;&amp; !horiz.isAdjacentHoriz() {<br/>      game.addPath(vert);<br/>      game.addPath(horiz);<br/>      this.addNeighbor(room);<br/>}</span></pre><p id="3812" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们根据目标房间现在是否是邻居返回一个布尔值。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="71a4" class="mx lp iq mt b gy my mz l na nb">return this.neighbors.includes(room);</span></pre><p id="1b7f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随意检查<a class="ae la" href="https://gist.github.com/nevkatz/3910bd2c48cc8a1c204c991fe9dbbf83" rel="noopener ugc nofollow" target="_blank">全法</a>检查你的工作。</p><h2 id="b2f8" class="mx lp iq bd lq oc od dn lu oe of dp ly kn og oh mc kr oi oj mg kv ok ol mk om bi translated">拐角水平法</h2><p id="2548" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">现在，让我们试着用一条水平线与方法调用室形成一个角。该方法以与<code class="fe nc nd ne mt b">cornerVert</code>相同的方式开始。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="1cac" class="mx lp iq mt b gy my mz l na nb">Room.prototype.cornerHoriz = function(room, corner) {</span><span id="f597" class="mx lp iq mt b gy ob mz l na nb">let horiz = new Path(), vert = new Path;</span><span id="6e64" class="mx lp iq mt b gy ob mz l na nb">}</span></pre><p id="9721" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一个关于<code class="fe nc nd ne mt b">cornerHoriz</code>的例子，水平线的起点与方法调用方接触。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/901254bd1f9eae6c3353eb0e33938ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*oUvv6WUVkdbk_-pwqzY86g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Here, the horizontal line touches the method-calling room.</figcaption></figure><p id="223a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果MC房间的右边缘在另一个房间的垂直中线的左边，则水平线从方法调用房间画到角落。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="2bfe" class="mx lp iq mt b gy my mz l na nb">if (this.end.x &lt; room.center.x) {<br/>         horiz.start = {x:this.end.x + 1,y:this.center.y},<br/>         horiz.end = corner<br/>}</span></pre><p id="a69f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之后，如果MC房间的水平中线高于另一个房间的顶边，则从角落向另一个房间绘制垂直线。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/65ea6854f64965a9318aedcfeca3a79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*pEEoU3YGLnp8Ors8X-SefQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Here, the MC room’s (dashed) midline is above the top edge of the room.</figcaption></figure><p id="7541" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的代码使用<code class="fe nc nd ne mt b">this.center.y</code>表示中线的位置，包含了这一点。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="7349" class="mx lp iq mt b gy my mz l na nb">if (this.center.y &lt; room.start.y) {<br/>      vert.start = corner,<br/>      vert.end = {x:room.center.x, y:room.start.y - 1}<br/>}</span></pre><p id="7e02" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以像以前一样，我们检查两个房间是如何定位的，并相应地画线。</p><p id="77ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看你能不能自己写完<code class="fe nc nd ne mt b">cornerHoriz</code>剩下的部分。万一遇到阻碍，可以参考这个<a class="ae la" href="https://gist.github.com/nevkatz/bfe82e85bf77044e07aa6ef2fbf5d9f3" rel="noopener ugc nofollow" target="_blank"> Github gis </a> t或者<code class="fe nc nd ne mt b">solutions</code>文件夹里的<code class="fe nc nd ne mt b">room.js</code>获取完整代码。</p><p id="1d58" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦完成，返回到<code class="fe nc nd ne mt b">script.js</code>中的<code class="fe nc nd ne mt b">generateMapRooms</code>。一旦出现，就在<code class="fe nc nd ne mt b">findFacingRooms</code>下面添加<code class="fe nc nd ne mt b">nearestNeighbor</code>方法。这将使房间有可能通过在拐角处相交的路径连接到其他房间。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="f514" class="mx lp iq mt b gy my mz l na nb">for (var room of game.rooms) {</span><span id="4d37" class="mx lp iq mt b gy ob mz l na nb">   success = room.findFacingRooms(min);</span><span id="4db8" class="mx lp iq mt b gy ob mz l na nb"><strong class="mt ir">   success = room.nearestNeighbor();</strong><br/> <br/>}</span></pre><p id="8c63" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你做到了这一点，干得好。你现在应该可以在你的<code class="fe nc nd ne mt b">project</code>目录中测试整个游戏了。这是一支笔，供你检查工作。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ou oa l"/></div></figure><h1 id="b5f2" class="lo lp iq bd lq lr nt lt lu lv nu lx ly lz nv mb mc md nw mf mg mh nx mj mk ml bi translated">后续步骤</h1><ul class=""><li id="1960" class="nf ng iq ke b kf mm kj mn kn ov kr ow kv ox kz nk nl nm nn bi translated">请注意，所有拐角形成路径都从房间的水平或垂直中心开始。您可以尝试修改代码，使它们从中心以外的地方开始。</li><li id="91ad" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">在少数情况下，并非所有房间都是连通的。我们将在下一个用递归查找房间的教程中解决这个问题。</li></ul><p id="202c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">目前就这些，如果你感兴趣的话，前面的教程在下面。日安！</p><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">如何在JavaScript Roguelike中连接房间</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">让我们用香草JS建造一些走廊。</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp jw pb"/></div></div></a></div><p id="b5dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mr">考虑注册</em><a class="ae la" href="https://medium.com/@nevkatz/membership" rel="noopener"><strong class="ke ir"><em class="mr">Medium</em></strong></a><em class="mr">无限制访问我的文章以及成千上万其他作家的文章。</em></p><p id="0135" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mr">更多内容请看</em><a class="ae la" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mr">plain English . io</em></strong></a><em class="mr">。报名参加我们的</em> <a class="ae la" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="mr">免费周报</em> </strong> </a> <em class="mr">。关注我们关于</em><a class="ae la" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mr">Twitter</em></strong></a><em class="mr">和</em><a class="ae la" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mr">LinkedIn</em></strong></a><em class="mr">。加入我们的</em> <a class="ae la" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="mr">社区不和谐</em> </strong> </a> <em class="mr">。</em></p></div></div>    
</body>
</html>