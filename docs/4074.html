<html>
<head>
<title>Angular Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度单位测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-unit-testing-5b188ae10a4?source=collection_archive---------5-----------------------#2022-10-22">https://javascript.plainenglish.io/angular-unit-testing-5b188ae10a4?source=collection_archive---------5-----------------------#2022-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9ebf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个角度单元测试教程中，我们将演示如何构建一个简单的角度应用程序，然后通过例子一步一步地完成单元测试过程。</p><p id="b2aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将详细介绍以下内容:</p><ul class=""><li id="b652" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">什么是角度测试？</strong></li><li id="ba23" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">什么是角度单元测试？</strong></li><li id="75b2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">为什么你应该对Angular apps进行单元测试</strong></li><li id="01c4" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">角度测试怎么写？</strong></li><li id="9471" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">什么是羯磨有角？</strong></li><li id="313f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">如何用Angular编写单元测试</strong></li><li id="ac61" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">如何测试角度服务</strong></li><li id="24a3" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">如何测试角度组件</strong></li><li id="8e11" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">如何测试角度异步运行</strong></li></ul><p id="9045" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照本教程，你应该对如何使用<a class="ae kz" href="https://angular.io/guide/testing-services" rel="noopener ugc nofollow" target="_blank"> Angular </a>有一个基本的了解。</p><h1 id="71c8" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是角度测试？</h1><p id="e506" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae kz" href="https://angular.io/guide/testing" rel="noopener ugc nofollow" target="_blank">角度测试</a>是使用<a class="ae kz" href="https://angular.io/cli" rel="noopener ugc nofollow" target="_blank">角度CLI </a>设置的每个项目的核心功能。</p><p id="a49e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了与JavaScript生态系统保持同步，Angular团队每年都会发布两个主要的Angular版本。从一开始到最近的版本，<a class="ae kz" href="https://blog.angular.io/version-11-of-angular-now-available-74721b7952f7" rel="noopener ugc nofollow" target="_blank"> Angular 11 </a>，Angular的设计就考虑到了可测试性。</p><p id="44aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种角度测试:</p><ol class=""><li id="ee61" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk md kr ks kt bi translated">单元测试是测试小的、孤立的代码片段的过程。也称为隔离测试，单元测试不使用外部资源，如网络或数据库</li><li id="2be1" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk md kr ks kt bi translated"><strong class="jp ir">功能测试</strong>是指从用户体验的角度测试Angular应用的功能，也就是说，当应用在浏览器中运行时，就像用户一样与应用进行交互</li></ol><h1 id="9028" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是角度单位测试？</h1><p id="0ccc" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae kz" href="https://docs.angularjs.org/guide/unit-testing" rel="noopener ugc nofollow" target="_blank">角度单元测试</a>是指测试单个代码单元的过程。</p><p id="8335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">角度单元测试旨在发现诸如不正确的逻辑、行为不当的函数等问题。通过分离代码片段。这有时比听起来更困难，尤其是对于关注点分离不良的复杂项目。Angular旨在帮助你以这样一种方式编写代码，使你能够单独测试你的应用程序的功能。</p><h1 id="b7d0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么应该对Angular应用进行单元测试</h1><p id="7f93" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">角度单元测试使你能够基于用户行为测试你的应用。虽然测试每一种可能的行为是乏味、低效和无效的，但是为应用程序中的每一个耦合块编写测试有助于演示这些块的行为。</p><p id="28b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试这些块的强度的最简单的方法之一是为每个块编写一个测试。您不必等到用户抱怨单击按钮时输入字段的行为。通过为你的模块(组件、服务等)编写单元测试。)，可以很容易的察觉到什么时候有断档。</p><p id="f3c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的示例Angular应用程序有一个服务、一个组件和一个异步任务来模拟从服务器获取的数据。</p><h1 id="eed3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">角度测试怎么写？</h1><p id="c9c8" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">当您使用Angular CLI ( <code class="fe me mf mg mh b">ng new appName</code>)创建新项目时，会添加一个默认组件和测试文件。另外——如果你像我一样，总是在寻找捷径——测试脚本总是与你使用Angular CLI创建的任何组件模块(服务、组件)一起创建。</p><p id="d92c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个以<code class="fe me mf mg mh b">.spec.ts</code>结尾的测试脚本总是被添加。让我们来看看最初的测试脚本文件，它是<code class="fe me mf mg mh b">app.component.spec.ts</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de48" class="mq lb iq mh b gy mr ms l mt mu">import { TestBed, async } from '@angular/core/testing';<br/>import { AppComponent } from './app.component';<br/>describe('AppComponent', () =&gt; {<br/>  beforeEach(async(() =&gt; {<br/>    TestBed.configureTestingModule({<br/>      declarations: [<br/>        AppComponent<br/>      ],<br/>    }).compileComponents();<br/>  }));<br/>  it('should create the app', async(() =&gt; {<br/>    const fixture = TestBed.createComponent(AppComponent);<br/>    const app = fixture.debugElement.componentInstance;<br/>    expect(app).toBeTruthy();<br/>  }));<br/>  it(`should have as title 'angular-unit-test'`, async(() =&gt; {<br/>    const fixture = TestBed.createComponent(AppComponent);<br/>    const app = fixture.debugElement.componentInstance;<br/>    expect(app.title).toEqual('angular-unit-test');<br/>  }));<br/>  it('should render title in a h1 tag', async(() =&gt; {<br/>    const fixture = TestBed.createComponent(AppComponent);<br/>    fixture.detectChanges();<br/>    const compiled = fixture.debugElement.nativeElement;<br/>    expect(compiled.querySelector('h1').textContent).toContain('Welcome to angular-unit-test!');<br/>  }));<br/>});</span></pre><p id="43d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们运行第一个测试，以确保没有任何问题发生:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e3f2" class="mq lb iq mh b gy mr ms l mt mu">ng test</span></pre><p id="8bbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能想知道，即使项目在浏览器中呈现，我们如何通过简单地编写测试来模拟用户行为？随着我们的继续，我将演示如何模拟和Angular应用程序在浏览器上运行。</p><h1 id="53b6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">《角》中的业力是什么？</h1><p id="e4bb" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae kz" href="https://karma-runner.github.io/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Karma </a>是一个JavaScript测试运行器，它在Angular中运行单元测试片段。Karma还确保测试结果在控制台或文件日志中打印出来。</p><p id="5e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Angular运行在Karma上。其他试跑者还包括<a class="ae kz" href="https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d/" rel="noopener ugc nofollow" target="_blank">摩卡</a>和<a class="ae kz" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank">茉莉</a>。Karma提供了一些工具，使得在用Angular编写代码时调用Jasmine测试变得更加容易。</p><h1 id="1b94" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何用Angular编写单元测试</h1><p id="5e76" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">角度测试包包括两个名为<code class="fe me mf mg mh b">TestBed</code>和<code class="fe me mf mg mh b">async</code>的工具。<code class="fe me mf mg mh b">TestBed</code>是主要的角度实用套件。</p><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a7130f4b9f1a20e556443479ba07eb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/0*AdWCzvawH2XV4HgI.jpeg"/></div></figure><p id="24c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">describe</code>容器包含不同的块(<code class="fe me mf mg mh b">it</code>、<code class="fe me mf mg mh b">beforeEach</code>、<code class="fe me mf mg mh b">xit</code>等)。).<code class="fe me mf mg mh b">beforeEach</code>在任何其他程序块之前运行。其他块的运行互不依赖。</p><p id="959c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<code class="fe me mf mg mh b">app.component.spec.ts</code>文件开始，第一个块是容器内的<code class="fe me mf mg mh b">beforeEach</code>(<code class="fe me mf mg mh b">describe</code>)。这是唯一一个在任何其他程序块之前运行的程序块(<code class="fe me mf mg mh b">it</code>)。<code class="fe me mf mg mh b">app.module.ts</code>文件中app模块的声明在<code class="fe me mf mg mh b">beforeEach</code>块中模拟(声明)。在<code class="fe me mf mg mh b">beforeEach</code>块中声明的组件(<code class="fe me mf mg mh b">AppComponent</code>)是我们希望在这个测试环境中拥有的主要组件。同样的逻辑也适用于其他测试声明。</p><p id="1e0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用<code class="fe me mf mg mh b">compileComponents</code>对象来编译组件的资源，如模板、样式等。如果使用webpack，您可能不一定要编译组件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bcd6" class="mq lb iq mh b gy mr ms l mt mu">beforeEach(async(() =&gt; {<br/>   TestBed.configureTestingModule({<br/>      declarations: [<br/>         AppComponent<br/>      ],<br/>   }).compileComponents();<br/>}));</span></pre><p id="786f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在组件已经在<code class="fe me mf mg mh b">beforeEach</code>块中声明，让我们检查组件是否被创建。</p><p id="7027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">fixture.debugElement.componentInstance</code>创建该类的一个实例(<code class="fe me mf mg mh b">AppComponent</code>)。我们将使用<code class="fe me mf mg mh b">toBeTruthy</code>测试该类的实例是否真正被创建:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7f87" class="mq lb iq mh b gy mr ms l mt mu">it('should create the app', async(() =&gt; {<br/>    const fixture = TestBed.createComponent(AppComponent);<br/>    const app = fixture.debugElement.componentInstance;<br/>    expect(app).toBeTruthy();<br/>}));</span></pre><p id="445d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三块演示了如何访问已创建组件的属性(<code class="fe me mf mg mh b">AppComponent</code>)。默认情况下添加的唯一属性是标题。您可以从创建的组件实例(<code class="fe me mf mg mh b">AppComponent</code>)中轻松检查您设置的标题是否已更改:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d407" class="mq lb iq mh b gy mr ms l mt mu">it(`should have as title 'angular-unit-test'`, async(() =&gt; {<br/>     const fixture = TestBed.createComponent(AppComponent);<br/>     const app = fixture.debugElement.componentInstance;<br/>     expect(app.title).toEqual('angular-unit-test');<br/>}));</span></pre><p id="1a31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四块演示了测试在浏览器环境中的行为。在创建组件之后，调用所创建组件的实例(<code class="fe me mf mg mh b">detectChanges</code>)来模拟在浏览器环境中运行。现在组件已经呈现，您可以通过访问呈现组件的<code class="fe me mf mg mh b">nativeElelment</code>对象(<code class="fe me mf mg mh b">fixture.debugElement.nativeElement</code>)来访问它的子元素:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cf85" class="mq lb iq mh b gy mr ms l mt mu">it('should render title in a h1 tag', async(() =&gt; {<br/>   const fixture = TestBed.createComponent(AppComponent);<br/>   fixture.detectChanges();<br/>   const compiled = fixture.debugElement.nativeElement;<br/> expect(compiled.querySelector('h1').textContent).toContain('Welcome to angular-unit-test!');<br/>}));</span></pre><p id="4539" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您已经熟悉了测试组件的基础知识，让我们测试我们的Angular示例应用程序。</p><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9e0e83ba1aaddf3bd4f9f8e7492919c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*HD5hyZ4iOLWenmRZ.jpeg"/></div></figure><h1 id="1ef6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何测试角度服务</h1><p id="9bd8" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">服务通常依赖于Angular注入到构造函数中的其他服务。在许多情况下，通过将<code class="fe me mf mg mh b">providedIn: root</code>添加到可注入对象，可以很容易地创建和注入这些依赖关系，这使得任何组件或服务都可以访问它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1948" class="mq lb iq mh b gy mr ms l mt mu">import { Injectable } from "@angular/core";<br/>import { QuoteModel } from "../model/QuoteModel";</span><span id="fa81" class="mq lb iq mh b gy na ms l mt mu">@Injectable({<br/>  providedIn: "root"<br/>})<br/>export class QuoteService {<br/>  public quoteList: QuoteModel[] = [];</span><span id="714d" class="mq lb iq mh b gy na ms l mt mu">  private daysOfTheWeeks = ["Sun", "Mon", "Tue", "Wed", "Thurs", "Fri", "Sat"];</span><span id="7f85" class="mq lb iq mh b gy na ms l mt mu">  constructor() {}</span><span id="a9aa" class="mq lb iq mh b gy na ms l mt mu">  addNewQuote(quote: String) {<br/>    const date = new Date();<br/>    const dayOfTheWeek = this.daysOfTheWeeks[date.getDate()];<br/>    const day = date.getDay();<br/>    const year = date.getFullYear();<br/>    this.quoteList.push(<br/>      new QuoteModel(quote, `${dayOfTheWeek} ${day}, ${year}`)<br/>    );<br/>  }</span><span id="1ce2" class="mq lb iq mh b gy na ms l mt mu">  getQuote() {<br/>    return this.quoteList;<br/>  }</span><span id="ef23" class="mq lb iq mh b gy na ms l mt mu">  removeQuote(index) {<br/>    this.quoteList.splice(index, 1);<br/>  }<br/>}</span></pre><p id="bd76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一些测试<code class="fe me mf mg mh b">QuoteService</code>类的方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8bab" class="mq lb iq mh b gy mr ms l mt mu">/* tslint:disable:no-unused-variable */<br/>import { QuoteService } from "./Quote.service";</span><span id="87cd" class="mq lb iq mh b gy na ms l mt mu">describe("QuoteService", () =&gt; {<br/>  let service: QuoteService;</span><span id="fe2e" class="mq lb iq mh b gy na ms l mt mu">  beforeEach(() =&gt; {<br/>    service = new QuoteService();<br/>  });</span><span id="812b" class="mq lb iq mh b gy na ms l mt mu">  it("should create a post in an array", () =&gt; {<br/>    const qouteText = "This is my first post";<br/>    service.addNewQuote(qouteText);<br/>    expect(service.quoteList.length).toBeGreaterThanOrEqual(1);<br/>  });</span><span id="090a" class="mq lb iq mh b gy na ms l mt mu">  it("should remove a created post from the array of posts", () =&gt; {<br/>    service.addNewQuote("This is my first post");<br/>    service.removeQuote(0);<br/>    expect(service.quoteList.length).toBeLessThan(1);<br/>  });<br/>});</span></pre><p id="1d5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个块<code class="fe me mf mg mh b">beforeEach</code>中，创建了一个<code class="fe me mf mg mh b">QuoteService</code>的实例，以确保它只被创建一次，并避免在其他块中重复，除了一些例外情况:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="52f3" class="mq lb iq mh b gy mr ms l mt mu">it("should create a post in an array", () =&gt; {<br/>    const qouteText = "This is my first post";<br/>    service.addNewQuote(qouteText);<br/>    expect(service.quoteList.length).toBeGreaterThanOrEqual(1);<br/>  });</span></pre><p id="7396" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个块通过检查数组的长度来测试post模型<code class="fe me mf mg mh b">QuoteModel(text, date)</code>是否被创建到一个数组中。<code class="fe me mf mg mh b">quoteList</code>的长度预计为<code class="fe me mf mg mh b">1</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e09d" class="mq lb iq mh b gy mr ms l mt mu">it("should remove a created post from the array of posts", () =&gt; {<br/>    service.addNewQuote("This is my first post");<br/>    service.removeQuote(0);<br/>    expect(service.quoteList.length).toBeLessThan(1);<br/>  });</span></pre><p id="0238" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个块在数组中创建一个post，并通过调用服务对象中的<code class="fe me mf mg mh b">removeQuote</code>立即删除它。<code class="fe me mf mg mh b">quoteList</code>的长度预计为<code class="fe me mf mg mh b">0</code>。</p><h1 id="af2d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何测试角度组件</h1><p id="3735" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">在我们的角度单元测试示例应用程序中，<code class="fe me mf mg mh b">service</code>被注入到<code class="fe me mf mg mh b">QuoteComponent</code>中以访问其属性，这是视图所需要的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6ea6" class="mq lb iq mh b gy mr ms l mt mu">import { Component, OnInit } from '@angular/core';<br/>import { QuoteService } from '../service/Quote.service';<br/>import { QuoteModel } from '../model/QuoteModel';</span><span id="36ab" class="mq lb iq mh b gy na ms l mt mu">@Component({<br/>  selector: 'app-Quotes',<br/>  templateUrl: './Quotes.component.html',<br/>  styleUrls: ['./Quotes.component.css']<br/>})<br/>export class QuotesComponent implements OnInit {</span><span id="454c" class="mq lb iq mh b gy na ms l mt mu">  public quoteList: QuoteModel[];<br/>  public quoteText: String = null;</span><span id="0f9a" class="mq lb iq mh b gy na ms l mt mu">  constructor(private service: QuoteService) { }</span><span id="c13f" class="mq lb iq mh b gy na ms l mt mu">  ngOnInit() {<br/>    this.quoteList = this.service.getQuote();<br/>  }</span><span id="7345" class="mq lb iq mh b gy na ms l mt mu">  createNewQuote() {<br/>    this.service.addNewQuote(this.quoteText);<br/>    this.quoteText = null;<br/>  }</span><span id="8e37" class="mq lb iq mh b gy na ms l mt mu">  removeQuote(index) {<br/>    this.service.removeQuote(index);<br/>  }<br/>}</span><span id="f2da" class="mq lb iq mh b gy na ms l mt mu">&lt;div class="container-fluid"&gt;<br/>  &lt;div class="row"&gt;<br/>    &lt;div class="col-8 col-sm-8 mb-3 offset-2"&gt;<br/>      &lt;div class="card"&gt;<br/>        &lt;div class="card-header"&gt;<br/>          &lt;h5&gt;What Quote is on your mind ?&lt;/h5&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="card-body"&gt;<br/>          &lt;div role="form"&gt;<br/>            &lt;div class="form-group col-8 offset-2"&gt;<br/>              &lt;textarea #quote class="form-control" rows="3" cols="8" [(ngModel)]="quoteText" name="quoteText"&gt;&lt;/textarea&gt;<br/>            &lt;/div&gt;<br/>            &lt;div class="form-group text-center"&gt;<br/>              &lt;button class="btn btn-primary" (click)="createNewQuote()" [disabled]="quoteText == null"&gt;Create a new<br/>                quote&lt;/button&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;</span><span id="0252" class="mq lb iq mh b gy na ms l mt mu">  &lt;div class="row"&gt;<br/>    &lt;div class="card mb-3 col-5 list-card" id="quote-cards" style="max-width: 18rem;" *ngFor="let quote of quoteList; let i = index"<br/>      (click)="removeQuote(i)"&gt;<br/>      &lt;div class="card-body"&gt;<br/>        &lt;h6&gt;{{ quote.text }}&lt;/h6&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="card-footer text-muted"&gt;<br/>        &lt;small&gt;Created on {{ quote.timeCreated }}&lt;/small&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="41a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">describe</code>容器中的前两个程序块连续运行。在第一个块中，<code class="fe me mf mg mh b">FormsModule</code>被导入到配置测试中。这确保了可以使用表单的相关指令，如<code class="fe me mf mg mh b">ngModel</code>。</p><p id="3be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，<code class="fe me mf mg mh b">QuotesComponent</code>在<code class="fe me mf mg mh b">configTestMod</code>中声明，类似于组件在<code class="fe me mf mg mh b">appModule</code>文件中的<code class="fe me mf mg mh b">ngModule</code>中声明。第二块<code class="fe me mf mg mh b">creates</code> a <code class="fe me mf mg mh b">QuoteComponent</code>及其<code class="fe me mf mg mh b">instance</code>，将被其他块使用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f650" class="mq lb iq mh b gy mr ms l mt mu">let component: QuotesComponent;<br/>  let fixture: ComponentFixture&lt;QuotesComponent&gt;;</span><span id="1026" class="mq lb iq mh b gy na ms l mt mu">  beforeEach(() =&gt; {<br/>    TestBed.configureTestingModule({<br/>      imports: [FormsModule],<br/>      declarations: [QuotesComponent]<br/>    });<br/>  });</span><span id="7929" class="mq lb iq mh b gy na ms l mt mu">  beforeEach(() =&gt; {<br/>    fixture = TestBed.createComponent(QuotesComponent);<br/>    component = fixture.debugElement.componentInstance;<br/>  });</span></pre><p id="d517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此块测试所创建的组件实例是否已定义:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="aea2" class="mq lb iq mh b gy mr ms l mt mu">it("should create Quote component", () =&gt; {<br/>    expect(component).toBeTruthy();<br/>  });</span></pre><p id="74f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注入的服务处理所有操作的操作(<code class="fe me mf mg mh b">add</code>、<code class="fe me mf mg mh b">remove</code>、<code class="fe me mf mg mh b">fetch</code>)。<code class="fe me mf mg mh b">quoteService</code>变量保存注入的服务(<code class="fe me mf mg mh b">QuoteService</code>)。此时，在调用<code class="fe me mf mg mh b">detectChanges</code>方法之前，组件尚未呈现:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="241d" class="mq lb iq mh b gy mr ms l mt mu">it("should use the quoteList from the service", () =&gt; {<br/>    const quoteService = fixture.debugElement.injector.get(QuoteService);<br/>    fixture.detectChanges();<br/>    expect(quoteService.getQuote()).toEqual(component.quoteList);<br/>  });</span></pre><p id="3f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们测试一下我们是否能成功创建帖子。组件的属性可以在实例化时访问，所以当一个值被传递到<code class="fe me mf mg mh b">quoteText</code>模型时，呈现的组件检测到新的变化。<code class="fe me mf mg mh b">nativeElement</code>对象提供了对呈现的HTML元素的访问，这使得检查添加的<code class="fe me mf mg mh b">quote</code>是否是呈现文本的一部分变得更加容易:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5d5c" class="mq lb iq mh b gy mr ms l mt mu">it("should create a new post", () =&gt; {<br/>    component.quoteText = "I love this test";<br/>    fixture.detectChanges();<br/>    const compiled = fixture.debugElement.nativeElement;<br/>    expect(compiled.innerHTML).toContain("I love this test");<br/>  });</span></pre><p id="8ba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了可以访问HTML内容之外，您还可以通过元素的CSS属性来获取元素。当<code class="fe me mf mg mh b">quoteText</code>模型为空或null时，按钮将被禁用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6889" class="mq lb iq mh b gy mr ms l mt mu">it("should disable the button when textArea is empty", () =&gt; {<br/>    fixture.detectChanges();<br/>    const button = fixture.debugElement.query(By.css("button"));<br/>    expect(button.nativeElement.disabled).toBeTruthy();<br/>  });</span><span id="6733" class="mq lb iq mh b gy na ms l mt mu">it("should enable button when textArea is not empty", () =&gt; {<br/>    component.quoteText = "I love this test";<br/>    fixture.detectChanges();<br/>    const button = fixture.debugElement.query(By.css("button"));<br/>    expect(button.nativeElement.disabled).toBeFalsy();<br/>  });</span></pre><p id="eddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像我们用CSS属性访问元素一样，我们也可以通过类名访问元素。使用<code class="fe me mf mg mh b">By e.g By.css(‘.className.className’)</code>可以同时访问多个类。</p><p id="5190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过调用<code class="fe me mf mg mh b">triggerEventHandler</code>来模拟按钮点击。必须指定<code class="fe me mf mg mh b">event</code>类型，在本例中是click。点击时，显示的报价将从<code class="fe me mf mg mh b">quoteList</code>中删除:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="66ce" class="mq lb iq mh b gy mr ms l mt mu">it("should remove post upon card click", () =&gt; {<br/>    component.quoteText = "This is a fresh post";<br/>    fixture.detectChanges();</span><span id="a6b1" class="mq lb iq mh b gy na ms l mt mu">    fixture.debugElement<br/>      .query(By.css(".row"))<br/>      .query(By.css(".card"))<br/>      .triggerEventHandler("click", null);<br/>    const compiled = fixture.debugElement.nativeElement;<br/>    expect(compiled.innerHTML).toContain("This is a fresh post");<br/>  });</span></pre><h1 id="9e14" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何在Angular中测试异步操作</h1><p id="59a9" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">不可避免的是，你最终需要远程获取数据。此操作最好被视为异步任务。</p><p id="0d87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">fetchQoutesFromServer</code>表示一个异步任务，它在两秒钟后返回一组引号:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a512" class="mq lb iq mh b gy mr ms l mt mu">fetchQuotesFromServer() {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      setTimeout(() =&gt; {<br/>        resolve([new QuoteModel("I love unit testing", "Mon 4, 2018")]);<br/>      }, 2000);<br/>    });<br/>  }</span></pre><p id="b078" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">spyOn</code>对象模拟<code class="fe me mf mg mh b">fetchQuotesFromServer</code>方法如何工作。它接受注入组件的两个参数<code class="fe me mf mg mh b">quoteService</code>和<code class="fe me mf mg mh b">fetchQuotesFromServer</code>方法。<code class="fe me mf mg mh b">fetchQuotesFromServer</code>有望回报承诺。<code class="fe me mf mg mh b">spyOn</code>将使用<code class="fe me mf mg mh b">and</code>的方法与使用<code class="fe me mf mg mh b">returnValue</code>返回的假承诺调用链接起来。因为我们想要模拟<code class="fe me mf mg mh b">fetchQuotesFromServer</code>的工作方式，所以我们需要传递一个<code class="fe me mf mg mh b">promise</code>来解析一个报价列表。</p><p id="dcfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们之前所做的，我们将调用<code class="fe me mf mg mh b">detectChanges</code>方法来获取更新的更改。<code class="fe me mf mg mh b">whenStable</code>允许访问所有<code class="fe me mf mg mh b">async </code>任务完成后的结果:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="efae" class="mq lb iq mh b gy mr ms l mt mu">it("should fetch data asynchronously", async () =&gt; {<br/>    const fakedFetchedList = [<br/>      new QuoteModel("I love unit testing", "Mon 4, 2018")<br/>    ];<br/>    const quoteService = fixture.debugElement.injector.get(QuoteService);<br/>    let spy = spyOn(quoteService, "fetchQuotesFromServer").and.returnValue(<br/>      Promise.resolve(fakedFetchedList)<br/>    );<br/>    fixture.detectChanges();<br/>    fixture.whenStable().then(() =&gt; {<br/>      expect(component.fetchedList).toBe(fakedFetchedList);<br/>    });<br/>  });</span></pre><h1 id="15d8" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用<a class="ae kz" href="https://www2.logrocket.com/angular-performance-monitoring" rel="noopener ugc nofollow" target="_blank"> LogRocket </a>确保角度异步操作在生产中成功。</h1><p id="2c23" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">调试Angular应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果你对监控和跟踪生产中所有用户的角度状态和动作感兴趣，<a class="ae kz" href="https://www2.logrocket.com/angular-performance-monitoring" rel="noopener ugc nofollow" target="_blank">试试LogRocket </a>。</p><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/2175f50cbf2bbebcca019fbb29f0e0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AY-PX1clU5Fne578.png"/></div></div></figure><p id="84a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kz" href="https://www2.logrocket.com/angular-performance-monitoring" rel="noopener ugc nofollow" target="_blank">https://logrocket.com/signup/</a></p><p id="5521" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LogRocket 就像是网络应用程序的DVR，记录你网站上发生的一切，包括网络请求、JavaScript错误等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p id="1ed4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LogRocket NgRx插件将角度状态和动作记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><h1 id="f30a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="d028" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">Angular确保在浏览器中查看测试结果。这将更好地显示测试结果。</p><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div class="ab gu cl ng"><img src="../Images/e18a9cdb89f1b050106566a9b1c19ae4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ZSUAwwNh3CoIkDYSntC84A.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Test Result</figcaption></figure><p id="bc3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nl">更多内容看</em> <a class="ae kz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="nl">说白了。报名参加我们的</em> <a class="ae kz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="nl">免费周报</em> </strong> </a> <em class="nl">。关注我们关于</em> <a class="ae kz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="nl">推特</em></strong></a><a class="ae kz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nl">LinkedIn</em></strong></a><em class="nl"/><a class="ae kz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nl">YouTube</em></strong></a><em class="nl"/><a class="ae kz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nl">不和</em> </strong> </a> <strong class="jp ir"> <em class="nl">。</em>T51】</strong></strong></a></p><p id="a658" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nl">对缩放您的软件启动感兴趣</em> </strong> <em class="nl">？检查</em> <a class="ae kz" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="nl">电路</em> </strong> </a> <em class="nl">。</em></p></div></div>    
</body>
</html>