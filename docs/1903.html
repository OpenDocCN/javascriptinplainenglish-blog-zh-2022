<html>
<head>
<title>Why Can’t Vite Use New Syntax?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Vite不能使用新语法？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-cant-vite-use-new-syntax-46b50886a1db?source=collection_archive---------4-----------------------#2022-04-28">https://javascript.plainenglish.io/why-cant-vite-use-new-syntax-46b50886a1db?source=collection_archive---------4-----------------------#2022-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c4d27c47d215af5461f8d7ce2f10f7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WqeG8c5XnX0aY-A7sDiYA.png"/></div></div></figure><p id="d37f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您是否知道您在Vite项目中编写的高级ECMAScript语法可能是项目的隐患？</p><h1 id="5019" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">背景</h1><p id="994b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">该项目是基于Vite开发的。在开发过程中，使用Object.fromeEntries。</p><p id="7b3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在较低版本的浏览器中打开时，出现以下错误:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/10892b8b447aff28541782a777e896bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZDDxEqqvRirJvFyIT79WDQ.png"/></div></div></figure><p id="7e23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">查一下vite.config.js，发现没有使用奇怪的插件，先排除配置文件的问题。</p><p id="beac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">秉承工程师追求极致的文化，开始刨根问底。</p><h1 id="b2f9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">检测问题</h1><p id="f8bb" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在分析原因之前，我们先来看看这个新语法<a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries" rel="noopener ugc nofollow" target="_blank"> Object.fromEntries </a>。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/372a2534b320257af14b1c7a9843bd3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5hbW4gD_o59E3v_v_Ga6Q.png"/></div></div></figure><p id="95ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是ES2019的新语法，已经是一个稳定的版本。</p><p id="fcc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">浏览器兼容性</strong></p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/16e68bac0883e31e386e259b89cca6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fv0jx2jNS_UOlVP-Q_rTCw.png"/></div></div></figure><p id="583b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不支持IE。嗯，时代的眼泪。</p><p id="30af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但错误不是针对IE，而是Chrome。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/5447fa0cbe0f848b5175edaaae0b0a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RO9mnKpv-U79NUygzm27JA.png"/></div></div></figure><p id="68e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">检查了Chrome版本是69，Object.fromEntries直到Chrome 73才获得支持，导致较低版本的Chrome出现错误。</p><p id="a740" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但通常情况下，为了兼容较低版本的浏览器，构建工具会将新的语法转换为较低版本浏览器可识别的语法。</p><p id="36d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">浏览器运行时，代码中确实存在Object.fromEntries，所以初步推断，在构建Vite时没有处理Object.fromEntries。</p><p id="f53d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在考察产品的时候，也可以发现语法确实被保留了下来。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/fe7b233fa3210c5429edd85ea0eaa880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3D554XCNDgN8WlZ3veZsw.png"/></div></div></figure><p id="f90c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然是建筑问题，我马上看了Vite的官网，在<a class="ae mb" href="https://vitejs.dev/guide/build.html#browser-compatibility" rel="noopener ugc nofollow" target="_blank">建筑章节找到了详细内容。</a></p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/7125b45b349c8e16163cd06490356e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yYGpkHh_l1juH4coSx6kw.png"/></div></div></figure><p id="8f0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">红框里说Vite只会做语法翻译，不会包含poly fill，那么poly fill和语法翻译到底是什么？</p><h1 id="1da8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">多填充物</h1><p id="e1f4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Polyfills通过模拟低版本浏览器中的等效代码来实现高版本语法的行为。</p><p id="5723" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以本文中的Object.fromEntries为例，其polyfill代码如下:</p><pre class="lx ly lz ma gt mc md me mf aw mg bi"><span id="e318" class="mh ku in md b gy mi mj l mk ml">Object.fromEntries = Object.fromEntries ||<br/> function fromEntries (iterable) {<br/>   return [...iterable].reduce((obj, [key, val]) =&gt; {<br/>     obj[key] = val<br/>     return obj<br/>   }, {})<br/> }</span></pre><p id="8084" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在执行项目代码之前，先加载相关的polyfills代码，当遇到Object.fromEntries时，它才能完美运行。</p><h2 id="81da" class="mh ku in bd kv mm mn dn kz mo mp dp ld kg mq mr lh kk ms mt ll ko mu mv lp mw bi translated">核心-js</h2><p id="bcbf" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">主流的polyfills库是<a class="ae mb" href="https://github.com/zloirock/core-js" rel="noopener ugc nofollow" target="_blank"> core-js </a>，按照版本或类型对最新的ECMAScript语法进行分类，以便开发者更好地按需引入。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/31fcfda8cd8f3181dbab3ef26284c3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ol4t5gmAAB9rJVoypEWchg.png"/></div></div></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/4eb6d6257360045b4cc0733af5939c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rQ0hGlL2DQb1vgNxPC-QQ.png"/></div></div></figure><h2 id="5f63" class="mh ku in bd kv mm mn dn kz mo mp dp ld kg mq mr lh kk ms mt ll ko mu mv lp mw bi translated">@babel/preset-env</h2><p id="33ae" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">另外还有一个基于core-js封装的上层插件<a class="ae mb" href="https://babeljs.io/docs/en/babel-preset-env" rel="noopener ugc nofollow" target="_blank">@ babel/preset-env</a>。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/72a4bb7cae6c10b011cb53a81cf8a3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xx_yFjAXB8KqpKIUJP2njA.png"/></div></div></figure><p id="2bdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过在文件(browserslist)并设置最低兼容语法版本来控制聚合填充的代码大小，避免引入过多和不必要的聚合填充。</p><h2 id="03b6" class="mh ku in bd kv mm mn dn kz mo mp dp ld kg mq mr lh kk ms mt ll ko mu mv lp mw bi translated">polyfill.io</h2><p id="2740" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">无论是core-js还是@babel/preset-env，polyfills代码都是在构建时生成的，换句话说，它们是以js文件的形式存储在本地产品中的。</p><p id="c16e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">他们两个都有一个缺点。虽然聚合填充的体积可以在构建时通过配置进行优化，但一旦生成就不能再进行进一步的优化。</p><p id="cc2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，当我使用低于chrome73的浏览器访问时，它会加载构建时生成的polyfills代码。</p><p id="bbf5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当使用最新版本的chrome访问时，它也会加载相同的代码。但是对于此时的chrome，由于内核已经支持新的语法，所以不需要这个polyfill。这时候加载无疑是浪费资源，还可能影响屏幕时间(FP)。</p><p id="6ce9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有没有办法在浏览器运行时动态加载polyfills？答案就是Vite官方<a class="ae mb" href="https://polyfill.io/v3/" rel="noopener ugc nofollow" target="_blank">网站</a>上提到的polyfill.io。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/fff17e72d1a09b59fb2fb4ad964bc38b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNi3PEqshptJIgZunNAT4Q.png"/></div></div></figure><p id="41c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要使用polyfill.io，您需要首先设置最高语法版本以获取URL。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/7cd2cf3490521e0f4ff9257200bce674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLApvEVE3TdfSWxrNjCRyg.png"/></div></div></figure><p id="be47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当浏览器访问URL时，动态返回适合当前浏览器的polyfills。</p><ul class=""><li id="695f" class="mx my in jx b jy jz kc kd kg mz kk na ko nb ks nc nd ne nf bi translated">低版本浏览器</li></ul><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/133e0adea0a4496de5e2445b17faa77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijdGZHqpQIFXjK8V4FNhfw.png"/></div></div></figure><ul class=""><li id="0724" class="mx my in jx b jy jz kc kd kg mz kk na ko nb ks nc nd ne nf bi translated">高端浏览器</li></ul><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/906e0960d29d39a0733acd08f9cb2a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXCGptTGCcHy9Ssk7VOlpA.png"/></div></div></figure><p id="2537" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以发现，对于同一个URL，低版本浏览器和高版本浏览器返回的结果是不一样的。请求头用户代理由它后面的服务器识别，并根据需要返回polyfills。</p><p id="9e0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是polyfill.io也并不完美</p><p id="44df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要请求第三方URL。由于polyfills需要在所有业务代码之前执行，如果外网出现波动，后续代码可能会被阻塞，导致白屏时间过长(可以通过私有化部署解决)。</p><p id="272d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些浏览器的用户代理可能不准确。</p><p id="dd06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用哪种聚合填充方法取决于项目，没有所谓的银弹</p><p id="93cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您对产品体积不敏感，请考虑使用预制的聚合填料</p><p id="c19c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果目标浏览器能够聚合并且能够进行私有部署，请考虑使用polyfills的运行时版本</p><p id="414b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说了这么多polyfills，让我们来看看transpilation</p><h1 id="c40e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">蒸腾作用</h1><p id="b2e1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对于某些新语法，不能单独使用多填充，例如</p><p id="ad2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mb" href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank">可选——链接(a？。b ) </a></p><p id="a651" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mb" href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" rel="noopener ugc nofollow" target="_blank">零化凝聚算子(a？？10 ) </a></p><p id="8311" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mb" href="https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators" rel="noopener ugc nofollow" target="_blank">逻辑赋值运算符(a ||= 10 ) </a></p><p id="2f86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似的新语法，由于依赖于浏览器内核的词法分析，较低版本浏览器无法以补丁的形式解决。</p><p id="f3ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以这种语法只能通过语法翻译，在构造的时候会返回低版本浏览器可以运行的代码。</p><pre class="lx ly lz ma gt mc md me mf aw mg bi"><span id="b718" class="mh ku in md b gy mi mj l mk ml">// source<br/>const a = 0<br/>console.log(a ?? 10)<br/> <br/>// dist<br/>var a = 0;<br/>console.log(a !== null &amp;&amp; a !== void 0 ? a : 10);</span></pre><p id="e576" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在主流的翻译工具是<a class="ae mb" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> babel </a>(没错，除了polyfills还支持transpilation)。通过与构建工具的集成，开发环境可以使用现成的新语法。实现原理如下</p><p id="ac62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.当构造时，通过词法分析将它解析成抽象语法树</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/760d9079ffdfe35d8734357f7d816d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0XulbTunYv2PUHbz3f3VA.png"/></div></div></figure><p id="e8d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.然后将抽象语法树转换成与较低版本浏览器兼容的抽象语法树</p><p id="2712" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.使用新的抽象语法树来生成低级js代码</p><p id="600a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终产品也不会包含新的语法，所以所有浏览器都可以完美运行</p><h1 id="5536" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">差异</h1><p id="589e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">那么哪些语法用polyfill，哪些语法用transpilation呢？我总结几点</p><p id="7d52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用polyfill，可以在任何版本的浏览器上模拟实现的API</p><p id="8ee7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于词法方面，比如新关键字(async/const/|&gt;/？？)，使用语法翻译</p><p id="1d23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对可以用polyfill实现的所有内容使用polyfill，对不能实现的内容使用语法翻译</p><p id="784e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其他几个例子</p><p id="8a94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多填充物</p><p id="4631" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">字符串.原型.匹配</p><p id="0c97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">号码. isNaN</p><p id="50cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">地图/套件</p><p id="0580" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">蒸腾作用</p><p id="1722" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">箭头功能</p><p id="8181" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">const/let</p><p id="a8d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步/等待</p><h1 id="953d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Vite支持聚合填充</h1><p id="d776" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我花了很多时间讨论多填充和透明的关系。回到问题本身，官方文件明确提到Vite不会添加polyfills。</p><p id="b8a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并且使用<a class="ae mb" href="https://cli.vuejs.org/guide/browser-compatibility.html#browserslist" rel="noopener ugc nofollow" target="_blank"> vue-cli </a>将自动添加聚合填充</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/25acff83dc1a23196e4fa8f5a73660ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KD4ORf3wHQMAaIa4qfWsng.png"/></div></div></figure><p id="ea6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对此感到困惑，我问了Vite开发者</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/729d5e77d1d44ec11ea042705ea687a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dG9F615mrySP1_BXV8FiqQ.png"/></div></div></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/882ee282ec9c5fa3e85a8dc96f887068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSHDQqJM0zWB0mpqeW0Oxw.png"/></div></div></figure><p id="32e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">他说Vite是针对现代浏览器的(这个其实不对，他后来补充了，现代浏览器也需要poly fill)，考虑到产品体积和esbuild本身对poly fill的支持，没有内置poly fill。</p><p id="60c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有，他推荐了<a class="ae mb" href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy#polyfill-specifiers" rel="noopener ugc nofollow" target="_blank"> @vitejs/plugin-legacy </a>插件，可以为Vite添加polyfills支持。</p><p id="0305" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者使用上面提到的运行时聚合填充。选择哪一个，要看分析产品的体积和第一屏的基准，再做决定。</p><p id="9fdc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论如何，问题终于找到了，有了相应的解决方案，任务完成了。</p><h1 id="5372" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">总结</h1><p id="108c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">默认情况下，Vite不会添加任何聚合填充。如果没有特殊处理，一定要避免编写需要多填充的新语法，否则会导致低版本浏览器出错。</p><p id="16f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">低配版浏览器不仅是IE浏览器，还有低配版Chrome浏览器。</p><p id="3cc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了让所有用户都能正确使用项目中的新语法，建议单独添加聚合填充。</p><p id="ea52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用<a class="ae mb" href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy#polyfill-specifiers" rel="noopener ugc nofollow" target="_blank"> @vitejs/plugin-legacy </a>或<a class="ae mb" href="https://polyfill.io/v3/" rel="noopener ugc nofollow" target="_blank"> polyfill.io </a>为Vite项目添加polyfill。</p><p id="ac6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章讲了一个Vite项目遇到的问题，主流的polyfills方法，babel，以及解决问题的方法，对我来说很有收获。</p><h1 id="671b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">参考</h1><p id="2a16" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><a class="ae mb" href="https://javascript.info/polyfills" rel="noopener ugc nofollow" target="_blank">多灌装器和输送器</a></p><p id="37d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">【Polyfilling和Transpiling有什么区别？</p><p id="76bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ng">更多内容看</em> <a class="ae mb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ng">说白了。报名参加我们的</em> <a class="ae mb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们关于</em><a class="ae mb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ng">Twitter</em></strong></a><em class="ng">和</em><a class="ae mb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ng">LinkedIn</em></strong></a><em class="ng">。加入我们的</em> <a class="ae mb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ng">社区</em> </strong> </a> <em class="ng">。</em></strong></a></p></div></div>    
</body>
</html>