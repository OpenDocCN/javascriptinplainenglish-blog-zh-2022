<html>
<head>
<title>ES6 Features that Make You a Modern JavaScript Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使您成为现代JavaScript开发人员的ES6特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/es6-features-that-make-you-a-modern-javascript-developer-2b6d279b8e4d?source=collection_archive---------6-----------------------#2022-01-21">https://javascript.plainenglish.io/es6-features-that-make-you-a-modern-javascript-developer-2b6d279b8e4d?source=collection_archive---------6-----------------------#2022-01-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f35cdd6da1202a429f7722aa03717611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G788U7EQNm70xhiW_hbwew.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@timmykp?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tim van der Kuip</a> on <a class="ae jz" href="https://unsplash.com/s/photos/software-developer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0490" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ES6也称为ECMAScript 2015，是ECMAScript语言标准的主要版本之一，它带来了一些令人兴奋的功能。今天，我们将看到它提供的一些优势。</p><ol class=""><li id="bece" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="kc io"> <em class="lh"> let和const关键字</em> </strong></li><li id="4efe" class="ky kz in kc b kd li kh lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="kc io"> <em class="lh">模板文字</em> </strong></li><li id="6244" class="ky kz in kc b kd li kh lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="kc io"> <em class="lh">多行字符串</em> </strong></li><li id="be5e" class="ky kz in kc b kd li kh lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="kc io"> <em class="lh">箭头功能</em> </strong></li><li id="102a" class="ky kz in kc b kd li kh lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="kc io"> <em class="lh">承诺</em> </strong></li><li id="8808" class="ky kz in kc b kd li kh lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="kc io"> <em class="lh">解构</em> </strong></li><li id="1a47" class="ky kz in kc b kd li kh lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="kc io"> <em class="lh">为…的循环</em> </strong></li><li id="6dfe" class="ky kz in kc b kd li kh lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="kc io"> <em class="lh">传播算子和休息参数</em> </strong></li></ol><p id="a9a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们一个一个来看看。</p><h1 id="bf5e" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">let和const关键字</h1><p id="16e1" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">在过去，<strong class="kc io"> <em class="lh"> var </em> </strong>关键字被用来定义变量。不过，现在鼓励开发者使用<strong class="kc io"><em class="lh">【let】</em></strong><strong class="kc io"><em class="lh">const</em></strong>而不是使用<strong class="kc io"> <em class="lh"> var。</em></strong></p><p id="c59c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="lh"> let </em> </strong>关键字允许用户定义变量，而<strong class="kc io"> <em class="lh"> const </em> </strong>帮助定义常量。换句话说，用<strong class="kc io"> <em class="lh"> const </em> </strong>声明的变量不能被重新赋值。如果你有一个不应该被意外覆盖的变量，你应该使用<strong class="kc io"> <em class="lh"> const </em> </strong>。它会在编译时显示错误。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0227" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得了解的是，为什么不首选使用var。请参见下面的示例。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="25be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仔细看看这两个for循环的输出。</p><p id="a8a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">变量<strong class="kc io"> <em class="lh"> i </em> </strong>在我们不需要发生的第一个for循环之外是可见的(意思是打印值“outside 3”)。原因是如果var在函数之外，那么它的<strong class="kc io">范围就是全局的。但是<strong class="kc io">让</strong>被<strong class="kc io">挡住了范围</strong>。这就是为什么当我们试图在循环外访问变量<strong class="kc io"> <em class="lh"> j </em> </strong>时，第二个for循环会给出错误。</strong></p><p id="ba75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并且"<strong class="kc io"> <em class="lh"> var </em> </strong>"不会责怪我们，如果我们像下面这样重新声明一个变量。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d3d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是“<strong class="kc io"> <em class="lh">让”</em> </strong>都不会答应去做。</p><p id="3466" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，总是喜欢用<strong class="kc io"> <em class="lh">让</em> </strong>或<em class="lh"> const </em> 而不是<strong class="kc io"> <em class="lh"> var </em> </strong>。</p><h1 id="3b65" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">模板文字</h1><p id="9efe" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">您不再需要使用“+”号连接字符串。有了ES6，这就容易多了。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="72dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">字符串应该是<strong class="kc io">反勾</strong><strong class="kc io">(`)</strong>，变量应该在<strong class="kc io"> ${} </strong>内部传递。</p><p id="9f6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你使用旧的方法，它看起来会是这样，对于复杂的方法来说，可读性和可管理性较差。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="ca89" class="nb lo in mx b gy nc nd l ne nf">const value = "Apple is "+ color;</span></pre><h1 id="c5d8" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">多行字符串</h1><p id="f10a" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">一气呵成就能写出多行字符串！</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c638" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们也需要使用<strong class="kc io">反勾</strong>。</p><p id="9d05" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一下我们用老方法做这件事。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="33f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看现代的方法有多简单！。</p><h1 id="1d13" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">箭头功能</h1><p id="cdab" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">这就是我们通常在JavaScript中定义函数的方式。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0d01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ES6提供了一种更加简洁的编写函数的方式。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f233" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个和第一个完全类似。<strong class="kc io">同样值得记住的是，箭头函数和函数声明并不总是可以互换的。</strong></p><h1 id="71b6" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">承诺</h1><p id="2c27" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">当我们需要处理异步任务时，承诺非常有用。</p><p id="96e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果我们需要在给定的时间后执行一些，我们可以这样做。它将在两秒钟后打印console.log()语句。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8d1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您从数据库和API获取数据时，这将非常有用。</p><p id="53e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果想了解更多关于异步的本质和处理，可以参考这个。</p><div class="ng nh gp gr ni nj"><a href="https://blog.devgenius.io/handling-asynchronous-nature-in-nodejs-javascript-66471aef6dae" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">处理NodeJS/JavaScript中的异步特性</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">回调，承诺和Asnyc-await简单解释</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">blog.devgenius.io</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jt nj"/></div></div></a></div><h1 id="7322" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">解构</h1><p id="56b0" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">这个特性提供了一种非常简单的方法来解包数组和对象中的值。</p><p id="5819" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以将析构特性应用于一个对象，如下所示。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2dab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以对数组做同样的事情。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="ec8f" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">for…of循环</h1><p id="0023" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">for…of循环是ES6提供的另一个有前途的特性。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1b6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码比使用传统的for循环要干净得多。我们可以毫不费力地遍历数组。</p><h1 id="f22c" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">展开运算符和静止参数</h1><p id="66f3" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">Spread运算符执行的是对数组中的值进行解包。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2951" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为它的一个用例，这在连接数组时非常有用。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="67cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Rest参数帮助我们通过参数为函数提供任意数量的值。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="2e6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经讨论了ES6的几个特性，它们使JavaScript变得更加简单。然而，ES6中有更多的特性，比如类和模块。尽量用ES6少写代码多做！。</p><p id="2b42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望这对你有帮助。编码快乐！</p><p id="641a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你。</p><p id="09e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lh">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lh">说白了。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lh">免费周报</em> </strong> </a> <em class="lh">。在我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lh">社区不和谐</em> </strong> </a> <em class="lh">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>