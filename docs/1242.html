<html>
<head>
<title>Manifest Your JavaScript Developer Power with Precise Function Invocations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过精确的函数调用展现您的JavaScript开发能力</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-functions-part-2-function-invocation-bb51407b81b8?source=collection_archive---------20-----------------------#2022-03-10">https://javascript.plainenglish.io/javascript-functions-part-2-function-invocation-bb51407b81b8?source=collection_archive---------20-----------------------#2022-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e28f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript函数第2部分:函数隐式参数和调用函数</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f202e75b8164241bc385914135720535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*La7b02df4yotuwmLd9ZdQw.jpeg"/></div></div></figure><p id="83c5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">这是第一篇文章的延续:</em></p><div class="ll lm gp gr ln lo"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-functions-part-1-definitions-and-arguments-ef2643e73233"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">作为一名JavaScript开发人员，3个函数概念将成为你的武器库</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">JavaScript函数第1部分:函数定义和参数赋值</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc km lo"/></div></div></a></div><p id="1c33" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这篇博客中，我们将讨论以下主题:</p><ul class=""><li id="99c8" class="md me in kq b kr ks ku kv kx mf lb mg lf mh lj mi mj mk ml bi translated">函数隐式参数</li><li id="b1fb" class="md me in kq b kr mm ku mn kx mo lb mp lf mq lj mi mj mk ml bi translated">以各种方式调用函数</li></ul><h2 id="fc91" class="mr ms in bd mt mu mv dn mw mx my dp mz kx na nb nc lb nd ne nf lf ng nh ni nj bi translated">1.函数隐式参数:<code class="fe nk nl nm nn b">“arguments”</code>和" this "</h2><p id="3b14" class="pw-post-body-paragraph ko kp in kq b kr no jo kt ku np jr kw kx nq kz la lb nr ld le lf ns lh li lj ig bi translated">从<a class="ae nt" href="https://medium.com/@shriomtripathi33/javascript-functions-part-1-definitions-and-arguments-ef2643e73233" rel="noopener">第1部分</a>我们了解了函数<em class="lk">参数</em>(作为函数定义的一部分列出的变量)和函数<em class="lk">参数</em>(调用函数时传递给函数的值)之间的区别。)<em class="lk">。所以当我们调用一个函数时，有两个参数被隐式地传递给函数，<code class="fe nk nl nm nn b">arguments</code>和<code class="fe nk nl nm nn b">this</code>。</em></p><p id="ef85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些参数没有在函数签名中显式指定，因此它们被认为是隐式的。</p><p id="c465" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 1.1 </strong> <code class="fe nk nl nm nn b"><strong class="kq io">arguments</strong></code> <strong class="kq io">参数</strong></p><p id="e613" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">提供给函数的所有参数都收集在<code class="fe nk nl nm nn b">arguments</code>参数中。它用于访问函数的所有参数。它允许我们使用函数重载，这是JavaScript本身不支持的。<br/>自从在ES6中引入<code class="fe nk nl nm nn b">rest</code>参数后，<code class="fe nk nl nm nn b">arguments</code>参数的使用显著减少。让我们看看实现参数是如何工作的。</p><p id="7c0a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe nk nl nm nn b">arguments</code>对象有一个合适的<em class="lk">长度</em>来表示参数的数量。单个参数值可以通过使用数组//索引符号获得；例如<em class="lk">论据【6】。</em></p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="827d" class="mr ms in nn b gy ny nz l oa ob">Sample 1 :<br/>// <a class="ae nt" href="https://www.w3schools.com/js/js_function_parameters.asp" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/js/js_function_parameters.asp</a></span><span id="676a" class="mr ms in nn b gy oc nz l oa ob">x = findMax(1, 123, 500, 115, 44, 88);<br/>function findMax() {<br/>   let max = -Infinity;<br/>     for (let i = 0; i &lt; arguments.length; i++) {<br/>       if (arguments[i] &gt; max) {<br/>       max = arguments[i];<br/>       }<br/>     }<br/>     return max;<br/> }</span><span id="939a" class="mr ms in nn b gy oc nz l oa ob">console.log(x)</span><span id="efe3" class="mr ms in nn b gy oc nz l oa ob">// output<br/>500</span><span id="cbad" class="mr ms in nn b gy oc nz l oa ob">Sample 2 :<br/>function nowhere(a, b, c) {<br/>    console.log(a, b, c);<br/>    console.log(arguments)<br/>}</span><span id="6ada" class="mr ms in nn b gy oc nz l oa ob">// output<br/>nowhere(3,4,5,6)<br/>3 4 5<br/>[Arguments] { '0': 3, '1': 4, '2': 5, '3': 6 }<br/></span></pre><p id="1187" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">严格模式:</p><p id="649d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">严格模式是对JavaScript的ES5增强，它导致错误被抛出，而不是被JavaScript引擎安静地拾取。一些语言特性的行为已经被改变，一些潜在有害的语言特性已经被彻底禁止(稍后将详细介绍)。严格模式禁用参数别名，这是它的改进之一。</p><p id="8b6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将函数参数与arguments对象混为一谈可能会令人困惑。让我们看看下面给出的例子，以避免混淆。</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="6f0e" class="mr ms in nn b gy ny nz l oa ob">"use strict"</span><span id="ce92" class="mr ms in nn b gy oc nz l oa ob">function handleBomb(country) {<br/> console.log(arguments)<br/> arguments[0] = 'Japan';<br/> console.log(country, arguments[0])<br/>}</span><span id="6310" class="mr ms in nn b gy oc nz l oa ob">handleBomb('USA')<br/>// output<br/>[Arguments] { '0': 'USA' }<br/>USA Japan</span></pre><p id="cfaa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了更好地理解，请参考这篇文章:</p><div class="ll lm gp gr ln lo"><a href="http://qnimate.com/javascript-strict-mode-in-nutshell/" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">带示例的Javascript“使用严格”教程</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">编辑描述</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">qnimate.com</p></div></div><div class="lx l"><div class="od l lz ma mb lx mc km lo"/></div></div></a></div><p id="30ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 1.2 </strong> <code class="fe nk nl nm nn b"><strong class="kq io">this</strong></code> <strong class="kq io">参数</strong></p><p id="40be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe nk nl nm nn b">this</code>参数是面向对象JavaScript的一个重要组成部分，指的是与函数调用相关联的对象。因此，它被称为功能<em class="lk">上下文。</em></p><p id="30a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数上下文是来自面向对象语言如Java的一个概念。他们可能认为他们理解了<code class="fe nk nl nm nn b">this</code>，因为在这种语言中<code class="fe nk nl nm nn b">this</code>指向定义了该方法的类的一个实例。</p><p id="1343" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是我们将在下面的上下文中看到，JavaScript中的<code class="fe nk nl nm nn b">this</code>依赖于函数调用的方式。因为理解<code class="fe nk nl nm nn b">this</code>参数的确切性质是面向对象JavaScript最重要的支柱之一。</p><h2 id="8a75" class="mr ms in bd mt mu mv dn mw mx my dp mz kx na nb nc lb nd ne nf lf ng nh ni nj bi translated">2.以各种方式调用函数</h2><p id="35b8" class="pw-post-body-paragraph ko kp in kq b kr no jo kt ku np jr kw kx nq kz la lb nr ld le lf ns lh li lj ig bi translated"><strong class="kq io"> 2.1作为函数调用</strong></p><p id="9867" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">别被标题搞糊涂了，调用“<em class="lk">作为函数</em>”是为了和其他调用机制区分开来:<em class="lk">方法</em>、<em class="lk">构造函数</em>和<code class="fe nk nl nm nn b">apply</code> <em class="lk"> / </em> <code class="fe nk nl nm nn b">call</code> <em class="lk">。</em></p><p id="0fee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当使用<code class="fe nk nl nm nn b">()</code> <em class="lk"> </em>操作符调用函数，并且应用了<code class="fe nk nl nm nn b">()</code>操作符的表达式没有将函数作为对象的属性引用时，就会发生这种类型的调用。</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="e7b3" class="mr ms in nn b gy ny nz l oa ob">// function declaration invoked as a function<br/>function hero() {};<br/>hero()</span><span id="5ddf" class="mr ms in nn b gy oc nz l oa ob">// function expression invoked as a function<br/>var superman = function () {};<br/>superman();</span><span id="da4f" class="mr ms in nn b gy oc nz l oa ob">// Immediately invoked function expression, invoked as function<br/>(function(){})()</span></pre><p id="db6f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们以这种方式调用函数时，函数的上下文(<code class="fe nk nl nm nn b">this</code>关键字)可以是两个东西:在非严格模式下，它将是全局上下文(窗口对象)，在严格模式下，它将是未定义的。</p><p id="a249" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2.2作为方法调用</strong></p><p id="24a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当一个函数被赋予一个对象的属性，并且通过引用该属性来调用该函数时，该函数被称为该对象的方法。</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="697b" class="mr ms in nn b gy ny nz l oa ob">const hero = {}<br/>hero.superman = function(){};<br/>hero.superman()</span></pre><p id="decd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里先来了解一下<em class="lk">法</em>这个词。来自面向对象的背景，您会记得方法所属的对象在方法体中是可用的，如<code class="fe nk nl nm nn b">this</code>。同样的事情也发生在这里。当一个函数作为一个对象的方法被调用时，该对象成为函数上下文，并通过<code class="fe nk nl nm nn b">this</code>参数在函数中可用。这意味着JavaScript允许编写面向对象的代码。</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="e319" class="mr ms in nn b gy ny nz l oa ob">function provideContext() {<br/> this.exceptionHero = 'Vision'<br/> return this;<br/>}</span><span id="ac73" class="mr ms in nn b gy oc nz l oa ob">const contextHandler = {<br/> orgName: 'Marvel',<br/> provideSuperHeroContext: provideContext<br/>}</span><span id="7779" class="mr ms in nn b gy oc nz l oa ob">console.log('---1---')<br/>console.log(provideContext())</span><span id="56c2" class="mr ms in nn b gy oc nz l oa ob">console.log('---2---')<br/>console.log(contextHandler.provideSuperHeroContext())</span><span id="ba1e" class="mr ms in nn b gy oc nz l oa ob">// output<br/>---1---<br/>Object [global] {<br/>  global: [Circular],<br/>  clearInterval: [Function: clearInterval],<br/>  clearTimeout: [Function: clearTimeout],<br/>  setInterval: [Function: setInterval],<br/>  setTimeout: [Function: setTimeout] {<br/>    [Symbol(nodejs.util.promisify.custom)]: [Function]<br/>  },<br/>  queueMicrotask: [Function: queueMicrotask],<br/>  clearImmediate: [Function: clearImmediate],<br/>  setImmediate: [Function: setImmediate] {<br/>    [Symbol(nodejs.util.promisify.custom)]: [Function]<br/>  },<br/>  exceptionHero: 'Vision'<br/>}<br/>---2---<br/>{<br/>  orgName: 'Marvel',<br/>  provideSuperHeroContext: [Function: provideContext],<br/>  exceptionHero: 'Vision'<br/>}</span></pre><p id="2e99" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注意:</strong>为了以面向对象的方式编写JavaScript，函数必须作为方法被调用。这允许您在任何方法中使用<code class="fe nk nl nm nn b">this</code>来引用方法的<strong class="kq io">所有者</strong>对象，这是面向对象编程中的一个基本思想。</p><p id="e4e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2.3作为构造函数调用</strong></p><p id="b907" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">构造函数的声明就像其他函数一样，我们可以使用函数声明或函数表达式来构造新的对象。只有数组函数有点不同。主要的区别总是来自于函数调用的方式。</p><p id="a9e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了将函数作为构造函数调用，我们在函数调用之前添加了关键字<code class="fe nk nl nm nn b">new</code>。</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="2645" class="mr ms in nn b gy ny nz l oa ob">function Marvel() {</span><span id="aa75" class="mr ms in nn b gy oc nz l oa ob">}</span><span id="ed7b" class="mr ms in nn b gy oc nz l oa ob">const marvel = new Marvel()</span></pre><p id="1a26" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2.3.1构造函数是函数的类固醇</strong></p><p id="1a16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们来看看:</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="b772" class="mr ms in nn b gy ny nz l oa ob">function HeroOrg() {<br/> this.groundRules = function() {<br/>  return this;<br/> }<br/>}</span><span id="4002" class="mr ms in nn b gy oc nz l oa ob">const marvel = new HeroOrg()<br/>const dc = new HeroOrg()</span><span id="982d" class="mr ms in nn b gy oc nz l oa ob">console.log('---1---')<br/>console.log(marvel.groundRules() === dc.groundRules())</span><span id="5350" class="mr ms in nn b gy oc nz l oa ob">console.log('---2---')<br/>console.log(marvel.groundRules() === marvel)</span><span id="17ca" class="mr ms in nn b gy oc nz l oa ob">//output<br/>---1---<br/>false<br/>---2---<br/>true</span></pre><p id="a763" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们创建一个名为<em class="lk"> HeroOrg </em>的函数，它将用于构造。我们创建两个实例<em class="lk">惊奇</em>和<em class="lk"> dc </em>。构造函数在这个对象上创建了一个名为<em class="lk"> groundRules </em>的属性，这个属性被赋予了一个函数，使得这个函数成为新创建的对象的一个方法。</p><p id="8745" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">构造函数调用时会发生一些事情:</p><ul class=""><li id="f526" class="md me in kq b kr ks ku kv kx mf lb mg lf mh lj mi mj mk ml bi translated">创建一个新的空对象。</li><li id="b24b" class="md me in kq b kr mm ku mn kx mo lb mp lf mq lj mi mj mk ml bi translated">这个创建的对象作为<code class="fe nk nl nm nn b">this</code>参数传递给构造函数，并因此成为构造函数的函数上下文。</li><li id="dee9" class="md me in kq b kr mm ku mn kx mo lb mp lf mq lj mi mj mk ml bi translated">构造函数对象作为<code class="fe nk nl nm nn b">new</code>操作符的值返回。</li></ul><p id="21cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">构造函数的工作是构建一个新对象，配置它，并将其作为构造函数的值返回。任何阻碍这一目标的事情对构造者来说都不是好事。</p><p id="6542" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2.3.2构造函数返回的值</strong></p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="8085" class="mr ms in nn b gy ny nz l oa ob">function Hero() {<br/> this.name = 'Superman'<br/> return 'sucess'<br/>}</span><span id="90fe" class="mr ms in nn b gy oc nz l oa ob">const hero1 = new Hero()<br/>const hero2 = Hero()</span><span id="a7ca" class="mr ms in nn b gy oc nz l oa ob">console.log('---1---')<br/>console.log(hero1)</span><span id="77cd" class="mr ms in nn b gy oc nz l oa ob">console.log('---2---')<br/>console.log(hero2)</span><span id="67cb" class="mr ms in nn b gy oc nz l oa ob">//output<br/>---1---<br/>Hero { name: 'Superman' }<br/>---2---<br/>sucess</span></pre><p id="2fa3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从上面的例子可以看出，当一个函数作为构造函数被调用时，构造函数创建的新对象被返回。如果我们调用一个没有<code class="fe nk nl nm nn b">new</code>关键字的函数，那么最终的返回语句值将被返回或<code class="fe nk nl nm nn b">undefined</code>。</p><p id="0321" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2.4使用</strong> <code class="fe nk nl nm nn b"><strong class="kq io">apply</strong></code> <strong class="kq io">、</strong> <code class="fe nk nl nm nn b"><strong class="kq io">call</strong></code> <strong class="kq io">和</strong> <code class="fe nk nl nm nn b"><strong class="kq io">bind</strong></code> <strong class="kq io">方法</strong></p><p id="0aa6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">到目前为止，我们已经看到<code class="fe nk nl nm nn b">this</code>是函数、全局或对象上下文的前缀，这取决于调用。JavaScript还允许我们将函数的上下文设置为自定义对象，即覆盖<code class="fe nk nl nm nn b">this</code>。我们可以使用每个函数都有的两种方法来实现这一点:<code class="fe nk nl nm nn b">apply</code>和<code class="fe nk nl nm nn b">call</code>。</p><p id="09ba" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2.4.1应用</strong></p><p id="9e5b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了通过<code class="fe nk nl nm nn b">apply</code>方法调用一个函数，我们向<code class="fe nk nl nm nn b">apply</code>传递两个参数，一个是作为函数上下文的对象，另一个是一组值。</p><p id="ff01" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如需更多详细信息，请查看:</p><div class="ll lm gp gr ln lo"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">function . prototype . apply()-JavaScript | MDN</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">该方法使用给定的this值和作为数组(或类似数组的对象)提供的参数调用函数。的…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">developer.mozilla.org</p></div></div><div class="lx l"><div class="oe l lz ma mb lx mc km lo"/></div></div></a></div><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="b72d" class="mr ms in nn b gy ny nz l oa ob">function fly() {<br/> console.log(this.org)<br/> console.log(...arguments)<br/>}</span><span id="2786" class="mr ms in nn b gy oc nz l oa ob">const customPower = { org: 'marvel'}<br/>fly.<strong class="nn io">apply</strong>(customPower, ['thor', 'ironman', 'vision'])</span><span id="5b9b" class="mr ms in nn b gy oc nz l oa ob">// output<br/>marvel<br/>thor ironman vision</span></pre><p id="b7a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为我们可以设置我们已经通过<code class="fe nk nl nm nn b">apply</code>传递了<em class="lk"> customPower </em>作为fly函数的上下文。如果是普通的调用，<code class="fe nk nl nm nn b">this</code>应该指向全局对象作为上下文，但是我们用自定义对象作为上下文覆盖了它。</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="60f2" class="mr ms in nn b gy ny nz l oa ob">const heroOrg = {<br/> fly: function () {<br/>  console.log(this.org)<br/>  console.log(...arguments)<br/> }<br/>}</span><span id="70c2" class="mr ms in nn b gy oc nz l oa ob">const customPower = { org: 'marvel'}<br/>heroOrg.fly.<strong class="nn io">apply</strong>(customPower, ['thor', 'ironman', 'vision'])</span><span id="4f3e" class="mr ms in nn b gy oc nz l oa ob">//output<br/>marvel<br/>thor ironman vision </span></pre><p id="f3b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2.4.2调用</strong></p><p id="fc2c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">call方法也以类似的方式使用。我们传递的不是参数数组，而是参数列表。</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="1d7c" class="mr ms in nn b gy ny nz l oa ob">function fly() {<br/> console.log(this.org)<br/> console.log(...arguments)<br/>}</span><span id="a5d4" class="mr ms in nn b gy oc nz l oa ob">const customPower = { org: 'marvel'}<br/>fly.<strong class="nn io">call</strong>(customPower, 'thor', 'ironman', 'vision')</span><span id="46f0" class="mr ms in nn b gy oc nz l oa ob">//output<br/>marvel<br/>thor ironman vision</span><span id="7bda" class="mr ms in nn b gy oc nz l oa ob">const heroOrg = {<br/> fly: function () {<br/>  console.log(this.org)<br/>  console.log(...arguments)<br/> }<br/>}</span><span id="5271" class="mr ms in nn b gy oc nz l oa ob">const customPower = { org: 'marvel'}<br/>heroOrg.fly.<strong class="nn io">call</strong>(customPower, 'thor', 'ironman', 'vision')</span><span id="171f" class="mr ms in nn b gy oc nz l oa ob">//output<br/>marvel<br/>thor ironman vision</span></pre><p id="36aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2.4.3绑定</strong></p><p id="080a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe nk nl nm nn b">bind</code>方法可用于所有函数，其设计目的是<em class="lk">创建</em>并返回一个绑定到传入对象的<em class="lk">新</em>函数。</p><pre class="kd ke kf kg gt nu nn nv nw aw nx bi"><span id="e11b" class="mr ms in nn b gy ny nz l oa ob">const marvel = { name: "Marvel", leader: 'Nick Fury' }<br/>const dc = { name: "DC", leader: 'Batman'}</span><span id="b6a1" class="mr ms in nn b gy oc nz l oa ob">function printOrgnizationDetail() {<br/> console.log(`Name: ${this.name}, Lead: ${this.leader}`)<br/>}</span><span id="6588" class="mr ms in nn b gy oc nz l oa ob">const marvelOrg = printOrgnizationDetail.<strong class="nn io">bind</strong>(marvel)<br/>const dcOrg = printOrgnizationDetail.<strong class="nn io">bind</strong>(dc)</span><span id="499c" class="mr ms in nn b gy oc nz l oa ob">marvelOrg()<br/>dcOrg()</span><span id="e14f" class="mr ms in nn b gy oc nz l oa ob">//output<br/>Name: Marvel, Lead: Nick Fury<br/>Name: DC, Lead: Batman</span></pre><p id="18b2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注意</strong>:箭头函数(lambda函数)有限制。“<strong class="kq io">调用</strong>”、“<strong class="kq io">绑定</strong>、“<strong class="kq io">应用</strong>”不能用于数组函数。为了更好地理解箭头功能，请查看以下内容:</p><div class="ll lm gp gr ln lo"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">箭头函数表达式- JavaScript | MDN</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">arrow函数表达式是传统函数表达式的一种紧凑替代形式，但它是有限的，不能…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">developer.mozilla.org</p></div></div><div class="lx l"><div class="of l lz ma mb lx mc km lo"/></div></div></a></div><p id="ccaf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是JavaScript函数的全部进展。我希望你已经发现这是有用的。感谢您的阅读。</p><p id="edd5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容请看</em><a class="ae nt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a><em class="lk">。报名参加我们的</em> <a class="ae nt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费每周简讯</em> </strong> </a> <em class="lk">。关注我们关于</em><a class="ae nt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">Twitter</em></strong></a><em class="lk">和</em><a class="ae nt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">。加入我们的</em> <a class="ae nt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">社区不和谐</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>