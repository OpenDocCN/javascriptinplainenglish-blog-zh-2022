# LeetCode 的组合问题 JavaScript 中的递归回溯

> 原文：<https://javascript.plainenglish.io/combinations-recursive-backtracking-in-javascript-e784cfb8e73d?source=collection_archive---------6----------------------->

![](img/e4ee2f2f74b3d0e3e50652c0967da55b.png)

大约 80%的时候，我的 LeetCode 尝试感觉良好。我立刻有了直觉，知道如何将问题简化为基本形式，并开始着手我的方法。

LeetCode 的[组合](https://leetcode.com/problems/combinations/)问题绝对属于另外 20%。在这些问题上，我需要克制自己坐上几个小时(甚至几天)的冲动，直到我最终找到解决方案，并对它感到完全“原创”。

## **回溯/递归**

当我最终决定寻找线索时，回溯是一个反复出现的主题。这是一种算法方法，用于在一个逐步的过程中探索所有可能的解决方案，如果生成的组合(在这种情况下)满足我们的标准，那么我们可以保留它并继续下去。

回溯可以用来解决许多类型的难题，从纵横字谜到数独。

现在，我的目标是用尽可能简单的解释来解释它，因为对我来说，将它形象化是相当具有挑战性的。

## **问题**

给定两个整数`n`和`k`，我们将返回*范围* `[1, n]`之外的 `k` *数字的所有可能组合。*

我将使用一个简明的例子

n = 3

k = 2

因此，我将生成所有可能的组合，长度为两位数，每个数字可以在 1 到 3 之间(包括 1 和 3)。

## **想通了**

我承认，我有时试图避免递归，除非它很舒服，但这不是做(或不做)任何事情的好理由。所以我真的很感激有机会克服这些实践中的一些尴尬。

乍一看，我试图提出包含(大量)嵌套迭代方法的算法，以某种方式允许我收集所有可能的组合，如果必要的话删除重复项并完成它。

不管每个尝试最初看起来有多聪明，在构建出来之后，它们会感到非常复杂、低效，并且最终不适合处理输入大小的不确定性。这是递归真正发挥作用的地方。

## **进场**

因此，如果递归是实现这一点的最佳途径，我们就要寻找一个可重复的过程，最终使用长度为 2 位数的数字[1，2，3]产生所有组合。

在最基本的层面上，以下是需要周期性发生的事情:

我有两个在每次递归函数调用中都会改变的条目，一个起始索引和一个结果。不是最终的结果，而是我们当前构建的一个可能的组合。

首先，我想确定当前结果是否满足必要的标准(结果长度等于 k)。如果有，可以将其添加到结果数组中。

然后，我将按照传入的起始值的指定，遍历这个范围

现在，这个循环中只剩下三行代码，可以让递归函数做我们想让它做的事情。

前两个相当直观:

因此，我们只是将 I 值添加到我们正在构建的组合中，并再次调用该函数，只是这次使用下一个 I 值和我们新形成的组合。

现在最后一行+完整解决方案…

第 14 行的 result.pop()执行实际的“回溯”。

因此，如果我记录该循环中的当前“结果”,对于 n=3 和 k=2，我会得到这些值:

[1]

[1, 2]

[1, 2, 3]

[1, 3]

[2]

[2, 3]

[3]

我们的解决方案现在有三个符合标准 length = k = 2: [1，2]，[1，3]，[2，3]。因此，每个可能的组合都是从全范围内的每个索引开始探索的[1，2，3]。

在不久的将来，我将解决更多的 LeetCode 问题，这些问题也使用了类似的回溯模板。我真的很喜欢在各种变化中解决这样的问题，直到原则变成第二天性。另外，我的理解是，这类问题在面试中经常出现。

*更多内容请看*[***plain English . io***](https://plainenglish.io/)*。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。关注我们关于*[***Twitter***](https://twitter.com/inPlainEngHQ)*和*[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*。加入我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *。*