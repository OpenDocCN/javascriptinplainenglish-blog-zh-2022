<html>
<head>
<title>Placing Passages in a JavaScript Roguelike</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将段落放置在JavaScript Roguelike中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tuning-passage-placement-algorithm-in-a-javascript-roguelike-ae6273d9366f?source=collection_archive---------15-----------------------#2022-04-07">https://javascript.plainenglish.io/tuning-passage-placement-algorithm-in-a-javascript-roguelike-ae6273d9366f?source=collection_archive---------15-----------------------#2022-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/433e52c64bfbecda20b85599fbb17822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cz7biQrG2QjOMQ-aqDUBUA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Designed by <a class="ae kc" href="https://www.freepik.com/vectorpocket" rel="noopener ugc nofollow" target="_blank">vectorpocket</a> on <a class="ae kc" href="https://freepik.com" rel="noopener ugc nofollow" target="_blank">freepik</a></figcaption></figure><p id="7339" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的一个月左右的时间里，我一直在开发实验性的rogue likes——带有程序生成的地下城的2D冒险游戏。我的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-dungeon-crawler-game-with-javascript-57189bdd9f08">初始游戏</a>创建了看起来像洞穴的关卡，而最近的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-dungeon-crawler-game-with-javascript-57189bdd9f08">游戏</a>由狭窄通道连接的房间组成，如下图所示。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/b5e409ed57e7f613b0d2287c79afddc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aMhR6iM_yOQ8-8-l2AVSw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A roguelike with rooms connected by hallways.</figcaption></figure><p id="a9d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">拥有由算法生成的关卡的好处是你每次都会得到不同的关卡，这有助于保持游戏的新鲜感。也就是说，一个巨大的挑战是找出如何修复由于某种原因看起来关闭的地下城布局。</p><p id="a115" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我一次又一次刷新浏览器以查看算法产生的各种关卡设计时，一个突出的问题是不同宽度的段落的存在。虽然目的是使狭窄的通道有一个瓷砖的宽度，但由于多个通道彼此相邻，一些通道最终有两个或更多的瓷砖宽。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/bf8760bb50d94b414993eb553b987621.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*PYdxykDNNUyhg3BL4Nxr2g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Paths of different widths.</figcaption></figure><p id="9d04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我澄清一下，我不反对宽度为两个、三个或四个瓷砖的通道——但是对于这个特定的游戏，我希望保持通道宽度一致。我还发现，当两条或多条路径被允许靠近时，它们可能会导致混乱的形成，如下图所示。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/1c63a2554a9a727fe337c40336db919b.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*OD4vktBb-q6jMict7CZkDQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">An example of a dungeon level that bothered me.</figcaption></figure><p id="fe61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然上面的迷宫可能看起来很有趣，但不均匀的宽度加上道路和房间的融合导致了缺乏秩序，这让我感到困扰。</p><p id="bef6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在看了许多这种看起来很奇怪的地牢之后，我决定增加一个限制条件，不允许两个通道长时间在一起。一个通道与另一个通道相邻有几块瓷砖可能没问题，但是我想避免让五块或更多的瓷砖在一起。</p><p id="2ba3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将研究一种方法来检查地下城中的新路径是否与现有路径相邻。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="f439" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">项目文件</h1><p id="9b1a" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">虽然本文涵盖了一个更大的游戏项目的一部分，但是每个阶段都有自己的起始代码目录——所以您可以直接进入阶段3，而无需任何前期工作。</p><p id="18e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要下载项目目录，可以去这个<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms" rel="noopener ugc nofollow" target="_blank"> Git repo </a>，点击<em class="mr">代码</em>，点击<em class="mr">下载ZIP。</em>或者，您可以从命令行克隆它:</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="6454" class="mx lp iq mt b gy my mz l na nb">git clone <a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nevkatz/js-roguelike-rooms.git</a></span></pre><p id="7e7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下载的repo中，有一个<code class="fe nc nd ne mt b">phase-3-separate-paths</code>目录，您可以使用以下布局在其中工作。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="a4ec" class="mx lp iq mt b gy my mz l na nb">phase-3-separate-paths<br/>  |<br/>  *--index.html<br/>  |<br/>  *--css <br/>  |   |<br/>  |   *--style.css<br/>  |<br/>  *--js <br/>      |<br/>      *--script.js<br/>      |<br/>      *--game.js<br/>      |<br/>      *--<strong class="mt ir">room.js</strong><br/>      |<br/>      *--<strong class="mt ir">path.js</strong></span></pre><p id="f3a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个阶段3的目录中，前面阶段的所有方法都已经完成了，这将使您有时间完成手头的任务。</p><ul class=""><li id="19cf" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated">在包含<code class="fe nc nd ne mt b">Room</code>类的<code class="fe nc nd ne mt b">room.js</code>中，我们将添加两个方法——<code class="fe nc nd ne mt b">placePathX</code>和<code class="fe nc nd ne mt b">placePathY</code>。每个人都为一条不相邻的路径选择一个位置。</li><li id="4a31" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">同样在<code class="fe nc nd ne mt b">room.js</code>，我们会从<code class="fe nc nd ne mt b">addPathVert</code>调用<code class="fe nc nd ne mt b">placePathX</code>，从<code class="fe nc nd ne mt b">addPathHoriz</code>调用<code class="fe nc nd ne mt b">placePathY</code>。</li><li id="83a4" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">在包含<code class="fe nc nd ne mt b">Path</code>类的<code class="fe nc nd ne mt b">path.js</code>中，我们将编写两个方法——<code class="fe nc nd ne mt b">isAdjacentVert</code>和<code class="fe nc nd ne mt b">isAdjacentHoriz</code>。每种方法都检查一条路径是否与另一条路径相邻五块或更多。</li></ul><p id="704a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以在<code class="fe nc nd ne mt b">phase-4-corners</code>目录和<code class="fe nc nd ne mt b">solutions</code>目录中预览完成的代码。</p><h1 id="dc24" class="lo lp iq bd lq lr nt lt lu lv nu lx ly lz nv mb mc md nw mf mg mh nx mj mk ml bi translated">上层社会</h1><p id="4adc" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们将使用三个类:<code class="fe nc nd ne mt b">Game</code>、<code class="fe nc nd ne mt b">Room</code>和<code class="fe nc nd ne mt b">Path</code>。虽然在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/rendering-roguelike-rooms-with-javascript-8a2dc58f3b63">渲染室</a>文章中详细讨论了它们，但是让我们在这里集中讨论最相关的属性。</p><h2 id="415c" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">比赛</h2><p id="7116" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><code class="fe nc nd ne mt b">Game</code>类有一个名为<code class="fe nc nd ne mt b">map</code>的2D数组，用来存储地下城的配置。例如，如果一个4x3的房间被添加到一个6x5的地图的中心，<code class="fe nc nd ne mt b">map</code>数组将如下所示:</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="6d30" class="mx lp iq mt b gy my mz l na nb">[[0,0,0,0,0,0],<br/> [0,1,1,1,1,0],<br/> [0,1,1,1,1,0],<br/> [0,1,1,1,1,0],<br/> [0,0,0,0,0,0]]</span></pre><p id="721e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还有一个存储<code class="fe nc nd ne mt b">Room</code>对象的<code class="fe nc nd ne mt b">rooms</code>数组。</p><h2 id="b064" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">房间</h2><p id="52c5" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><code class="fe nc nd ne mt b">Room</code>类有两个我们将使用的依赖于位置的属性:</p><ul class=""><li id="d052" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated"><code class="fe nc nd ne mt b">start</code>，存储房间左上角的<code class="fe nc nd ne mt b">x</code>和<code class="fe nc nd ne mt b">y</code>值的对象</li><li id="d148" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><code class="fe nc nd ne mt b">end</code>，存储房间右下角的<code class="fe nc nd ne mt b">x</code>和<code class="fe nc nd ne mt b">y</code>值的对象。</li></ul><p id="fddc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以实例化一个<code class="fe nc nd ne mt b">Room</code>类，并如下设置它的开始和结束属性:</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="dfea" class="mx lp iq mt b gy my mz l na nb">let myRoom = new Room();</span><span id="2e20" class="mx lp iq mt b gy oj mz l na nb">myRoom.start = {x:1,y:1};<br/>myRoom.end = {x:4,y:4};</span></pre><h2 id="e1b8" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">房间邻居</h2><p id="b85f" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">room类还有一个名为<code class="fe nc nd ne mt b">neighbors</code>的数组属性，它存储它所连接的<code class="fe nc nd ne mt b">Room</code>对象。我们检查这个数组，以确保我们没有两次连接同一个房间，如果出现新的连接，每个房间都会将另一个房间添加到它的<code class="fe nc nd ne mt b">rooms</code>数组中，如下面的<code class="fe nc nd ne mt b">addNeighbors</code>所示。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="0997" class="mx lp iq mt b gy my mz l na nb">Room.prototype.addNeighbor = function(room) {<br/>   this.neighbors.push(room);<br/>   room.neighbors.push(this);<br/>}</span></pre><p id="797c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是你如何将它添加到主<code class="fe nc nd ne mt b">Game</code>对象中。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="b7c7" class="mx lp iq mt b gy my mz l na nb">myGame.rooms.push(myRoom);</span></pre><h2 id="a795" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">小路</h2><p id="9aad" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><code class="fe nc nd ne mt b">Path</code>类也有<code class="fe nc nd ne mt b">start</code>和<code class="fe nc nd ne mt b">end</code>坐标。考虑一下下面有路径的小游戏地图。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="8c80" class="mx lp iq mt b gy my mz l na nb">[[0,0,0,0,0,0,0],<br/> [1,1,1,1,1,1,1],<br/> [0,0,0,0,0,0,0]]</span></pre><p id="2da8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以实例化这样的路径，并将其添加到游戏中，如下所示:</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="721d" class="mx lp iq mt b gy my mz l na nb">let myPath = new Path();</span><span id="9466" class="mx lp iq mt b gy oj mz l na nb">myRoom.start = {x:0,y:1};<br/>myRoom.end = {x:6,y:1};</span><span id="f271" class="mx lp iq mt b gy oj mz l na nb">myGame.addPath(myPath);</span></pre><p id="69d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该路径还有一个布尔属性<code class="fe nc nd ne mt b">allowed</code>，以<code class="fe nc nd ne mt b">false</code>开始，但是如果它能在地图上找到一个地方，就会被设置为<code class="fe nc nd ne mt b">true</code>。</p><p id="4caf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是本教程中每个类需要了解的主要方面。虽然我们将为<code class="fe nc nd ne mt b">Path</code>和<code class="fe nc nd ne mt b">Room</code>类编写方法，但是每个类的属性都是完整的。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="c731" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">到目前为止代码是如何工作的</h1><p id="ccf4" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在我们卷起袖子准备代码之前，让我们看看游戏是如何生成房间并连接它们的。</p><p id="f32b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe nc nd ne mt b">script.js</code>文件中，我们有一个名为<code class="fe nc nd ne mt b">generateMapRooms</code>的函数。在这里生成多个房间后，每个<code class="fe nc nd ne mt b">Room</code>对象通过调用<code class="fe nc nd ne mt b">findFacingRooms</code>方法搜索其正对面的房间，这在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9">添加段落</a>文章中有详细介绍。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Generate map rooms.</figcaption></figure><p id="8860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个房间与另一个房间相连，就会产生一连串的其他方法。下面是一张快速示意图，展示了通话顺序。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="aabc" class="mx lp iq mt b gy my mz l na nb">generateMapRooms<br/> |<br/> *--findFacingRooms<br/>    |<br/>    *--connectRoom<br/>       |<br/>       *--directConnect<br/>          |<br/>          *--addVertPath<br/>          |<br/>          OR<br/>          |<br/>          *--addHorizPath</span></pre><p id="0d50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个快速分类:</p><ul class=""><li id="dd07" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated">一个<code class="fe nc nd ne mt b">Room</code>对象调用<code class="fe nc nd ne mt b">findFacingRooms</code>方法来寻找它对面的房间。</li><li id="7d28" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">如果一个<code class="fe nc nd ne mt b">Room</code>对象找到一个面对的房间，它调用<code class="fe nc nd ne mt b">connectRoom</code>，后者又调用<code class="fe nc nd ne mt b">directConnect</code>。</li><li id="a887" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><code class="fe nc nd ne mt b">directConnect</code>方法连接彼此面对的房间。</li><li id="1362" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">如果一个房间在另一个房间的北面或南面，<code class="fe nc nd ne mt b">directConnect</code>将调用<code class="fe nc nd ne mt b">addVertPath</code>。</li><li id="78f9" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">如果两个房间并排，<code class="fe nc nd ne mt b">directConnect</code>会调用<code class="fe nc nd ne mt b">addHorizPath</code>。</li></ul><p id="faaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们跳过<code class="fe nc nd ne mt b">connectRoom</code>和<code class="fe nc nd ne mt b">directConnect</code>，看看添加路径是如何发生的。</p><h2 id="a095" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">添加垂直路径</h2><p id="2d52" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在起始代码中，<code class="fe nc nd ne mt b">addVertPath</code>方法使用一个叫做<code class="fe nc nd ne mt b">placePath</code>的简单方法找到路径的<code class="fe nc nd ne mt b">x</code>坐标，我们最终会替换它。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The initial addVertPath method.</figcaption></figure><p id="ff93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，在我们获得垂直路径的起点和终点之后，就调用了<code class="fe nc nd ne mt b">placePath</code>方法。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="a523" class="mx lp iq mt b gy my mz l na nb">path.start.y = Math.min(this.end.y,room.end.y) + 1;</span><span id="868f" class="mx lp iq mt b gy oj mz l na nb">path.end.y = Math.max(this.start.y,room.start.y) - 1;</span><span id="9ec3" class="mx lp iq mt b gy oj mz l na nb"><strong class="mt ir">path = this.placePath(room, path, wall, 'x');</strong></span></pre><h2 id="4164" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">处理成功</h2><p id="0563" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">假设<code class="fe nc nd ne mt b">placePath</code>已经将有效的<code class="fe nc nd ne mt b">x</code>坐标添加到路径对象的<code class="fe nc nd ne mt b">start</code>和<code class="fe nc nd ne mt b">end</code>属性中，路径的<code class="fe nc nd ne mt b">allowed</code>状态将被设置为<code class="fe nc nd ne mt b">true</code>。</p><p id="bd89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后游戏可以通过调用<code class="fe nc nd ne mt b">addPath</code>将路径添加到<code class="fe nc nd ne mt b">map</code> 2D数组中。由于<code class="fe nc nd ne mt b">addNeighbor</code>调用，每个房间将另一个房间添加到它的<code class="fe nc nd ne mt b">rooms</code>数组中。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="87e2" class="mx lp iq mt b gy my mz l na nb">if (path.allowed) {</span><span id="a7eb" class="mx lp iq mt b gy oj mz l na nb">   game.addPath(path);</span><span id="6158" class="mx lp iq mt b gy oj mz l na nb">   this.addNeighbor(room);<br/>}</span></pre><p id="856a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是<code class="fe nc nd ne mt b">placePath</code>的作用——现在让我们看看它是如何工作的。</p><h2 id="99c2" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">通过寻找平均值来放置路径</h2><p id="ec88" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">对于垂直路径，<code class="fe nc nd ne mt b">placePath</code>的目标是找出水平放置的位置。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The placePath method.</figcaption></figure><p id="5bfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确定位置，它使用一种叫做<code class="fe nc nd ne mt b">possibleExits</code>的方法获得最低和最高可能的<code class="fe nc nd ne mt b">x</code>值。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="ac94" class="mx lp iq mt b gy my mz l na nb">let {start, end} = this.possibleExits(room, axis, wall);</span></pre><p id="b8de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将路径的<code class="fe nc nd ne mt b">x</code>坐标设为这两个值的平均值。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="3204" class="mx lp iq mt b gy my mz l na nb">path.start[axis] = path.end[axis] = Math.round((start+end)/2);</span></pre><p id="60fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，它通过将<code class="fe nc nd ne mt b">allowed</code>设置为<code class="fe nc nd ne mt b">true</code>来批准路径，并返回<code class="fe nc nd ne mt b">path</code>对象。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="acff" class="mx lp iq mt b gy my mz l na nb">path.allowed = true;</span><span id="3246" class="mx lp iq mt b gy oj mz l na nb">return path;</span></pre><p id="1efb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nc nd ne mt b">addHorizPath</code>方法也以同样的方式使用<code class="fe nc nd ne mt b">placePath</code>来确定水平路径的<code class="fe nc nd ne mt b">y</code>值。</p><p id="96a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码审查到此结束——现在让我们编写一种放置路径的新方法。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="c09f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">更仔细地放置路径</h1><p id="4a9a" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><code class="fe nc nd ne mt b">placePath</code>的问题是它没有考虑到其他路径的邻近性——所以现在我们将编写我们的第一个替换方法<code class="fe nc nd ne mt b">placePathX</code>，它在决定在哪里放置新的垂直路径之前检查现有的邻近路径。</p><p id="55fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用下面的代码启动<code class="fe nc nd ne mt b">placePathX</code>方法。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="b490" class="mx lp iq mt b gy my mz l na nb">Room.prototype.placePathX = function(room,path,wall) {<br/>   <br/>   let {start, end} = this.possibleExits(room,'x',wall);<br/>}</span></pre><p id="d2f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe nc nd ne mt b">placePath</code>一样，<code class="fe nc nd ne mt b">placePathX</code>的目标是为我们的垂直路径找到一个有效的<code class="fe nc nd ne mt b">x</code>坐标，并使用<code class="fe nc nd ne mt b">findPossibleExits</code>获得可能的最低和最高的<code class="fe nc nd ne mt b">x</code>值。</p><p id="206d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但相似之处仅此而已。</p><p id="58e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如下图所示，<code class="fe nc nd ne mt b">placePathX</code>不会找到最高和最低<code class="fe nc nd ne mt b">x</code>坐标的平均值。相反，它遍历所有可能的<code class="fe nc nd ne mt b">x</code>值，直到找到一个<em class="mr">而不是</em>使该路径与另一个路径相邻的值。继续添加下面的循环。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="a66f" class="mx lp iq mt b gy my mz l na nb">let {start, end} = this.possibleExits(room,'x',wall);</span><span id="4f00" class="mx lp iq mt b gy oj mz l na nb">for (var x = start; x &lt;= end; ++x) {</span><span id="fe28" class="mx lp iq mt b gy oj mz l na nb"><strong class="mt ir">  if (!path.isAdjacentVert(x)) {</strong></span><span id="fbd3" class="mx lp iq mt b gy oj mz l na nb"><strong class="mt ir">   // grab the first path that is not adjacent</strong></span><span id="ab76" class="mx lp iq mt b gy oj mz l na nb"><strong class="mt ir">   }</strong><br/>}</span></pre><p id="b11e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，它使用一种新的方法来检查一条路径是否与另一条路径相邻，我们将很快编写这种方法:<code class="fe nc nd ne mt b">isAdjacentVert</code>。</p><p id="ff94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦找到有效的<code class="fe nc nd ne mt b">x</code>坐标，它就批准路径，设置路径的水平位置，跳出循环，然后返回！</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="b8ba" class="mx lp iq mt b gy my mz l na nb">let {start, end} = this.possibleExits(room,'x',wall);</span><span id="de00" class="mx lp iq mt b gy oj mz l na nb">for (var x = start; x &lt;= end; ++x) {</span><span id="f230" class="mx lp iq mt b gy oj mz l na nb">if (!path.isAdjacentVert(x)) {<br/>    <strong class="mt ir">path.allowed = true;<br/>    path.start.x = path.end.x = x;<br/>    break;</strong><br/>  }<br/>}<br/><strong class="mt ir">return path;</strong></span></pre><p id="b93c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe nc nd ne mt b">addVertPath</code>调用的完整的<code class="fe nc nd ne mt b">placePathX</code>方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The full placePathX method.</figcaption></figure><p id="b81d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是放置垂直路径所需的方法调用的快速回顾。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="05ec" class="mx lp iq mt b gy my mz l na nb">directConnect<br/>  |<br/>  *--addVertPath<br/>       |<br/>       *--placePathX (just written)<br/>            |<br/>            *--possibleExits<br/>                 |<br/>               (loop through possible x values)<br/>                 |<br/>                 *--isAdjacentVert (up next)</span></pre><h2 id="d25a" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">检查相邻路径</h2><p id="fa34" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">现在我们已经有了方法调用的鸟瞰图，让我们再次深入代码，在<code class="fe nc nd ne mt b">path.js</code>中编写<code class="fe nc nd ne mt b">isAdjacentVert</code>。</p><p id="3938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个路径对象使用这个方法来判断它是否在一个特定的<code class="fe nc nd ne mt b">x</code>坐标上与另一个路径相邻。下面是完整的代码，然后是它的工作原理。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9e18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一点一点地浏览这段代码。</p><p id="e27e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一开始，我们将瓷砖的最大数量限制为五个。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="d5e2" class="mx lp iq mt b gy my mz l na nb">const limit = 5;</span></pre><p id="64ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将<code class="fe nc nd ne mt b">x</code>值设置为可选参数<code class="fe nc nd ne mt b">testX</code>或路径的起始<code class="fe nc nd ne mt b">x</code>坐标。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="4d43" class="mx lp iq mt b gy my mz l na nb">const x = testX || this.start.x;</span></pre><p id="2ecd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于有了<code class="fe nc nd ne mt b">for...of [-1,1]</code>语句，我们检查了路径两次:一次检查左边的瓦片，一次检查右边的瓦片。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="218d" class="mx lp iq mt b gy my mz l na nb">for (var diff of [-1, 1]) {</span></pre><p id="1ab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次，我们初始化一个<code class="fe nc nd ne mt b">consecutive</code>变量，它存储我们已经找到的连续图块的数量。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="34a3" class="mx lp iq mt b gy my mz l na nb">let consecutive = 0;</span></pre><ul class=""><li id="bf3c" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated">使用这个循环，我们沿着这条路走，检查左边或右边是否有地砖。</li></ul><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="68dc" class="mx lp iq mt b gy my mz l na nb">for (var y = this.start.y; y &lt;= this.end.y; ++y) {</span><span id="8893" class="mx lp iq mt b gy oj mz l na nb">if (game.map[y][x + diff] != WALL_CODE) {</span></pre><ul class=""><li id="9e10" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated">如果是，则<code class="fe nc nd ne mt b">consecutive</code>递增。</li></ul><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="098f" class="mx lp iq mt b gy my mz l na nb">consecutive++;</span></pre><ul class=""><li id="f929" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated">如果<code class="fe nc nd ne mt b">consecutive</code>等于瓦限，我们立即返回。</li></ul><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="87f0" class="mx lp iq mt b gy my mz l na nb">if (consecutive == limit) {<br/>   return true;<br/>}</span></pre><p id="5bff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果墙砖打破了地砖的条纹，我们将<code class="fe nc nd ne mt b">consecutive</code>重置为零。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="eeb3" class="mx lp iq mt b gy my mz l na nb">consecutive = 0;</span></pre><p id="e293" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们完成了循环，这意味着没有五个或更多瓷砖的相邻路径，所以我们返回<code class="fe nc nd ne mt b">false</code>。</p><p id="e960" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们如何测试一条路径是否与另一条路径垂直相邻。</p><p id="51a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在<code class="fe nc nd ne mt b">placePathX</code>有了它的<code class="fe nc nd ne mt b">isAdjacentVert</code>助手，我们可以让它工作了。</p><p id="8f00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nc nd ne mt b">addVertPath</code>中，让我们去掉这一行:</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="79b4" class="mx lp iq mt b gy my mz l na nb">path = this.placePath(room, path, wall, 'x');</span></pre><p id="e3cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换成这个:</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="f076" class="mx lp iq mt b gy my mz l na nb">path = this.placePathX(room, path, wall);</span></pre><p id="18cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是更新后的方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The revised addVertPath method.</figcaption></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="7b34" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">处理水平路径</h1><p id="8848" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">现在我们已经学习了如何添加一个垂直路径，看看你是否能自己编写下面的方法:</p><ul class=""><li id="c430" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated">在<code class="fe nc nd ne mt b">room.js</code>中写上<code class="fe nc nd ne mt b">placePathY</code></li><li id="956c" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">在<code class="fe nc nd ne mt b">path.js</code>中写入<code class="fe nc nd ne mt b">isAdjacentHoriz</code></li><li id="ca76" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">将<code class="fe nc nd ne mt b">placePathY</code>换成<code class="fe nc nd ne mt b">room.js</code>中的<code class="fe nc nd ne mt b">addPathHoriz</code></li></ul><p id="7ba9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">都准备好了吗？太好了，现在让我们看一下它们应该是什么样子。</p><h2 id="45a2" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">绘制水平路径</h2><p id="59ed" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">下面是修改后的<code class="fe nc nd ne mt b">addHorizPath</code>方法，用来添加水平路径。它的结构与<code class="fe nc nd ne mt b">addVertPath</code>相同，但找到了路径起点和终点的<code class="fe nc nd ne mt b">x</code>坐标。然后使用新的<code class="fe nc nd ne mt b">placePathY</code>方法计算出将其放置在<code class="fe nc nd ne mt b">y</code>轴上的位置。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The revised addHorizPath method.</figcaption></figure><h2 id="f191" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">放置水平路径</h2><p id="f4e8" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">下面是<code class="fe nc nd ne mt b">placePathY</code>，与<code class="fe nc nd ne mt b">placePathX</code>类似，但调用了一个<code class="fe nc nd ne mt b">isAdjacentHoriz</code>，是<code class="fe nc nd ne mt b">isAdjacentVert</code>的新的水平对应物。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d084" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个方法中，现在是您获取和迭代的<code class="fe nc nd ne mt b">y</code>坐标。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="7a6c" class="mx lp iq mt b gy my mz l na nb">let {start, end} = this.possibleExits(room,'y', wall);</span><span id="c0a8" class="mx lp iq mt b gy oj mz l na nb">for (var y = start; y &lt;= end; ++y) {</span><span id="961d" class="mx lp iq mt b gy oj mz l na nb">  // if not adjacent to another path, <br/>  // set position, approve, and break out of loop<br/>}</span></pre><h2 id="2b37" class="mx lp iq bd lq ny nz dn lu oa ob dp ly ko oc od mc ks oe of mg kw og oh mk oi bi translated">检查上下相邻的路径</h2><p id="e90e" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">方法以同样的方式检查我们路径上面和下面的路径。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="a1fa" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试您的工作</h1><p id="00dc" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在这一点上，你调好的路径放置算法应该是工作的，所以这是一个伟大的时间来尝试它。下面是一个代码笔供你比较你的作品，当然，你也可以查看<code class="fe nc nd ne mt b">phase-4-corners</code>和<code class="fe nc nd ne mt b">solutions</code>版本进行比较。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="om ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The new version that uses the path placement algorithm.</figcaption></figure><p id="8e0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你和我们一起更新了游戏，恭喜你！您已经完成了教程。如果你有兴趣更进一步，试试下一个关于如何连接对角房间的方法。</p><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-roguelikes-connecting-diagonal-dungeon-rooms-using-corners-79f460f96615"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">用JavaScript的Roguelike构建带角的段落</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">让我们用两条在拐角处相交的小路把对角交叉的房间连接起来。</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe jw oq"/></div></div></a></div><p id="9e8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论您是否阅读过这篇文章或者和我们一起编写过代码，我希望这篇文章能够增强您对如何调整过程化生成算法来改进游戏的理解。日安！</p><p id="f812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mr">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mr">plain English . io</em></strong></a><em class="mr">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mr">免费周报</em> </strong> </a> <em class="mr">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mr">Twitter</em></strong></a><em class="mr">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mr">LinkedIn</em></strong></a><em class="mr">。加入我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mr">社区不和谐</em> </strong> </a> <em class="mr">。</em></p><p id="14ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mr">最后，考虑注册</em><a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"><strong class="kf ir"><em class="mr">Medium</em></strong></a><em class="mr">无限制访问我以及其他作家的文章。</em></p></div></div>    
</body>
</html>