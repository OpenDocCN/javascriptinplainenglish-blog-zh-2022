<html>
<head>
<title>How Methods of Primitive Data Types Work in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中基本数据类型的方法是如何工作的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-methods-of-primitive-data-types-work-in-javascript-ac9e5f61ec69?source=collection_archive---------9-----------------------#2022-11-14">https://javascript.plainenglish.io/how-methods-of-primitive-data-types-work-in-javascript-ac9e5f61ec69?source=collection_archive---------9-----------------------#2022-11-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1ed5606fa90d78a678a3e694dd65b649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEsu1dR3NJUNlfm2FGWyEg.png"/></div></div></figure><p id="c3ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript允许我们使用原语。在本文中，我们将试图理解方法是如何出现在原始值上的。</p><p id="651e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有7种原语类型<strong class="jx io"> null、undefined、number、string、boolean、symbol、bigInt </strong>。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="4625" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当对原始数据类型调用方法时会发生什么，例如:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="daab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所知，与对象不同，原语没有自己的<em class="kz">方法</em>，但是有包装原语类型的值并允许您对其执行各种转换的对象副本:</p><ul class=""><li id="de10" class="la lb in jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated"><code class="fe lj lk ll lm b">String</code>为<strong class="jx io">字符串</strong>原语。</li><li id="f047" class="la lb in jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><code class="fe lj lk ll lm b">Number</code>为<strong class="jx io">号</strong>原始人。</li><li id="d21c" class="la lb in jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><code class="fe lj lk ll lm b">BigInt</code>为<strong class="jx io"> bigInt </strong>原语。</li><li id="1845" class="la lb in jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><code class="fe lj lk ll lm b">Boolean</code>为<strong class="jx io">布尔</strong>原语。</li><li id="c39b" class="la lb in jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><code class="fe lj lk ll lm b">Symbol</code>为<strong class="jx io">符号</strong>原始人。</li></ul><p id="f889" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个构造函数都有自己的方法和将被继承的原型。</p><p id="7018" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们调用<code class="fe lj lk ll lm b">String.prototype</code>，我们将看到以下内容:</p><pre class="kt ku kv kw gt ls lm lt bn lu lv bi"><span id="ae0c" class="lw lx in lm b be ly lz l ma mb">String {<br/>  anchor: anchor()<br/>  at: at()<br/>  big: big()<br/>  blink: blink()<br/>  bold: bold()<br/>  charAt: charAt()<br/>  ...<br/>  toUpperCase: toUpperCase();<br/>  ...<br/>  length: 5<br/>  [[Prototype]]: Object<br/>}</span></pre><p id="8103" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是在<code class="fe lj lk ll lm b">name.toUpperCase()</code>中实际发生的事情:</p><ol class=""><li id="9da6" class="la lb in jx b jy jz kc kd kg lc kk ld ko le ks mc lg lh li bi translated">字符串<code class="fe lj lk ll lm b">name</code>是一个原语。因此在访问它的属性时，一个特殊的对象<code class="fe lj lk ll lm b">new String(name) </code>被创建，它知道字符串<code class="fe lj lk ll lm b"><a class="ae md" href="https://tc39.es/ecma262/#sec-getvalue" rel="noopener ugc nofollow" target="_blank">GetValue(V)</a></code>的值，并拥有来自原型的有用方法，如<code class="fe lj lk ll lm b">toUpperCase()</code>。</li><li id="7f2d" class="la lb in jx b jy ln kc lo kg lp kk lq ko lr ks mc lg lh li bi translated">该方法运行并返回一个新字符串。</li><li id="6d04" class="la lb in jx b jy ln kc lo kg lp kk lq ko lr ks mc lg lh li bi translated">特殊对象被销毁，只剩下原始对象。</li></ol><p id="d2e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，它可以写成这样的形式:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="1070" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两个条目将是等同的</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="c731" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是创建的字符串返回的<em class="kz">“object”</em>的<strong class="jx io"> typeof </strong>与我们预期的不太一样，所以最好不要用构造函数来创建原语。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="0e63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果打开Chrome开发者工具栏，或者你使用的任何调试工具，你会看到如下内容:</p><pre class="kt ku kv kw gt ls lm lt bn lu lv bi"><span id="3493" class="lw lx in lm b be ly lz l ma mb">String:<br/>  0: "R"<br/>  1: "o"<br/>  2: "m"<br/>  3: "a"<br/>  4: "n"<br/>  length: 5<br/>  [[Prototype]]: String<br/>  [[PrimitiveValue]]: "Roman"</span></pre><p id="e359" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，使用<strong class="jx io">字符串/数字/布尔</strong>函数而不使用<strong class="jx io">新的</strong>操作符是聪明且有用的。它们将值转换为原始类型:字符串、数字、布尔值。例如，以下是有效的:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="fdac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解开包装对象的一般方法是方法<code class="fe lj lk ll lm b">.valueOf()</code>:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="a87a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">特殊原语<code class="fe lj lk ll lm b">null</code>和<code class="fe lj lk ll lm b">undefined</code>是例外。它们没有相应的“包装对象”，也不提供任何方法。从某种意义上说，他们是“<em class="kz">最原始的</em>”。</p><p id="a695" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望对你有用！</p><p id="47f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读！回头见。😊</p><p id="5c69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kz">更多内容请看</em><a class="ae md" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kz">plain English . io</em></strong></a><em class="kz">。报名参加我们的</em> <a class="ae md" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kz">免费周报</em> </strong> </a> <em class="kz">。关注我们上</em><a class="ae md" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kz">Twitter</em></strong></a><strong class="jx io"/><a class="ae md" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kz">LinkedIn</em></strong></a><strong class="jx io"><em class="kz"/></strong><a class="ae md" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kz">YouTube</em></strong></a><strong class="jx io"><em class="kz"/></strong><em class="kz">和</em> <strong class="jx io"> <em class="kz"> </em> </strong> <a class="ae md" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank">对增长黑客感兴趣？检查出 </a><a class="ae md" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kz">电路</em> </strong> </a> <em class="kz">。</em></p></div></div>    
</body>
</html>