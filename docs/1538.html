<html>
<head>
<title>When Should You Use the useRef() Over useState() in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中，什么时候应该使用useRef()而不是useState()。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/when-should-you-use-the-useref-over-usestate-in-react-2eb515b9643b?source=collection_archive---------6-----------------------#2022-03-31">https://javascript.plainenglish.io/when-should-you-use-the-useref-over-usestate-in-react-2eb515b9643b?source=collection_archive---------6-----------------------#2022-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="69a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你知道吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fdae2b220148501b15531378eaec7665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7fMx7Dee8K3r-y3LGASuEw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image made by author</figcaption></figure><h2 id="bd4b" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用useRef()实际上可以做什么？让我们回顾一些使用useRef()钩子的案例和好方法！</h2><p id="7399" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">实际上<code class="fe mk ml mm mn b">useRef()</code>可能很有用，在我知道它能用来做什么之前，我对它持怀疑态度。</p><p id="6b39" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">让我们深入了解一下，<code class="fe mk ml mm mn b">useRef()</code>是一个React钩子，它接受1个参数作为初始值，并返回一个<code class="fe mk ml mm mn b">reference</code>，这是一个具有属性名为<code class="fe mk ml mm mn b">current.</code>的对象</p><p id="1d5f" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">例如:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="b673" class="kv kw iq mn b gy mx my l mz na">const ref = useRef(initialValue);<br/>ref.current = 10</span></pre><h1 id="f5d8" class="nb kw iq bd kx nc nd ne la nf ng nh ld jw ni jx lh jz nj ka ll kc nk kd lp nl bi translated">重新渲染</h1><p id="28f8" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated"><code class="fe mk ml mm mn b">useRef()</code>的酷之处在于它不会像<code class="fe mk ml mm mn b">useState()</code>那样触发任何重新渲染，所以如果你痴迷于性能，有一个很好的使用<code class="fe mk ml mm mn b">useRef()</code>而不是<code class="fe mk ml mm mn b">useState()</code>的例子，那就是……用它来输入。是的。</p><p id="5277" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">每次我们在输入中输入内容时，组件都会重新呈现，所以<em class="nm">如果</em>我们在使用带有<code class="fe mk ml mm mn b">useState()</code>的输入的组件树中处于较高的位置，那么这可能会导致重新呈现问题，因为每次我们在输入字段中输入内容时，组件都会更新，这将导致其下所有组件的一系列重新呈现。</p><p id="cf89" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">更好的方法是使用它来关注输入字段，而不是根据状态是真还是假来激活<code class="fe mk ml mm mn b">useState()</code>和不同的关注类，相反，我们可以像这样对输入使用<code class="fe mk ml mm mn b">useRef()</code>:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="aaab" class="kv kw iq mn b gy mx my l mz na">const inputRef = useRef()<br/>inputRef.current.focus()<br/>&lt;input ref={inputRef}/&gt;</span></pre><h1 id="9188" class="nb kw iq bd kx nc nd ne la nf ng nh ld jw ni jx lh jz nj ka ll kc nk kd lp nl bi translated">滚动到组件</h1><p id="4806" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated"><code class="fe mk ml mm mn b">useRef()</code>是向下滚动到某个组件的好方法，而不是使用<code class="fe mk ml mm mn b">useState()</code>和做一堆额外的逻辑。</p><p id="c261" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated"><strong class="lt ir">它是这样工作的:</strong></p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="8c37" class="kv kw iq mn b gy mx my l mz na">const componentSection3 = useRef(null);<br/>const scrollToComponent = () =&gt; componentSection3.current.scrollIntoView({<em class="nm">behavior</em>:<em class="nm"> </em>"smooth"});</span><span id="71fd" class="kv kw iq mn b gy nn my l mz na">return (<br/>&lt;&gt;<br/>&lt;Component1 /&gt;<br/>&lt;Component3 ref={componentSection}/&gt;<br/>&lt;Component4 /&gt;</span><span id="bfef" class="kv kw iq mn b gy nn my l mz na">&lt;/&gt;<br/>)</span></pre><h1 id="2191" class="nb kw iq bd kx nc nd ne la nf ng nh ld jw ni jx lh jz nj ka ll kc nk kd lp nl bi translated">拖延的</h1><p id="7d13" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们可以使用<code class="fe mk ml mm mn b">useRef()</code>来获得HTML元素的<strong class="lt ir">位置</strong>，并且我们可以操作它的位置。</p><p id="040b" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">例如，昨天我制作了一个自定义滑块，你可以不用鼠标滚动，也可以通过抓取项目来水平拖动。当你拖动的时候，我改变了它应该实时滚动的量，所以我得到了位置和<code class="fe mk ml mm mn b">ref.current.scrollLeft = newPosition</code></p><p id="6414" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">这是一个改变元素位置的超级简单的方法！</p><h1 id="130c" class="nb kw iq bd kx nc nd ne la nf ng nh ld jw ni jx lh jz nj ka ll kc nk kd lp nl bi translated">注意外面的咔哒声</h1><p id="d272" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们可以使用<code class="fe mk ml mm mn b">useRef()</code>来获取HTML元素，并将其与另一个HTML元素进行比较，然后决定它是否是您单击的正确HTML元素，并基于此执行一些操作。</p><p id="6140" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">我们当然可以用<code class="fe mk ml mm mn b">useState()</code>对它进行硬编码，添加一个HTML元素拥有的默认标签，并对其进行比较，但是只使用<code class="fe mk ml mm mn b">useRef()</code>这非常简单，只需将你的HTML元素存储在一个变量中，并与<code class="fe mk ml mm mn b">useRef.current</code>进行比较！</p><h1 id="27c0" class="nb kw iq bd kx nc nd ne la nf ng nh ld jw ni jx lh jz nj ka ll kc nk kd lp nl bi translated">你可能也会喜欢:</h1><div class="no np gp gr nq nr"><a href="https://betterprogramming.pub/callbacks-vs-promises-vs-async-await-a-step-by-step-guide-f93d13447604" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">回调vs .承诺vs .异步Await:逐步指南</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">引擎盖下也有点。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">better编程. pub</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/stop-learning-from-react-tutorials-that-suck-5e2031d9bdc7"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">停止从糟糕的React教程中学习</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">不受欢迎的观点</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="og l oc od oe oa of kp nr"/></div></div></a></div><p id="eb1c" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated"><em class="nm">你好，如果你想体验中等的自己，请考虑</em> <strong class="lt ir"> <em class="nm">支持</em> </strong> <em class="nm">我和其他所有的作家通过注册成为</em> <a class="ae oh" href="https://medium.com/@anton.franzen/membership" rel="noopener"> <strong class="lt ir"> <em class="nm">会员</em> </strong> </a> <em class="nm">每月5美元来保持独立写作的活力，</em> <a class="ae oh" href="https://medium.com/@anton.franzen/membership" rel="noopener"> <strong class="lt ir"> <em class="nm">在这里注册；)</em> </strong> </a></p><p id="37ee" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">除了支持他人，Medium还可以通过写作和在这里找到家的强大、积极参与的社区来支持你。</p><p id="96b7" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated"><em class="nm">更多内容请看</em><a class="ae oh" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lt ir"><em class="nm">plain English . io</em></strong></a><em class="nm">。报名参加我们的</em> <a class="ae oh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt ir"> <em class="nm">免费每周简讯</em> </strong> </a> <em class="nm">。关注我们</em><a class="ae oh" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lt ir"><em class="nm">Twitter</em></strong></a><em class="nm">和</em><a class="ae oh" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lt ir"><em class="nm">LinkedIn</em></strong></a><em class="nm">。加入我们的</em> <a class="ae oh" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lt ir"> <em class="nm">社区不和谐</em> </strong> </a> <em class="nm">。</em></p></div></div>    
</body>
</html>