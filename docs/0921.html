<html>
<head>
<title>4 Ways to Handle Async Operations in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中处理异步操作的4种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/4-ways-to-handle-async-operations-in-javascript-266ab51d8166?source=collection_archive---------15-----------------------#2022-02-21">https://javascript.plainenglish.io/4-ways-to-handle-async-operations-in-javascript-266ab51d8166?source=collection_archive---------15-----------------------#2022-02-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2ca3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">探索JavaScript中处理异步操作的不同方式。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9870d308823c7960d7a28f236f1a4136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHztMrOzRRlUev_rbW8naQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@insungyoon" rel="noopener ugc nofollow" target="_blank">insung yoon</a> on <a class="ae ks" href="https://unsplash.com/photos/w2JtIQQXoRU" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="68fe" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">介绍</h1><p id="21b6" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在同步编程中，一次可以运行一个任务，每一行代码都会阻塞下一行。另一方面，在异步编程中，读取文件或执行API调用等操作可以在后台启动，这大大提高了应用程序的性能。</p><p id="921a" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">然而，JavaScript是一种单线程编程语言，它本质上是异步和非阻塞的，可以在不阻塞主线程的情况下执行长时间的网络请求。</p><p id="6a34" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">但是我们如何处理JavaScript的异步特性呢？在这篇文章中，我们将探索四种方法。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="084e" class="kt ku in bd kv kw mt ky kz la mu lc ld jt mv ju lf jw mw jx lh jz mx ka lj lk bi translated">复试</h1><p id="12b3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在异步操作中，我们需要的是在异步操作完成时得到通知。回调是最简单的机制。它是一个传递给另一个函数的函数，在异步操作完成时被调用。</p><p id="7740" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">JavaScript是回调的理想环境，因为它有两个特性:</p><ul class=""><li id="593e" class="my mz in ln b lo mh lr mi lu na ly nb mc nc mg nd ne nf ng bi translated">在JavaScript中，函数是<strong class="ln io">一级对象</strong>，这意味着它们可以被赋给变量，作为参数传递，或者从另一个函数返回。</li><li id="2f88" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">JavaScript有<strong class="ln io">闭包</strong>，其中函数可以保留它的上下文和状态，不管它何时何地被调用。</li></ul><h2 id="1578" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">处理回访时的注意事项</h2><p id="71df" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">1.最糟糕的情况之一是函数在某些条件下同步运行，而在其他条件下异步运行。看一下这个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a27b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">如您所见，这个示例很难调试或预测其行为。因为回调可以用于同步或异步操作，所以你必须确保你的代码没有混合同步/异步行为。</p><p id="fcf6" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">2.在异步回调中抛出错误会使错误在事件循环中跳跃，从而使程序在非零退出代码中退出。因此，要以正确的方式传播异步回调中的错误，您应该将该错误传递给链中的下一个回调，而不是抛出或返回它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="745a" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">3.你可以尽可能遵循这些实践来组织你的回访。看前面的例子，将这些点匹配起来:</p><ul class=""><li id="8fca" class="my mz in ln b lo mh lr mi lu na ly nb mc nc mg nd ne nf ng bi translated">尽早从回调中返回。</li><li id="6b0d" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">命名您的回调，而不是使用内联样式。</li><li id="e64c" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">模块化你的代码，尽可能使用可重用的组件。</li></ul><h2 id="d5d0" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">赞成的意见</h2><ul class=""><li id="72c7" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated">简单的方法。</li><li id="32d7" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">不需要运输工具。</li></ul><h2 id="40da" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">骗局</h2><ul class=""><li id="b418" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated">很容易陷入<strong class="ln io">回调地狱</strong>，其中代码水平增长而不是垂直增长，这使得它容易出错并且非常难以阅读和维护。</li><li id="cd24" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">嵌套回调会导致变量名的重叠。</li><li id="c87c" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">硬错误处理。您很容易忘记将错误传播到下一个回调，如果您忘记传播同步操作错误，将很容易使您的应用程序崩溃。</li><li id="aa74" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">您很容易陷入这样一种情况:您的代码在某些情况下可以同步运行，而在其他情况下可以异步运行。</li></ul></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="52bd" class="kt ku in bd kv kw mt ky kz la mu lc ld jt mv ju lf jw mw jx lh jz mx ka lj lk bi translated">承诺</h1><p id="2240" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><strong class="ln io">承诺</strong>作为ES6标准的一部分出现在JavaScript中。这代表着向提供一个替代<strong class="ln io">回调</strong>的好方法迈出了一大步。</p><p id="3b61" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">承诺是包含异步操作结果或错误的对象。如果承诺尚未完成(履行或拒绝)，则称其为待定，如果完成(履行或拒绝)，则称其为已解决。</p><p id="90d7" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">要接收异步操作的完成或拒绝，您必须使用承诺的<code class="fe od oe of og b">.then</code>方法，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d4da" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><code class="fe od oe of og b">onFulfilled</code>是一个回调，它将接收已完成的值，而<code class="fe od oe of og b">onRejected</code>是另一个回调，它将接收错误原因(如果有的话)。</p><h2 id="029a" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">处理承诺时需要注意的事项</h2><p id="bb41" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">1.<code class="fe od oe of og b">then</code>方法同步返回另一个承诺，这使我们能够链接许多承诺，并轻松地将许多异步操作聚合到许多级别。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6740" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">2.如果我们不定义<code class="fe od oe of og b">onFulfilled</code>或<code class="fe od oe of og b">onRejected</code>处理程序，履行值或拒绝原因将自动传播到下一级<code class="fe od oe of og b">then</code>承诺。这种行为使我们能够在整个承诺链中自动传播任何错误。<br/>此外，您可以在任何处理程序中使用与<strong class="ln io">回调</strong>相反的<code class="fe od oe of og b">throw</code>语句，这将使<strong class="ln io">承诺</strong>自动拒绝，这意味着抛出的异常将自动在整个承诺链中传播。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4083" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">3.<code class="fe od oe of og b">onFulfilled</code>和<code class="fe od oe of og b">onRejected</code>处理程序保证异步运行，即使在调用<code class="fe od oe of og b">then</code>时<strong class="ln io">承诺</strong>已经确定。这种行为可以保护我们免受混合同步/异步代码的不可预测行为的影响，正如我们所见，这种行为很容易陷入<strong class="ln io">回调</strong>中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="6add" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">赞成的意见</h2><ul class=""><li id="4d2e" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated"><strong class="ln io">承诺</strong>显著提高代码可读性和可维护性，减轻<strong class="ln io">回调地狱</strong>。</li><li id="153a" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">我们所看到的优雅的错误处理方式。</li><li id="0790" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">主流浏览器不需要transpilers。</li><li id="1f89" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">保护我们的代码免受不可预测的行为，比如<strong class="ln io">回调</strong>。</li></ul><h2 id="d731" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">骗局</h2><ul class=""><li id="7e31" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated">当在顺序操作中使用<strong class="ln io"> Promises </strong>时，你不得不使用许多<code class="fe od oe of og b">then</code> s，这意味着每个<code class="fe od oe of og b">then</code>都有许多函数，这对于日常编程来说可能太多了。</li></ul></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="28c0" class="kt ku in bd kv kw mt ky kz la mu lc ld jt mv ju lf jw mw jx lh jz mx ka lj lk bi translated">异步/等待</h1><p id="953a" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">随着时间的推移，JavaScript社区试图在不牺牲好处的情况下降低异步操作的复杂性。在处理异步操作时，<strong class="ln io"> Async/Await </strong>被认为是这种努力的顶峰，也是推荐的方法。它被添加到ES2017标准的JavaScript中。并且是<strong class="ln io">承诺</strong>和<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">生成器 </a>的超集。</p><p id="922f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><code class="fe od oe of og b">async</code>函数是一种特殊的函数，您可以使用<code class="fe od oe of og b">await</code>表达式来暂停异步操作的执行，直到它解决。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="fd51" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">处理承诺时需要注意的事项</h2><p id="2ec7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">1.<strong class="ln io"> async </strong>函数总是返回一个<strong class="ln io"> Promise </strong>而不管解析的值类型，这保护我们免受具有混合同步/异步行为的不可预测代码的影响。</p><p id="edef" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">2.与<strong class="ln io">承诺</strong>不同，使用<strong class="ln io"> async/await </strong>我们可以使用<code class="fe od oe of og b">try/catch</code>让它无缝地处理同步抛出和异步承诺拒绝。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0afa" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">不幸的是，我们不能同时等待多个异步操作。但是作为一个解决方案，我们可以使用<code class="fe od oe of og b">Promise.all()</code>静态方法来解决多个并发承诺。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="cff0" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">赞成的意见</h2><ul class=""><li id="fce0" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated">代码可读性和可维护性的显著提高。正如我们所见，编写一系列异步操作就像编写同步代码一样简单。不需要额外的嵌套。</li><li id="5ab0" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">优雅的错误处理方式。现在我们可以使用<code class="fe od oe of og b">try/catch</code>块无缝地处理同步抛出和异步拒绝。</li><li id="fcc0" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">避免具有混合同步/异步行为的不可预测的代码。</li></ul><h2 id="0953" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">骗局</h2><ul class=""><li id="9233" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated">事实上，在<strong class="ln io">异步</strong>函数中，你可能最终得到一个巨大的函数，它包含几个粘合在一起的函数。反过来，该功能执行许多可能与<a class="ae ks" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">单一责任原则</strong> </a>相冲突的任务。</li><li id="fc7e" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">与promise版本相比，<strong class="ln io"> async/await </strong>的transpiled版本非常庞大。看看下面的截图。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/d25445d0da42678b25fe121f17f4f25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BeQE19SJ3p3b2m9Q5jcQkw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The <strong class="bd oi">Promise</strong> version</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/bed2a66213da6c751a8cf4e1244efaea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQtFxfyGxRBix_l14cUdCA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The transpiled version of <strong class="bd oi">Async/Await</strong></figcaption></figure></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="3949" class="kt ku in bd kv kw mt ky kz la mu lc ld jt mv ju lf jw mw jx lh jz mx ka lj lk bi translated">ReactiveX</h1><p id="0f9c" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank"><strong class="ln io">react vex programming</strong></a>是一个范例，它将每一位数据都视为一个流，您可以对其进行监听并做出相应的反应。它通过应用以下实践对同步和异步流进行操作:</p><ul class=""><li id="f5d6" class="my mz in ln b lo mh lr mi lu na ly nb mc nc mg nd ne nf ng bi translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">观察器模式</strong> </a> : <strong class="ln io">可观察</strong>至少有一个<strong class="ln io">观察器</strong>会自动通知它任何状态变化，这种模型称为<strong class="ln io">推模型</strong>。</li><li id="b3f1" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Iterator_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">迭代器模式</strong> </a>:实际上，在JavaScript中，任何<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#iterators" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">迭代器</strong> </a>都必须支持<code class="fe od oe of og b">next()</code>方法，而<strong class="ln io"> Observers </strong> API支持这种方法来获取下一个数据流，这种模型被称为<strong class="ln io"> Pull模型</strong>。</li><li id="ed0b" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">函数式编程</strong></a>:<strong class="ln io">react vex</strong>库包括<strong class="ln io">运算符</strong>，这些运算符只不过是<a class="ae ks" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">纯函数</strong> </a>，它们接受输入/观察值，并返回仅依赖于这些输入的新观察值，因此它们是可链接的或可管道化的。</li></ul><p id="c3c8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io"> Observable </strong>是一个对象，它获取一个数据流，并随着时间的推移发出事件以做出相应的反应。有一个将它加入ECMAScript标准的谈话，它的提议是<a class="ae ks" href="https://github.com/tc39/proposal-observable" rel="noopener ugc nofollow" target="_blank">这里</a>。到目前为止，它还不是ECMAScript标准的一部分，所以要使用它，你必须使用第三方库，JavaScript中众所周知的<strong class="ln io">反应扩展</strong>是<a class="ae ks" href="https://github.com/ReactiveX/rxjs" rel="noopener ugc nofollow" target="_blank"> RxJs </a>。</p><p id="f595" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">看看下面的例子，我们创建了一个新的<strong class="ln io">可观察对象</strong>，并将其与之前的点进行匹配:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0abf" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们还可以像这样处理API调用操作:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="b61e" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">处理可观测量时的注意事项</h2><p id="d097" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">1- <strong class="ln io">可观察的</strong>是懒惰的，这意味着它不做任何事情，除非你订阅它。另一方面，<strong class="ln io"> Promise </strong>是热切的，这意味着一旦它被创建，它将解决或拒绝。</p><p id="23d9" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">2-您应该取消订阅任何已订阅的<strong class="ln io">可观察的</strong>，以避免任何内存泄漏。</p><p id="0d7f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">3-你可以用<code class="fe od oe of og b">fromPromise</code>函数从<strong class="ln io">承诺</strong>创建<strong class="ln io">可观察</strong>，用<code class="fe od oe of og b">bindCallback</code>或<code class="fe od oe of og b">bindNodeCallback</code>从based- <strong class="ln io">回调</strong> API创建<strong class="ln io">可观察</strong>。</p><p id="5f06" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">4- <strong class="ln io">可观测量</strong>可以是<strong class="ln io">单播</strong>或<strong class="ln io">多播</strong>。另一方面，<strong class="ln io">承诺</strong>总是<strong class="ln io">组播</strong>。要知道<strong class="ln io">单播</strong>和<strong class="ln io">多播</strong>的区别我先来解释一下<strong class="ln io">热可观测量</strong>和<strong class="ln io">冷可观测量</strong>的区别。<br/>如果流是在订阅期间创建的，则<strong class="ln io">可观察的</strong>是<strong class="ln io">冷的</strong>。这意味着每个观察者将获得一个唯一的通信信道，因此将获得其唯一的数据结果(<strong class="ln io">单播</strong>或者你可以调用“unique-cast”来记住)。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e981" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">另一方面，如果流是在订阅之外创建的，则可观察到的<strong class="ln io">是<strong class="ln io">热的</strong>。这意味着每个订阅的观察者将获得相同的数据结果(<strong class="ln io">组播</strong>)。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0d4f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因此<strong class="ln io">单播</strong>是一对一的通信过程，其中每个观察者将获得其唯一的通信信道，而<strong class="ln io">多播</strong>是一对多的通信过程，其中所有观察者将共享相同的数据。</p><p id="4516" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">承诺</strong>是多播的，因为每个解析器将与<strong class="ln io">热观测值</strong>共享相同的数据。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="3a56" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">赞成的意见</h2><ul class=""><li id="4326" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated">一个<strong class="ln io">可观察的</strong>可以随时间发出多个值，这使得它非常适合处理事件、WebSocket和重复的REST API调用。</li><li id="7535" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><strong class="ln io">被观测者</strong>与其<strong class="ln io">观测者</strong>之间的松耦合，其中<strong class="ln io">被观测者</strong>会将任何变化通知其<strong class="ln io">观测者</strong>，而没有直接的依赖关系。</li><li id="ebfd" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><strong class="ln io">可观察的</strong>可以是<strong class="ln io">单播</strong>或<strong class="ln io">多播</strong>也可以根据你的使用情况。</li><li id="fd87" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">极其强大的<strong class="ln io">算子</strong>来过滤、转换或合成<strong class="ln io">可观测量</strong>。</li><li id="6991" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><strong class="ln io">违背承诺的可观测量</strong>是可取消的。</li><li id="b829" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">重构<strong class="ln io">承诺基于</strong>或<strong class="ln io">回调基于</strong>的代码到<strong class="ln io">可观察对象</strong>很容易。</li></ul><h2 id="0053" class="nm ku in bd kv nn no dn kz np nq dp ld lu nr ns lf ly nt nu lh mc nv nw lj nx bi translated">骗局</h2><ul class=""><li id="bc4c" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated"><strong class="ln io">观察值</strong>有一个陡峭的学习曲线。</li><li id="7565" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">到目前为止，你必须添加一个第三方库才能使用它。</li><li id="f5ef" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated">很容易忘记取消订阅一个<strong class="ln io">可观察的</strong>，这会导致内存泄漏。</li></ul></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="4d81" class="kt ku in bd kv kw mt ky kz la mu lc ld jt mv ju lf jw mw jx lh jz mx ka lj lk bi translated">结论</h1><p id="56a7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">到目前为止，我们已经探索了四种处理异步操作的方法，它们都可以完成工作，但是您应该使用哪种方法呢？这个问题的答案完全取决于你，你必须完全理解每种方法的利弊。最终，你可以根据自己的情况决定更适合的。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="900a" class="kt ku in bd kv kw mt ky kz la mu lc ld jt mv ju lf jw mw jx lh jz mx ka lj lk bi translated">资源</h1><ul class=""><li id="4af8" class="my mz in ln b lo lp lr ls lu oa ly ob mc oc mg nd ne nf ng bi translated">Nodejs设计模式第三版书。</li><li id="9c17" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><a class="ae ks" href="https://benlesh.medium.com/async-await-it-s-good-and-bad-15cf121ade40" rel="noopener">异步/等待:有好有坏</a></li><li id="399a" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><a class="ae ks" href="https://auth0.com/blog/javascript-promises-vs-rxjs-observables" rel="noopener ugc nofollow" target="_blank"> JavaScript承诺与RxJS观察值</a></li><li id="d13a" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><a class="ae ks" href="https://www.twilio.com/blog/async-js-rxjs-observables-rest-api-nodejs" rel="noopener ugc nofollow" target="_blank">异步JavaScript:在Node.js中使用RxJS Observables和REST API</a></li><li id="559f" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><a class="ae ks" href="https://www.twilio.com/blog/asynchronous-javascript-reactivex-rxjs-observables-nodejs" rel="noopener ugc nofollow" target="_blank">异步JavaScript:介绍ReactiveX和RxJS观察器</a></li><li id="c07f" class="my mz in ln b lo nh lr ni lu nj ly nk mc nl mg nd ne nf ng bi translated"><a class="ae ks" href="https://benlesh.medium.com/hot-vs-cold-observables-f8094ed53339" rel="noopener">热与冷的可观测量</a></li></ul></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="be69" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">现在我们有了。我希望你已经发现这是有用的。感谢您的阅读。</p><p id="6c25" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io"> <em class="ok">原载于</em></strong><em class="ok"/><a class="ae ks" href="https://blog.mayallo.com/4-ways-to-handle-async-operations-in-javascript" rel="noopener ugc nofollow" target="_blank"><em class="ok">https://blog.mayallo.com</em></a><em class="ok">。</em></p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="570c" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="ok">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="ok">plain English . io</em></strong></a><em class="ok">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="ok">免费周报</em> </strong> </a> <em class="ok">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="ok">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="ok">LinkedIn</em></strong></a><em class="ok">，以及</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="ok">不和</em> </strong> </a> <em class="ok">。</em></p></div></div>    
</body>
</html>