<html>
<head>
<title>Build React Like Web Components in Plain JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像普通JavaScript中的Web组件一样构建React</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-react-like-web-components-in-plain-javascript-b9921dcf6df0?source=collection_archive---------5-----------------------#2022-07-20">https://javascript.plainenglish.io/build-react-like-web-components-in-plain-javascript-b9921dcf6df0?source=collection_archive---------5-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="12d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解JavaScript的一些高级特性，创建自己的组件框架。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9eb03d22cd1b846bb664641873f8bf94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AS8zgJZ-Fg9EoA-L5RGig.png"/></div></div></figure><p id="1597" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有许多库可用于创建web组件。然而，如果你想知道如何制作自己的组件框架。这篇文章将帮助你。</p><p id="ce30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，我正试图重新发明轮子。然而，学习一门语言的高级特性是有好处的。它将帮助你用那种语言有效地调试和工作。在本文中，我们将了解JavaScript的一些高级特性。</p><h2 id="a67c" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated"><strong class="ak">先决条件</strong></h2><ul class=""><li id="9a05" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated">很好地理解ES6语法，如类、异步等待、代理</li><li id="cd88" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">对Web组件、影子DOM有基本的了解</li></ul><h2 id="1cd2" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">1.初始设置</h2><p id="118d" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我们将使用ES6和下一代JavaScript语法。我们需要一个代码转换器来转换代码以支持浏览器。我们还合并了多个文件，如CSS、JS和HTML。一个好的捆扎机会非常有用。在这次演示中，我将使用带有巴别塔的包。你可以使用任何你想要的包。也可以从<a class="ae mz" href="https://github.com/deepakshrma/webcomponent-demo/tree/start" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">web-components-demo</strong></a>repo的<a class="ae mz" href="https://github.com/deepakshrma/webcomponent-demo/tree/start" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> start </strong> </a>分支下载代码，避免初始设置。</p><div class="kg kh ki kj gt ab cb"><figure class="na kk nb nc nd ne nf paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/1ec1f3939abff037885149c6ea0aa9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*SW0fk7kemXq6gt2mQ2C5gA.png"/></div></figure><figure class="na kk ng nc nd ne nf paragraph-image"><img src="../Images/daf7af59b1d6251c4d9b5f22161e44c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1540/format:webp/1*uACYmASD_yp7ph6kIcz7eg.png"/></figure></div><p id="290a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下载源代码后。尽管如此，您还是会看到文件。现在，您可以使用<code class="fe nh ni nj nk b">npm start</code>命令在<a class="ae mz" href="http://localhost:1234/" rel="noopener ugc nofollow" target="_blank"> http://localhost:1234/ </a>启动web服务器。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="ec13" class="ln lo iq nk b gy np nq l nr ns">// index.js</span><span id="54d0" class="ln lo iq nk b gy nt nq l nr ns">class App extends HTMLElement {<br/>  async connectedCallback() {<br/>    this.attachShadow({ mode: "open" });<br/>    const name = this.getAttribute("name") ?? "John Doe";<br/>    this.shadowRoot.innerHTML = `<br/>      &lt;style&gt;.title { text-align: center; } &lt;/style&gt;<br/>      &lt;h1 class="title"&gt;Welcome ${name}&lt;/h1&gt;<br/>    `;<br/>  }<br/>}</span><span id="73b9" class="ln lo iq nk b gy nt nq l nr ns">customElements.define("dv-app", App);</span></pre><p id="c43c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定文件<strong class="kt ir"> index.js </strong>包含单个Web组件<strong class="kt ir"> App </strong>。每当<strong class="kt ir">应用程序被</strong>附加到JavaScript时，<em class="nu"> connectedCallback </em>就会被触发。它会在<em class="nu"> shadowRoot </em> <strong class="kt ir">的<em class="nu"> innerHTML </em> <strong class="kt ir"> </strong>内编写HTML代码。</strong> <code class="fe nh ni nj nk b">this<strong class="kt ir">.</strong>getAttribute</code>在这里用来获取属性名的值。这些属性可以用作元素的道具。<code class="fe nh ni nj nk b">customElements.define</code>用于注册一个web组件。现在，在HTML中使用<code class="fe nh ni nj nk b">dv-app</code>就可以了。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="6328" class="ln lo iq nk b gy np nq l nr ns">//index.html</span><span id="4a97" class="ln lo iq nk b gy nt nq l nr ns">&lt;body&gt;<br/>  &lt;<strong class="nk ir">dv-app</strong> name="deepak"&gt;&lt;/dv-app&gt;<br/>  &lt;script type="module" src="index.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;</span></pre><h2 id="5d7f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">2.创建一个可重用的组件类</h2><p id="d721" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">如果你已经注意到在给定的<strong class="kt ir">应用</strong>组件中，多个可重用的行可以很容易地提取到一个单独的类中。让我们创建一个可重用的<strong class="kt ir">组件</strong>类。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="17bb" class="ln lo iq nk b gy np nq l nr ns">// index.js<br/>class Component extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    this.attachShadow({ mode: "open" });<br/>  }<br/>  async connectedCallback() {<br/>    // This will trigger<br/>    this.#render();<br/>  }<br/>  async #render() {<br/>    let view = await this.render();<br/>    this.shadowRoot.innerHTML = view;<br/>  }<br/>  async render() {<br/>    console.warn("Render method is not implemented");<br/>    return "";<br/>  }<br/>}</span></pre><p id="90c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以更新<strong class="kt ir"> App </strong>组件来使用<strong class="kt ir">组件</strong>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="ea5d" class="ln lo iq nk b gy np nq l nr ns">class App extends Component {<br/>  async render() {<br/>    const name = this.getAttribute("name") ?? "John Doe";<br/>    return `<br/>    &lt;style&gt;.title { text-align: center; } &lt;/style&gt;<br/>    &lt;h1 class="title"&gt;Welcome ${name}&lt;/h1&gt;<br/>  `;<br/>  }<br/>}</span></pre><p id="520b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在给定的代码中，我将<strong class="kt ir"> render </strong>和<strong class="kt ir"> connectedCallback </strong>定义为异步方法。稍后，这对于支持<strong class="kt ir">异步等待</strong>调用非常有用。</p><p id="c99e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">说明:</strong>在上面给出的代码中，组件一打开就写HTML。我们正在调用<strong class="kt ir"> render </strong>方法并将字符串附加到shadow DOM。如果您仍然在监视模式下运行服务器，您将看不到UI的任何变化。</p><h2 id="6a0f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated"><strong class="ak"> 3。向组件添加样式</strong></h2><p id="383d" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">Web组件应该是独立的。这意味着所有与组件相关的属性都应该写在组件本身中。这也包括CSS样式。<br/>我们将创建一个基于主题的组件。我们将使用CSS变量来实现这一点。<br/>让我们在<strong class="kt ir"> global.css: </strong>中添加几个变量</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="65af" class="ln lo iq nk b gy np nq l nr ns">/* global.css */</span><span id="5db7" class="ln lo iq nk b gy nt nq l nr ns">:root {<br/>  --dv-text-color: #333;<br/>  --dv-text-color-slate: #4e4e4e;<br/>}</span></pre><p id="6870" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了支持来自组件的样式，让我们修改组件类。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="5795" class="ln lo iq nk b gy np nq l nr ns">class Component extends HTMLElement {<br/>  <strong class="nk ir">static styles = undefined;</strong> // Define Optional, Just for reference<br/>  <br/>  //constructor() {<br/>  //...</span><span id="63f8" class="ln lo iq nk b gy nt nq l nr ns">async #render() {<br/>    let view = await this.render();<br/>    if (typeof this.constructor.styles !== "undefined") {<br/>      <strong class="nk ir">const style = [].concat(this.constructor.styles).join("\n");</strong><br/>      view = `<br/>        <strong class="nk ir">&lt;style&gt;${style}&lt;/style&gt;</strong><br/>        ${view}<br/>      `;<br/>    }<br/>    this.shadowRoot.innerHTML = view;<br/>  }<br/>  //...<br/>}</span></pre><p id="6861" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们来更新一下<strong class="kt ir"> App </strong>代码。这个<strong class="kt ir">渲染</strong>的方法会干净很多。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="4ab2" class="ln lo iq nk b gy np nq l nr ns">class App extends Component {<br/>  static styles = `<br/>  <strong class="nk ir">.title</strong> { <br/>    text-align: center; <br/>    color: var(--dv-text-color); <br/>  } <br/>  <strong class="nk ir">p </strong>{ <br/>    text-align: center;  <br/>    color: var(--dv-text-color-slate)<br/>  };<br/>  `;</span><span id="ca9f" class="ln lo iq nk b gy nt nq l nr ns">  async render() {<br/>    const name = this.getAttribute("name") ?? "John Doe";<br/>    return `<br/>    &lt;h1 <strong class="nk ir">class="title"</strong>&gt;Welcome ${name}&lt;/h1&gt;<br/>    <strong class="nk ir">&lt;p&gt;</strong>This is going to be awesome app<strong class="nk ir">&lt;/p&gt;</strong><br/>  `;<br/>  }<br/>}</span></pre><h2 id="683a" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">4.组件的道具</h2><p id="23ee" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">React提供了一种通过props将数据从<em class="nu">父组件传递到</em>子组件的好方法。在我们的组件中，我们将使用属性作为道具。虽然，不建议这么做。由于我们的应用程序不是很大，我们现在可以使用它。</p><p id="1a80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用属性作为道具有一个缺点。只有凝视可以作为HTML中的一个属性。所以我们需要自己对数据进行消毒和反序列化。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="4103" class="ln lo iq nk b gy np nq l nr ns">class Component extends HTMLElement {<br/>   // ...</span><span id="1b40" class="ln lo iq nk b gy nt nq l nr ns">  <strong class="nk ir">get props() {<br/>    let props = {};<br/>    for (let name of this.getAttributeNames()) {<br/>      props[name] = this.getAttribute(name);<br/>    }<br/>    return props;<br/>  }</strong></span><span id="b1bf" class="ln lo iq nk b gy nt nq l nr ns">  async connectedCallback() {<br/>    this.#render();<br/>  }<br/>  // ...<br/>}</span></pre><p id="b2a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在可以获得所有属性道具作为<strong class="kt ir"> getter属性</strong>。现在，每当render方法被触发时，它将重新执行props计算并返回属性值。我们可以考虑以后使用缓存来优化它。为了演示，我们需要创建一个子组件。让我们创建一个<strong class="kt ir">用户组件</strong>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="50ee" class="ln lo iq nk b gy np nq l nr ns">class UserComponent extends Component {<br/>  render() {<br/>    <strong class="nk ir">if (!this.props.user) return "";<br/>    const { name, age, address } = JSON.parse(this.props.user) ?? {};</strong><br/>    return `<br/>      &lt;div&gt;<br/>        &lt;p&gt;Name: ${name}&lt;/p&gt;<br/>        &lt;p&gt;Age: ${age}&lt;/p&gt;<br/>        &lt;p&gt;Address: ${address.street} ${address.pin}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    `;<br/>  }<br/>}<br/>customElements.define("dv-user", UserComponent);</span></pre><p id="9135" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们更新应用程序来使用它。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="f516" class="ln lo iq nk b gy np nq l nr ns">class App extends Component {<br/>  //..<br/>  <br/>  async render() {<br/>    const name = this.getAttribute("name") ?? "John Doe";<br/>    const user = {<br/>      name: "deepak",<br/>      age: 20,<br/>      address: {<br/>        street: "No Where",<br/>        pin: 2222,<br/>      },<br/>    };</span><span id="47e4" class="ln lo iq nk b gy nt nq l nr ns">return `<br/>    &lt;div&gt;<br/>      &lt;h1 class="title"&gt;Welcome ${name}&lt;/h1&gt;<br/>      &lt;p&gt;This is going to be awesome app&lt;/p&gt;<br/>      <strong class="nk ir">&lt;dv-user user='${JSON.stringify(user)}'&gt;&lt;/dv-user&gt;</strong><br/>    &lt;/div&gt;<br/>  `;<br/>  }<br/>}</span></pre><p id="ffc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nu">如果你注意到了，我们正在使用</em> <strong class="kt ir"> <em class="nu">单引号(')</em> </strong> <em class="nu">来编写HTML。这只是为了避免解析问题。这是因为</em><strong class="kt ir"><em class="nu">JSON . stringify</em></strong><em class="nu">使用</em> <strong class="kt ir"> <em class="nu">双引号(")</em> </strong> <em class="nu">对字符串值进行序列化。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/0f0604658f493455f2875af4fd3909c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1x0gWlitiukgt9kfqTwKmA.png"/></div></div></figure><h2 id="9174" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">5.添加用户交互</h2><p id="1406" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我们已经有了一个基本的工作组件结构。然而，仍然缺少一些东西。如果您想与组件交互，您将永远不知道render何时被调用。所以我们需要某种钩子。React提供了<strong class="kt ir"> componentDidMount </strong>钩子，你可以在那里编写你的事件监听器。我们需要在我们的<strong class="kt ir">基础组件</strong>中模仿这种行为。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="8837" class="ln lo iq nk b gy np nq l nr ns">class Component extends HTMLElement {<br/>  //..<br/>  <strong class="nk ir">async onMount() {}</strong></span><span id="5620" class="ln lo iq nk b gy nt nq l nr ns">  async connectedCallback() {<br/>    this.#render();<br/>  }<br/>  async #render() {<br/>    //..<br/>    this.shadowRoot.innerHTML = view;<br/>    // Run after render HTML<br/>    <strong class="nk ir">this.onMount();</strong><br/>  }<br/>  <br/>}</span><span id="cac8" class="ln lo iq nk b gy nt nq l nr ns">class App extends Component {<br/>  //..<br/>  <strong class="nk ir">async onMount() {<br/>    this.shadowRoot<br/>      .querySelector("#btn")<br/>      .addEventListener("click", <br/>        () =&gt; console.log("User has pressed btn")<br/>      );<br/>  }</strong><br/>  async render() {<br/>    const name = this.getAttribute("name") ?? "John Doe";<br/>    return `<br/>    &lt;div&gt;<br/>      &lt;h1 class="title"&gt;Welcome ${name}&lt;/h1&gt;<br/>      &lt;p&gt;This is going to be awesome app&lt;/p&gt;<br/>      <strong class="nk ir">&lt;button id="btn"&gt;Fetch User&lt;/button&gt;</strong><br/>      &lt;dv-user name='deepak' age='20' address='${JSON.stringify({<br/>        street: "No Where",<br/>        pin: 2222,<br/>      })}'&gt;&lt;/dv-user&gt;<br/>    &lt;/div&gt;<br/>  `;<br/>  }<br/>}</span></pre><p id="ec56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次渲染后都会触发<strong class="kt ir"> onMount </strong>钩子。这将确保你将总是在<strong class="kt ir">挂载</strong>钩子中得到附加的元素。<br/> <em class="nu">既然我们一次又一次地重写</em><strong class="kt ir"><em class="nu">innerHTML</em></strong><em class="nu">，那么在这种情况下我们就不需要</em><strong class="kt ir"><em class="nu">component will unmount</em></strong><em class="nu">了。</em></p><h2 id="47bf" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">6.本地状态更新。</h2><p id="c9b4" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在用户交互时，您可能希望从网络上获取一些数据，并再次重新呈现组件。React在每次状态更新时渲染。这可以通过使用React应用程序中的<strong class="kt ir">设置状态</strong>或<strong class="kt ir">使用状态</strong>钩子来实现。我们将使用JavaScript代理。我们将使用一个代理来创建一个可观察的<strong class="kt ir">状态</strong>对象。每当<strong class="kt ir">状态</strong>对象有更新时。它将在内部重新触发render方法。</p><p id="ab5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，更新<strong class="kt ir">组件</strong>，在其中创建一个<strong class="kt ir">代理状态</strong>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="57fe" class="ln lo iq nk b gy np nq l nr ns">class Component extends HTMLElement {<br/>  static styles = undefined;<br/>  // Private local state<br/>  <strong class="nk ir">#state = {};</strong></span><span id="eb88" class="ln lo iq nk b gy nt nq l nr ns">  constructor() {<br/>    super();<br/>    this.attachShadow({ mode: "open" });<br/>    <strong class="nk ir">this.#bindState();</strong><br/>  }<br/>  #bindState() {<br/>    const that = this;<br/>    const handler = {<br/>      get(target, prop) {<br/>        return target[prop];<br/>      },<br/>      set(target, prop, value) {<br/>        target[prop] = value;<br/>        that.#render({ ...target });<br/>        return target;<br/>      },<br/>    };<br/>    <strong class="nk ir">this.state = new Proxy(this.#state, handler);</strong><br/>  }</span><span id="5ae6" class="ln lo iq nk b gy nt nq l nr ns">//...  <br/>}</span></pre><p id="c797" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们稍微调整一下<strong class="kt ir">应用</strong>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="ed77" class="ln lo iq nk b gy np nq l nr ns">// Mock API<br/>const fetchUser = () =&gt; {<br/>  return new Promise((r) =&gt; {<br/>    setTimeout(<br/>      () =&gt;<br/>        r({<br/>          name: "deepak",<br/>          age: 20,<br/>          address: {<br/>            street: "No Where",<br/>            pin: 2222,<br/>          },<br/>        }),<br/>      2000<br/>    );<br/>  });<br/>};</span><span id="c6ad" class="ln lo iq nk b gy nt nq l nr ns">class App extends Component {<br/>  <br/>  async onMount() {<br/>    this.shadowRoot.querySelector("#btn").addEventListener("click", () =&gt; {<br/>      <strong class="nk ir">fetchUser().then((user) =&gt; {<br/>        this.state.user = user;<br/>      });</strong><br/>    });<br/>  }<br/>  async render() {<br/>    <strong class="nk ir">const user = this.state.user ? JSON.stringify(this.state.user) : "";</strong><br/>    return `<br/>    &lt;div&gt;<br/>      &lt;h1 class="title"&gt;Welcome&lt;/h1&gt;<br/>      &lt;p&gt;This is going to be awesome app&lt;/p&gt;<br/>      &lt;button id="btn"&gt;Fetch User&lt;/button&gt;<br/>      <strong class="nk ir">&lt;dv-user user='${user}'&gt;&lt;/dv-user&gt;</strong><br/>    &lt;/div&gt;<br/>  `;<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1fac73320c3c1acb09ee8886db4347e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*5wuE0Ayh6u3FJkym37Nx9Q.gif"/></div></figure><h2 id="74fd" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">结论</h2><p id="1a45" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我希望你从这篇文章中学到了很多。最好是先学习概念，然后在实际应用中应用。一旦你理解了这个概念，你就可以开始玩了。您可以定制和优化上述概念，以满足您的需求。然而，在你的框架中写点东西总是很有趣的。</p><p id="2c99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nu">注意，为了演示高级特性，比如获取和更新网络调用的状态，我创建了一个工作示例。完整的代码总是可以在我的GitHub repo</em><a class="ae mz" href="https://github.com/deepakshrma/webcomponent-demo" rel="noopener ugc nofollow" target="_blank"><em class="nu">web-component-demo/m</em>ain</a><em class="nu">中找到。<br/>你也可以在</em><a class="ae mz" href="https://codesandbox.io/s/react-like-web-components-2o43qw" rel="noopener ugc nofollow" target="_blank"><em class="nu">code sandbox</em></a><em class="nu">寻找运行代码。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="94e0" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">参考资料:</h2><ul class=""><li id="a790" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated"><strong class="kt ir"> ES6教程:</strong><a class="ae mz" href="https://www.javascripttutorial.net/es6/" rel="noopener ugc nofollow" target="_blank">https://www.javascripttutorial.net/es6/</a></li><li id="c3a0" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated"><strong class="kt ir">网页组件:</strong>T56】https://www.webcomponents.org/introduction</li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="b6a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nu">更多内容请看</em><a class="ae mz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">plain English . io</em></strong></a><em class="nu">。报名参加我们的</em> <a class="ae mz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">免费周报</em> </strong> </a> <em class="nu">。关注我们关于</em><a class="ae mz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">Twitter</em></strong></a><em class="nu">和</em><a class="ae mz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nu">LinkedIn</em></strong></a><em class="nu">。查看我们的</em> <a class="ae mz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">社区不和谐</em> </strong> </a> <em class="nu">加入我们的</em> <a class="ae mz" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nu">人才集体</em> </strong> </a> <em class="nu">。</em></p></div></div>    
</body>
</html>