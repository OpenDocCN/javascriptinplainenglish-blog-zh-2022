<html>
<head>
<title>Theming Components with React and Design Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和Design标记对组件进行主题化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/theming-components-with-react-and-bit-456fca5d537b?source=collection_archive---------6-----------------------#2022-06-01">https://javascript.plainenglish.io/theming-components-with-react-and-bit-456fca5d537b?source=collection_archive---------6-----------------------#2022-06-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ef01" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用可组合的主题、React上下文API和Bit构建可伸缩的前端</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/019b0da457939293bcd514da85220c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bAnkaLYP63HQWhCVo0D8g.jpeg"/></div></div></figure><p id="7e99" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">webdev的圣杯是一个<em class="lk">可伸缩的</em>前端——远离单一的设计模式，将组件的外观与底层逻辑和系统分离。这是工程和设计团队面临的一个组织问题。</p><p id="f62e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">创建一个可重用组件库<em class="lk">独自</em>不能解决它。</p><p id="7e64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要的是一个<em class="lk">设计系统</em>——一个统一的视觉语言，让我们不仅可以重用属性，还可以随意进行修饰性的修改，而不用担心组件的功能。主题的概念实现了我们想要的分离，解放了设计团队去解决更大的问题。</p><p id="06f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看如何利用React Context API来开发我们自己的组件主题化系统，该系统具有无限的可伸缩性和可组合性。我们将使用<a class="ae ll" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank">位</a>作为我们的代码示例——一个开源工具链，使构建、发现和共享组件变得轻而易举——但是即使您坚持使用vanilla React，通过遵循本文中解释的设计模式，您也将很快在您的应用程序中进行系统范围的UI更改！</p><h1 id="fc47" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">这在上下文中是有意义的</h1><p id="be03" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">让我们快速讨论一下为什么React v16.3中引入的上下文API能够完美地满足我们的组件主题化需求。</p><p id="af3f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，主题只是一种统一的设计语言，可以跨所有组件、站点、应用程序等使用。但是无论你考虑的是一个UI元素的组件，还是一个具体的应用程序，主题化都是一个<em class="lk">上下文相关的问题</em>。</p><p id="a867" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您曾经设计过的表单组件总是由HTML标签和输入组成，并且总是作为表单运行——但是您会希望它具有不同的布局、修饰、排版等。这取决于表单在哪里以及如何使用，即表单的<em class="lk">上下文</em>。</p><p id="c9c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你相信吗，这正是React上下文API的用途！上下文允许我们将可以被认为是“全局”的数据，容易地提供给所有组件——使用<em class="lk">或</em>来修改——不管它们的嵌套有多深。像首选语言、当前认证的用户，以及…你猜对了，主题！</p><h1 id="e278" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated"><strong class="ak">提供商模式</strong></h1><p id="a802" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">使用主题的概念将组件的UI从底层逻辑和数据中分离出来，我们可以以一种可伸缩的、设计一致的、高效的方式对UI进行大规模的修改。这个想法很简单:</p><ol class=""><li id="6775" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj mo mp mq mr bi translated">创建主题，即定义应用外观的样式集合。颜色、字体、边框、过渡等。</li><li id="0ef8" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">为主题数据创建一个<strong class="kq io">上下文</strong>。任何使用我们的<strong class="kq io">上下文</strong>的组件现在都可以访问我们的主题——在系统范围内应用或更改UI样式。</li><li id="60a1" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">为了保持可重用性和最小化渲染，我们只创建了一个高阶组件——一个<strong class="kq io">提供者</strong>——它将使用我们的<strong class="kq io">上下文</strong>(而不是到处导入<strong class="kq io">上下文</strong>)，用一个定制钩子(通常命名为<strong class="kq io"> useTheme </strong>)为所有组件提供上下文。</li><li id="7e77" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">将我们的<strong class="kq io"> provider </strong>组件导入到我们想要主题化的任何地方，并包装所有我们希望主题化的UI组件——按钮、表单、定制组件，你明白了。</li><li id="cce9" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">导入你的自定义<strong class="kq io"> useTheme </strong>钩子到任何你需要深度定制的组件中。</li></ol><p id="f5ec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">无论您是使用React，还是在Bit workspace中构建组件，这都是我们的基本设计模式。</p><p id="7c21" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">主题提供了一种将UI与功能分离的方法，React提供了一种将代码转化为组件的API，而Bit将组件转化为可重用、可组合的构建块。这是一个强大的技术组合。</p><h1 id="3774" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">使用Bit使主题化变得简单</h1><h2 id="a6f1" class="mx ln in bd lo my mz dn ls na nb dp lw kx nc nd ly lb ne nf ma lf ng nh mc ni bi translated">步骤1:创建一个主题(用设计符号)</h2><p id="66b9" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">为了解决这个问题——是的，你的主题可以简单地是一个巨大的CSS文件，为你的应用程序中每一个可能的UI组件定义样式，但是这是一个糟糕的做法。这种方法不仅会导致代码可读性/可维护性/可重用性的问题，而且还会在团队中的设计人员和开发人员之间产生摩擦。设计师使用Sketch、Adobe XD或Figma来可视化地设计UI/UX<em class="lk"/>，而开发者则使用样式表、JavaScript和/或TypeScript来构建，即<em class="lk">代码</em>。</p><p id="d31c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是<a class="ae ll" href="https://bit.cloud/blog/design-tokens-in-components-with-react-and-bit-l28qlxq6" rel="noopener ugc nofollow" target="_blank">设计标志</a>的用武之地！</p><p id="cf15" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">设计符号是开发者和设计者都能理解<em class="lk">和</em>所贡献的真理的单一来源。他们简化了协作以及构建、维护和扩展产品的工作——因为如果你需要在整个网站范围内改变颜色或字体，团队中的任何人只需要在一个地方编辑就可以了。不需要代码重构！</strong></p><p id="1513" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">听起来令人畏惧？一点也不！如果你曾经使用CSS中的<strong class="kq io"> :root </strong>伪选择器将你的应用程序的设计语言定义为一组中央变量，那么你已经在正确的轨道上了！定义一个主题的设计符号通常是从你的设计团队的软件中导出的，它们可以是代码、JSON、YAML——这没关系。使用设计令牌的目的是将外观从正在使用的框架中分离出来。</p><p id="ba6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你愿意，可以看看由Bit团队自己创建和维护的<a class="ae ll" href="https://bit.cloud/teambit/design/themes/base-theme" rel="noopener ugc nofollow" target="_blank"> BaseTheme </a>来获得一些灵感。它包含了默认主题的所有设计符号。通常情况下，您的代码如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="d864" class="mx ln in bd lo my mz dn ls na nb dp lw kx nc nd ly lb ne nf ma lf ng nh mc ni bi translated">步骤2:创建主题提供者</h2><p id="703c" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">为了保持代码的整洁和可维护性，我们只创建了一个称为<strong class="kq io">提供者</strong>的高阶组件(HOC ),它既可以使用也可以设置<strong class="kq io">上下文</strong>,可以在整个应用程序中访问和应用。然后你可以在任何你想要主题化的地方导入这个特设(我们称之为ThemeProvider)。</p><p id="5b90" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一个好的主题提供者应该能够做到以下几点:</p><ul class=""><li id="92bb" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj nl mp mq mr bi translated">理想情况下，从一组设计符号中生成一个基本主题；</li><li id="361a" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj nl mp mq mr bi translated">应用基本主题；</li><li id="d412" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj nl mp mq mr bi translated">提供一个API(通常带有道具)来覆盖基本主题。</li></ul><p id="52a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样，对于我们的例子，我们将只使用Bit的开源<a class="ae ll" href="https://bit.cloud/teambit/base-react/theme/theme-provider" rel="noopener ugc nofollow" target="_blank"> ThemeProvider </a>组件。它使用<strong class="kq io"> createTheme </strong>函数从我们的设计令牌中生成一个主题，返回:</p><ul class=""><li id="31f3" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj nl mp mq mr bi translated">一个自定义钩子(<strong class="kq io"> useTheme </strong>)作为<strong class="kq io">上下文的包装器，</strong>通过它您可以访问任何组件中的设计令牌值，以及</li><li id="0756" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj nl mp mq mr bi translated">我们刚刚谈到的HOC (ThemeProvider)。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="813a" class="mx ln in bd lo my mz dn ls na nb dp lw kx nc nd ly lb ne nf ma lf ng nh mc ni bi translated">步骤3:将主题应用到React组件</h2><p id="4f14" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">既然繁重的工作已经完成，我们就可以将我们希望主题化的组件打包到我们的高阶ThemeProvider组件中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a388" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的BaseTheme，连同它的一整套设计标记，现在将被应用到按钮上。</p><p id="7ae4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请记住，<strong class="kq io"> useTheme </strong>定制钩子让您可以访问设计令牌值，这意味着如果您愿意，您仍然可以按照粒度来设计每个组件！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="0cb0" class="mx ln in bd lo my mz dn ls na nb dp lw kx nc nd ly lb ne nf ma lf ng nh mc ni bi translated">奖金:如何覆盖一个主题</h2><p id="d8be" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">将你的第一个主题作为你的应用程序的基础主题是有意义的，但是即使是一个非常基本的主题设置，你也需要至少两个——一个深色主题和一个浅色主题，你可以在它们之间切换。无论如何，不管你的用例需要多少，这个过程都很简单。要覆盖一个主题，我们首先需要创建另一个主题。</p><p id="aed7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里，我们可以遵循前面提到的相同步骤——只是不是创建另一个BaseTheme，而是使用相同的设计令牌集创建它的变体。</p><p id="0695" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，如果我们的基本主题有一个<code class="fe nm nn no np b">{backgroundColor: #FFFFFF}</code>属性，我们的新主题可能有<code class="fe nm nn no np b">{backgroundColor: #FF0000}</code>。</p><p id="90c7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们可以使用ThemeProvider组件中的<strong class="kq io">覆盖</strong>属性，用新主题中的值替换<code class="fe nm nn no np b">backgroundColor</code> <strong class="kq io"> </strong>的基本主题值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="eae2" class="mx ln in bd lo my mz dn ls na nb dp lw kx nc nd ly lb ne nf ma lf ng nh mc ni bi translated">这种方法的好处</h2><p id="7e61" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">让我们回顾一下。现在我们已经结合了React和Bit，我们有了一个可组合的主题化方法，它促进了一致性，可无限扩展，遵循了最佳实践，避免了React反模式，如prop-drilling和全局变量创建，给了我们对系统的信心，并节省了时间、金钱和资源。</p><h1 id="f6a2" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">结论</h1><p id="491c" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">希望您现在能更好地理解如何使用设计令牌原理进行主题化是一种可伸缩的方式来实现组件的外观和功能之间难以捉摸的关注点分离，以及提供者设计模式如何利用React的上下文API为我们提供一种优雅的方式来在组件中进行主题化。</p><p id="a2f0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，最令人印象深刻的还是Bit本身。像乐高积木一样“插入”主题的能力使得设计变得非常直观，组件驱动的开发也变得非常容易。</p></div></div>    
</body>
</html>