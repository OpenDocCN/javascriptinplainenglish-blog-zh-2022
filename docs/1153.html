<html>
<head>
<title>TypeScript Structural Typing In-Depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript结构类型深入</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-the-typescript-structural-typing-8fc6a001c260?source=collection_archive---------8-----------------------#2022-03-06">https://javascript.plainenglish.io/understanding-the-typescript-structural-typing-8fc6a001c260?source=collection_archive---------8-----------------------#2022-03-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e499" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过示例理解TypeScript中的结构类型。</h2></div><p id="9eb2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">众所周知，JavaScript有一个“<a class="ae ky" href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank"> duck typing </a>”系统，而TypeScript遵循了一种被称为“<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" rel="noopener ugc nofollow" target="_blank">结构类型</a>的东西。函数所期望的任何对象都将被它所拥有的属性所接受，而不是被它的实际值所接受。让我们通过例子来理解这一点。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/1d22ec0c6231e31b86aa9bc7b2544d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Bqc_HGiCM7cI8XT0dSmrA.png"/></div></div></figure><p id="b0fb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个例子展示了我们如何拥有两个不同的接口，它们之间没有声明的关系，以及一个接收其中一个接口的方法。正如我们所看到的，如果我们调用方法“stringifyAge”传递一个用另一种类型声明的变量(在本例中是“ICar”接口)，就没有问题。</p><p id="0b70" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">唯一重要的是接收到的参数具有所需的属性(“age:number”)。在我们的例子中，它可能会导致我们失败，也许一个模型的“年龄”是以年为单位，而另一个是以月或模型的年龄为单位。</p><p id="2532" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的，但是，这是一个接口，对于一个类也是一样的吗？让我们看看。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ll"><img src="../Images/64508266a20fef63d7c2da287e92547f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_p1-4AsywJkQcpRET58dQw.png"/></div></div></figure><p id="50d9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，它工作得很好，我们不需要创建Person的实例。传递一个属性相同的对象就够了。不需要传递规则“value instanceof Person”。</p><p id="52fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们来看看当我们在发展的时候它是如何对我们有益的。结构类型将帮助我们在测试代码中模拟依赖关系。让我们看一个例子。</p><p id="d876" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有类似于:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lm"><img src="../Images/0ac3b53e5e9879156bb2db57bf3e6fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kijtHd70ZynYAg_vDza_tw.png"/></div></div></figure><p id="427a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以创建一个使用“模拟”实例的测试(对于更专业的模拟，我们应该选择<a class="ae ky" href="https://jestjs.io/es-ES/docs/mock-functions" rel="noopener ugc nofollow" target="_blank"> Jest </a>，<a class="ae ky" href="https://sinonjs.org/releases/latest/mocks/" rel="noopener ugc nofollow" target="_blank"> Sinon </a>等)。).</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ln"><img src="../Images/1a9d20f187382f36fa9a30c5d3ff1da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9016HCejUoxFuisOY_-8Fw.png"/></div></div></figure><p id="4334" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更好的选择是使用一些可靠的原则(<a class="ae ky" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank"> Liskov替换</a>或<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>)。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lo"><img src="../Images/ef256e6d98cf328869e99835d0e40106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQglqaqolkJvbIVzBFNMyg.png"/></div></div></figure><p id="786b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们看到由于结构类型化，在Typescript中模仿对象是多么容易。</p><p id="840d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从这里我们可以得出三个主要观点:</p><ul class=""><li id="1567" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">可赋给接口的值可能具有类型声明中明确列出的属性之外的属性。类型不是“密封的”请注意，类也遵循结构化类型规则。</li><li id="a9e0" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">运行时，您拥有的实例可能不是您期望的类。</li><li id="d1d7" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">便于单元测试的结构类型。</li></ul><p id="ea99" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这有助于更好地理解JavaScript和TypeScript中的打字工作方式。</p><p id="e0d6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="md">更多内容请看</em><a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="md">plain English . io</em></strong></a><em class="md">。报名参加我们的</em> <a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="md">免费周报</em> </strong> </a> <em class="md">。关注我们关于</em><a class="ae ky" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="md">Twitter</em></strong></a><em class="md">和</em><a class="ae ky" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="md">LinkedIn</em></strong></a><em class="md">。加入我们的</em> <a class="ae ky" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="md">社区不和谐</em> </strong> </a> <em class="md">。</em></p></div></div>    
</body>
</html>