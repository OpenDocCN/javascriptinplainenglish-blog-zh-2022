<html>
<head>
<title>Learn React Pagination with SWR and Styled Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习用SWR和样式组件反应分页</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-paginated-list-in-react-with-swr-and-styled-components-453b50b32a3b?source=collection_archive---------11-----------------------#2022-03-10">https://javascript.plainenglish.io/build-a-paginated-list-in-react-with-swr-and-styled-components-453b50b32a3b?source=collection_archive---------11-----------------------#2022-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/24476c72c34d688628b21fe8dac72e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SYqwgfuC2wPe8-ZsakVGFQ.png"/></div></div></figure><p id="51da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在之前的一篇博客文章中，我们学习了如何构建带有分页的API。在这篇博文中，我们将重点讨论如何通过使用React(目前最流行的JavaScript前端框架)构建分页列表来使用这样的API。</p><h1 id="8a93" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">项目设置</h1><p id="2466" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了生成项目，我们使用了流行的工具链<strong class="ka ir"> Create React App : </strong></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7567" class="mi kx iq me b gy mj mk l ml mm">npx create-react-app build-paginated-list-in-react</span></pre><p id="9399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建项目后，我们使用npm安装所需的依赖项:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0127" class="mi kx iq me b gy mj mk l ml mm">npm i swr axios styled-components</span></pre><p id="cf8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Axios是一个流行的HTTP客户端，我们用它来消费API和获取分页数据。它是大多数浏览器默认提供的获取API的替代品<a class="ae mn" href="http://browsers.It" rel="noopener ugc nofollow" target="_blank">。</a>它易于使用，并提供开箱即用的有用特性，如自动JSON转换或HTTP拦截器。</p><p id="39ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Next.js背后的公司Vercel创建了SWR，这是一个数据获取库。它提供了一个定制的React钩子，具有许多功能和内置优化，并在https://swr.vercel.app/的<a class="ae mn" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank">之上有很好的记录。</a></p><p id="225f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Styled Components是最常用的CSS-in-JS样式库。CSS-in-JS是一种样式技术，其中样式是用JavaScript编写的，然后被解析以生成CSS。如果您不喜欢CSS-in-JS，那么React中还有许多其他方式来样式化组件，比如像Tailwind这样的实用程序库、CSS模块，甚至是普通的CSS。</p><p id="17fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于这个博客的目的，我们使用mockAPI作为后端层<a class="ae mn" href="https://mockapi.io/docs" rel="noopener ugc nofollow" target="_blank">https://mockapi.io/docs</a>。</p><p id="c174" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过声明单个实体并使用默认设置来简化事情:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/ff56355d9960fcc324b26cd955f28412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5afj0avaa0jCyIglhN_xBw.png"/></div></div></figure><p id="f3e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唯一的修改是为根端点定义响应的JSON模板:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/72822a27ab238d134367d61250859504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7APcKGjm_EkjRRjYU7wWug.png"/></div></div></figure><p id="090a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们添加了在构建分页机制时有用的元素总数。</p><h1 id="a282" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">建造基地</h1><p id="b99e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们从构建应用程序的基本元素开始。</p><p id="4361" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步是声明应用程序中使用的全局样式:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2f35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了字体，这个文件的目的是声明应用程序中使用的颜色。为此，我们使用CSS自定义属性，这样，如果一种颜色需要稍微调整，它将应用于任何地方，而不需要在使用它的每个地方修改颜色。</p><p id="2b87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还编辑默认的App.js组件:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8027" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们保持布局简单，只有一个包含标题和PaginatedList组件的基本标题。</p><p id="32e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，我们利用样式组件直接在组件中声明我们的样式。通过这种方式，我们将样式保持在接近它们被使用的地方，这使得JSX清晰简洁。</p><h1 id="291b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">构建组件</h1><p id="dbd1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们现在可以使用自顶向下的方法来构建组件，根据需要实现组件。</p><p id="af91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先创建主要组件，即PaginatedList组件:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4903" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用useState钩子跟踪分页和排序的状态。状态和它们的setter函数通过props传递给需要它们的组件，但是如果我们希望我们的应用程序变得更加复杂，并且避免像props drilling这样的不良做法，我们可以使用上下文甚至全局状态管理库。</p><p id="fee6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用useSWR钩子从MockAPI获取数据。这个钩子接受一个键和一个fetcher函数，这个函数把这个键作为一个参数给出。在我们的例子中，关键只是从端点获取数据的完整URL，而fetcher函数只是简单地获取所提供的URL，这是使用Axios完成的…就是这样！</p><p id="ca95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">useSwr还返回一个error对象，仅当来自fetch的承诺被拒绝时才定义该对象。我们在这里不处理它，但是我们可以在定义错误时返回一个不同的组件。</p><p id="e11e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用像SWR这样的提取库是很棒的，因为除了提供非常简单的API之外，它还提供了方便的特性，可以提高性能和开箱即用的用户体验，比如自动重新验证、错误处理、缓存等等。你可以查看官方文件来了解更多信息<a class="ae mn" href="https://swr.vercel.app/docs/getting-started" rel="noopener ugc nofollow" target="_blank">https://swr.vercel.app/docs/getting-started</a>。</p><p id="934f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从MockAPI获取数据后，我们将每个获取的工厂映射到一个工厂组件:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ad45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对工厂的每个属性进行循环，在键旁边显示每个值。我们再次利用样式化组件和flexbox来对组件进行样式化。</p><p id="914b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能已经注意到，由于URL中的sortBy和order查询字符串参数，获取的数据被排序。在我们简单的演示应用程序中，作为排序依据的字段是硬编码的，但是我们可以创建一个组件让用户动态设置它。</p><p id="5467" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了控制列表的顺序，我们定义了一个SortButton组件:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b39f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">订单及其设置者的状态作为道具直接传递给组件。</p><p id="f763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次按下按钮时，顺序在降序和升序之间切换。然后，该组件重新呈现以更新图像，从而显示应用于列表的新顺序。</p><p id="7b82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们来看看分页组件，它控制着与分页相关的一切:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2fdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有必需的状态、设置和参数都作为props传递，与前面的组件类似。</p><p id="4ae3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建按钮来执行以下操作:</p><ul class=""><li id="3c7c" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">转到第一页</li><li id="6057" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">转到上一页</li><li id="d0e7" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">转到下一页</li><li id="0a0c" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">转到最后一页</li></ul><p id="6435" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们利用添加到由MockAPI返回的模板中的元素总数来知道何时到达最后一页。</p><p id="a031" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还利用样式化的组件属性为所有按钮提供一个基本样式，并根据按钮是否被禁用来改变颜色和光标。</p><h1 id="f747" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">把所有的放在一起</h1><p id="8f7d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在一切就绪，我们可以开始我们的项目了:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="bf63" class="mi kx iq me b gy mj mk l ml mm">npm run start</span></pre><p id="bb06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是最终的结果！</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/834da1277f4dd81769aaa594f919395e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kObrNfn2AR_AzCr4.png"/></div></div></figure><p id="d342" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个博客的项目可以在这里找到<a class="ae mn" href="https://github.com/Mozenn/pagination-in-react-with-useSwr" rel="noopener ugc nofollow" target="_blank">https://github.com/Mozenn/pagination-in-react-with-useSwr</a>。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="a2f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="no">最初发表于</em><a class="ae mn" href="https://gauthier-cassany.com/posts/build-paginated-list-react-swr" rel="noopener ugc nofollow" target="_blank">T5【https://gauthier-cassany.com】</a><em class="no">。</em></p><p id="f879" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="no">更多内容看</em> <a class="ae mn" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="no">说白了。报名参加我们的</em> <a class="ae mn" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="no">免费周报</em> </strong> </a> <em class="no">。关注我们关于</em><a class="ae mn" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="no">Twitter</em></strong></a><em class="no">和</em><a class="ae mn" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="no">LinkedIn</em></strong></a><em class="no">。加入我们的</em> <a class="ae mn" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="no">社区不和谐</em> </strong> </a> <em class="no">。</em></strong></a></p></div></div>    
</body>
</html>