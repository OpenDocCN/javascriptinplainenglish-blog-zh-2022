<html>
<head>
<title>How to Make All Rooms Reachable in a JavaScript Roguelike</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript Roguelike中实现所有房间的可达性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/making-all-rooms-reachable-in-a-javascript-roguelike-eb1265cadf99?source=collection_archive---------17-----------------------#2022-04-11">https://javascript.plainenglish.io/making-all-rooms-reachable-in-a-javascript-roguelike-eb1265cadf99?source=collection_archive---------17-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a476f86668a12d266c72bc9cfe889a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kjQxImUxwyKf1eJBrUY6g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by v<a class="ae kc" href="https://www.freepik.com/vectorpouch" rel="noopener ugc nofollow" target="_blank">ectorpouch</a> on freepik</figcaption></figure><p id="c3f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在流行的2D游戏类型roguelike中，地牢布局是由一种算法生成的。当我在自己的roguelike中编写生成房间的逻辑时，我遇到了一个问题，在我测试的一些自动创建的关卡中，玩家无法到达所有的房间。</p><p id="73e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题偶尔会出现在<a class="ae kc" href="https://nevkatz.medium.com/javascript-roguelikes-connecting-diagonal-dungeon-rooms-using-corners-79f460f96615?postPublishedType=repub" rel="noopener">建造拐角通道</a>教程的产品中，该教程解释了如何建造一个roguelike，其中房间通过一个直通道或两个在拐角处相交的通道连接。虽然完成的代码通常会导致所有房间都可以到达，但有一点点机会你会得到一个像下面这样的级别。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/fed16733d89976dfdc8f8bec924346c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOdejR2TMh8TPYYo-umgxA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">How is the player in blue supposed to reach the rooms on the left?</figcaption></figure><p id="80ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，穿蓝色衣服的玩家不能到达左边的三个房间。因为必须击败所有红色的敌人才能完成地下城，玩家将无法前进。</p><p id="9890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章描述了一种方法来解决这个问题，使玩家可以从任何房间开始进入所有房间。让我们看看如何添加额外的逻辑来检查无法到达的房间，并尝试将它们连接到地牢的主房间网络。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="b775" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">文件结构</h1><p id="9cb0" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">虽然本文涵盖了一个更大的游戏项目的第5阶段，但是每个阶段都有自己的起始代码目录——所以如果您愿意，您可以直接进入第5阶段，而无需任何前期工作。</p><p id="902f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要下载项目目录，可以去这个<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms" rel="noopener ugc nofollow" target="_blank"> Git repo </a>，点击<em class="mq"> Code </em>，点击<em class="mq"> Download ZIP。</em>或者，您可以从命令行克隆它:</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="248a" class="mw lo iq ms b gy mx my l mz na">git clone <a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nevkatz/js-roguelike-rooms.git</a></span></pre><p id="4f2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下载的repo中，有一个结构如下的<code class="fe nb nc nd ms b">phase-5-recursion</code>目录。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="ce81" class="mw lo iq ms b gy mx my l mz na">phase-5-recursion<br/>  |<br/>  *--index.html<br/>  |<br/>  *--css <br/>  |   |<br/>  |   *--style.css<br/>  |<br/>  *--js <br/>      |<br/>      *--<strong class="ms ir">script.js</strong><br/>      |<br/>      *--game.js<br/>      |<br/>      *--<strong class="ms ir">room.js</strong><br/>      |<br/>      *--path.js</span></pre><p id="e6f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个目录中，前面阶段的所有方法都已经完成，所以您可以专注于本文的任务。虽然以前的roguelike文章中的代码没有详细介绍，但是您可以在您正在工作的<code class="fe nb nc nd ms b">phase-5-recursion</code>目录中查看它。下面是我们关注的两个JavaScript文件:</p><ul class=""><li id="7058" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated"><code class="fe nb nc nd ms b">script.js</code>负责管理游戏</li><li id="07cb" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><code class="fe nb nc nd ms b">room.js</code>，其中包含了<code class="fe nb nc nd ms b">Room</code>类</li></ul><p id="bafb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以在<code class="fe nb nc nd ms b">solutions</code>目录中查看完成的代码。</p><p id="adb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在深入研究之前，让我们先看看现有代码最相关的方面，从<code class="fe nb nc nd ms b">Game</code>和<code class="fe nb nc nd ms b">Room</code>类开始。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="53aa" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">游戏课</h1><p id="d771" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在下面你会发现<code class="fe nb nc nd ms b">Game</code>类，它保存了地牢布局、房间记录以及对游戏的<code class="fe nb nc nd ms b">&lt;canvas&gt;</code>元素和其被称为<code class="fe nb nc nd ms b">context</code>的绘制方法的引用。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f74e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">地牢布局保存在<code class="fe nb nc nd ms b">map</code>属性中，作为瓷砖代码的2D数组。在下面的示例<code class="fe nb nc nd ms b">map</code>值中，一个4x4的房间位于6x6地图的中心。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="c1db" class="mw lo iq ms b gy mx my l mz na">[[0,0,0,0,0,0],<br/> [0,1,1,1,1,0],<br/> [0,1,1,1,1,0],<br/> [0,1,1,1,1,0],<br/> [0,1,1,1,1,0],<br/> [0,0,0,0,0,0]]</span></pre><p id="6f34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd ms b">rooms</code>数组存储游戏中的<code class="fe nb nc nd ms b">Room</code>对象。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="0b9b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">房间类</h1><p id="c41a" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated"><code class="fe nb nc nd ms b">Room</code>类是一个表示单个房间的对象，它包含许多与连接到其他房间相关的方法和属性。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The room class.</figcaption></figure><p id="d2e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个<code class="fe nb nc nd ms b">Room</code>对象都有一个名为<code class="fe nb nc nd ms b">neighbors</code>的属性，这是它通过路径连接到的其他<code class="fe nb nc nd ms b">Room</code>对象的数组。每个房间存放三个坐标为<code class="fe nb nc nd ms b">x</code>和<code class="fe nb nc nd ms b">y</code>的物体:</p><ul class=""><li id="2c65" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated"><code class="fe nb nc nd ms b">start</code>，代表左上角</li><li id="da06" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><code class="fe nb nc nd ms b">end</code>，代表右下角</li><li id="c094" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><code class="fe nb nc nd ms b">center</code>，在房间生成时用于计算<code class="fe nb nc nd ms b">start</code>和<code class="fe nb nc nd ms b">end</code></li></ul></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="ea89" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">到目前为止代码是如何工作的</h1><p id="7531" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在我们的<code class="fe nb nc nd ms b">script.js</code>文件中有一个名为<code class="fe nb nc nd ms b">generateMapRooms</code>的函数，它创建游戏关卡。它是这样工作的:</p><ul class=""><li id="8452" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated">它生成多个房间，将每个房间添加到<code class="fe nb nc nd ms b">Game</code>对象的<code class="fe nb nc nd ms b">map</code>和<code class="fe nb nc nd ms b">rooms</code>属性中。</li><li id="04ad" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">每个<code class="fe nb nc nd ms b">Room</code>对象试图连接到两个房间:一个房间直接穿过它和它最近的邻居。</li></ul><p id="de86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这种方法通常会产生一个单一的房间网络，但正如我们前面看到的那样，经常会出现两个或更多单独的房间网络。下面是另一个例子。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/a9a281b7da9163b02dfcf673583ec03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9odZnXvgqsLZIS_AMLa-g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Two networks of rooms in a roguelike.</figcaption></figure><p id="f24b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确保每个房间都可以被其他房间访问，我们将添加两种方法:</p><ul class=""><li id="85d3" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated">搜索给定房间可到达的房间的人；</li><li id="375f" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">另一个将其余房间连接到主网络。</li></ul></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="066c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">搜索可到达的房间</h1><p id="3b69" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在<code class="fe nb nc nd ms b">room.js</code>文件中，您现在可以向<code class="fe nb nc nd ms b">Room</code>类添加一个名为<code class="fe nb nc nd ms b">searchNeighbors</code>的方法。</p><ul class=""><li id="ef51" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated">当一个给定的<code class="fe nb nc nd ms b">Room</code>对象调用<code class="fe nb nc nd ms b">searchNeighbors</code>时，它让它的每个邻居调用它，那些邻居也这样做。</li><li id="7a9c" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">这将产生一个从原始房间可以到达的所有房间的列表。</li></ul><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="3f6b" class="mw lo iq bd lp nv nw dn lt nx ny dp lx ko nz oa mb ks ob oc mf kw od oe mj of bi translated">它是如何工作的</h2><p id="e5c3" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">当原来的<code class="fe nb nc nd ms b">Room</code>对象调用这个方法时，不会传入任何参数。下面是下一个方法<code class="fe nb nc nd ms b">connectRemaining</code>中发生的<code class="fe nb nc nd ms b">searchNeighbors</code>调用的预览。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="d970" class="mw lo iq ms b gy mx my l mz na">let connectedRooms = this.searchNeighbors();</span></pre><p id="aa4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为没有传入参数，<code class="fe nb nc nd ms b">reachable</code>由于缺省参数而作为空数组启动。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="f835" class="mw lo iq ms b gy mx my l mz na">Room.prototype.searchNeighbors = function(reachable=[]) {</span></pre><p id="cb73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的循环中，这个初始房间将把它所有的邻居推入<code class="fe nb nc nd ms b">reachable</code>数组。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="c9e7" class="mw lo iq ms b gy mx my l mz na">for (let neighbor of this.neighbors) {<br/><br/>      if (!reachable.includes(neighbor)) {<br/><br/>       <strong class="ms ir">  reachable.push(neighbor);</strong></span></pre><p id="c37d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它的每个邻居将调用<code class="fe nb nc nd ms b">searchNeighbors</code>并做同样的事情。对于那些刚刚习惯递归的人来说，这是使方法递归的原因——因为它调用自己。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="63a1" class="mw lo iq ms b gy mx my l mz na">for (let neighbor of this.neighbors) {</span><span id="0440" class="mw lo iq ms b gy og my l mz na">      if (!reachable.includes(neighbor)) {<br/><br/>         reachable.push(neighbor);</span><span id="d64d" class="mw lo iq ms b gy og my l mz na"><strong class="ms ir">         reachable = neighbor.searchNeighbors(reachable);</strong><br/>      } <br/> }</span></pre><p id="62a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe nb nc nd ms b">reachable</code>在每个方法调用结束时被返回，每个邻居收集的每个额外的房间将在由原始房间返回的<code class="fe nb nc nd ms b">reachable</code>数组中结束。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="ffea" class="mw lo iq ms b gy mx my l mz na">return reachable;</span></pre><p id="ced4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果，所有可到达的房间都在前面的<code class="fe nb nc nd ms b">connectedRooms</code>数组中结束。</p><p id="d3f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是等等！如果方法调用自身，为什么最终不会导致无限循环？注意这一行:</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="f3bd" class="mw lo iq ms b gy mx my l mz na">if (!reachable.includes(neighbor)) {</span></pre><p id="13db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为一个相邻的房间只在它还不在<code class="fe nb nc nd ms b">reachable</code>数组中的时候调用<code class="fe nb nc nd ms b">searchNeighbors</code>，所以一个已经在列表中的房间不会再调用这个方法。因此，当添加完所有可到达的房间后，方法调用结束。</p><p id="b3e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以找到所有可到达的房间，让我们写一个方法来识别那些不可到达的房间，并把它们带入网络。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="d44a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">连接其余房间</h1><p id="2fdc" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">下面是<code class="fe nb nc nd ms b">connectRemaining</code>方法，它使用<code class="fe nb nc nd ms b">searchNeighbors</code>获得可到达房间的列表，然后识别不在列表中的不可到达房间。然后，它会尝试将无法到达的房间连接到主网络。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The connectRemaining method.</figcaption></figure><p id="c141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来分析一下发生了什么。</p><p id="f494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法调用房间首先用<code class="fe nb nc nd ms b"><a class="ae kc" href="https://gist.github.com/nevkatz/3d29f95b2e58f3709621b28c4417cf88" rel="noopener ugc nofollow" target="_blank">findPotentialRooms</a></code>获得一个潜在房间的数组，这在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9">渲染房间</a>教程中有介绍。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="2ec2" class="mw lo iq ms b gy mx my l mz na">let rooms = this.findPotentialRooms();</span></pre><p id="50c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，它初始化一个<code class="fe nb nc nd ms b">connectedRooms</code>数组，将它设置为等于由<code class="fe nb nc nd ms b">searchNeighbors</code>返回的可到达房间列表。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="6839" class="mw lo iq ms b gy mx my l mz na">let connectedRooms = this.searchNeighbors();</span></pre><p id="96f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，<code class="fe nb nc nd ms b">connectRemaining</code>方法将从游戏的所有房间中过滤出可到达的房间，留下一个只有<code class="fe nb nc nd ms b">unreachable</code>房间的列表。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="7942" class="mw lo iq ms b gy mx my l mz na">let unreachable = rooms.filter(x =&gt; !connectedRooms.includes(x));</span></pre><p id="8f3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，它将遍历每个无法到达的房间，并尝试将每个房间连接到网络中的一个房间。房间调用<code class="fe nb nc nd ms b"><a class="ae kc" href="https://gist.github.com/nevkatz/69524b6c54f8e5291614a4072d8687d6" rel="noopener ugc nofollow" target="_blank">nearestNeighbor</a></code>方法，该方法在<a class="ae kc" href="http://which sorts the connectedRooms from closest to farthers" rel="noopener ugc nofollow" target="_blank">带拐角的建筑通道</a>文章中有所介绍，并传入<code class="fe nb nc nd ms b">connectedRooms</code>作为要使用的房间列表。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="2efa" class="mw lo iq ms b gy mx my l mz na">for (var room of unreachable) {</span><span id="1b5a" class="mw lo iq ms b gy og my l mz na">let success = room.nearestNeighbor(connectedRooms);<br/><br/>      if (success) { numConnected++; }<br/>}</span></pre><p id="8468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个房间在这里调用<code class="fe nb nc nd ms b"><a class="ae kc" href="https://gist.github.com/nevkatz/69524b6c54f8e5291614a4072d8687d6" rel="noopener ugc nofollow" target="_blank">nearestNeighbor</a></code>方法时，它将从最近到最远对<code class="fe nb nc nd ms b">connectedRooms</code>进行排序，并尝试首先连接到最近的房间。如果不起作用，它将尝试下一个最接近的房间，以此类推，直到它连接到一个房间或用尽列表中的所有房间。</p><p id="db10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回顾一下这里发生了什么:</p><ul class=""><li id="089b" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated">给定的房间将调用<code class="fe nb nc nd ms b">connectRemaining</code>，它使用<code class="fe nb nc nd ms b">searchNeighbors</code>来收集从方法调用房间可到达的房间列表。</li><li id="1475" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">然后通过从游戏的房间列表中过滤出可到达的房间来生成不可到达房间的列表。</li><li id="1af2" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">然后，每个不可到达的房间尝试连接到一个可到达的房间，从离它最近的房间开始。</li><li id="206d" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">最后，出于调试的目的，我希望返回一个对象，其中包含连接的房间数量以及最初无法到达的房间数量。</li></ul><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="3482" class="mw lo iq ms b gy mx my l mz na">return {numConnected, numDisc:unreachable.length};</span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="4dfa" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">完成的主要功能</h1><p id="1ae0" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在所有的方法都完成了，是时候完成<code class="fe nb nc nd ms b">script.js</code>中的游戏逻辑了。下面是集成了<code class="fe nb nc nd ms b">nearestNeighbor</code>和<code class="fe nb nc nd ms b">connectRemaining</code>逻辑的完整<code class="fe nb nc nd ms b">generateMapRooms</code>功能。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The completed generateMapRooms method.</figcaption></figure><p id="5079" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，在循环的底部，我们让每个房间调用<code class="fe nb nc nd ms b">connectRemaining</code>来确保每个房间都可以从其他房间到达。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="40db" class="mw lo iq ms b gy mx my l mz na">for (var myRoom of game.rooms) {</span><span id="577c" class="mw lo iq ms b gy og my l mz na">   myRoom.connectRemaining();</span><span id="ac95" class="mw lo iq ms b gy og my l mz na">}</span></pre><p id="e36a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有在极少数情况下才需要这种方法，因此，即使您打印日志语句来指示它何时连接到以前无法到达的房间，您也可能需要多次刷新浏览器才能看到它发生。</p><p id="944d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想有更好的机会看到它的运行，试着通过在<code class="fe nb nc nd ms b">generateMapRooms</code>中注释掉最初的<code class="fe nb nc nd ms b"><a class="ae kc" href="https://gist.github.com/nevkatz/69524b6c54f8e5291614a4072d8687d6" rel="noopener ugc nofollow" target="_blank">nearestNeighbor</a>()</code>调用来预先连接更少的房间。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="aefa" class="mw lo iq ms b gy mx my l mz na">for (var room of game.rooms) {</span><span id="6f79" class="mw lo iq ms b gy og my l mz na">   success = room.findFacingRooms(min);</span><span id="511f" class="mw lo iq ms b gy og my l mz na">  <strong class="ms ir"> // success = room.nearestNeighbor();</strong><br/>}</span></pre><p id="3477" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，您可以注释掉<code class="fe nb nc nd ms b"><a class="ae kc" href="https://gist.github.com/nevkatz/dec1067b6836240a38129d26b94ca917" rel="noopener ugc nofollow" target="_blank">findFacingRooms</a></code>方法。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="4f76" class="mw lo iq ms b gy mx my l mz na">for (var room of game.rooms) {</span><span id="6993" class="mw lo iq ms b gy og my l mz na"><strong class="ms ir">   // success = room.findFacingRooms(min);</strong></span><span id="ebbc" class="mw lo iq ms b gy og my l mz na">   success = room.nearestNeighbor();<br/>}</span></pre><p id="9799" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是一定要运行其中一个方法，免得你根本没有任何段落。</p><p id="d0cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦您注释掉了一个房间连接方法，您可以尝试在您的<code class="fe nb nc nd ms b">unreachable</code>循环中记录一些语句。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="56f2" class="mw lo iq ms b gy mx my l mz na">for (var room of unreachable) {</span><span id="b32b" class="mw lo iq ms b gy og my l mz na"><strong class="ms ir">      console.log(`${room.id} is disconnected`);</strong></span><span id="9c1d" class="mw lo iq ms b gy og my l mz na">      let success = room.nearestNeighbor(connectedRooms);<br/><br/>      if (success) {<br/><strong class="ms ir">         console.log(`${room.id} has been connected`);</strong><br/>         numConnected++;<br/>      }<br/>}</span></pre><p id="d474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到<code class="fe nb nc nd ms b">generateMapRooms</code>，您还可以捕获返回对象的属性，并记录每次调用<code class="fe nb nc nd ms b">connectRemaining</code>后连接了多少个房间。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="d4b1" class="mw lo iq ms b gy mx my l mz na">for (var myRoom of game.rooms) {</span><span id="abda" class="mw lo iq ms b gy og my l mz na">    let {numConnected, numDisc} = myRoom.connectRemaining();</span><span id="92dd" class="mw lo iq ms b gy og my l mz na">    console.log(`Room${myRoom.id} connected ${numConnected} out of ${numDisc} rooms`);</span><span id="bb2d" class="mw lo iq ms b gy og my l mz na">}</span></pre><p id="3e3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你！你已经完成了教程，现在应该有完整的游戏工作。请随意将您的工作与下面的CodePen或Netlify上的这个<a class="ae kc" href="https://stellular-biscuit-6757a3.netlify.app/solution/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>进行比较。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="oh nt l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The final game on CodePen.</figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="984a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">可能的后续步骤</h1><ul class=""><li id="2db5" class="ne nf iq kf b kg ml kk mm ko oi ks oj kw ok la nj nk nl nm bi translated">尝试添加滚动逻辑、滑动控制或加速度控制。</li><li id="300b" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">考虑将图像用于地板和墙砖。</li><li id="f3fa" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">尝试为玩家、武器、药剂和敌人使用精灵。</li><li id="d086" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">看看能不能加一个离玩家足够远的目标物品作为挑战。</li><li id="7f34" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">尝试调整房间生成算法，使房间总是靠得更近。</li></ul><p id="d3cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇用递归连接剩余房间的教程。日安！</p><p id="f36d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mq">考虑注册</em><a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"><strong class="kf ir"><em class="mq">Medium</em></strong></a><em class="mq">无限制访问我以及其他作者的文章。</em></p><p id="9322" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mq">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mq">plain English . io</em></strong></a><em class="mq">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mq">免费周报</em> </strong> </a> <em class="mq">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mq">Twitter</em></strong></a><em class="mq">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mq">LinkedIn</em></strong></a><em class="mq">。加入我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mq">社区不和谐</em> </strong> </a> <em class="mq">。</em></p></div></div>    
</body>
</html>