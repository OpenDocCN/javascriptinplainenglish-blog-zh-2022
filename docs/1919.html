<html>
<head>
<title>LeetCode: The Climbing Stairs Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode:爬楼梯问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/climbing-stairs-c6a833c23a9a?source=collection_archive---------6-----------------------#2022-04-29">https://javascript.plainenglish.io/climbing-stairs-c6a833c23a9a?source=collection_archive---------6-----------------------#2022-04-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a690" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">LeetCode #70，JavaScript</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c32b691b61e43a208ad87374e1d58a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIlVbMfT1Ew_Pt2I0otfHg.jpeg"/></div></div></figure><p id="56a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天我开始探索动态编程，解决LeetCode的<a class="ae ku" href="https://leetcode.com/problems/climbing-stairs/" rel="noopener ugc nofollow" target="_blank">爬楼梯</a>问题。</p><p id="639b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个概念很简单，我们会得到一个n级楼梯。我们可以一次走一两步，我们需要返回我们可以登上楼梯的独特方式的数量。</p><p id="2bc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，如果给我们一个只有两级台阶高的楼梯，我们可以用两种方式爬上去—</p><p id="81fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个步骤单独进行，或两个步骤同时进行。我们在这里的返回值是2。</p><p id="52dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谁知道有多少方法可以解决这个问题。我认为使用置换框架，或者甚至通过一些费力的嵌套迭代工作，这是可以解决的。</p><p id="6ec7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我的最终目标和Leetcode问题是一样的——理解我面前事物最简单、最基本的本质。在几次没有结果的尝试之后，我意识到从第0步开始，解决方案的数量有上升的趋势…</p><p id="e28c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1步= 1</p><p id="7413" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两步= 2</p><p id="f393" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3步= 3</p><p id="60cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4步= 5步</p><p id="0ee4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5步= 8步…</p><p id="07e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kv">惊喜！</em></strong><em class="kv">……这是一个斐波那契数列</em></p><p id="fb15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是说，每一步的解，就是前两步的解的数量。(步骤3有步骤1 +步骤2的解决方案数)</p><p id="cfac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们的子问题是1步和2步的解。从这里，我们可以得到此后任何一步的解的数目。</p><p id="e4c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，为什么不实现一个斐波纳契函数，并完成它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="ddd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">毕竟，这很简单，也实现了我们的目标。从技术上讲，这是可行的。然而，由于递归涉及的所有开销，您可能会从Leetcode得到一个超时。</p><p id="030e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，基本的迭代方法是有效的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="1e4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是这个问题的目的之一就是练习动态编程或者记忆。</p><p id="94a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我听到这些术语几乎可以互换，但在解决这个问题时，我真的想抓住它们的区别。</p><p id="6724" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">记忆化</strong></p><p id="c2e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记忆是一种技术，我们把以前的计算结果储存起来以备将来使用。</p><p id="6c00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，让我们改变上面的递归方法来做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="95e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，现在我们将在每次递归调用的返回中添加备忘录。</p><p id="8217" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值得一提的是，当用递归解决爬楼梯问题时，我是这样想的——我们实际上是从最高的一级开始下降。</p><p id="406a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第5行，当进行第一次climbStairs递归调用时，我们将继续打开新的执行上下文，直到我们从原始memo ([0，1])中返回一个值。然后，这些上下文将开始关闭并建立我们的备忘录。</p><p id="90cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从现在开始，我们可以通过访问这些先前存储的值来减少大量的递归函数调用。</p><p id="4698" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">动态编程</strong></p><p id="126a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，正如我所读到的，动态编程是当一个人使用制表或记忆迭代地解决一个递归问题。为了保持简洁，我不会深入探究其中的区别。可以说，记忆(如上面的例子所示)最终采用了自顶向下的方法，向下处理子问题。</p><p id="4460" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，制表是一种自下而上的方法，首先解决子问题，然后用它们来构建最终的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="15b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们从“最底层”开始，一路上缓存计算，减少工作负载，并逐步达到我们的目标。</p><p id="d47d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kv">速度试炼</em> </strong></p><p id="815f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哪一种更快——递归记忆还是使用制表的动态编程方法？</p><p id="737c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了回答这个问题，我设置了一些performance.now()调用来用特别大的参数来计时每个函数。我能传递给递归函数的最大值是~7000，而不超过最大调用堆栈，所以这是我的限制因素。</p><p id="b008" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这个输入大小，动态方法能够比递归(memoized)版本快5.6倍。</p><p id="007e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这足以让我相信，我需要投入更多的时间来让动态编程成为我技能集中的一项熟悉的技术。</p><p id="2560" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kv">更多内容见于</em><a class="ae ku" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kv"/></strong></a><em class="kv">。报名参加我们的</em> <a class="ae ku" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kv">免费周报</em> </strong> </a> <em class="kv">。</em> <a class="ae ku" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kv">推特</em> </strong> </a>和 <a class="ae ku" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kv">领英</em> </strong> </a> <em class="kv">上跟随我们。加入我们的</em> <a class="ae ku" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kv">社群不和</em> </strong> </a> <em class="kv">。</em></p></div></div>    
</body>
</html>