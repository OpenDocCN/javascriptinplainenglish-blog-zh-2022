<html>
<head>
<title>Data Structures and Algorithms: String Permutations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构和算法:字符串排列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-structures-and-algorithms-string-permutations-b283175bbfb3?source=collection_archive---------5-----------------------#2022-05-29">https://javascript.plainenglish.io/data-structures-and-algorithms-string-permutations-b283175bbfb3?source=collection_archive---------5-----------------------#2022-05-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b21660ade6174263c8bcf4184973e89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GA1hYgu2wOWAcYLU"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="478d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对面试进行编码可能会面临许多挑战。不管你喜不喜欢，数据结构和算法问题在软件开发的过程中仍然很常见。申请足够多的工作，你很可能会遇到这样的问题:</p><p id="7423" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">给定一个字符串，返回该字符串的所有唯一排列</em></p><p id="8fe4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">起初看起来很简单，但很快就会明白，在表面之下隐藏着一些复杂性。让我们看看这个问题是什么，它带来的挑战以及它是如何解决的。</p><p id="0eaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从理解问题的要求开始:字符串的所有唯一排列。排列是事物顺序的变化。关于这个问题，排列是一个包含所有相同字符但顺序不同的新字符串。例如，给定字符串“abc”，排列将是:</p><p id="bcbf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“abc”、“acb”、“bac”、“bca”、“cab”、“cba”</p><p id="f42e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">期望的结果是给定字符串的所有不同字母组合。让我们分解这个问题并解决它。</p><p id="3afb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查看“abc ”,对结果进行更仔细的检查显示，不同的组合是通过取一个字母，将其移动到前面，然后将其余字母的不同组合附加到上面来实现的。</p><p id="d4dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以" a "作为前导字母，其余两个字母" bc "将有两种可能的组合，" bc "和" cb "，从而产生" abc "和" acb "。</p><p id="bc75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">移至" b "作为前导字母，其余字母" ac "可重新排列为" ac "或" ca "，从而产生" bac "和" bca "。</p><p id="b31a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，前导字母" c "具有剩余的字母" ab "和" ba "，导致出现" cab "和" cba "。</p><p id="3d16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法可以分解为对给定字符串中的每个字母进行迭代，将其保存为前导字符，然后对剩余的字母进行迭代，得到它们的不同组合，并将这些组合附加到前导字符上。这需要大量的迭代。在for循环中编写for循环可能很难阅读，所以这是使用递归的好时机。递归是一个在满足中断条件之前调用自身的函数。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="ab47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lf lg lh li b">countdown</code>函数用一个每次调用都减1的参数调用自己。这一直持续到数字小于1，函数返回，递归结束。这是休息状态。</p><p id="2a1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到字符串排列问题，我们将迭代每一个字符串，取当前迭代值的字母(我们称之为<code class="fe lf lg lh li b">char</code>)，然后用递归得到剩余字母的所有组合，并将其附加到<code class="fe lf lg lh li b">char</code>。结果将被推入一个数组中。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="100f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们使用了递归，所以这个函数从一个中断条件开始。递归调用都使用剩余的字母作为参数来获得它们的各种组合。如果只提供了一个字母(<code class="fe lf lg lh li b">if(str.length &lt; 2)</code>)，那么只能有一个组合，因此递归被停止，返回单个字母。</p><p id="d052" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来我们有一个数组(<code class="fe lf lg lh li b">permutations</code>)来存储结果。</p><p id="ca23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在迭代给定的字符串，将位于<code class="fe lf lg lh li b">str[i]</code>的字母赋给变量<code class="fe lf lg lh li b">char</code>。既然我们知道了<code class="fe lf lg lh li b">char</code>的索引，那么<code class="fe lf lg lh li b">slice()</code>就可以用来得到剩余的字母，并把它们赋给<code class="fe lf lg lh li b">remainingChars</code>。剩余的字母将用作递归函数调用中的参数。</p><p id="e026" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再次使用“abc”，在调用<code class="fe lf lg lh li b">getPermutations("abc")</code>时，第一次迭代将产生<code class="fe lf lg lh li b">char = "a"</code>和<code class="fe lf lg lh li b">remainingChars = "bc"</code>。我们现在到达函数中的递归部分:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="9c87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">for…of语句迭代递归函数调用的每个返回值，它们被追加到<code class="fe lf lg lh li b">char</code>中，此时为“a”并被推送到<code class="fe lf lg lh li b">permutations</code>数组中。<code class="fe lf lg lh li b">remainingChars</code>中的字母当前是“bc ”,因此第一次递归调用等同于<code class="fe lf lg lh li b">getPermutations("bc")</code>,它将迭代这些字母，将它们分开，并再次递归调用函数，直到满足中断条件，剩下“bc”和“cb”被附加到“a”并被推送到<code class="fe lf lg lh li b">permutations</code>数组。</p><p id="a936" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对给定字符串中的每个字母重复这一过程，得到一个有六种排列的数组。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="501e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数是有效的，但是还需要考虑一些其他的东西。在“abc”的例子中，字符串中的每个字母都是不同的。如果字符串有重复字符会怎么样？</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="c645" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住问题状态，找出所有<strong class="kc io"> <em class="ky">唯一的</em> </strong>排列。让我们来解决这个问题。我们需要一种方法来检查<code class="fe lf lg lh li b">char</code>的当前值是否已经被使用。还有其他方法可以实现这一点，但我发现<code class="fe lf lg lh li b">indexOf()</code>方法在这里工作得很好，因为它检查给定值的第一个索引。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="83b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有一个条件来检查<code class="fe lf lg lh li b">char</code>的值之前是否已经被使用过。如果有，从<code class="fe lf lg lh li b">indexOf()</code>返回的索引将低于循环中的当前索引，我们使用<code class="fe lf lg lh li b">continue</code>跳到下一次迭代。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="e61f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很好，现在每个排列只出现一次，我们已经满足了问题的要求。这是全部功能的排列组合。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="5a30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题在编码面试中经常出现。仅仅因为这个原因而学习是有好处的，但是理解如何解决这个问题也有其他好处。例如，这是学习递归以及何时使用递归的好方法。它还有助于编码人员注意和处理边缘情况。研究它，理解它，把你学到的东西带到下一次面试或项目中去！</p><p id="4946" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容尽在</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">说白了. io </em> </strong> </a> <em class="ky">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">免费周报</em> </strong> </a> <em class="ky">。关注我们关于</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">推特</em> </strong> </a> <em class="ky">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">LinkedIn</em></strong></a><em class="ky">。查看我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">社区不和谐</em> </strong> </a> <em class="ky">加入我们的</em> <a class="ae jz" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">人才集体</em> </strong> </a> <em class="ky">。</em></p></div></div>    
</body>
</html>