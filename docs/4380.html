<html>
<head>
<title>Angular: Different ways and places you can provide Services and its impact on Singleton Status of Services- Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:您可以提供服务的不同方式和位置及其对服务的单体状态的影响——第二部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-different-ways-and-places-you-can-provide-services-and-its-impact-on-singleton-status-of-1e9330c60744?source=collection_archive---------3-----------------------#2022-11-27">https://javascript.plainenglish.io/angular-different-ways-and-places-you-can-provide-services-and-its-impact-on-singleton-status-of-1e9330c60744?source=collection_archive---------3-----------------------#2022-11-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8833" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个故事只关注在一个加载功能模块中提供服务。如果你有兴趣用AppModule探索同样的概念，你可以看看下面的故事。</p><div class="ki kj gp gr kk kl"><a href="https://ramya-bala221190.medium.com/angular-different-ways-and-places-you-can-provide-services-and-their-impact-on-the-singleton-81fc2fe538bf" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">Angular:你可以提供服务的不同方式和地点以及它们对单身者的影响…</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">缺省情况下，Angular中的服务是单例的。就这样结束了吗？不完全是。大多数时候，我们唯一的两个地方…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">ramya-bala221190.medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div><p id="0878" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经创建了一个简单的项目，演示了在急切加载的功能模块中提供服务的不同方式以及它将产生的影响。</p><p id="71cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我创建了一个名为<strong class="jm io"> EagerModule </strong>的特性模块。该模块有三个组件:<strong class="jm io"> ParentComponent、ChildComponent和SiblingComponent </strong>。</p><p id="74ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顾名思义，ChildComponent是ParentComponent的子级，SiblingComponent是ParentComponent的同级。</p><p id="d9b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们只有一项服务，<strong class="jm io">数据服务</strong>。</p><p id="dfe8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是<strong class="jm io"> AppModule @NgModule()定义</strong>。</p><pre class="lb lc ld le gt lf lg lh bn li lj bi"><span id="7973" class="lk ll in lg b be lm ln l lo lp">export const routes: Routes = [];<br/><br/>@NgModule({<br/>imports: [BrowserModule,FormsModule,EagerModule,RouterModule.forRoot(routes)],<br/>declarations: [AppComponent],<br/>bootstrap: [AppComponent],<br/>providers: [DataService],<br/>})<br/><br/>export class AppModule {}</span></pre><p id="6f3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经在AppModule的<strong class="jm io">【imports】</strong>中导入了<strong class="jm io"> EagerModule </strong>。这意味着该功能模块将被急切地加载。</p><p id="38a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经将<strong class="jm io">数据服务</strong>添加到NgModule的<strong class="jm io">【providers】</strong>中。提供服务不会创建服务的实例。只有当服务被注入到需要它的类的构造函数中时，才会创建实例。</p><p id="6a94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这意味着每当DataService被注入到应用程序中任何类的构造函数中时，DataService的同一个实例将对所有其他类可用。</strong></p><p id="9144" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种说法确实有例外。我们很快就会看到这一点。</p><p id="82a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">移动到<strong class="jm io"> EagerModule @NgModule()定义</strong>。</p><pre class="lb lc ld le gt lf lg lh bn li lj bi"><span id="d7ab" class="lk ll in lg b be lm ln l lo lp">export const routes: Routes = [<br/>{path: ‘’,component: ParentComponent},<br/>{path: ‘sibling’,component: SiblingComponent}<br/>];<br/><br/>@NgModule({<br/>imports: [CommonModule, RouterModule.forChild(routes)],<br/>declarations: [ParentComponent, ChildComponent, SiblingComponent],<br/>providers: [DataService],<br/>})<br/><br/>export class EagerModule {}</span></pre><p id="f2ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也通过[providers]在EagerModule中提供了数据服务。</p><p id="e2da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是数据服务的样子。我们已经创建了一个属性<strong class="jm io"> randomNum </strong>来保存一个随机数。<strong class="jm io"> fetchNumber() </strong>返回这个随机生成的数字。</p><pre class="lb lc ld le gt lf lg lh bn li lj bi"><span id="98c1" class="lk ll in lg b be lm ln l lo lp">@Injectable()<br/>export class DataService {<br/>constructor() {}<br/><br/>public randomNum: number = Math.floor(Math.random() * 100);<br/><br/>fetchNumber() {<br/>return this.randomNum;<br/>}<br/>}</span></pre><p id="4b55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果DataService 的<strong class="jm io">相同实例被注入到所有类中，那么所有类都必须接收到<strong class="jm io">相同的随机数</strong>。</strong></p><p id="614a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转到组件，所有组件类都是彼此的精确副本。</p><p id="0a90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我只展示一下<strong class="jm io"> AppComponent类</strong>。我们调用了DataService的<strong class="jm io"> fetchNumber() </strong>来获取生成的随机数。这个随机数将显示在模板中。</p><p id="3aa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其他组件类将遵循相同的模式。</p><pre class="lb lc ld le gt lf lg lh bn li lj bi"><span id="2cbe" class="lk ll in lg b be lm ln l lo lp">@Component({<br/>selector: ‘my-app’,<br/>templateUrl: ‘./app.component.html’,<br/>styleUrls: [ ‘./app.component.css’ ]<br/>})<br/><br/>export class AppComponent {<br/>constructor(private service: DataService) {}<br/>public randomNumber: number;<br/><br/>ngOnInit() {<br/>this.randomNumber = this.service.fetchNumber();<br/>}<br/>}</span></pre><p id="52df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就组件模板而言，</p><p id="eab5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">EagerModule的组件将被加载到AppComponent的<strong class="jm io"> &lt;路由器出口&gt; </strong>中。</p><p id="9180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ChildComponent通过引用承载在ParentComponent内部。</p><p id="6b3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是应用程序的外观。AppComponent、ParentComponent和ChildComponent <strong class="jm io">从DataService </strong>接收相同的随机数。</p><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lq"><img src="../Images/6b16052988572996b1301c40a202400b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxh35-WHgfKluMl1WX2YTw.png"/></div></div></figure><p id="1872" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击ParentComponent中的<strong class="jm io">“切换到同级”</strong>链接，将加载&lt;路由器出口&gt;中的<strong class="jm io"> SiblingComponent </strong>，如下图所示。SiblingComponent也和其他组件一样从DataService接收到了相同的随机数。</p><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lx"><img src="../Images/ee233dcf430fc1e1e37c93d003765767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ukumuo-YJBA7yTkyfEiGJw.png"/></div></div></figure><p id="0dba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击上面SiblingComponent中的<strong class="jm io"> "Switch to Parent" </strong>链接，将在&lt;路由器出口&gt;中再次加载ParentComponent和ChildComponent。</p><p id="dfa1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有些人会认为<strong class="jm io">通过[providers]在EagerModule中再次单独提供DataService应该会为EagerModule创建一个新的DataService实例。</strong></p><p id="5445" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么<strong class="jm io"> AppModule </strong>中的AppComponent和<strong class="jm io"> EagerModule </strong>中的Parent、Child和Sibling组件从DataService接收到相同的随机数？</p><ol class=""><li id="e444" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">当您将一个功能模块导入到AppModule的<strong class="jm io">【imports】</strong>中时，该功能模块将被急切地加载。</li><li id="5372" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">导入特性模块的另一个效果是，<strong class="jm io">特性模块的[providers]的所有内容都将与RootModuleInjector相关联。</strong></li><li id="63d8" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">这个<strong class="jm io"> RootModuleInjector，</strong>我们知道<strong class="jm io"> </strong>是和AppModule关联的。</li><li id="9946" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">这意味着AppModule和EagerModule使用相同的注射器。这也意味着由注入器生成的DataService的同一个实例将被AppModule和EagerModule使用。</li><li id="8961" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">如果将DataService注入到app component/parent component/child component/sibling component的构造函数中，那么使用的DataService实例将是相同的。因此，传递给这些组件的随机数的值也将是相同的。</li></ol><p id="d330" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我稍微调整一下ParentComponent，这样<strong class="jm io">也可以提供数据服务</strong>。</p><pre class="lb lc ld le gt lf lg lh bn li lj bi"><span id="3700" class="lk ll in lg b be lm ln l lo lp">@Component({<br/>selector: ‘app-parent’,<br/>templateUrl: ‘./parent.component.html’,<br/>styleUrls: [‘./parent.component.css’],<br/>providers:[DataService]<br/>})<br/><br/>export class ParentComponent implements OnInit {<br/>/*<br/>Nothing changes here. The code remains the same.<br/>*/<br/>}</span></pre><p id="bbf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该应用程序现在将如下所示。</p><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mm"><img src="../Images/ecd02c3e111f3981a33548c2d792c3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TaBCvzCLq_6j9MDr5vR2w.png"/></div></div></figure><p id="339f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击“切换到同级”加载SiblingComponent。</p><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mn"><img src="../Images/aca8fd8428615796692488f3336aac94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*miAqcM7DcJISmtLbzZHcyg.png"/></div></div></figure><p id="2f48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以观察到AppComponent和SiblingComponent中的<strong class="jm io">随机数是相同的</strong>。但是它与ParentComponent和ChildComponent中的数字不同。</p><ol class=""><li id="e427" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">当我将DataService注入到AppComponent的构造函数中时，DI系统将检查服务实例对于与AppComponent关联的注入器是否可用。</li></ol><p id="08eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于DataService不是在AppComponent级别提供的，并且由于AppComponent没有任何父级，DI系统将使用与<strong class="jm io"> AppModule </strong>相关联的<strong class="jm io"> RootModuleInjector </strong>来检查服务实例是否可用。</p><p id="e3db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在AppModule 的【providers】中提供了<strong class="jm io">数据服务。因此，DI系统可以使用<strong class="jm io"> RootModuleInjector </strong>找到服务实例。</strong></p><p id="6ed9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.当我将DataService注入到<strong class="jm io"> SiblingComponent </strong>的构造函数中时，DI系统将检查服务实例是否可以与SiblingComponent关联的注入器一起使用。</p><p id="5922" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要！<strong class="jm io">在SiblingComponent级别</strong>不提供数据服务。因此，DI系统向上移动一个级别，并且<strong class="jm io">检查与SiblingComponent(即AppComponent)的父组件相关联的注入器。</strong></p><p id="f785" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">在AppComponent级别没有提供data service</strong>，由于AppComponent没有任何父级，DI系统将在模块级别开始检查。</p><p id="201b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它首先<strong class="jm io">检查数据服务是否在EagerModule级别</strong>提供。<strong class="jm io">是的它提供了！</strong>但是我们已经知道EagerModule和AppModule共享同一个注入器，即RootModuleInjector。</p><p id="3a18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此注入器生成的实例将用于AppComponent和SiblingComponent。这解释了为什么AppComponent和SiblingComponent接收到相同的随机数。</p><p id="fbae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.当我将DataService注入到<strong class="jm io"> ParentComponent </strong>的构造函数中时，DI系统将检查服务实例是否可以用与<strong class="jm io"> ParentComponent </strong>相关联的注入器获得。</p><p id="0f83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，它是可用的！正如我们前面看到的，<strong class="jm io"> DataService是通过ParentComponent </strong>中的【providers】提供的。因此与ParentComponent关联的<strong class="jm io">注入器将创建一个新的DataService实例。</strong></p><p id="2a09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这解释了为什么ParentComponent收到的随机数不同于AppComponent和SiblingComponent。</p><p id="d327" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.当我将DataService注入到<strong class="jm io">子组件</strong>的构造函数中时，DI系统将检查服务实例是否可以使用与<strong class="jm io">子组件</strong>关联的注入器。</p><p id="4a2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不，它不可用！因此，DI系统向上移动一级，并且<strong class="jm io">检查该实例是否可用于与子组件的父组件(即父组件)相关联的注入器。</strong></p><p id="5881" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，它是可用的！DataService通过ParentComponent中的[providers]提供。因为与ParentComponent关联的injector已经创建了一个DataService实例，所以它不会再创建另一个实例。DI系统为ChildComponent重用相同的DataService实例。</p><p id="01b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这解释了为什么ParentComponent和ChildComponent从DataService接收到相同的随机数。</p><p id="62a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在我们有了数据服务的<strong class="jm io">两个不同的实例。您可以尝试下面的场景，看看输出有什么不同。</strong></p><p id="9ab7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;在SiblingComponent和ChildComponent级别提供数据服务。</p><p id="c967" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;仅在SiblingComponent级别提供新服务，然后尝试在其他组件中访问它。</p><p id="214b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在下面找到完整的工作示例。</p><div class="ki kj gp gr kk kl"><a href="https://stackblitz.com/edit/angular-gcaupq?file=src/app/eager/parent/parent.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">角形(叉形)堆叠</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">stackblitz.com</p></div></div><div class="ku l"><div class="mo l kw kx ky ku kz la kl"/></div></div></a></div><p id="4d36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mp">更多内容看</em> <a class="ae mq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mp">说白了。报名参加我们的</em> <a class="ae mq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mp">免费周报</em> </strong> </a> <em class="mp">。关注我们上</em> <a class="ae mq" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mp">推特</em></strong></a><a class="ae mq" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mp">领英</em></strong></a><strong class="jm io"><em class="mp"/></strong><a class="ae mq" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mp">YouTube</em></strong></a><strong class="jm io"><em class="mp"/></strong><em class="mp">和</em> <a class="ae mq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mp">不和</em> </strong> </a> </strong> <em class="mp">对成长黑客感兴趣？检查出</em> </a><a class="ae mq" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mp">电路</em> </strong> </a> <strong class="jm io"> <em class="mp">。</em> </strong></p></div></div>    
</body>
</html>