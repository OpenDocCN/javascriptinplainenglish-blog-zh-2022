<html>
<head>
<title>Read Files via JavaScript in the Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在浏览器中通过JavaScript读取文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reading-files-via-javascript-in-the-browser-part-3-responding-to-filereader-errors-and-progress-458fce0a9f17?source=collection_archive---------15-----------------------#2022-02-08">https://javascript.plainenglish.io/reading-files-via-javascript-in-the-browser-part-3-responding-to-filereader-errors-and-progress-458fce0a9f17?source=collection_archive---------15-----------------------#2022-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a018" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第3部分:用JavaScript响应FileReader错误和进度更新。</h2></div><p id="f174" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于通过JavaScript读取文件的<a class="ae ky" href="https://medium.com/@chad.campbell/reading-files-via-javascript-in-the-browser-introduction-ad40af01a1dd" rel="noopener">的本系列的第2部分</a>向您展示了如何使用客户端JavaScript读取文件。本文将接过接力棒，向您展示如何响应读取文件时发生的事件。为了介绍这些事件，我想向大家展示一个流程图。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/d2e0dfe67cb2d896fd1277cf33880f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Asr2IeRMT-s0nPqg"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">flowchart 3.1</figcaption></figure><p id="3f25" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">流程图3.1显示了读取文件时触发的事件。这些事件在JavaScript的标准FileReader对象上可用。这个过程从触发loadstart事件开始，到触发loadend事件结束。在此过程中还会发生其他一些事件。通过对这些事件做出反应，您可以创建一个更丰富、更健壮的应用程序。本文将讨论:</p><ul class=""><li id="4627" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">对文件加载事件做出反应</li><li id="8146" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">管理进度更新</li><li id="2483" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">应对错误</li><li id="9d50" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">捕捉取消</li></ul><p id="f23e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了强调本文的主题，我想提醒你三件事:1。本系列使用一个名为“Expenses”的虚拟费用报告应用程序来强化这些想法。2.本文中展示的示例可以在<a class="ae ky" href="https://github.com/ecofic/article-reading-files-via-javascript" rel="noopener ugc nofollow" target="_blank">源代码库</a>中找到。3.如果在这篇文章中的任何时候你感到困惑，我会鼓励你回顾流程图3.1。它可以帮助你重新集中注意力。有了这三个提醒，我们可以继续讨论本文中涉及的六个事件。前三个事件直接处理文件的加载。</p><h1 id="b102" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">对文件加载事件做出反应</h1><p id="b9b3" class="pw-post-body-paragraph kc kd in ke b kf mv jo kh ki mw jr kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">FileReader对象提供了三个与加载文件直接相关的事件。这三个事件是loadstart、load和loadend事件。这三个事件显示在上面流程图3.1的顶行。下面的代码示例展示了使用中的所有这三个事件。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi na"><img src="../Images/6d906ec7c2392c6638d839c77ce9b829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYqgKzaM9F7owO_yEGUVMg.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">sample 3.1</figcaption></figure><p id="9362" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例3.1显示了FileReader的loadstart、load和loadend事件。当FileReader开始读取文件时，将触发loadstart事件。如果文件被成功读取，加载事件将被触发。然后，一旦FileReader完成获取File对象的数据，loadend事件将被触发。需要认识的重要事实是，只有当文件被成功读取时，加载事件才会被触发。即使文件<em class="nb">未</em>成功读取，loadend也会触发。值得注意的是，所有的FileReader事件都共享相同类型的细节。</p><p id="3d7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个FileReader事件接收一个ProgressEvent。这个参数就是示例3.1中打印到控制台的详细信息的来源。下表描述了与在浏览器中读取文件相关的属性:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1c0c4e5ebdff0551f6f0542c89c763f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*-j03ErKhsgmOD0U8JPCjqQ.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">table 3.1</figcaption></figure><p id="e686" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">表3.1显示了属于传递给loadstart、load和loadend事件的ProgressEvent参数的属性。该参数也被传递给其他FileReader事件，包括progress事件。</p><h1 id="5397" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">管理进度更新</h1><p id="40ec" class="pw-post-body-paragraph kc kd in ke b kf mv jo kh ki mw jr kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">FileReader的progress事件让您发现一个文件已经被读取了多少。此事件将在loadstart事件之后开始激发。它至少会触发一次，即使文件的大小为零字节(是的，我测试过)。如果文件足够大，进度事件<em class="nb">可能会</em>触发多次。我之所以说“may”是因为progress事件会定期触发。</p><p id="3906" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大约每隔50毫秒触发一次进度事件(<a class="ae ky" href="https://w3c.github.io/FileAPI/#dfn-filereader" rel="noopener ugc nofollow" target="_blank">源</a>)，直到文件被读取。在每次更新过程中，可以计算出文件被读取的数量。以下示例显示了该计算:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi na"><img src="../Images/71106d069481e784f9a4eedc717e5a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFjW88zOr9z0Vw9moFJEUA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">sample 3.2</figcaption></figure><p id="d7ba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例3.2建立在示例3.1的基础上，以响应进度事件。为了测试这个示例，使用了源存储库中的<a class="ae ky" href="https://github.com/ecofic/article-reading-files-via-javascript/blob/live/files/large-file.txt" rel="noopener ugc nofollow" target="_blank"> large-file.txt </a>。在测试期间，我的机器上的进度事件被触发了两次。在每一次迭代中，下载的字节百分比都是按照第2行所示进行计算的。该信息然后被打印到控制台，如第3行所示。在现实世界中，您可能希望使用progress事件来更新UI中的进度条。虽然这是增强体验的一种方式，但另一种方式是优雅地应对错误。</p><h1 id="7aaa" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">应对错误</h1><p id="3a24" class="pw-post-body-paragraph kc kd in ke b kf mv jo kh ki mw jr kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">FileReader的错误事件允许您对意外发生的情况做出响应。例如，一个文件在被选中和被读取之间可能会被移动。虽然这种情况似乎很少发生，但这种情况以及其他意想不到的情况确实会发生。事实上，<a class="ae ky" href="https://w3c.github.io/FileAPI/#ErrorAndException" rel="noopener ugc nofollow" target="_blank">文件API规范</a>会调用以下错误:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/190479f67e93ef2c6a5c90f7813ebd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*4buWbTraRSUHxxzqvUX5bQ.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">table 3.2</figcaption></figure><p id="caae" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">表3.2显示了可能触发文件读取器错误的情况。下面的示例建立在示例3.1的基础上，包括一个错误处理程序。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nd"><img src="../Images/02fef0ff81466885f74e336b30943eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5SMi9b9KGBNrkrOTEmMBw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">sample 3.3</figcaption></figure><p id="e244" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例3.3在文件读取器读取文件时发生错误的情况下创建一个处理程序。这个处理程序的第2行使用了FileReader对象的error <em class="nb">属性</em>。为了确认并消除任何混淆，FileReader有一个事件和一个名为error的属性🤷‍♂️.错误<em class="nb">属性</em>是一个共享问题原因细节的DOMException。这些细节用于第3行。</p><p id="3230" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例3.3的第3行创建了描述错误的注释，并将其打印到控制台。此注释依靠错误的name属性来识别问题。该名称将是此处列出的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMException#error_names" rel="noopener ugc nofollow" target="_blank">名称之一。该值由message属性补充，它提供了问题的简要描述。这一行还包括导致错误的文件的名称。</a></p><p id="2816" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">导致错误的文件名是<em class="nb">，而不是在错误事件处理程序中直接可用的</em>。传递给事件处理程序的ProgressEvent参数不包含文件名。FileReader对象也不包含文件名。这意味着您需要跟踪自己正在读取的文件的名称。样本3.3依赖于样本3.1中定义的收据。关于错误事件，我还想分享另外一个细节。</p><p id="4d1c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果在<em class="nb">其他</em> FileReader事件之一中发生错误，将<em class="nb">而不是</em>调用错误事件。例如，假设从progress事件调用一个名为calculateCompleted的未定义方法。虽然这会引发ReferenceError，但不会触发Error事件。因此，您需要适当地处理其他FileReader事件中的异常。你可能也想考虑处理取消。</p><h1 id="54c7" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">捕捉取消</h1><p id="95b6" class="pw-post-body-paragraph kc kd in ke b kf mv jo kh ki mw jr kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">FileReader允许取消正在进行的读取操作。如果通过abort方法取消读取操作，将会触发相应的abort事件。重申一下，FileReader有一个中止<em class="nb">事件</em>和一个中止<em class="nb">方法</em>。您可以将它们一起使用，如下面的代码示例所示。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi na"><img src="../Images/2822fa7fa1ec2721f4749bffb976a93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_XuSgAjvJ4yoK8SvfivNDQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">sample 3.4</figcaption></figure><p id="b4a8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">样本3.4修改了样本3.2，并使用<a class="ae ky" href="https://github.com/ecofic/article-reading-files-via-javascript/blob/live/files/large-file.txt" rel="noopener ugc nofollow" target="_blank"> large-file.txt </a>进行了测试。此示例的第4行在第一次进度更新后中止了文件的读取。这将触发第7–9行定义的中止事件处理程序。中止事件不做任何特殊的事情，也不提供任何独特的信息。相反，我想包括这一部分只是为了确保你知道它的存在。</p><p id="37b2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文向您展示了如何响应读取文件时发生的FileReader事件。如果这篇文章有帮助，请鼓掌(👏，)现在。这让我和其他人知道你觉得它很有价值。这是阅读文件系列的第三篇文章。因此，现在请<a class="ae ky" href="https://medium.com/@chad.campbell" rel="noopener">跟随我</a>以便您知道本系列的最后一篇文章何时发表。下一篇文章将向您展示如何从FileReader中检索文件内容。</p><p id="d223" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nb">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nb">plain English . io</em></strong></a><em class="nb">。报名参加我们的</em> <a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nb">免费周报</em> </strong> </a> <em class="nb">。在我们的</em> <a class="ae ky" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nb">社区</em> </strong> </a> <em class="nb">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>