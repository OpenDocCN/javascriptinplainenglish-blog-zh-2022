# 如何实现 JavaScript 承诺

> 原文：<https://javascript.plainenglish.io/how-to-implement-javascript-promise-part-1-8407a8f75584?source=collection_archive---------7----------------------->

## 第 1 部分:带着承诺处理任务。

![](img/252c8b782e62769766634224a011fcf4.png)

Photo by [Joshua Earle](https://unsplash.com/@joshuaearle?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

我们一直在使用 JavaScript 承诺，从获取 API 到等待事情发生。但是信不信由你，我们中没有多少人知道承诺的准确定义是什么。如果没有也没关系。我们不知道很多事情，但我们仍然每天使用它们。

然而，当涉及到实现时，对定义部分的知识的缺乏最终总是会回来伤害我们。记住这一点。当你想做一些困难或复杂的事情时，你想确保你能记住目标，因为由于一路上各种各样的干扰，你很容易忘记你在做什么。承诺在这里也不例外。

## 承诺能做什么？

让我们快速看一下它的一个典型用法:

```
const p = **new** Promise((resolve, reject) => { resolve(3) })
p**.then**(res => { console.log(res })
 .**catch**(e => { console.error(e) })
```

我们可以通过提供一个任务(功能)来创建一个承诺。之后这个任务解决了我们就可以用`then`来处理了。如果由于某种原因任务被拒绝，我们可以在`catch`中处理错误。

虽然用法足够简单，但是任务需要写成函数。该函数采用两个名为`resolve`和`reject`的函数:

```
const taskFn = (resolve, reject) => { ... }
```

很快，这就变成了函数式编程 101。给定定义如何解决或拒绝的方法，我们可以定义任务函数。在函数式编程中，方法可以通过函数来定义。在其他编程语言中，它们通常通过类来定义。如果你把函数/类作为一个可以注入另一个的实体，你或多或少可以用同样的方式对待它们。

## 什么是承诺？

好了，定义了任务函数，让我们回到承诺:

```
const taskFn = (resolve, reject) => { resolve(5) }
const p = new Promise(taskFn).then(res => {})
```

承诺不会给你从任务中得到的任何回报。上面的例子从任务中解析出数字`5`，但是承诺`p`不会给你这个数字。因为这是承诺。它向你承诺(在未来),如果你通过一个`then`请求，当任务解决时，值可以被返回。在我们的例子中，我们将在`then`中得到数字`5`。

更准确的定义是:承诺是一个固定的任务。一旦承诺被创造出来，它不一定会启动任务。因此，任务的结果在创建时不应该可用。关于“**不应该**的部分需要多一点解释。因为一个琐碎的任务可以运行得非常快，只需要很少的时间。但是即使对于那种任务，承诺也不能立即调用它并完成它。相反，它只能承诺调用它，因此在某种意义上，**承诺在起跑线前增加了一些空间/时间。**当我们实现时，我们将看到如何在代码中实现这一点。

## 什么是'`then'`？

随着诺言的产生，现在又出现了另一种说法`then`，到底什么是`then`？

```
.then(resolve)
.then(value => {})
```

`then`采用一个定义任务完成时做什么的函数。本质上，这是另一个函数编程 101。`then`与任务本身没有太大关系，相反，它处理如何处理任务返回的值。因此，功能`value => {}`也被称为`resolve`功能。

如果`then`不是为承诺而写的，那么当任务完成时什么都不重要，因为我们无论如何都不会得到通知，也没有人知道那个任务发生了什么。

如果`then`是为一个承诺编写的，那么`resolve`函数会在任务完成时被调用，并且很可能解析为一个值。请记住，这只是在任务完成之后，而不是在任务完成之前或任务定义时。这里最常见的做法是任务可能需要 3 秒钟才能运行。3 秒钟后，调用`resolve`。这里不太明显的是，如果任务运行需要 0.1 秒，那么`resolve`会在 0.1 秒后被调用。运行该任务可能需要 0.000001 秒，因此在调用`resolve`之前应该会有一点延迟。这种理解将有助于我们在编写代码时实现承诺。

# 结论

我们将在第二部分从头开始实现这个承诺。在第一部分中，我们看到承诺是如何处理任务的。通过使用承诺，我们将任务的定义和任务处理分成两个独立的工作。前者在 Promise 构造函数中定义，而后者在`then`语句中定义。本质上，涉及承诺的任务需要时间来运行，并且非常适合异步操作。但是也要记住，承诺**必须**用于延期的任务。如果您对立即调用的任务感兴趣，请考虑使用基本的函数调用。

*更多内容尽在* [***说白了. io***](https://plainenglish.io/) *。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。关注我们关于* [***推特***](https://twitter.com/inPlainEngHQ)[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*，以及* [***不和***](https://discord.gg/GtDtUAvyhW) *。*