<html>
<head>
<title>React Tracked: Manage State and Prevent Excessive Re-Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跟踪反应:管理状态并防止过度重新渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tracked-manage-state-and-prevent-excessive-re-rendering-d41d20f3335c?source=collection_archive---------1-----------------------#2022-02-09">https://javascript.plainenglish.io/react-tracked-manage-state-and-prevent-excessive-re-rendering-d41d20f3335c?source=collection_archive---------1-----------------------#2022-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ed442131735b32d67cc21b8d6503a532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5UpYsjbj_kdT6kll"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://github.com/dai-shi/react-tracked" rel="noopener ugc nofollow" target="_blank">https://github.com/dai-shi/react-tracked</a></figcaption></figure><p id="36f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的几年中，React中的状态管理经历了重大的演变。有了像内置React Context API和React Redux这样的解决方案，保持全局状态和跟踪变化变得前所未有的简单。然而，在实现这些工具时，一个持续的挑战是优化性能和防止组件不必要的重新呈现。</p><p id="4753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而在较小的应用程序中，过多的重新渲染可能不会引起注意或者没有负面影响，随着应用程序的增长，每次重新渲染都可能导致UI延迟或滞后。在本教程中，我们将使用<a class="ae kc" href="https://github.com/dai-shi/react-tracked" rel="noopener ugc nofollow" target="_blank"> React Tracked </a>，一个用于状态使用跟踪的库，通过防止不必要的重新渲染来优化我们的应用程序的性能。</p><h1 id="4b4f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装React Tracked</h1><p id="049b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，在您的机器上建立一个新的React项目。在终端中打开项目，并添加以下命令来安装React跟踪库:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ff6e" class="mn lc iq mj b gy mo mp l mq mr">yarn add react-tracked scheduler</span></pre><p id="446b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们通过给它以下结构来清理我们的项目:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/fee765623c944dfc877bc9b7b10ae135.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/0*ZSq89ompIL21JJBB.png"/></div></figure><h1 id="2560" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置我们的应用程序</h1><p id="11c7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们比较一下React Tracked和共享状态的普通React实现。我们将创建一个简单的全局上下文，它有两个计数器组件，每个组件使用一个值。</p><p id="2616" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">App.js</code>中添加以下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="62c9" class="mn lc iq mj b gy mo mp l mq mr">import Counter1 from "./Counter1";<br/>import Counter2 from "./Counter2";</span><span id="3b72" class="mn lc iq mj b gy mw mp l mq mr">import { SharedStateProvider } from "./store";</span><span id="054e" class="mn lc iq mj b gy mw mp l mq mr">function App() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;SharedStateProvider&gt;<br/>        &lt;div<br/>          style={{<br/>            display: "flex",<br/>            flexDirection: "row",<br/>            border: "1px solid black",<br/>            justifyContent: "space-around",<br/>          }}<br/>        &gt;<br/>          &lt;Counter1 /&gt;<br/>          &lt;Counter2 /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/SharedStateProvider&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span><span id="8a4b" class="mn lc iq mj b gy mw mp l mq mr">export default App;</span></pre><p id="799d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建计数器组件，请在每个文件中添加以下代码:</p><h1 id="6543" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">Counter1</code></h1><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7f99" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";<br/>import { useSharedState } from "./store";</span><span id="8249" class="mn lc iq mj b gy mw mp l mq mr">export default function Counter1() {<br/>  const [state, setState] = useSharedState();</span><span id="5983" class="mn lc iq mj b gy mw mp l mq mr">  const increment = () =&gt; {<br/>    setState((prev) =&gt; ({ ...prev, count1: prev.count1 + 1 }));<br/>  };</span><span id="d0bb" class="mn lc iq mj b gy mw mp l mq mr">  return (<br/>    &lt;div&gt;<br/>      {state.count1}<br/>      {console.log("render counter 1")}</span><span id="2653" class="mn lc iq mj b gy mw mp l mq mr">      &lt;button onClick={increment}&gt;Increment count1&lt;/button&gt;</span><span id="7557" class="mn lc iq mj b gy mw mp l mq mr">    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="8ea8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">Counter2</code></h1><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="09e0" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";<br/>import { useSharedState } from "./store";</span><span id="6a56" class="mn lc iq mj b gy mw mp l mq mr">export default function Counter2() {<br/>  const [state, setState] = useSharedState();</span><span id="12f7" class="mn lc iq mj b gy mw mp l mq mr">  const increment = () =&gt; {<br/>    setState((prev) =&gt; ({ ...prev, count2: prev.count2 + 1 }));<br/>  };</span><span id="57f4" class="mn lc iq mj b gy mw mp l mq mr">  return (<br/>    &lt;div&gt;<br/>      {state.count1}<br/>      {console.log("render counter 2")}</span><span id="c4bc" class="mn lc iq mj b gy mw mp l mq mr">      &lt;button onClick={increment}&gt;Increment count2&lt;/button&gt;</span><span id="6409" class="mn lc iq mj b gy mw mp l mq mr">    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="5a09" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">store.js</code></h1><p id="bb63" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">最后，让我们创建我们的<code class="fe mt mu mv mj b">store.js</code>文件，它使用全局计数器上下文和计数器组件中状态的<code class="fe mt mu mv mj b">useSharedState()</code>钩子:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="97e9" class="mn lc iq mj b gy mo mp l mq mr">import React, { createContext, useState, useContext } from "react";</span><span id="6651" class="mn lc iq mj b gy mw mp l mq mr">const initialState = {<br/>  count1: 0,<br/>  count2: 0,<br/>};</span><span id="0f7d" class="mn lc iq mj b gy mw mp l mq mr">const useValue = () =&gt; useState(initialState);</span><span id="4883" class="mn lc iq mj b gy mw mp l mq mr">const MyContext = createContext(null);</span><span id="3cef" class="mn lc iq mj b gy mw mp l mq mr">export const useSharedState = () =&gt; {<br/>  const value = useContext(MyContext);<br/>  return value;<br/>};</span><span id="9248" class="mn lc iq mj b gy mw mp l mq mr">export const SharedStateProvider = ({ children }) =&gt; (<br/>  &lt;MyContext.Provider value={useValue()}&gt;{children}&lt;/MyContext.Provider&gt;<br/>);</span></pre><p id="62ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要运行该项目，请添加以下命令:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b156" class="mn lc iq mj b gy mo mp l mq mr">yarn start</span></pre><p id="681f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将在浏览器屏幕上看到以下输出:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a85658fa46579ef8f926ffd00ef0f223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/0*XwkVxrXwLvYR2YOK.png"/></div></figure><p id="e50b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打开浏览器控制台，按下每个<strong class="kf ir">增量</strong>按钮三次。我们将收到以下输出:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1f97b9de707a060382b278bb7c0d3a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/0*9_zkXM4g7tx558nq.png"/></div></figure><p id="4b69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论状态是否更新，每个组件都会重新呈现。理想情况下，组件应该只在状态改变时才重新呈现。</p><p id="3ae4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的示例中，总共应该有六次重新渲染，两个组件都有三次，但是，我们得到了12次，这表明两个组件在每次单击时都重新渲染了。</p><h1 id="52b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">呈现一个大列表</h1><p id="e7b7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在，让我们尝试呈现一个大的元素列表。将下面的代码添加到<code class="fe mt mu mv mj b">Counter1</code>和<code class="fe mt mu mv mj b">Counter2</code>中，在每个组件中生成一个10，000个随机数的列表:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f5c9" class="mn lc iq mj b gy mo mp l mq mr">import React, { useEffect, useState } from "react";<br/>import { useSharedState } from "./store";</span><span id="bd7d" class="mn lc iq mj b gy mw mp l mq mr">export default function Counter1() {<br/>  const [state, setState] = useSharedState();</span><span id="1a7d" class="mn lc iq mj b gy mw mp l mq mr">  const [randomNumbers, setRandomNumbers] = useState([]);<br/>  const increment = () =&gt; {<br/>    setState((prev) =&gt; ({ ...prev, count1: prev.count1 + 1 }));<br/>  };<br/>  const generateHugeList = () =&gt; {<br/>    let list = [];<br/>    for (let i = 0; i &lt; 10000; i++) {<br/>      list.push(Math.floor(Math.random() * 10));<br/>    }<br/>    setRandomNumbers(list);<br/>  };<br/>  useEffect(() =&gt; {<br/>   generateHugeList();<br/>  }, []);<br/>  return (<br/>    &lt;div&gt;<br/>      {state.count1}<br/>      {console.log("render counter 1")}</span><span id="108f" class="mn lc iq mj b gy mw mp l mq mr">      &lt;button onClick={increment}&gt;Increment count1&lt;/button&gt;<br/>      {randomNumbers.map((number) =&gt; {<br/>        return &lt;p&gt;{number}&lt;/p&gt;;<br/>      })}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="69b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计数器组件在浏览器上呈现列表，产生类似如下的输出:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/78e4303254e4a01f8960ed0e957a7d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/0*8-PYKBkbtsf9H5GQ.png"/></div></figure><p id="14e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着这些新元素的引入，我们的应用程序需要更多的时间来加载:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/351e3fadc13d990b648117891d4ecfd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/0*1gV0Fcs_spKyaqEg.png"/></div></figure><p id="2528" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一次加载时，CPU使用率跃升至100 %:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/81a14d9bfed80d63e91d90dcb5ff7b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/0*XUvWKEY9YDhoNxun.png"/></div></figure><p id="5ea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React将在第一次渲染时将所有元素绘制到浏览器DOM中，因此100%的CPU使用率是典型的。但是，在单击每个计数器组件上的<strong class="kf ir">增量</strong>按钮后，CPU使用率保持在100 %,这表明两个计数器都在不断重新呈现:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/12d679bb06828de4756fffadc7039ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bzBY9YBT-ERN9__N.gif"/></div></div></figure><h1 id="4f29" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">防止重新渲染的选项</h1><p id="d2c4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">防止重新渲染的一个流行方法是<a class="ae kc" href="https://blog.logrocket.com/getting-started-react-redux-firebase/" rel="noopener ugc nofollow" target="_blank">在React Redux </a>中使用选择器，这是订阅Redux存储并在调度动作时运行的函数。选择器使用<code class="fe mt mu mv mj b">===</code>作为严格的质量检查，每当数据改变时重新呈现组件。虽然这个过程对变量很有效，但每次数据改变时返回新引用的函数会不断地重新呈现。</p><p id="754e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，React Tracked包装上下文对象，并通过使用JavaScript代理来跟踪状态的单个属性的变化，从而返回自己的提供者。</p><p id="c8c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代理包装单个对象，截取或改变其基本操作。React Tracked实现了检查组件内部状态的代理，只有当信息改变时才重新呈现它。要查看代理的运行情况，让我们在应用程序中实现React Tracked。</p><h1 id="5390" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">呈现跟踪了反应的列表</h1><p id="b45a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，我们需要通过添加以下代码来修改我们之前创建的<code class="fe mt mu mv mj b">store.js</code>文件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="23d5" class="mn lc iq mj b gy mo mp l mq mr">import { useState } from "react";<br/>import { createContainer } from "react-tracked";</span><span id="1e50" class="mn lc iq mj b gy mw mp l mq mr">const initialState = {<br/>  count1: 0,<br/>  count2: 0,<br/>};</span><span id="4d8f" class="mn lc iq mj b gy mw mp l mq mr">const useMyState = () =&gt; useState(initialState);</span><span id="8816" class="mn lc iq mj b gy mw mp l mq mr">export const { Provider: SharedStateProvider, useTracked: useSharedState } =<br/>  createContainer(useMyState);</span></pre><p id="f927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们导入了<code class="fe mt mu mv mj b">createContainer()</code>，它返回一个React跟踪的提供者。<code class="fe mt mu mv mj b">useTracked</code>钩子为我们的状态创建了一个代理。</p><p id="9c95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们重新构建项目，并将之前的输出与React Tracked的输出进行比较:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/1ec0e7b0660c44824c432c2ba7a3cca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nR4F_oC9XoH7cd-8.gif"/></div></div></figure><p id="9352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，当我们选择<strong class="kf ir">增量计数1 </strong>按钮时，在第一次渲染时，<code class="fe mt mu mv mj b">Counter1</code>和<code class="fe mt mu mv mj b">Counter2</code>都会被渲染。然而，在随后的点击中，只有<code class="fe mt mu mv mj b">Counter1</code>被重新渲染，减少了CPU的整体使用，提高了我们应用的性能。</p><h1 id="b819" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="02a3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本教程中，我们探讨了由不必要的重新渲染导致的不必要的性能缺陷。虽然像React Redux和React Context API这样的工具可以很容易地跟踪应用程序状态的变化，但它们并没有提供一个简单的解决方案来最小化重新呈现。</p><p id="8445" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用React Tracked库，我们构建了一个应用程序，并最大限度地减少了重新呈现计数器组件的次数，从而减少了CPU的使用并提高了整体性能。我希望你喜欢这个教程！</p><p id="3bf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原帖通过<a class="ae kc" href="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering" rel="noopener ugc nofollow" target="_blank"> LogRocket </a>发布。</p><p id="1030" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nc">更多内容看</em> <a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nc">说白了。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。在我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nc">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="nc">。</em></strong></a></p></div></div>    
</body>
</html>