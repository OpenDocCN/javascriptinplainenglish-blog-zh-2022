<html>
<head>
<title>Level Up Your JavaScript Skills With the Inclusion of Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过承诺来提升你的JavaScript技能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/level-up-your-skills-in-javascript-with-the-inclusion-of-promises-5a2c84f2fe71?source=collection_archive---------8-----------------------#2022-09-27">https://javascript.plainenglish.io/level-up-your-skills-in-javascript-with-the-inclusion-of-promises-5a2c84f2fe71?source=collection_archive---------8-----------------------#2022-09-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="666b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中的承诺是什么？这是一段可能在某个时间点产生一个值的代码。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/dd011be5228e2c244dbe45296e311aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*HuUdxy79d7oFClg7"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk"><a class="ae ko" href="https://www.pexels.com/photo/island-landscape-13727429/" rel="noopener ugc nofollow" target="_blank">Photo by Valerie Voila from Pexels</a></figcaption></figure><p id="dd80" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果你现在写JavaScript，你最终会听到或读到所谓的<code class="fe ll lm ln lo b">asynchronous</code>代码。JavaScript最初是以同步方式构建的，简而言之，这意味着它以编写代码的方式运行:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="b36a" class="lt lu in lo b gy lv lw l lx ly">console.log('a');<br/>console.log('b');<br/>console.log('c');</span><span id="49d4" class="lt lu in lo b gy lz lw l lx ly">// Output: a b c</span></pre><p id="0c43" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这将按照准确的顺序输出。异步代码可以用我们关心的方式编写。如果我们想要一个特定的顺序，我们可以这样做:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="8e27" class="lt lu in lo b gy lv lw l lx ly">console.log('a');</span><span id="9c98" class="lt lu in lo b gy lz lw l lx ly">setTimeout(() =&gt; { console.log('b') }, 2000);</span><span id="c1a1" class="lt lu in lo b gy lz lw l lx ly">console.log('c');</span><span id="4f0b" class="lt lu in lo b gy lz lw l lx ly">// Output: a c b</span></pre><p id="8321" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">正如你所看到的，使用异步代码，我们可以更好地控制代码的顺序。我们可以让事情以我们真正关心的方式运行。今天，我们将讨论承诺的概念！</p><h1 id="1952" class="ma lu in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">承诺()</h1><p id="e226" class="pw-post-body-paragraph kp kq in kr b ks mr jo ku kv ms jr kx ky mt la lb lc mu le lf lg mv li lj lk ig bi translated">简而言之，承诺是一段代码，可以在某个时间点产生一个值。在任何给定时间，承诺可能处于三种状态之一:待定、履行或拒绝。承诺取代了编写回调的需要，与传入的回调不同，承诺有一些保证:</p><ul class=""><li id="b0bb" class="mw mx in kr b ks kt kv kw ky my lc mz lg na lk nb nc nd ne bi translated">当通过<code class="fe ll lm ln lo b">then()</code>关键字添加回调时，在当前运行完成之前，这些回调永远不会被调用。本质上，如果我们有3个步骤，第2步将不会开始，直到第1步已经完成。</li><li id="f943" class="mw mx in kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated">即使添加了异步操作的成功或失败，也会调用回调。</li><li id="88d7" class="mw mx in kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated">您可以添加任意数量的<code class="fe ll lm ln lo b">then()</code>，它们将按照接收的顺序被调用。</li></ul><p id="b385" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这方面的一个例子如下(我们将在下面进一步讨论带有箭头功能的版本):</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="1c5d" class="lt lu in lo b gy lv lw l lx ly">firstFunction()<br/>  .then(function (firstResult) {<br/>    return secondFunction(firstResult);<br/>  })<br/>  .then(function (secondResult) {<br/>    return thirdFunction(secondResult);<br/>  })<br/>  .then(function (thirdResult) {<br/>    console.log(`Result: ${thirdResult}`);<br/>  })<br/>  .catch(theFailingCallback);</span></pre><p id="1c0a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这是无限优于老学校回调地狱，这是下面</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="5b8b" class="lt lu in lo b gy lv lw l lx ly">firstFunction (function (firstResult) {<br/>  secondFunction (firstResult, function (secondResult) {<br/>    thirdFunction (secondResult, function (thirdResult) {<br/>      console.log (`Result: ${thirdResult}`);<br/>    }, theFailingCallback);<br/>  }, theFailingCallback);<br/>}, theFailingCallback);<!-- --> </span></pre><p id="e4a1" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">使用像承诺这样的现代方法，我们将回调附加到返回的承诺上，这形成了一个承诺链。我们还可以使用箭头函数来编写我们的承诺链，如下所示:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="9b94" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">Example 1 (Arrow function with explicitly used return keyword)</strong></span><span id="5411" class="lt lu in lo b gy lz lw l lx ly">firstFunction()<br/>  .then((firstResult) =&gt; {return secondFunction(firstResult)})<br/>  .then((secondResult) =&gt; {return thirdFunction(secondResult)})<br/>  .then((thirdResult) =&gt; {console.log(`result: {thirdResult})})<br/>  .catch(theFailingCallback);<!-- --> </span></pre><p id="3f2f" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">或者</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="5b61" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">Example 2 (Arrow function without explicitly used return keyword)</strong></span><span id="a7fd" class="lt lu in lo b gy lz lw l lx ly">firstFunction()<br/>  .then((firstResult) =&gt; secondFunction(firstResult))<br/>  .then((secondResult) =&gt; thirdFunction(secondResult))<br/>  .then((thirdResult) =&gt; console.log(`result: {thirdResult}))<br/>  .catch(theFailingCallback);</span></pre><blockquote class="nk nl nm"><p id="8dfa" class="kp kq nn kr b ks kt jo ku kv kw jr kx no kz la lb np ld le lf nq lh li lj lk ig bi translated">重要提示:一定要返回结果，否则回调不会捕捉到之前承诺的结果(对于箭头函数，<code class="fe ll lm ln lo b">() =&gt; x</code>是<code class="fe ll lm ln lo b">() =&gt; { return x; }</code>的简称)。如果前一个处理程序开始了一个承诺，但没有返回，就没有办法再跟踪它的结算，这个承诺就被称为“浮动的”。<br/> — <a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="d508" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果存在类似竞态条件的情况，这尤其糟糕。如果来自前一个处理程序的承诺从未正确返回，那么下一个承诺中的处理程序将被提前调用，并且值可能不完整。如果可以的话，我们希望不惜一切代价避免这种情况</p><p id="edf6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果需要，您可以在catch语句后链接一个then，即使承诺失败，该语句也会执行:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="bb3d" class="lt lu in lo b gy lv lw l lx ly">firstFunction()<br/>  .then((firstResult) =&gt; {return secondFunction(firstResult)})<br/>  .then((secondResult) =&gt; {return thirdFunction(secondResult)})<br/>  .then((thirdResult) =&gt; {console.log(`result: {thirdResult})})<br/>  .catch(theFailingCallback)<br/>  .then((fourthResult) =&gt; {console.log(`do this {fourthResult})};<!-- --> </span></pre><div class="nr ns gp gr nt nu"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">Promise - JavaScript | MDN</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">Promise对象表示异步操作的最终完成(或失败)及其结果…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">developer.mozilla.org</p></div></div><div class="od l"><div class="oe l of og oh od oi ki nu"/></div></div></a></div></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><h1 id="412d" class="ma lu in bd mb mc oq me mf mg or mi mj jt os ju ml jw ot jx mn jz ou ka mp mq bi translated">Promise.all()</h1><p id="b23b" class="pw-post-body-paragraph kp kq in kr b ks mr jo ku kv ms jr kx ky mt la lb lc mu le lf lg mv li lj lk ig bi translated">promise.all()函数接受一系列承诺。返回值是一个单独的数组，它将包含从传入的承诺中返回的值。但是，如果这些值中的任何一个被拒绝，promise.all()会立即被拒绝。这方面的一个例子如下:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="3a91" class="lt lu in lo b gy lv lw l lx ly">const <!-- -->firstPromise <!-- -->= new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve('1'), 1000);<br/>});</span><span id="cb2c" class="lt lu in lo b gy lz lw l lx ly">const <!-- -->secondPromise<!-- -->= new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve('2'), 2000);<br/>});</span><span id="1c96" class="lt lu in lo b gy lz lw l lx ly">Promise.all([firstPromise, secondPromise]).then((returnedValues) =&gt; console.log(returnedValues)); // Output: Array ["1", "2"]</span></pre><div class="nr ns gp gr nt nu"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">Promise.all() - JavaScript | MDN</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">Promise.all()方法接受一个可迭代的承诺作为输入，并返回一个解析为…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">developer.mozilla.org</p></div></div><div class="od l"><div class="ov l of og oh od oi ki nu"/></div></div></a></div></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><p id="6537" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">虽然我知道这只是对JavaScript前景的一个非常简要的概述，但我强烈建议更深入地了解一下。这确实感觉像一个兔子洞，但它是最有价值的概念之一，值得学习和充分理解。我在过去的福特和福克斯体育工作中使用过这些概念，一旦我开始理解和编写异步代码，我就像这样</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/ac5e4eac95d3242d1b563d309ef06b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/0*KyjAMSM1ilWCERQZ"/></div></figure></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><p id="c155" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我希望这篇文章是令人愉快的。如果你有任何反馈，发表评论，让我知道我可以改进的地方。</p><p id="20e4" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果你想看看我的其他帖子，可以在这里找到。我写的都是前端特有的东西，所以我有关于<a class="ae ko" href="https://medium.com/javascript-in-plain-english/level-up-your-javascript-skills-with-these-built-in-functions-a15607b72c2b" rel="noopener">内置JavaScript函数</a>的文章，用React 、<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/developing-custom-themes-for-shopify-getting-started-b137407c0cb7">设置</a><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/use-a-firebase-db-inside-your-reactjs-project-2cfb56b51162"> Firebase，为Shopify </a>、<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/class-based-components-in-react-14335f0ee539">基于类的React组件</a>和<a class="ae ko" href="https://avetwhocodes.com/fetching-data-from-an-api-with-the-fetch-api-in-react-5dbe0abcfb41" rel="noopener ugc nofollow" target="_blank">获取API </a>进行定制主题开发。</p><p id="d6b8" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">感谢您的阅读，祝您愉快！</p></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><p id="85fc" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><em class="nn">更多内容请看</em><a class="ae ko" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="nn">plain English . io</em></strong></a><em class="nn">。报名参加我们的</em> <a class="ae ko" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="nn">免费周报</em> </strong> </a> <em class="nn">。关注我们关于</em><a class="ae ko" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="nn">Twitter</em></strong></a><a class="ae ko" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="nn">LinkedIn</em></strong></a><em class="nn"/><a class="ae ko" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="nn">YouTube</em></strong></a><em class="nn"/><a class="ae ko" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="nn">不和</em> </strong> </a> <em class="nn">。对增长黑客感兴趣？检查</em> <a class="ae ko" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="nn">电路</em> </strong> </a> <em class="nn">。</em></p></div></div>    
</body>
</html>