<html>
<head>
<title>React Native Higher-Order Components Vs Utils Functions: When to Use Each Approach?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React本机高阶组件与Utils函数:何时使用每种方法？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/higher-order-components-vs-utils-functions-react-native-when-to-use-each-approach-8c2063ff3914?source=collection_archive---------13-----------------------#2022-03-01">https://javascript.plainenglish.io/higher-order-components-vs-utils-functions-react-native-when-to-use-each-approach-8c2063ff3914?source=collection_archive---------13-----------------------#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1d5a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释如何以及何时使用React本机高阶组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cf0474a39f2b0edd338cd0fa0a75730a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DHDl1IalMNgHUe_Y-rm6mQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">When To Use Each Approach?</figcaption></figure><p id="8090" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经常有人问我什么时候使用HOC ( <a class="ae lr" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>)以及什么时候使用通常在具有以下名称的文件中找到的常用函数:</p><ul class=""><li id="f1d7" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">Helpers.js</li><li id="a7ac" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">Commons.js</li><li id="37c1" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">Utils.js等等。</li></ul><p id="6735" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我决定把这个主题讲清楚，并解释如何以及何时以最正确的方式使用每种方法。所以就跟着走吧。</p><h1 id="70c2" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">什么是反应高阶组件？</h1><p id="60c2" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated"><em class="nd">高阶分量(HOC)是取一个分量并返回一个分量的函数。</em></p><p id="a4a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">具体来说，<strong class="kx ir">高阶分量是取一个分量并返回一个新分量的函数。</strong></p><h1 id="50c7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">HOCs解决什么问题？</h1><p id="9c80" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们不要兜圈子，问一个主要问题，hoc解决的问题是什么？我们为什么需要它？</p><p id="d756" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">简单的</strong>答案是干，你问什么是干？干是一个原则，意思是“不要重复自己”。<br/>在我的职业生涯中，我已经在多种编程语言中使用了DRY原则，业内专家也一直建议我这样做。</p><p id="d9b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">比如API调用，复杂函数等等。</p><p id="9141" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，是的，在某些情况下，您可以使用Utils函数来这样做，但是hoc是另一种可能来做同样的事情，甚至更多。通过使用hoc，您可以共享公共功能，而无需重复相同的代码。</p><p id="b538" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">高级</strong>答案是不止这些。例如，使用HOCs，我们可以在原始组件旁边添加另一个组件，并创建一个包含这两个组件的新组件。</p><p id="391c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将在下一个问题中解释，如果我们希望在通过API请求获取数据的同时显示一个加载器，该怎么办？</p><p id="270e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这个问题可以感受到HOC的强大。</p><h1 id="5f58" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">通过例子学习</h1><p id="e242" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">假设我们有以下组件。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="6cab" class="nj mh iq nf b gy nk nl l nm nn">function ListOfUsers = ()=&gt; {<br/>  const [users, setUsers] = useState([]);<br/>  const [isLoading, setIsLoading] = useState(false);useEffect(()=&gt;{<br/>  (<br/>    async ()=&gt;{<br/>      setIsLoading(true);<br/>      const users = <br/>         await axios.get(GET_USERS_URL.then(results =&gt; results);<br/>      setUsers(users);<br/>      setIsLoading(false);<br/>    }<br/>  )();<br/>  },[])render(<br/>  &lt;View&gt;<br/>    &lt;Loader isLoading={isLoading}/&gt;<br/>    users.length ?<br/>      users.map((user) =&gt; &lt;UserCard user={user}/&gt;) :<br/>      &lt;Text&gt;No users&lt;/Text&gt;<br/>  &lt;/View&gt;<br/>  )<br/>}<br/>export default ListOfUsers;</span></pre><p id="b69c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们想要实现特定的方法。这里我们可以注意到两件事:</p><ul class=""><li id="2dfc" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">我们发出一个调用请求，从服务器获取所有用户。</li><li id="c6a5" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">我们正在使用<code class="fe no np nq nf b">Loader</code>组件。</li></ul><p id="fe8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们可以将API请求和<code class="fe no np nq nf b">Loader</code>组件从<code class="fe no np nq nf b">ListOfUsers</code>组件中取出，并将它们移动到HOC中，这一步将使它们可以在下一次获取调用中重用。</p><h1 id="be56" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">特别创作</h1><p id="7599" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">现在，让我们创建特设。用前缀“with”来调用HOC是可以接受的，就像我们的例子中的“withAxiosRequest”。</p><p id="4905" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该文件可以创建在。/hoc/withAxiosRequest。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4cba" class="nj mh iq nf b gy nk nl l nm nn">const withAxiosRequest = (OriginalComponent) =&gt; {<br/>  return class extends React.Component {<br/>    <br/>    state = { isLoading: false};    createRequest = async (params: {url:string}) =&gt; {<br/>      try {<br/>        this.setState({ ...this.state, isLoading: true });        response = await axios.get(params.url).then((res) =&gt; res);        this.setState({...this.state, isLoading: false});<br/>       return response;<br/>      } catch (error) {<br/>        this.setState({ ...this.state, isLoading: false });<br/>        return false;<br/>    }<br/>  }  render() {<br/>    return (<br/>    &lt;&gt;<br/>      &lt;Loader isLoading={this.state.isLoading} /&gt;<br/>      &lt;OriginalComponent {...this.props}<br/>       createRequest = {this.createRequest}<br/>      /&gt;<br/>    &lt;/&gt;)<br/>  }<br/> }<br/>}export default withAxiosRequest;</span></pre><p id="fa35" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">自组织网络接收原始组件，并发回具有更多功能的新组件。</p><p id="cd96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该功能是可重用的<code class="fe no np nq nf b">createRequest</code>功能。现在，每当我们用<code class="fe no np nq nf b">withAxiosRequest</code> HOC封装一个组件时，我们可以使用<code class="fe no np nq nf b">createRequest</code>函数。</p><p id="32c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">被包装的组件现在包含了<code class="fe no np nq nf b">Loader</code>组件，所以任何带有<code class="fe no np nq nf b">createRequest</code>的获取调用都会自动激活<code class="fe no np nq nf b">Loader</code>组件。</p><p id="5d73" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>这个例子只让您获取数据，您可以改进这个概念来支持POST、DELETE、PUT等等。</p><h1 id="0a0f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">最后一步</h1><p id="b4f4" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">最后一步是用<code class="fe no np nq nf b">withAxiosRequest</code> HOC包装我们的<code class="fe no np nq nf b">ListOfUsers</code>组件。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c919" class="nj mh iq nf b gy nk nl l nm nn">function ListOfUsers = ({createRequest})=&gt; {<br/>  const [users, setUsers] = useState([]);useEffect(()=&gt;{<br/>  (<br/>    async ()=&gt;{<br/>      const users = await createRequest({url:GET_USERS_URL});<br/>      setUsers(users);<br/>    }<br/>  )();<br/>  },[])render(<br/>  &lt;View&gt;<br/>    users.length ?<br/>      users.map((user) =&gt; &lt;UserCard user={user}/&gt;) :<br/>      &lt;Text&gt;No users&lt;/Text&gt;<br/>  &lt;/View&gt;<br/>  )<br/>}<br/>export default withAxiosRequest(ListOfUsers);</span></pre><p id="6540" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，我们可以在<code class="fe no np nq nf b">ListOfUsers</code>组件中接收函数<code class="fe no np nq nf b">createRequest</code>作为道具，因此我们不再需要<code class="fe no np nq nf b">ListOfUsers</code>组件中的axios请求。</p><p id="0366" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认情况下，我们包装的组件现在包含了<code class="fe no np nq nf b">Loader</code>组件，所以我们不再需要<code class="fe no np nq nf b">ListOfUsers</code>组件中的<code class="fe no np nq nf b">Loader</code>组件。</p><h1 id="dbd4" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="80eb" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在这个例子中，我们看到了HOC通过使用<code class="fe no np nq nf b">createRequest</code>函数使我们的代码更短和可重用的能力，以及在我们选择包含的每个组件中包含<code class="fe no np nq nf b">Loader</code>组件的能力。</p><p id="e727" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">高阶组件使您的代码更加抽象，一旦您掌握了它，您可能会过于频繁地使用这种模式。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="43e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">感谢您迄今为止的阅读，</strong>如果您喜欢这样的内容，并且您想支持我作为一名程序员和作家撰写更多这样的文章，<a class="ae lr" href="https://medium.com/membership/@nissimzarur" rel="noopener"> <strong class="kx ir"> <em class="nd">请使用我的链接注册Medium成为会员(每月订阅5美元)，您将可以无限制地访问Medium上的所有内容。</em> </strong> </a></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="8881" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请继续关注更多React本地示例和技巧。</p><p id="1c50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nd">更多内容请看</em><a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nd">plain English . io</em></strong></a><em class="nd">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="nd">免费周报</em> </strong> </a> <em class="nd">。关注我们关于</em><a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nd">Twitter</em></strong></a><em class="nd">和</em><a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nd">LinkedIn</em></strong></a><em class="nd">。查看我们的</em> <a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="nd">社区不和谐</em> </strong> </a> <em class="nd">加入我们的</em> <a class="ae lr" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="nd">人才集体</em> </strong> </a> <em class="nd">。</em></p></div></div>    
</body>
</html>