<html>
<head>
<title>Understanding Prototypes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的原型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-prototypes-in-javascript-3629ee0439a2?source=collection_archive---------12-----------------------#2022-11-21">https://javascript.plainenglish.io/understanding-prototypes-in-javascript-3629ee0439a2?source=collection_archive---------12-----------------------#2022-11-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/98dec28ecd1e24d522343ccd8dc6d3b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CeusRf4v93SZ2w_LZ2AMg.png"/></div></div></figure><p id="ca47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在编程中，我们经常想要获取一些东西并对其进行扩展。</p><p id="12f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，我们有一个带有属性和方法的<code class="fe kt ku kv kw b">animal</code>对象。我们想在<code class="fe kt ku kv kw b">animal</code>之上制作具有特定属性和方法的<code class="fe kt ku kv kw b">cat</code>和<code class="fe kt ku kv kw b">dog</code>对象。我们想重用我们在<code class="fe kt ku kv kw b">animal</code>中的东西，而不是复制/重新实现它的方法，只是在它的基础上建立一个新的对象。</p><p id="751f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原型是JavaScript中的底层特性，它使得对象之间可以继承和共享属性。</p><p id="b666" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了正确使用原型，我们需要理解它们到底是什么，以及它们如何帮助继承。</p><h1 id="5cb2" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是原型</h1><p id="1e1e" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">在JavaScript中，每个对象都有一个名为<code class="fe kt ku kv kw b">[[prototype]]</code>的隐藏内部属性，要么引用另一个对象，要么为空。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/2cd343f60e17f821f5616580eac5f295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmUut3vWq5UnZmwId0r4BA.png"/></div></div></figure><p id="84ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript使用原型继承。也就是说，每当你试图访问一个对象的属性时。</p><ol class=""><li id="60f3" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated">它首先检查对象本身的属性。</li><li id="41f1" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated">如果在那里找不到，就在对象的原型中搜索属性。</li><li id="8c1f" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated">如果它也不能到达那里，则搜索原型的原型，依此类推，直到找到属性，或者到达链的末端，在这种情况下返回<code class="fe kt ku kv kw b">undefined</code>。</li></ol><p id="74d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">[[prototype]]</code> field是一个隐藏字段，但是我们可以用几种方法来设置它。</p><ol class=""><li id="129d" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated"><code class="fe kt ku kv kw b">obj.__proto__</code>:属性<code class="fe kt ku kv kw b">__proto__</code>已被弃用，不应再使用。</li><li id="b079" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated"><code class="fe kt ku kv kw b">Object.setPrototypeOf(obj, proto)</code>:将<code class="fe kt ku kv kw b">obj</code>的<code class="fe kt ku kv kw b">[[Prototype]]</code>设置为<code class="fe kt ku kv kw b">proto</code>。</li><li id="8b40" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated"><code class="fe kt ku kv kw b">Object.create(proto, [descriptors])</code>:用给定的<code class="fe kt ku kv kw b">proto</code>作为<code class="fe kt ku kv kw b">[[Prototype]]</code>和可选的属性描述符创建一个空对象。</li></ol><p id="b1f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Object.create</code>方法更加强大，因为它有一个可选的第二个参数:属性描述符。此外，用<code class="fe kt ku kv kw b">Object.setPrototypeOf</code>或<code class="fe kt ku kv kw b">obj.__proto__</code>动态改变原型是一个非常慢的操作，因为它破坏了对象属性访问操作的内部优化。</p><p id="dc47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于这些原因，我们将在本文的其余部分使用<code class="fe kt ku kv kw b">Object.create</code>方法。</p><pre class="mb mc md me gt mt kw mu bn mv mw bi"><span id="0bb1" class="mx ky in kw b be my mz l na nb">let animal = {<br/>  eats: true<br/>};<br/><br/>let cat = Object.create(animal, {<br/>  meows: {<br/>    value: true<br/>  }<br/>});<br/><br/>// we can find both properties in cat now:<br/>console.log(cat.eats); // true <br/>console.log(cat.meows); // true</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/d2db0838ac77798d81df6114989e7f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*Cxy55_0pamtNP_c_0eAG3A.png"/></div></figure><p id="06c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以看到，当我们试图读取不在<code class="fe kt ku kv kw b">cat</code>中的<code class="fe kt ku kv kw b">cat.eats</code>时，JavaScript会跟随<code class="fe kt ku kv kw b">[[Prototype]]</code>引用并在<code class="fe kt ku kv kw b">animal</code>中找到它。</p><p id="f12f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以说<code class="fe kt ku kv kw b">animal</code>是<code class="fe kt ku kv kw b">cat</code>的原型，或者说<code class="fe kt ku kv kw b">cat</code>原型继承了<code class="fe kt ku kv kw b">animal</code>。</p><p id="f875" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是原型的强大之处。如果<code class="fe kt ku kv kw b">animal</code>有很多有用的属性和方法，那么它们在<code class="fe kt ku kv kw b">cat</code>中会自动可用。</p><p id="2233" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，对象只能有一个<code class="fe kt ku kv kw b">[[Prototype]]</code>。他们只能继承一个。</p><h1 id="bed2" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">原型不用于写作</h1><p id="8b0a" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">原型仅用于读取属性。写/删除操作直接处理对象。</p><p id="0267" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下面的例子中，我们将自己的<code class="fe kt ku kv kw b">dangerous</code>属性分配给<code class="fe kt ku kv kw b">cat</code>。</p><pre class="mb mc md me gt mt kw mu bn mv mw bi"><span id="56c5" class="mx ky in kw b be my mz l na nb">let animal = {<br/>  eats: true,<br/>  dangerous: true<br/>};<br/><br/>let cat = Object.create(animal, {<br/>  meows: {<br/>    value: true<br/>  }<br/>});<br/><br/>console.log(animal.dangerous); // true<br/><br/>// Updating cat object<br/>cat.dangerous = false; <br/><br/>console.log(animal.dangerous); // true<br/>console.log(cat.dangerous); // false</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi gj"><img src="../Images/80253f9763524dfae53224830f5a9722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crn5gdw8JAu-DXE9UbYwVA.png"/></div></div></figure><p id="3080" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从现在开始，<code class="fe kt ku kv kw b">cat.dangerous</code> call直接在对象中查找属性并执行，不使用原型。</p><h1 id="fd10" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">“这个”有什么价值？</h1><p id="30b3" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">考虑下面的例子。</p><pre class="mb mc md me gt mt kw mu bn mv mw bi"><span id="a723" class="mx ky in kw b be my mz l na nb">let animal = {<br/>  eats: true,<br/>  doesItEat: function() {<br/>    return this.eats;<br/>  }<br/>  <br/>};<br/><br/>let cat = Object.create(animal, {<br/>  meows: {<br/>    value: true<br/>  }<br/>});<br/><br/>cat.eats = false;<br/><br/>console.log(animal.doesItEat()); // true<br/>console.log(cat.doesItEat()); // false</span></pre><p id="91c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可能会出现一个有趣的问题，那就是行<code class="fe kt ku kv kw b">return this.eats</code>中<code class="fe kt ku kv kw b">this</code>的值是什么。是<code class="fe kt ku kv kw b">animal</code>还是<code class="fe kt ku kv kw b">cat</code>？</p><p id="e71e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">答案很简单:<code class="fe kt ku kv kw b">this</code>永远是点之前的对象。完全不受原型的影响。</p><p id="37fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以线<code class="fe kt ku kv kw b">cat.eats = false</code>使用<code class="fe kt ku kv kw b">cat</code>作为<code class="fe kt ku kv kw b">this</code>而不是<code class="fe kt ku kv kw b">animal</code>。</p><p id="2dad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总而言之，当继承对象运行继承的方法时，它们将只修改自己的状态，而不是父对象的状态。</p><h1 id="eaf4" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">原型在for…in循环中的作用</h1><p id="92dd" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated"><code class="fe kt ku kv kw b">for..in</code>循环也遍历继承的属性。</p><pre class="mb mc md me gt mt kw mu bn mv mw bi"><span id="a087" class="mx ky in kw b be my mz l na nb">let animal = {<br/>  eats: true<br/>};<br/><br/>let cat = Object.create(animal, {<br/>  meows: {<br/>    value: true,<br/>    enumerable: true<br/>  }<br/>});<br/><br/><br/>// for..in loops over both own and inherited keys<br/>for(let prop in cat) console.log(prop); // meows, eats</span></pre><p id="164a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们想排除继承的属性，我们可以使用一个内置方法<code class="fe kt ku kv kw b">obj.hasOwnProperty(key)</code>，如果<code class="fe kt ku kv kw b">key</code>是它自己的属性(不是继承的),它将返回<code class="fe kt ku kv kw b">true</code>。</p><pre class="mb mc md me gt mt kw mu bn mv mw bi"><span id="3d11" class="mx ky in kw b be my mz l na nb">let animal = {<br/>  eats: true<br/>};<br/><br/>let cat = Object.create(animal, {<br/>  meows: {<br/>    value: true,<br/>    enumerable: true<br/>  }<br/>});<br/><br/>for(let prop in cat) {<br/>  let isOwn = cat.hasOwnProperty(prop);<br/><br/>  if (isOwn) {<br/>    console.log(`Our: ${prop}`); // Our: meows<br/>  } else {<br/>    console.log(`Inherited: ${prop}`); // Inherited: eats<br/>  }<br/>}</span></pre><h1 id="24a0" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><a class="ae nd" href="https://javascript.info/prototype-inheritance#summary" rel="noopener ugc nofollow" target="_blank">总结</a></h1><ul class=""><li id="9008" class="mf mg in jx b jy lv kc lw kg ne kk nf ko ng ks nh ml mm mn bi translated">所有对象都有一个隐藏的<code class="fe kt ku kv kw b">[[Prototype]]</code>属性，要么引用另一个对象，要么是<code class="fe kt ku kv kw b">null</code>。</li><li id="fb33" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks nh ml mm mn bi translated">如果我们想读取一个属性或者调用一个对象的方法，如果它不存在，那么JavaScript试图在它的原型链中找到它。</li><li id="d186" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks nh ml mm mn bi translated">写/删除操作不涉及原型，它直接作用于对象。</li><li id="57ed" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks nh ml mm mn bi translated"><code class="fe kt ku kv kw b">this</code>的值总是调用函数的对象。</li><li id="af9d" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks nh ml mm mn bi translated"><code class="fe kt ku kv kw b">for..in</code>循环遍历它自己的和它继承的属性。</li></ul><p id="1b35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">耶，你已经走到尽头了。希望你今天的概念有点清楚了。敬请关注更多此类帖子。</p><p id="7be6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ni">如果你喜欢这个，请看看我的其他作品</em></strong><a class="ae nd" href="https://tahajiru.start.page/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ni"/></strong></a><strong class="jx io"><em class="ni">。</em>T15】</strong></p><p id="a8de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ni">更多内容请看</em> <a class="ae nd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ni">说白了就是</em> </strong> </a> <em class="ni">。报名参加我们的</em> <a class="ae nd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ni">免费每周简讯</em> </strong> </a> <em class="ni">。关注我们</em> <a class="ae nd" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ni">推特</em> </strong> </a>，<a class="ae nd" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ni">领英</em> </strong> </a> <strong class="jx io"> <em class="ni">，</em></strong><a class="ae nd" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ni">YouTube</em></strong></a><strong class="jx io"><em class="ni">，</em></strong><em class="ni"/><a class="ae nd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><strong class="jx io"><em class="ni">不和</em> </strong> <em class="ni">对成长黑客感兴趣？检查出</em> <a class="ae nd" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ni">电路</em> </strong> </a> <strong class="jx io"> <em class="ni">。</em>T83】</strong></strong></a></p></div></div>    
</body>
</html>