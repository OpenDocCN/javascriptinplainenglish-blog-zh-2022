<html>
<head>
<title>Runtime Data Validation in TypeScript using Decorators and Reflection Metadata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用装饰器和反射元数据在TypeScript中进行运行时数据验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5?source=collection_archive---------16-----------------------#2022-03-09">https://javascript.plainenglish.io/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5?source=collection_archive---------16-----------------------#2022-03-09</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="1e99" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">运行时数据的自动、简单、验证变得容易</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/8622f03c915b39cac727742256bb4684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iQBEB2v724LKKN_0.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Image by Author using logos from corresponding projects</figcaption></figure><p id="e8ce" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">TypeScript decorators允许我们拦截对访问函数和方法的调用。这让我们可以监视传递给任一类型函数的数据，甚至为任何缺失的数据提供默认值。这种方法的一个实际用途是自动验证到达访问器或方法的数据。通过检测这些函数，验证包可以充当看门人，确保对象中的数据总是正确的。</p></div><div class="ab cl ls lt hv lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ik il im in io"><p id="d60b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在本文中，我们将探索使用TypeScript decorators实现自动数据验证。结果将是对象，我们将在其中为属性或调用方法分配数据，验证数据，如果提供了无效值，将抛出异常。TypeScript为JavaScript带来了编译时类型检查和验证，但在运行时没有这样的行为。</p><p id="9be4" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们知道很多人会提出异议。也就是说，普遍认为运行时数据验证会由于额外的代码而导致膨胀，并降低执行速度，因为每个数据访问都是经过验证的。让我们从一开始就解决这个问题。</p><p id="a390" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">显然，这是一个合理的担忧。数据验证需要执行额外的代码来检查数据值，需要更多的代码内存和执行时间。但是，考虑三件事:</p><ol class=""><li id="a32c" class="lz ma ir ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated"><em class="mi">防御性编码</em>，包括编写函数的输入端，以正确处理任何坏的或不可信的数据。</li><li id="51a2" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr me mf mg mh bi translated"><em class="mi">类型守卫函数</em>是由TypeScript团队推荐的一种实现防御性编码的方法。建议为每种类型创建这些函数，用它们来检查传入的数据。</li><li id="b795" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr me mf mg mh bi translated">通过<em class="mi">选择关键路径</em>进行数据验证，我们可以最小化开销。</li></ol><p id="3c88" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">类型保护函数是我们被警告的开销或膨胀的一个例子。通过开发类型保护函数，我们可以在使用数据之前对其进行验证，这将减少应用程序中的错误并提高稳定性。但是，每种类型保护都会增加要维护的代码量、运行进程的内存大小和执行时间。</p><p id="fc42" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这就是刚才提到的权衡。类型保护功能增加了代码大小和执行时间，同时提高了应用程序的质量。</p><p id="37fa" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">通过智能地选择哪些代码路径将使用或不使用数据验证，可以减少开销。</p><h1 id="ed46" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">防御性编码的好处</h1><p id="90a5" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">我第一次听说<em class="mi">防御性编码</em>的概念是在经典编程书《Kernighan和Plauger的编程风格的<em class="mi">元素》中。在这种情况下，Kernighan就是帮助开发了<em class="mi"> C </em>编程语言和<em class="mi"> UNIX </em>操作系统的同一个人。第5章，<em class="mi">输入和输出</em>，以一篇新闻文章开始，描述了一个在印第安纳州Woonsocket的城市雇员如何犯了一个“键入”(又名数据输入)错误，使该市损失了29万美元的税收。在那个时间段，1972年，数据是通过穿孔卡片上的按键输入的，这当然是你们大多数人没有经历过的遥远的记忆。真正的问题是检测数据输入错误，并认识到数据输入问题在今天和那时一样可能存在。</em></p><p id="842b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们中有多少人写过因为输入验证失败而导致错误的应用程序？</p><p id="7dd7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如果我们的应用程序由于输入验证失败而做出疯狂的事情，对我们自己或我们的业务(因此对我们的工作)有什么潜在的成本？</p><p id="b8e7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要正确看待这个问题，请看:https://xkcd.com/327/被人们称为博比·博比·博比。</p><p id="c4d8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">使用防御性编码，在使用输入数据之前对其进行检查和验证，是一个非常好的想法。类型保护函数是防御性编码的优秀工具。guard函数可以编写一次并使用一千次，而不是到处重新实现数据验证。开发人员必须记住在任何需要的地方调用类型保护。开发人员可能会忘记在关键路径上使用类型保护，再次冒着由于验证数据失败而导致疯狂行为的风险。</p></div><div class="ab cl ls lt hv lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ik il im in io"><p id="3d0a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">考虑一个类</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="29e5" class="nr mp ir nn b gz ns nt l nu nv">class CarLicense {<br/>     #make: string;</span><span id="9794" class="nr mp ir nn b gz nw nt l nu nv">     set make(nt: string) { this.#make = nt; }<br/>     get make() { return this.#make; }</span><span id="8187" class="nr mp ir nn b gz nw nt l nu nv">     #model: string;</span><span id="1863" class="nr mp ir nn b gz nw nt l nu nv">     set model(nm: string) { this.#model = nm; }<br/>     get model() { return this.#model; }</span><span id="fac4" class="nr mp ir nn b gz nw nt l nu nv">     #year: number;</span><span id="bb4b" class="nr mp ir nn b gz nw nt l nu nv">     set year(ny: number) { this.#year = ny; }<br/>     get year() { return this.#year; }</span><span id="9f8e" class="nr mp ir nn b gz nw nt l nu nv">     #vin: string;</span><span id="e74e" class="nr mp ir nn b gz nw nt l nu nv">     set vin(nv: string) { this.#vin = nv; }<br/>     get vin() { return this.#vin; }</span><span id="6616" class="nr mp ir nn b gz nw nt l nu nv">     #license: string;</span><span id="88a7" class="nr mp ir nn b gz nw nt l nu nv">     set license(nl: string) { this.#license = nl; }<br/>     get license() { return this.#license; } <br/>}</span></pre><p id="2a57" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这些是汽车的一些重要属性。正确识别汽车的所有属性非常重要。这些属性中的大多数都有已知的值——制造商名称、型号名称、VIN号码格式和牌照格式。核实这些事情很容易。但是目前的代码没有验证任何东西。这意味着这个类的一个实例可能持有不正确的数据，而应用程序无法知道。</p><p id="8c0b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我的建议是，在这些属性的<code class="fe nx ny nz nn b">set</code>端，安装数据验证。使用装饰函数，我们可以可靠地覆盖<code class="fe nx ny nz nn b">set</code>方法，因此知道分配给这些字段的每个值都是正确的。因为数据存储在JavaScript私有属性中，赋予它新值的唯一途径是通过<code class="fe nx ny nz nn b">set</code>方法。因此，安装在该方法上的验证将确保只存储正确的、经过验证的数据。</p><p id="228b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">换句话说，如果验证可以像在访问器函数中添加相应的装饰器一样简单，那会怎么样呢？像<code class="fe nx ny nz nn b">@IsIn([ 'Ford', 'GM', 'Chevy', 'Tesla', ... ])</code>这样的装饰者可以在已知名称列表中验证汽车制造商名称，或者使用<code class="fe nx ny nz nn b">@IsIntRange(1920, 2030)</code>验证车型年份。</p><p id="f382" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在本文中，我们将展示如何使用TypeScript decorators实现运行时数据验证。验证将自动在访问器函数的<code class="fe nx ny nz nn b">set</code>端执行，并将参数传递给类方法。只有附加了验证修饰符的访问器或方法才会进行验证。</p><p id="5f08" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文是系列文章的一部分:</p><ul class=""><li id="274f" class="lz ma ir ky b kz la lc ld lf mb lj mc ln md lr oa mf mg mh bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">装修工介绍</a></li><li id="e460" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><a class="ae nl" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装修工</a></li><li id="701d" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">物业装修工</a></li><li id="51b5" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">访问器装饰器</a></li><li id="774b" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-parameter-decorators-in-typescript-b0042b5474ed">参数装饰器</a></li><li id="a94f" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">方法装饰者</a></li><li id="ea17" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0">混合装修工</a></li><li id="424a" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7">反射和带装饰器的反射API</a></li><li id="c0d1" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><strong class="ky is">运行时数据验证在TypeScript中使用装饰器和反射元数据</strong> <em class="mi">本文</em></li></ul><p id="2536" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要使用decorator，必须在TypeScript中启用两个特性，所以请务必阅读本系列的decorator介绍文章。</p><h1 id="e1f8" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">检查访问器、方法和参数修饰符</h1><p id="2ed7" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">所需的核心技术是覆盖附加到PropertyDescriptor对象的函数。访问器装饰函数和方法装饰函数都提供与被装饰对象相关的属性描述符。在这两种情况下，对象都有函数，我们可以用自己的函数替换它们。具体来说:</p><ul class=""><li id="e431" class="lz ma ir ky b kz la lc ld lf mb lj mc ln md lr oa mf mg mh bi translated">访问器装饰器在<code class="fe nx ny nz nn b">get</code>和<code class="fe nx ny nz nn b">set</code>字段中有函数。为了处理数据验证，我们用一个执行数据验证的函数覆盖了<code class="fe nx ny nz nn b">set</code>函数。参见<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">TypeScript</a>中对访问器装饰器的深入介绍</li><li id="4246" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated">方法装饰者在<code class="fe nx ny nz nn b">value</code>字段中有一个函数。要处理数据验证，用一个扫描参数的函数覆盖它，验证任何已经给定了验证装饰器的参数。参见<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">对TypeScript </a>中方法装饰器的深入介绍</li></ul><p id="4694" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这需要三组装饰函数:</p><ul class=""><li id="e451" class="lz ma ir ky b kz la lc ld lf mb lj mc ln md lr oa mf mg mh bi translated">可以附加到访问函数或方法参数的验证装饰器。这些描述了它们附加到的对象所需的验证</li><li id="83b4" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><code class="fe nx ny nz nn b">@ValidateAccessor&lt;type&gt;()</code> -附加到访问器上，也就是附加覆盖函数的部分，覆盖函数反过来执行验证</li><li id="f75e" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><code class="fe nx ny nz nn b">@ValidateParams</code> -附加到方法上，也就是附加覆盖函数的部分，覆盖函数反过来执行验证</li></ul><p id="acb0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">作为参考，在<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">对TypeScript </a>中的访问器装饰器的深入介绍中有一个简单的数据验证示例</p><p id="fc3a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">最后要考虑的是让验证装饰器能够附加到<code class="fe nx ny nz nn b">set</code>访问器或方法参数上。我们在<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0">在TypeScript中实现混合装饰函数</a>中讨论了实现技术</p><h1 id="caf0" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">运行时数据验证的状态</h1><p id="c9c1" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">有几个处理运行时数据验证的包。其中包括<a class="ae nl" href="https://www.npmjs.com/package/joi" rel="noopener ugc nofollow" target="_blank">乔伊</a>、<a class="ae nl" href="https://www.npmjs.com/package/ajv" rel="noopener ugc nofollow" target="_blank"> AJV </a>和<a class="ae nl" href="https://www.npmjs.com/package/zod" rel="noopener ugc nofollow" target="_blank">佐德</a>。all的一个问题是我前面提到的，程序员必须记得添加数据验证，但可能会忘记这样做。</p><p id="ae8d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe nx ny nz nn b"><a class="ae nl" href="https://www.npmjs.com/package/class-validator" rel="noopener ugc nofollow" target="_blank">class-validator</a></code>包使用附加到属性的装饰器。在开发下述软件包时，该软件包是一个灵感来源。然而，程序员必须记得调用它的<code class="fe nx ny nz nn b">validate</code>或<code class="fe nx ny nz nn b">validateOrReject</code>方法。</p><p id="60ef" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">一个包<code class="fe nx ny nz nn b"><a class="ae nl" href="https://www.npmjs.com/package/validator" rel="noopener ugc nofollow" target="_blank">validator</a></code>，有一个很长的验证函数列表。<code class="fe nx ny nz nn b">class-validator</code>包使用了这个包中的验证函数。下面将要描述的包也是如此。</p><p id="17e6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文描述了一个不同的包，<code class="fe nx ny nz nn b"><a class="ae nl" href="https://www.npmjs.com/package/runtime-data-validation" rel="noopener ugc nofollow" target="_blank">runtime-data-validation</a></code>。它包含了一长串数据验证装饰器，并支持在使用类属性和方法的正常过程中自动执行数据验证。</p><h1 id="4a1c" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">测试类</h1><p id="7332" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">我们将使用这个类定义作为测试用例:</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="9359" class="nr mp ir nn b gz ns nt l nu nv">class ValidateExample {<br/>     #year: number;</span><span id="8b0d" class="nr mp ir nn b gz nw nt l nu nv">     @ValidateAccessor&lt;number&gt;()<br/>     @IsIntRange(1990, 2050)<br/>     @IsInt()<br/>     set year(ny: number | string) {<br/>         this.#year = ToInt(ny);<br/>     }<br/>     get year() { return this.#year; }</span><span id="9246" class="nr mp ir nn b gz nw nt l nu nv">     @ValidateParams<br/>     area(<br/>         @IsFloatRange(0, 1000) width: number | string,<br/>         @IsFloatRange(0, 1000) height: number | string<br/>     ) {<br/>         return ToFloat(width) * ToFloat(height);<br/>     }<br/>}</span></pre><p id="9dea" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">有一个访问器对覆盖了<code class="fe nx ny nz nn b">year</code>属性。我们把它定义为1990年到2050年之间的一个整数。还有一个名为<code class="fe nx ny nz nn b">area</code>的函数，它使用<code class="fe nx ny nz nn b">width</code>和<code class="fe nx ny nz nn b">height</code>来计算面积。两者都被定义为<code class="fe nx ny nz nn b">0</code>和<code class="fe nx ny nz nn b">1000</code>之间的浮点值。</p><p id="e58d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们将参数定义为<code class="fe nx ny nz nn b">number | string</code>，因为我们经常从可能包含数字的字符串表示的数据源中读取数据。验证装饰者必须注意识别这两种格式的数字。此外，我们使用<code class="fe nx ny nz nn b">ToInt</code>和<code class="fe nx ny nz nn b">ToFloat</code>将可能的字符串值转换为数字。</p><p id="eddc" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe nx ny nz nn b">@ValidateParams</code>装饰器将寻找附属于参数的装饰器。同样的，<code class="fe nx ny nz nn b">@ValidateAccessor</code> decorator将寻找附加到访问器的其他decorator。在这两种情况下，它将覆盖PropertyDescriptor中的正确函数，以便可以验证这些值。</p><h1 id="96e8" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">实现混合验证装饰器</h1><p id="1355" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">我们有两种装饰函数要实现:</p><ul class=""><li id="af4e" class="lz ma ir ky b kz la lc ld lf mb lj mc ln md lr oa mf mg mh bi translated"><em class="mi">验证装饰器</em>必须能够附加到访问器或者方法参数。</li><li id="bd2f" class="lz ma ir ky b kz mj lc mk lf ml lj mm ln mn lr oa mf mg mh bi translated"><em class="mi">执行装饰器</em>是<code class="fe nx ny nz nn b">@ValidateParams</code>，附加在方法上，和<code class="fe nx ny nz nn b">@ValidateAccessor</code>，附加在访问器上。</li></ul><p id="9a65" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于验证装饰器，我们在关于混合装饰器的文章中讨论了一种技术。在那篇文章中，我们开发了五个函数，用于确定装饰器附加到哪种对象上。这些功能可以从<code class="fe nx ny nz nn b"><a class="ae nl" href="https://www.npmjs.com/package/decorator-inspectors" rel="noopener ugc nofollow" target="_blank">decorator-inspectors</a></code>包中获得。</p><p id="4d48" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这意味着实现类似于:</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="fb16" class="nr mp ir nn b gz ns nt l nu nv">import {<br/>     isClassDecorator, isPropertyDecorator, isParameterDecorator,<br/>     isMethodDecorator, isAccessorDecorator <br/>} from 'decorator-inspectors';  </span><span id="f839" class="nr mp ir nn b gz nw nt l nu nv">function IsFloatRange(min: number, max: number) {<br/>   return (target: Object,<br/>      propertyKey?: string | symbol,<br/>      descriptor?: number | PropertyDescriptor) =&gt; {</span><span id="a029" class="nr mp ir nn b gz nw nt l nu nv">      if (isAccessorDecorator(target, propertyKey, descriptor)) {<br/>         // Record in metadata a function to check that<br/>         // a value is within range<br/>      } else if (isParameterDecorator(target, propertyKey, descriptor)) {<br/>         // Record in metadata a function to check that<br/>         // a value is within range<br/>     }<br/>  } <br/>}</span></pre><p id="66d7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是一个装饰工厂函数。外部函数接受参数<code class="fe nx ny nz nn b">min</code>和<code class="fe nx ny nz nn b">max</code>，定制这个装饰器的行为。内部函数是实际的装饰器。这个函数的签名是我们在研究混合装饰器时确定的，它让我们创建一个可以附加到任何可装饰对象的装饰器。通过这五个<code class="fe nx ny nz nn b">isXYZZYDecorator</code>函数，我们确定了使用这个装饰器的上下文，然后为每个上下文做正确的事情。</p><p id="753c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">换句话说，装饰函数必须测试它是如何被使用的，并对每个上下文采取正确的动作。</p><p id="35db" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">但是，以这种方式实现大量混合装饰函数是不可伸缩的。考虑到<code class="fe nx ny nz nn b">validator</code>包中验证函数的数量，我们需要一个更紧凑的实现，特别是因为会有很多重复的代码。</p><h1 id="1cc5" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">验证装饰器实现</h1><p id="a372" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">在<a class="ae nl" href="https://www.npmjs.com/package/runtime-data-validation" rel="noopener ugc nofollow" target="_blank">运行时数据验证</a>包中，我想到的是让外部装饰函数遵循这种模式:</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="9d94" class="nr mp ir nn b gz ns nt l nu nv">export function IsInt() {<br/>     // console.log(`params.IsInt`);<br/>     return generateValidationDecorator(<br/>                 (value) =&gt; numbers.IsInt(value),<br/>                 `Value :value: not an integer`); <br/>}</span></pre><p id="625b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">内部函数由<code class="fe nx ny nz nn b">generateValidationDecorator</code>封装，依次带两个参数。一个是验证函数的核心，另一个是在抛出的错误中使用的消息。在这种情况下，<code class="fe nx ny nz nn b">numbers.IsInt</code>是内部模块中处理验证的函数。</p><p id="1c67" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在<code class="fe nx ny nz nn b">generateValidationDecorator</code>中，我们测试这是哪种装饰器:</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="b26a" class="nr mp ir nn b gz ns nt l nu nv">export function generateValidationDecorator(<br/>                 validator: Function, message: string) {<br/>   return (target: Object, propertyKey?: string | symbol,<br/>       descriptor?: number | PropertyDescriptor) =&gt; {</span><span id="c1a3" class="nr mp ir nn b gz nw nt l nu nv">       if (isAccessorDecorator(target, propertyKey, descriptor)) {<br/>           generateAccessorDecorator(validator, message,<br/>                     target, propertyKey,<br/>                     &lt;PropertyDescriptor&gt;descriptor);<br/>       } else if (isParameterDecorator(target, propertyKey,<br/>                                       descriptor)) {<br/>           generateParameterDecorator(validator, message,<br/>                     target, propertyKey, &lt;number&gt;descriptor);<br/>       }<br/>   } <br/>}</span></pre><p id="8dd2" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于访问器装饰器，我们使用<code class="fe nx ny nz nn b">generateAccessorDecorator</code>，否则使用<code class="fe nx ny nz nn b">generateParameterDecorator</code>。每个都包含特定于每个装饰器类型的代码。</p><p id="a9b8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">由于<code class="fe nx ny nz nn b">descriptor</code>既可以是<code class="fe nx ny nz nn b">number</code>也可以是<code class="fe nx ny nz nn b">PropertyDescriptor</code>，我们根据调用的函数将其转换为正确的类型。</p><p id="28ca" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">那么，我们来看看<code class="fe nx ny nz nn b">generateAccessorDecorator</code>:</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="f66e" class="nr mp ir nn b gz ns nt l nu nv">function generateAccessorDecorator(<br/>                  validator: Function, message: string,<br/>                  target: Object, propertyKey: string | symbol,<br/>                  descriptor: PropertyDescriptor) {</span><span id="1878" class="nr mp ir nn b gz nw nt l nu nv">     let existing = Reflect.getMetadata(ACCESSOR_VALIDATORS,<br/>                 target, propertyKey)<br/>         || [];<br/>     const vfunc = function(value) {<br/>         if (!validator(value)) {<br/>             throw new Error(<br/>                 message.replace(':value:',<br/>                     util.inspect(value)));<br/>         }<br/>     };<br/>     if (!existing) {<br/>         existing = [ vfunc ];<br/>     } else {<br/>         existing.push(vfunc);<br/>     }<br/>     // Store metadata<br/>     Reflect.defineMetadata(ACCESSOR_VALIDATORS,<br/>         existing, target, propertyKey);<br/>}</span></pre><p id="3622" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是我们进入正题的地方。装饰器被附加到由<code class="fe nx ny nz nn b">target</code>和<code class="fe nx ny nz nn b">propertyKey</code>标识的对象上。我们使用<code class="fe nx ny nz nn b">Reflect.getMetadata</code>将验证器函数存储在目标对象的<code class="fe nx ny nz nn b">ACCESSOR_VALIDATORS</code>元数据中。我们生成一个执行验证器函数的函数，传递一个值，如果验证器指示<code class="fe nx ny nz nn b">false</code>，那么就会抛出一个错误。这个函数被推入一个数组，然后被添加回<code class="fe nx ny nz nn b">ACCESSOR_VALIDATORS</code>元数据。</p><p id="d247" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">换句话说，对于由<code class="fe nx ny nz nn b">target</code>和<code class="fe nx ny nz nn b">propertyKey</code>标识的访问器，我们维护一个名为<code class="fe nx ny nz nn b">ACCESSOR_VALIDATORS</code>的元数据值。这包含一个验证器函数数组。目标是在<code class="fe nx ny nz nn b">set</code>函数执行之前执行这些函数来验证值，并避免在值无效时执行<code class="fe nx ny nz nn b">set</code>。</p><p id="82a7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在<code class="fe nx ny nz nn b">generateParameterDecorator</code>中，我们做了大致相同的事情，但是元数据是<code class="fe nx ny nz nn b">PARAMETER_VALIDATORS</code>。在这种情况下，<code class="fe nx ny nz nn b">target</code>和<code class="fe nx ny nz nn b">propertyKey</code>指的是包含被修饰参数的方法。</p><p id="568f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于这两种情况，都提供了验证函数。验证函数存储在反射元数据中，这就是这些函数所做的全部工作。这两个函数不能设置验证函数的执行。它们只能存储函数，以便其他代码可以设置它们的执行。</p><h1 id="d0ba" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">执行装饰器实现</h1><p id="fd13" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">对于访问器，执行由这个访问器装饰器安排:</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="2ebe" class="nr mp ir nn b gz ns nt l nu nv">export function ValidateAccessor&lt;T&gt;() {<br/>     return (target: Object, propertyKey: string,<br/>                     descriptor: PropertyDescriptor) =&gt; {</span><span id="8fcd" class="nr mp ir nn b gz nw nt l nu nv">         const originals = {<br/>             get: descriptor.get,<br/>             set: descriptor.set<br/>         };<br/>         if (originals.set) {<br/>             descriptor.set = function(newval: T) {<br/>                 let validators =<br/>                     Reflect.getMetadata(ACCESSOR_VALIDATORS,<br/>                             target, propertyKey)<br/>                     || [];<br/>                 for (const func of validators) {<br/>                     func(newval);<br/>                 }<br/>                 originals.set.call(this, newval);<br/>             };<br/>         }<br/>     } <br/>}</span></pre><p id="a3c1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于访问器，我们通过附加<code class="fe nx ny nz nn b">ValidateAccessor</code>装饰器来执行验证器函数。这会得到一个<code class="fe nx ny nz nn b">PropertyDescriptor</code>对象，其中的<code class="fe nx ny nz nn b">get</code>和<code class="fe nx ny nz nn b">set</code>函数对应于<code class="fe nx ny nz nn b">get</code>和<code class="fe nx ny nz nn b">set</code>访问器。我们所做的就是将这些保存在<code class="fe nx ny nz nn b">originals</code>对象中。然后我们添加一个<code class="fe nx ny nz nn b">set</code>函数来检索<code class="fe nx ny nz nn b">ACCESSOR_VALIDATORS</code>元数据，您记得它包含这个特定目标的验证器函数。</p><p id="afee" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">注意，这个实现允许对每个目标使用多个验证函数。这样我们就可以添加任意数量的验证。</p><p id="bac4" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这个覆盖函数执行每个验证函数。如果它们都执行了，这意味着它们都没有失败，因为失败的验证会导致抛出一个错误，从而中止该函数。因此，如果全部正确执行，那么<code class="fe nx ny nz nn b">originals.set</code>被调用来执行原来的<code class="fe nx ny nz nn b">set</code>功能。</p><p id="e1d0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">现在..既然所有的访问器装饰函数都接收<code class="fe nx ny nz nn b">PropertyDescriptor</code>，那么这是否提出了为什么我们必须创建<code class="fe nx ny nz nn b">ValidateAccessor</code>的问题？</p><p id="9633" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">答案与通过<code class="fe nx ny nz nn b">ValidateAccessor</code>传递数据类型的必要性有关。注意，我们使用一个通用字段来传入一个数据类型，该数据类型在覆盖的<code class="fe nx ny nz nn b">set</code>函数中使用。这个内部函数需要使用这个数据类型。我们将无法使用验证器装饰函数来做到这一点。因此，需要<code class="fe nx ny nz nn b">ValidateAccessor</code>。</p><p id="74ea" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">查看更多关于访问器装饰器的内容:<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">TypeScript中对访问器装饰器的深入介绍</a></p><p id="0d77" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在<code class="fe nx ny nz nn b">ValidateParams</code>中，我们有一个类似的实现。不同之处在于这个装饰器被附加到方法上，从而得到一个具有不同内容的<code class="fe nx ny nz nn b">PropertyDescriptor</code>。</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="2640" class="nr mp ir nn b gz ns nt l nu nv">export function ValidateParams(<br/>     target: Object, propertyKey: string | symbol,<br/>     descriptor: PropertyDescriptor, ) {</span><span id="3f31" class="nr mp ir nn b gz nw nt l nu nv">     // Store the original value<br/>     const savedValue = descriptor.value;<br/>     // Attach validation logic<br/>     descriptor.value = function(...args: any[]) {<br/>         let validators = Reflect.getMetadata(PARAMETER_VALIDATORS,<br/>                                 target, propertyKey)<br/>                         || [];<br/>          for (const key in Object.keys(validators)) {<br/>             if (key === 'length') continue;<br/>             const funclist = validators[key];<br/>             const value = args[key];<br/>             for (const func of funclist) {<br/>                 func(value);<br/>             }<br/>         }<br/>         // Actually call the function<br/>         return savedValue.call(this, ...args);<br/>     }; <br/>}</span></pre><p id="9585" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">使用方法装饰器，<code class="fe nx ny nz nn b">value</code>字段包含方法的函数。我们保存它，然后创建一个覆盖函数。在这种情况下，我们查看为其提供了验证器函数的每个参数。对于每一个，我们获取验证器函数的列表，然后根据存储在该参数中的值运行每个验证器函数。如果都正确执行，那么我们调用原始函数，提供原始参数列表。</p><p id="1ac6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要查看更多关于方法装饰器的内容，请参见:<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">对TypeScript中方法装饰器的深入介绍</a> —对于参数装饰器，请参见:<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-parameter-decorators-in-typescript-b0042b5474ed">对TypeScript中参数装饰器的深入介绍</a></p><h1 id="c44b" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">测试运行时数据验证装饰器</h1><p id="0edf" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">要测试我们所创建的内容，请创建以下脚本:</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="5575" class="nr mp ir nn b gz ns nt l nu nv">import {<br/>     IsIntRange, IsInt, IsFloatRange, IsFloat,<br/>     ToFloat, ToInt,<br/>     Contains,<br/>     ValidateParams, ValidateAccessor<br/>} from 'runtime-data-validation';  </span><span id="4bb3" class="nr mp ir nn b gz nw nt l nu nv">// The above code - ValidateExample</span><span id="1284" class="nr mp ir nn b gz nw nt l nu nv">const ve = new ValidateExample();  <br/>ve.year = 1990; <br/>ve.year = 2000; <br/>ve.year = 2020; <br/>// ve.year = 2060; <br/>// ve.year = 1980;  <br/>console.log({<br/>     width: 10,<br/>     height: 10,<br/>     area: ve.area(10, 10) <br/>});  <br/>console.log({<br/>     width: '20',<br/>     height: '16.6',<br/>     area: ve.area('20', '16.6') <br/>});  console.log({<br/>     width: 'twenty',<br/>     height: '16.6',<br/>     area: ve.area('twenty', '16.6') <br/>});</span></pre><p id="f268" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们有几行代码给<code class="fe nx ny nz nn b">year</code>属性赋值。然后我们几次调用<code class="fe nx ny nz nn b">area</code>方法。对于每一个，我们提供有效数据和无效数据。</p><p id="4683" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">运行该程序，我们得到以下输出:</p><pre class="kh ki kj kk gu nm nn no np aw nq bi"><span id="c188" class="nr mp ir nn b gz ns nt l nu nv">$ npx ts-node lib/validation/validate2.ts  <br/>{ width: 10, height: 10, area: 100 } <br/>{ width: '20', height: '16.6', area: 332 } <br/>.../runtime-data-validation-typescript/lib/validators.ts:51<br/>             throw new Error(<br/>                   ^ <br/>Error: Value 'twenty' not a float between 0 and 1000</span></pre><p id="dcc2" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">注意，传递字符串<code class="fe nx ny nz nn b">'20'</code>和<code class="fe nx ny nz nn b">'16.6'</code>被解释为数字，结果是正确的。这是因为实现识别两个数字字符串，并在执行数学运算之前将它们转换为数字。在任何情况下，要点是这些赋值和方法调用都是经过验证的。此外，当我们确实有一个错误时，错误消息是相当有用的。</p><h1 id="49da" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">摘要</h1><p id="1f4a" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated">这表明在TypeScript中自动化运行时数据验证是可能的。该方法包括将decorators附加到访问函数和常规类方法上。这些装饰器处理对任何一个的重写调用，并确保数据满足应用程序开发人员设计的有效性约束。</p><p id="e0ea" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">因此，只要您可以通过对象中的访问器或方法来收集数据，就可以自动验证这些数据。</p><p id="16df" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文展示的技术是一个包的核心:<code class="fe nx ny nz nn b"><a class="ae nl" href="https://www.npmjs.com/package/runtime-data-validation" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/runtime-data-validation</a></code>这个包包含了一长串的验证装饰器，并且使得创建你自己的验证装饰器变得容易。</p><h1 id="c8cd" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">关于作者</h1><p id="42ec" class="pw-post-body-paragraph kw kx ir ky b kz ng js lb lc nh jv le lf ni lh li lj nj ll lm ln nk lp lq lr ik bi translated"><a class="ae nl" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mi">大卫·赫伦</em> </strong> </a> <em class="mi">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl ls lt hv lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ik il im in io"><p id="c34e" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="mi">最初发表于</em><a class="ae nl" href="https://techsparx.com/nodejs/typescript/decorators/runtime-validation.html" rel="noopener ugc nofollow" target="_blank"><em class="mi">【https://techsparx.com】</em></a><em class="mi">。</em></p><p id="0541" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="mi">更多内容看</em> <a class="ae nl" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mi">说白了。报名参加我们的</em> <a class="ae nl" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mi">免费周报</em> </strong> </a> <em class="mi">。关注我们关于</em><a class="ae nl" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky is"><em class="mi">Twitter</em></strong></a><em class="mi">和</em><a class="ae nl" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky is"><em class="mi">LinkedIn</em></strong></a><em class="mi">。加入我们的</em> <a class="ae nl" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mi">社区</em> </strong> </a> <em class="mi">。</em></strong></a></p></div></div>    
</body>
</html>