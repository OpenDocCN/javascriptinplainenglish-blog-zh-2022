<html>
<head>
<title>How to Use Web Workers in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中使用Web Workers</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-web-workers-in-react-9de15a006e89?source=collection_archive---------1-----------------------#2022-09-30">https://javascript.plainenglish.io/how-to-use-web-workers-in-react-9de15a006e89?source=collection_archive---------1-----------------------#2022-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e9a8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React生态系统中的web workers简介</h2></div><h2 id="2795" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">什么是网络工作者？</strong></h2><p id="f10d" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">web worker帮助在后台的独立线程中运行脚本，而不会干扰web应用程序的主线程。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/94f375bad6e3c97b2ece2155a3f1054f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9M2o1CnQbNj9Oj5IeME8pQ.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Web Workers in React</figcaption></figure><h2 id="1874" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">React为什么需要网络工作者？</strong></h2><p id="35b2" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">JavaScript是一种单线程语言。这意味着JavaScript有一个调用栈来一个接一个地执行任务。每个任务等待它的前一个任务被执行。因此JavaScript不能同时执行多个脚本/任务。此外，如果它执行繁重的计算脚本/任务，它将阻塞用户界面和其他功能。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mh"><img src="../Images/d60d9abcd60e7ca2595b881081404145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhDpN8Z_qiNwrMVMojg3uw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Web workers in React</figcaption></figure><p id="f8a6" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">众所周知，React是一个JavaScript库，它是按照JavaScript范式设计的。所以，它跟JavaScript的脚步是一样的。因此，我们在React中使用web workers来执行线程阻塞的繁重计算脚本。它将帮助用户与用户界面进行交互，并在没有任何中断的情况下执行其他功能。</p><p id="a8c6" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">因此，现在React可以在主线程中执行一个函数，同时，它可以在web worker支持的独立线程中执行一个脚本。因此，像JavaScript这样的内部构建为并发执行代码的编程语言现在也可以通过使用web workers来并行执行代码。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="457e" class="mu kd in bd ke mv mw mx kh my mz na kk jt nb ju ko jw nc jx ks jz nd ka kw ne bi translated">它是如何工作的</h1><p id="66f3" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">要记住的最重要的事情是我们的应用程序和web worker是两回事。它们不共享状态库和依赖库。他们只是通过某种方式相互交流。</p><p id="8ce3" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">在React应用程序中有许多使用Web workers的方法。</p><h2 id="28e9" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> 1。使用Web Workers API </strong></h2><p id="6fd2" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">我们可以使用web workers使用已经可用的<code class="fe nf ng nh ni b"><a class="ae nj" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" rel="noopener ugc nofollow" target="_blank"><strong class="la io">Web Workers API</strong></a></code>，并且可以从我们的React应用程序中使用，就像Fetch API一样。许多浏览器都支持Web Workers API，但是请检查<code class="fe nf ng nh ni b"><a class="ae nj" href="https://caniuse.com/webworkers" rel="noopener ugc nofollow" target="_blank">here</a></code>是否适合您的浏览器。</p><h2 id="501d" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">Web Workers API如何在主线程&amp;工作线程</strong>之间通信</h2><p id="3a53" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">在Web Workers API中，主线程和工作线程之间的通信使用一种简单的机制。我们需要启动一个工作者实例，并传递工作者脚本的路径。主线程必须通过使用<strong class="la io"> postMessage </strong>方法发送消息来启动连接，工作线程将使用<strong class="la io"> onmessage来监听该消息。</strong>当工作线程使用<strong class="la io"> postMessage </strong>发送消息时，主线程将使用<strong class="la io"> onmessage </strong>接收消息。此外，<strong class="la io"> onerror </strong>回调用于捕获来自工作线程的任何错误。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nk"><img src="../Images/a1fc423528a5c723a9d1062b155e1ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oK1RGS1Aj-9hF8TAwNsHyQ.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Web worker communication</figcaption></figure><p id="c5b2" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">下面的代码片段显示了使用代码执行上述流程</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nl"><img src="../Images/5c457aaedbde50d347ca129fdcbb2344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSPBAgwVZr_rz-mwFxTh2A.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Access web worker from the main thread</figcaption></figure><h2 id="467f" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> 2。使用第三方库</strong></h2><p id="ad1b" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">此外，我们可以使用像<code class="fe nf ng nh ni b"><a class="ae nj" href="https://github.com/alewin/useworker" rel="noopener ugc nofollow" target="_blank">@koale/useworker</a></code>这样的第三方库来使用web workers。该库在其实现下使用了<strong class="la io"> Web Workers API </strong>。他们给了我们一个简单的抽象层来运行一个工作者脚本。所以我们必须传递一个简单的函数，它会在工作线程上运行。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nm"><img src="../Images/35d0c69e965cd4f65352458ad5cf65df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ReGtm9v3pfB_bC3BpdeuMg.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Using @koale/web-worker library</figcaption></figure><h2 id="8f17" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">如何在浏览器中调试web worker？</h2><p id="4e97" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">当我们启动一个web worker时，会有一个worker线程在运行worker脚本后被创建和终止。我们可以在浏览器开发者工具下的<strong class="la io"> Sources </strong>标签下见证。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/74f6cae6c3c3b32d6359926057c31722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*jGhcFmvkjgRYPB-N8X5BlQ.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Sources tab under developer tool</figcaption></figure></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="50a5" class="mu kd in bd ke mv mw mx kh my mz na kk jt nb ju ko jw nc jx ks jz nd ka kw ne bi translated">网络工作者的局限性</h1><p id="7ca9" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">Web Workers令人印象深刻，使用简单，但它有自己的局限性，我们在使用它之前必须知道。Web worker的实例将被限制在浏览器的单个选项卡中。所以工人拿走了标签的寿命。当我们从一个新的选项卡使用一个工人执行一个脚本时，它将创建一个新的工人。</p><p id="0321" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">由于Web worker是一个独立的线程，我们无法从worker脚本中访问<strong class="la io">窗口对象</strong>、<strong class="la io">文档对象</strong>、<strong class="la io"> </strong>和<strong class="la io">父对象</strong>。同样，我们不能通过<strong class="la io"> postMessage </strong>传递函数。</p><p id="9b3c" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">我们只能在worker脚本中使用有限数量的函数和类。下面是一些重要和有用的。你可以在这里看到其他人的<code class="fe nf ng nh ni b"><a class="ae nj" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers" rel="noopener ugc nofollow" target="_blank">docs</a></code>。</p><ul class=""><li id="3a61" class="no np in la b lb mi le mj kl nq kp nr kt ns lq nt nu nv nw bi translated">导航对象</li><li id="7947" class="no np in la b lb nx le ny kl nz kp oa kt ob lq nt nu nv nw bi translated">位置对象</li><li id="00fd" class="no np in la b lb nx le ny kl nz kp oa kt ob lq nt nu nv nw bi translated">取得</li><li id="9d34" class="no np in la b lb nx le ny kl nz kp oa kt ob lq nt nu nv nw bi translated">setTimeout，setInterval，clearTimeout，clearInterval</li><li id="4410" class="no np in la b lb nx le ny kl nz kp oa kt ob lq nt nu nv nw bi translated">数组、日期、数学和字符串</li><li id="9ec9" class="no np in la b lb nx le ny kl nz kp oa kt ob lq nt nu nv nw bi translated">使用<strong class="la io">导入脚本</strong>()导入其他脚本</li></ul></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="1148" class="mu kd in bd ke mv mw mx kh my mz na kk jt nb ju ko jw nc jx ks jz nd ka kw ne bi translated">结论</h1><p id="da53" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">Web Workers通过在后台执行线程阻塞和繁重的计算任务来帮助开发高性能和高效的React应用程序。通过并行执行任务和脚本，它使开发人员的生活变得更加轻松。此外，使用Web Workers也有缺点，因为它的启动性能成本和每个实例的内存成本都很高。但是考虑到权衡利弊，这是一个方便的解决方案。我肯定会在我未来的项目中使用它。</p><p id="54a6" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">请随意使用下面我的Web Workers GitHub repo。该代码是开源的，如果有人有兴趣贡献，请将您的PRs发送给我。</p><p id="a157" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated"><strong class="la io"> ⭐️ </strong>回购如果你觉得有用。</p><p id="91e0" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated">可以联系我@ <a class="ae nj" href="https://www.vithushan.me/" rel="noopener ugc nofollow" target="_blank"> www.vithushan.me </a></p><div class="oc od gp gr oe of"><a href="https://github.com/VithuJey/web-worker/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">GitHub - VithuJey/web-worker:如何在React中使用web worker？🕸</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在这个项目中，你会看到以下文件夹和文件:/ ├──公共/ │ └──工人/│└──图书馆工人. ts │ │…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot mb of"/></div></div></a></div></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="860e" class="pw-post-body-paragraph ky kz in la b lb mi jo ld le mj jr lg kl mk li lj kp ml ll lm kt mm lo lp lq ig bi translated"><em class="ou">更多内容看</em> <a class="ae nj" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ou">说白了就是</em> </strong> </a> <em class="ou">。报名参加我们的</em> <a class="ae nj" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ou">免费周报</em> </strong> </a> <em class="ou">。关注我们关于</em> <a class="ae nj" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ou">推特</em> </strong> </a>，<a class="ae nj" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ou">领英</em> </strong> </a> <em class="ou">，</em><a class="ae nj" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="ou">YouTube</em></strong></a><em class="ou">，以及</em> <a class="ae nj" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ou">不和</em> </strong> </a> <em class="ou">。对增长黑客感兴趣？检查</em> <a class="ae nj" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="ou">电路</em> </strong> </a> <em class="ou">。</em></p></div></div>    
</body>
</html>