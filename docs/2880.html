<html>
<head>
<title>Angular, RXJS: 2 ways you could share the HTTP request execution when the request is executed inside a method call</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular，RXJS:当请求在方法调用中执行时，共享HTTP请求执行的两种方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-rxjs-2-ways-you-could-share-the-http-request-execution-when-the-request-is-executed-inside-975d0dce054c?source=collection_archive---------5-----------------------#2022-07-12">https://javascript.plainenglish.io/angular-rxjs-2-ways-you-could-share-the-http-request-execution-when-the-request-is-executed-inside-975d0dce054c?source=collection_archive---------5-----------------------#2022-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8791140f420db29596a70759f2c34ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QC84Q2ugFV-ueZjB"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0151" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我曾经写过一个类似的概念，您可以使用哪个多播操作符来确保HTTP请求只执行一次，并且在多个观察者之间共享响应，而不管他们何时订阅。</p><p id="5752" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，HTTP请求不在方法内部执行。</p><div class="ky kz gp gr la lb"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-rxjs-which-multicast-operator-can-be-used-for-sharing-http-request-between-multiple-ac0a349bd9c3"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">TypeScript，RXJS:使用哪个多播运算符来共享HTTP请求b/w多个观察器…</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">RXJS提供了许多操作符，哪一个操作符将满足您的要求，这肯定需要一些研究和…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jt lb"/></div></div></a></div><p id="eaf1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个故事略有不同。在Angular应用程序中，HTTP请求执行发生在服务的方法内部。</p><p id="ec93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多次调用该方法意味着有多个观察者订阅了该方法返回的可观察值。</p><p id="a51d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">对于这些观察者中的每一个，都将执行一个单独的HTTP请求。</strong></p><p id="9e4c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果HTTP请求在一个方法中执行，我如何防止它被多次执行？</p><p id="1d01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第一种方法:</strong></p><p id="b8cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了演示这个方法，我使用了一个组件<strong class="kc io"> HelloComponent </strong>和一个服务<strong class="kc io"> Method1Service。</strong></p><p id="8edd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">方法1服务:</strong></p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c67f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> getUsers() </strong>是我们在其中执行HTTP GET请求以获取用户Id为2 的用户的数据的方法。</p><p id="51f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们没有将<strong class="kc io"> this.http.get() </strong>创建的可观察对象返回给调用<strong class="kc io"> getUsers() </strong>的组件，而是将这个可观察对象分配给我们定义的可观察对象<strong class="kc io"> userData$ </strong>。</p><p id="f89e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">任何将Method1Service添加为依赖项的组件都可以访问userData$ 。正确的做法应该是<strong class="kc io">将userData$声明为</strong> <strong class="kc io"> private </strong>并通过<strong class="kc io"> public方法访问它。我只是不想在例子中添加很多方法。尽量保持简单:)。</strong></p><p id="10ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用了<strong class="kc io"> publishLast()+refCount()多播操作符</strong>来确保来自HTTP请求的响应在观察者之间共享。</p><p id="6e5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> HelloComponent类:</strong></p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="3aed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io"> ngOnInit() </strong>中，我们首先调用了<strong class="kc io"> getUsers() </strong>，用使用<strong class="kc io"> this.http.get() </strong>创建的可观察对象来重新分配<strong class="kc io"> userData$ </strong>可观察对象。</p><p id="204c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们调用了一个方法<strong class="kc io">creating observers for firstuserdata()</strong>，其中我们创建了2个观察者，他们将订阅<strong class="kc io"> userData$ </strong> observable来获取数据。第二个观察者在<strong class="kc io">延迟1秒</strong>后订阅。</p><p id="e0fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> getUsers() </strong>将只被<strong class="kc io">调用一次</strong>到<strong class="kc io">执行一次HTTP GET请求</strong>并将返回的可观察值赋给<strong class="kc io"> userData$。</strong>此后，任何想要该数据的组件只需订阅<strong class="kc io"> userData$。</strong></p><p id="9aa0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第二种方法:</strong></p><p id="4a58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了演示这个方法，我使用了一个组件<strong class="kc io"> HiComponent </strong>和一个服务<strong class="kc io"> Method2Service </strong>。</p><p id="e504" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> Method2Service: </strong>现在，你只需要知道这个服务的2点:= &gt;服务定义了一个<strong class="kc io">behavior subject userdata subject $</strong>，初始值为<strong class="kc io"> null </strong>。</p><p id="1319" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;该服务定义了一个<strong class="kc io"> getUsers() </strong>，它执行一个HTTP GET请求来获取一个用户Id为<strong class="kc io">3</strong>的用户的数据。</p><p id="5ee5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两点是如何协同工作的，我们将在查看<strong class="kc io"> HiComponent类</strong>后进行检查。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="ce26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> HiComponent类:</strong></p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="79a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io"> ngOnInit() </strong>中，我们首先调用了<strong class="kc io"> Method2Service </strong>的<strong class="kc io"> getUsers() </strong>，它可以返回两个值中的任意一个:</p><p id="b998" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;由<strong class="kc io"> this.http.get() </strong>在<strong class="kc io"> Method2Service </strong>中创建的可观察对象。</p><p id="3004" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运筹学</p><p id="f2f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;操作员的rxjs <strong class="kc io">创建的冷可观察值。</strong>该操作符将发出由<strong class="kc io"> Method2Service中的主题<strong class="kc io"> userDataSubject$ </strong>持有的值。</strong></p><p id="25d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们调用了方法<strong class="kc io">creating observersforseconduserdata()</strong>，其中我们创建了2个观察器，它们将订阅由<strong class="kc io"> getUsers() </strong>返回的可观察对象以获取数据。第二个观察者在<strong class="kc io">延迟3秒</strong>后订阅。</p><p id="49b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">策略:</strong></p><p id="3501" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;在<strong class="kc io">方法2服务</strong>中的<strong class="kc io">用户数据主体$ </strong>是一个<strong class="kc io">行为主体</strong>，其<strong class="kc io">初始值为空</strong>。当有观察者订阅该主题，但该主题尚未发出值时，会向观察者发出该值。</p><p id="35a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;当<strong class="kc io"> HiComponent </strong>类第一次调用<strong class="kc io"> getUsers() </strong>时，即当第一个观察者订阅了<strong class="kc io"> getUsers() </strong>返回的可观察对象时，<strong class="kc io"> userDataSubject$ </strong> subject的value属性将为空。</p><p id="e981" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，控制转到<strong class="kc io"> getUsers() </strong>中的ELSE块，并执行HTTP GET请求。</p><pre class="lq lr ls lt gt lw lx ly lz aw ma bi"><span id="199f" class="mb mc in lx b gy md me l mf mg">else {<br/><strong class="lx io">return this.http.get(‘https://jsonplaceholder.typicode.com/users/3')</strong>.pipe(<br/>tap((y) =&gt; console.log(‘Emitting value’)),<br/>map((x) =&gt; x),<br/>catchError((err) =&gt; throwError(err))<br/>);<br/>}</span></pre><p id="36a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当请求成功完成时，第一个观察者的<strong class="kc io"> next()回调</strong>被执行，在这个回调中，我们记录了响应，并对<strong class="kc io"> userDataSubject$调用了<strong class="kc io"> next() </strong>。</strong></p><pre class="lq lr ls lt gt lw lx ly lz aw ma bi"><span id="ddbd" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">this.method2Service.userDataSubject$.next(value);</strong></span></pre><p id="1e5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;当<strong class="kc io"> HiComponent </strong>类下次调用<strong class="kc io"> getUsers() </strong>时，<strong class="kc io">userdata subject $</strong>subject的value属性将包含用户数据，因此控件将在IF块本身中。</p><pre class="lq lr ls lt gt lw lx ly lz aw ma bi"><span id="b10a" class="mb mc in lx b gy md me l mf mg">if (this.userDataSubject$.value) {<br/><strong class="lx io">return of(this.userDataSubject$.value);</strong><br/>}</span></pre><p id="684a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">操作员的<strong class="kc io"> rxjs创建的冷可观察值将返回到组件。这个可观察对象将向第二个观察者发出userDataSubject$ </strong>的<strong class="kc io">值。</strong></p><p id="1e23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，我们避免了额外的HTTP请求，并与多个观察者共享单个HTTP请求执行的响应。</p><p id="bf0f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以在下面找到完整的工作示例。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="mh lv l"/></div></figure><p id="2136" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mi">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mi">plain English . io</em></strong></a><em class="mi">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mi">免费周报</em> </strong> </a> <em class="mi">。关注我们</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mi">Twitter</em></strong></a><em class="mi">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mi">LinkedIn</em></strong></a><em class="mi">。查看我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mi">社区不和谐</em> </strong> </a> <em class="mi">加入我们的</em> <a class="ae jz" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mi">人才集体</em> </strong> </a> <em class="mi">。</em></p></div></div>    
</body>
</html>