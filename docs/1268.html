<html>
<head>
<title>Why you shouldn’t always use “useState”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不应该总是使用“使用状态”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-shouldnt-always-use-usestate-658994693018?source=collection_archive---------0-----------------------#2022-03-13">https://javascript.plainenglish.io/why-you-shouldnt-always-use-usestate-658994693018?source=collection_archive---------0-----------------------#2022-03-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c934" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你好，我是一名前端开发人员，我想分享一下我对为什么不应该总是使用<code class="fe ki kj kk kl b">useState</code>的看法。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/41eba2936d31bcad0ac0794481cc811e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/0*1XRAtpzChotlp0Yr.jpg"/></div></figure><blockquote class="ku kv kw"><p id="0ca9" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">TL；DR: <code class="fe ki kj kk kl b">useState</code>是一个异步钩子，它不会立即改变状态，它必须等待组件重新呈现。</p><p id="dfb9" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">useRef</code>是一个同步挂钩，它可以立即更新状态，并在组件的生命周期中保持其值，但不会触发重新渲染。</p></blockquote><p id="bca5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近，我和一位同事结对编程，他正与一个“奇怪的bug”作斗争。</p><p id="f541" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kx">*编辑:不是bug，只是误用了useState。</em></p><p id="88e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了便于理解，我举了这个例子。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lb"><img src="../Images/68e4b0eea05ee6639f1968bf8771df8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVZ78Qnpu2hiyjR2cEJnDg.png"/></div></div></figure><p id="f1a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我那位热心的朋友很困惑，为什么他的表单没有像预期的那样正确提交输入。</p><p id="5e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我建议他使用“正常变量”而不是“使用状态”,但他看不起我，好像我只是一个白痴(他怎么知道的？😅)并开玩笑说:“你显然不知道你在说什么。”</p><p id="6f95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">令他自己惊讶的是，这个变量派上了用场。</p></div><div class="ab cl lg lh hr li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ig ih ii ij ik"><h1 id="a466" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">我为什么喜欢useRef？</h1><p id="f0cf" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">好的，我只是想声明你不应该总是依赖于<code class="fe ki kj kk kl b">useRef</code>或一个“正常变量”来处理所有情况，但是我只是想分享为什么有时候我更喜欢它们而不是<code class="fe ki kj kk kl b">useState</code>。</p><p id="ed6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编辑:我确实收到了读者的反馈，他们认为我的例子不正确，因此我更新了他们的反馈来说明我的观点。</p><h2 id="249a" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated">1-使用状态</h2><p id="dcce" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">看看下面的例子。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/bd3e7f0c5e0e6e4a28e57199933befff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*c_ZxUaJz1PnIOHxmEvTrig.png"/></div></figure><p id="9529" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你知道会发生什么吗？</p><p id="b7f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">useState</code>是一个异步钩子，它会等待组件完成它的循环，重新渲染，然后它会更新状态。因此，<code class="fe ki kj kk kl b">userToken</code>第20行仍然是一个空字符串。</p><h2 id="b3cc" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated">2-用户参考</h2><p id="43c8" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">当我需要立即做一些事情，并且我的代码流需要它时，我会瞄准<code class="fe ki kj kk kl b">useRef</code>…为什么？因为它有着和<code class="fe ki kj kk kl b">useState</code>一样的坚持的力量。</p><p id="6791" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它通过组件的生命周期来维持价值，但最酷的是它是同步的！</p><p id="f47e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们重新编写上面的示例，这次让它生效！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/58958a88c573fb8be92082199750a27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*vf4gt6lv5rfRQWdktsquCw.png"/></div></figure><p id="5937" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最酷的是，它将在组件的整个生命周期中保持不变，无论组件重新渲染多少次都不会被初始化为false。</p><p id="03ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">useRef</code>仅用于保持状态并同步更新，但不会触发重新渲染。所以，不要到处用<code class="fe ki kj kk kl b">useRef</code>代替<code class="fe ki kj kk kl b">useState</code>。</p><h2 id="b75d" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated">3-正常变量</h2><p id="a24c" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">在我的例子中，我不需要维持<code class="fe ki kj kk kl b">userToken</code>的值，因为我只会使用它一次，因此我可以用一个普通变量替换<code class="fe ki kj kk kl b">useRef</code>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1ee7f70b5f151b00c443a0d6a85102c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*lkVcBMrIrn6DO_ef9pfXhQ.png"/></div></figure></div><div class="ab cl lg lh hr li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ig ih ii ij ik"><h1 id="99b0" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用状态如何工作</h1><p id="cb95" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">我做了一个插图代码来解释<code class="fe ki kj kk kl b">useState</code>钩子是如何在引擎盖下工作的。</p><p id="f87b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您听说过闭包，那么这看起来会很熟悉。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nf"><img src="../Images/8fb3dccc0f11fc9a50238cbf89dbb690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIb6-T7rc1rcnxqV_DzedQ.png"/></div></div></figure><blockquote class="ku kv kw"><p id="054c" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">根据定义,“闭包”意味着一个函数可以访问它最初创建的作用域，即使它是在作用域之外执行的。</p></blockquote><p id="7bdd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，<code class="fe ki kj kk kl b">state</code>和<code class="fe ki kj kk kl b">setState</code>是在它们的作用域之外执行的函数，但是它们仍然可以访问最初在其中声明它们的作用域。</p><p id="84ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，<code class="fe ki kj kk kl b">setState</code>是异步的，它必须排队等待组件重新呈现的订单，等待订单完成，然后它将更新状态。</p><p id="4e00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它如何在组件重新渲染的过程中保持状态值不变？关闭，我的朋友。</p><p id="88fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">闭包使您能够创建具有持久“记忆”的函数，这意味着您再次执行该函数时，它将引用上一次的执行…让我解释一下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ccea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么不在控制台中试试这段代码呢？</p><p id="f1e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">猜猜这里发生了什么？</p><p id="61b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">确切地说，闭包保留了函数作用域的“缓存”或“内存”,即使函数在外部执行也可以访问。</p></div><div class="ab cl lg lh hr li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ig ih ii ij ik"><h1 id="6b68" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="123d" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">不要瞧不起别人，告诉他们“你显然不知道你在说什么。”或者那个人会在媒体上写一篇文章。😆</p><p id="6d78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读。</p><p id="e06e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kx">更多内容看</em> <a class="ae ni" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kx">说白了就是</em> </strong> </a> <em class="kx">。报名参加我们的</em> <a class="ae ni" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kx">免费周报</em> </strong> </a> <em class="kx">。关注我们关于</em><a class="ae ni" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kx">Twitter</em></strong></a><em class="kx">和</em><a class="ae ni" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kx">LinkedIn</em></strong></a><em class="kx">。加入我们的</em> <a class="ae ni" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kx">社区</em> </strong> </a> <em class="kx">。</em></p></div></div>    
</body>
</html>