<html>
<head>
<title>Every Dev Should Understand Big O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发者都应该理解大O</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/every-dev-should-understand-big-o-279b2f57fa73?source=collection_archive---------4-----------------------#2022-09-17">https://javascript.plainenglish.io/every-dev-should-understand-big-o-279b2f57fa73?source=collection_archive---------4-----------------------#2022-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f3fe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">初学者指南:7分钟以内理解算法的大O和时间复杂度。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fd67a74b93d62161059788e8d2d23ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2djP9JDL8HTBEtIk_rN-oA.png"/></div></div></figure><p id="dfca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本节讲的都是在7分钟(<em class="ln">或更少</em>)内理解算法的大O和时间复杂度。是入门级别的章节，应该不会太难理解。</p><h1 id="9767" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">大O</h1><p id="cb17" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><a class="ae ml" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大O符号</a>衡量一个算法的执行效率，以及它消耗了多少内存。它可以被认为是其时间复杂度<strong class="kt ir">或空间复杂度</strong>。</p><p id="513d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每当我们谈论大O和它的效率度量时，我们感兴趣的是当我们的输入规模增加时，算法的表现如何。</p><p id="acb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大O有助于区分好代码和坏代码，也有助于区分好代码和好代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/634024ae7dd0415dbfe08998f1d5820a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qebiYDFzsjHGUgk5CtNLTQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Big-O Complexity Chart from <a class="ae ml" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a></figcaption></figure><p id="44ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能听说过或者遇到过的最常见的时间复杂度是<strong class="kt ir"> O(n) </strong>、<strong class="kt ir"> O(n^2) </strong>、<strong class="kt ir"> O(log-n) </strong>、<strong class="kt ir"> O(n log-n) </strong>。我会一点一点地详细谈论每一个。</p><h1 id="e84d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">O(1) —常数时间</h1><p id="5495" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果一个算法需要相同的时间，不管输入大小如何，就说它在恒定时间内运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/b24b3d374173705a13c112f4710624ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lz0W7cZVd9QxslOT-BXmgw.png"/></div></figure><p id="26ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该算法的时间复杂度为O(1)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="619a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">O(n) —线性时间</h1><p id="566a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">时间复杂度为O(n)的算法被编程为具有与输入大小成正比的执行时间。这种符号也称为“线性时间”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/eda27e5804dedb87963ba89d6d650a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyvBY36sChXPQi2AuQVuYA.png"/></div></figure><p id="efcb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下算法的时间复杂度为O(n)，其中n是输入数组的长度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="cb96" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">大O分析—最佳、一般和最差情况</h1><p id="89a7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在我们继续更基本的大操作系统之前，有必要了解不同的情况。</p><p id="1538" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">最佳情况分析</strong> —在这里，我们计算算法完成所需的最佳或最短时间。</p><p id="ac5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">平均案例分析</strong> —为了计算我们算法的平均案例，我们需要知道它将接收的所有可能的输入。然后，我们将每次使用该输入的时间除以输入次数。</p><p id="7678" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">最坏情况分析</strong> —这里，我们计算算法完成的最大时间。</p><p id="bbf3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看看这个例子。这里我们有一个从玩家列表中搜索名为<strong class="kt ir"> Kane </strong>的玩家的函数。如果玩家被找到，它返回true否则返回false。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="dc7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的<strong class="kt ir">最佳</strong>情况是凯恩在开头(<em class="ln">第一个元素</em>)，我们只需要循环一次玩家列表。</p><p id="9044" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最坏的情况是Kane不是第三个元素，而是出现在最后，或者更糟的是，不在列表中，我们的程序需要遍历列表中的每个元素。</p><p id="8222" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们谈论时间复杂性时，我们只关心最坏的情况。也许你想知道为什么。</p><p id="8ca2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您的代码在一般输入下表现良好，但是对于特定输入，它花费了不可接受的时间。</p><p id="c0f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一名程序员，了解这些场景并找出优化它们或修改算法的方法是至关重要的。这就是为什么<strong class="kt ir">人们在面试中只讨论或关心你的项目的最坏情况的复杂性。</strong></p><h1 id="ee39" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">O(n)</h1><p id="6f09" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">随着迭代的元素数量(n)的增加，算法所用的时间呈指数增加。因此，举例来说，如果您将输入增加10倍，您可能需要等待17倍的时间来获得您想要的输出。</p><p id="d234" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了更好地理解这一点，考虑下面的例子。如您所见，计算时间以n的指数速度增长:</p><ul class=""><li id="3eb7" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated">1个项目= 1秒</li><li id="3791" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">10个项目= 100秒</li><li id="0e4f" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">100个项目= 10，000秒</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/2a6a5ca6e2f567367b536e6d240516cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVS66V3cly-FxTHEHgZy1g.png"/></div></figure><p id="1d78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常(<em class="ln">，但不总是</em>)，嵌套for循环的时间复杂度为O(n)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="383d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">面试通常认为O(n)解决方案是一种蛮力方法。因此，这通常意味着找到更好的方法，如O(n log n)甚至O(n) <strong class="kt ir">是可能的。</strong></p><h1 id="48c2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">o(登录号)</h1><p id="e11e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了理解这一点，我们将首先研究对数背后的<a class="ae ml" href="https://en.wikipedia.org/wiki/Logarithm" rel="noopener ugc nofollow" target="_blank">数学，然后研究它们与复杂性分析的关系。</a></p><p id="4bad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ml" href="https://en.wikipedia.org/wiki/Logarithm" rel="noopener ugc nofollow" target="_blank">维基百科</a>对对数有如下定义:</p><p id="b08a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">数学上，对数是幂的反函数。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/5ecfac0a34f6c9d28840722bd78a2e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-W8gdHEAxH6TayDQiV4NcQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">A logarithmic function is the opposite of an exponential function.</figcaption></figure><p id="8ca3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">这意味着给定数字x的对数是另一个固定数字(以b为底)的指数，它必须被提升以产生该数字x。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/3df57d71678e55e2f3fc38a7666612ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tws2R2ttx7UtUz9WQMrZOg.png"/></div></figure><p id="2081" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">二进制对数以2为底(b = 2)，常用于计算机科学。(</em> <a class="ae ml" href="https://stackoverflow.com/a/6701841/1182982" rel="noopener ugc nofollow" target="_blank"> <em class="ln">为什么基数为2？这里解释了</em> </a> <em class="ln">)。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/f76c83e4461221899df02e6db6578148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXOnxTCEaLjOdDT6p5WBRg.png"/></div></div></figure><p id="b9e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">乍一看，这可能有点难以理解，所以让我们通过一些例子来理解这些方程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/3319c5ae6dc682aa5b79d09f02f91e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmfHakyC_YWWSsKV3-prog.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Understanding log(N) calculation with examples.</figcaption></figure><p id="15e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们已经学会了如何计算<strong class="kt ir"> log(n) </strong>，让我们继续增加N，观察时间复杂度的增加:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="5762" class="nn lp iq nj b gy no np l nq nr">log(8) = 3</span><span id="6661" class="nn lp iq nj b gy ns np l nq nr">log(16) = 4</span><span id="b729" class="nn lp iq nj b gy ns np l nq nr">log(32) = 5</span><span id="d145" class="nn lp iq nj b gy ns np l nq nr">log(64) = 6</span><span id="f664" class="nn lp iq nj b gy ns np l nq nr">log(128) = 7</span><span id="4983" class="nn lp iq nj b gy ns np l nq nr">log(256) = 8</span><span id="4204" class="nn lp iq nj b gy ns np l nq nr">…</span><span id="df45" class="nn lp iq nj b gy ns np l nq nr">log(1024) = 10</span><span id="d078" class="nn lp iq nj b gy ns np l nq nr">log(~1M) = 20</span><span id="aa77" class="nn lp iq nj b gy ns np l nq nr">log(~4B) = 32</span></pre><p id="69ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很简单，我们可以看到当输入<strong class="kt ir"> N </strong>加倍时，时间复杂度<strong class="kt ir"> log(N) </strong>只增加1。并且对比<strong class="kt ir"> O(N) </strong>可以看出<strong class="kt ir"> O(log(N)) </strong>的表现有多好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/4a9a16d42061e9256f0a16d3fca4b217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZHokihmTfIKbSL0fdPkWQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">The time complexity of O(log n) vs. O(n)</figcaption></figure><p id="171b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种时间复杂性经常出现在分治算法中，该算法在再次合并它们之前递归地将问题分成子问题。比如<a class="ae ml" href="https://www.geeksforgeeks.org/binary-search/" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>、<a class="ae ml" href="https://www.geeksforgeeks.org/merge-sort/" rel="noopener ugc nofollow" target="_blank">归并排序</a> (O(N log N))等。</p><h1 id="fa62" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">一些最后的想法</h1><p id="6faa" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一旦你牢牢掌握了O(n)，O(n)和O(log n)的基本时间复杂性，就很容易理解其他类型的复杂性，如O(n)，O(n log n)，O(n！)…以及它们是如何工作的。</p><p id="d079" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想回到我在本文开头分享的时间复杂度图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/634024ae7dd0415dbfe08998f1d5820a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qebiYDFzsjHGUgk5CtNLTQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Big-O Complexity Chart from <a class="ae ml" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a></figcaption></figure><h1 id="7956" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">在你离开之前！</h1><p id="134e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">理解Big O是开发人员进步的关键，因为它将帮助您理解如何优化您的代码，因为您将能够计算其复杂性。</p><p id="069e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果你喜欢这个帖子，<strong class="kt ir">我会在我的时事通讯中发布更多令人兴奋的内容；您可以在这里免费查看:</strong> <a class="ae ml" href="https://coderpreneurs.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">立即查看Coderpreneurs！</strong>T9】</a></p><p id="0e9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，我喜欢在Twitter上发布引人入胜的内容和帖子，所以我也建议关注我！<a class="ae ml" href="https://twitter.com/thenaubit" rel="noopener ugc nofollow" target="_blank">这是我的推特:@thenaubit </a>。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="cfe0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">更多内容看</em> <a class="ae ml" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">说白了。报名参加我们的</em> <a class="ae ml" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">免费周报</em> </strong> </a> <em class="ln">。关注我们关于</em><a class="ae ml" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ln">Twitter</em></strong></a>，<a class="ae ml" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ln">LinkedIn</em></strong></a><em class="ln">，</em><a class="ae ml" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ln">YouTube</em></strong></a><em class="ln">，以及</em> <a class="ae ml" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">不和</em> </strong> </a> <em class="ln">。对增长黑客感兴趣？检查出</em> <a class="ae ml" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">电路</em> </strong> </a> <em class="ln">。</em></strong></a></p></div></div>    
</body>
</html>