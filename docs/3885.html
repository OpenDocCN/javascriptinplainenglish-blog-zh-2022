<html>
<head>
<title>Binary Search and Its Time Complexity in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的二分搜索法及其时间复杂度</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-search-and-its-time-complexity-in-javascript-d3f6e79fe84e?source=collection_archive---------12-----------------------#2022-10-05">https://javascript.plainenglish.io/binary-search-and-its-time-complexity-in-javascript-d3f6e79fe84e?source=collection_archive---------12-----------------------#2022-10-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5db3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript算法基础—第6部分:理解JavaScript中的二分搜索法及其时间复杂性</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/251fd8d1170d6078ad992fca3ffa3c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lqf0TOwPfkEoRPBmYgdBxw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Binary Search</figcaption></figure><p id="21eb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">作为程序员应该知道的最重要和最流行的算法之一是<strong class="ku io">二分搜索法</strong>算法。在本文中，我们将深入研究这类算法及其时间复杂度。</p><h2 id="a768" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">需要搜索算法</h2><p id="f81a" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在编程中，我们经常面对一个数据列表，在列表中寻找某个元素。为了实现这一点，我们需要实现一个解决方案，该方案可以从列表中检索元素，或者在没有找到元素时返回一条消息。</p><p id="7d31" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">而且，我们确实有多种算法，对不同类型的具有不同时间复杂度的列表进行操作。<strong class="ku io">二分搜索法</strong>就是其中之一，也是最受欢迎的搜索算法之一。</p><ul class=""><li id="382e" class="mm mn in ku b kv kw ky kz lb mo lf mp lj mq ln mr ms mt mu bi translated"><em class="mv">线性搜索</em></li><li id="9f16" class="mm mn in ku b kv mw ky mx lb my lf mz lj na ln mr ms mt mu bi translated"><strong class="ku io"> <em class="mv">二分搜索法</em> </strong></li><li id="872a" class="mm mn in ku b kv mw ky mx lb my lf mz lj na ln mr ms mt mu bi translated"><em class="mv">跳转搜索</em></li><li id="4070" class="mm mn in ku b kv mw ky mx lb my lf mz lj na ln mr ms mt mu bi translated"><em class="mv">插补搜索</em></li><li id="5133" class="mm mn in ku b kv mw ky mx lb my lf mz lj na ln mr ms mt mu bi translated"><em class="mv">指数搜索</em></li><li id="fdf3" class="mm mn in ku b kv mw ky mx lb my lf mz lj na ln mr ms mt mu bi translated"><em class="mv">斐波那契搜索</em></li></ul></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h2 id="0eda" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">什么是二分搜索法？</h2><p id="5f3c" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated"><strong class="ku io">二分搜索法</strong>是一种比<strong class="ku io">线性搜索时间复杂度</strong>更好的搜索算法。然而，如果我们将其与线性搜索算法进行比较，就会发现它有一个重要的局限性。</p><p id="43e9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">线性搜索可以在<strong class="ku io">有序</strong>和<strong class="ku io">无序</strong>列表上操作，而二分搜索法只能在<strong class="ku io">有序</strong>列表上操作。所以为了让二分搜索法工作，我们需要一个<strong class="ku io">排序列表</strong>，可以是升序也可以是降序。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h2 id="5766" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">二分搜索法是如何工作的？</h2><p id="8178" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">如果我们有一个已排序的数组，二分搜索法将定位<strong class="ku io">数组的中间元素</strong>，并对照要查找的搜索元素进行检查。</p><p id="e957" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">例如，如果一个数组中有6个元素，二分搜索法将选择中间的元素，即第3个元素，并确定它是否是我们要寻找的元素。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/3041fa42265b64f60d687f28255dcf53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YvyaXIAm6Qd9b2J9qbxkHQ.png"/></div></div></figure><p id="8fd0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果<strong class="ku io">中间的元素是我们正在寻找的</strong>，那么算法返回<strong class="ku io">中间的元素，而不进一步迭代整个数组</strong>。</p><p id="0550" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果中间的元素与项目不匹配，那么<strong class="ku io">将列表分成两半</strong>并且<strong class="ku io">选择该元素必须出现的列表</strong>。</p><p id="fb81" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">由于列表是排序的，它可以发现我们正在寻找的项目是小于还是大于我们刚刚检查的项目。</p><p id="7991" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果我们的<strong class="ku io">搜索元素小于中间元素</strong>，那么它会查看数组的<strong class="ku io">前半部分，如果<strong class="ku io">搜索元素大于中间元素</strong>，那么它会查看数组</strong>的<strong class="ku io">后半部分。</strong></p><p id="a9be" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">它继续这个划分和遍历被划分的数组的过程，直到找到搜索元素或完成所有的迭代。</p><p id="b215" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">由于它每次都将数组分成两半，因此它的性能确实优于线性时间复杂度。</p><p id="ccd3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以让我们来看看二分搜索法在JavaScript中的实现</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h2 id="63e3" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">二分搜索法算法</h2><p id="ed37" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">作为输入，我们将得到一个排序后的数组以及要查找的搜索元素。记住，二分搜索法只处理排序数据。如果数据没有排序，那么算法应该首先排序，然后执行搜索。</p><h2 id="21e5" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated"><strong class="ak">第一步</strong></h2><p id="476d" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">根据二分搜索法的核心规则，我们首先从数组中找到中间元素，并将其存储在变量<strong class="ku io">middle position</strong>中。</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="ad17" class="lo lp in nk b gy no np l nq nr">function searchElement(arr, searchElement) {<br/>  let startPosition = 0;<br/>  let endPosition = arr.length - 1;</span><span id="da37" class="lo lp in nk b gy ns np l nq nr">  <strong class="nk io">let midPosition = Math.floor((endPosition - startPosition) / 2);</strong><br/>}</span></pre><h2 id="a05e" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated"><strong class="ak">第二步</strong></h2><p id="c68d" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">计算完数组的中间元素后，我们检查中间元素是否是我们要搜索的元素。如果中间元素匹配搜索元素，那么我们返回中间元素索引。</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="82f1" class="lo lp in nk b gy no np l nq nr">function searchElement(arr, searchElement) {<br/> let startPosition = 0;<br/> let endPosition = arr.length - 1;</span><span id="4227" class="lo lp in nk b gy ns np l nq nr"><strong class="nk io"> </strong>let midPosition = Math.floor((endPosition - startPosition) / 2);</span><span id="f67d" class="lo lp in nk b gy ns np l nq nr"> <strong class="nk io">if (searchElement === arr[midPosition]) {<br/>  return midPosition;<br/> }</strong><br/>}</span></pre><h2 id="e22b" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">第三步</h2><p id="ec9d" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">如果我们没有找到中间的元素，那么我们需要循环遍历数组，直到找到我们要找的元素。因此，为了实现这一点，我们添加了一个循环，并继续计算中间位置，直到我们的数组列表用尽。</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="90d4" class="lo lp in nk b gy no np l nq nr">function searchElement(arr, searchElement) {<br/> let startPosition = 0;<br/> let endPosition = arr.length - 1;</span><span id="a91e" class="lo lp in nk b gy ns np l nq nr"> <strong class="nk io">while (startPosition &lt;= endPosition)</strong> {<br/>  let midPosition = Math.floor((endPosition - startPosition) / 2);<br/><br/>  if (searchElement === arr[midPosition]) {<br/>   return midPosition;<br/>  }<br/> <strong class="nk io">}</strong><br/>}</span></pre><h2 id="2200" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">第四步</h2><p id="8daf" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">这实际上会导致无限循环，因为我们没有更新<strong class="ku io">开始位置</strong>和<strong class="ku io">结束位置</strong>的值。</p><p id="982b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">需要一个<strong class="ku io">分割逻辑来根据搜索元素是在数组的前半部分还是后半部分来分割数组</strong>。</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="0b6c" class="lo lp in nk b gy no np l nq nr">function searchElement(arr, searchElement) {<br/> let startPosition = 0;<br/> let endPosition = arr.length - 1;</span><span id="e841" class="lo lp in nk b gy ns np l nq nr">while (startPosition &lt;= endPosition) {<br/>  let midPosition = Math.floor((endPosition - startPosition) / 2);<br/><br/>  if (searchElement === arr[midPosition]) {<br/>   return midPosition;<br/>  }</span><span id="e825" class="lo lp in nk b gy ns np l nq nr">  <strong class="nk io">if (searchElement &lt; arr[midPosition]) {<br/>   endPosition = midPosition - 1;<br/>  } else {<br/>   startPosition = midPosition + 1;<br/>  }</strong><br/> }<br/>}</span></pre><p id="f196" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">第五步</p><p id="e91c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果搜索元素大于中间元素，我们还需要改进我们的<strong class="ku io">中间位置</strong>逻辑，因为我们正在更新<strong class="ku io">开始位置</strong>。</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="4b54" class="lo lp in nk b gy no np l nq nr">function searchElement(arr, searchElement) {<br/> let startPosition = 0;<br/> let endPosition = arr.length - 1;</span><span id="3e36" class="lo lp in nk b gy ns np l nq nr"> while (startPosition &lt;= endPosition) {<br/>  let midPosition = <strong class="nk io">startPosition </strong>+ Math.floor((endPosition - startPosition) / 2);<br/><br/>  if (searchElement === arr[midPosition]) {<br/>   return midPosition;<br/>  }</span><span id="9f8d" class="lo lp in nk b gy ns np l nq nr"><strong class="nk io">  </strong>if (searchElement &lt; arr[midPosition]) {<br/>   endPosition = midPosition - 1;<br/>  } else {<br/>   startPosition = midPosition + 1;<br/>  }<br/> }<br/>}</span></pre><p id="4b39" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是二分搜索法算法的基于循环的解决方案。我们也有递归方法，可以用递归来实现。</p><h1 id="0c46" class="nt lp in bd lq nu nv nw lt nx ny nz lw jt oa ju lz jw ob jx mc jz oc ka mf od bi translated">时间复杂度</h1><p id="53af" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">现在，让我们看看二分搜索法的时间复杂度是多少，如果我们考虑它的最好和最坏的情况。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/12924d5afcad35b3e2de226e5c522f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tRHA26WVuG4v7XhORwE0Q.png"/></div></div></figure><h2 id="ffae" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated"><strong class="ak">最佳情况</strong></h2><p id="ef0b" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">最好的情况是当我们要找的东西在中间的时候。在这种情况下，我们将得到<strong class="ku io"> O(1)常数时间复杂度</strong>，因为我们只需要一次迭代。</p><h2 id="db7d" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated"><strong class="ak">最坏情况</strong></h2><p id="97be" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">当我们要寻找的项目正好在数组的开头或结尾<strong class="ku io">时，我们会得到最坏的情况。</strong></p><p id="b018" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">此外，因为我们总是将数组分成两半，所以我们总是从中间的成员开始。因此，我们只在每次迭代的最后遇到数组的开始或结束。</p><p id="f114" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">而且，由于我们在每次迭代中将数组分成两半，我们将得到一个<strong class="ku io">对数时间复杂度</strong>。因此，无论我们的<strong class="ku io">数组</strong>有多大，我们都不会遍历数组中的每一项。这采用了一个<strong class="ku io">分而治之的策略</strong>，导致了<strong class="ku io"> O(log n) </strong>个步骤。</p><p id="3a4f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以我们可以说，采用上述方案的二分搜索法的时间复杂度为<strong class="ku io"> O(log n) </strong>。</p><p id="e579" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">要记住的一个普遍原则是，如果我们把问题集分成两半，甚至更小，分成三四份。我们每次迭代都要处理对数时间复杂度，二分搜索法算法就是这种情况。T15】</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="0d71" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="mv">更多内容请看</em> <a class="ae of" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="mv">说白了就是</em> </strong> </a> <em class="mv">。报名参加我们的</em> <a class="ae of" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="mv">免费每周简讯</em> </strong> </a> <em class="mv">。关注我们关于</em> <a class="ae of" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="mv">推特</em> </strong> </a>，<a class="ae of" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="mv">LinkedIn</em></strong></a><em class="mv">，</em><a class="ae of" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="mv">YouTube</em></strong></a><em class="mv"/><a class="ae of" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="mv">不和</em> </strong> </a> <em class="mv">。对增长黑客感兴趣？检查出</em> <a class="ae of" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="mv">电路</em> </strong> </a> <em class="mv">。</em></p></div></div>    
</body>
</html>