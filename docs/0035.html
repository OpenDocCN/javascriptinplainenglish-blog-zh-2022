<html>
<head>
<title>Asynchronous Loops in JavaScript — using forEach, map, and for loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的异步循环—使用forEach、map和for循环</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/asynchronous-loops-in-javascript-using-foreach-map-and-for-loop-8a1db09fd3b1?source=collection_archive---------18-----------------------#2022-01-03">https://javascript.plainenglish.io/asynchronous-loops-in-javascript-using-foreach-map-and-for-loop-8a1db09fd3b1?source=collection_archive---------18-----------------------#2022-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="89f0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在async/await中使用JavaScript循环的正确方法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4a9d265d85a0bbf53904e6509c530b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QCHgFPbMFrxi7zaY.jpg"/></div></div></figure><p id="1a2c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用web应用程序时，异步操作至关重要。我们都同意，在处理异步操作时，async/await让我们的生活变得多么简单。</p><p id="3061" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这篇文章中，我们将看到如何在async/await中使用循环。</p><p id="4685" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们深入研究之前，这里是我在演示中使用的实用函数</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="7b74" class="lp lq in ll b gy lr ls l lt lu">// creates a logger function to print logs with function name<br/>function getLogger(fnName) {<br/>  return function logger(value, diffInMS) {<br/>    return console.log(<br/>      `${fnName}: Item ${value} finished waiting ${Math.round(<br/>        diffInMS / 1000<br/>      )} seconds later.`<br/>    );<br/>  };<br/>}<br/><br/>// simulates an async flow, a network request for example<br/>async function waitFor(seconds) {<br/>  // used to create the fancy waterfall<br/>  fetch("https://random-data- <br/>         api.com/api/stripe/random_stripe" + Math.random());<br/><br/>  // the fake asynchronous task<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(resolve, seconds * 1000);<br/>  });<br/>}</span></pre><h1 id="91ba" class="lv lq in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">经典For循环</h1><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="380d" class="lp lq in ll b gy lr ls l lt lu">const list = [1, 2, 3, 4, 5, 6, 7, 8 , 9, 10];<br/><br/>export async function mainWithFor() {<br/>  const start = Date.now();<br/>  const logger = getLogger("mainWithFor");<br/>  for (const item of list) {<br/>    await waitFor(2);<br/>    const later = Date.now();<br/>    logger(item, later - start);<br/>  }<br/>}</span></pre><p id="fa61" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一个接一个地按顺序运行代码。在进行下一次迭代之前，等待每个<code class="fe mm mn mo ll b">waitFor</code>完成。</p><p id="acc2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下图展示了一个漂亮的瀑布演示，看看每个绿色部分是如何在前一个的2秒后开始的。(不要担心它们的持续时间，因为它是一个随机的终点。仅为了瀑布描绘)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/da55b6ab6eba08ecc28b421c263861e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4e73rdjWdg-2lRYh.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">for loop waterfall async/await</figcaption></figure><p id="8ae2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您还会注意到，日志一个接一个地出现，相差2秒。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/1d5e886743d18ff9483c510803bff5cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*x-vqUcRJ863Vc9Tc.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">for loop console logs</figcaption></figure><blockquote class="mv mw mx"><p id="ad5e" class="ko kp my kq b kr ks jo kt ku kv jr kw mz ky kz la na lc ld le nb lg lh li lj ig bi translated"><em class="in">这种方法的一个很好的用例是运行顺序操作，其中您希望在前一个操作完成后运行下一个操作。</em></p></blockquote><h1 id="dcfc" class="lv lq in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">forEach高阶方法</h1><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="bdf6" class="lp lq in ll b gy lr ls l lt lu">export async function mainWithForEach() {<br/>  const start = Date.now();<br/>  const logger = getLogger("mainWithForEach");<br/>  list.forEach(async (item) =&gt; {<br/>    await waitFor(2);<br/>    const later = Date.now();<br/>    logger(item, later - start);<br/>  });<br/>}</span></pre><p id="1e19" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mm mn mo ll b">forEach</code>循环的行为不同于<code class="fe mm mn mo ll b">for</code>循环，而<code class="fe mm mn mo ll b">for</code>循环在进一步移动之前<code class="fe mm mn mo ll b">await</code>迭代，<code class="fe mm mn mo ll b">forEach</code>循环同时执行所有迭代。因此，所有十次执行都在同一点开始，并在2秒后记录。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/addd61ab584e7c96b6f2d635ff3c7de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*TDfBwWsgJYT724MG.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">forEach loop console logs</figcaption></figure><p id="cca8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们也可以用瀑布图来观察，看看它们是如何同时开始的。(再次请忽略每次执行的持续时间，这是random-API)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/1afd18ec3585f84dd8d748a761a81f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q9vwXQexEkWM89hD.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">forEach loop waterfall async/await</figcaption></figure><blockquote class="mv mw mx"><p id="85ad" class="ko kp my kq b kr ks jo kt ku kv jr kw mz ky kz la na lc ld le nb lg lh li lj ig bi translated"><em class="in">这种方法的一个很好的用例是运行并行操作，其中您不关心前一个操作是否完成。比</em> <code class="fe mm mn mo ll b"><em class="in">for</em></code> <em class="in">循环快多了。但是这种方法有一个警告:如果您请求的API有某种速率限制设置，那么同时请求可能会适得其反。</em></p></blockquote><h1 id="ab31" class="lv lq in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">映射高阶方法</h1><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="1523" class="lp lq in ll b gy lr ls l lt lu">export async function mainWithMap() {<br/>  const start = Date.now();<br/>  const logger = getLogger("mainWithMap");<br/>  const promises = list.map(async (item) =&gt; {<br/>    await waitFor(2);<br/>    const later = Date.now();<br/>    logger(item, later - start);<br/>  });<br/>  const finalAnswer = await Promise.all(promises)<br/>}</span></pre><p id="71dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就异步操作而言，<code class="fe mm mn mo ll b">map</code>函数的行为与<code class="fe mm mn mo ll b">forEach</code>完全相同，这意味着所有的回调同时开始，并在2秒后记录。</p><p id="e4ff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最重要的是，<code class="fe mm mn mo ll b">.map</code>返回一个承诺数组(每次执行一个承诺，顺序相同)。</p><p id="1208" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">稍后我们可以做一个<code class="fe mm mn mo ll b">await Promise.all(promises)</code>来从中获得最终的答案数组。</p><p id="0180" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="my">需要注意的是，如果输入数组中只有一个承诺被拒绝，则Promise.all将被完全拒绝。</em></p><blockquote class="mv mw mx"><p id="f758" class="ko kp my kq b kr ks jo kt ku kv jr kw mz ky kz la na lc ld le nb lg lh li lj ig bi translated"><code class="fe mm mn mo ll b"><em class="in">map</em></code> <em class="in">应该用在需要根据每个异步操作返回一些数据的地方。如果不是这样，坚持用</em> <code class="fe mm mn mo ll b"><em class="in">forEach</em></code> <em class="in">也不会是个坏选择。</em></p></blockquote><p id="eeac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你想亲自尝试，这里有到<a class="ae ne" href="https://codesandbox.io/s/async-await-loops-4brdl" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>的链接。</p><p id="7078" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我还制作了一个<a class="ae ne" href="https://www.youtube.com/watch?v=Ce1ywrKeStI" rel="noopener ugc nofollow" target="_blank"> YouTube视频</a>来亲自解释这个帖子，</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Asynchronous loops in JavaScript: Youtube video</figcaption></figure><p id="d246" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我希望这篇文章对你有帮助。如果你有任何反馈或问题，请在下面的评论中提问。我很想听听他们的想法并为之努力。</p><p id="d9a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您还没有，请<a class="ae ne" href="https://twitter.com/sun_anshuman" rel="noopener ugc nofollow" target="_blank">关注我</a>，以获得关于此类帖子的通知。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="2f7b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="my">原载于2022年1月3日</em><a class="ae ne" href="https://theanshuman.dev/articles/asynchronous-loops-in-javascript-using-foreach-vs-map-vs-for-loop-5020" rel="noopener ugc nofollow" target="_blank"><em class="my">https://theanshuman . dev</em></a><em class="my">。</em></p><p id="60ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="my">更多内容请看</em> <a class="ae ne" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="my">说白了就是</em> </strong> </a> <em class="my">。报名参加我们的</em> <a class="ae ne" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="my">免费每周简讯</em> </strong> </a> <em class="my">。在我们的</em> <a class="ae ne" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="my">社区</em> </strong> </a> <em class="my">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>