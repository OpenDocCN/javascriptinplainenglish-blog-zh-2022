<html>
<head>
<title>Why You Should Be Using GraphQL (If You Aren’t Already)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该使用GraphQL(如果您还没有)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-should-be-using-graphql-if-you-arent-already-7f5deb4333a8?source=collection_archive---------6-----------------------#2022-11-20">https://javascript.plainenglish.io/why-you-should-be-using-graphql-if-you-arent-already-7f5deb4333a8?source=collection_archive---------6-----------------------#2022-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d5335b4135b7fe4f17c28186ff3eebba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjVr87nTkybfJLmZM8QFfg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://codersociety.com/blog/articles/graphql-reasons" rel="noopener ugc nofollow" target="_blank">https://codersociety.com/blog/articles/graphql-reasons</a></figcaption></figure><p id="6e0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都知道在我们的应用程序中管理数据通常是一件苦差事，因为它需要:</p><ul class=""><li id="76a1" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">独立的前端客户端管理各种平台，如Web、移动(iOS、Android等。)，而且这些客户端通常需要不同的数据集</li><li id="2a3b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">一个后端系统，可能从各种存储入口点(如PostgreSQL、Redis、Firebase等)获取数据。</li><li id="9c21" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">堆栈两端(前端和后端)的复杂状态和缓存管理</li><li id="2349" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">查询的单独文档</li></ul><p id="db02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，有一种更现代的方式来管理这些琐事，这就是GraphQL。</p><p id="128f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，你可能会问，<strong class="kf ir"> GraphQL </strong>到底是什么？好吧，我们就直接进入这个话题。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="0b7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lw">本文原载</em> <a class="ae kc" href="https://upmostly.com/web-development/benefits-of-adopting-graphql" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lw">此处</em> </strong> </a> <em class="lw">。</em></p><h1 id="0204" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">GraphQL是什么？</h1><p id="d6c5" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated"><strong class="kf ir"> GraphQL </strong>最初是作为一个<strong class="kf ir"> API机制</strong>出现的，用于在<strong class="kf ir">脸书处理<strong class="kf ir">复杂的查询任务</strong>。</strong></p><p id="2971" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是在考虑到<strong class="kf ir">易用性</strong>和<strong class="kf ir">开发速度</strong>的情况下构思出来的，旨在打造严重依赖<strong class="kf ir">各种系统之间的数据和通信</strong>的新产品。</p><p id="b8a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lw">因此在面向服务的</em><em class="lw">&amp;</em><strong class="kf ir"><em class="lw">微服务</em> </strong> <em class="lw"> </em> <strong class="kf ir"> <em class="lw">架构中使用非常普遍。</em>T45】</strong></p><p id="772f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脸书用例的一个很好的例子是它的移动应用，比如脸书和Instagram。</p><p id="7e50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，在其核心，<strong class="kf ir"> GraphQL是一种查询语言</strong>，为前端和后端提供发送和检索数据的双向指令。</p><p id="abc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着它允许前端开发人员<strong class="kf ir"> <em class="lw">从可访问的数据条目池中请求他们需要的确切数据。</em>T55】</strong></p><p id="42cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比每次客户需要新的特定数据批次来解决经典的<strong class="kf ir"> <em class="lw">欠查询</em> </strong>和<strong class="kf ir"> <em class="lw">过查询</em> </strong> <strong class="kf ir">问题</strong>时定义新的端点要方便得多。</p><h1 id="fda0" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">GraphQL是如何工作的？</h1><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/e2d867fc3e220715d88568eac7783f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KW2asXodoKF-YLVqgKqoqQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Several REST endpoint requests can be replaced with a single GraphQL query. Source: Poirier-Ginter 2019.</figcaption></figure><p id="3ab6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> GraphQL </strong>充当客户端和服务器之间连接的<strong class="kf ir">包装器，因此，它为您的客户端提供了一个<strong class="kf ir">单一端点</strong>来访问来自服务器的数据池，并<strong class="kf ir">挑选他们可能需要的任何东西</strong>。</strong></p><p id="1151" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不仅如此，它还为数据的进入提供了多个入口点，因此我们可能能够<strong class="kf ir">访问来自不同来源的数据</strong>，这非常方便！</p><p id="2bdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据GraphQL使用的抽象，我们将引用GraphQL将数据点/模型解释为<strong class="kf ir"> <em class="lw">节点</em> </strong>，而这些节点之间的关系将被引用为<strong class="kf ir"> <em class="lw">边</em> </strong>。</p><p id="1b95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，数据被表示为互连对象/数据点的<strong class="kf ir"> <em class="lw">图</em> </strong>，而不是我们通过RESTful端点访问的资源。整个图就是我们所说的<strong class="kf ir"> <em class="lw">应用数据图</em> </strong>。</p><h1 id="7aac" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">GraphQL与RESTful APIs</h1><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8eb4087568416e1ff81db1960e0f7b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*bvqZ_TMKMLXR8S4E.png"/></div></figure><h1 id="f41b" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用GraphQL相对于REST的优势:</h1><h2 id="2ea6" class="ng ly iq bd lz nh ni dn md nj nk dp mh ko nl nm ml ks nn no mp kw np nq mt nr bi translated">1.表演</h2><p id="c996" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">GraphQL比任何其他通信API都要快，因为它迫使您通过只选择您想要查询的特定字段来减少请求查询，这解决了上面提到的<strong class="kf ir">欠查询</strong>和<strong class="kf ir">过查询</strong>的问题。</p><h2 id="86b9" class="ng ly iq bd lz nh ni dn md nj nk dp mh ko nl nm ml ks nn no mp kw np nq mt nr bi translated">2.最适合复杂系统</h2><p id="9b0f" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">它最适合于复杂的系统，比如那些实现<strong class="kf ir"> SOA </strong>或<strong class="kf ir">微服务</strong>架构的系统，因为它允许将系统的所有服务合并到一个保护伞下。</p><p id="be55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着数据在整个系统中更容易访问，正如前面提到的，这非常方便。</p><h2 id="79a9" class="ng ly iq bd lz nh ni dn md nj nk dp mh ko nl nm ml ks nn no mp kw np nq mt nr bi translated">3.层次结构方法</h2><p id="6b18" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated"><strong class="kf ir"> GraphQL </strong>遵循分层结构，其中对象之间的关系在图形结构中定义。</p><p id="241e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> GraphQL </strong>中，每个对象类型代表一个<strong class="kf ir">组件</strong>，从一个对象类型到另一个对象类型的每个关系字段代表一个组件包装另一个组件。</p><h2 id="d40d" class="ng ly iq bd lz nh ni dn md nj nk dp mh ko nl nm ml ks nn no mp kw np nq mt nr bi translated">4.为客户塑造数据</h2><p id="7de2" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">将形状添加到数据中。当我们向服务器请求GraphQL查询时，服务器以简单、安全和可预测的形式返回响应。因此，它便于您根据自己的需求编写特定的查询。</p><p id="a652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lw">这让GraphQL真的很好学很好用。</em> </strong></p><h2 id="5a26" class="ng ly iq bd lz nh ni dn md nj nk dp mh ko nl nm ml ks nn no mp kw np nq mt nr bi translated">5.客户端/服务器不可知</h2><p id="94a5" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">由于GraphQL是一种协议，它不关心您在应用程序的前端或后端使用什么技术。</p><p id="9ca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要支持实现一个GraphQL客户端来处理协议实现，GraphQL这边就没问题。</p><p id="a9ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以想到JavaScript的<a class="ae kc" href="https://www.apollographql.com" rel="noopener ugc nofollow" target="_blank"> Apollo </a>，C#/的<a class="ae kc" href="https://chillicream.com/docs/hotchocolate" rel="noopener ugc nofollow" target="_blank">热巧克力</a>。网等。</p><h1 id="2d9e" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用GraphQL优于REST的缺点</h1><h2 id="7bab" class="ng ly iq bd lz nh ni dn md nj nk dp mh ko nl nm ml ks nn no mp kw np nq mt nr bi translated">1.查询复杂性</h2><p id="2782" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">当我们必须在一个查询中访问多个字段时，不管是通过<strong class="kf ir"> RESTfully </strong>请求还是通过<strong class="kf ir"> GraphQL </strong>请求，各种资源和字段仍然必须从<strong class="kf ir">数据源</strong>中检索，因此当<strong class="kf ir">客户端同时请求太多嵌套字段数据</strong>时，也会出现同样的问题。</p><p id="e0af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，必须有一种类似于<strong class="kf ir">最大查询深度</strong>、<strong class="kf ir">查询复杂度加权</strong>、<strong class="kf ir">避免递归</strong>或<strong class="kf ir">持久查询的机制来阻止来自客户端的低效和中断请求</strong>。</p><h2 id="bf83" class="ng ly iq bd lz nh ni dn md nj nk dp mh ko nl nm ml ks nn no mp kw np nq mt nr bi translated">2.贮藏</h2><p id="49aa" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">用<strong class="kf ir"> GraphQL </strong>实现一个简化的缓存比用<strong class="kf ir"> REST </strong>实现要复杂得多。</p><p id="b3c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当使用RESTful API时，我们通过URL访问资源，然后我们可以在资源级别缓存它们，因为我们有资源URL作为标识符。</p><p id="1c60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，在<strong class="kf ir"> GraphQL </strong>中，它非常复杂，因为每个查询都可能不同，即使它操作的是同一个实体。但是大多数构建在GraphQL之上的库都提供了有效的缓存机制。</p><h1 id="0a33" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">GraphQL常用术语词汇表</h1><ul class=""><li id="271a" class="lb lc iq kf b kg mv kk mw ko ns ks nt kw nu la lg lh li lj bi translated"><strong class="kf ir">查询</strong>:从GraphQL服务获取数据的只读操作。</li><li id="12d8" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">突变</strong>:虽然可以将查询设计为进行数据写入，但不建议这样做。建议进行明确的突变。</li><li id="57da" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">字段</strong>:我们可以获取的数据的基本单位。事实上，GraphQL是关于在对象上选择字段的。您可以将字段视为您希望查询或变更的数据模型的属性。</li><li id="d855" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">片段</strong>:可以跨多个查询重用的一组字段。</li><li id="7c73" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">参数</strong>:每个字段和嵌套对象都可以有一个参数，从而使我们能够过滤或定制结果。参数基本上是关键:我们可以用来过滤数据的值对。</li><li id="12e1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">别名</strong>:为了避免结果中的命名冲突，别名很有帮助。例如，我们可以用不同的参数查询同一个对象，并用不同的别名得到结果。</li><li id="47ed" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">指令</strong>:这个可以附加在一个字段或者片段上，动态影响数据的形状。强制指令是<code class="fe nv nw nx ny b">@include</code>和<code class="fe nv nw nx ny b">@skip</code>，根据条件包括或跳过一个字段。指令通常用于分页。</li></ul><h1 id="8a9e" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">一锤定音</h1><p id="8fb4" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我相信GraphQL是管理更复杂系统的一种优秀方式，在处理更复杂的应用程序时可能会遇到这种情况。</p><blockquote class="nz oa ob"><p id="a90a" class="kd ke lw kf b kg kh ki kj kk kl km kn oc kp kq kr od kt ku kv oe kx ky kz la ij bi translated"><strong class="kf ir"> <em class="iq">假设您遇到了这样一种情况，您正试图协调各种前端客户端或多个后端数据输入源之间的关系；在这种情况下，GraphQL可能很适合您的用例。</em> </strong></p></blockquote></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="d8b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里 查看这篇文章<a class="ae kc" href="http://upmostly.com/web-development/how-to-set-up-a-graphql-server-with-node-js" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">，看看我们将如何<strong class="kf ir">用Node.js &amp; Express </strong>建立一个GraphQL服务器。</strong></a></p><p id="9400" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想了解我们如何在React应用程序中通过Apollo客户端<strong class="kf ir">实现GraphQL并与GraphQL服务器交互，您可以查看这篇</strong> 文章。</p><p id="71f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你觉得我错过了什么，或者你想进一步讨论我在这篇文章中提到的任何东西，请随时留下评论，这样我们就可以继续讨论。非常感谢。</p><p id="76dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯！</p><p id="34e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lw">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lw">plain English . io</em></strong></a><em class="lw">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lw">免费周报</em> </strong> </a> <em class="lw">。关注我们上</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lw">Twitter</em></strong></a><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lw">LinkedIn</em></strong></a><strong class="kf ir"><em class="lw"/></strong><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lw">YouTube</em></strong></a><strong class="kf ir"><em class="lw"/></strong><em class="lw">和</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lw">不和</em> </strong> </a>  <em class="lw">对成长黑客感兴趣？检查</em> <a class="ae kc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lw">电路</em> </strong> </a> <strong class="kf ir"> <em class="lw">。</em> </strong></p></div></div>    
</body>
</html>