<html>
<head>
<title>Angular: 2 Ways You Can Perform Crossfield Validation in Reactive Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度:有两种方法可以在反应式表单中执行交叉场验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-2-ways-you-can-perform-crossfield-validationin-reactive-forms-6a9b688b8cff?source=collection_archive---------5-----------------------#2022-11-21">https://javascript.plainenglish.io/angular-2-ways-you-can-perform-crossfield-validationin-reactive-forms-6a9b688b8cff?source=collection_archive---------5-----------------------#2022-11-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1e59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">交叉验证基本上意味着字段的验证可能不仅仅依赖于它自己的值，还可能依赖于一个或多个其他字段的值。</p><p id="d23b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个故事只是演示了两种方法。我用了一个非常简单的表格，下面只有4个字段:<strong class="jm io">电子邮件，确认电子邮件，密码</strong>和<strong class="jm io">确认密码</strong>。最后，我们还将reactive表单的值打印为JSON。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c246575c72ba8184af3ac0cbac2c662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0RxTh45l4PgaVPN6N-CYAA.png"/></div></div></figure><p id="618a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们首先来看看在单个字段上应用了什么验证。</p><p id="e266" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;所有字段都是必填的。</p><p id="fdd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;电子邮件字段必须包含有效的电子邮件地址。</p><p id="6d74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;确认电子邮件字段必须包含与电子邮件字段相同的值。存在对电子邮件字段的依赖。</p><p id="ec9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;密码字段除了是强制性的以外，没有具体的验证。</p><p id="447c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">= &gt;确认密码字段必须包含与密码字段相同的值。存在对密码字段的依赖性。</p><p id="152b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将使用<strong class="jm io">第一种方法</strong>，通过电子邮件确认电子邮件字段进行交叉验证。第二种方法将应用于密码确认密码字段。在这两种方法中，我们都使用<strong class="jm io">定制同步验证器</strong>来执行验证。</p><p id="0bbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一、第一种方法:</strong></p><p id="8caf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种方法中，我们将<strong class="jm io">将依赖字段分组到一个新的表单组</strong>中，而<strong class="jm io">将自定义验证器应用到表单组</strong>中，而不是应用到单个字段中。想法是，<strong class="jm io">我们应该能够访问验证器</strong>中的整个表单组，因此也能够访问表单组中的所有表单控件。</p><p id="01a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是表单结构。<strong class="jm io"> crossValidationForm </strong>是根表单组，包含嵌套表单组<strong class="jm io"> emailGroup </strong>和2个表单控件<strong class="jm io"> password </strong>和<strong class="jm io"> confirmPassword </strong>。</p><p id="b695" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> fb </strong>是对<strong class="jm io">form builder C</strong>Class的引用，注入到组件类的构造器中。</p><pre class="kj kk kl km gt ku kv kw bn kx ky bi"><span id="ed8d" class="kz la in kv b be lb lc l ld le">this.crossValidationForm = this.fb.group({<br/>emailGroup: this.fb.group(<br/>{<br/>email: [‘’, [Validators.required, Validators.email]],<br/>confirmEmail: [‘’, Validators.required],<br/>},<br/>{ validators: emailCheck() }<br/>),<br/>password: [‘’, [Validators.required]],<br/>confirmPassword: [‘’, [Validators.required, passwordCheck()]],<br/>});</span></pre><p id="5aff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经将<strong class="jm io"> email </strong>和<strong class="jm io"> confirmEmail </strong>表单控件分组到嵌套的<strong class="jm io"> emailGroup </strong>表单组下。</p><p id="0cda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在emailGroup表单组中添加了一个<strong class="jm io"> emailCheck </strong>自定义验证器。</p><pre class="kj kk kl km gt ku kv kw bn kx ky bi"><span id="2684" class="kz la in kv b be lb lc l ld le">function emailCheck(): ValidatorFn {<br/>return (c: AbstractControl): ValidationErrors | null =&gt; {<br/><br/>let email = c.get(‘email’);<br/>let confirmEmail = c.get(‘confirmEmail’);<br/><br/>if (email.pristine || confirmEmail.pristine) {<br/>return null;<br/>}<br/><br/>return email.value !== confirmEmail.value ? { emailNotSame: true } : null;<br/>};<br/>}</span></pre><p id="4989" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参数<strong class="jm io"> c </strong>是<strong class="jm io">邮件组</strong>表单组。</p><p id="cb3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过验证器内的<strong class="jm io"> emailGroup </strong>表单组访问<strong class="jm io"> email </strong>和<strong class="jm io"> confirmEmail </strong>表单控件。我们比较了两个FormControls的值，如果值不匹配，则返回一个<strong class="jm io">错误对象</strong>，如果值匹配，则返回空值<strong class="jm io">。</strong></p><p id="3db0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果要验证的<strong class="jm io">字段可以在嵌套的表单组</strong>中分组，那么这种方法是合适的。可能会发生这样的情况:某些不相关的字段放置在表单的不同位置，但却相互依赖。这种方法在这种情况下不合适，因为从结构上来说，可能/不可能对它们进行分组。</p><p id="b0ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二。第二种方法:</strong></p><p id="0618" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，我们已经在<strong class="jm io"> confirmPassword </strong>字段中添加了<strong class="jm io"> passwordCheck </strong>自定义验证器。</p><p id="64b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">密码</strong>和<strong class="jm io">确认密码</strong>字段的唯一共同点是根表单组<strong class="jm io">交叉验证表单。我们利用了这一点。</strong></p><pre class="kj kk kl km gt ku kv kw bn kx ky bi"><span id="4cac" class="kz la in kv b be lb lc l ld le">function passwordCheck(): ValidatorFn {<br/>return (c: AbstractControl): ValidationErrors | null =&gt; {<br/>if (c.parent) {<br/><br/>let password = c.parent.get(‘password’);<br/>let confirmPassword = c.parent.get(‘confirmPassword’);<br/><br/>return password.value !== confirmPassword.value? { passwordMismatch: true }: null;<br/>}<br/>return null;<br/>};<br/>}</span></pre><p id="0f29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参数<strong class="jm io"> c </strong>是<strong class="jm io">confirm password</strong>form control。我们如何访问验证器内部的<strong class="jm io">密码</strong> FormControl？</p><p id="941d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们获取<strong class="jm io">confirm password</strong>form control的<strong class="jm io">父属性</strong>来访问它们的父FormGroup。</p><p id="6a21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">使用父窗体组，我们可以访问它的所有子窗体控件/窗体组。</strong></p><p id="0681" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这种方式，我们访问了<strong class="jm io">密码</strong>和<strong class="jm io">确认密码</strong>表单控件，比较了它们的值，如果不匹配，则返回<strong class="jm io">错误对象</strong>，如果值匹配，则返回<strong class="jm io">空值</strong>。</p><p id="4336" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我没有深入研究验证消息是如何显示的。那是完全不同的话题。我们刚刚看到了如何实现跨字段验证的定制验证器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lf"><img src="../Images/433f62026d03586411216b5525f2a451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBxTGDrn7DD3Vq-5jF9ZWw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">email is invalid</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lk"><img src="../Images/987db280f8073f426b5b8c2ba3de94be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlVPWYDnd1m5B0h7KSO4hw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">confirmEmail validation</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ll"><img src="../Images/dcead1d5e99c5a816e5c85b9f8bbd504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*if4cXLTGnvdOhVk-Kyvmng.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">confirmPassword Validation</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lm"><img src="../Images/3505f9e14b44901cbef3927b3b0bc488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BOa53jt0NFRBHASa06fPVg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">all fields valid</figcaption></figure><p id="e27c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在下面找到完整的工作示例:</p><div class="ln lo gp gr lp lq"><a href="https://stackblitz.com/edit/angular-ldzggw?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd io gy z fp lv fr fs lw fu fw im bi translated">角形(叉形)堆叠</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">stackblitz.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me ks lq"/></div></div></a></div><p id="d795" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mf">更多内容请看</em><a class="ae mg" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mf">plain English . io</em></strong></a><em class="mf">。报名参加我们的</em> <a class="ae mg" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mf">免费周报</em> </strong> </a> <em class="mf">。关注我们关于</em><a class="ae mg" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mf">Twitter</em></strong></a><a class="ae mg" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mf">LinkedIn</em></strong></a><em class="mf"/><a class="ae mg" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mf">YouTube</em></strong></a><em class="mf"/><a class="ae mg" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mf">不和</em> </strong> </a> <em class="mf">。对增长黑客感兴趣？检查</em> <a class="ae mg" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mf">电路</em> </strong> </a> <em class="mf">。</em></p></div></div>    
</body>
</html>