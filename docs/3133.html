<html>
<head>
<title>Use Angular Async Pipe to Make Your Life Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角形异步管道，让您的生活更轻松</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-async-pipe-714dd864adaa?source=collection_archive---------6-----------------------#2022-08-03">https://javascript.plainenglish.io/angular-async-pipe-714dd864adaa?source=collection_archive---------6-----------------------#2022-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="fda1" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">角异步管道</h2><div class=""/><div class=""><h2 id="0cbf" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">尽可能使用异步管道。让Angular为您做繁重的工作吧！</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/795ee5a2b0db800e631c7cfa70388298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NRzYAD9tcKEfyuvh"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@victorfreitas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Victor Freitas</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9d86" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">AsyncPipe 是Angular提供的工具之一，让我们的生活变得更加轻松。根据官方文档，<strong class="le ix"> <em class="ly">异步管道</em> </strong>做4件事:</p><ol class=""><li id="51f9" class="lz ma in le b lf lg li lj ll mb lp mc lt md lx me mf mg mh bi translated">它自动订阅一个<code class="fe mi mj mk ml b">Observable</code>(或<code class="fe mi mj mk ml b">Promise</code>)并返回最新发出的值。</li><li id="40c1" class="lz ma in le b lf mm li mn ll mo lp mp lt mq lx me mf mg mh bi translated">每当发出一个新值时，它就标记关联的组件以进行更改检测。</li><li id="51ff" class="lz ma in le b lf mm li mn ll mo lp mp lt mq lx me mf mg mh bi translated">如果表达式的引用发生变化，它会自动退订旧的<code class="fe mi mj mk ml b">Observable</code>，并订阅新的。</li><li id="4006" class="lz ma in le b lf mm li mn ll mo lp mp lt mq lx me mf mg mh bi translated">当组件被销毁时，它会自动取消订阅以避免内存泄漏。</li></ol><p id="6e28" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">让我们使用一个演示应用程序来详细检查每一点。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="253c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在我们的演示应用程序中，我们有2个组件:使用<strong class="le ix">异步管道</strong>、<em class="ly">、</em>的<code class="fe mi mj mk ml b">DopeComponent</code>和不使用的<code class="fe mi mj mk ml b">RegularComponent</code>。</p><p id="8eb2" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们将比较这些实现，并强调在不使用异步管道时我们必须做的额外工作。</p><p id="58aa" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">两个组件<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/angular-component-communication-81e5e02c6cbe">都通过一个<code class="fe mi mj mk ml b">@Input()</code>修饰属性从它们的父组件</a>接收数据，这个属性是一个<code class="fe mi mj mk ml b">Observable</code>。</p><p id="6484" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果你不熟悉可观测量，可以把它们想象成异步数据流。它们用于异步发出值。但是为了接收发出的值，必须首先订阅它们。</p><p id="cd9a" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><code class="fe mi mj mk ml b">DopeComponent</code>的类中只有修饰属性。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2ff9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在各自的模板文件中使用的<em class="ly">异步管道</em>负责我们提到的所有事情。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b8f8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">另一方面，<code class="fe mi mj mk ml b">RegularComponent</code>就没那么简单了。让我们看看在这种特定情况下各自的实现是什么样的，并逐一说明。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5eb0" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">首先，我们需要手动订阅。我们在<code class="fe mi mj mk ml b">ngOnChanges</code>方法中这样做，并将值赋给一个局部变量(第21行和第29–31行)。所以，第一次可观察的被传递，我们订阅它。</p><p id="5213" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">接下来，我们需要跟踪订阅。我们首先声明变量(第9行),然后分配订阅(第21行),以便在组件销毁时取消订阅(第25–27行)。我们需要这样做来避免内存泄漏。</p><p id="efa3" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">由于两个组件都使用<code class="fe mi mj mk ml b">OnPush</code>变更检测策略，变更检测只有在非常特殊的情况下才会被触发。要了解更多关于<code class="fe mi mj mk ml b">OnPush</code>变化检测策略的工作原理，您可以观看此视频:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na mz l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">YouTube video by <a class="ae lb" href="https://www.youtube.com/channel/UC3cEGKhg3OERn-ihVsJcb7A" rel="noopener ugc nofollow" target="_blank">Angular University</a></figcaption></figure><p id="ac8d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">回到我们的演示，异步管道会处理这个问题，我们不必担心变化检测。</p><p id="9fdf" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">然而，在<code class="fe mi mj mk ml b">RegularComponent</code>中，我们必须注入<code class="fe mi mj mk ml b">ChangeDetectorRef</code>(第12行)并手动标记用于变更检测的组件(第32行)。</p><p id="bc92" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> <em class="ly">注:</em> </strong> <em class="ly">还有其他方法来实现这一点，以达到相同的结果。请记住，这只是为了演示。</em></p><p id="71ad" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">最后，如果表达式的引用发生变化，<code class="fe mi mj mk ml b">RegularComponent</code>不会自动订阅新的可观察值。这意味着我们必须再多走一步，实现这一点。</p><p id="1948" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们在<code class="fe mi mj mk ml b">ngOnChanges</code>生命周期挂钩方法中这样做。我们取消订阅之前的<code class="fe mi mj mk ml b">Observable</code>(第15-18行)，然后订阅新的(第20-22行)。</p><p id="940f" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">咻，这么多工作！这款<strong class="le ix"> <em class="ly"> AsyncPipe </em> </strong>肯定是游戏规则的改变者，对吧？</p><p id="e87d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">和往常一样，你可以在下面的StackBlitz找到一个工作演示，或者只在<a class="ae lb" href="https://github.com/kagklis/ng-async-pipe-demo" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中找到代码。</p><p id="0334" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">最后，不要忘记<a class="ae lb" href="https://vkagklis.medium.com/subscribe" rel="noopener">订阅我的时事通讯</a>来关注更多类似的内容！</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mz l"/></div></figure></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="dceb" class="nc nd in bd ne nf ng nh ni nj nk nl nm kc nn kd no kf np kg nq ki nr kj ns nt bi translated">结论</h1><p id="834f" class="pw-post-body-paragraph lc ld in le b lf nu jx lh li nv ka lk ll nw ln lo lp nx lr ls lt ny lv lw lx ig bi translated">在本文中，我们研究了<strong class="le ix">异步管道</strong>以及它能为我们做的所有工作。不要努力工作，要聪明工作。只要有可能，就用这根管子。让Angular为您做这项工作。</p><p id="a153" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">感谢阅读！我希望你喜欢这篇文章，并且你学到了一些新的东西。</p><p id="3803" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">编码快乐！</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="1262" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="ly">更多内容请看</em><a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="ly">plain English . io</em></strong></a><em class="ly">。报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> <em class="ly">免费周报</em> </strong> </a> <em class="ly">。关注我们上</em> <a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> <em class="ly">推特</em></strong></a><a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="ly">领英</em></strong></a><em class="ly">与</em> <a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> <em class="ly">不和</em> </strong> </a> <em class="ly">。</em></p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="e61d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> <em class="ly">供进一步阅读:</em> </strong></p><div class="nz oa gp gr ob oc"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-interceptors-a-complete-guide-7294e2317ecf"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ix gy z fp oh fr fs oi fu fw iw bi translated">角度截击机——完全指南</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">关于Angular中的截击机，你需要知道的一切。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ol l"><div class="om l on oo op ol oq kv oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://betterprogramming.pub/split-angular-nested-forms-into-subform-components-dcf32d1fb10d" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ix gy z fp oh fr fs oi fu fw iw bi translated">将角形嵌套形状拆分为子形状构件</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">如何将有角度的嵌套形状变成更小的子形状组件</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">better编程. pub</p></div></div><div class="ol l"><div class="or l on oo op ol oq kv oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-route-parameters-a-simple-guide-88c69d54102c"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ix gy z fp oh fr fs oi fu fw iw bi translated">角度布线参数:简单指南</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">Angular的布线参数以及如何在布线元件之间传递小块信息的概述。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ol l"><div class="os l on oo op ol oq kv oc"/></div></div></a></div></div></div>    
</body>
</html>