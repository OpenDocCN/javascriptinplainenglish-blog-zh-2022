<html>
<head>
<title>React 18: Automatic Batching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应18:自动配料</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-18-automatic-batching-3cf7bf545ab6?source=collection_archive---------8-----------------------#2022-06-21">https://javascript.plainenglish.io/react-18-automatic-batching-3cf7bf545ab6?source=collection_archive---------8-----------------------#2022-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="47db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React 18有一些很棒的特性，其中之一是自动批处理的概念。在本文中，您将了解什么是批处理，React以前是如何处理批处理的，以及自动批处理如何改变我们的生活。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><p id="71fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从基础开始。</p><p id="8ee2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">React中的批处理是什么？</strong></p><p id="041d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">批处理只是React对多个状态更新进行分组并只重新呈现组件一次以获得更好的性能的方式。</p><p id="973c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这对于小型应用程序来说并不重要，但是当您有一个更大的应用程序时，每一次不必要的重新渲染都会对您的性能造成负担。</p><p id="ad3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">批处理是React的新事物吗？</strong></p><p id="08aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不，不是的。React在版本18之前就已经在批处理了。但是只在React事件处理程序中批处理多个状态更新。它没有对超时、承诺等情况下发生的状态更新进行批处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ku"><img src="../Images/47aeb431b84e43c62b6c77e97ecfc821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLfqC01sYZM7WfQz_0oHew.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Batching Before React 18</figcaption></figure><p id="0cf6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">版本18后的批处理(自动批处理):</strong></p><p id="99b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在React 18中，promises、setTimeout、本地事件处理程序或任何其他事件中的更新都是自动批处理的。最棒的是，你不必在代码中添加任何东西来使用自动批处理，React会在你将项目的React版本升级到18后自动执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kz"><img src="../Images/dc570c5594fe484adddf392f6b82a61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umbk1rEFWog5tCNx90RhVw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">React 18 — Automatic Batching</figcaption></figure><p id="ef1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我们可以停止自动配料吗？</strong></p><p id="3235" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有些情况下，您可能希望在每次状态更新后重新渲染组件，因此不希望React自动批处理状态更新。React引入<code class="fe la lb lc ld b">flushSync()</code>功能，在必要时停止自动配料。可以从<code class="fe la lb lc ld b">react-dom</code>导入。</p><p id="570c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这在一个真正基础的应用程序上是如何工作的。我们有一个组件，它在每次再次运行时记录“重新呈现”,并且该组件有一个按钮，它像任何普通按钮一样抛出一个单击事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi le"><img src="../Images/528e856172901f2ae07e4e5a1e1f4736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJUbUsV4RybroKDXbDD1Lg.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Our really basic application 😄</figcaption></figure><p id="c538" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你点击那个按钮时，两个状态将在处理函数中被更新。为了停止自动批处理，我们将用<code class="fe la lb lc ld b">flushSync</code>函数包装其中一个状态更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lf"><img src="../Images/3eeacba9a1f47c802fda7f702cbf6479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnH0DYBFGFGzc8_A7QYUDw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">React 18 — flushSync</figcaption></figure><p id="2f68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们单击该按钮时，我们可以检查我们的控制台，并看到“重新呈现”被记录了两次，因为我们停止了自动批处理，并为每个状态更新重新呈现组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lg"><img src="../Images/12222605c7a44b6a4134716595d9ad78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qa6zfmBwsQx2ExEynlKYlQ.png"/></div></div></figure><p id="a97f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读🙂</p><p id="918d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">参考文献:</strong></p><p id="4982" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lh" href="https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html" rel="noopener ugc nofollow" target="_blank">https://react js . org/blog/2022/03/08/react-18-upgrade-guide . html</a></p><p id="51cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="li">更多内容请看</em><a class="ae lh" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="li">plain English . io</em></strong></a><em class="li">。报名参加我们的</em> <a class="ae lh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="li">免费周报</em> </strong> </a> <em class="li">。关注我们关于</em><a class="ae lh" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="li">Twitter</em></strong></a><em class="li">和</em><a class="ae lh" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="li">LinkedIn</em></strong></a><em class="li">。查看我们的</em> <a class="ae lh" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="li">社区不和谐</em> </strong> </a> <em class="li">加入我们的</em> <a class="ae lh" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="li">人才集体</em> </strong> </a> <em class="li">。</em></p></div></div>    
</body>
</html>