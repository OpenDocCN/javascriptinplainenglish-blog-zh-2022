<html>
<head>
<title>How to Add an API to Your Neo4J Graph with @neo4j/graphql</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用@neo4j/graphql给你的Neo4J图添加API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/adding-an-api-to-your-neo4j-graph-with-neo4j-graphql-3d4908def8d2?source=collection_archive---------3-----------------------#2022-04-19">https://javascript.plainenglish.io/adding-an-api-to-your-neo4j-graph-with-neo4j-graphql-3d4908def8d2?source=collection_archive---------3-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c6f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用@neo4j/graphql库向Neo4J图添加API的指南。</h2></div><p id="2b60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了证明<a class="ae lb" href="https://clime-app.com" rel="noopener ugc nofollow" target="_blank">我的新产品——Clime(一款连接多种工具产品知识的应用)</a>背后的概念在技术上是可行的，<a class="ae lb" href="https://gitlab.com/colinfwren/neo4j-and-graphql-example" rel="noopener ugc nofollow" target="_blank">我使用Neo4J </a>创建了一个概念验证，因为这个问题非常适合图形数据库。</p><p id="0f70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建了一组基本节点并建立了它们之间的关系之后，我能够执行查询，允许一个节点使用两组节点都相关的节点来查找不直接相关的链接节点。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/bd9c575c071e088dfd09ba836ab0b2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMol9COia3taO7JJ4b8apA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The example data I used</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ls"><img src="../Images/ead1707edcbe89fd2b59060400ec554d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxxqKfVza-MAhG_6q--Uag.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Query showing the Tests linked to UserStorys that a single Mockup is linked to</figcaption></figure><p id="f177" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这验证了我想法的技术方面，所以我继续进行下一步<a class="ae lb" href="https://colinwren.medium.com/iterating-my-way-to-a-product-landing-page-via-user-testing-with-maze-4f80c0cecec2" rel="noopener">验证我的想法，即建立一个登录页面来激起对产品的兴趣。</a></p><p id="98af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">登录页面上线后，我决定重新进行概念验证，因为有些事情困扰着我——图形数据库提供了查询产品知识图的方法，但我还没有计划好如何在它的基础上构建应用程序。</p><p id="18f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我对Clime的愿景是成为一个集中的知识库，通过我自己或用户社区构建的一系列插件和集成，从团队使用的工具中访问产品知识(例如，你可以右键单击Figma中的一个设计，并获得它链接到的用户故事列表)。</p><p id="9d33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然构建一个库来直接处理对Neo4J的查询可能很容易，但我觉得REST或GraphQL API对其他人来说更容易使用，如果我想构建一个人们可以为之构建自己的程序的产品，这一点很关键。</p><p id="d1a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过一番研究，我非常兴奋地看到Neo4J已经有了一个解决方案，可以围绕图形数据库构建一个GraphQL包装器——<code class="fe lt lu lv lw b">@neo4j/graphql</code>包。</p><p id="16fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个包与Neo4J驱动程序(一个用于访问Neo4J实例的库)结合使用时，允许您为Neo4J图中的节点创建GraphQL模式，并提供一些方便的GraphQL指令，使查询关系易于定义。然后，GraphQL模式可以与Apollo或您选择的GraphQL服务器一起使用。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Setting up the Neo4J GraphQL server isn’t that different from setting up a standard Apollo server</figcaption></figure><h1 id="40d9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为Neo4J创建GraphQL模式</h1><p id="d2bc" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在我们可以构建一个API之前，我们需要有一个我们希望通过该API公开的数据模型。对于图形数据库上的API，该模型需要包括节点和边，因为边表示的关系将是返回链接数据的关键。</p><p id="9589" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，我将重复使用我在Clime概念验证中使用的模型</p><ul class=""><li id="66f4" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe lt lu lv lw b">Mockup</code>——(一个设计，<code class="fe lt lu lv lw b">:VISUALISES</code>一个<code class="fe lt lu lv lw b">UserStory</code>)</li><li id="5134" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lt lu lv lw b">UserStory</code>——(系统行为的定义，<code class="fe lt lu lv lw b">:DEFINES</code> a <code class="fe lt lu lv lw b">Product</code>)</li><li id="e5bb" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lt lu lv lw b">Product</code> —(产品，顶层对象)</li><li id="dc39" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lt lu lv lw b">Test</code> —(为确保系统正常运行而执行的测试，<code class="fe lt lu lv lw b">:TESTS</code> a <code class="fe lt lu lv lw b">UserStory</code>)</li></ul><p id="3a96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于这个模型，下面是一个Cypher查询，它将向Neo4J添加一个样本数据集:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Test Data used to create the Graph shown above</figcaption></figure><p id="1e67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了为这个模型创建GraphQL API，我们需要创建类型定义，这样<code class="fe lt lu lv lw b">Neo4jGraphQL</code>构造函数就知道如何将Neo4J中的节点映射到GraphQL对象。首先，我们可以只包含这些对象将公开的字段(我们稍后将讨论链接节点)。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">A basic GraphQL schema containing fields for the properties on the nodes. The @id directive means that the ID field is a unique reference for when we need to connect nodes (more on that later)</figcaption></figure><p id="9a01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦在Apollo中设置了模式，就可以像使用GraphQL一样查询这些类型和字段。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Query for the basic schema objects</figcaption></figure><h1 id="575b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">返回链接的节点</h1><p id="11b3" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">当前返回的基本字段足以看到节点的值，但是使用图形数据库的主要原因是能够找到相关的节点，并且<code class="fe lt lu lv lw b">@neo4j/graphql</code>库提供了一些GraphQL指令来简化设置。</p><p id="c1d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lt lu lv lw b">@relationship</code>指令允许您为直接链接到正在定义的源节点的节点添加字段。它需要两个参数:<code class="fe lt lu lv lw b">type</code>是链接两个节点的边的类型，而<code class="fe lt lu lv lw b">direction</code>是关系的方向(对于定义边的另一个节点为<code class="fe lt lu lv lw b">IN</code>，如果源节点定义边为<code class="fe lt lu lv lw b">OUT</code>)。</p><h2 id="50f4" class="nk ma iq bd mb nl nm dn mf nn no dp mj ko np nq ml ks nr ns mn kw nt nu mp nv bi translated">从链接节点的边返回数据</h2><p id="2cfb" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">使用<code class="fe lt lu lv lw b">@relationshipProperties</code>指令可以扩展<code class="fe lt lu lv lw b">@relationship</code>字段，以包含在定义两个节点之间的边时设置的属性。<code class="fe lt lu lv lw b">@relationship</code>字段定义是一个<code class="fe lt lu lv lw b">properties</code>参数，它匹配实现<code class="fe lt lu lv lw b">@relationshipProperties</code>接口的类型。</p><p id="c7f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查询连接字段时，您将无法从字段内访问边数据，而是需要查询包含边数据和节点的<code class="fe lt lu lv lw b">[FIELD NAME]Connection</code>(例如<code class="fe lt lu lv lw b">userStoriesConnection</code>)对象</p><h2 id="6c8d" class="nk ma iq bd mb nl nm dn mf nn no dp mj ko np nq ml ks nr ns mn kw nt nu mp nv bi translated">从非直接链接的节点返回数据</h2><p id="8fd4" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">如果源节点和您想要返回的另一个节点之间没有明确的关系，因为它们共享一个公共的相关节点，那么您可以使用<code class="fe lt lu lv lw b">@cypher</code>指令来执行一个Cypher查询，并将结果作为一个字段返回。</p><p id="4256" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是如何在您的模式中使用这些指令:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Basic schema updated with fields for getting directly linked and indirectly linked nodes as well as properties from the edges linking UserStory to Product</figcaption></figure><p id="b295" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及获取关系的示例查询:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">In order to access the edge fields you need to query the connection, not the linked node but you can access the linked node via the connection</figcaption></figure><h1 id="2699" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">通过GraphQL向Neo4J写入数据</h1><p id="eace" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><code class="fe lt lu lv lw b">@neo4j/graphql</code>库创建了一组有用的突变，用于对我们已经介绍过的GraphQL模式中定义的类型执行创建-读取-更新-删除(CRUD)操作，但这里是如何创建、更新和删除节点和边。</p><h2 id="2869" class="nk ma iq bd mb nl nm dn mf nn no dp mj ko np nq ml ks nr ns mn kw nt nu mp nv bi translated">添加节点和边</h2><p id="9b4c" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">要创建一个新节点，您可以调用<code class="fe lt lu lv lw b">create[TYPE NAME]</code>(例如<code class="fe lt lu lv lw b">createTest</code>)变异，它将接受一个输入对象，该对象是该类型的非ID字段。这方面的一个例子是:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The input object is essentially the same as the type but without the ID field as this is set automatically. You can return the ID after the new node is created</figcaption></figure><h2 id="a64e" class="nk ma iq bd mb nl nm dn mf nn no dp mj ko np nq ml ks nr ns mn kw nt nu mp nv bi translated">更新节点和边</h2><p id="9a9d" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">要更新一个节点，您可以调用<code class="fe lt lu lv lw b">update[TYPE NAME]</code>(例如<code class="fe lt lu lv lw b">updateTest</code>)变异，它将接受一个where对象(用于查找要更新的节点)和一个包含该节点上要更新的字段的update对象。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">In order to update a node you need to define a where the object which will help Neo4J find the node to update, the update object defines the fields to change on the node</figcaption></figure><p id="7d4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用相同的<code class="fe lt lu lv lw b">update[TYPE NAME]</code>变异来创建节点之间的新边，方法是定义一个<code class="fe lt lu lv lw b">connect</code>或<code class="fe lt lu lv lw b">connectOrCreate</code>对象，用一个<code class="fe lt lu lv lw b">where</code>对象来查找源节点，用一个<code class="fe lt lu lv lw b">where</code>对象来查找目标节点(不同之处在于<code class="fe lt lu lv lw b">connectOrCreate</code>将创建所链接的节点，如果它不存在)。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Similar to the update mutation but instead of ‘update’-ing a node we ‘connect’ a node based on its field that has the relationship directive on it.</figcaption></figure><h2 id="2781" class="nk ma iq bd mb nl nm dn mf nn no dp mj ko np nq ml ks nr ns mn kw nt nu mp nv bi translated">移除节点和边</h2><p id="fd5a" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">如果您想要移除两个节点之间的边，您可以使用相同的<code class="fe lt lu lv lw b">update[TYPE NAME]</code>变异，但是您可以使用一个<code class="fe lt lu lv lw b">where</code>对象来定义一个<code class="fe lt lu lv lw b">disconnect</code>对象，而不是一个<code class="fe lt lu lv lw b">connect</code>对象，以找到要移除链接的节点。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The disconnect operation is basically the same as the connect operation but with the disconnect name</figcaption></figure><p id="e60f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用带有<code class="fe lt lu lv lw b">where</code>对象的<code class="fe lt lu lv lw b">delete[TYPE NAME]</code>(例如<code class="fe lt lu lv lw b">deleteTest</code>)变异来找到要删除的节点，从而删除节点。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Deleting a node, similar to updating nodes requires a where object. Because the node will be deleted the only fields that can be returned are the number of nodes deleted and the relationships that were deleted</figcaption></figure><h1 id="4016" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在应用程序中使用API</h1><p id="a6ff" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">有许多GraphQL客户端可以在您的应用程序中使用，以便使用GraphQL从Neo4J图形中提取数据。</p><p id="533f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">页面顶部链接的概念证明repo包含一个我为使用GraphQL API而创建的基本Figma插件，它使用Apollo client for React，该客户端通过React上下文公开Apollo客户端，并具有<code class="fe lt lu lv lw b">useQuery</code>和<code class="fe lt lu lv lw b">useMutation</code>挂钩来执行较低级组件内的操作。</p><p id="d85e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些钩子执行与上面列出的相同的查询和变异，所以通过使用Apollo沙箱并复制它们，很容易构建这些调用。</p><h1 id="7196" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="d1cc" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><code class="fe lt lu lv lw b">@neo4j/graphql</code>库在Neo4J的基础上创建了一个非常强大的API，使得那些没有什么图形数据库经验的人(比如我自己)可以很容易地构建应用程序，在处理记录之间的关系时，可以利用图形数据库提供的好处。</p><p id="00d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我提到的CRUD例子和指令实际上只是这个库的表面功能，所以我强烈推荐阅读<a class="ae lb" href="https://neo4j.com/docs/graphql-manual/current/" rel="noopener ugc nofollow" target="_blank">Neo4J graph QL库文档</a>，因为它组织得很好，很有见地。</p><p id="3679" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以找到我的概念验证代码，其中包含Neo4J测试数据、GraphQL服务器和我在Gitlab上创建的示例Figma插件，以证明我的想法:</p><div class="nw nx gp gr ny nz"><a href="https://gitlab.com/colinfwren/neo4j-and-graphql-example" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">Colin Wren / Neo4J和GraphQL示例</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">15.0主要版本即将发布！该版本为GitLab带来了许多令人兴奋的改进，但也删除了一些…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">gitlab.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on lm nz"/></div></div></a></div><p id="d4c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oo">更多内容看</em> <a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="oo">说白了就是io </em> </strong> </a> <em class="oo">。报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="oo">免费周报</em> </strong> </a> <em class="oo">。关注我们关于</em><a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oo">Twitter</em></strong></a><em class="oo">和</em><a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oo">LinkedIn</em></strong></a><em class="oo">。加入我们的</em> <a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="oo">社区不和谐</em> </strong> </a> <em class="oo">。</em></p></div></div>    
</body>
</html>