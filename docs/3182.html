<html>
<head>
<title>Under the Hood: Worst Case Complexities &amp; Workings of Popular JS Array Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下:最坏情况的复杂性&amp;流行的JS数组方法的工作方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/under-the-hood-worst-case-complexities-workings-of-popular-js-array-methods-739d5fef314a?source=collection_archive---------1-----------------------#2022-08-07">https://javascript.plainenglish.io/under-the-hood-worst-case-complexities-workings-of-popular-js-array-methods-739d5fef314a?source=collection_archive---------1-----------------------#2022-08-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0983" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">概述:了解流行的JS数组方法以及它们是如何工作的。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/37257040d945c80cc97c11d64bd6ea67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaVF_8gkz0OxfPsnrHX57g.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@gamell?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joan Gamell</a> on <a class="ae ks" href="https://unsplash.com/s/photos/js?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="5198" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">概述:</h2><ol class=""><li id="c298" class="lp lq in lr b ls lt lu lv lc lw lg lx lk ly lz ma mb mc md bi translated">介绍</li><li id="1a61" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated">大O符号和工作方法如下:</li></ol><p id="e5db" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><em class="my">。在()，。copyWithin()，。concat()，。条目()，。every()，。fill()，。find()，。filter()，。forEach()，from()，includes()，indexOf()，。map()，。reduce()，… (spread运算符)，shift()，some()，slice()，splice()，sort()，push()，pop()，。toString()，unshift()，values() </em></p><p id="1fb4" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><em class="my">需求——大O符号，JS数据结构。</em></p><p id="c40f" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><em class="my">级别—中级</em></p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="be1d" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">简介:</h1><p id="9a43" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">对于所有JS开发人员来说，无论您是专业人员还是试图破解令人恐惧的编码面试，都可以使用内置数组方法。filter()，。reduce()，。map()等。是我们的第二天性。</p><p id="74f1" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">这些方法引入了一个抽象层次，使得代码更容易阅读，编写起来更简单快捷。</p><p id="e4d8" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">但是你有没有想过这种方法最糟糕的时间和空间复杂性(大O)是什么，或者它们是如何工作的？它们可能看起来像简单的一行程序，但是很多都隐藏在里面。</p><p id="e147" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">在本文中，我们将深入研究这些方法的幕后工作和效率。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="5280" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">在我们继续之前…</h1><p id="33fd" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">任何数组操作都没有指定的<em class="my">时间</em>复杂度保证。数组的性能取决于引擎选择的底层数据结构。引擎也可能有不同的表示，并根据特定的启发在它们之间切换。[4]</p><p id="190f" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">数组操作几乎总是根据它所代表的运行时引擎进行优化。</p><p id="21b6" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><strong class="lr io"> <em class="my">因此</em> </strong> <em class="my">，这篇文章概述了如果不进行优化，这些数组方法的空间和时间复杂性是什么，以及用来表示它们的底层数据结构是一个数组。</em></p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="be95" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。在()</h1><p id="cd54" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">at()</strong></code>方法接受一个整数值，并返回正整数的索引项。对于负整数，从数组的最后一项开始计数。[6]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="d270" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="195f" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="1420" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">方法不会循环访问数组来获取元素。它使用直接给出的索引。</p><p id="5a0d" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="325a" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">此方法从数组中返回单个元素。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="7234" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。copyWithin()</h1><p id="2eed" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">copyWithin()</strong></code>方法将数组的一部分复制到同一个数组中的另一个位置，并在不修改其长度的情况下返回它。[5]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="70e1" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><strong class="lr io">大O: </strong></p><p id="9e04" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="61c0" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">这种方法类似于C++的<code class="fe nu nv nw nx b"><strong class="lr io">memmove</strong></code><strong class="lr io"/>【5】用来移动数组中的数据。在最坏的情况下，n-1个元素将被复制到数组中的新位置。</p><p id="e72a" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="d23c" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">所有修改都已就绪，修改后将返回原始数组。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="dfde" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。concat()</h1><p id="ac68" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">concat()</strong></code>方法用于合并两个或多个数组，返回一个浅拷贝的新数组。[7]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="23ca" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="a532" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="7038" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">当两个数组被<em class="my">合并</em>时，该操作将考虑合并最大列表所花费的时间。</p><p id="6500" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="6045" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">此方法的结果是两个数组的浅表副本。因此，空间复杂度为O(n)。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="a7bc" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。条目()</h1><p id="5e3a" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">entries()</strong></code>方法返回一个新的数组迭代器对象，它包含数组中每个索引的键/值对。[19]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="1bf0" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="c756" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="8aa1" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">所有的元素都必须被线性扫描，并且在迭代器对象中包含一个数组[index，element]。</p><p id="36fb" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="0d7a" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">返回一个新的迭代器对象，其中包含每个元素的数组。单个数组具有恒定的间距。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="6451" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。每隔()</h1><p id="70e6" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">every()</strong></code>方法测试数组中的所有元素是否通过由提供的函数实现的测试，并返回一个布尔值。[20]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="6218" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="ef5f" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="f296" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">在最坏的情况下，所有的元素都被扫描并对照测试进行检查。</p><p id="6795" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="3937" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法返回一个布尔值。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="b286" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。填充()</h1><p id="d44d" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">fill()</strong></code>方法将数组中的所有元素更改为给定的静态值，从起始索引(默认为<code class="fe nu nv nw nx b">0</code>)到结束索引(默认为<code class="fe nu nv nw nx b">array.length</code>)，并返回修改后的数组。[21]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="0932" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="e77e" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度—<strong class="lr io"><em class="my"/></strong></p><p id="065d" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该阵列的所有元素可以在线性时间内改变。</p><p id="28a5" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="a838" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">方法返回修改后的数组。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="bfde" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。过滤器()</h1><p id="3bde" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">filter()</strong></code>方法创建了一个<em class="my">浅拷贝</em>，它包含了所有通过过滤函数的元素。[22]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">In this example, the new ‘result’ array contains element which are greater than 4.</figcaption></figure><h2 id="dd01" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="179e" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="4378" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">线性地对数组<strong class="lr io"><em class="my"/></strong>的所有元素执行回调函数，分别检查它们是否通过测试。</p><p id="5566" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="d125" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">filter方法的结果存储在一个新数组中。在最坏的情况下，所有元素都可能通过测试，因此，空间将等于输入数组的大小。</p><p id="b4c6" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><strong class="lr io">注:</strong> <em class="my">浅拷贝是与源有相同引用的拷贝。这意味着对新拷贝的任何更改也会反映在源代码中。例如:在上面的例子中，从“结果”数组中删除值6也会将其从“值”数组中删除。</em></p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="e149" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。查找()</h1><p id="914e" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">find()</strong></code>方法返回所提供的数组中满足所提供的测试函数的第一个元素。[23]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="7e00" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="82e1" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="aa5e" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">测试函数可能必须在线性时间内检查数组的所有元素。</p><p id="a70e" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性—<strong class="lr io"><em class="my">O①</em></strong></p><p id="0156" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">通过测试的第一个元素从数组中返回。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="fa38" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。forEach()</h1><p id="c9d9" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">forEach()</strong></code>方法为每个数组元素执行一次提供的函数。[24]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="d323" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="16f2" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="59dc" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">回调函数线性地在数组<strong class="lr io"><em class="my"/></strong>的所有元素上实现，并且就地进行改变。</p><p id="04a8" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="9073" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">在所有元素都经历了回调函数之后，返回相同的数组，因此没有使用额外的空间。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="d3aa" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。来自()</h1><p id="ad37" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><em class="my">Array . from()</em><em class="my">static</em>方法从可迭代或类似数组的对象(如字符串、数组、映射或集合)创建一个新的、空拷贝的<em class="my">数组实例。[25]</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Here, the string ‘abcd ef gh’ is converted to an array with each letter as an element. In the second example, a call back function is implemented to increment every element by 1.</figcaption></figure><h2 id="515d" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="41ca" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="d6fd" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">回调函数线性地在数组<strong class="lr io"><em class="my"/></strong>的所有元素上实现，并且就地进行更改。</p><p id="3613" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="ee7d" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">创建一个新的元素数组，它使用的空间与输入的类似数组的对象大约相同。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="21f0" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。包括()</h1><p id="09b0" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">includes()</strong></code>方法检查数组中是否存在一个值或元素，并分别返回<em class="my">真</em>或<em class="my">假</em>。[26]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Here, string ‘c’ exists in arr2 hence output is the boolean value true whereas string ‘z’ does not which is false.</figcaption></figure><h2 id="6915" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="4de3" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="ad43" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">在最坏的情况下，该方法必须迭代并检查数组中的所有值。</p><p id="7c41" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="0857" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法返回布尔值true或false，这不需要额外的空间。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="e833" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。索引Of()</h1><p id="6b10" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">indexOf()</strong></code>方法返回给定元素在数组中的第一个索引，如果不存在则返回-1。[18]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="fc43" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="1e59" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="d5bb" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法必须在最坏的情况下解析所有元素，以确定该元素是否存在。</p><p id="4cad" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="f074" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">方法返回元素的索引或-1。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="2b22" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。加入()</h1><p id="5eaa" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">join()</strong></code>方法通过连接一个数组中的所有元素(或一个类似于<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects" rel="noopener ugc nofollow" target="_blank">数组的对象</a>)创建并返回一个新的字符串，用逗号或指定的分隔符字符串分隔。[17]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="ae17" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="bdbc" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="f1b1" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">为了创建字符串，必须对所有元素进行线性解析。</p><p id="d597" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(n*m) </em> </strong></p><p id="6fe9" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法返回一个字符串，其中n是节点数，m是最大字符串的长度。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="40b0" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。地图()</h1><p id="4509" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">map()</strong></code>方法创建一个新的数组，用调用数组中每个元素的函数的结果填充。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="ebe5" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="0428" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="2465" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">这种方法利用一个回调函数来单独和线性地处理每个元素，并存储在新的数组中。</p><p id="fd23" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="43b8" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">方法使用回调函数修改的原始数组的值创建一个新数组。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="3a73" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。减少()</h1><p id="607e" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">reduce()</strong></code>方法在数组的每个元素上执行一个回调函数，称为“reducer ”,方法是传递前一个元素计算的返回值。对数组的所有元素运行缩减器的最终结果是一个值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Here, the previousValue (return value from calculation of preceding element) is added to the current element and returned. All the elements in the above array are added.</figcaption></figure><h2 id="0fa0" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="b751" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="25ee" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法通过对每个元素逐一运行回调函数来返回累积计算值。</p><p id="1a94" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="48a2" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法从所有元素的累积计算中返回一个值。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="635c" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">…(扩展语法)</h1><p id="1a0c" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">spread语法(<code class="fe nu nv nw nx b">...</code>)允许在零个或多个参数(用于函数调用)或元素(用于数组文字)的地方扩展iterable，如数组或字符串。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="611f" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="614a" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度—<strong class="lr io"><em class="my"/></strong></p><p id="9f55" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">对于数组，它连续调用数组迭代器的<code class="fe nu nv nw nx b">.next()</code>方法，直到迭代器用尽。</p><p id="3e2d" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="4e13" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><strong class="lr io"> <em class="my"> O(n) - &gt; </em> </strong>如果像上面的例子那样在创建新数组时使用，spread语法将创建原始数组的深层副本。</p><p id="8ea2" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><strong class="lr io"> <em class="my"> O(1) - &gt; </em> </strong>如果仅用于迭代数组或将参数传递给函数。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="1826" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。一些()</h1><p id="c847" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">some()</strong></code>方法测试<em class="my">数组中是否至少有一个</em>元素通过了由提供的函数实现的测试(回调Fn ),如果是则返回true，否则返回false。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Here .some() checks if at least 1 element in the array is odd and returns true</figcaption></figure><h2 id="c267" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="0a1c" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度—<strong class="lr io"><em class="my"/></strong></p><p id="4d7b" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">这个方法<strong class="lr io"> <em class="my">线性地</em> </strong>遍历数组，看看是否至少有一个元素匹配测试。在最坏的情况下，它必须检查所有的元素。</p><p id="25ac" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="0fc9" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法返回一个布尔值。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="838e" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。推送()</h1><p id="a202" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">push()</strong></code>方法将一个或多个元素添加到数组的末尾，并返回数组的新长度。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The element is inserted in the back of the array. So, [0, -1, 2, 8] becomes [0, -1, 2, 8, -5].</figcaption></figure><h2 id="3192" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="d0b4" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="b13c" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">此方法直接利用当前长度属性向数组末尾添加一个元素，并将长度增加1。</p><p id="fa46" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="55fe" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">方法返回数组的更新长度。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="f3ce" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。流行()</h1><p id="d101" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">pop()</strong></code>方法从数组中移除最后一个<strong class="lr io">元素并返回该元素。此方法更改数组的长度。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="84ab" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="c6f7" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="7230" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">此方法直接利用当前长度属性将元素移至数组末尾，并将长度减1。</p><p id="6d38" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="0d8c" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">方法返回数组中移除的元素。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="593d" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。反向()</h1><p id="4969" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">reverse()</strong></code>方法就地反转一个数组。第一个数组元素成为最后一个，最后一个数组元素成为第一个。[16]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="2e4c" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="6b60" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="faeb" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">阵列的第一个和最后一个元素的交换线性进行，直到阵列反转。</p><p id="0df5" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="d8cd" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法就地反转占用恒定空间的数组。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="5a44" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。shift()</h1><p id="a257" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">方法从数组中移除第一个元素并返回移除的元素。[15]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9d5a" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="8cb9" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">为了从数组的开始移除一个元素，所有随后的元素必须相应地移位。</p><p id="fa57" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(1) </em> </strong></p><p id="cf6d" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">返回移除的元素。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="5b1f" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。切片()</h1><p id="31d3" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">slice()</strong></code>方法将数组的一部分的浅拷贝返回到从<em class="my">开始</em>索引到<em class="my">结束</em>索引选择的新数组对象中。原始数组不会被修改。[14]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="ca97" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="d4ba" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="4c9c" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">如果必须访问所有元素，那么对浅层副本的写入将是线性的。</p><p id="a944" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="3b7a" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">如果没有给定索引，则返回数组的一个新的浅表副本。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="0a9f" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。排序()</h1><p id="6901" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">sort()</strong></code>方法对一个数组的元素进行就地排序，并返回对同一个数组的引用，现在已经排序了。[12]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="14f0" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="2b30" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度—<strong class="lr io"><em class="my">(nlogn)</em></strong></p><p id="a36a" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">对于较大的数组，快速排序通常用于对数组进行排序。[13]</p><p id="71e7" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(logn) </em> </strong></p><p id="2e39" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">快速排序需要logn堆栈空间来实现排序。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="2fde" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。拼接()</h1><p id="2ff3" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">splice()</strong></code>方法通过移除或替换现有元素和/或在适当的位置添加新元素来改变数组的内容。[11]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="c929" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="6a17" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="0062" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">在最坏的情况下，如果向阵列中添加一个元素，则必须移动n-1个元素。</p><p id="8267" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性—<strong class="lr io"><em class="my">O(n+k)~ O(n)</em></strong></p><p id="bc0c" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">如果将k个元素添加到数组中，那么新的长度将是以前的长度+ k ~ n。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="ebeb" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。toString()</h1><p id="20d5" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">toString()</strong></code>方法返回一个代表指定数组及其元素的字符串。[10]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="e2b1" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="0fb6" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度—<strong class="lr io"><em class="my">【O(n)</em></strong></p><p id="19ec" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">为了创建字符串，必须对所有元素进行线性解析。</p><p id="e3c1" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(n*m) </em> </strong></p><p id="929d" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法返回一个字符串，其中n是节点数，m是最大字符串的长度。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="dfc6" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。未移位()</h1><p id="1dd5" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">unshift()</strong></code>方法将一个或多个元素添加到数组的开头，并返回数组的新长度。[9]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="2abe" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="86bd" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="38be" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">为了在数组的开头添加一个元素，所有后续的元素都必须相应地移位。</p><p id="b1af" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂性— <strong class="lr io"> <em class="my"> O(n + k) ~ O(n) </em> </strong></p><p id="51e5" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">在数组中，k个新元素与前n个元素一起添加。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="0749" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">。值()</h1><p id="f82d" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated"><code class="fe nu nv nw nx b"><strong class="lr io">values()</strong></code>方法返回一个新的数组迭代器对象，它包含数组中每个索引的值。[8]</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="3fc8" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">大O:</h2><p id="4708" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">时间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="85f5" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">所有元素都必须线性添加到对象中。</p><p id="dbab" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">空间复杂度— <strong class="lr io"> <em class="my"> O(n) </em> </strong></p><p id="cef7" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">该方法返回一个数组迭代器对象，它包含数组的所有元素。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="f081" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">结论:</h1><p id="f51c" class="pw-post-body-paragraph mj mk in lr b ls lt jo mm lu lv jr mo lc nr mq mr lg ns mt mu lk nt mw mx lz ig bi translated">在本文中，我们看到了最坏情况下的时间和空间复杂性，以及JS数组方法的幕后工作。</p><p id="5412" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated">下次见。干杯！</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="11d3" class="ng ku in bd kv nh ni nj ky nk nl nm lb jt nn ju lf jw no jx lj jz np ka ln nq bi translated">参考资料:</h1><ol class=""><li id="5d6b" class="lp lq in lr b ls lt lu lv lc lw lg lx lk ly lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></li><li id="510c" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://dev.to/lukocastillo/time-complexity-big-0-for-javascript-array-methods-and-examples-mlg" rel="noopener ugc nofollow" target="_blank">时间复杂度大0的Javascript数组方法及实例。</a></li><li id="fa50" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://medium.datadriveninvestor.com/big-o-notation-14fa1e4538a1" rel="noopener ugc nofollow" target="_blank">大O批注</a></li><li id="0444" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://stackoverflow.com/questions/11514308/big-o-of-javascript-arrays/61713477#61713477" rel="noopener ugc nofollow" target="_blank">Javascript数组的大O。</a></li><li id="ccff" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin" rel="noopener ugc nofollow" target="_blank">copy within()方法</a></li><li id="4cd4" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at" rel="noopener ugc nofollow" target="_blank">at()方法</a></li><li id="8b79" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" rel="noopener ugc nofollow" target="_blank">concat()方法</a></li><li id="9816" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values" rel="noopener ugc nofollow" target="_blank">数值()方法</a></li><li id="58d0" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" rel="noopener ugc nofollow" target="_blank"> unshift()方法</a></li><li id="85ec" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString" rel="noopener ugc nofollow" target="_blank"> toString()方法</a></li><li id="e15a" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="noopener ugc nofollow" target="_blank">拼接()方法</a></li><li id="42e6" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank"> sort()方法</a></li><li id="82be" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://blog.shovonhasan.com/time-space-complexity-of-array-sort-in-v8/" rel="noopener ugc nofollow" target="_blank">V8中的大O实现sort() </a></li><li id="648e" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">切()法</a></li><li id="0a6a" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" rel="noopener ugc nofollow" target="_blank"> shift()方法</a></li><li id="2def" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" rel="noopener ugc nofollow" target="_blank">反向()方法</a></li><li id="5f76" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" rel="noopener ugc nofollow" target="_blank"> join()方法</a></li><li id="a9e6" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" rel="noopener ugc nofollow" target="_blank"> indexOf()方法</a></li><li id="d61d" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries" rel="noopener ugc nofollow" target="_blank">条目()方法</a></li><li id="30d1" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank"> every()方法</a></li><li id="0694" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" rel="noopener ugc nofollow" target="_blank"> fill()方法</a></li><li id="f975" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">过滤()方法</a></li><li id="92c0" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" rel="noopener ugc nofollow" target="_blank">查找()方法</a></li><li id="2fed" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"> forEach()方法</a></li><li id="12a4" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" rel="noopener ugc nofollow" target="_blank">从()方法</a></li><li id="bea0" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="noopener ugc nofollow" target="_blank">包括()方法</a></li></ol></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="dc65" class="pw-post-body-paragraph mj mk in lr b ls ml jo mm lu mn jr mo lc mp mq mr lg ms mt mu lk mv mw mx lz ig bi translated"><em class="my">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lr io"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lr io"> <em class="my">免费周报</em> </strong> </a> <em class="my">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lr io"><em class="my">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lr io"><em class="my">LinkedIn</em></strong></a><em class="my">，以及</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lr io"> <em class="my">不和</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>