<html>
<head>
<title>React Native Architecture — Old Vs New</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应原生架构—旧与新</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-new-architecture-old-vs-new-d0130f42bc79?source=collection_archive---------1-----------------------#2022-08-12">https://javascript.plainenglish.io/react-native-new-architecture-old-vs-new-d0130f42bc79?source=collection_archive---------1-----------------------#2022-08-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c14a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">新旧React原生架构之间的端到端比较。更多关于JSI、Turbo模块和Fabric的信息。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ee23f7c91a0cd05ee1f5ed5c2b8cad11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6heoOAgrxXZ3BoJrPRDYUQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React Native Architecture (Old vs New)</figcaption></figure><p id="8dbc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">欢迎来到另一个博客，在上一个博客中，我们讨论了关于React Native的所有内容:优点、缺点和未来  <strong class="ku io">。</strong>将讨论向前推进，在这篇博客中，我们将通过了解当前的架构、缺点和新的架构来深入了解React Native的内部工作方式。</p><blockquote class="lp lq lr"><p id="67b1" class="ks kt ls ku b kv kw jo kx ky kz jr la lt lc ld le lu lg lh li lv lk ll lm ln ig bi translated">🎺🎺🎺<strong class="ku io"> <em class="in">最新博客上的公告</em> </strong>🎺🎺🎺：</p><p id="4fa8" class="ks kt ls ku b kv kw jo kx ky kz jr la lt lc ld le lu lg lh li lv lk ll lm ln ig bi translated"><a class="ae lo" href="https://medium.com/@srvkmr130/analysis-of-react-native-new-architecture-with-results-1c157ab9c9c8?source=your_stories_page-------------------------------------" rel="noopener"><strong class="ku io"><em class="in">React Native新架构分析及结果—</em></strong>React Native讲座之一总结&amp; Flutter — Hybrid meetup。新的React本机体系结构的结果以及分析。</a></p></blockquote></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h2 id="66c2" class="md me in bd mf mg mh dn mi mj mk dp ml lb mm mn mo lf mp mq mr lj ms mt mu mv bi translated"><strong class="ak">当前架构</strong></h2><p id="7416" class="pw-post-body-paragraph ks kt in ku b kv mw jo kx ky mx jr la lb my ld le lf mz lh li lj na ll lm ln ig bi translated">在当前的场景中，当我们查看react原生架构时，我们发现两个不同的部分经常相互作用——一个是原生世界，另一个是JavaScript世界。众所周知，React Native通过创建本地元素来帮助我们构建<strong class="ku io">跨平台</strong>应用程序，这些元素可以很容易地被本地世界理解。因此，我们不能直接访问创建的元素的节点，所以我们不能使用React (JavaScript world)执行任何类型的操作。那么两个世界之间的交流是如何发生的呢？嗯，这种双向交互通过<strong class="ku io"> React Native bridge </strong>发生。React Native将来自React世界的一堆命令解析为一个JSON数组，将其序列化为一个字符串，然后通过那个桥将其传输到本地世界。</p><p id="786c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了保持跨所有平台的一致性，React Native通过将基于React的显示样式(例如，flex)转换为每个元素的相对位置值来实现实际布局，然后最终将其传递到本机世界的UI层。概括地说，当前的React本机架构基于3个主要线程-</p><ol class=""><li id="b601" class="nb nc in ku b kv kw ky kz lb nd lf ne lj nf ln ng nh ni nj bi translated"><strong class="ku io"> Main/Native/UI线程</strong> —所有UI元素都在这里呈现，本地代码也在这里执行。</li><li id="5bb5" class="nb nc in ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated"><strong class="ku io">布局线程/阴影线程</strong> —这是一个计算实际布局的后台线程。如前所述，它在脸书的布局引擎<strong class="ku io"> Yoga </strong>的帮助下重铸了flexbox的布局。</li><li id="285c" class="nb nc in ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated"><strong class="ku io"> JavaScript线程</strong> —这个线程负责执行和编译所有JavaScript相关的代码。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/bbc71372ea55420ccf648123c431b201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWqmBOsC-tWGyBa5lfpbeA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React Native current architecture</figcaption></figure></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h2 id="cafa" class="md me in bd mf mg mh dn mi mj mk dp ml lb mm mn mo lf mp mq mr lj ms mt mu mv bi translated">缺点</h2><ol class=""><li id="6e54" class="nb nc in ku b kv mw ky mx lb nq lf nr lj ns ln ng nh ni nj bi translated">在当前的体系结构中，线程之间的通信是通过桥进行的，因此它导致了较低的传输速率和不必要的数据复制。</li><li id="bfd4" class="nb nc in ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">由于通信是异步发生的，这种异步方法的一个主要缺点是它不实时执行事件，而是调度动作。让我们想象一个场景，我们实现了一个平面列表，当我们开始滚动时，每次事件被触发并被安排执行。因此，当处理大量列表项并快速滚动时，在实际呈现发生之前，人们很容易注意到一个白色小故障。发生这种情况是因为当滚动完成时，本地世界的UI层还没有收到任何布局信息。因此，这种滚动效果需要同步发生，以实现期望的结果，这在当前的架构中是不可能的。</li></ol><p id="3190" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">因此，需要能够解决这些问题的新型/现代建筑。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h2 id="1591" class="md me in bd mf mg mh dn mi mj mk dp ml lb mm mn mo lf mp mq mr lj ms mt mu mv bi translated"><strong class="ak">新建筑就位</strong></h2><p id="95fc" class="pw-post-body-paragraph ks kt in ku b kv mw jo kx ky mx jr la lb my ld le lf mz lh li lj na ll lm ln ig bi translated">新的架构引入了一个称为JavaScript接口(JSI)的不同层，作为React Native bridge的替代。这一层将允许本地世界与Javascript世界直接通信，因此JS线程和本地模块的完全同步现在是可能的。</p><p id="7a3e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">JSI架构的优势-</p><ol class=""><li id="8447" class="nb nc in ku b kv kw ky kz lb nd lf ne lj nf ln ng nh ni nj bi translated"><strong class="ku io"> Turbo模块:</strong>首先，这一层将允许JS保存宿主对象的引用，并在需要时调用它们的方法。所以即使在应用打开之前，我们也不需要预加载JavsScript使用的原生模块。这也消除了额外的序列化开销，这是我们目前在基于桥的架构中所具有的。</li><li id="4ec0" class="nb nc in ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated"><strong class="ku io">Fabric:</strong>JSI提供的另一个优势是它为下一代React原生视图管理器(称为Fabric)奠定了基础。在Fabric的帮助下，渲染机制变得更加优化和高效，因为它将直接在C++中创建阴影树，从而提高与主机平台的互操作性。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/959aef8844735b3f9f79ef07c8d890d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sI7OWs6q-fhgVU25dS0Lgg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React Native Re-Architecture</figcaption></figure></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h2 id="8cf5" class="md me in bd mf mg mh dn mi mj mk dp ml lb mm mn mo lf mp mq mr lj ms mt mu mv bi translated">结论</h2><p id="b4ef" class="pw-post-body-paragraph ks kt in ku b kv mw jo kx ky mx jr la lb my ld le lf mz lh li lj na ll lm ln ig bi translated">所以这都是关于React Native的新旧架构。最有可能在2022年底，我们会从React本地团队听到一些关于新架构推出的好消息。</p><p id="1c7a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="ls">关于最佳编码实践——请查看我之前的博客:</em> <a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/best-coding-practices-react-native-edition-2022-da833c8161de"> <strong class="ku io"> <em class="ls">最佳编码实践——React Native Edition 2022</em></strong></a></p><p id="db45" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢阅读！</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><p id="d910" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="ls">更物在</em> <a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="ls">素朴</em></strong> </a> <em class="ls">。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。</em><a class="ae lo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ls">Twitter</em></strong></a><a class="ae lo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ls">LinkedIn</em></strong></a><em class="ls"/><a class="ae lo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ls">YouTube</em></strong></a><em class="ls">和</em><a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ku io">T42【不和</strong></a><em class="ls">。</em></p></div></div>    
</body>
</html>