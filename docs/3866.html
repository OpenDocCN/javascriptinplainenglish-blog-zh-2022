<html>
<head>
<title>Breadth-First Search in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的广度优先搜索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/breadth-first-search-in-javascript-daa5626323d3?source=collection_archive---------3-----------------------#2022-10-04">https://javascript.plainenglish.io/breadth-first-search-in-javascript-daa5626323d3?source=collection_archive---------3-----------------------#2022-10-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4ea4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">广度优先搜索的工作原理以及如何用Javascript实现它</h2></div><p id="4d46" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图搜索算法是竞争性编程和面试中常见问题的基础，并且经常在生产应用程序本身中使用。程序员可以使用几种算法来解决他们的特定问题，每种算法都有自己的实现和优缺点。本文将介绍广度优先搜索，也称为BFS。BFS使用队列遍历一个图(或树)。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/579af50ae3df25117c2afecdab739aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMfeRIO_uCFD2UjuNNEdOw.jpeg"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@safarslife?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Safar Safarov</a> on <a class="ae lo" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="28ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">广度优先搜索包括以下步骤:</p><ol class=""><li id="8243" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">首先，将一个节点出队并标记为已访问。广度优先搜索需要一个数据结构来存储一个节点以前是否访问过。有多种数据结构和方法可用于确定节点之前是否被访问过。这些包括HashMap、dictionary或JSON对象，一个二维数组。然而，最直接的方法是使用一维布尔数组。有必要检查节点之前是否被访问过，因为如果图是循环的，则节点不会被重新访问。如果要重新访问节点，那么算法将永远运行下去。</li><li id="3322" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">第二，与当前节点相邻的未被访问的每个点被添加到队列中(排队)。根据用于数据输入的数据结构，有许多方法可以确定哪些节点与当前节点相邻。这些数据结构包括邻接矩阵。如果图形是网格的形式，那么当前点周围的点可以被识别(如果它们在边界内)并被遍历。</li></ol><p id="0571" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行广度优先搜索的时间复杂度是O(节点+边)。时间复杂度是O(节点+边)，因为每个顶点迭代一次，每个边迭代两次(尽管根据实现可以更少)。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi md"><img src="../Images/88a4c1ea812da25a302cd94d1f8a83bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gupu8RARlP86tYq1pWP7oQ.jpeg"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@lunarts?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Volodymyr Hryshchenko</a> on <a class="ae lo" href="https://unsplash.com/s/photos/solving?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0781" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">广度优先搜索最常用于路径查找算法，其中实现了优先级队列，而不是常规队列，节点按照到达该节点所需的距离进行排序。使用优先级队列将广度优先搜索的时间复杂度增加了log(n)倍。</p><p id="6d83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看广度优先搜索如何在样本图上工作:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi me"><img src="../Images/4f5631fb44546dd14d9620225e948c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*_4SGEr-76_lB3rbx.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Courtesy of visualgo.net</figcaption></figure><p id="5f66" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">广度优先搜索和深度优先搜索一样，必须从单个节点开始。在这种情况下，节点将是节点0。</p><ol class=""><li id="c9ab" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">节点0已出队。将visited[0]设置为true，因为当前正在访问节点0。</li><li id="72d5" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">穿过边缘。节点1被添加到队列中，因为它没有被访问过。</li><li id="8e87" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">节点1出列，并且visited[1]被设置为真。</li><li id="d8ca" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">穿过边缘。节点3被添加到队列中，因为它没有被访问过。</li><li id="4c36" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">节点3出列，并且visited[3]被设置为真。</li><li id="b4d6" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">穿过边缘。节点2被添加到队列中，因为它没有被访问过。节点4被添加到队列中，因为它没有被访问过。</li><li id="38b6" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">节点2出列，并且visited[2]被设置为真。</li><li id="3454" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">穿过边缘。因为已经访问了节点1，所以没有任何东西被添加到队列中。</li><li id="36ed" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">节点4出列，并且visited[4]被设置为真。</li></ol><p id="2686" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这在图表的其余部分继续进行。</p><p id="a94b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要在JavaScript中实现这一点，首先需要定义一个被访问的数组。</p><pre class="kz la lb lc gt mf mg mh mi aw mj bi"><span id="3d1e" class="mk ml in mg b gy mm mn l mo mp">var visited = new Array(nodeCount).fill(false);</span></pre><p id="e148" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">初始节点是队列中的第一个值，在这个基数中，是节点0。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mq"><img src="../Images/2845849a35b50c7293bfeeb66c1f0273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Laj6pvbOAhoW6wGB9RQZw.png"/></div></div></figure><p id="e71e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之，广度优先搜索是一种有用的算法，在竞争性编程问题中很流行，在现实生活中也有应用。在本教程中，我们回顾了广度优先搜索的步骤，并完成了一个JavaScript实现。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="905b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="my">更多内容请看</em><a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="my">免费周报</em> </strong> </a> <em class="my">。关注我们关于</em><a class="ae lo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="my">Twitter</em></strong></a><a class="ae lo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="my">LinkedIn</em></strong></a><em class="my"/><a class="ae lo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="my">YouTube</em></strong></a><em class="my"/><a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="my">不和</em> </strong> </a> <em class="my">。对增长黑客感兴趣？检查</em> <a class="ae lo" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="my">电路</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>