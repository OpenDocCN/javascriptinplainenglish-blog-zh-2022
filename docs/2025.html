<html>
<head>
<title>Data Structures and Algorithms: Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构和算法:记忆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-structures-and-algorithms-prep-memoization-cc5e5f75f9d8?source=collection_archive---------0-----------------------#2022-05-08">https://javascript.plainenglish.io/data-structures-and-algorithms-prep-memoization-cc5e5f75f9d8?source=collection_archive---------0-----------------------#2022-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d37c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">必须记住。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/92f6a7c0dae2a685680d692def8f6dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0yBGzofQzbSvZG2q"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shahadat Rahman</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fa9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我进入科技世界的漫长而曲折的旅程中，我遇到过许多不同的面试，涉及数据结构和算法。许多公司仍在使用带DSA问题的编码评估作为筛选申请人的第一步，所以我花时间研究了不同类型的问题和解决它们的方法。</p><p id="24b8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">记忆化就是这样一个主题，学习它很重要，而且有助于解决一些讨厌的代码面试问题。</p><h2 id="34fb" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">什么是记忆化，什么时候应该使用记忆化？</h2><p id="5feb" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">当处理递归或迭代函数时，比如一个函数多次调用自己或者发生大量迭代，程序的性能会明显下降。记忆化通过存储密集函数调用的结果并在需要加速程序时返回它们来帮助优化这些过程。让我们看一个例子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1a48" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个数的阶乘是从1到给定数的乘积。例如，4的阶乘等于1 * 2 * 3 * 4。上面的函数处理这个计算。它可以工作，但效率不高。第一次计算<code class="fe mp mq mr ms b">factorial(4)</code>递归调用自身4次，达到1 * 2 * 3 * 4 = 24的结果。第二次计算<code class="fe mp mq mr ms b">factorial(5)</code>得出的结果是1 * 2 * 3 * 4 * 5 = 120。该函数的每次调用都必须从1开始重新计算。现在这可能不是什么大问题，但是当处理大量数据时，它真的会减慢速度。如果有一种方法可以记住以前的计算，以便在将来调用函数时使用，那么效率会高得多。两个函数调用都有相同的计算结果1 * 2 * 3 * 4，那么如果我们能记住从<code class="fe mp mq mr ms b">factorial(4)</code>返回的值，那么当<code class="fe mp mq mr ms b">factorial(5)</code>被调用时，它等于24 * 5 = 120的计算结果呢？</p><h2 id="89b8" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">记忆价值观</h2><p id="7ae7" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">记忆的基本原理是将值存储到一个对象中，以便以后使用。本质上，这是一种记忆已完成函数的返回值的方式，这样就可以从memo对象中获取存储的值，而不是一遍又一遍地重新运行函数，从而节省时间。记忆化可以作为高阶函数来实现。它接受一个函数并检查它的参数，看看从这些参数返回的值是否被存储。如果是这样，它从memo对象获取值并返回它。如果没有，它允许函数正常运行，并将返回值存储在memo对象中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7f25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mp mq mr ms b">memoize</code>函数接受<code class="fe mp mq mr ms b">factorial</code>作为参数，并声明为<code class="fe mp mq mr ms b">memoizedFact</code>。第一个调用<code class="fe mp mq mr ms b">memoizedFact(10)</code>，必须运行完整的计算1 * 2 * 3…*10.返回值保存在memo对象中，无论何时使用相同的参数(本例中为10)调用，它都会从memo对象中获取计算值，而不是重新处理计算结果。这在计算11的下一个阶乘时也很方便。一旦<code class="fe mp mq mr ms b">factorial</code>函数递归调用<code class="fe mp mq mr ms b">factorial(10)</code>，它将再次获取保存的值。这大大缩短了处理时间，因为最终计算结果为<code class="fe mp mq mr ms b">11 * factorial(10)</code>，而不是1 * 2 * 3…..*11.</p><h2 id="2dce" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">很高兴知道</h2><p id="d4aa" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这只是一个基本的例子，希望能阐明记忆化是如何工作的，以及它如何优化程序。上面显示的memoize函数适用于大多数只包含一个参数的情况，但是如果有多个参数，就必须稍微修改一下。</p><p id="8030" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">记忆化是一个熟悉的好概念，因为它可能会在面试中的数据结构和算法问题中出现，特别是在处理关于寻找斐波那契数列的正确数字的问题时(查看<a class="ae ks" href="https://lucasfcosta.com/2016/01/25/Understanding-and-Applying-Memoization.html" rel="noopener ugc nofollow" target="_blank">这篇</a>文章，了解记忆化如何大大加快递归斐波那契函数的速度)。这也可能对你的下一个项目有所帮助，所以去看看吧！</p><p id="0413" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mt">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mt">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mt">免费周报</em> </strong> </a> <em class="mt">。关注我们</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mt">推特</em> </strong> </a> <em class="mt">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mt">LinkedIn</em></strong></a><em class="mt">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mt">社区</em> </strong> </a> <em class="mt">。</em></strong></a></p></div></div>    
</body>
</html>