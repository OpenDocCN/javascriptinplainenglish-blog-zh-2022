<html>
<head>
<title>How to Create Multi-Module Node.js Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建多模块Node.js应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-multi-module-nodejs-applications-9aff2d73dc17?source=collection_archive---------3-----------------------#2022-01-17">https://javascript.plainenglish.io/how-to-create-multi-module-nodejs-applications-9aff2d73dc17?source=collection_archive---------3-----------------------#2022-01-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a171" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多模块项目是JVM应用程序中的常见规范。大多数企业应用程序都会有它。它有它的优点和缺点。让我们看看如何在Node.js中实现多模块应用，它有什么好处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a17293a2db15a559f357cb21a8c4292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1kkjss6EfNGLQ0vK8QBhQ.jpeg"/></div></div></figure><h1 id="dc47" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">什么是多模块项目？</strong></h1><p id="2b06" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在JVM应用程序中，应用程序代码库被分割成逻辑子模块，并且这些子模块中的每一个都可以用作其他子模块中的依赖项。</p><p id="d86e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们举个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/24781e4c6edc22095962824e29e3da4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ODUVIxh6PMwzu3wN5AxhDg.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">A simple Maven multi-module project</figcaption></figure><p id="be3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们有:</p><ol class=""><li id="f8a4" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated">一个<code class="fe ml mm mn mo b">core</code>模块，假设它包含所有领域类、核心配置和实用程序类</li><li id="1bbe" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">一个包含所有外部API连接器的<code class="fe ml mm mn mo b">clients</code>模块</li><li id="b39a" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">一个将服务和业务规则作为rest api公开的<code class="fe ml mm mn mo b">api</code>模块</li><li id="539c" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">一个<code class="fe ml mm mn mo b">batch-job</code>模块，它将拥有每晚运行的任务来执行一些任务</li><li id="50a4" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">每个子模块都有自己的<code class="fe ml mm mn mo b">pom.xml</code>来管理依赖关系。</li></ol><h1 id="90cc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">那么，为什么是模块呢？</strong></h1><ol class=""><li id="6b0b" class="mc md in jm b jn ls jr lt jv mu jz mv kd mw kh mh mi mj mk bi translated">API和批处理作业可以拆分成可单独部署的组件，并且可以单独扩展。对于批处理作业，API可能需要的实例数量可能不相同。事实上，在大多数情况下，实例的数量会更少。</li><li id="0dd8" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">某些配置可能非常特定于API或批处理作业，而您不希望它们在两者上都可用。</li><li id="bc43" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">发展更快。子模块一旦构建，就可以作为依赖项使用。只有正在处理的模块需要构建，因为其他模块已经编译并作为依赖项添加。如果被用作依赖项的模块发生了变化，您也需要构建它。</li></ol><h1 id="8237" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">node . js中多模块的优势是什么？</strong></h1><p id="c737" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">上述优势同样适用于Node.js应用程序。当我在项目中拥有以下结构时，我发现它非常有用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d9d7572ad24b2783a74f18b0be6f89e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*xX-e5ux-YKg3zTO7OGsinA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Sample NodeJs application with multiple modules</figcaption></figure><h1 id="b313" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">如何实现？</strong></h1><p id="a8cb" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们需要使用名为<code class="fe ml mm mn mo b">workspaces</code>的npm特性来创建多模块项目。此功能在NPM版本7及更高版本中可用。</p><blockquote class="my mz na"><p id="f151" class="jk jl nb jm b jn jo jp jq jr js jt ju nc jw jx jy nd ka kb kc ne ke kf kg kh ig bi translated">以下代码演示是使用npm 8.x创建的</p></blockquote><p id="5f5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们创建一个文件夹<code class="fe ml mm mn mo b">demo-app</code>。在这方面，我们将有应用程序的模块。</p><pre class="kj kk kl km gt nf mo ng nh aw ni bi"><span id="6c88" class="nj kv in mo b gy nk nl l nm nn">npx create-react-app demo-frontend -template typescript</span></pre><p id="8145" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将在文件夹<code class="fe ml mm mn mo b">demo-frontend</code>中创建一个React应用程序。我们使用TypeScript，因为它更容易展示依赖功能。</p><p id="cbbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们有另一个名为<code class="fe ml mm mn mo b">demo-models</code>的文件夹，我们将在其中存放一个模型，并在前端和后端使用它。</p><p id="c8e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，文件夹<code class="fe ml mm mn mo b">demo-server</code>中的一个简单的Express应用程序。</p><p id="54d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在文件夹的根目录(<code class="fe ml mm mn mo b">demo-app</code>)，让我们创建一个<code class="fe ml mm mn mo b">package.json</code>并添加工作区配置。</p><pre class="kj kk kl km gt nf mo ng nh aw ni bi"><span id="57d4" class="nj kv in mo b gy nk nl l nm nn">{<br/>   "name":"app",<br/>   "version":"1.0.0",<br/>   "workspaces":[<br/>      "demo-models",<br/>      "demo-frontend",<br/>      "demo-server"<br/>   ],<br/>   "author":"Devayan",<br/>   "license":"ISC"<br/>}</span></pre><p id="6826" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ml mm mn mo b">workspaces</code>参数将一个项目中的三个子模块相加。现在子模块可以找到彼此，并添加其他模块作为依赖项。</p><p id="4834" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们添加一些代码。</p><p id="d084" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在演示模型中，创建如下所示的结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/801ed7135313e7fd59d1e69c7f429497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*pP3S9WGsQoNamKAqOEbdMA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">demo-models housing simple models that can be reused in server and frontend</figcaption></figure><p id="3ae9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并添加一个这样的接口:</p><pre class="kj kk kl km gt nf mo ng nh aw ni bi"><span id="5c67" class="nj kv in mo b gy nk nl l nm nn">export interface SignupUserRequest {</span><span id="8a8b" class="nj kv in mo b gy np nl l nm nn">   firstName: string;<br/>   lastName: string;<br/>   email: string;</span><span id="eccf" class="nj kv in mo b gy np nl l nm nn">}</span></pre><p id="1d0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ml mm mn mo b">demo-server</code>中，添加Express app所需的依赖项，并添加<code class="fe ml mm mn mo b">demo-models</code>作为path的依赖项。</p><pre class="kj kk kl km gt nf mo ng nh aw ni bi"><span id="bd37" class="nj kv in mo b gy nk nl l nm nn">{<br/>   "name":"demo-server",<br/>   "version":"1.0.0",<br/>   "description":"Server app",<br/>   "main":"src/app.ts",<br/>   "scripts":{<br/>      "start":"tsc src/app.ts --esModuleInterop &amp;&amp; node src/app.js"<br/>   },<br/>   "author":"Devayan Sarkar",<br/>   "license":"ISC",<br/>   "devDependencies":{<br/>      "<a class="ae nq" href="http://twitter.com/types/express" rel="noopener ugc nofollow" target="_blank">@types/express</a>":"^4.17.13",<br/>      "<a class="ae nq" href="http://twitter.com/types/node" rel="noopener ugc nofollow" target="_blank">@types/node</a>":"^17.0.8",<br/>      "ts-node":"^10.4.0",<br/>      "typescript":"^4.5.4"<br/>   },<br/>   "dependencies":{<br/>      "express":"^4.17.2",<br/>      "demo-models":"../demo-models"<br/>   }<br/>}</span></pre><p id="3526" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ml mm mn mo b">app.ts</code>中，添加代码来运行一个简单的hello-world Express应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/736b7b2f1e051a33f11d1c816b82791f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0q4HBEOVoFXgppdPMxNFg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">importing SignupUserRequest from ‘demo-models’</figcaption></figure><p id="e446" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有一个来自<code class="fe ml mm mn mo b">demo-models</code>的导入来使用<code class="fe ml mm mn mo b">SignupUserRequest</code>。</p><p id="d0c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，在React app的package.json中，添加对<code class="fe ml mm mn mo b">demo-models</code>的依赖，导入包来使用<code class="fe ml mm mn mo b">SignupUserRequest</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/c73981f09ac3c71209fdb16c61fe10e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbyHYnhEGF3hU7YPrNrSNA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">importing SignupUserRequest in App.ts file of the react app</figcaption></figure><p id="898e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在前端和服务器上都使用相同的模型。这确保我们在两个地方使用相同的模型和结构，并且我们遵循DRY原则，不复制代码块。</p><p id="13ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似地，实用程序类、函数和复杂模型类可以很容易地在前端和服务器之间共享。</p><p id="b0e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">任何突破性的变化都可以很容易地在前面识别出来。</p><p id="98e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们假设在<code class="fe ml mm mn mo b">SignupUserRequest</code>中增加了一个额外的参数:</p><pre class="kj kk kl km gt nf mo ng nh aw ni bi"><span id="44a6" class="nj kv in mo b gy nk nl l nm nn">export interface SignupUserRequest {<br/>    firstName: string;<br/>    lastName: string;<br/>    email: string;<br/>    phone: number;</span><span id="7b21" class="nj kv in mo b gy np nl l nm nn">}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/0694915375f8ac4d95d192a799ccfa21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5r4PE99Dg48PrYuxb2AMA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">phone number is required and shows an error in the App.ts file</figcaption></figure><p id="f029" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根节点<code class="fe ml mm mn mo b">package-lock.json</code>拥有应用程序中所有子模块的依赖信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/122399fe8496e00265a8e9cd158a0984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUXmIVdDVFs-2SG_naDSfw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">package-lock.json</figcaption></figure><p id="2efd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在每个子模块都有自己的<code class="fe ml mm mn mo b">node_modules</code>，但是根应用也有一个<code class="fe ml mm mn mo b">node_module</code>，它包含了到实际文件夹的链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/9b23f5ff8f99d5e945c4c00c8b01c4b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kGjWIHRL5JNGjngwomvOpA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">node_modules at the root of the app</figcaption></figure><blockquote class="my mz na"><p id="5acd" class="jk jl nb jm b jn jo jp jq jr js jt ju nc jw jx jy nd ka kb kc ne ke kf kg kh ig bi translated">弯曲的小箭头表示这些是到实际文件夹的链接。</p></blockquote><p id="3dda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">设置这些子模块可以确保代码被分组到逻辑文件夹中。这种划分还确保了当您构建服务器或前端时，只构建那个模块，这样会更快。</p><p id="8dd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样。</p><p id="c33b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您可以添加更多的接口、函数或实用程序类，并在前端和服务器上使用它们。</p><p id="fb3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nb">更多内容请看</em><a class="ae nq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="nb">plain English . io</em></strong></a><em class="nb">。报名参加我们的</em> <a class="ae nq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="nb">免费周报</em> </strong> </a> <em class="nb">。在我们的</em> <a class="ae nq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="nb">社区</em> </strong> </a> <em class="nb">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>