# 为什么优秀的程序员不愿意在代码中使用“如果”

> 原文：<https://javascript.plainenglish.io/why-do-good-programmers-hesitate-to-put-if-in-their-code-a5ffcf2156d?source=collection_archive---------0----------------------->

## 并不是说消灭了 ***如果*** s 就神奇的解决了所有问题。

![](img/2911319dbd279f49f215ee8500d11fa8.png)

Photo by [Jason Strull](https://unsplash.com/@jasonstrull?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

有一个运动叫无 if 编程，试图说服程序员尽量少用 if。

这与面向对象编程有着某种交织的重要性。尽管如此，我相信这是资历最低的开发人员在修改、更好地重构现有代码以及面对复杂的嵌套 if 模式时的共同经历。

通常，特别是如果原始软件是旧的，或者可能在充满全局变量的非面向对象语言中。但是让我们按顺序来。

总的来说，有些代码很好，但是在某些时候，一些涉众(在 Scrum 术语中)要求改变，这并不罕见。

产品负责人把这个请求带到一个会议上，通常 scrum 经理会笑着，但是讨厌这个主题，因为这个主题会从技术上讨论这个请求。

通常，这个请求被插入到软件需要的改进、变更和缺陷修复的连续流程中。

也许团队已经改变了，最初的开发人员，他们知道代码的细节，已经不在了，因为他们被安排去做其他的事情，或者不再是公司的员工。

当然，文档是存在的，但是它并不是完全一致的(修改文档比一般的修改花费更多)，所以 scrum master 决定委托修改的那个可怜的家伙有着不同的软件能力，从在黑暗中摸索到在黑暗中钓鱼几个月后的特定知识。

此外，改变必须是紧急的(几乎总是非常紧急，因为营销必须去一个交易会或一个重要的客户被抛弃，等等)。)，然后这个可怜的家伙就想办法快点。

他没有详细说明为了实现这种修改，应该修改哪些类，他也不能这么容易地做到，因为 UML 图，如果有的话，是旧的，没有更新。

通常是完全错误的，经常决定改变一个类名，甚至一个名称空间，但是没有更新它们，或者更糟的是，部分更新了它们。

从 IDE 开始，并开始考虑从哪里开始编辑:

他经常摸索部分更改并用调试器测试它们，以了解它们如何影响新的场景。

他认为这没那么戏剧化，但是他没有说:停，现在我正在和我的老板谈话并建立一个有效的重构，而是做了部分的改变。

他调试并运行它，而不引入方法、子类和接口。它放置 if:当与修改相对应的情况被识别时，在有必要区分标准情况和这个新情况的地方放置一个很好的 if，可能是级联的，因为代码最初已经经历了类似的修改。

推码。持续集成使新版本具有新功能。也许他是幸运的，单元测试通过了，集成测试几乎肯定有效，因为该功能最初不存在，因此没有被验证。

程序员关闭标签，并将更改放入测试中。测试人员甚至不知道该做什么。他们玩了一会儿，写得还行。门票关闭。

在现场，事实证明这种改变非常好，但是在软件生成的几十个打印输出中选择一个是有问题的。在其中一张照片中，更改没有达到预期效果。

## **车票**

scrum 大师对最初的修改者很生气。可能他不喜欢，把球传给了另一个开发者。这可能是在与同事交谈，可能他只是看到了提交的更改并修改了打印内容。其他 if 的插入就像下雨一样，因为这种变化可能会放大印刷，通常进入页面的内容不再出现。

然后新来的开发人员，比同事少，开始思考如何处理问题。前面的代码没有预料到能够生成两个打印页面，所以他添加了一点 if 并添加了一个打印菜单，当他认识到新的情况时，首先打印第一页，然后打印第二页。

发明了一个挂钩，也许是通过放置一个从印刷开始的偏移，并且没有必要添加多重印刷的管理。

## **其他如果**

这次推送代码集成测试没有通过，因为菜单已经改变了，所以这个可怜的家伙添加测试来修改预先存在的(其他 if)，最后，可能在星期五晚上，推送他的修改。

他更有经验或者资历，于是他想了想，又做了一个原来的变更需要的，最初的程序员已经忘记的变更。

## **其他 if**

几个月过去了，功能增加了，变化了，新版本的编译器和 IDE 安装了，各种东西也更新了，因为新版本很酷，但是迁移到新版本并不是立竿见影的。

一年后，事实证明，在一个特定的配置中，没有人真正分析过，或者第二个程序员考虑过，但决定保持沉默，因为这是一个稀缺的条件，它使应用程序崩溃。

幸运的是，scrum master 记得(通过查看 backlog 或者询问吉拉)是谁做了植入的修改。而之前提到的程序员又拿到了烫手山芋。

他有一千件事情要做(新的编译器有一些问题是供应商告诉他的，所以他做了一些重构，这也涉及到他上次添加的 if)，几个月后，他必须明白为什么会出现这个错误。

首先他要复制，一点都不容易，但是后来他成功了。有了调试器，它就能找出崩溃的原因，因为它取消了对空指针的引用，理解了为什么会发生这种情况，并设置了各种其他 if 来识别情况并更改执行流程以避免空指针。

这种情况持续了几年。

## 我们来分析一下结果。

一个原本只有 30 行的方法，在高速进行了各种修改而没有修改类的逻辑结构和它们之间的交互之后，变成了 150 行，其中大部分都是嵌套的，如果它们报告了所请求的修改所需的所有特定情况乘以原始结构所需的一系列子条件。

混乱比意大利面条式代码更糟糕，通常进一步的修改需要在方法的不同部分修改各种缩进和重复的 if。

为了指定特定的情况，也许，一个布尔参数被添加到方法中，所以在调用该方法的十个点中，该参数(其他 if)的值必须被确定，以便调用该方法。

## 应该做些什么？

需要的新功能必须详细分析它对细分成类的干扰，也许一切都可以通过在被删减的类中引入一个子类来解决。

子类将会简化所有的事情，而不是增加 ifs，在特定情况下智能地创建一个子类而不是原始类就足够了。

如果代码支持依赖倒置，可能会更容易，因为您甚至不需要重新编译所有代码:只需为所需的接口创建一个新方法，并将该新方法添加到现有的可能会抛出未实现的异常的类中(非常有用，反正它们不应该被调用),并编写一个实现新功能的新类。

对现有代码的改动最小，乱搞的机会最小。也许只需重新编译组成应用程序的众多库中的一个库就足够了。

我已经对软件开发团队中通常发生的事情做了一个很长很有趣的回顾。有些人在评论中分析荒谬的代码味道，也许他们是第一个放置 if 数组的人，而只有用多态(我的意思是通过添加多态方法)才能出色地解决所有问题。

## **让我们明确一下**

这并不是说消除“如果”就能神奇地解决所有问题。将它们限制在最少的必要范围内，编写包含这些 if 的方法，而不是将相同的条件显式化(复制和粘贴)几十次，考虑类的结构并记录它们，也许你可以避免几十个无用和不清楚的 if，但你可以编写更敏捷、更易于维护的代码。

如果减少编程是可以使你的代码更易维护的事情之一。如果我想了很多。也许我对一个案例做了同样的事情，或者也许我做了一个字典(map ),它将一系列方法与一个键相关联，这些方法接收的不是对象而是一个接口:因此，我没有淡化代码中的终端逻辑，而是为那个特定的案例创建了各种方法，也许所有的方法都是公开基本函数的类的子类。

经过多年的编程，我的假设总是经过深思熟虑的。

*更多内容请看*[***plain English . io***](https://plainenglish.io/)*。报名参加我们的**[***免费周报***](http://newsletter.plainenglish.io/) *。关注我们关于*[***Twitter***](https://twitter.com/inPlainEngHQ)*和*[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*。查看我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *加入我们的* [***人才集体***](https://inplainenglish.pallet.com/talent/welcome) *。**