<html>
<head>
<title>Server-Side Rendering with Web Components and Puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web组件和木偶师进行服务器端渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/server-side-rendering-with-web-components-and-puppeteer-d55b0fe00b68?source=collection_archive---------2-----------------------#2022-08-31">https://javascript.plainenglish.io/server-side-rendering-with-web-components-and-puppeteer-d55b0fe00b68?source=collection_archive---------2-----------------------#2022-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="93a5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">声明式Shadow DOM使我们能够使用Puppeteer在服务器端呈现Web组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5b79f75f4b9ef6d765ba28572ef6b257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qkIA1t35P9fwrhBf"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SpaceX</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="adc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<strong class="ky ir"> SSR </strong>与Web组件结合使用实际上很难<strong class="ky ir">。</strong> Web组件依赖于服务器上不可用的特定于浏览器的DOM APIs，许多人甚至说这是不可能的。因此许多开发者把缺乏SSR作为完全避免Web组件的理由。</p><p id="5abd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，通过在服务器上预先呈现您的web组件并使用声明性Shadow DOM，有可能实现SSR。在本文中，我们将创建一个简单的<strong class="ky ir"> Web组件</strong>，并使用<strong class="ky ir"> Express.js </strong>在服务器端呈现我们的组件。</p><div class="ls lt gp gr lu lv"><a href="http://web-highlights.com/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Web亮点— PDF和Web荧光笔</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Web Highlights是一个在Web上突出显示文本的工具，可以更有效地组织您的研究。提升你的…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">web-highlights.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="f09c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">什么是Web组件？</h1><p id="d29c" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Web组件是基于官方web标准的可重用客户端组件，受所有主流浏览器支持。它们是将<strong class="ky ir">功能</strong>与我们代码的其余部分<strong class="ky ir"> </strong>封装在一起的极好方式。不仅如此，你还可以在每个网络应用程序和网页中重用它们。</p><p id="b6a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们的目的是编写在任何地方都可以使用的封装强大的定制元素。Web组件使我们能够完全独立于前端框架进行开发。</p><blockquote class="no np nq"><p id="f689" class="kw kx nr ky b kz la jr lb lc ld ju le ns lg lh li nt lk ll lm nu lo lp lq lr ij bi translated">Web组件的主要好处是我们可以在任何地方使用它们。有任何框架，甚至没有框架。—<a class="ae kv" href="https://v3.vuejs.org/guide/web-components.html" rel="noopener ugc nofollow" target="_blank">vuejs.org</a></p></blockquote><p id="4bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="nr">它们是如何工作的？</em> </strong></p><p id="4d60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个如何定义<strong class="ky ir">自治web组件</strong>的例子:</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="af3f" class="oa ms iq nw b gy ob oc l od oe">class MyWebComponent extends HTMLElement {...}</span><span id="e9dd" class="oa ms iq nw b gy of oc l od oe">window.customElements.define('my-web-component', MyWebComponent);</span></pre><p id="1bcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将元素传递给任何HTML页面，如下所示:</p><p id="969c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe og oh oi nw b">&lt;my-web-component value="something"&gt;&lt;/my-web-component&gt;</code></p><p id="72a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关web组件的更多详细信息，请查看我的其他文章:</p><ul class=""><li id="a65d" class="oj ok iq ky b kz la lc ld lf ol lj om ln on lr oo op oq or bi translated"><a class="ae kv" href="https://medium.com/@mariusbongarts/will-web-components-replace-frontend-frameworks-535891d779ba" rel="noopener"><strong class="ky ir">Web组件会取代前端框架吗？</strong> </a></li><li id="91cc" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated"><a class="ae kv" href="https://levelup.gitconnected.com/are-web-components-dead-12e404e0f4b0" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Web组件死了吗？</strong> </a></li><li id="9ba2" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated"><a class="ae kv" href="https://medium.com/@mariusbongarts/the-complete-web-component-guide-part-1-custom-elements-a627af805df8" rel="noopener"> <strong class="ky ir">完整的Web组件指南</strong> </a></li><li id="ec34" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated"><a class="ae kv" href="https://medium.com/@mariusbongarts/showcase-your-medium-articles-with-web-components-part-1-basics-d2c6618e9482" rel="noopener"> <strong class="ky ir">用Web组件构建自己的博客组合:基础知识</strong> </a></li></ul><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/web-components-at-big-tech-companies-salesforce-89a8a4c97d04"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">大型科技公司的Web组件:Salesforce</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">如果企业可以部署web组件，那么您也可以！</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="me l"><div class="ox l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6455" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">什么是服务器端渲染？</h1><p id="2e7f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">服务器端渲染(SSR)是一种允许我们在服务器上而不是在客户端浏览器中生成HTML和CSS的技术。这样做的结果是，您的web应用程序将加载得更快，因为它不必在呈现页面之前等待JS / CSS文件下载。</p><p id="47e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多现代框架提供了一种在服务器端呈现组件的方式。比如Angular提供<strong class="ky ir">角度通用</strong>，React a <strong class="ky ir"> ReactDOMServer </strong>，Vue.js提供<code class="fe og oh oi nw b">renderToString</code>功能。</p><p id="fd98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Web组件来说，实现SSR非常困难，但是即使是像<strong class="ky ir"> Lit </strong>或<strong class="ky ir"> Stencil </strong>这样的库也为我们提供了支持Web组件SSR的特性。Stencil已经提供了他们的<a class="ae kv" href="https://stenciljs.com/docs/hydrate-app" rel="noopener ugc nofollow" target="_blank"> Hydrate App-Bundle </a>来完成SSR，并且<a class="ae kv" href="https://medium.com/@mariusbongarts/build-your-own-blog-portfolio-with-web-components-lit-library-2701dffc735f" rel="noopener"> Lit </a>也正在为服务器端渲染开发一个<code class="fe og oh oi nw b">@lit-lab/ssr</code>包。</p><p id="fe59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将不使用任何前端库，并将尝试使用普通的JavaScript自定义元素来实现SSR。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="54a4" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">创建Web组件</h1><p id="c641" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">对于我们的例子，我们将创建一个非常简单的<a class="ae kv" href="https://medium.com/@mariusbongarts/the-complete-web-component-guide-shadow-dom-2e40921eb77" rel="noopener">定制元素</a>，它附加了一个<a class="ae kv" href="https://medium.com/@mariusbongarts/the-complete-web-component-guide-shadow-dom-2e40921eb77" rel="noopener">阴影DOM </a>并包含一些样式。</p><p id="9b83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@mariusbongarts/the-complete-web-component-guide-shadow-dom-2e40921eb77" rel="noopener"> <strong class="ky ir"> Shadow DOM API </strong> </a>是使Web组件的封装易于实现的关键部分。影子树(影子DOM中的DOM树)使我们能够将组件的标记和样式与页面上的其他代码分开，以防止混淆网站不同部分的样式。</p><p id="7437" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是影子DOM经常会导致关于Web组件的SSR的问题。让我们看看我们是否能让它工作。</p><p id="ad4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们的自定义元素的代码，它将呈现一个漂亮的标题，看起来像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="707e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们通过调用<code class="fe og oh oi nw b">this.attachShadow({ mode: "open" });</code>给自定义元素附加一个开放阴影DOM。之后，我们向我们的<code class="fe og oh oi nw b">template</code>元素添加一些HTML，包含一些封装的样式。HTML中还包含一个<code class="fe og oh oi nw b">h1</code>标签和一个<code class="fe og oh oi nw b">slot</code>标签。</p><p id="bd7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="nr"> Slots </em> </strong> <em class="nr">是在每个元素中显示不同文本或标记的极好的声明性方式。</em></p><p id="3b3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们克隆我们的<code class="fe og oh oi nw b">template</code>的内容，并将其附加到元素的附属<code class="fe og oh oi nw b">shadowRoot</code>中。将上面的代码加载到我们的HTML中，我们可以像这样使用我们的<code class="fe og oh oi nw b">fancy-headline</code>自定义元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="531f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将呈现以下标题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/76154d82fca6d812f103c7fae054ec1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nI31n-5B9p129iw-dxJuNQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Fancy Headline</figcaption></figure><p id="3e4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个<a class="ae kv" href="https://codepen.io/marius2502/pen/XWELKoV" rel="noopener ugc nofollow" target="_blank">代码笔</a>上面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb oz l"/></div></figure><p id="bfaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在设置已经完成，我们可以投身于激动人心的事情。让我们尝试在服务器端用一个小的Express.js应用程序来呈现创建的Web组件。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="a727" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><strong class="ak">创建Express.js服务器</strong></h1><p id="cbf1" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们将使用一个简单的Express.js应用程序来保持简单，该应用程序将从上面返回我们的HTML。我将指导您一步一步地创建应用程序。这里是<a class="ae kv" href="https://github.com/MariusBongarts/medium-webcomponents-ssr" rel="noopener ugc nofollow" target="_blank"> Github库</a>，以防你直接想要检查代码。</p><p id="79c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是让您开始的步骤:</p><p id="0524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。创建一个新目录:</strong></p><p id="90ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe og oh oi nw b">mkdir medium-webcomponents-ssr</code></p><p id="1cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。创建一个package.json </strong></p><p id="8249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe og oh oi nw b">npm init --yes</code></p><p id="5c3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。安装快捷</strong></p><p id="7f48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe og oh oi nw b">npm install express --save</code></p><p id="9e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。在</strong>项目的根目录下创建 <code class="fe og oh oi nw b"><strong class="ky ir">app.js</strong></code> <strong class="ky ir">条目文件</strong></p><p id="3fab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe og oh oi nw b">touch app.js</code></p><p id="7e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 6。在</strong> <code class="fe og oh oi nw b"><strong class="ky ir">app.js</strong></code> <strong class="ky ir">文件中配置Express.js来服务我们的HTML </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">app.js</figcaption></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="28a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我们完成了。剩下唯一要做的事情就是通过运行<code class="fe og oh oi nw b">node app</code>来启动我们的服务器，并访问<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>上的应用程序。</p><p id="f9d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们包括了我们在<a class="ae kv" href="https://codepen.io/marius2502/pen/XWELKoV" rel="noopener ugc nofollow" target="_blank"> CodePen </a>示例中提供的所有代码。让我们加载页面并<strong class="ky ir">在浏览器中禁用Javascript </strong>(查看<a class="ae kv" href="https://developer.chrome.com/docs/devtools/javascript/disable/" rel="noopener ugc nofollow" target="_blank"> Chrome开发者文档</a>了解如何禁用Javascript)。</p><p id="e803" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们的<strong class="ky ir"> <em class="nr">不那么花哨的标题</em> </strong>在客户端禁用JavaScript时在服务器上呈现的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/dd2f6c38a6413163b46ca878022f0a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJEAs1R8pwzHiw_ZUO8FOA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screenshot of localhost:3000</figcaption></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="21d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">发生了什么？</strong></p><p id="5c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当查看源代码时，我们可以看到我们的文本被呈现在<code class="fe og oh oi nw b">&lt;fancy-headline&gt;</code>标签中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/33a62169a957c2828570fbdc69dbd71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ah12NmBqsEN7v8aLWJ642Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">HTML Source Code</figcaption></figure><p id="b5f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，我们可以看到没有影子DOM附加到元素上。它通常应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/769e47261b85e67e37d981c6d6f78190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*Xn60N4TjhC7WO2AC0Ylt_g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">HTML Source Code</figcaption></figure><p id="bffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看不到应用于元素的任何样式的原因是，从服务器端提供的Javascript从未被执行过。</p><p id="58e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但SSR就是这么回事。我们希望返回预先呈现的HTML字符串，这样客户端就不需要用JavaScript来呈现它。这可以提高你的性能，也优化搜索引擎优化。</p><p id="a0d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要以某种方式让JavaScript预先在服务器上执行。幸运的是，有两个解决方案可以帮助我们从服务器获取定制元素:</p><ol class=""><li id="1073" class="oj ok iq ky b kz la lc ld lf ol lj om ln on lr pf op oq or bi translated"><strong class="ky ir">声明性阴影DOMs </strong></li><li id="ede1" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr pf op oq or bi translated"><strong class="ky ir">木偶师</strong></li></ol></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h2 id="5e68" class="oa ms iq bd mt pg ph dn mx pi pj dp nb lf pk pl nd lj pm pn nf ln po pp nh pq bi translated">1.声明性阴影DOMs</h2><p id="db89" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">声明性影子DOM (DSD)是一个新的web平台API，它使我们能够在不使用JavaScript的情况下声明一个影子根。</p><p id="abe0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直到最近，使用影子DOM的唯一方法是使用JavaScript调用<code class="fe og oh oi nw b">Element.attachShadow(...)</code>。我们在自定义元素中做到了这一点，只要客户端启用了JavaScript，它就能工作。</p><p id="2122" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种限制使得过去无法从服务器发送带有阴影DOM的预渲染定制元素。</p><p id="6015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<strong class="ky ir">声明性的影子根</strong>现在使这成为可能。需要注意的是，这个浏览器API仍然非常新，并且只在新的浏览器中受支持。</p><blockquote class="no np nq"><p id="c61e" class="kw kx nr ky b kz la jr lb lc ld ju le ns lg lh li nt lk ll lm nu lo lp lq lr ij bi translated">声明式阴影DOM在Chrome 90和Edge 91中可用。它也可以使用Chrome 85中的<strong class="ky ir">实验网络平台特性</strong>标志来启用。导航到<code class="fe og oh oi nw b">about://flags/#enable-experimental-web-platform-features</code>找到该设置。——<a class="ae kv" href="https://web.dev/declarative-shadow-dom/" rel="noopener ugc nofollow" target="_blank">web.dev/declarative-shadow-dom</a></p></blockquote><p id="f84f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义DSD可以通过使用带有<code class="fe og oh oi nw b">shadowroot</code>属性的<code class="fe og oh oi nw b">&lt;template&gt;</code>元素来实现。该属性将被HTML解析器检测到，并被转换成其父元素的影子根。</p><p id="1283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，以下标记:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="f61a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将产生这个DOM树:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><blockquote class="no np nq"><p id="2013" class="kw kx nr ky b kz la jr lb lc ld ju le ns lg lh li nt lk ll lm nu lo lp lq lr ij bi translated">声明性影子DOM (DSD)消除了这个限制，<strong class="ky ir">将影子DOM带到了服务器</strong>。—<a class="ae kv" href="https://web.dev/declarative-shadow-dom/" rel="noopener ugc nofollow" target="_blank">web.dev/declarative-shadow-dom</a></p></blockquote><p id="2269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们继续使用DSD来转换我们的模板:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Template using DSD</figcaption></figure><p id="c36a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到我们移除了构造函数中最初的<code class="fe og oh oi nw b">this.attachShadow( {mode: "open" })</code>调用。相反，我们通过将<code class="fe og oh oi nw b">&lt;template&gt;</code>标签的<code class="fe og oh oi nw b">shadowroot</code>属性设置为<code class="fe og oh oi nw b">open</code>来使用声明性阴影DOM。</p><blockquote class="no np nq"><p id="08f3" class="kw kx nr ky b kz la jr lb lc ld ju le ns lg lh li nt lk ll lm nu lo lp lq lr ij bi translated"><code class="fe og oh oi nw b">open</code>简单地说就是可以使用JavaScript访问影子DOM。将它设置为<code class="fe og oh oi nw b">closed</code>意味着您不能从外部访问影子DOM。</p></blockquote><p id="a42a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到我们再次在模板中放了一个<code class="fe og oh oi nw b">&lt;slot&gt;</code>。值得注意的是，我们现在不再简单地将文本放在<code class="fe og oh oi nw b">&lt;fancy-headline&gt;</code>标签中，而是使用一个<code class="fe og oh oi nw b">text</code>属性将其放在元素中。</p><p id="0617" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="nr">重要提示</em> </strong> <em class="nr">:我必须说，我在这个问题上卡住了相当一段时间，但没有成功。这就是为什么我使用了</em> <code class="fe og oh oi nw b"><em class="nr">text</em></code> <em class="nr">属性而不是</em> <strong class="ky ir"> <em class="nr">槽</em> </strong> <em class="nr">来显示相应的标题文本。有人知道如何使用DSD和SSR来实现这一点吗？</em></p><p id="5eb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们成功地将我们的影子DOM转换成了声明性的。现在，剩下的唯一事情就是在服务器上预先呈现JavaScript。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h2 id="4763" class="oa ms iq bd mt pg ph dn mx pi pj dp nb lf pk pl nd lj pm pn nf ln po pp nh pq bi translated">2.操纵木偶的人</h2><p id="b261" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们已经看到，一旦我们在客户机上禁用了JavaScript，我们的定制元素就不能正确呈现了。因此，我们需要找到一种方法来预先呈现我们的JavaScript，并且只将HTML作为字符串发送给客户端。</p><p id="e889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将使用<strong class="ky ir">木偶师</strong>库在服务器上预渲染我们的自定义元素。为此，我们需要安装库:</p><p id="01f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe og oh oi nw b">npm install puppeteer --save</code></p><p id="c0e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们启动一个新的浏览器并创建一个新的木偶页面，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ebaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将页面的内容设置为我们的<code class="fe og oh oi nw b">html</code>模板，并等待<code class="fe og oh oi nw b">"domcontentloaded"</code>事件来确保页面被完全加载。</p><p id="7d0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们解析<code class="fe og oh oi nw b">fullHTML</code>字符串并将其发送回客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="b7f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再次<strong class="ky ir">禁用JavaScript </strong>并访问<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/76154d82fca6d812f103c7fae054ec1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nI31n-5B9p129iw-dxJuNQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Fancy Headline</figcaption></figure><p id="d4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们做到了！我们成功地在服务器端呈现了包含阴影DOM的自定义元素。我们可以通过查看从服务器返回的源代码来进行复查(<em class="nr">右键点击页面- &gt;查看页面源代码</em>):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/876bc10593244d7c7410961c1d501933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*SILko87oTHKXrMYf6SjuQg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Page Source</figcaption></figure><p id="817d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，服务器的预呈现字符串不仅包括简单的定制元素标记，还包括它的所有内容，包括声明性的Shadow DOM。</p><p id="9a96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在DOM中，我们可以看到HTML解析器成功地将DSD解析为一个开放的影子根，并将其附加到其父元素<code class="fe og oh oi nw b">fancy-headline</code>上:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/f429c24057dd0fccedd328f24188a1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*YQnI-XUPBpDeudoq-QBwyQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">DOM</figcaption></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h2 id="a1ae" class="oa ms iq bd mt pg ph dn mx pi pj dp nb lf pk pl nd lj pm pn nf ln po pp nh pq bi translated"><strong class="ak">浏览器支持</strong></h2><p id="9f68" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我已经提到声明式阴影DOM在Chrome 90和Edge 91上可用。许多浏览器还不支持它。我们可以通过从Firefox浏览器访问我们的应用程序来验证这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/3ae938871a797298fd422c45f16c3189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t62Qt2hUMylOM4fn5Fafrw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Firefox Browser</figcaption></figure><p id="2008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到我们返回了带有<code class="fe og oh oi nw b">shadowroot</code>属性的正确模板，但是Firefox的HTML解析器无法正确解释它。</p><p id="fe04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在caniuse.com，我们可以看到许多浏览器不支持DSD提案:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/c632b6c536a5525e51a8a683e7f9b1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nwQzH3Wznri7r06T9CvpAA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://caniuse.com/declarative-shadow-dom" rel="noopener ugc nofollow" target="_blank">https://caniuse.com/declarative-shadow-dom</a></figcaption></figure><p id="6995" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，根据caniuse.com的调查，这一比例仍达到71.72%(2022年8月30日)。我们可以预期，所有主流浏览器迟早都会适应这个新提议，因为它是SSR和Web组件的一个里程碑。此外，polyfills已经存在，可以支持较旧的浏览器。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="e3f0" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">最后的想法</h1><p id="906b" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Web组件和SSR多年来一直是一个非常矛盾的话题。许多人继续避免Web组件，因为它们似乎与SSR不兼容。在这篇文章中，我们看到这仍然不容易，但却是可能的。声明性阴影DOMs最终允许我们享受封装的阴影DOMs在服务器端呈现的好处。</p><p id="c5ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我总是乐于回答问题，并乐于接受批评。随时欢迎联系我！通过<strong class="ky ir"/><a class="ae kv" href="https://www.linkedin.com/in/marius-bongarts-6b3638171/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">LinkedIn</strong></a><strong class="ky ir">，</strong>关注我<strong class="ky ir"/><a class="ae kv" href="https://twitter.com/MariusBongarts" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Twitter</strong></a>或<a class="ae kv" href="https://medium.com/subscribe/@mariusbongarts" rel="noopener"> <strong class="ky ir">订阅</strong> </a>通过电子邮件获取我的故事。</p><p id="f2a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@mariusbongarts/membership" rel="noopener"> <strong class="ky ir">这里是无限制访问媒体上每一个内容的链接</strong> </a> <strong class="ky ir">。如果你使用这个链接注册，我会赚一小笔钱，不需要你额外付费。</strong></p><div class="ls lt gp gr lu lv"><a href="https://medium.com/@mariusbongarts/membership" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">通过我的推荐链接加入Medium-Marius bong arts</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">阅读马里乌斯·邦加茨(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="pv l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="edb0" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">关于作者</h1><p id="206e" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我是埃森哲软件工程分析师宋。最驱动我的是我想创造一些可能对他人有帮助并改变他人生活的东西的冲动。</p><p id="89ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如你是否厌倦了浏览自己的历史来寻找前几天看到的信息？我的<a class="ae kv" href="https://chrome.google.com/webstore/detail/web-highlights-%20-bookmark/hldjnlbobkdkghfidgoecgmklcemanhm" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">网站重点介绍Chrome扩展</strong> </a>覆盖了你，并将通过以结构化和高效的方式组织你的研究来提高你的生产力。就像你在书和文章上做的那样，突出显示任何网页或PDF上的文本。你的精彩片段会直接同步到web-highlights.com的网络应用上，你可以在任何地方找到它们。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9844" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">进一步阅读</h1><div class="ls lt gp gr lu lv"><a href="https://medium.com/@mariusbongarts/will-web-components-replace-frontend-frameworks-535891d779ba" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Web组件会取代前端框架吗？</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">它们是为解决不同的问题而构建的。</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="pw l mg mh mi me mj kp lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://levelup.gitconnected.com/are-web-components-dead-12e404e0f4b0" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Web组件死了吗？</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">最近，我发表了一篇关于类似主题的不同问题的文章:Web组件会取代前端吗…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="me l"><div class="px l mg mh mi me mj kp lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/@mariusbongarts/the-complete-web-component-guide-part-1-custom-elements-a627af805df8" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">完整的Web组件指南:自定义元素</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">成为Web开发未来的专家(第1部分)</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="py l mg mh mi me mj kp lv"/></div></div></a></div><p id="324a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nr">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nr">plain English . io</em></strong></a><em class="nr">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nr">免费周报</em> </strong> </a> <em class="nr">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nr">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nr">LinkedIn</em></strong></a><em class="nr"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nr">YouTube</em></strong></a><em class="nr"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nr">不和</em> </strong> </a> <em class="nr">。</em></p></div></div>    
</body>
</html>