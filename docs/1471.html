<html>
<head>
<title>Understand Type Declarations and Type Assertions in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解TypeScript中的类型声明和类型断言</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-type-declarations-and-type-assertions-in-typescript-39bee93c889c?source=collection_archive---------4-----------------------#2022-03-26">https://javascript.plainenglish.io/understanding-type-declarations-and-type-assertions-in-typescript-39bee93c889c?source=collection_archive---------4-----------------------#2022-03-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/865e760b4c728106a0801fd155dad85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHM9APqxW3wIIl9CXVcu4Q.png"/></div></div></figure><p id="e23d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们定义类型声明和类型断言。</p><p id="9d28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">类型声明</strong>:类型声明验证(并确保)值符合所选接口/类型。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/890a96f592c45db85983ef785c3958b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVxrD3KdVM9Ur2nRQEokkg.png"/></div></div></figure><p id="375b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Type Assertion </strong>:告诉TypeScript，不管它推断的是什么类型，您都更了解，并且希望该类型是所选的接口/类型。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/2846794ac14d0fa6d72a4d2fbe119f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-R5Z7u-rxxk8Pww8I74XQ.png"/></div></div></figure><p id="cf8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，我们可以用两种方式键入变量</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/011e65d9a7af513a68799c9a6ebf6344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZXx45Pgfm8cK51KEWKM3g.png"/></div></div></figure><p id="c4f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在最后一个示例中，我们正在创建一个满足接口的对象。在中，我们尝试创建另一个，但缺少必需的属性，对于类型声明，我们将看到一个众所周知的错误</p><p id="0ade" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="la">“Property”name在类型“{ 0 }”中缺失，但在类型“Person”中是必需的。ts”</em></p><p id="e12e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但有了类型断言，就没有问题了。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lb"><img src="../Images/e04a40b277226de8c92509f02af4a886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9spmk4y_qDujDAmekHiqA.png"/></div></div></figure><p id="b3b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们试图定义一个具有比已定义更多属性的变量，也会发生同样的情况。通过类型声明，我们将得到:</p><p id="dc76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">”<em class="la">类型“{名称:字符串；年龄:数字；其他:字符串；“}”不能分配给类型“Person”。对象文字只能指定已知属性，而“Person”类型中不存在“other”。ts </em></p><p id="b378" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但对于类型断言，没有错误。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lc"><img src="../Images/0d65db086e375365e6854dea12e9af1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ck7xWL50YBGzPxsGf8n_sw.png"/></div></div></figure><p id="addf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们看看从字符串(名称)数组创建Person列表的不同方法。</p><p id="d99e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可能认为这种做法会奏效</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ld"><img src="../Images/f546bc2995d4810983772de537eb9137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jW2QBm8qUqHT5gq1tVRXg.png"/></div></div></figure><p id="c714" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但相反，我们将得到一种类型的“<em class="la">string[</em>”。</p><p id="6282" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用类型断言来“强制”类型化(不管它是否满足)</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/ec4043aaf718aa3a125816c7c27e14de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17mYCPjE1vOxENUAMrbgCQ.png"/></div></div></figure><p id="ff6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">两者都生成类型“<em class="la"> Person[] </em>”。</p><p id="760d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要生成正确的人员列表，更好的选择是。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi le"><img src="../Images/3e4f3312c84490aa4cc16288f41fb264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0JNQxx41aO3KH3XQJ3dwQ.png"/></div></div></figure><p id="a04a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过查看前面的这些示例，我们可以一致认为，在大多数情况下最好使用类型声明，并让Typescript在它比我们更了解时帮助我们。</p><p id="d464" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看什么时候使用类型断言可能是更好的选择。选择类型断言的一个很好的例子可能是来自API的响应，其中Typescript不知道响应类型</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/525bca1b78e0590ec94ffe4bd7792a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MTPrF1hXHSuTotSmf-DFA.png"/></div></div></figure></div><div class="ab cl lg lh hr li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ig ih ii ij ik"><p id="ea3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且，什么时候类型断言不起作用呢？当我们试图分配一个类型的变量并试图断言另一个类型时，我们将得到错误</p><p id="8c9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">”<em class="la">转换类型“{大小:数字；地址:字符串；“}”来键入“Person”可能是个错误，因为两个类型都没有与另一个类型充分重叠。如果这是有意的，请先将表达式转换为“unknown”。类型“{ size:number }”中缺少属性“name”；地址:字符串；“}”但在“Person”类型中是必需的。</em>”</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi le"><img src="../Images/72a14ac98bb35b70612546a77879488e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3R6rAqxYvZjbf4VqX5Mbag.png"/></div></div></figure></div><div class="ab cl lg lh hr li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ig ih ii ij ik"><p id="2cc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这些示例能帮助您理解类型声明和类型断言之间的区别，以及何时使用它们。</p><p id="0a2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读。</p><p id="aa7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="la">更多内容请看</em><a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="la">plain English . io</em></strong></a><em class="la">。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="la">免费周报</em> </strong> </a> <em class="la">。关注我们关于</em><a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="la">Twitter</em></strong></a><em class="la">和</em><a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="la">LinkedIn</em></strong></a><em class="la">。加入我们的</em> <a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="la">社区不和谐</em> </strong> </a> <em class="la">。</em></p></div></div>    
</body>
</html>