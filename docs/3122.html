<html>
<head>
<title>Understand React Design Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解React设计原则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-react-design-principles-af0051e272c3?source=collection_archive---------8-----------------------#2022-08-02">https://javascript.plainenglish.io/understand-react-design-principles-af0051e272c3?source=collection_archive---------8-----------------------#2022-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="95a5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React背后的主要原理是什么？了解他们如何在引擎盖下工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/055a98f4ec47ca910d3bb4eb7b871c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EyLmv2hsgYshsm6y"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="310b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于前端开发人员经常使用React前端框架，因此更好地理解其指导原则是有意义的。由于我使用React已经有一段时间了，所以我将在下面简要讨论我是如何解读它的指导原则的。首先，让我们谈谈VDOM，因为React和Vue都是基于它的前端框架。</p><h1 id="e78f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">虚拟DOM(VDOM)</h1><h1 id="cf37" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么VDOM应该是React和Vue的基础？</h1><p id="08c9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您无法直接操作真正的DOM。想想接下来的情况。呈现包括使用DOM API添加、删除和更改真实的DOM。我们必须遍历一个DOM的所有属性，如果它们已经被渲染和修改了，就要重新设置它们。这些属性包括id、类名、onClick和其他属性。</p><p id="4293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DOM的属性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/881f73c701c201fe245e4fb1d8e5b44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*RuMphWAAGdU544F15rSObQ.png"/></div></figure><p id="71ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多属性在更新时必须重置，即使它们根本不被使用。</p><h2 id="aa36" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated"><strong class="ak">我们能简单地比较对我们重要的属性吗？</strong></h2><p id="d724" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">将它们分离出来并表示为JS对象会更好。<strong class="ky ir"> VDOM正因为如此而拥有它的第一个优势。VDOM还消除了与DOM的紧密联系，允许你在其他平台上渲染，如native、Canvas等。</strong></p><p id="f1e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">VDOM的第二个优势是这个</strong>。我们知道VDOM是一个JS对象，它代表了渲染完成的DOM。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="e3b7" class="mq lt iq nd b gy nh ni l nj nk">{ <br/>  type: ‘div’, <br/>  props: { <br/>    id: ‘aaa’, <br/>    className: [‘bbb’, ‘ccc’], <br/>    onClick: function() {} <br/>  }, <br/>  children: [] <br/>}</span></pre><p id="37f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后用渲染器渲染。但是你希望开发者把VDOM写成那样吗？那不可能；这太麻烦了，而且我们熟悉HTML方法，所以我们需要引入一个编译工具。</p><h1 id="5fe9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">DSL(一种特定领域语言)的编译</h1><h2 id="ecc2" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">HTML，CSS，CSS都是web域DSL。</h2><p id="28b7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">直接写VDOM太麻烦了，所以前端框架会设计一套DSL，然后编译成渲染函数，执行后生成VDOM。Vue和React都是这样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/a5347bb3a8dda03f4f1e1f4a338da0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A88CTndZ8nijtea-6ac0pg.png"/></div></div></figure><h2 id="bece" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated"><strong class="ak">如何设计这套DSL？</strong></h2><p id="6e18" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">前端领域中描述DOM的常见方式是HTML，最好的方式就是这样设计。这就是为什么Vue的模板和React的JSX都是这样设计的。Vue的模板编译器是自己实现的，而React的JSX编译器是由babel实现的，这是两个团队合作的结果。</p><p id="0c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">渲染器如何渲染VDOM？</strong></p><h1 id="02e0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">渲染VDOM</h1><p id="1174" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">渲染VDOM意味着通过DOM API添加、删除和更改DOM。例如，对于一个div，您必须使用document.createElement创建一个元素，然后使用setAttribute、addEventListener并设置事件侦听器。如果是文本，那么我们需要一个document.createTextNode来创建它。所以，根据VDOM的不同类型，写一个if else，对它做不同的处理。是的，不管是Vue还是React，这个if else在渲染器中都是不可或缺的。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="d789" class="mq lt iq nd b gy nh ni l nj nk">switch (vdom.tag) { <br/>    case HostComponent: <br/>        // Create or update dom <br/>    case HostText:  <br/>        // create or update dom <br/>    case FunctionComponent: <br/>        // Create or update dom <br/>    case ClassComponent: <br/>        // Create or update dom <br/>}</span></pre><p id="143f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React中，VDOM类型是通过标签来区分的。例如，HostComponent是元素，HostText是文本，FunctionComponent和ClassComponent分别是函数组件和类组件。<strong class="ky ir">那么问题来了，如何渲染组件？</strong>这就引出了组件的原理。</p><h1 id="bf9c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">成分</h1><p id="c2a9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们的目标是通过VDOM描述接口，在React中，我们使用JSX。这种JSX有时基于状态动态生成。</p><p id="b389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">我们怎么能把国家和JSX联系起来呢？</strong> <br/>将它们包装成函数、类或选项对象。然后，您可以执行它们以在渲染时获得VDOM。这就是组件的实现方式。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="8fa2" class="mq lt iq nd b gy nh ni l nj nk">switch (vdom.tag) {<br/>  case FunctionComponent:<br/>    const childVdom = vdom.type(props);<br/>    render(childVdom);<br/>    //…<br/>  case ClassComponent:<br/>    const instance = new vdom.type(props);<br/>    const childVdom = instance.render();<br/>    render(childVdom);<br/>    //…<br/>}</span></pre><p id="69ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是函数组件，那么传入props执行它，得到VDOM，然后递归渲染。如果它是一个类组件，那么创建它的实例对象，调用render方法获得VDOM，并递归地渲染它。<strong class="ky ir">那么，你能猜出Vue的options对象的组件描述是如何渲染的吗？</strong></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="7239" class="mq lt iq nd b gy nh ni l nj nk">{<br/>  data: {},<br/>  props: {}<br/>  render(h) {<br/>    return h(‘div’, {}, ‘’);<br/>  }<br/>}</span></pre><p id="4faf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没错，执行render方法就行了。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="bdc7" class="mq lt iq nd b gy nh ni l nj nk">const childVdom = option.render();<br/>render(childVdom);</span></pre><p id="71e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能通常以SFC的形式编写单文件组件，它将有一个特殊的编译器，将模板编译成呈现函数，然后将其与options对象的呈现方法挂钩。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/a9a453f53bfe5e9dbd8ac666866501b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSZG1_0Qsyg-091nE-_rbQ.png"/></div></div></figure><p id="d7e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，该组件本质上只是生成VDOM的逻辑的包装，以函数、选项对象或类的形式存在。就像Vue3也有功能组件一样，组件的形式并不重要。基于VDOM的前端框架的呈现过程是相似的。Vue和React在很多方面是一样的。但是管理国家的方式是不同的。</p><p id="43c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Vue是responsive，React是setState API。</strong>真的，Vue和React最大的区别就是状态管理方式的不同，因为这种不同导致了架构演进的不同方向。</p><h1 id="3735" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">状态管理</h1><p id="9aee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir"> React通过setState API触发状态更新，更新后重新渲染整个VDOM。另一方面，Vue通过代理收集状态，然后在状态被修改时触发相应组件的呈现。</strong>有些同学可能会问，<strong class="ky ir">为什么react不直接渲染对应的组件？</strong>想象一下这个场景。父组件将其setState函数传递给子组件，子组件调用它。此时，更新是由子组件<strong class="ky ir">触发的，但是这是唯一要呈现的组件吗？</strong></p><p id="7712" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然不是，还有它的母成分。类似地，组件更新实际上可以触发任何位置的其他组件。所以整个VDOM必须被重新渲染。</p><p id="40b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">那为什么Vue可以准确的更新更改后的组件呢？</strong> <br/>因为有了响应式代理，无论是子组件、父组件，还是在另一个位置的组件，只要使用了对应的状态，就会被收集为依赖项，状态变化就可以触发它们的渲染，而不管组件在哪里。这就是为什么React需要重新渲染整个VDOM，而Vue不需要。这个问题也导致了后来两者逐渐的架构差异。</p><h1 id="296f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">React架构的发展</strong></h1><p id="7d4d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在React 15的时候，React和Vue的渲染过程仍然非常相似，都是递归地渲染VDOM，并添加、删除和更改DOM。但是国家管理上的差异逐渐导致了架构上的差异。React的setState渲染整个VDOM，一个应用的所有vdom可能都非常大，所以计算量可能非常大。浏览器中JS计算时间太多会阻塞渲染，占用动画的每一帧，重绘，重排时间，所以动画会滞后。</p><p id="bdfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为前端框架，动画口吃肯定不是选项。但由于setState方法只能渲染整个VDOM，所以计算量大是必然的。<strong class="ky ir">我们能否将计算拆分，计算每帧的一部分，以避免阻碍动画的渲染？</strong>按照这个思路，react被改造成了纤程架构。</p><h2 id="86a3" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">纤维建筑</h2><p id="323c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">优化的目标是中断计算并将其分成多个帧，但现在递归渲染不能被中断，原因有两个。</p><ul class=""><li id="97a5" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><strong class="ky ir">渲染中断时已经更新到dom的部分怎么办？</strong></li><li id="9c35" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">现在VDOM是直接渲染的，只有VDOM的孩子的信息，如果我们中断它，<strong class="ky ir">怎么才能找到它的父节点？</strong></li></ul><p id="a56d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个问题的解决方法很容易想到。渲染的时候，不要直接更新到DOM，只需要找到改变的部分，做一个添加、删除、创建DOM的标记，然后全部计算完立刻更新到DOM。</p><p id="66c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以React把渲染过程分为两部分:<strong class="ky ir">渲染和提交</strong>。渲染阶段找到VDOM被改变的部分，创建DOM，并用添加、删除和改变来标记它，这被称为<strong class="ky ir">协调</strong>。</p><p id="c6b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协调是可中断的，并且由调度来安排。所有计算完成后，它会立即更新到DOM，称为<strong class="ky ir">提交</strong>。通过这种方式，React将之前非常类似于Vue的递归渲染转化为render(reconcile+schedule)+commit两阶段渲染。从那以后，React和Vue的架构差异变大了。</p><p id="d86c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二个问题是，中断后如何找到父节点和其他兄弟节点。</strong>现有的VDOM不起作用；我们需要再次记录父节点和兄弟节点的信息。所以React创建了纤程的数据结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/e5beb674112f8f21bc9c3fd9c86e34f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJIbgDA39cPDDCcAR5c6OQ.png"/></div></div></figure><p id="98c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了子节点的信息，还有sibling和return，分别记录了兄弟节点和父节点的信息。这个数据结构也叫纤程(纤程既是数据结构，也是render + commit的渲染过程)。</p><p id="2ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React将首先将VDOM转换为纤程，然后进行协调，因此它是可中断的。<strong class="ky ir">为什么这是可中断的？因为它不再是递归的，所以它是一个循环:</strong></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="0393" class="mq lt iq nd b gy nh ni l nj nk">function workLoop() {<br/>  while (wip) {<br/>    performUnitOfWork();<br/>  }<br/>  if (!wip &amp;&amp; wipRoot) {<br/>    commitRoot();<br/>  }<br/>}</span></pre><p id="4f3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React中有一个workLoop循环，每个循环对纤程进行协调，当前处理的纤程放在workInProgress全局变量中。当循环结束时，即workInProgress为空时，将执行提交阶段，并将协调后的结果更新到Dom。根据类型的不同，对每个纤维的协调处理也不同。当前纤程节点完成后，workInProgress被指向兄弟节点，并返回以剪切到下一个纤程节点。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="8f22" class="mq lt iq nd b gy nh ni l nj nk">function performUnitOfWork() {<br/>  const { tag } = wip;<br/><br/>  switch (tag) {<br/>    case HostComponent:<br/>      updateHostComponent(wip);<br/>      break;<br/><br/>    case FunctionComponent:<br/>      updateFunctionComponent(wip);<br/>      break;<br/><br/>    case ClassComponent:<br/>      updateClassComponent(wip);<br/>      break;<br/>    case Fragment:<br/>      updateFragmentComponent(wip);<br/>      break;<br/>    case HostText:<br/>      updateHostTextComponent(wip);<br/>      break;<br/>    default:<br/>      break;<br/>  }<br/><br/>  if (wip.child) {<br/>    wip = wip.child;<br/>    return;<br/>  }<br/><br/>  let next = wip;<br/><br/>  while (next) {<br/>    if (next.sibling) {<br/>      wip = next.sibling;<br/>      return;<br/>    }<br/>    next = next.return;<br/>  }<br/><br/>  wip = null;<br/>}</span></pre><p id="f221" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于函数组件和类组件的调和和之前一样，都是调用render获取VDOM，然后继续处理渲染后的VDOM:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="bec3" class="mq lt iq nd b gy nh ni l nj nk">function updateClassComponent(wip) {<br/>  const { type, props } = wip;<br/>  const instance = new type(props);<br/>  const children = instance.render();<br/>  reconcileChildren(wip, children);<br/>}<br/>function updateFunctionComponent(wip) {<br/>  renderWithHooks(wip);<br/>  const { type, props } = wip;<br/>  const children = type(props);<br/>  reconcileChildren(wip, children);<br/>}</span></pre><p id="978e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协调是在一个循环中执行的，它在每次处理之前确定是否有更高优先级的任务可以被中断。因此，我们在每次协调纤程节点之前调用shouldYield方法。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="ad2d" class="mq lt iq nd b gy nh ni l nj nk">function workLoop() {<br/>  while (wip &amp;&amp; shouldYield()) {<br/>    performUnitOfWork();<br/>  }<br/>  if (!wip &amp;&amp; wipRoot) {<br/>    commitRoot();<br/>  }<br/>}</span></pre><p id="b22a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">shouldYield方法用于确定队列中是否有更高优先级的任务要处理，如果是，则首先处理纤程的这一侧，然后首先暂停这一侧。这就是纤维结构的调和是如何被打断的。这是通过纤程的数据结构，加上每次判断是否中断之前的循环处理来实现的。</p><p id="6fde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谈完渲染阶段(reconcile + schedule)，下一步就是进入提交阶段。如前所述，为了成为可中断的，协调阶段并不真正操作dom，而只是创建dom，然后创建一个effectTag来添加、删除和更改标签。提交阶段根据标签更新DOM。</p><p id="7633" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是提交阶段必须再次遍历纤程以找到带有effectTag的节点 <strong class="ky ir">并更新DOM吗？</strong>那也行，但没必要。您可以在协调期间将带有effectTag的节点收集到一个队列中，然后在提交期间遍历该队列。这个队列被称为effectList。</p><p id="8492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React将在提交阶段遍历effectList，并根据effectTag添加、删除和更改DOM。在创建DOM之前和之后，执行useEffect、useLayoutEffect和一些函数组件的生命周期函数。useEffect设计为在DOM操作之前异步调用，useLayoutEffect在DOM操作之后同步调用。</p><h2 id="c6ad" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated"><strong class="ak">为什么会这样？</strong></h2><p id="0a76" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为所有的DOM操作都要做，如果同步执行一个效果，计算量会非常大，会毁了纤程架构的优势。所以效果是异步的，不会阻塞渲染。而useLayoutEffect，顾名思义，就是在这个阶段获取一些布局信息。DOM操作完成并呈现后，您也可以自然地同步调用。</p><p id="125c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，React将提交阶段分为3个小阶段。<strong class="ky ir">突变前，突变后，布局</strong>。变异是迭代通过effectList来更新DOM。它前面是before variation，它异步调度useEffect回调函数。后面是布局阶段，因为这个阶段已经可以获取布局信息，并且会同步调用useLayoutEffect回调函数。这个阶段还获取新的DOM节点并更新ref。至此，我们对React的新架构以及渲染和提交阶段的工作有了一个清晰的了解。</p><h1 id="3b28" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="5405" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">React和Vue都是基于VDOM的前端框架。我们之所以使用VDOM，是因为我们可以准确地比较我们关心的属性，我们也可以跨平台渲染。</p><p id="9f72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但开发者不会直接编写VDOM，而是通过JSX，一种接近HTML语法的DSL，编译生成渲染函数，执行生成VDOM。VDOM的渲染是通过使用不同的DOM APIs根据不同的类型操作DOM来实现的。</p><p id="7365" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">渲染组件时，如果是函数组件，则执行它以获得VDOM。</p><p id="78ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该类组件创建一个实例并调用render方法来获取VDOM。</p><p id="477a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Vue的options对象调用render方法来获取VDOM。组件本质上是VDOM逻辑、函数、类、选项对象或其他任何东西的包装。React和Vue最大的区别是状态的管理方式。</p><p id="2769" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Vue是响应式的，React通过setState API工作。我认为这是最大的不同，因为它导致了React架构后来的变化。React的setState方法导致它不知道哪些组件发生了变化，它需要渲染整个VDOM。但这样计算量会更大，阻碍渲染并导致动画延迟。所以React后来被转换成了纤程架构，目标是可中断的计算。</p><p id="4ae7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了达到这个目的，我们不能边比较边更新DOM，所以我们把渲染分为两个阶段:<strong class="ky ir">渲染和提交。</strong>render阶段通过调度进行调和，即找到更改的部分，创建DOM，用添加、删除、更改来标记，在所有计算完成后，commit阶段更新DOM。</p><p id="ab49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在中断之后，我们必须找到父节点和兄弟节点，因此VDOM也被转换成纤程的数据结构，具有父节点和兄弟节点的信息。所以纤程指的是链表的数据结构和渲染提交的过程。</p><p id="9168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协调阶段一次处理一个纤程节点，在处理之前，它将判断shouldYield，如果有更高优先级的任务，那么它将首先执行另一个。</p><p id="7c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提交阶段不需要再次遍历纤程树，为了优化，react将所有带有effectTag的纤程放在effectList队列中，并遍历它以更新它。</p><p id="4544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在DOM操作之前，异步调用useEffect回调函数，异步是因为它不能阻止渲染。DOM操作后，同步调用useLayoutEffect的回调函数，更新ref。</p><p id="6413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，提交阶段分为变异前、变异和布局，它们对应于上面提到的三个部分。</p><p id="9f4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我觉得了解VDOM、JSX、组件本质、纤程、render(调和+调度)+ commit(变异、变异、布局前)的渲染流程，是对React原理的更深层次的理解。</p><p id="8f62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">期待您关注和阅读更多高质量的文章。</strong></p><p id="5dc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oc">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oc">plain English . io</em></strong></a><em class="oc">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oc">免费周报</em> </strong> </a> <em class="oc">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oc">Twitter</em></strong></a><strong class="ky ir"><em class="oc"/></strong><em class="oc">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oc">LinkedIn</em></strong></a><em class="oc">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oc">社区不和谐</em> </strong> </a> <em class="oc">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oc">人才集体</em> </strong> </a> <em class="oc">。</em></p></div></div>    
</body>
</html>