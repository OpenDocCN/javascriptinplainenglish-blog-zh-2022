<html>
<head>
<title>React: Create useFetch Custom Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:创建使用获取自定义钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-creating-usefetch-custom-hook-d123ebfd5ff?source=collection_archive---------2-----------------------#2022-09-04">https://javascript.plainenglish.io/react-creating-usefetch-custom-hook-d123ebfd5ff?source=collection_archive---------2-----------------------#2022-09-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="88cc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一个关于在React中创建自定义钩子以在所有组件中使用Fetch的教程。</h2></div><p id="487d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从16.8版开始，React Hooks被正式添加到React.js中。除了内置的钩子之外，我们可以定义自己的钩子来使用状态和其他reactor特性，而无需编写一个类。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/565696196c033ffaa0fd2ab89c43831a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*MPf44y3rDygE3T7dryiB_w.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Create useFetch cutom hook</figcaption></figure><p id="b0da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您有需要由多个组件使用的组件逻辑时，我们可以将该逻辑提取到自定义钩子。例如，如果需要在不同的组件中从服务器获取数据，则必须在每个组件中写入fetch函数，然后添加一个状态来处理加载和错误状态。我们可以创建一个自定义钩子并在任何地方重用它，而不是在每个组件中放入fetch。</p><p id="f139" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自定义挂钩以“<strong class="ke io">use”</strong>前缀开头。例如:<code class="fe lk ll lm ln b">useFetch</code>。</p><h2 id="f182" class="lo lp in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">第一步</h2><p id="60af" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">让我们创建一个新文件:<code class="fe lk ll lm ln b">useFetch.js</code></p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6aea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe lk ll lm ln b">app.js</code>我们正在进口我们的<code class="fe lk ll lm ln b">useFetch</code>鱼钩，并像使用任何其他鱼钩一样使用它。这是我们传入URL以获取数据的地方。现在，我们可以在任何组件中重用这个自定义钩子来从任何URL获取数据。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="fbb0" class="lo lp in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">第2步:添加加载/错误状态</h2><p id="fbb6" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">我们还可以添加额外的<code class="fe lk ll lm ln b">loading </code>和<code class="fe lk ll lm ln b">error</code>参数来指示数据是否正在获取以及是否发生错误。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2381" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用法:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="d3c4" class="lo lp in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">第3步:提取有什么“问题”？</h2><p id="46fb" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">让我们再看看这个代码块:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b468" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一切似乎都很好，可能会出什么问题？这个代码块你可以在几乎所有的文章和视频教程中找到。但我想在这里强调两点。如果:</p><p id="3651" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">首先:服务器返回无效的JSON字符串</strong></p><p id="386b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mo"/><code class="fe lk ll lm ln b"><em class="mo">json()</em></code><code class="fe lk ll lm ln b"><a class="ae mp" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank"><em class="mo">Response</em></a></code><em class="mo">接口的<em class="mo">方法接收</em> <code class="fe lk ll lm ln b"><a class="ae mp" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank"><em class="mo">Response</em></a></code> <em class="mo">数据流并读取直至完成。它返回一个承诺，将解析正文的结果解析为</em> <code class="fe lk ll lm ln b"><a class="ae mp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON" rel="noopener ugc nofollow" target="_blank"><em class="mo">JSON</em></a></code> <em class="mo">。</em></em></p><p id="d523" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第(1)行，我们使用<strong class="ke io"> json() </strong>函数解析响应，但是如果服务器返回一个字符串而不是json字符串，这个块将会抛出一个错误。假设我们的服务器只返回<strong class="ke io">“OK”</strong>文本作为响应。</p><pre class="kz la lb lc gt mq ln mr ms aw mt bi"><span id="9be1" class="lo lp in ln b gy mu mv l mw mx">res.status(200).send('OK')</span></pre><p id="986e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我们将获得成功状态，但是我们的获取将抛出一个错误:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/f4156b4c0a6d36c627ac9142860361b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUdNYf1iEvYqA56Mk1sviA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Invalid JSON string</figcaption></figure><p id="72b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">第二:捕捉服务器错误</strong></p><p id="2d7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果服务器返回<strong class="ke io"> 4xx </strong>或<strong class="ke io"> 5xx </strong>状态(例如404、500)，我们仍然会转到<code class="fe lk ll lm ln b">then</code>块而不是<code class="fe lk ll lm ln b">catch </code>块。因为这就是获取请求的工作方式。</p><p id="2c1c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mo">当出现网络错误时，Fetch承诺仅拒绝一个TypeError。因为4xx和5xx响应不是网络错误，所以没有什么可捕捉的。</em></p><p id="f67b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">解决这些错误</strong></p><p id="4c58" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于<strong class="ke io">第一点，</strong>我们可以添加一个try/catch块(对于<code class="fe lk ll lm ln b">async/await</code>和<code class="fe lk ll lm ln b">catch</code>块，用于处理Promise中的错误),如果出现错误，我们可以从响应中返回文本值。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2a5a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">注:</strong>我们这里用<code class="fe lk ll lm ln b">clone </code>是因为<code class="fe lk ll lm ln b">json </code>或者<code class="fe lk ll lm ln b">text </code>只能用一次。否则，它将抛出一个错误:</p><pre class="kz la lb lc gt mq ln mr ms aw mt bi"><span id="c7ef" class="lo lp in ln b gy mu mv l mw mx">TypeError: Failed to execute 'text' on 'Response': body stream already read at eval</span></pre><p id="599c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于<strong class="ke io">第二点</strong>(处理服务器错误)，我们需要检查响应状态(<code class="fe lk ll lm ln b">res.ok</code>可以是<code class="fe lk ll lm ln b">true </code>或<code class="fe lk ll lm ln b">false</code>)。</p><p id="3f5c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">密码</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="6c2d" class="lo lp in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">最后的步骤</h2><ul class=""><li id="86a8" class="nd ne in ke b kf mh ki mi kl nf kp ng kt nh kx ni nj nk nl bi translated">用async/await替换我们的promise链</li><li id="797d" class="nd ne in ke b kf nm ki nn kl no kp np kt nq kx ni nj nk nl bi translated">添加类型脚本</li><li id="d090" class="nd ne in ke b kf nm ki nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="ke io">添加重取选项</strong></li><li id="16fc" class="nd ne in ke b kf nm ki nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="ke io">有条件地获取(不仅在组件安装上)</strong></li></ul><p id="a85b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再次调用定制钩子的唯一方法是在钩子的<code class="fe lk ll lm ln b">useEffect</code>中添加依赖关系，并从组件中改变它。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="34f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">示例:</strong>假设我们需要在每次点击按钮时获取数据。点击按钮时，我们可以更改<strong class="ke io">切换</strong>值，该值用作useFetch挂钩中的依赖项，数据将被再次提取。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0d88" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在一切似乎都很好，但是如果我们需要通过点击按钮来加载数据，而不是在<strong class="ke io">组件安装</strong>上加载数据，该怎么办？如果我们试图像下面这样添加条件，它将抛出一个错误。这是因为钩子不能在条件下使用。这个代码不对↓</p><pre class="kz la lb lc gt mq ln mr ms aw mt bi"><span id="e63e" class="lo lp in ln b gy mu mv l mw mx">const [needToLoad, setNeedToLoad] = useState(false);<br/> let data;<br/>  if(needToLoad){<br/>     const resp =  useFetch(url, null);<br/>     data = resp.data<br/>  } else {<br/>    data = []<br/>}<br/>....<br/> &lt;h2&gt;Fetch data on Component load&lt;/h2&gt;<br/> &lt;button onClick={() =&gt;  setNeedToLoad(prev =&gt; !prev)}&gt;<br/>   change<br/>&lt;/button&gt;<br/>{data[0]?.title}</span></pre><p id="18eb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们会得到这个错误:</p><pre class="kz la lb lc gt mq ln mr ms aw mt bi"><span id="8a08" class="lo lp in ln b gy mu mv l mw mx">Rendered more hooks than during the previous render.</span></pre><p id="6544" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，我们可以将条件放在自定义挂钩中，而不是放在组件中。如果提供了<code class="fe lk ll lm ln b">refetch</code>并且值为<code class="fe lk ll lm ln b">null </code> —不需要加载数据。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="5b13" class="nr lp in bd lq ns nt nu lt nv nw nx lw jt ny ju lz jw nz jx mc jz oa ka mf ob bi translated">例子</h1><ul class=""><li id="4a96" class="nd ne in ke b kf mh ki mi kl nf kp ng kt nh kx ni nj nk nl bi translated">服务器返回一个字符串而不是JSON。<a class="ae mp" href="https://stackblitz.com/edit/useeffect-extended-hook?file=TextBlock.tsx" rel="noopener ugc nofollow" target="_blank"> Stackblitz演示</a></li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><ul class=""><li id="63dc" class="nd ne in ke b kf kg ki kj kl oc kp od kt oe kx ni nj nk nl bi translated">点击按钮重新提取数据。<a class="ae mp" href="https://stackblitz.com/edit/useeffect-extended-hook?file=App.tsx" rel="noopener ugc nofollow" target="_blank"> Stackblitz演示</a></li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><ul class=""><li id="2959" class="nd ne in ke b kf kg ki kj kl oc kp od kt oe kx ni nj nk nl bi translated">点击按钮而不是安装组件时发出获取请求。这里我们需要将<code class="fe lk ll lm ln b">param</code>设置为<code class="fe lk ll lm ln b">null</code>,这将阻止组件安装请求的发送。</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><ul class=""><li id="c7b1" class="nd ne in ke b kf kg ki kj kl oc kp od kt oe kx ni nj nk nl bi translated">提出发布/上传请求</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2b8a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样。此外，我们还可以从自定义钩子添加返回状态代码和错误消息。</p><p id="6f65" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这里找到<strong class="ke io">源代码</strong> <a class="ae mp" href="https://github.com/armenstepanyan/js-tips/blob/master/examples/react-useFetch-custom-hook.md" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到<strong class="ke io"> StackBlitz </strong>示例<a class="ae mp" href="https://stackblitz.com/edit/useeffect-extended-hook?file=App.tsx" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl of og hr oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ig ih ii ij ik"><p id="2527" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mo">更多内容看</em> <a class="ae mp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mo">说白了。报名参加我们的</em> <a class="ae mp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mo">免费周报</em> </strong> </a> <em class="mo">。关注我们关于</em><a class="ae mp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mo">Twitter</em></strong></a>，<a class="ae mp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mo">LinkedIn</em></strong></a><em class="mo">，</em><a class="ae mp" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mo">YouTube</em></strong></a><em class="mo">，以及</em> <a class="ae mp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mo">不和</em> </strong> </a> <em class="mo">。</em></strong></a></p></div></div>    
</body>
</html>