<html>
<head>
<title>How to Render a List in React, Angular, Vue, and Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React，Angular，Vue和Svelte中呈现列表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rendering-a-list-in-react-angular-vue-and-svelte-a2ea987f0c21?source=collection_archive---------5-----------------------#2022-05-09">https://javascript.plainenglish.io/rendering-a-list-in-react-angular-vue-and-svelte-a2ea987f0c21?source=collection_archive---------5-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="31ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">哪种方法是最好的？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aa3a42beb0149e35fc4966c92ab3b8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHF5_ZgxruaCm4LYeo9PGQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.pexels.com/de-de/@ketut-subiyanto?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Ketut Subiyanto</a> on <a class="ae kv" href="https://www.pexels.com/de-de/foto/liebe-menschen-frau-frauen-4760126/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="caf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将比较<a class="ae kv" href="https://2021.stateofjs.com/en-US/libraries/front-end-frameworks" rel="noopener ugc nofollow" target="_blank">四个最常用的前端框架</a> ( <strong class="ky ir"> React、Angular、Vue.js和Svelte </strong>)来分析它们呈现列表的方法。我将为每个框架提供一个带有运动场的代码示例，以指出相似性和特殊性。最后，我会在每个解决方案中加入我个人的看法。你最喜欢的方法是什么？请随意发表评论😊</p><p id="e7c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">免责声明:</em> </strong> <em class="ls">我知道React是一个库而不是一个框架，但出于本文的目的，我将它称为框架。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8ed4" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">介绍</h1><p id="ecd5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">你可能听人说过，如果你非常了解一种编程语言，那么学习其他语言是很简单的。许多编程结构在许多语言中都以相同的方式使用(循环、条件、数组、函数、类)，所以您只需要记住语法，就有了一个良好的开端。如果你是一个前端web开发人员，你可能已经意识到这同样适用于前端框架。主要概念总是相同的。总是有解决方案来<strong class="ky ir">呈现元素列表</strong>，有条件地呈现元素，传递属性，处理状态，对生命周期事件做出反应，以及更多的概念。</p><p id="22b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们将保持我们的列表非常简单。我们迭代包含一个<code class="fe mx my mz na b">name</code>和一个<code class="fe mx my mz na b">logo</code>属性的对象数组。我们在有序列表中显示数据，并显示条目的当前索引。这就是我们的产品系列的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><div class="nd ne gp gr nf ng"><a href="https://medium.com/@mariusbongarts11/will-web-components-replace-frontend-frameworks-535891d779ba" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">Web组件会取代前端框架吗？</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">它们是为解决不同的问题而构建的。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b65c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">反应</h1><p id="7691" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">假设您熟悉Javascript，React呈现列表的方法非常简单。React使您能够使用<code class="fe mx my mz na b">map()</code>函数轻松地遍历数组。下面，我们遍历<code class="fe mx my mz na b">items</code>数组并为每一项返回一个<code class="fe mx my mz na b">&lt;li&gt;</code>元素。访问当前索引也很容易，因为我们可以利用<code class="fe mx my mz na b">map()</code>函数的第二个参数。在元素中，我们可以将<code class="fe mx my mz na b">item</code>的属性放在花括号<code class="fe mx my mz na b">{</code> <code class="fe mx my mz na b">}</code>中。此外，我们还添加了一个独特的<code class="fe mx my mz na b">key</code>属性，以确保在我们想要让列表动态地删除或添加元素时有良好的性能。我们将更详细地了解这个属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">List rendering in React</figcaption></figure><p id="229f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://stackblitz.com/edit/react-ts-kynyaw?file=App.tsx" rel="noopener ugc nofollow" target="_blank">的Stackblitz </a>上玩这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nc l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">List rendering in React demo</figcaption></figure><h2 id="fa11" class="nw mb iq bd mc nx ny dn mg nz oa dp mk lf ob oc mm lj od oe mo ln of og mq oh bi translated">特殊性</h2><p id="6d16" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们看看React与其他框架的不同之处，以及在React中使用列表时需要考虑的问题。</p><p id="02c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关键属性</strong></p><p id="3c13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React中，如果列表可以动态改变，您应该向每个条目传递一个<code class="fe mx my mz na b">key</code>属性。数组中的键在其同级中必须是唯一的；否则，React将抛出一个错误。然而，它们不需要是全球唯一的。我们将看到在所有框架中提供唯一键的概念，现在我将更详细地解释这个概念。它的主要思想也适用于所有其他框架。</p><blockquote class="oi oj ok"><p id="651e" class="kw kx ls ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">该键只需在其同级中是唯一的，而不是全局唯一的。- <a class="ae kv" href="https://reactjs.org/docs/reconciliation.html#recursing-on-children" rel="noopener ugc nofollow" target="_blank"> reactjs .或</a> g</p></blockquote><p id="f6ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，<strong class="ky ir"> <em class="ls"> key </em> </strong>属性仅作为反应的提示，但它们不会传递给组件。对于我们的例子，这意味着传递的键在DOM中不可见。如果您的组件中需要相同的值，请将其作为具有不同名称的prop显式传递。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/71e0ba66573747e4003a2be5b5650117.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*-JKwOTlhPOWX1w1-6BoYQQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">DOM of the React list</figcaption></figure><p id="5c15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">我们如何给每个元素分配一个唯一的键？</strong>您显示的元素可能已经有了一个惟一的ID，所以密钥可能只是来自您的数据。您也可以将当前索引作为一个<code class="fe mx my mz na b">key</code>属性传递，但是React建议<strong class="ky ir">而不是</strong>这样做，如果条目的顺序可能改变的话。这可能会对性能产生负面影响，因为React需要弄清楚如何更新UI以有效地匹配最近的树。</p><blockquote class="oi oj ok"><p id="4360" class="kw kx ls ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">最后，您可以将数组中某项的索引作为键传递。如果商品从来没有重新订购过，这种方法可以很好地工作，但是重新订购会很慢。—<a class="ae kv" href="https://reactjs.org/docs/reconciliation.html#recursing-on-children" rel="noopener ugc nofollow" target="_blank">reactjs.org</a></p></blockquote><p id="48c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我定期将元素的当前索引与其值相结合。这可以确保没有重复的键，并防止我影响React的性能。</p><h2 id="1f3c" class="nw mb iq bd mc nx ny dn mg nz oa dp mk lf ob oc mm lj od oe mo ln of og mq oh bi translated">个人观点</h2><p id="eb11" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我喜欢React处理列表呈现的方式。使用基本的Javascript感觉很自然，因为你不需要理解新的语法。由于我使用了大量的Javascript/Typescript、<a class="ae kv" href="https://medium.com/@mariusbongarts11/will-web-components-replace-frontend-frameworks-535891d779ba" rel="noopener"> Web组件</a>和<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-blog-portfolio-with-web-components-lit-library-2701dffc735f"> Lit库</a>，当我第一次使用React时，我觉得我不需要学习任何新的东西。</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/@mariusbongarts11/share-code-between-react-client-and-express-server-5dc0977faa76" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">在React客户端和Express服务器之间共享代码</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">用yarn工作空间建立一个mono存储库</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="op l nr ns nt np nu kp ng"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="bcc1" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">有角的</h1><p id="fbee" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在Angular中，我们使用<code class="fe mx my mz na b">*ngFor</code>指令来呈现列表。我们使用关键字<code class="fe mx my mz na b">let</code>定义了一个名为<code class="fe mx my mz na b">item</code>的循环变量。然后我们可以使用插值<code class="fe mx my mz na b">{{</code> <code class="fe mx my mz na b">}}</code>来访问模板中的对象属性。此外，我们使用一个<strong class="ky ir">局部变量</strong>来访问当前索引并提供一个<code class="fe mx my mz na b">trackBy</code>函数，它是React中<code class="fe mx my mz na b">key</code>属性的等价解决方案。我们的模板看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="680e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://stackblitz.com/edit/angular-ivy-e9cqne?file=src/app/app.component.html" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>的例子上玩一玩:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nc l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Angular playground</figcaption></figure><h2 id="f963" class="nw mb iq bd mc nx ny dn mg nz oa dp mk lf ob oc mm lj od oe mo ln of og mq oh bi translated">特殊性</h2><p id="84a8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们看看Angular与其他框架的不同之处，以及在Angular中使用列表时需要考虑的问题。</p><p id="3783" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">跟踪功能</strong></p><p id="56ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">trackBy</code>函数的作用与React的<code class="fe mx my mz na b">key</code>属性相同。它允许我们定义一个函数，为每个iterable元素返回一个惟一的标识符。</p><blockquote class="oi oj ok"><p id="0435" class="kw kx ls ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">如果没有提供自定义<code class="fe mx my mz na b"><a class="ae kv" href="https://angular.io/api/core/TrackByFunction" rel="noopener ugc nofollow" target="_blank">TrackByFunction</a></code>，<code class="fe mx my mz na b"><a class="ae kv" href="https://angular.io/api/common/NgForOf" rel="noopener ugc nofollow" target="_blank">NgForOf</a></code>将使用项目的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank">对象标识</a>作为关键字。——<a class="ae kv" href="https://angular.io/api/common/NgForOf" rel="noopener ugc nofollow" target="_blank">https://angular.io/api/common/NgForOf</a></p></blockquote><p id="2034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们没有传递一个自定义的track by函数，并且我们的列表数据发生了变化，Angular就不能识别出发生变化的特定对象。这将导致整个列表的重新呈现，因为每个引用都被修改了。因此，每一个物体看起来都是新的。</p><p id="2731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">trackBy</code>函数将<em class="ls">索引</em>和<em class="ls">当前元素</em>作为参数，并返回该元素的唯一标识符。下面是我们的自定义函数在示例中的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">TrackBy function Angular</figcaption></figure><p id="0a0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">局部变量</strong></p><p id="d70a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Angular`s <code class="fe mx my mz na b">*ngFor</code>指令导出一些可以作为局部变量别名的值。例如:</p><p id="dae5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">*ngFor="let item of items; index as i, first as isFirst"</code></p><p id="916d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后可以在模板中使用变量<code class="fe mx my mz na b">isFirst</code>,当iterable中的第一个项目时，该变量解析为true。</p><p id="171b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下导出值可以作为局部变量的别名:</p><ul class=""><li id="0fff" class="oq or iq ky b kz la lc ld lf os lj ot ln ou lr ov ow ox oy bi translated"><code class="fe mx my mz na b">$implicit: T</code>:iterable(<code class="fe mx my mz na b"><a class="ae kv" href="https://angular.io/api/common/NgForOf" rel="noopener ugc nofollow" target="_blank">ngForOf</a></code>)中单个项目的值。</li><li id="35d8" class="oq or iq ky b kz oz lc pa lf pb lj pc ln pd lr ov ow ox oy bi translated"><code class="fe mx my mz na b"><a class="ae kv" href="https://angular.io/api/common/NgForOf" rel="noopener ugc nofollow" target="_blank">ngForOf</a>: <a class="ae kv" href="https://angular.io/api/core/NgIterable" rel="noopener ugc nofollow" target="_blank">NgIterable</a>&lt;T&gt;</code>:可迭代表达式的值。</li><li id="b170" class="oq or iq ky b kz oz lc pa lf pb lj pc ln pd lr ov ow ox oy bi translated"><code class="fe mx my mz na b">index: number</code>:iterable中当前项的索引。</li><li id="b76b" class="oq or iq ky b kz oz lc pa lf pb lj pc ln pd lr ov ow ox oy bi translated"><code class="fe mx my mz na b">count: number</code>:可迭代的长度。</li><li id="583c" class="oq or iq ky b kz oz lc pa lf pb lj pc ln pd lr ov ow ox oy bi translated"><code class="fe mx my mz na b">first: boolean</code>:当项目是iterable中的第一个项目时为True。</li><li id="b40d" class="oq or iq ky b kz oz lc pa lf pb lj pc ln pd lr ov ow ox oy bi translated"><code class="fe mx my mz na b">last: boolean</code>:当项目是iterable中的最后一个项目时为True。</li><li id="ab74" class="oq or iq ky b kz oz lc pa lf pb lj pc ln pd lr ov ow ox oy bi translated"><code class="fe mx my mz na b">even: boolean</code>:当iterable中项的索引为偶数时为真。</li><li id="b09c" class="oq or iq ky b kz oz lc pa lf pb lj pc ln pd lr ov ow ox oy bi translated"><code class="fe mx my mz na b">odd: boolean</code>:当iterable中项的索引为奇数时为真。</li></ul><p id="9bb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">管道</strong></p><p id="eb94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">角度管道是<a class="ae kv" href="https://angular.io/guide/glossary#template-expression" rel="noopener ugc nofollow" target="_blank">模板表达式</a>中的简单函数，用于接受输入值并返回转换值。我们可以使用<a class="ae kv" href="https://angular.io/guide/glossary#pipe" rel="noopener ugc nofollow" target="_blank">管道</a>来转换字符串、货币金额、日期，例如，过滤一组项目。有很多内置管道。例如，其中最重要的一个是<code class="fe mx my mz na b">AsyncPipe</code>，它使我们能够在模板中直接使用承诺和可观察值。</p><p id="204d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们没有使用角形管道，但是它们是转换数组的好方法。让我们创建一个管道来过滤以字母<em class="ls">S</em>开头的所有项目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="33f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并在我们的模板中使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="23eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将导致只显示苗条的条目。</p><h2 id="4572" class="nw mb iq bd mc nx ny dn mg nz oa dp mk lf ob oc mm lj od oe mo ln of og mq oh bi translated">个人观点</h2><p id="e95a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我不喜欢你需要学习新的框架语法。尽管我使用Angular已经很多年了，但有些时候还没有，我使用<code class="fe mx my mz na b">ngFor</code>语法的第一直觉是错误的，因为我忘了把<code class="fe mx my mz na b">*</code>放在它前面。</p><p id="17a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，Angular的解决方案干净优雅。包含特殊<strong class="ky ir">局部变量</strong>的可能性是有用的。但是，它们中的许多都有点不必要，因为您只需使用<code class="fe mx my mz na b">index</code>就可以轻松复制其中的大部分:</p><ul class=""><li id="de44" class="oq or iq ky b kz la lc ld lf os lj ot ln ou lr ov ow ox oy bi translated"><code class="fe mx my mz na b">first</code>与<code class="fe mx my mz na b">index === 0</code>相同</li><li id="e27e" class="oq or iq ky b kz oz lc pa lf pb lj pc ln pd lr ov ow ox oy bi translated"><code class="fe mx my mz na b">even</code>与<code class="fe mx my mz na b">index % 2 === 0</code>相同</li></ul><p id="c5b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，我看不出提供<code class="fe mx my mz na b">trackBy</code>功能有什么好处。传递一个<code class="fe mx my mz na b">key</code>属性，就像我们在React、Vue和Svelte中做的那样，似乎容易得多。此外，我看不到通过析构对象来直接访问其属性的可能性。这是我通常喜欢做的事情。</p><p id="1d47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能听起来我不是Angular的粉丝，但我是。Angular非常强大，尤其是在大型企业应用方面。使用Rxjs遵循反应式编程方法使得框架非常稳定。尽管如此，学习Rxjs对许多开发人员来说可能是一个障碍，因为学习曲线无疑是陡峭的。</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/@mariusbongarts11/share-code-between-angular-client-and-express-server-110750d32e30" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">在Angular客户端和Express服务器之间共享代码</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">使用Yarn 3工作空间设置Monorepo</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="pe l nr ns nt np nu kp ng"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6efd" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">某视频剪辑软件</h1><p id="8951" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Vue处理列表呈现的方式看起来很像Angular在做这件事。在Vue中，我们可以使用<code class="fe mx my mz na b">v-for</code>指令来呈现基于数组的项目列表。我们遍历<code class="fe mx my mz na b">items</code>数组，并为每个<code class="fe mx my mz na b">item</code>返回一个<code class="fe mx my mz na b">&lt;li&gt;</code>元素。在<code class="fe mx my mz na b">v-for</code>范围内，模板表达式可以访问所有的父范围属性。此外，<code class="fe mx my mz na b">v-for</code>还支持当前项目索引的可选第二别名，我们可以提供一个<code class="fe mx my mz na b">key</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">List rendering in Vue</figcaption></figure><p id="5289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以用<a class="ae kv" href="https://stackblitz.com/edit/vue-gk7a6v?file=src/components/Items.vue" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>上的例子进行试验:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nc l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Vue playground</figcaption></figure><h2 id="1d67" class="nw mb iq bd mc nx ny dn mg nz oa dp mk lf ob oc mm lj od oe mo ln of og mq oh bi translated">特殊性</h2><p id="94ca" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们看看Vue与其他框架的不同之处，以及在Vue中使用列表时需要考虑的问题。</p><p id="fb61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><strong class="ky ir">v-for</strong></code> <strong class="ky ir">用一个物体</strong></p><p id="eecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Vue中，您还可以使用<code class="fe mx my mz na b">v-for</code>来遍历对象的属性。我还没有在其他框架中看到过。但是，当然，在任何其他框架中使用JavaScript也可以达到同样的效果。它看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f15c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><strong class="ky ir">v-for</strong></code> <strong class="ky ir">带量程</strong></p><p id="a31e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个具体的特性是你可以迭代一个整数。在这种情况下，它将根据<code class="fe mx my mz na b">1...n</code>的范围多次重复模板。</p><pre class="kg kh ki kj gt pf na pg ph aw pi bi"><span id="a068" class="nw mb iq na b gy pj pk l pl pm">&lt;span v-for="n in 10"&gt;{{ n }}&lt;/span&gt;</span></pre><p id="235c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关键属性</strong></p><p id="806a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了React，Vue还提供了一个关键属性，这样它就可以跟踪每个节点的身份</p><blockquote class="oi oj ok"><p id="7ec7" class="kw kx ls ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated"><a class="ae kv" href="https://vuejs.org/style-guide/rules-essential.html#use-keyed-v-for" rel="noopener ugc nofollow" target="_blank">建议</a>尽可能提供一个带有<code class="fe mx my mz na b">v-for</code>的<code class="fe mx my mz na b">key</code>属性—<a class="ae kv" href="https://vuejs.org/guide/essentials/list.html#maintaining-state-with-key" rel="noopener ugc nofollow" target="_blank">vuejs.org</a></p></blockquote><h2 id="9d3c" class="nw mb iq bd mc nx ny dn mg nz oa dp mk lf ob oc mm lj od oe mo ln of og mq oh bi translated">个人观点</h2><p id="c5ac" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我对这个的看法和我对Angular的看法很像。我总是喜欢使用简单的Javascript <code class="fe mx my mz na b">map()</code>函数来遍历我的列表。但是，与Angular相比，Vue的解决方案在我看来更简单明了，也没那么复杂。</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/@mariusbongarts11/showcase-your-medium-articles-with-web-components-part-1-basics-d2c6618e9482" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">用Web组件构建自己的博客组合:基础</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">第1部分—定制元素、阴影DOM和HTML模板</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="pn l nr ns nt np nu kp ng"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b42d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">苗条的</h1><p id="681b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">使用Svelte，我们可以使用each-block来迭代我们的<code class="fe mx my mz na b">items</code>数组。我们可以通过指定第二个参数来获取索引。为了唯一地标识每个列表项，我们在方括号<code class="fe mx my mz na b">(</code> <code class="fe mx my mz na b">)</code>中提供了一个关键表达式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Svelte list rendering syntax</figcaption></figure><p id="2aaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://stackblitz.com/edit/node-9derzq" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>的例子上玩一玩:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nc l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Svelte playground</figcaption></figure><h2 id="fac4" class="nw mb iq bd mc nx ny dn mg nz oa dp mk lf ob oc mm lj od oe mo ln of og mq oh bi translated">特殊性</h2><p id="e0d7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们看看Svelte与其他框架的不同之处，以及在Svelte中使用列表时需要考虑的问题。</p><p id="2135" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><strong class="ky ir">{:else}</strong></code> <strong class="ky ir">条款</strong></p><p id="b498" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Svelte中一个方便的事情是，你还可以有一个<code class="fe mx my mz na b">{:else}</code>子句，如果列表为空，就会呈现这个子句:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关键属性</strong></p><p id="8722" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像所有其他框架一样，Svelte提供了唯一标识每个列表项的方法。为此，我们可以为<code class="fe mx my mz na b">each</code>块指定一个惟一的标识符(或“键”)。这样，我们就告诉了Svelte如何在组件更新时确定要更改哪个DOM节点。</p><blockquote class="oi oj ok"><p id="ca86" class="kw kx ls ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">键可以是任何对象，但是建议使用字符串和数字，因为当对象本身发生变化时，它们允许身份保持不变。—【https://svelte.dev/docs#template-syntax-each T21】</p></blockquote><h2 id="a65c" class="nw mb iq bd mc nx ny dn mg nz oa dp mk lf ob oc mm lj od oe mo ln of og mq oh bi translated">个人观点</h2><p id="20e3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我需要习惯Svelte的语法。我喜欢在模板中添加一个<code class="fe mx my mz na b">:else</code>块的可能性，因为这是你需要经常做的事情。我还喜欢你可以在<code class="fe mx my mz na b">#each</code>块中自由使用析构和rest模式。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="4b78" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">最后的想法</h1><p id="1aa4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">所有四个最常用的前端框架在呈现列表上都非常相似。它们有很多相似之处，比如可以为每个条目提供唯一的键来有效地更新DOM。</p><p id="ab70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不能说一个框架有完美的解决方案。归根结底，这是一个品味问题。最重要的是，如果您知道如何在一个框架中呈现列表，您可以将您的知识应用到任何其他框架中。当掌握任何其他概念时，学习新的前端框架将很快到来。</p><p id="f47c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢阅读这篇文章。我总是很乐意回答问题，也乐于接受批评。请随时联系我😊</p><p id="56e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@mariusbongarts/membership" rel="noopener"> <strong class="ky ir">这里是无限制访问媒体上每一个内容的链接</strong> </a> <strong class="ky ir">。如果你通过这个链接注册，我将免费为你赚一小笔钱。</strong></p><div class="nd ne gp gr nf ng"><a href="https://medium.com/@mariusbongarts/membership" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">通过我的推荐链接加入Medium-Marius bong arts</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="po l nr ns nt np nu kp ng"/></div></div></a></div><p id="d53d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关注我，不要错过我的下一篇文章。我写了关于Typescript、Web组件、前端框架、软件设计模式、Chrome扩展以及更多的主题！🙏</p><h1 id="4ada" class="ma mb iq bd mc md pp mf mg mh pq mj mk jw pr jx mm jz ps ka mo kc pt kd mq mr bi translated">关于作者</h1><p id="3136" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Marius Bongarts是埃森哲互动公司的软件工程分析师。他还创建了<a class="ae kv" href="https://chrome.google.com/webstore/detail/web-highlights-%20-bookmark/hldjnlbobkdkghfidgoecgmklcemanhm" rel="noopener ugc nofollow" target="_blank"> Web Highlights Chrome扩展</a>，允许成千上万的用户在每个网站上创建文本亮点和书签。通过提供标签和目录，您可以在<a class="ae kv" href="https://web-highlights.com/home" rel="noopener ugc nofollow" target="_blank">web-highlights.com</a>上的相应web应用程序中轻松重新找到您的web研究。看看吧！</p><p id="69b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过<strong class="ky ir"/><a class="ae kv" href="https://www.linkedin.com/in/marius-bongarts-6b3638171/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">LinkedIn</strong></a><strong class="ky ir"/>联系我或者在<a class="ae kv" href="https://twitter.com/MariusBongarts" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Twitter </strong> </a>上关注我。</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/@mariusbongarts11/will-web-components-replace-frontend-frameworks-535891d779ba" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">Web组件会取代前端框架吗？</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">它们是为解决不同的问题而构建的。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://medium.com/@mariusbongarts11/when-you-should-duplicate-code-b0d747bc1c67" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">何时应该复制代码</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">复制比错误的抽象要便宜得多</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="pu l nr ns nt np nu kp ng"/></div></div></a></div><p id="e725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">plain English . io</em></strong></a><em class="ls">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">Twitter</em></strong></a><em class="ls">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">LinkedIn</em></strong></a><em class="ls">。加入我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">社区不和谐</em> </strong> </a> <em class="ls">。</em></p></div></div>    
</body>
</html>