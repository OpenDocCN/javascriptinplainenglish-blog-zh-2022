<html>
<head>
<title>React: MVVM example with MobX and Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React: MVVM使用MobX和钩子的例子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-mvvm-with-mobx-89b2444b1f64?source=collection_archive---------3-----------------------#2022-12-21">https://javascript.plainenglish.io/react-mvvm-with-mobx-89b2444b1f64?source=collection_archive---------3-----------------------#2022-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/36ebecc407644d900ab145b0bf746b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1IZjh74vgRP_wrKDwb1yOQ.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="9a18" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">您有开发React应用程序的经验，但是您从未在您的项目中使用过模型-视图-视图模型(MVVM)架构模式。不要担心！在这篇文章中，我将向您概述如何在您的下一个React应用中实现MVVM，它使用MobX来创建高度可测试的代码。</p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="f9f4" class="la lb in bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">MVVM？那是什么鬼东西？</h2><p id="c172" class="pw-post-body-paragraph kc kd in ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ig bi translated">MVVM是通过将驱动UI的代码(例如，改变按钮上的颜色或标签上的文本)从驱动它的业务逻辑(例如，根据John是否被授权产生字符串“Hello，John”或“Hello，Guest ”)中分离出来，方法是将该逻辑转移到组件之外的独立对象中。在用户的要求下，呈现信息或执行任务的行为会因应用程序中的每个屏幕或组件而异。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/c8703194a5d9942eee5bfe5efc3ce955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XNFgx3mN1Vrk-IjO.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">MVVM explained</figcaption></figure><h2 id="bb69" class="la lb in bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">为什么用MVVM？</h2><p id="e549" class="pw-post-body-paragraph kc kd in ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ig bi translated">MVVM维护连接到视图的特定于视图的逻辑，从某种意义上说，它不是在更全局的设置中维护的(像Redux may)，但它也将它从视图中分离/解耦，因为它是完全由开发人员定义的完全不同的对象。也就是说，它是如何工作的并不神秘，并且它可以在相关的高代码覆盖率下进行测试。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c47f107f4b3b553226fe5229939b9e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*EzrhF55FpOWO9W46"/></div></figure><p id="7f9e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">测试，MVVM使得对对象的逻辑进行单元测试变得更加容易，而不是模糊UI测试的界限。我们不需要渲染任何组件，也不需要依赖任何特定于UI的生命周期或其他依赖。相反，我们可以简单地创建一些纯业务逻辑，注入任何我们自己的依赖项，并确保它产生UI期望的任何东西。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c19bc2ee258b8fa1d802ed1bb72ae75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*CdUxhCcvsEhWNJGj"/></div></figure><p id="98a6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">将它与UI分离还允许我们构建一个“哑”UI，这意味着我们的UI除了显示数据而不改变它，并将交互转移到其他东西(视图模型)之外什么也不做。这简化了UI代码(使其更容易阅读),因为不需要逻辑，所以更易于重用——并使在Storybook中显示UI组件变得非常容易。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/0d3a725fec1da030f7c452ad6471617a.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/0*ovWXbZMmEQUQCccS"/></div></figure><h2 id="8610" class="la lb in bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated"><strong class="ak">MobX是什么？值得吗？</strong></h2><p id="7d38" class="pw-post-body-paragraph kc kd in ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ig bi translated">MobX(根据他们的网站)是一个久经考验的库，通过透明地应用函数式反应式编程，使状态管理变得简单和可伸缩。</p><p id="8ffe" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">它是一个库，当视图模型的状态发生变化时，它会通知视图，从而产生一个新的呈现(这称为观察者模式)。</p><h2 id="f3d4" class="la lb in bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">这个例子</h2><p id="ff84" class="pw-post-body-paragraph kc kd in ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ig bi translated">如果您曾经阅读过Redux Toolkit文档，您可能会遇到他们的反例。我们将使用MVVM方法构建相同的东西，看看它看起来有什么不同，以及如何测试它。</p><p id="ab62" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">要将其转换为MVVM设计，我们需要一个称为视图模型的对象来存放我们的逻辑，一个称为视图的对象将视图模型作为道具并返回完全呈现的视图，另一个对象将它们连接在一起。</p><p id="40f2" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">从视图模型开始，我们可以将所有的功能都转移到这个对象上，只暴露视图需要交互的内容:</p><pre class="lz ma mb mc gt mj mk ml bn mm mn bi"><span id="c6a8" class="mo lb in mk b be mp mq l mr ms">// ViewModel.js<br/>import {action, computed, observable} from "mobx";<br/><br/>class ViewModel {<br/>  // Initial value for the count variable that is marked as observable<br/>  @observable private count = 0;<br/>  <br/>  constructor(/*here we can accept any dependency*/){<br/>    // here we use our dependency and manipulate it<br/>   }<br/><br/>  @action onClick = (): void =&gt; {<br/>    this.count += 1;<br/>  };<br/><br/>  @computed get countLabel(): string {<br/>    return `clicked ${this.count} times`;<br/>  }<br/>}<br/><br/>export default ViewModel;</span></pre><p id="0a9a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在视图模型中，我们可以使用Jest在测试中模拟它们。但是，在我们开始测试之前，这里是我们的观点:</p><pre class="lz ma mb mc gt mj mk ml bn mm mn bi"><span id="2101" class="mo lb in mk b be mp mq l mr ms">// View.jsx<br/><br/>import {observer} from "mobx-react";<br/>import ViewModel from "./ViewModel";<br/><br/>const ViewComponent = ({viewModel}: Props) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;p&gt;{viewModel.countLabel}&lt;/p&gt;<br/>    &lt;button onClick={viewModel.onClick}&gt;Click me&lt;/button&gt;<br/>  &lt;/div&gt;<br/>);<br/><br/>export default observer(ViewComponent);</span></pre><p id="e10b" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的视图不再被认为仅仅是UI代码。视图不执行任何逻辑；从显示的信息到用户交互，一切都通过视图模型传递。</p><p id="7c76" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">最后，还有将它们粘合在一起的“胶水”。这是我们在“根”或其他组件中提到的组件(而不是显式的“ViewModel.js”或“View.jsx”)。</p><pre class="lz ma mb mc gt mj mk ml bn mm mn bi"><span id="351f" class="mo lb in mk b be mp mq l mr ms">// App.jsx <br/>const App = () =&gt; {<br/>  const viewModel = new ViewModel(/*here we can inject dependenicies to retrieve them as i said above*/);<br/>  return &lt;ViewComponent viewModel={viewModel} /&gt;;<br/>};<br/><br/>export default App;</span></pre><p id="8896" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">对于每个MVVM组件，这个文件看起来完全一样(除了注入到视图模型中的依赖项，如果它们存在的话)。它的主要目标是将依赖项注入视图模型并返回视图，从而消除了在使用该视图的UI组件中对样板代码的需求。</p><h2 id="1949" class="la lb in bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated"><strong class="ak">测试！</strong></h2><p id="651e" class="pw-post-body-paragraph kc kd in ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ig bi translated">现在是使用MVVM的主要原因:测试！本质上，您必须构建一个标准的组件测试，在与组件进行交互之前显示组件。</p><p id="ee79" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的视图模型测试将会像这样结束。</p><pre class="lz ma mb mc gt mj mk ml bn mm mn bi"><span id="008e" class="mo lb in mk b be mp mq l mr ms">// ViewModel.test.js<br/>import ViewModel from "./ViewModel";<br/><br/>beforeEach(() =&gt; {<br/>  viewModel = new ViewModel(/*we mock our dependency*/);<br/>});<br/><br/>it("has appropriate initial label", () =&gt; {<br/>  expect(viewModel.countLabel).toEqual("clicked 0 times");<br/>});<br/><br/>describe("when clicked", () =&gt; {<br/>  beforeEach(() =&gt; {<br/>    viewModel.onClick();<br/>  });<br/><br/>  it("updates the counter label", () =&gt; {<br/>    expect(viewModel.countLabel).toEqual("clicked 1 times");<br/>  });<br/>});</span></pre><p id="dc9c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在开发单元测试时，我们通常希望一次测试一件事情。这是一个视图模型测试，类似于他们的样本组件测试。不通过UI，我们可以只测试驱动计数器的逻辑。</p><h2 id="efba" class="la lb in bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">简单地</h2><p id="28df" class="pw-post-body-paragraph kc kd in ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ig bi translated">我描述的用例非常简单，这可能会让您疑惑“这有什么意义？”鉴于反例的简单性，这是合理的。更有可能的是，我们会有网络呼叫、异步活动和要跟踪的全球状态，这是MVVM真正能发光的地方。我们可以简单地注入这种依赖，并使用MVVM验证我们的UI行为，而不必开发UI测试来确保我们的UI按预期运行。</p><p id="787e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">有了MVVM，你可以建立一个清晰的关注点分离，测试将会像呼吸一样简单。</p><p id="eb47" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><em class="mt">更多内容请看</em><a class="ae mu" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mt">plain English . io</em></strong></a><em class="mt">。报名参加我们的</em> <a class="ae mu" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mt">免费周报</em> </strong> </a> <em class="mt">。关注我们关于</em><a class="ae mu" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mt">Twitter</em></strong></a><a class="ae mu" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mt">LinkedIn</em></strong></a><em class="mt"/><a class="ae mu" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mt">YouTube</em></strong></a><em class="mt"/><a class="ae mu" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mt">不和</em> </strong> </a> <strong class="ke io"> <em class="mt">。</em>T49】</strong></p><p id="955f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io"> <em class="mt">对缩放您的软件启动感兴趣</em> </strong> <em class="mt">？检查</em> <a class="ae mu" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mt">电路</em> </strong> </a> <em class="mt">。</em></p></div></div>    
</body>
</html>