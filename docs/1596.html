<html>
<head>
<title>The Power of Proxy Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中代理模式的威力</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-power-of-proxy-pattern-in-javascript-46b2223c48ec?source=collection_archive---------4-----------------------#2022-04-05">https://javascript.plainenglish.io/the-power-of-proxy-pattern-in-javascript-46b2223c48ec?source=collection_archive---------4-----------------------#2022-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="466d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">代理人不需要总是听起来很无聊。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/583e2c823b34726d596cff3fbf2e0b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*6h5X0FsEasJJdaKtkUrydA.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk"><em class="kr">Photo by Caspar Camille Rubin on Unsplash</em></figcaption></figure><p id="f101" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我在职业生涯后期学到的一个更有趣的模式是代理。</p><p id="c3df" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您寻找代理模式的例子时，您可能经常会看到不同的实现变体。这是因为代理并不局限于一个用例。一个代理可能充当验证者，而另一个可能对提高性能更感兴趣，等等。</p><p id="b16f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">其思想是，通过利用一个代理，我们包装现有的对象，其功能与原始对象相同，其中其方法(甚至属性)完全相同，直到我们在包装的函数被调用之前，在包装的方法<em class="lo">中添加额外的逻辑。这是一个对外界完全隐藏的过程，并且这个呼叫对呼叫者来说总是相同的。</em></p><p id="2a3e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">换句话说，代理正好位于对象的客户端和实际对象本身之间。这是它可以选择充当“保护者”或添加自定义逻辑的地方，比如<em class="lo">缓存</em>，而调用者对此一无所知。正因为如此，它有时可以被称为调解人。有些人也可能把它归类为装饰模式的另一种形式，但还是有一些不同。</p><p id="b8c6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在本帖中，我们将介绍JavaScript中代理设计模式的强大功能，以及它对您的下一个应用程序有多大益处的几个例子。</p><p id="f8c4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为JavaScript本身添加了一个实现该模式的<code class="fe lp lq lr ls b">Proxy</code>类，所以我们将直接使用<code class="fe lp lq lr ls b">Proxy</code>类来演示这个模式。</p><h1 id="0c10" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">装饰者和代理的区别</h1><p id="333b" class="pw-post-body-paragraph ks kt iq ku b kv ml jr kx ky mm ju la lb mn ld le lf mo lh li lj mp ll lm ln ij bi translated">在装饰器模式中，装饰器的主要职责是增强它所包装(或“装饰”)的对象，而代理具有更多的可访问性并控制对象。</p><p id="4c7d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">代理可以选择增强它所包装的对象，或者以其他方式控制它，比如限制来自外界的访问，但是装饰器会通知并应用增强。</p><p id="f960" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">责任方面的区别是显而易见的。工程师通常使用decorators来添加新的行为，或者作为旧的或遗留类的适配器的一种形式，在那里他们返回一个增强的接口<em class="lo">，客户端可能知道但同时并不关心这个接口</em>。代理通常打算返回<em class="lo">同一个接口，在这个接口上，客户端可能假设它正在处理同一个未被触及的对象</em>。</p><h1 id="6432" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">验证器/助手</h1><p id="4083" class="pw-post-body-paragraph ks kt iq ku b kv ml jr kx ky mm ju la lb mn ld le lf mo lh li lj mp ll lm ln ij bi translated">我将在这里展示的代理模式的第一个实现是一个验证器。</p><p id="18f0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个例子展示了作为一种帮助验证输入和保护属性不被设置为错误数据类型的方法而实现的模式。请记住，调用方必须始终假设它正在处理原始对象，因此代理不能更改它正在包装的对象的签名或接口:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ab41" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个例子展示了一个简单的助手，它验证一个对象的字段，当验证失败时抛出一个<code class="fe lp lq lr ls b">TypeError</code>异常。</p><p id="d90e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">代理取得<code class="fe lp lq lr ls b">id</code>属性的<code class="fe lp lq lr ls b">getter</code>和<code class="fe lp lq lr ls b">setter</code>的所有权，并选择允许或拒绝试图设置的值。</p><p id="f07e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe lp lq lr ls b">Proxy</code>类中，它可以这样实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d9b9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">验证器工作得非常好:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="77ee" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">剪贴板多填充</h1><p id="1453" class="pw-post-body-paragraph ks kt iq ku b kv ml jr kx ky mm ju la lb mn ld le lf mo lh li lj mp ll lm ln ij bi translated">这一节将通过确保浏览器支持<code class="fe lp lq lr ls b">Navigator.clipboard</code> API，将代理作为一种支持旧浏览器的方式，将选择的文本复制到用户的剪贴板中。如果没有，那么它将使用<code class="fe lp lq lr ls b">execCommand</code>来复制选择。</p><p id="ec0a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">同样，客户端将总是假设它正在调用方法的对象是原始对象，并且只知道它正在调用上述方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bf26" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您可能会问，在这种情况下应用代理有什么意义，而不是在实际的<code class="fe lp lq lr ls b">copyToClipboard</code>函数中直接硬编码实现。如果我们使用一个代理，我们可以把它作为一个独立的来重用，并且通过<a class="ae ms" href="https://en.wikipedia.org/wiki/Inversion_of_control#:~:text=In%20software%20engineering%2C%20inversion%20of,control%20from%20a%20generic%20framework." rel="noopener ugc nofollow" target="_blank">控制反转</a>来自由地改变实现。</p><p id="40e6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用这种策略的另一个好处是我们不会修改原始函数。</p><h1 id="86ae" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">缓存器(增强性能)</h1><p id="220e" class="pw-post-body-paragraph ks kt iq ku b kv ml jr kx ky mm ju la lb mn ld le lf mo lh li lj mp ll lm ln ij bi translated">在许多不同的场景中，缓存可以采用许多不同的形式。比如HTTP请求的重新验证时有<a class="ae ms" href="https://datatracker.ietf.org/doc/html/rfc5861" rel="noopener ugc nofollow" target="_blank"> Stale、</a><a class="ae ms" href="https://docs.nginx.com/nginx/admin-guide/content-cache/content-caching/" rel="noopener ugc nofollow" target="_blank"> nginx内容缓存</a>、<a class="ae ms" href="https://en.wikipedia.org/wiki/CPU_cache" rel="noopener ugc nofollow" target="_blank"> CPU缓存</a>、<a class="ae ms" href="https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/Strategies.html" rel="noopener ugc nofollow" target="_blank">懒加载缓存</a>、内存等。</p><p id="a487" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在JavaScript中，我们还可以在代理的帮助下实现缓存。</p><p id="8f7e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">要实现代理模式而不直接使用<code class="fe lp lq lr ls b">Proxy</code>类，我们可以这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="23ba" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">缓存:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2912" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe lp lq lr ls b">Proxy</code>类中直接实现这一点很简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="cbe2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><code class="fe lp lq lr ls b">Proxy</code>类</h1><p id="f99c" class="pw-post-body-paragraph ks kt iq ku b kv ml jr kx ky mm ju la lb mn ld le lf mo lh li lj mp ll lm ln ij bi translated">我们已经在几个准系统代理模式实现中看到了持久模式，而不是直接使用<code class="fe lp lq lr ls b">Proxy</code>类。因为JavaScript直接将<code class="fe lp lq lr ls b">Proxy</code>作为对象提供给语言，所以为了方便起见，本文的其余部分将使用它。</p><p id="1c42" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">所有剩下的例子都可以在没有<code class="fe lp lq lr ls b">Proxy</code>的情况下实现，但是我们将把重点放在类语法上，因为它更简洁，更容易操作，特别是为了这篇文章。</p><h1 id="80af" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">单例的代理</h1><p id="819d" class="pw-post-body-paragraph ks kt iq ku b kv ml jr kx ky mm ju la lb mn ld le lf mo lh li lj mp ll lm ln ij bi translated">如果您从未听说过Singleton，那么它是另一种设计模式，可以确保如果感兴趣的对象已经在应用程序的整个生命周期中被实例化，那么它将被返回和重用。在实践中，你很可能会看到它被用作一些全局变量。</p><p id="123e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">例如，如果我们正在编写一个MMORPG游戏，我们有三个类<code class="fe lp lq lr ls b">Equipment</code>、<code class="fe lp lq lr ls b">Person</code>和<code class="fe lp lq lr ls b">Warrior</code>，其中只能有一个<em class="lo"/><code class="fe lp lq lr ls b">Warrior</code>，我们可以在实例化<code class="fe lp lq lr ls b">Warrior</code><em class="lo"/>类上的<code class="fe lp lq lr ls b">Proxy</code>时使用第二个参数中的<code class="fe lp lq lr ls b">construct</code>处理程序方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8c0c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们试图创建多个<code class="fe lp lq lr ls b">Warrior</code>实例，我们可以确保每次只使用第一个创建的实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e933" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="b642" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">偷饼干的人</h1><p id="6f4b" class="pw-post-body-paragraph ks kt iq ku b kv ml jr kx ky mm ju la lb mn ld le lf mo lh li lj mp ll lm ln ij bi translated">在这一节中，我们将演示一个使用<code class="fe lp lq lr ls b">Proxy</code>来防止cookies列表突变的例子。这将防止原始对象发生变异，并且变异者(<code class="fe lp lq lr ls b">CookieStealer</code>)会认为他们的邪恶操作成功了。</p><p id="7be4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们来看看这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8453" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">乔治的食物:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="afbe" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们使用<code class="fe lp lq lr ls b">Human</code>类实例化了<code class="fe lp lq lr ls b">george</code>,并在它的存储中添加了7种食物。乔治很高兴他将要吃他的水果和饼干。他对他的饼干特别兴奋，因为他同时得到了他最喜欢的口味，很快就会狼吞虎咽地吃下去，以满足他对饼干的渴望。</p><p id="1d69" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然而，有一个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="fab6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">那只<code class="fe lp lq lr ls b">CookieStealer</code>突然出现来偷他的饼干。<code class="fe lp lq lr ls b">CookieStealer</code>现在在他的存储器中有5个cookies:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e96f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">乔治:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="095f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们倒回去，介绍我们的救世主<code class="fe lp lq lr ls b">Superman</code>来应用他的一种实现<code class="fe lp lq lr ls b">Proxy</code>模式的方法来阻止<code class="fe lp lq lr ls b">CookieStealer</code>的邪恶行为，这将解决我们的问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a4a7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们的朋友<code class="fe lp lq lr ls b">superman</code>幸运地碰巧有一个<code class="fe lp lq lr ls b">protectFromCookieStealers</code>利用<code class="fe lp lq lr ls b">Proxy</code>的力量给<em class="lo">伪造了</em>一份饼干名单！他把真正的包含乔治饼干的食物收藏藏起来，不让T3看到。<code class="fe lp lq lr ls b">CookieStealer</code>继续他邪恶的计划，似乎被<em class="lo">骗了</em>以为他带走了饼干:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="43f4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lp lq lr ls b">CookieStealer</code>拿走了他储藏室里的饼干，而<em class="lo">认为</em>他侥幸逃脱了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3cda" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">他一点也不知道他被超人骗了，那些是假饼干！<code class="fe lp lq lr ls b">george</code>多亏了<code class="fe lp lq lr ls b">Proxy</code>的力量将他从邪恶的黑暗中拯救出来，他的饼干仍然完好无损:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="3c5a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="3f4e" class="pw-post-body-paragraph ks kt iq ku b kv ml jr kx ky mm ju la lb mn ld le lf mo lh li lj mp ll lm ln ij bi translated">我希望这有助于阐明代理模式，以及如何使用JavaScript中现在内置的<code class="fe lp lq lr ls b">Proxy</code>类来利用这一概念。</p><p id="8b7a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这篇文章到此结束:)我希望这篇文章对你有所帮助，并确保在以后的文章中关注我！</p><p id="fa36" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="lo">更多内容看</em> <a class="ae ms" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="lo">说白了就是</em> </strong> </a> <em class="lo">。报名参加我们的</em> <a class="ae ms" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="lo">免费每周简讯</em> </strong> </a> <em class="lo">。关注我们</em> <a class="ae ms" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="lo">推特</em> </strong> </a> <em class="lo">和</em><a class="ae ms" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"><em class="lo">LinkedIn</em></strong></a><em class="lo">。加入我们的</em> <a class="ae ms" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="lo">社区不和谐</em> </strong> </a> <em class="lo">。</em></p></div></div>    
</body>
</html>