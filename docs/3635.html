<html>
<head>
<title>Process Management in Node.js with PM2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PM2实现Node.js中的进程管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/process-management-in-node-js-with-pm2-ca32d75c94af?source=collection_archive---------3-----------------------#2022-09-13">https://javascript.plainenglish.io/process-management-in-node-js-with-pm2-ca32d75c94af?source=collection_archive---------3-----------------------#2022-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9d07673dcb1d1f9e6546db82229cf51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-GnittiWC5k3C20rCFFCg.png"/></div></div></figure><p id="822d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Node.js非常擅长处理I/O操作，但是当涉及到CPU密集型任务时，它就不行了。您可以通过运行繁重的操作来轻松地停止应用程序，因为Node.js是单线程的，它将阻塞进一步的请求。</p><p id="878e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，为了处理这个问题，您可以与主进程并行地产生子进程，这样每当有新的请求进来时，它就会被这个新的进程处理。Node.js中的native cluster模块允许您手动<strong class="jx io"><em class="kt"/></strong><em class="kt"/>配置您的应用程序以生成子进程的集群。但是如果有一个为你处理它的软件包不是更好吗？</p><p id="dc15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PM2是一个进程管理器，负责处理从处理多个进程、设置特定于环境的部署策略到将日志保存到您的系统中的所有事情。这是一个功能丰富的库，在Node.js社区中很受欢迎，这篇博文将介绍其中的一些关键特性。所以让我们开始吧！</p><p id="39ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在YouTube上也有这篇文章的视频版本，一定要看看。  </p><h2 id="e5d7" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">基本设置</h2><p id="63f0" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">要在你的系统上安装它，你可以输入<code class="fe lt lu lv lw b">npm i -g pm2</code>。最好是全局安装，这样可以直接在命令行使用pm2。我们将使用一个简单的具有单一端点的express应用程序。因此，在一个空目录中，首先通过键入<code class="fe lt lu lv lw b">npm init -y</code>创建您的节点项目。之后，你可以通过输入<code class="fe lt lu lv lw b">npm i express</code>来安装express。现在，创建一个名为<strong class="jx io"> main.js </strong>的文件，并将这段代码片段复制到文件中。</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="5600" class="kv kw in lw b gy mf mg l mh mi">const app = require("express")()<br/>app.get("/light", (req, res) =&gt; {<br/>   console.log("Light request triggered")<br/>   res.send(`Request successful!\n`);<br/>})</span><span id="c58a" class="kv kw in lw b gy mj mg l mh mi">app.listen(3000, () =&gt; console.log("Listening to port 3000"));</span></pre><p id="9139" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在通常我们会使用<code class="fe lt lu lv lw b"><strong class="jx io">node main.js</strong></code>来运行我们的应用程序，但是现在我们使用pm2，我们可以使用<code class="fe lt lu lv lw b"><strong class="jx io">pm2 start main.js</strong></code>。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/81df92128b6ad7da2dd0b28bc1abd323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMmSV9q_un3VUHo_bPfNeg.png"/></div></div></figure><p id="3466" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个表显示了名称/id、CPU/内存消耗以及运行应用程序的进程的状态等详细信息。您还可以选择使用<code class="fe lt lu lv lw b">name</code>标志显式地为您的流程提供一个名称。如果你不给它一个明确的名字，它将使用文件名作为进程的名字。</p><p id="1b79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在在截图中，看起来应用程序已经停止。在牌桌前，您会看到“完成”消息，但在牌桌后，您什么也看不到。但是如果你打开浏览器，进入<a class="ae ku" href="http://localhost:3000/light," rel="noopener ugc nofollow" target="_blank">http://localhost:3000/light，</a>你会看到我们从API端点发回的“请求成功”消息。因此应用程序仍在运行。只是pm2对它进行了守护，本质上意味着它在后台运行进程，仅此而已。您将在一个单独的日志文件中找到日志消息，我们将在这篇博客文章的后面部分查看这个日志文件。</p><h2 id="f630" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">流程管理命令</h2><ul class=""><li id="64e3" class="ml mm in jx b jy lo kc lp kg mn kk mo ko mp ks mq mr ms mt bi translated">在任何时候，您都可以通过输入<code class="fe lt lu lv lw b">pm2 status</code>或<code class="fe lt lu lv lw b">pm2 ls</code>或<code class="fe lt lu lv lw b">pm2 list</code>来查看流程的状态。</li><li id="397b" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">您可以通过使用<code class="fe lt lu lv lw b">pm2 stop</code>后跟进程的名称或id(<code class="fe lt lu lv lw b">pm2 stop main</code>或<code class="fe lt lu lv lw b">pm2 stop 0</code>)来停止进程。也可以使用<code class="fe lt lu lv lw b">pm2 stop all</code>停止所有进程。一旦你停止了你的进程，试着向你的应用程序发出一个请求，看看它是否工作。附言:不应该。</li><li id="4b70" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><code class="fe lt lu lv lw b">pm2 delete</code>后跟进程的名称或id将那个进程从列表中删除。(<code class="fe lt lu lv lw b">pm2 delete main</code>或<code class="fe lt lu lv lw b">pm2 delete 0</code>)。您也可以使用<code class="fe lt lu lv lw b">pm2 delete all</code>删除所有进程。</li><li id="3311" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">还有两个命令可以帮助您管理流程。一个是<code class="fe lt lu lv lw b">restart</code>命令，另一个是<code class="fe lt lu lv lw b">reload</code>命令。这两个命令本质上都是重新运行一个进程，但区别在于它们是如何执行的。</li><li id="35de" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">A <code class="fe lt lu lv lw b">pm2 restart &lt;process_name/ID&gt;</code>将首先终止进程，然后再次启动它。因此，当您重新启动一个流程时，会有一些停机时间。</li><li id="6358" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">另一方面，<code class="fe lt lu lv lw b">pm2 reload &lt;process_name/ID&gt;</code>将在后台创建一个新进程。只有当这个新进程被创建时，它才会杀死旧进程。这确保了在重新加载流程时不会停机。如果由于某种原因重新加载不起作用，在特定的时间后，它最终会退回到经典的重新启动。</li></ul><h2 id="ec8c" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">热重装</h2><p id="a2d2" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">当使用Node.js运行应用程序时，每次对应用程序进行更改时，都需要重新启动服务器。<a class="ae ku" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank"> Nodemon </a>是一个流行的库，它会在检测到变化时重启服务器。您可以在pm2中使用<code class="fe lt lu lv lw b">watch</code>标志实现同样的事情。因此，在启动任何进程时，如果您在最后提供了watch标志，它将侦听更改，然后自动重启服务器(<code class="fe lt lu lv lw b">pm2 start main.js --watch</code>)</p><h2 id="bbd2" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">一些其他启动选项</h2><ul class=""><li id="36c0" class="ml mm in jx b jy lo kc lp kg mn kk mo ko mp ks mq mr ms mt bi translated"><strong class="jx io">max-memory-restart&lt;200 MB&gt;—</strong>该选项将在进程达到某个内存限制时重启进程。您可以用千字节(K)、兆字节(M)或千兆字节(G)来指定内存限制</li><li id="2c02" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><strong class="jx io"> log &lt;文件路径&gt; </strong> — Log将指定您要在其中存储应用程序日志的文件。尝试启动一个进程，但这一次，在日志文件的末尾使用日志标志。<br/> <code class="fe lt lu lv lw b">pm2 start main.js --log ./logFile.txt</code> <br/>现在，如果你向light端点发出一个请求，你会看到在你的项目文件夹中自动生成一个名为logFile.txt的文件。</li><li id="841a" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><strong class="jx io">重启-延迟&lt;毫秒延迟&gt; </strong>将在自动重启之间增加一个延迟。</li><li id="4897" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><strong class="jx io">时间</strong>标志将为您的所有日志添加时间戳。重新启动你的应用程序，但这一次在末尾附加时间标志。<code class="fe lt lu lv lw b">pm2 restart 0 --time</code>。现在向端点发出一个请求，您将看到日志文件中记录的消息之前的时间戳。</li><li id="7a6a" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><strong class="jx io">否-自动重启</strong>将禁用自动重启。当您希望执行一次性脚本，并且不希望进程管理器在脚本完成运行后重新启动脚本时，这是有意义的。</li><li id="f3dc" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><strong class="jx io"> cron </strong>标志将根据您添加的cron表达式间隔重新启动进程。<a class="ae ku" href="https://youtu.be/LmDw-nbVLQk?t=350" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">我有一个单独的视频详细讲解了cron的表情，想了解更多的可以去看看。</em> </strong> </a></li><li id="3ab4" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">无守护进程标志不会妖魔化你的pm2进程。因此，您现在可以在控制台上看到所有日志和事件，而不是在后台运行它，就像在典型的节点执行中一样。</li></ul><p id="c722" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们在启动时或重启一个进程时手动添加这些选项是没有意义的。相反，我们要做的是添加一个包含所有这些选项的配置文件，这样无论何时我们启动应用程序，它都会在启用这些选项的情况下运行。</p><h2 id="edf8" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">创建pm2配置文件</h2><p id="b1d9" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">要生成这个配置文件，在您的控制台中键入<code class="fe lt lu lv lw b">pm2 init simple</code>。这将创建一个名为ecosystem.config.js的文件。如果您正在创建自己的配置文件，请确保它以<code class="fe lt lu lv lw b">.config.js</code>结尾，以便PM2能够将其识别为配置文件。在文件内部，复制以下代码片段。</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="7146" class="kv kw in lw b gy mf mg l mh mi">module.exports = {<br/>  apps: [{<br/>    name : "app",<br/>    script: "./main.js",<br/>    watch: true,<br/>    ignore_watch : "node_modules",<br/>    time: true,<br/>    out_file : "./scripts.txt",<br/>    error_file : "./error.txt",<br/>    env: {<br/>      "NODE_ENV": "development"<br/>    },<br/>    env_production: {<br/>      "NODE_ENV": "production",<br/>    }<br/>  }]<br/>}</span></pre><p id="c1b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将解释我们在这里使用的选项。</p><ul class=""><li id="8d46" class="ml mm in jx b jy jz kc kd kg mz kk na ko nb ks mq mr ms mt bi translated">名称:流程的名称</li><li id="9cbd" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">脚本:要执行的脚本的位置</li><li id="0e29" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">观察:跟踪变化并重新开始过程</li><li id="1522" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">ignore_watch:不会跟踪一组文件/文件夹的更改</li><li id="ca12" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">时间:会将时间戳附加到日志文件中的日志语句</li><li id="004f" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">out_file和error_file:将各自的日志语句添加到这些文件中</li></ul><p id="1c82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以添加特定于环境的选项，例如，如果您的环境变量值在测试和生产模式之间发生变化，您可以分别在<code class="fe lt lu lv lw b">env</code>或<code class="fe lt lu lv lw b">env_production</code>中添加这些变量。</p><p id="2323" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们切换到集群模式时，我们将添加一些额外的选项，但是现在，这看起来不错。</p><p id="e469" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以运行配置文件(<code class="fe lt lu lv lw b">pm2 start ecosystem.config.js</code>)而不是使用<code class="fe lt lu lv lw b">pm2 start main.js</code>，它将依次为我们运行脚本。您可以在apps数组中添加多个非Node.js应用程序，它仍然可以工作。pm2并不仅仅局限于Node.js，你可以用不同的语言运行一个进程，比如python，比如使用PM2。</p><p id="b74c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们对pm2有了一点了解，让我们看看它是如何帮助管理多个流程的。在配置文件中，添加两个额外的选项:exec_mode和instances。</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="2c53" class="kv kw in lw b gy mf mg l mh mi">module.exports = {<br/>  apps: [{<br/>    name : "app",<br/>    script: "./main.js",<br/>    watch: true,<br/>    ignore_watch : "node_modules",<br/>    time: true,<br/>    <strong class="lw io">exec_mode:"cluster",<br/>    instances:"max",</strong><br/>    out_file : "./scripts.txt",<br/>    error_file : "./error.txt",<br/>    env: {<br/>      "NODE_ENV": "development"<br/>    },<br/>    env_production: {<br/>      "NODE_ENV": "production",<br/>    }<br/>  }]<br/>}</span></pre><p id="ec2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您想要为您的应用程序启动一个进程集群时，您需要将exec_mode设置为“cluster”。默认设置为“fork”。</p><p id="ab1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当建立一个集群时，您需要提到您将需要多少流程实例。您可以通过<strong class="jx io"> 0/max </strong>，这将加速与您系统中内核数量相等的进程。<strong class="jx io"> -1 </strong>将比最大值少旋转1，如果你传入任何其他数字，它将旋转那么多进程。</p><p id="b85e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果您运行配置文件，您将看到许多进程同时运行(在我的例子中是8个，因为我有一个8核系统)。您还会注意到，执行模式已经更改为“集群”。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/9fc76ddd7619af9e2f724c29429dea43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*if9u6zqYKquhq12zWwsx1A.png"/></div></div></figure><p id="b6f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PM2有一个先进的仪表板，让您监控您的过程。您可以运行您的配置文件，然后使用<code class="fe lt lu lv lw b">pm2 monit</code>命令打开这个仪表板。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/21c6f90011cab1049467c71485664019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOtX7A8hvSSF1z71lTN0nQ.png"/></div></div></figure><p id="ea21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它为您提供了所有流程的更实时视图。您可以单独检查系统中每个进程的资源消耗和分配情况。还有一个日志部分，你可以实时跟踪你所有的日志。</p><h2 id="a2c7" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">结论</h2><p id="07b2" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">好了，这篇博文到此为止。这是对pm2及其便利特性的简要概述。很明显还有更多。我并没有真正讨论任何可以用pm2实现的部署策略，这本身就是一个全新的话题。也许在将来，我会为此写一篇单独的博文，但是这篇博文只是为了演示我们如何使用pm2来自动化流程管理。</p><p id="7e6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ku" href="https://www.youtube.com/watch?v=od6BPZWx6yc&amp;ab_channel=AkileshRao" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">我在Youtube上也有这篇文章的视频版本，你可以去看看。</em> </strong> </a></p><p id="edc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章是我们研究Node.js中多任务处理的系列文章的一部分。</p><ul class=""><li id="0b13" class="ml mm in jx b jy jz kc kd kg mz kk na ko nb ks mq mr ms mt bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/multitasking-in-node-js-with-child-process-d82841fd8d29"><strong class="jx io">node . js中的多任务处理带子进程</strong> </a></li><li id="c283" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/multitasking-in-node-js-with-the-cluster-module-ee8480208f86"> <strong class="jx io">使用集群模块</strong> </a>在Node.js中进行多任务处理</li></ul><p id="a85e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你有任何疑问或建议，你可以在评论中提出，或者通过我的任何一个社交网站与我联系。干杯！</p><p id="df89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ku" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/><a class="ae ku" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae ku" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae ku" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">GitHub</a></p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="372d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容请看</em><a class="ae ku" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">plain English . io</em></strong></a><em class="kt">。报名参加我们的</em> <a class="ae ku" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">免费周报</em> </strong> </a> <em class="kt">。关注我们关于</em><a class="ae ku" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">Twitter</em></strong></a><a class="ae ku" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">LinkedIn</em></strong></a><strong class="jx io"><em class="kt"/></strong><a class="ae ku" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">YouTube</em></strong></a><strong class="jx io"><em class="kt">，以及</em></strong><em class="kt"/><a class="ae ku" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">不和</em> </strong> </a>  <em class="kt">对成长黑客感兴趣？检查</em> <a class="ae ku" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">电路</em> </strong> </a> <strong class="jx io"> <em class="kt">。</em> </strong></p></div></div>    
</body>
</html>