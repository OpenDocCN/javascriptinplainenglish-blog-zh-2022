# “状态是硬的”React 中在哪里处理状态？

> 原文：<https://javascript.plainenglish.io/state-is-hard-where-to-handle-state-in-react-75c18ec5c6f?source=collection_archive---------6----------------------->

![](img/e9255571f169e835c201f294b90363e2.png)

Photo by [Coffee Geek](https://unsplash.com/@coffeegeek?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/compare?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

当我们编写软件时，最大的问题之一是我们应该如何处理状态？用户需要填写表单并更新字段。数据，也就是状态，应该保存在一个对象中还是由一个库来管理，以便我们在其他地方也能容易地访问它？还是应该用输入字段的值在 DOM 中反映状态？

当数据被发送到服务器时，我们如何处理持久性？我们应该使用关系数据库还是一些新奇的 NoSQL 数据库？更重要的是:我们如何处理来自多个用户的 it 突变？

在一些框架的帮助下，这些问题中的许多都为我们解答了，我们可以继续前进了。像 [Rails](https://rubyonrails.org/) 、 [Django](https://www.djangoproject.com/) 或 [Laravel](https://laravel.com/) 这样的后端框架正在为我们处理大量的数据库问题。如何解决前端的状态管理？

当我们使用 React 时，许多问题都没有答案，直到我们花时间去解决它们，因为 React 非常简单。当我们这样做时，我们应该考虑不同种类的状态:本地状态和全局状态。

# 我说的局部状态和全局状态是什么意思？

区别很简单:全局状态是可能呈现在 UI 中不同区域的数据。有时，这些数据可能会通过不同的表单进行更新。而且通常情况下，一些 UI 组件会根据特定的状态显示一些图标/徽章或其他东西。脸书、LinkedIn 或其他网络应用程序中的“*收到新消息*”图标就是一个很好的例子。根据经验，我们从服务器获取的所有东西都应该被认为是一个全局状态。

另一方面，本地状态是表示 UI 如何显示的数据，或者是易变的数据，即非持久的数据。例如，对于嵌套模式对话框组件，它是对话框是否打开的标志。或者，它可以是决定某些表单域是否可见的逻辑。通常情况下，这种状态依赖于全局状态，并且可能是从全局状态派生出来的。

# 我们应该区分这两种类型的国家吗？

在一些架构中，著名的是榆树架构，每个状态都是全局的。如果开发人员确保表示状态的数据结构是有效的，这就很好。对我个人来说，我觉得 JavaScript 有点令人困惑，但是 Elm 可以很容易地设置一个类型来表示您需要的所有内容，而不会迷失在细节中。

# 为什么我们不应该处理组件内部的状态呢？

迟早你**将**不得不对不同组件中的一些状态变化做出响应，实现通知系统将会让你非常头疼。

如果一个数据非常重要，以至于我们需要持久化它，我们可能希望在许多组件中使用它。当我们这样做时，我们在这些组件之间创建了一个紧密的耦合，为了解耦它们，我们创建了一个每个人都可以访问的全局*数据存储*。因此，我们在某种程度上创建了这些组件所依赖的接口，而不是实际的实现。js 以这种方式处理状态管理，效果很好。

我们有两个选择，将数据放在哪里以使其可用。我们可以使用 React 上下文或状态管理库，如反冲或 Redux。

# 什么时候我们应该为一个状态使用上下文？

一个上下文有一个很大的优势，那就是它包含在 React out of the box 中。文档很棒，概念很容易理解，API 也很容易使用。但是，用例是有限的！当上下文保存的数据不会改变或者至少不会经常改变时，应该使用上下文。为什么会这样呢？因为当上下文*中的数据改变时，无论组件是否依赖于数据，所有的*子组件都将被重新呈现。因此，如果我们对变化很大的数据使用上下文，就会产生性能瓶颈。

一个上下文很好的用例是陈述许多子组件所依赖的，因此我们必须使用适当的钻取。当这种状态改变时，子组件无论如何都必须重新呈现，因为它们实际上依赖于数据。

对于所有其他数据，我们应该考虑使用状态管理库。

# React 中的状态管理选项

状态管理库在 React 中有很长的历史。例如，Redux 于 2015 年发布，仅比 React 本身的发布晚了两年。Redux 的灵感来源于茶。

最近，[反冲](https://recoiljs.org/)也设法创造了一些牵引力。反冲与 React 集成得非常好，因为它也是由脸书开发的，他们利用了现代 React 功能，如[挂钩](https://reactjs.org/docs/hooks-intro.html)。

有了这些库，当然也可以使用本地状态。我们可以在组件中使用`useState`钩子。

# 结论

国家管理一直很难。但是，在像反冲这样的库的帮助下，以及我们这方面的一点前瞻性思维，这变得更加容易。我们现在有了创建架构良好的 web 应用程序的所有选项，同时依赖于经过验证的工具，我们不必自己发明这些工具。

当然，处理数据的存储必须被导入以实际使用它。这类似于访问一个上下文或另一个组件。

附注:首先，你应该收到我的邮件。 [***你可以在这里做！***](https://grnt-grdwhl.medium.com/subscribe) *其次，如果你喜欢体验媒介的自己，可以考虑通过报名成为会员* *来支持我和其他成千上万的作家* [***。每月只需 5 美元，你也有机会通过写作赚钱。通过这个链接***](https://grnt-grdwhl.medium.com/membership) *报名* [***，你就直接用你的一部分费用支持我，不会多花你多少钱。如果你这样做了，万分感谢！***](https://grnt-grdwhl.medium.com/membership)

*更多内容请看*[***plain English . io***](https://plainenglish.io/)*。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。关注我们*[***Twitter***](https://twitter.com/inPlainEngHQ)*和*[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*。加入我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *。*