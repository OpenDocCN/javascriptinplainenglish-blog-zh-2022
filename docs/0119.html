<html>
<head>
<title>Run JavaScript Code One Magnitude Faster Using WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WebAssembly将JavaScript代码运行速度提高一个数量级</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/run-javascript-code-one-magnitude-faster-using-webassembly-448d470eb77d?source=collection_archive---------1-----------------------#2022-01-08">https://javascript.plainenglish.io/run-javascript-code-one-magnitude-faster-using-webassembly-448d470eb77d?source=collection_archive---------1-----------------------#2022-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="702c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">耗时50秒的JavaScript </em>代码在<em class="kc"> Rust </em>中被重新编码，并转换成<em class="kc"> WebAssembly </em>注入回<em class="kc"> JavaScript中，在7秒内运行。</em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/3beefbac6a03020d59b36a4279f63da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gdU0jYwPcae0H9kW"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4d09" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我以为我永远不会把<em class="lq"> JavaScript </em>和<em class="lq">汇编</em>联系起来。我想，当然。因为在我看来，<em class="lq"> JavaScript </em>是一种脚本语言，现在它确实运行得很快，但是我还没有把它用在比web开发更重要的事情上。最近在研究一些路径查找问题时，我遇到了一种情况，一段JavaScript代码可能要运行50秒才能找到解决方案。这个问题的结构相当复杂，而且是面向算法的，但是我将在下面几行中分享代码的基本结构:</p><pre class="ke kf kg kh gt lr ls lt lu aw lv bi"><span id="687e" class="lw lx in ls b gy ly lz l ma mb">const <strong class="ls io">buildMaze</strong> = (data) =&gt; {<br/>  ...  <br/>  return { maze, startPos, numKeys }<br/>}</span><span id="f57f" class="lw lx in ls b gy mc lz l ma mb">const <strong class="ls io">findMazeKeys</strong> = (maze, srcPos, keysTaken) =&gt; {<br/>  ...  <br/>  return dests<br/>}</span><span id="192a" class="lw lx in ls b gy mc lz l ma mb">const <strong class="ls io">findMazeSteps</strong> = (maze, startPos, numKeys) =&gt; {<br/>  const <strong class="ls io">minMazeSteps</strong> = (srcPos, keysTaken) =&gt; { <br/>    ...<br/>    return memo[memoKey]<br/>  }<br/>  <br/>  let memo = {}, usage = 0, actual = 0<br/>  return <strong class="ls io">minMazeSteps</strong>(startPos, [])<br/>}</span><span id="e192" class="lw lx in ls b gy mc lz l ma mb">function World(data) {<br/>  const { maze, startPos, numKeys } = <strong class="ls io">buildMaze</strong>(data)<br/>  return <strong class="ls io">findMazeSteps</strong>(maze, startPos, numKeys)<br/>}</span></pre><p id="f96a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在上面的代码中，我在突出显示函数名的同时省略了所有的细节。其中一个函数<code class="fe md me mf ls b">minMazeSteps</code>在另一个函数的闭包内递归使用。运行时间主要花在函数<code class="fe md me mf ls b">findMazeKeys</code>上，这是一个普通的基于迭代的函数。</p><h2 id="3dd9" class="lw lx in bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">使用的低级语言，<em class="kc">铁锈</em></h2><p id="4b2f" class="pw-post-body-paragraph ku kv in kw b kx mx jo kz la my jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">由于缺乏更好的词来描述我的基本原理，我首先想看看一种更低级的语言，如<em class="lq"> C++ </em>能否做到，在这种情况下，我选择了<em class="lq"> Rust </em>，因为它最近引起了很多关注。我不得不承认我对此没有多少经验。翻译这段代码花了我不少时间。这么说吧，我重写了它，而不是移植它，因为我真的不知道如何将JavaScript移植到Rust。</p><pre class="ke kf kg kh gt lr ls lt lu aw lv bi"><span id="396b" class="lw lx in ls b gy ly lz l ma mb">use std::collections::HashMap;</span><span id="e14e" class="lw lx in ls b gy mc lz l ma mb">#[derive(Debug,Hash,PartialEq,Eq,Copy,Clone)]<br/>struct <strong class="ls io">Pos</strong>(i8, i8);</span><span id="d88c" class="lw lx in ls b gy mc lz l ma mb">type <strong class="ls io">CharMat</strong> = Vec&lt;Vec&lt;char&gt;&gt;;<br/>type <strong class="ls io">MemoHash</strong> = HashMap&lt;String, usize&gt;;</span><span id="625b" class="lw lx in ls b gy mc lz l ma mb">struct <strong class="ls io">Maze</strong> {<br/>  mat: CharMat,<br/>  origin: Pos,<br/>  keys_len: usize,<br/>  memo: MemoHash,<br/>  usage: usize,<br/>  actual: usize<br/>}</span><span id="10ce" class="lw lx in ls b gy mc lz l ma mb">impl <strong class="ls io">Maze</strong> {<br/>  fn <strong class="ls io">new</strong>(strs: &amp;str) -&gt; Maze {<br/>    ...      <br/>    Maze {<br/>      mat,<br/>      origin,<br/>      keys_len,<br/>      memo: HashMap::new(),<br/>      usage: 0,<br/>      actual: 0<br/>    }<br/>  }<br/>  <br/>  fn <strong class="ls io">locate_keys</strong>(<br/>    &amp;self, p: &amp;Pos, keys: &amp;Vec&lt;char&gt;<br/>  ) -&gt; Vec&lt;(char, Pos, usize)&gt; {<br/>    ...<br/>    dest<br/>  }<br/>   <br/>  fn <strong class="ls io">min_steps</strong>(<br/>    &amp;mut self, p: &amp;Pos, keys: &amp;Vec&lt;char&gt;<br/>  ) -&gt; usize { <br/>    ...<br/>    steps<br/>  }<br/>  <br/>  fn <strong class="ls io">solve</strong>(&amp;mut self) -&gt; usize {<br/>    let o = self.origin.clone();<br/>    self.<strong class="ls io">min_steps</strong>(&amp;o, &amp;vec![]);<br/>  }<br/>}</span></pre><p id="6b77" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Rust版本相对来说更加结构化，因为它有定义明确的类型，比如T2。所有的函数都是围绕struct <code class="fe md me mf ls b">Maze</code>实现的简单的类方法。没有涉及到闭包，因为我不能像JavaScript那样成功地实现它。最后，我得出结论，两种语言中的闭包只是不同，所以我放弃了这个端口。</p><p id="a60e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果你一直关注这篇文章，我会告诉你第一个发现。令人震惊的是<strong class="kw io"><em class="lq">Rust</em>版本的代码耗时5秒而不是<em class="lq"> JavaScript </em>版本</strong>的50秒，因此有大约一个数量级的差异。对我来说，生锈的版本更难写。</p><h2 id="f9cb" class="lw lx in bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">加速高级语言JavaScript</h2><p id="38e7" class="pw-post-body-paragraph ku kv in kw b kx mx jo kz la my jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">虽然我对结果感到震惊，但我也很兴奋地看到是否有任何地方我可以改进我的<em class="lq"> JavaScript </em>以提高性能。实际上我很兴奋，因为我认为我找到了一个金蛋来帮助我提高JavaScript技能。</p><p id="3f58" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我走了几个方向:<strong class="kw io"> a) </strong>闭包<strong class="kw io"> b) </strong>递归<strong class="kw io"> c) </strong>向量分配。信不信由你，我在消除闭包、递归以及向量过度分配的基础上重写了几次JavaScript版本。毫无疑问，我还可以尝试更多的东西，但是我越是尝试，就越是发现我写的初始代码在性能方面相当不错。经过上述优化后，我可以将它从50秒提高到40秒，但仅此而已。我根本推不进30秒范畴！</p><p id="53f5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">总之NodeJS引擎真的很快。<strong class="kw io">如果循环的幅度小于</strong> <code class="fe md me mf ls b"><strong class="kw io">100,000</strong></code> <strong class="kw io">，你写代码的方式没多大关系。</strong>引擎优化应该能很好的覆盖你。当经营规模超过<code class="fe md me mf ls b">100,000</code>时，肯定会有明显的不同。我对速度很满意，虽然我想看看我是否能让它跑得更快。这也解释了为什么我现在看不到JavaScript有那么慢，因为它没那么慢。考虑到我可以用来公式化和编码算法的速度，<em class="lq"> JavaScript </em>绝对不在慢的范畴。经过这次练习，我确信这一点。</p><h2 id="67c0" class="lw lx in bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">满足50年代和5s之间的差距，WebAssembly</h2><p id="a33f" class="pw-post-body-paragraph ku kv in kw b kx mx jo kz la my jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我有点痴迷于我自己的<code class="fe md me mf ls b">Maze</code>。为了继续寻找差距，我去了不同的方向，而不是证明为什么<em class="lq"> Rust </em>版本快。如果组装更快，那么我会选择组装。于是我挑了几本书，发现有个叫<em class="lq"> WebAssembly </em>的东西，可以让你把汇编代码注入<em class="lq"> JavaScript </em>。事实证明<em class="lq"> Rust </em>支持一个构建目标<code class="fe md me mf ls b">wasm32</code>。我跟着一个网上的<a class="ae kt" href="https://rustwasm.github.io/book/introduction.html" rel="noopener ugc nofollow" target="_blank">教程</a>，把<em class="lq">锈</em>版本抄了过来。然后调用<em class="lq"> JavaScript </em> <code class="fe md me mf ls b">index.js</code>文件中导入的方法:</p><pre class="ke kf kg kh gt lr ls lt lu aw lv bi"><span id="5474" class="lw lx in ls b gy ly lz l ma mb">import * as wasm from "world-interpretation"<br/>console.log(wasm.<strong class="ls io">run</strong>())</span></pre><p id="dbae" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Wola，<em class="lq"> JavaScript </em>版本现在在7秒内运行。虽然不像纯<em class="lq">锈</em>那样5秒，但也差不多了。此外，导入的组装函数与基本函数一样简单，只是所有的子函数都被命名为类似于<code class="fe md me mf ls b">wasm-function[2]</code> ( <strong class="kw io"> min_steps </strong>)的名称。在我们的例子中，这个函数是高度递归的，正如您在performance选项卡中看到的，花费了1.6秒。最昂贵的函数<code class="fe md me mf ls b">wasm-function[48]</code> ( <strong class="kw io"> locate_keys </strong>)现在只需要2.3秒，而最初的<em class="lq"> JavaScript </em>版本需要16秒。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi nc"><img src="../Images/e5d9132afe0dba75a4cecde66db25a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbeRuRmIhOOV6KA9yUKhqA.png"/></div></div></figure><h1 id="cb85" class="nd lx in bd mg ne nf ng mj nh ni nj mm jt nk ju mp jw nl jx ms jz nm ka mv nn bi translated">摘要</h1><p id="d024" class="pw-post-body-paragraph ku kv in kw b kx mx jo kz la my jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">一段耗时约50秒的<em class="lq"> JavaScript </em>代码在<em class="lq"> Rust </em>中被重新编码，并转换成一个<em class="lq"> WebAssembly </em>注入回<em class="lq"> JavaScript </em>。在浏览器中运行的最终版本需要7秒，因此在这个繁重的练习中获得了一个数量级的差异。</p><p id="a35d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">更多内容看</em> <a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">说白了就是</em> </a> <em class="lq">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">免费每周简讯</em> </a> <em class="lq">。在我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="lq">社区不和谐</em> </a> <em class="lq">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>