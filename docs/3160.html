<html>
<head>
<title>99% of Beginners Do Not Understand the Difference Between ‘for’ Loops &amp; ‘forEach’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">99%的初学者不明白“for”循环和“forEach”之间的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/99-of-beginners-do-not-understand-the-difference-between-for-loops-foreach-6cb0bc375595?source=collection_archive---------2-----------------------#2022-08-05">https://javascript.plainenglish.io/99-of-beginners-do-not-understand-the-difference-between-for-loops-foreach-6cb0bc375595?source=collection_archive---------2-----------------------#2022-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2aae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们详细看看“for”和“forEach”的区别。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8114d39c70f75acfbb34f4223c5b09a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HUNqyS6izId7q09HI8KHw.jpeg"/></div></div></figure><p id="9451" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">我们先来看本质区别:</strong></p><p id="f0b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“for”循环从JavaScript开始就存在了。ES5中引入的‘forEach’是挂载在可迭代对象的原型上的，比如数组集合映射。</p><p id="d9fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">‘forEach’</strong>是负责遍历可迭代对象的迭代器。那么什么是遍历、迭代和可迭代对象呢？这个稍微详细一点，留给大家自己回顾。</p><p id="7a61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">知道' forEach '其实是一个迭代器，它和' for '循环的本质区别在于' forEach '负责遍历(数组集合映射)可迭代对象，而' for '循环是一个循环机制，但是它可以通过它遍历一个数组。</p><p id="4091" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">解释:</strong>什么是迭代器？这里，发电机作为一个例子。当它被调用时，会生成一个迭代器对象(iterator object)。它有一个. next()方法，每次调用返回一个对象{value:value，done:Boolean }，value返回yield后的返回值，yield结束时，done变为true，通过依次调用和迭代访问内部值。</p><p id="62bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">迭代器是一种特殊的对象。在ES6规范中，它的标志是返回对象的next()方法，迭代行为判断为done。迭代器实现遍历而不公开内部表示。参见代码:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="c507" class="ls lt iq lo b gy lu lv l lw lx">let arr = [4, 5, 6, 7]</span><span id="9f2e" class="ls lt iq lo b gy ly lv l lw lx"> let iterator = arr[Symbol.iterator]()</span><span id="30a1" class="ls lt iq lo b gy ly lv l lw lx"> console.log(iterator.next());</span><span id="b45d" class="ls lt iq lo b gy ly lv l lw lx"> console.log(iterator.next());</span><span id="4895" class="ls lt iq lo b gy ly lv l lw lx"> console.log(iterator.next());</span><span id="c08a" class="ls lt iq lo b gy ly lv l lw lx"> console.log(iterator.next());</span><span id="d3f0" class="ls lt iq lo b gy ly lv l lw lx"> console.log(iterator.next());</span></pre><p id="584b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面我们可以看到，只要是iterable对象，调用内部Symbol.iterator就会提供一个迭代器，根据迭代器返回的next方法访问内部，这也是for…of的实现原理。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="9f45" class="ls lt iq lo b gy lu lv l lw lx">let arr = [4, 5, 6, 7]<br/>for (const item of arr) {<br/> console.log(item);<br/>}</span></pre><p id="4432" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">调用next方法返回对象的值并保存在item中直到done为true跳出循环，所有iterable对象都可以被for…of消耗。让我们看看其他可迭代对象:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="3347" class="ls lt iq lo b gy lu lv l lw lx">function num(params) {<br/> console.log(arguments);<br/> let iterator = arguments[Symbol.iterator]()<br/> console.log(iterator.next());<br/> console.log(iterator.next());<br/> console.log(iterator.next());<br/> console.log(iterator.next());<br/> console.log(iterator.next());<br/>}<br/>num(4, 5, 6, 7)</span><span id="c2bb" class="ls lt iq lo b gy ly lv l lw lx">let set = new Set(‘4567’)<br/>set.forEach(item =&gt; {<br/> console.log(item);<br/>})<br/>let iterator = set[Symbol.iterator]()<br/>console.log(iterator.next());<br/>console.log(iterator.next());<br/>console.log(iterator.next());<br/>console.log(iterator.next());<br/>console.log(iterator.next());</span></pre><p id="639c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么我们也可以直观的看到iterable对象中的Symbol.iterator属性在被调用时可以生成一个迭代器，forEach也生成一个迭代器，在内部回调函数中传递每个元素的值。</p><p id="f0a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">描述:我觉得这里调用的是迭代器，连续调用next，给回调函数传递参数。可以在评论区留言，谈谈自己的看法。</strong></p><p id="7cd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“for”循环和“forEach”之间的语法差异:</p><p id="6298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1.forEach的参数。<br/> 2。中断forEach。<br/> 3。forEach删除它自己的元素，并且不能重置索引。<br/> 4。for循环可以控制循环的起点。</p><p id="4380" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">forEach的参数</strong> <br/>让我们了解一下forEach的完整参数内容:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="3e58" class="ls lt iq lo b gy lu lv l lw lx">arr.forEach((self,index,arr) =&gt;{},this)</span></pre><p id="88c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> self: </strong>数组当前遍历的元素。默认情况下，数组元素按从左到右的顺序获取。</p><p id="8744" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> index: </strong>数组当前元素的索引，第一个元素的索引为0，以此类推。</p><p id="41b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> arr: </strong>当前遍历的数组。</p><p id="1c7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">这个:</strong>这个是指回调函数。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="b7c5" class="ls lt iq lo b gy lu lv l lw lx">let arr = [4, 5, 6, 7];<br/>let person = {<br/> name: ‘BOb’<br/>};<br/>arr.forEach(function (self, index, arr) {console.log(`${self} ${index}, ${arr}`);<br/> console.log(this.name+=’high’);<br/>}, person)</span></pre><p id="8998" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用arr来实现阵列重复数据消除:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="895c" class="ls lt iq lo b gy lu lv l lw lx">let arr1 = [4, 5, 4, 6, 4];<br/>let arr2 = [];<br/>arr1.forEach(function (self, index, arr) {<br/> arr1.indexOf(self) === index ? arr2.push(self) : null;<br/>});<br/>console.log(arr2);</span></pre><p id="3a4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> forEach中断</strong><br/>JavaScript中有break-return-continue中断函数或跳出循环。我们会在for循环中使用一些中断行为，这对于优化数组遍历和搜索非常好，但是因为forEach属于迭代器，只能按照顺序遍历完成的顺序进行排序，所以不支持上面的中断行为。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="873c" class="ls lt iq lo b gy lu lv l lw lx"><em class="lz">let arr = [4,5,6,7],<br/>i = 0,<br/>length = arr.length;<br/>for (; i &lt; length; i++) {<br/>console.log(arr[i]);<br/>if (arr[i] === 5) {<br/>break;<br/>};<br/>};</em></span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><pre class="ln lo lp lq aw lr bi"><span id="6bb2" class="ls lt iq lo b gy mh mi mj mk ml lv l lw lx"><em class="lz">arr.forEach((self,index) =&gt; { <br/> console.log(self);<br/> if (self === 5) {<br/> break;<br/> };<br/>});</em></span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><pre class="ln lo lp lq aw lr bi"><span id="b0b8" class="ls lt iq lo b gy mh mi mj mk ml lv l lw lx"><em class="lz">arr.forEach((self,index) =&gt; {</em><em class="lz"><br/></em><em class="lz"> console.log(self);<br/> if (self === 5) {<br/> continue;<br/> };<br/>});</em></span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="3f03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我必须在forEach中跳出循环怎么办？事实上，有一种方法，借助于try/catch:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="80f5" class="ls lt iq lo b gy lu lv l lw lx"><em class="lz">try {<br/> var arr = [4, 5, 6, 7];<br/> arr.forEach(function (item, index) {<br/> if (item ===6 ) {<br/> throw new Error(“LoopTerminates”);<br/> }</em><em class="lz"><br/> <br/></em><em class="lz"> console.log(item);<br/> });<br/>} catch (e) {<br/> if (e.message !== “LoopTerminates”) throw e;<br/>};</em></span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="9cdb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果遇到return，不会报告错误，但不会生效:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="49f5" class="ls lt iq lo b gy lu lv l lw lx"><em class="lz">let arr = [4, 5, 6, 7];</em></span><span id="1956" class="ls lt iq lo b gy ly lv l lw lx"><em class="lz">function find(array, num) {<br/> array.forEach((self, index) =&gt; {<br/> if (self === num) {<br/> return index;<br/> };<br/> });<br/>};<br/>let index = find(arr, 5);</em><br/></span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="029e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> forEach删除自己的元素，index无法重置</strong> <br/>在forEach中，我们无法控制index的值，它只会无意识地递增，直到大于数组的长度，然后跳出循环。因此，不可能通过删除自身来重置索引。让我们看一个简单的例子:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="d287" class="ls lt iq lo b gy lu lv l lw lx"><em class="lz">let arr = [4,5,6,7]<br/>arr.forEach((item, index) =&gt; {<br/> console.log(item);<br/> index++;<br/>});</em></span></pre><p id="6987" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">index在函数体内增加或减少时不会改变。在实际开发中，遍历一个数组同时删除一个项是很常见的。使用forEach删除时要注意。</p><p id="2b4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> for循环可以控制循环的起点<br/> </strong>如上所述，forEach循环的起点在没有人为干预的情况下只能是0，但for循环则不同。</p><p id="0144" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">前面遍历数组删除育种的操作可以写成:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="0fda" class="ls lt iq lo b gy lu lv l lw lx"><em class="lz">let data = [];</em></span><span id="a6b5" class="ls lt iq lo b gy ly lv l lw lx"><em class="lz">let data2 = [1,2,3];</em></span><span id="6782" class="ls lt iq lo b gy ly lv l lw lx"><em class="lz">data2.map(item=&gt;data.push(item));</em><br/><strong class="lo ir"> </strong></span></pre><p id="d2f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">for循环和forEach的性能差异</strong> <br/>在性能比较方面，我们增加了一个map迭代器，它和filter一样，生成一个新的数组。我们比较了for forEach map在浏览器环境中的性能:</p><p id="55a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">性能对比:对于chrome 62和Node.js v9.1.0环境下的&gt;forEach&gt;map</strong><br/>:for循环比forEach快1倍，forEach比map快20%左右。</p><p id="8b4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">原因分析</strong></p><p id="f32d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">for:</strong>for循环没有额外的函数调用栈和上下文，所以它的实现最简单。</p><p id="4bf9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> forEach: </strong>对于forEach，其函数签名包含参数和上下文，所以性能会低于for loop。</p><p id="44ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">map:</strong>map之所以最慢，是因为map返回一个新的数组，数组的创建和赋值会造成内存空间的分配，所以会带来较大的性能开销。如果映射嵌套在循环中，会带来更多不必要的内存消耗。</p><p id="7194" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当使用迭代器遍历数组时，使用map而不返回新数组是违背设计意图的。</p><p id="86c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">感谢您的阅读，期待您的关注。</strong></p><p id="39e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lz">更多内容看</em> <a class="ae mm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lz">说白了就是</em> </strong> </a> <em class="lz">。报名参加我们的</em> <a class="ae mm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lz">免费周报</em> </strong> </a> <em class="lz">。关注我们关于</em> <a class="ae mm" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lz">推特</em></strong></a><a class="ae mm" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lz">领英</em></strong></a><strong class="kt ir"><em class="lz"/></strong><em class="lz">和</em> <a class="ae mm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lz">不和</em> </strong> </a> <strong class="kt ir"> <em class="lz">。</em>T49】</strong></p></div></div>    
</body>
</html>