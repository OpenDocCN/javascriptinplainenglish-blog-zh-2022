<html>
<head>
<title>Understand React Context with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过例子理解反应上下文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-react-context-with-examples-b66b9161d9de?source=collection_archive---------3-----------------------#2022-05-02">https://javascript.plainenglish.io/understand-react-context-with-examples-b66b9161d9de?source=collection_archive---------3-----------------------#2022-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7095" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用React中的上下文创建地址管理React应用程序</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dd6ba8186f7d7524d0a0853151ca2d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9Ejp0F-jAHBkVpf0"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@veeterzy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">veeterzy</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4bd0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您刚刚开始学习React，或者在理解React上下文的概念上有困难，那么这篇文章是为您准备的。当我第一次在React中查看上下文代码时，我也面临类似的困难。在这篇文章中，我们将分解这个主题，并试图使它简单易懂</p><h1 id="66d9" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">什么是语境？</h1><blockquote class="mh mi mj"><p id="e20a" class="kt ku mk kv b kw kx jo ky kz la jr lb ml ld le lf mm lh li lj mn ll lm ln lo ig bi translated">“上下文提供了一种通过组件树传递数据的方式，而不必在每一级手动向下传递属性。”</p></blockquote><p id="e229" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们知道，在单页面应用程序中，用户界面是以树状结构表示的，而在React中，用户界面被分解成不同的组件。</p><p id="2624" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些组件可以表示为一棵树，如下图所示，顶部是根组件(或父组件)，下面是子组件。这种应用程序中的数据流是通过props从上到下(从父到子)的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/3868acae3330c13060d68ceac4951fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*KvTEOsuJEGr0rDHVE47Fpg.png"/></div></figure><p id="5fc0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是这里有一个问题，当一个孩子深深地嵌套在树中并且需要来自根的数据时，那么我们必须将数据传递给它的流中的所有中间组件才能到达那里。</p><p id="3655" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:如上图所示，如果子节点4需要从应用程序访问数据或状态，则需要通过子节点1传递，然后传递给子节点4</p><p id="2542" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着不需要该特定数据的组件将被提供该数据，以便该数据可以在它们之间传递。这种将道具传递给嵌套很深的孩子的问题叫做道具钻取。</p><h1 id="3d44" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">背景如何解决道具训练</h1><p id="3a94" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">使用上下文，我们可以避免通过许多级别传递一些道具，它被设计为共享数据，这些数据可以被认为是React组件树的“全局”数据</p><p id="a4ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着我们不再需要在组件之间传递数据，因为它对于树(或子树)是全局可用的，并且需要数据的子组件可以使用上下文API来访问它</p><h1 id="47bf" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">设置上下文所涉及的步骤</h1><p id="6689" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">第一步是使用React创建一个上下文。<strong class="kv io"> createContext </strong>()函数</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="e449" class="mz lq in mv b gy na nb l nc nd">const ThemeContext = React.createContext('light');</span></pre><p id="1a9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二步是创建一个提供者，并将其包装在将要访问数据的组件/组件树周围</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="57da" class="mz lq in mv b gy na nb l nc nd">&lt;ThemeContext.Provider value="dark"&gt;<br/>   &lt;App /&gt;<br/>&lt;/ThemeContext.Provider&gt;</span></pre><p id="ff5a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，App组件和App中的任何子组件都可以访问ThemeContext中提供的值。使用useContext挂钩的提供程序</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="7d0c" class="mz lq in mv b gy na nb l nc nd">const theme = useContext(<!-- -->ThemeContext<!-- -->);</span></pre><p id="d91d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们通过一个真实的例子(地址管理)来理解，并抽象出上下文API中的某些功能</p><h1 id="b9a4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">地址管理示例</h1><p id="37ee" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">让我们创建一个addressContext.js文件，并从这个文件中导出我们的上下文和提供者</p><p id="da2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">步骤1: </strong>创建上下文</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="d8ea" class="mz lq in mv b gy na nb l nc nd">const AddressContext = createContext();</span></pre><p id="4dfa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">步骤2: </strong>如上所述，消费者使用React的useContext钩子并传递上下文，我希望将它抽象出来，这样我们就不必每次都导入AddressContext并将其传递给钩子</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="2008" class="mz lq in mv b gy na nb l nc nd">const useAddress = () =&gt; {    <br/>  const context = useContext(AddressContext)  <br/>  <br/>  if(!context){        <br/>      throw new Error("Context error")    <br/>   }    </span><span id="6358" class="mz lq in mv b gy ne nb l nc nd">  return context<br/>}</span></pre><p id="aaf6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在在消费者上下文中，我们只需调用useAddress方法并获取结果</p><p id="da57" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">步骤3: </strong>最后一步是设置提供者，现在我希望将它抽象成一个更高阶的组件，这样我就不必导入地址上下文并编写地址上下文。提供更好的可读性</p><blockquote class="mh mi mj"><p id="38ad" class="kt ku mk kv b kw kx jo ky kz la jr lb ml ld le lf mm lh li lj mn ll lm ln lo ig bi translated">“高阶分量是接受一个分量并返回一个新分量的函数”</p></blockquote><p id="7233" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望达到以下结果</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="ac42" class="mz lq in mv b gy na nb l nc nd">&lt;AddressProvider&gt;<br/>  &lt;App /&gt;<br/>&lt;/AddressProvider&gt;</span></pre><p id="aa01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="21c7" class="mz lq in mv b gy na nb l nc nd">&lt;AddressContext.Provider&gt;<br/>  &lt;App /&gt;<br/>&lt;/AddressContext.Provider&gt;</span></pre><p id="7232" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，让我们设置这个高阶组件，在这种情况下，App组件将作为props.children传递给AddressProvider组件，如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="572a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">步骤4: </strong>在设置了提供者(AddressProvider)和消费者(useAddress)之后，我们必须导出这两个函数，然后将提供者包装在需要访问数据的组件上</p><p id="fa26" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，组件树中的任何嵌套组件都能够像全局可用一样访问数据，而无需将其作为适当的使用上下文来传递。</p><p id="c9be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要查看带有API调用的地址管理应用程序的完整实现，您可以查看我的资源库</p><div class="nh ni gp gr nj nk"><a href="https://github.com/Ash-D23/Addressmanagement" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">GitHub-Ash-D23/地址管理</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny km nk"/></div></div></a></div></div><div class="ab cl nz oa hr ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ig ih ii ij ik"><p id="97a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="mk">感谢你一直读到最后，希望这篇文章对你有帮助。请关注我，获取更多此类文章！</em> </strong></p><h1 id="e619" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">参考</h1><div class="nh ni gp gr nj nk"><a href="https://reactjs.org/docs/context.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">上下文反应</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">上下文提供了一种通过组件树传递数据的方法，而不必每次都手动传递属性</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">reactjs.org</p></div></div><div class="nt l"><div class="og l nv nw nx nt ny km nk"/></div></div></a></div><p id="853d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mk">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mk">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mk">免费周报</em> </strong> </a> <em class="mk">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mk">Twitter</em></strong></a><em class="mk">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mk">LinkedIn</em></strong></a><em class="mk">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mk">社区</em> </strong> </a> <em class="mk">。</em></strong></a></p></div></div>    
</body>
</html>