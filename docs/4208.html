<html>
<head>
<title>The Right Way to Use ‘this’ in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中使用“this”的正确方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-right-way-to-use-this-in-javascript-4815cd9e6c65?source=collection_archive---------12-----------------------#2022-11-08">https://javascript.plainenglish.io/the-right-way-to-use-this-in-javascript-4815cd9e6c65?source=collection_archive---------12-----------------------#2022-11-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1361fd41945a1c6e64e1b7d8ece6b64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iO6GDI73cmGcBgQDiXx0uQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Copyright <a class="jz ka ep" href="https://medium.com/u/ffc03660639f?source=post_page-----4815cd9e6c65--------------------------------" rel="noopener" target="_blank">Justin Lee</a></figcaption></figure><p id="c559" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">关键字<strong class="kd io"> <em class="kz">这个</em> </strong>使用频率很高，但是经常会引起很多混淆🤯<em class="kz">。</em>根据它被调用的地方，<strong class="kd io"> <em class="kz">这个</em> </strong>可能成就或者破坏你的编程逻辑<em class="kz">。我们来这里是为了缓解这种困惑。这里我将根据<strong class="kd io"> <em class="kz">这个</em> </strong>最常见的调用来分开:在对象中，在构造函数中<em class="kz">。</em></em></p><blockquote class="la lb lc"><p id="96a7" class="kb kc kz kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky ig bi translated">注意，所有代码输出都是基于我的本地节点终端，在浏览器中，全局对象会指向窗口对象<em class="in">。</em></p></blockquote></div><div class="ab cl lg lh hr li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ig ih ii ij ik"><h1 id="7886" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><em class="ml"> 1。方法调用:<em class="ml">这在一个对象中</em></em></h1><p id="21f6" class="pw-post-body-paragraph kb kc in kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky ig bi translated">在JavaScript中，对象内的<em class="kz">函数被称为<strong class="kd io">方法调用</strong>。在本例中，函数<em class="kz"> fullName() </em>将返回一个包含两个属性(<code class="fe mr ms mt mu b"><em class="kz">first</em></code>和<code class="fe mr ms mt mu b">last</code>)的全名字符串。</em></p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/96b46c11c76981bea888079c9567899f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGhzssGMmAra5u8S4RPepg.png"/></div></div></figure><p id="7435" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">对于方法调用，<em class="kz"> fullName() </em>方法属于<code class="fe mr ms mt mu b"><em class="kz">John</em></code>对象，<code class="fe mr ms mt mu b"><strong class="kd io"><em class="kz">this</em></strong></code> <strong class="kd io">指的是</strong> <code class="fe mr ms mt mu b"><strong class="kd io"><em class="kz">John</em></strong></code>。</p><h2 id="de9b" class="na lo in bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">❌ <em class="ml">不要</em> <strong class="ak"> <em class="ml">在方法调用</em> </strong>中使用箭头函数</h2><p id="6426" class="pw-post-body-paragraph kb kc in kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky ig bi translated">让我们尝试用箭头函数(ES6)语法做同样的事情。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/b58b094241bf0cc0e526ed9c3c341e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsCKLmEQqP6uvxCLeaxzCQ.png"/></div></div></figure><h2 id="57a8" class="na lo in bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">❗️发生了什么事？</h2><p id="8c83" class="pw-post-body-paragraph kb kc in kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky ig bi translated">箭头函数的不同之处在于它遵循<a class="ae nm" href="https://medium.com/@iampika/es6-arrow-functions-syntax-and-lexical-scoping-d061732071e7" rel="noopener">词法</a>范围<em class="kz">。</em>这意味着它继承了其父元素<code class="fe mr ms mt mu b"><em class="kz">Global</em></code>的<code class="fe mr ms mt mu b"><em class="kz">this</em></code>，它在<code class="fe mr ms mt mu b"><em class="kz">John</em></code>对象<em class="kz">之外。</em>现实中你要<code class="fe mr ms mt mu b"><strong class="kd io"><em class="kz">this</em></strong></code> <strong class="kd io">是指</strong> <code class="fe mr ms mt mu b"><strong class="kd io"><em class="kz">John</em></strong></code> <strong class="kd io">而不是</strong> <code class="fe mr ms mt mu b"><strong class="kd io"><em class="kz">Global</em></strong></code> <em class="kz">。</em></p><p id="2671" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">⭐️因此，在方法调用的情况下使用常规函数语法<em class="kz"> fullName() </em>。</p><h2 id="af93" class="na lo in bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">✅在方法调用中使用箭头函数</h2><p id="adbf" class="pw-post-body-paragraph kb kc in kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky ig bi translated">也许我在<em class="kz"> fullName() </em>中添加了一个名为<em class="kz"> combineNames() </em>的函数来连接输入。由于<em class="kz"> fullName() </em>属于<code class="fe mr ms mt mu b"><em class="kz">John</em></code>对象，<em class="kz"> combineNames() </em>里面的<code class="fe mr ms mt mu b"><em class="kz">this</em></code>应该也是指<code class="fe mr ms mt mu b"><em class="kz">John</em></code>吧？</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/4dae82e1a99c61420df84acc7b8a59cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHLKNMQ_-5vJRImEGvnoxw.png"/></div></div></figure><h2 id="fe1b" class="na lo in bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">❗️What发生了什么？</h2><p id="db89" class="pw-post-body-paragraph kb kc in kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky ig bi translated">好了，既然<em class="kz"> fullName() </em>是对象<code class="fe mr ms mt mu b"><em class="kz">John</em></code>的<strong class="kd io">方法调用</strong>，<code class="fe mr ms mt mu b"><em class="kz">this</em></code>指的是<code class="fe mr ms mt mu b"><em class="kz">John</em></code>。但是由于<em class="kz"> combineNames() </em>是一个<strong class="kd io">函数调用</strong>，<code class="fe mr ms mt mu b"><em class="kz">this</em></code>指的是<code class="fe mr ms mt mu b"><em class="kz">Global</em></code>。外部函数<em class="kz"> fullName() </em>不影响内部函数<em class="kz"> combineNames() </em>的上下文。</p><p id="fd5a" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">⭐️在这种情况下，解决这个问题的一个常用方法是使用arrow函数语法。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/22640d8bc8278bc9edca7b2f64893118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TF5CqyG_J57_HrAhpfAfnQ.png"/></div></div></figure><p id="e386" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">内部函数将在<em class="kz">full name()</em><code class="fe mr ms mt mu b"><em class="kz">John</em></code>对象之外继承<code class="fe mr ms mt mu b"><em class="kz">this</em></code>，这正是我们想要的！</p><h1 id="8ac5" class="ln lo in bd lp lq nn ls lt lu no lw lx ly np ma mb mc nq me mf mg nr mi mj mk bi translated">2.构造函数调用:这是在构造函数中</h1><p id="ed13" class="pw-post-body-paragraph kb kc in kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky ig bi translated">当你用关键字<code class="fe mr ms mt mu b">new</code>调用一个构造函数时，构造函数被构建。构造函数是创建多个具有特定主题的对象的蓝图，如<em class="kz">人</em>、<em class="kz">动物</em>或<em class="kz">水果</em>。</p><p id="b9b0" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">使用前面例子中的代码，我们可以使用一个<code class="fe mr ms mt mu b"><em class="kz">Person</em></code>构造函数定义许多其他人，比如<code class="fe mr ms mt mu b"><em class="kz">John</em></code>。还有其他<a class="ae nm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" rel="noopener ugc nofollow" target="_blank">方法来创建构造函数。</a></p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/bf14823c29ce3a58400136ba6d9016fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SLPEnuYC_lSrDzBKOzdMA.png"/></div></div></figure><p id="9723" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">使用关键字<code class="fe mr ms mt mu b">new</code>我们传递名字和姓氏<em class="kz"> </em>，并将对象存储在变量<code class="fe mr ms mt mu b"><em class="kz">Jane</em></code> <em class="kz">中。</em> <code class="fe mr ms mt mu b"><em class="kz">Jane</em></code>将是一个包含<code class="fe mr ms mt mu b"><em class="kz">first</em></code>、<code class="fe mr ms mt mu b"><em class="kz">last</em></code>等属性的对象，以及可调用的<em class="kz"> fullName() </em>函数。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/11dab94e9b056fe93eafef1ce8d6d9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYQU5_HIr70IvOkRJAeDbQ.png"/></div></div></figure><p id="3759" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在这种情况下，<code class="fe mr ms mt mu b"><strong class="kd io"><em class="kz">this</em></strong></code> <strong class="kd io">指的是</strong> <code class="fe mr ms mt mu b"><strong class="kd io">Jane</strong></code>，被创建的对象，而不是<code class="fe mr ms mt mu b"><em class="kz">Person</em></code>，因为<code class="fe mr ms mt mu b"><em class="kz">Person</em></code>仅仅是一个构造器/蓝图<em class="kz">。</em></p><h2 id="4797" class="na lo in bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">➜使用原型</h2><p id="434c" class="pw-post-body-paragraph kb kc in kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky ig bi translated">在可能有许多<code class="fe mr ms mt mu b"><em class="kz">People</em></code>对象的情况下，使用原型可能是直接构造函数调用的替代方法<em class="kz">。</em>这里有两个原因说明为什么在构造函数中定义函数可能不是一个好主意<em class="kz">。</em></p><ol class=""><li id="afbe" class="ns nt in kd b ke kf ki kj km nu kq nv ku nw ky nx ny nz oa bi translated">每次使用<code class="fe mr ms mt mu b">new</code>调用一个新对象时，函数也会被复制过来。</li><li id="1fb2" class="ns nt in kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">如果将来需要一个新的函数，您需要将它添加到构造函数中，并重新创建以前的所有对象。</li></ol><p id="4b3c" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">使用原型可以解决这两个潜在的问题。</p><p id="8245" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">下面是上面重写的构造函数示例<em class="kz">。</em>注意<code class="fe mr ms mt mu b"><strong class="kd io"><em class="kz">this</em></strong></code> <strong class="kd io">怎么还指</strong> <code class="fe mr ms mt mu b"><strong class="kd io">Jane</strong></code> <em class="kz">。</em></p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/8d2970d72f30193a1cd3db1bcb641f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4fmXySx78TlEr-GIhHFCw.png"/></div></div></figure><p id="a2c9" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="kz">在这里</em>  <em class="kz">阅读更多关于构造函数和原型</em> <a class="ae nm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" rel="noopener ugc nofollow" target="_blank"> <em class="kz">。</em></a></p></div><div class="ab cl lg lh hr li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ig ih ii ij ik"><h1 id="6c13" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><em class="ml">就这样</em></h1><p id="a42e" class="pw-post-body-paragraph kb kc in kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky ig bi translated">与其关注<strong class="kd io"> <em class="kz">这个</em> </strong>的实际定义，记住这将取决于它是如何被调用的以及它的上下文。问这样的问题，“我是在一个<em class="kz">对象</em>内部调用这个吗？<em class="kz">建造师</em>？还是<em class="kz">功能</em>？”以及“我使用的是什么函数语法？<em class="kz">箭头</em>？”。当有疑问时，打印<em class="kz"> console.log() </em>和如下所示的逻辑语句。</p><figure class="mw mx my mz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/a5b41049680d01f6b98ef3871348e13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1V2vIPozt5U0ck8IxKiMkQ.png"/></div></div></figure><p id="2874" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">现在我们有了。我希望你已经发现这是有用的。感谢您的阅读！</p><p id="4c5d" class="pw-post-body-paragraph kb kc in kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="kz">更多内容请看</em><a class="ae nm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kd io"><em class="kz">plain English . io</em></strong></a><em class="kz">。报名参加我们的</em> <a class="ae nm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io"> <em class="kz">免费周报</em> </strong> </a> <em class="kz">。关注我们关于</em><a class="ae nm" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kd io"><em class="kz">Twitter</em></strong></a><a class="ae nm" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kd io"><em class="kz">LinkedIn</em></strong></a><em class="kz"/><a class="ae nm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kd io"><em class="kz">YouTube</em></strong></a><em class="kz"/><a class="ae nm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kd io"><em class="kz">不和</em> </strong> </a> <em class="kz">。对增长黑客感兴趣？检查</em> <a class="ae nm" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd io"> <em class="kz">电路</em> </strong> </a> <em class="kz">。</em></p></div></div>    
</body>
</html>