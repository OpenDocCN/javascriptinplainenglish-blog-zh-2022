# 扩展 React 应用的 5 个技巧

> 原文：<https://javascript.plainenglish.io/5-tips-to-scale-up-your-react-apps-8fb68319062e?source=collection_archive---------3----------------------->

## 对适用于生产和个人项目的最佳实践做出反应。

![](img/f94b43df0bbd83f12b9d293671b9d96e.png)

[Photo](https://unsplash.com/photos/Ys78stblUyY) by Our Life In Pixels @ Unsplash

可伸缩性不是一个您可以专门针对的 KPI。这是良好设计决策和可维护代码的功能。不幸的是，这个等式对开发者不利。项目越大，走捷径的诱惑就越大，“现在就这么做，快点把它弄出去，我们以后再回来解决这个问题”。

软件工程已经够难的了，请不要再难为自己了。

相反，更聪明地工作，这五个技巧将在任何环境下挽救你的咸肉——无论你是:一个单独的开发人员，从事个人项目，还是一个混乱的“我们需要摇滚明星开发人员！”初创公司，或有多个不同团队从事单一回购的公司。

**剧透:**“用打字稿！”不包括在这里，但是如果你重视你的理智，考虑一下**默认的**规则，当你准备好跳过 ToDo 应用的时候。

# 1.使用 Bit 来充分利用 React 组件的可组合性

谢天谢地，React 的核心原则也是最容易理解的:可组合性。您构建 JavaScript 函数来管理 UI 和状态之间的关系，并生成 JSX/TSX 作为输出，您使用这些独立的、可重用的片段来构建越来越大的 UI 元素，以扩展您的应用程序。

让它变得更简单:构建原子→使用原子构建分子→决定分子在你的应用程序中的位置→冲洗并根据需要重复。

这就是[位](https://bit.dev/)的用武之地。Bit 是一个开源工具链，可以让您在可组合性上加倍努力，因此您可以独立地构建、存储、测试和记录组件，然后将它们存储在公共、私有或未列出的带有自动版本控制的存储库中。

“这是另一个 UI 库吗？”

一点也不！

Bit 是一种用 React 中任何可组合的东西来做上述所有事情的方法。你、你的团队或者世界上的任何人都可以在 [Bit](https://bit.cloud/) 上发现和分享独立的原子和分子——有样式的或者无头的；组件、实用功能、定制挂钩或主题——并在他们自己的应用程序中、在他们自己的上下文中使用它们，所有这些都只需简单的`npm install`。

![](img/e3694301d74a2d0e0959591e15dd29b6.png)

Need a Modal for your auth page? Get one.

# 2.使用设计系统

快速问题:如果你的网站/网络应用现在将被成千上万的用户看到，你更需要哪一个:最炫的 CSS 和最漂亮的动画，还是一个可维护的、可增量迭代的、易于调试的设计？

恶作剧问题。这两个目标并不相互排斥。

您可以交付尽可能最花哨的设计，同时仍然以让您的开发人员满意的方式构建它们。怎么会？输入设计标记。

Here’s what design tokens exported by your design team could look like.

设计标志是颜色、边距、填充、行高和间距、字体系列、过渡、关键帧——任何重复使用的东西。您可以从您的设计团队获得这些值，并将它们整合到一个去耦层中，该层是 JSON、YAML，甚至只是 JavaScript 对象，它位于您的应用程序之上，您的开发团队可以使用它在整个应用程序中提供一致、连贯、可扩展的 UI 元素。

如果使用 Bit，用设计符号进行主题化会变得更加容易。你可以从众多使用提供者模式的主题化组件中选择一个(Team Bit 自己的开源主题提供者足够好了)来构建一个上下文感知的主题，只使用设计令牌作为输入，通过将它们包装在提供者中提供给所有消费组件，*瞧*，你就有了一个应用范围的主题化系统，其中主题是可热插拔的。

# 3.编写定制钩子来管理你的网络请求

通过这种方式，您将抽象出自定义挂钩背后的异步样板、请求主体和选项/配置，而是专注于构建您的 UI +管理应用程序状态。

Yes, even if they’re only a wrapper around your axios/fetch calls.

如果你使用像 SWR 或 react-query 这样的库，还是做同样的事情，这次是每次查询。

The approach should be to refactor each query into its own custom hook (usePosts, usePostsByUser, useUserById, and so on). This design makes it much easier to manage query keys and shared query logic.

这使得您的网络请求*模块化*，确保如果您决定更改 HTTP 库(从简单的 axios/fetch 一直到 react-query、RTK 等),它将是一个现成的替代品。

> *💡更好的是，这样你可以将它们共享给 Bit，这样其他人可以通过他们选择的包管理器使用你的钩子。*

# 4.不要管理你*不应该*管理的状态

为了理解这一点，问问你自己“状态”到底是什么。只是描述系统当前状况的数据，对吗？这意味着，从广义上讲，可能有两种不同的状态。

1.  您自己创建和生成的用于描述应用程序内部的数据——一个布尔值，用于跟踪模式或侧栏是否打开、未保存的表单数据的对象等。
2.  您通过 API 异步获取的数据(还有更多，但我们现在仅限于这个定义)，它描述了服务器或从中获取数据的数据库的内部状态。你只是*借用*这些数据，甚至可能看不到它的最新版本，因为在此期间它可能已经被其他人更改了。

这只是第一种状态，你应该管理并让你的用户与它进行交互，以实现同步的 UI 操作。

**示例场景**:从你的服务器获取待办事项列表，并让你的用户在 UI 中更新/删除/标记它们为完成。你 **不应该做的事情**是在每一次操作中用对服务器的 GET/POST 请求来管理获取的数据，那将会慢得令人难以置信，并且会引入*所有*错误和意外行为。

那么，正确的方法应该是用服务器数据初始化应用程序状态，并且只对前者进行操作，每隔一段时间或在事件触发时将它与服务器同步。

现在你知道在 Medium 上写文章会发生什么了吧！未保存的更改只存在于前端，并定期保存到服务器。

> *💡*为了管理客户端状态，您希望在组件级别使用 React 的 useState/useReducer 挂钩，并在应用程序级别使用上下文 API(专业提示:坚持对大多数静态值使用此挂钩)或第三方状态管理库，如 [Zustand](https://github.com/pmndrs/zustand) 或 [Redux](https://redux.js.org/) 。对于服务器状态/缓存管理，使用像 [SWR](https://swr.vercel.app/) 、[阿波罗](https://www.apollographql.com/)或[反应查询](https://react-query.tanstack.com/)这样的库。

# 5.精简的项目结构是关键

React 是非单调性的；它最大的优点*和*弱点于一身。有许多组织 React 项目的观点和方法，其中一些是相互冲突的。但是每个人都同意一件事——无论项目规模如何，您都需要一个具有以下特征的结构:

1.  **一个文件/文件夹结构，使你的代码库可以立即被任何人浏览**，无论他们是新员工还是有经验的贡献者。一种方法是根据特性来组织组件，而不是仅仅将它们放在一个共享的“组件”目录中。
2.  足够明显和直观的代码约定，这样任何参与你的项目的人都不需要阅读指南就可以开始。例如，这就是为什么 TypeScript 使得在团队中开发软件变得如此容易。代码**本身**成为你的文档。
3.  **易于理解的代码库结构，在开发过程中在本地构建。**这就是为什么多包 monorepo 架构是一个很好的起点(如果您的 API 不是公共的),所以您拥有以上所有的共享类型、共享库，以及每个特性一个拉请求的优势。另外，随着每个特性被抽象成自己独立的东西和包，你的导入看起来更容易理解:`import { Component } from ‘@project/ui/thing’`而不是`import { Component } from ‘../../../components/thing’`。
4.  **为重构而优化的代码。**不要追求完美的永不失败的代码。相反，建立更好的安全网，以备*失败的时候。编写的代码不要把依赖关系和逻辑耦合得太紧，否则基本上会把它们钉在地板上，甚至连重构的想法都成了噩梦。*

> *💡*这是 Bit 有意义的另一个领域，它专注于独立存储、记录和测试的构建块，这些构建块被扫描到独立的包中，这些包可以隐藏到您组织的命名空间存储库中，并在需要时由任何人导入到任何项目中。

# “完美是好的敌人”

今天，我们已经讨论了很多在构建可扩展项目时会遇到的陷阱，但是 TL；随着应用的增长，灾难恢复非常简单:

不要把项目想成是紧密耦合的整体，而是把它们想成是具有自己的特性集的独立构建块的组合，然后你可以用一种直观且容易修改的方式一起构建。这就是 Bit 提倡的那种思维，把 web dev 变成了玩乐高。

可伸缩性将随之而来。你就不用考虑了。