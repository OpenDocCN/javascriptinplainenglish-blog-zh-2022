<html>
<head>
<title>Basics of Component Communication in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular中组件通信的基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basics-of-component-communication-in-angular-82fc196f30f9?source=collection_archive---------5-----------------------#2022-06-24">https://javascript.plainenglish.io/basics-of-component-communication-in-angular-82fc196f30f9?source=collection_archive---------5-----------------------#2022-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f20" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解组件交互对于理解角度是必不可少的。下面是让组件进行通信的基本方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f69f09bf254d30ff2051b4e97cadbbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_8DI0aB9NlXtpRa6"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ptrikutam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pavan Trikutam</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f6c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像其他前端框架一样，组件是Angular的基石。所以，知道如何让组件互相通信，对Angular开发至关重要。让我们看看组件与一个或多个其他组件通信的几种方式。</p><h2 id="75c5" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">1.调用子组件中的函数</h2><p id="aaa1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">父子关系是组件交互的最常见需求。假设我们有一个<code class="fe mq mr ms mt b">ProfileComponent</code>，其中有一个<code class="fe mq mr ms mt b">ProfilePictureComponent</code>。当用户点击<code class="fe mq mr ms mt b">ProfileComponent</code>中的按钮时，我们想调用一个函数来改变<code class="fe mq mr ms mt b">ProfilePictureComponent</code>中的图像。我们可以通过在父组件中使用<code class="fe mq mr ms mt b">ViewChild</code>装饰器来实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">ViewChild</code>装饰器可以用来引用作为子元素存在的<code class="fe mq mr ms mt b">@Component</code>或<code class="fe mq mr ms mt b">@Directive</code>。它接受一个选择器，在我们的例子中是子组件<code class="fe mq mr ms mt b">ProfilePictureComponent</code>。现在我们可以简单地引用组件并公开调用它的任何可用方法。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="126a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">2.将数据传递给子组件</h2><p id="b972" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果我们不想调用子对象中的方法，而是想传递一个值给子对象，会怎么样？在这种情况下，我们可以利用子组件中的<code class="fe mq mr ms mt b">Input</code>装饰器。看看我们的子组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="91f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">Input</code> decorator充当实例化组件的模板和组件本身的属性之间的绑定。在变化检测期间，Angular会将模板值传递给组件值，确保它们被绑定。换句话说，在我们的父模板中，我们可以实例化ProfilePictureComponent:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="d4f8" class="ls lt iq mt b gy na nb l nc nd">&lt;profile-picture [pictureURL]="currentImageURL"&gt;&lt;/profile-picture&gt;</span></pre><p id="42cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将<code class="fe mq mr ms mt b">currentImageURL</code>传递给子节点，我们可以将它们绑定在一起，允许我们更改父节点中的值，并查看子节点中反映的更改。</p><h2 id="e3fc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">3.调用父组件中的函数</h2><p id="5274" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在示例1中，我们调用了子组件中的一个函数。如果我们想反过来调用父类中的函数呢？这就是我们可以利用<code class="fe mq mr ms mt b">Output</code>装饰器的地方。在我们的子组件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mq mr ms mt b">Input</code>装饰器，数据从父模板流向子组件；使用<code class="fe mq mr ms mt b">Output</code>装饰器，数据从子组件流向父模板。现在，在我们的父模板中，我们可以有:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="4af0" class="ls lt iq mt b gy na nb l nc nd">&lt;profile-picture (changeImage)="reloadImage($event)"&gt;&lt;/profile-picture&gt;</span></pre><p id="c912" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，<code class="fe mq mr ms mt b">changeImage</code>被圆括号而不是方括号包围，这意味着我们绑定到一个输出，而不是一个输入。我们将父节点的<code class="fe mq mr ms mt b">reloadImage</code>方法传递给这个输出，现在每当子节点发出一个事件时<code class="fe mq mr ms mt b">reloadImage</code>就会被调用。</p><p id="8ed8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要发出一个事件，我们必须调用我们的<code class="fe mq mr ms mt b">EventEmitter</code>上的<code class="fe mq mr ms mt b">emit()</code>方法，并传递预期的数据类型，我们已经将其指定为<code class="fe mq mr ms mt b">string</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过变化检测的能力，Angular将把<code class="fe mq mr ms mt b">img</code>值向上传递给父节点。</p><h2 id="aec1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">4.父子之间的双向数据</h2><p id="e430" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe mq mr ms mt b">Output</code>装饰器不仅可以用来调用父组件中的方法，还可以用来传递值。这是显而易见的，在我们之前的例子中——<code class="fe mq mr ms mt b">img</code>值被直接传递给父节点。但是我们可以将它与一个<code class="fe mq mr ms mt b">Input</code>结合起来，以实现双向数据流:子节点中的更改将传播到父节点，而父节点中的更改将向下传递到子节点。让我们把<code class="fe mq mr ms mt b">ProfilePictureComponent</code>改成这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4d67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让这种双向流与Angular的盒中香蕉语法一起工作，<code class="fe mq mr ms mt b">Output</code> <strong class="ky ir">必须</strong>遵循精确的命名约定。<code class="fe mq mr ms mt b">Output</code>变量名必须是<code class="fe mq mr ms mt b">Input</code>的名称加上单词“Change”因此，如果你有一个名为“颜色”的<code class="fe mq mr ms mt b">Input</code>，那么<code class="fe mq mr ms mt b">Output</code>将被命名为“颜色变化”遵循这个约定，我们可以在父模板中使用香蕉盒语法来实现双向绑定:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="74da" class="ls lt iq mt b gy na nb l nc nd">&lt;profile-picture [(img)]="image"&gt;&lt;/profile-picture&gt;</span></pre><p id="967a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个方法，我们可以改变父节点的<code class="fe mq mr ms mt b">image</code>变量，并让它流向子节点，子节点可以使用它的本地<code class="fe mq mr ms mt b">changeImage()</code>方法将改变发送给父节点。</p><h2 id="fb45" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">5.向不相关的组件“广播”数据</h2><p id="5d2a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">到目前为止，我们所有的例子都包括父子关系中的两个组件。但是有时一个组件需要将数据发送给页面中某个不相关的组件。实现这一目标的最佳方式之一是将订阅与角度服务相结合。</p><p id="70b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们修改我们的例子。现在，它需要与页面上其他地方的<code class="fe mq mr ms mt b">ContactCardComponent</code>通信，而不是父<code class="fe mq mr ms mt b">ProfileComponent</code>与子通信。我们不能使用直接的属性绑定，因为这两个组件是互不可知的。相反，我们可以创建一个服务来存储和处理数据中的变化，并将这些变化传递给任何选择订阅的组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1eee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个私有的<code class="fe mq mr ms mt b">contactInfoSubject</code>，它将是负责联系方式变更的主体。public <code class="fe mq mr ms mt b">contactInfoStream</code>是任何组件都可以订阅的可观察对象，以便从<code class="fe mq mr ms mt b">contactInfoSubject</code>接收更新。类似地，任何组件都可以调用<code class="fe mq mr ms mt b">changeContactInfo()</code>方法来触发主题的变化。由于Angular的依赖注入，服务的同一个实例将在我们注入的任何组件中使用，允许数据同步。</p><p id="7add" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以创建一个<code class="fe mq mr ms mt b">ContactCardComponent</code>,如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a570" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mq mr ms mt b">ngOnInit</code>生命周期挂钩中，我们订阅了在<code class="fe mq mr ms mt b">ContactService</code>中创建的主题，这样无论何时主题发送一个新值，本地<code class="fe mq mr ms mt b">contactInfo</code>字符串都会被更新以匹配。组件也有自己的方法来调用<code class="fe mq mr ms mt b">changeContactInfo()</code>方法，这样它也可以触发自己的更改。</p><p id="c09b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这些方法，我们可以在服务中订阅主题的任意数量的组件之间同步数据，而不必依赖父子关系。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="65ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望您发现组件通信的基础知识是有用的。下面您将找到有助于加深理解的资源。一如既往的感谢您的阅读。</p><div class="nl nm gp gr nn no"><a href="https://angular.io/guide/inputs-outputs" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">有角的</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Angular是一个构建移动和桌面web应用程序的平台。加入数百万开发者的社区…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">angular.io</p></div></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://angular.io/guide/two-way-binding" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">有角的</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Angular是一个构建移动和桌面web应用程序的平台。加入数百万开发者的社区…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">angular.io</p></div></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://rxjs.dev/guide/subject" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">RxJS</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">编辑描述</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">rxjs.dev</p></div></div></div></a></div><p id="fc78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nx">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nx">plain English . io</em></strong></a><em class="nx">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nx">免费周报</em> </strong> </a> <em class="nx">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nx">Twitter</em></strong></a><em class="nx">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nx">LinkedIn</em></strong></a><em class="nx">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nx">社区不和谐</em> </strong> </a> <em class="nx">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nx">人才集体</em> </strong> </a> <em class="nx">。</em></p></div></div>    
</body>
</html>