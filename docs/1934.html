<html>
<head>
<title>Local Overrides: Chrome’s Best Debugging Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本地覆盖:Chrome最好的调试功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/chromes-best-debugging-feature-301de685a616?source=collection_archive---------3-----------------------#2022-05-01">https://javascript.plainenglish.io/chromes-best-debugging-feature-301de685a616?source=collection_archive---------3-----------------------#2022-05-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4ad6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">可以说这取决于你正在寻找的bug的类型，但是最近，我发现自己重新发现了这个特性的巧妙之处</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d37dc525733a49f1ce8dfeacfd3e3c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9w-1lFnjo_Izixt--8PmAQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Chrome DevTools</figcaption></figure><p id="a658" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">本地覆盖不是Chrome DevTools中的新功能，但它经常被忽略，其威力可能是未知的。据我所知，它自<a class="ae lo" href="https://developer.chrome.com/blog/new-in-devtools-65/" rel="noopener ugc nofollow" target="_blank"> Chrome版本65 </a> (2018)以来就一直存在，但许多人可能没有发现或听说过它，因为它不是Chrome DevTools中的“明星”之一。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/efa7167aa1a5b3646b1ec0672422f9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zaz3i6FwbGADh7MGNU1_MA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Local Overrides placement in Chrome DevTools</figcaption></figure><h2 id="ef7f" class="lq lr in bd ls lt lu dn lv lw lx dp ly lb lz ma mb lf mc md me lj mf mg mh mi bi translated">简短描述</h2><p id="8c48" class="pw-post-body-paragraph ks kt in ku b kv mj jo kx ky mk jr la lb ml ld le lf mm lh li lj mn ll lm ln ig bi translated">本地覆盖功能只是让您覆盖任何站点上的外部JavaScript和CSS，并在重新加载时保持这些更改。<br/>更详细一点的描述是，Chrome要求获得许可才能将文件保存到你电脑上的文件夹中。每当Chromes获取任何保存的文件时，都会提供本地副本，而不是来自服务器的副本。让我们看一些用例。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h2 id="e907" class="lq lr in bd ls lt lu dn lv lw lx dp ly lb lz ma mb lf mc md me lj mf mg mh mi bi translated">更改CSS</h2><p id="bb96" class="pw-post-body-paragraph ks kt in ku b kv mj jo kx ky mk jr la lb ml ld le lf mm lh li lj mn ll lm ln ig bi translated">我相信很多web开发者都尝试过打开Chrome控制台，更改一些CSS属性，看看某个bug是否与该属性有关。通常，您可以快速更改许多值，并最终得到所需的输出。而是能够始终如一地复制输出，而且复制得最多。如果CSS来自您自己的应用程序托管的文件，您可以简单地在您的本地主机上更改它，这个特性将没有任何用处。然而，如果CSS来自外部资源，这就是这些特性开始显示威力的地方。</p><p id="232d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们举一个来自<a class="ae lo" href="https://www.nytimes.com/" rel="noopener ugc nofollow" target="_blank">nytimes.com</a>的简单例子:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/fae6f37a6c3633201492274abe1f3490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmZd93ZTbW8mZyIVAmSGlw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of <a class="ae lo" href="https://www.nytimes.com/" rel="noopener ugc nofollow" target="_blank">nytimes</a></figcaption></figure><p id="86c1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在让我们假设这是一个错误，所有的achor标签不是黑色的，大小为16。通过对DevTools的检查，我们发现特定的CSS设置在来自网站的CSS文件中:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7c79b576d54e6791cbd4888fdbd9e1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*JD3tKXTaTwpU04gLxcmpFA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Achor tag with it’s CSS</figcaption></figure><p id="c6bb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我可以更改该文件中的属性，每次重新加载网站时，我都会得到自己的本地版本。现在CSS不是最明显的用例，因为CSS可以在运行时在浏览器中更改，这意味着在大多数情况下确定哪个CSS导致了错误非常简单。接下来的两个用例更好地展示了这个特性的威力。</p><h2 id="e30a" class="lq lr in bd ls lt lu dn lv lw lx dp ly lb lz ma mb lf mc md me lj mf mg mh mi bi translated">调试外部库</h2><p id="55e8" class="pw-post-body-paragraph ks kt in ku b kv mj jo kx ky mk jr la lb ml ld le lf mm lh li lj mn ll lm ln ig bi translated">作为一个非平凡网站的web开发人员，您几乎肯定会引入一些第三方库。这可以是一些分析，一个CMP，广告脚本，动画助手，图表库等。</p><p id="4be6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在与CSS相比，你不能改变已经在你的页面上执行的代码。您可以运行一个正常的调试会话来找出某个bug可能发生在哪里。但是因为这不是你的库，你没有办法改变他们的代码。直到本地覆盖！</p><p id="c3dd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">假设你认为一个第三方库有一个错误，或者你只是好奇想知道一些内部是如何工作的。为了便于讨论，让我们假设您想要一个第三方库来实现某个方法或接口。</p><p id="4646" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在下面的例子中，我们希望ast.js(包含在<a class="ae lo" href="https://www.msn.com/da-dk" rel="noopener ugc nofollow" target="_blank">msn.com/da-dk</a>中)实现激活事件监听器的方法:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/c4ad469186adbc85c4b5cb860db5f22a.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*HBUksK6usx2pup4ovyz97A.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A dummy method we want/think the library should implement</figcaption></figure><p id="55e7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了“证明”这个方法在正确的环境中(而不仅仅是在我的本地IDE中)能够正常工作，我将在ast.js文件中“实现”它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/56dc2c8e58bb28d40d9b48e968ec67f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmp7ZFNXXwfaKcXdtXW8yA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">My function inserted with local override</figcaption></figure><p id="19e2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我可以重新加载站点，就好像ast.js已经本机实现了该方法一样，以查看它在这个特定的站点上是如何工作的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/f893809e3c2a1f8413be6b784d0c0059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usUUvSur7M-GWOYZ83C-TA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Here the inserted function is tested</figcaption></figure><p id="411a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，当您确定该函数工作正常(至少对您来说)时，您可以选择将代码发送给库的维护人员，希望他们能确切地看到您想要什么特性，甚至知道他们如何实现它。这对库开发人员来说是一个很大的帮助，但是它也帮助你思考你想要的特性应该如何工作的细节。</p><h2 id="3fb8" class="lq lr in bd ls lt lu dn lv lw lx dp ly lb lz ma mb lf mc md me lj mf mg mh mi bi translated">调试您自己的库</h2><p id="29fa" class="pw-post-body-paragraph ks kt in ku b kv mj jo kx ky mk jr la lb ml ld le lf mm lh li lj mn ll lm ln ig bi translated">这个用例在我自己的工作中特别有用。案例是，我们向数百个(甚至数千个)网站提供一个脚本。从他们的角度来看，这使我们成为第三方库。我们的脚本有一组配置变量和一个对这些变量做出反应的核心“引擎”。</p><p id="f9fc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">该库的一个简单示例如下所示</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/edf710ad2dcc2295180aee630f88bf89.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*H2WlpQyoTbty2BoLmfX52w.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Some dummy library to prove my point</figcaption></figure><p id="9810" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">由于real library在数千个站点中实现，我们有一个更大的部署/标签管理系统来部署对“mainFunction”和“configVars”的更改。</p><p id="5448" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">由于“configVars”对象有许多组合，“mainFunction”可以执行许多许多不同的路径，这并不总是容易弄清楚的。因此，有时需要测试一组“配置变量”,而不需要将它们实际部署到现场。最坏的情况是，该配置可能会产生不良影响。<br/>这就是本地覆盖可以帮助我们的地方。<br/>现在，我可以在正确的环境中简单地测试所有不同的组合。当我确信配置可以工作时，我就可以进行实际的部署，这样站点的所有用户都可以从新配置中受益。</p><p id="f0a1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="nb">更多内容请看</em><a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nb">plain English . io</em></strong></a><em class="nb">。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="nb">免费周报</em> </strong> </a> <em class="nb">。关注我们关于</em><a class="ae lo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nb">Twitter</em></strong></a><em class="nb">和</em><a class="ae lo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nb">LinkedIn</em></strong></a><em class="nb">。加入我们的</em> <a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="nb">社区不和谐</em> </strong> </a> <em class="nb">。</em></p></div></div>    
</body>
</html>