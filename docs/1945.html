<html>
<head>
<title>A Guide to Understanding Vue Lifecycle Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Vue生命周期挂钩的指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-guide-to-understanding-vue-lifecycle-hooks-dc6a34ce7ecb?source=collection_archive---------8-----------------------#2022-05-02">https://javascript.plainenglish.io/a-guide-to-understanding-vue-lifecycle-hooks-dc6a34ce7ecb?source=collection_archive---------8-----------------------#2022-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dbdc9a8acd3cf22a53c54408a121435e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1L0tAYpWQDTDDPOs_-2Rg.png"/></div></div></figure><p id="3a1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像其他框架一样，Vue有许多<strong class="jx io">生命周期挂钩</strong>，允许我们将代码附加到创建或使用Vue应用程序时发生的特定事件上——例如，当组件加载时，当组件被添加到DOM时，或者当某些东西被删除时。</p><p id="c689" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Vue有很多生命周期挂钩，令人困惑的是每个挂钩的含义或作用。在本指南中，我们将介绍每个生命周期挂钩的作用，以及如何使用它们。</p><h1 id="e444" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">先决条件</h1><p id="0a43" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果你不熟悉Vue，在做这个之前，你可能想看看<a class="ae lw" href="https://fjolt.com/article/vue-create-your-first-app" rel="noopener ugc nofollow" target="_blank">我的关于创建你的第一个Vue应用的指南</a>。或者，如果你对它稍微熟悉一点的话，你可以阅读我关于在Vue 中创建待办事项列表的指南。</p><h1 id="37f3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Vue中的生命周期挂钩</h1><p id="d33c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io">这里需要注意的重要一点是，当涉及到生命周期挂钩时，Vue有两种范例。一个是使用Compositions API，这是在Vue 3中引入的，另一个是“<strong class="jx io"> Options API </strong>”，这是定义Vue组件的原型模式。在本指南中，我们将从<strong class="jx io">选项API </strong>开始，然后在此基础上展示如何在组合API中工作。</strong></p><h1 id="6d26" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">选项API示例</h1><p id="7443" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果你不熟悉<strong class="jx io">选项API </strong>，它是Vue的版本，看起来像下面的代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="17c4" class="mg ku in mc b gy mh mi l mj mk">export default {<br/>    name: 'Component Name',<br/>    data() {<br/>        return {<br/>            phoneNumber: '123-123-123'<br/>        }<br/>    },<br/>    mounted() {</span><span id="76f0" class="mg ku in mc b gy ml mi l mj mk">    }<br/>}</span></pre><h1 id="74ff" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">生命周期挂钩图</h1><p id="5e2e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了理解每个生命周期钩子何时触发，让我们看一个图表。下图描述了每个生命周期挂钩触发的时间。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/d9c3f10379a78d3ddb6faa17982eae28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QAVBGqZwc9Bs1PTZ.png"/></div></div></figure><h1 id="3118" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">运行生命周期挂钩</h1><p id="7595" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">要使用Options API运行任何生命周期挂钩，可以将其添加到Javascript原型中。例如，如果您想使用<code class="fe mn mo mp mc b">beforeCreate()</code>，即检测到新组件后触发的第一个钩子，您可以像这样添加它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="cf62" class="mg ku in mc b gy mh mi l mj mk">export default {<br/>    name: 'Component Name',<br/>    data() {<br/>        return {<br/>            someData: '123-123-123'<br/>        }<br/>    },<br/>    mounted() {<br/>        // Any code you want to fire immediately before the Options API loads up<br/>    }<br/>}</span></pre><p id="26de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们已经讨论了不同钩子何时出现，那么让我们来看看它们各自做什么，以及它们何时出现。</p><h1 id="1c65" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建之前()</h1><p id="96e8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在组件初始化时调用。<code class="fe mn mo mp mc b">data()</code>和计算属性此时不可用。这对于调用不调整组件数据的API很有用。如果你在这里更新<code class="fe mn mo mp mc b">data()</code>，它将会在选项API加载后丢失。</p><h1 id="1b9f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">已创建()</h1><p id="2163" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在实例处理完所有状态操作后调用。您可以访问反应数据、计算属性、方法和观察器。Vue存储组件HTML的地方<code class="fe mn mo mp mc b">$el</code>还不可用，因为DOM元素还没有创建。如果你想启动一个类似API的东西，或者更新<code class="fe mn mo mp mc b">data()</code>，你可以在这里完成。</p><h1 id="195d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">安装前()</h1><p id="6329" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这个钩子在渲染发生之前立即运行。模板已经被编译，所以它存储在内存中，但是它还没有被附加到页面上。还没有创建任何DOM元素。<code class="fe mn mo mp mc b">$el</code>现阶段仍不可用。</p><p id="8f3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器端呈现站点时，不会调用这个函数。</p><h1 id="e765" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">已安装()</h1><p id="2c2c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">组件已安装并显示在页面上。<code class="fe mn mo mp mc b">$el</code>现已可用，因此您现在可以从Vue访问和操作DOM。这将仅在所有子组件完全安装后触发。当您想在DOM加载后对它做一些事情时，比如改变其中的一个特定元素，使用这个方法是很有用的。</p><p id="4326" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器端呈现站点时，不会调用这个函数。</p><h1 id="c6ea" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">更新前()</h1><p id="30da" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">有时，您会通过在观察器中更新数据，或者通过用户交互来更改Vue组件中的数据。当你改变<code class="fe mn mo mp mc b">data()</code>或者在你的组件中重新渲染时，一个<strong class="jx io">更新</strong>事件将被触发。就在重新渲染发生之前，<code class="fe mn mo mp mc b">beforeUpdate()</code>将启动。此事件之后，组件将被重新呈现，并使用最新数据进行更新。您可以使用这个钩子来访问DOM的当前状态，甚至从中更新<code class="fe mn mo mp mc b">data()</code>。</p><p id="9f1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器端呈现站点时，不会调用这个函数。</p><h1 id="92f5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">已更新()</h1><p id="f94d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在一个更新被触发，并且DOM已经被更新以匹配最新的数据之后，<code class="fe mn mo mp mc b">updated()</code>将被触发。这在重新渲染后立即发生。现在，如果您访问<code class="fe mn mo mp mc b">$el</code>，或者任何关于DOM内容的内容，它将显示新的、重新呈现的版本。如果你有一个父组件，子组件<code class="fe mn mo mp mc b">updated()</code>首先被调用，然后是父组件<code class="fe mn mo mp mc b">updated()</code>钩子。</p><p id="4e1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器端呈现站点时，不会调用这个函数。</p><h1 id="85af" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">卸载前()</h1><p id="637b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果某个组件被删除，它将被卸载。在组件完全移除之前，<code class="fe mn mo mp mc b">beforeUnmount()</code>启动。这个事件仍然可以访问DOM元素，以及与组件相关的任何东西。这在删除事件中很有用，例如，您可以使用该事件通知服务器用户删除了表中的一个节点。如果需要的话，您仍然可以访问<code class="fe mn mo mp mc b">this.$el</code>，以及数据、观察器和方法。</p><p id="3788" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器端呈现站点时，不会调用这个函数。</p><h1 id="9ff8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">卸载()</h1><p id="b381" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">一旦完全删除，<code class="fe mn mo mp mc b">unmount()</code>事件就会触发。这可以用来清理其他数据或事件侦听器或计时器，让它们知道该组件不再存在于页面上。如果需要的话，您仍然可以访问<code class="fe mn mo mp mc b">this.$el</code>，以及数据、观察器和方法。</p><p id="a7ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器端呈现站点时，不会调用这个函数。</p><h1 id="92f6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在组合API中使用Vue生命周期挂钩</h1><p id="a3ed" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果你习惯使用<strong class="jx io">选项API </strong>，上面的钩子会很有意义。如果你主要使用Vue 3，你可能更习惯使用<strong class="jx io">组合API </strong>。组合API是选项API的补充，但是我们使用钩子的方式略有不同。让我们来看看它是如何工作的。</p><h1 id="a4a1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">created()和beforeCreated()替换为setup()</h1><p id="6f9d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在组合API中，<code class="fe mn mo mp mc b">created()</code>和<code class="fe mn mo mp mc b">beforeCreated()</code>是不可访问的。而是换成了<code class="fe mn mo mp mc b">setup()</code>。这是有意义的，因为不需要加载“选项API”。你原本放在<code class="fe mn mo mp mc b">created()</code>或<code class="fe mn mo mp mc b">beforeCreated()</code>中的任何代码，现在都可以安全地放入<code class="fe mn mo mp mc b">setup()</code></p><h1 id="253b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">挂钩可以与setup()一起使用</h1><p id="b2d5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">钩子仍然可以和setup一起使用，就像它们在Options API中一样，这非常直观。例如:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1791" class="mg ku in mc b gy mh mi l mj mk">export default {<br/>    data() {<br/>        return {<br/>            msg: 1<br/>        }<br/>    },<br/>    setup() {<br/>        console.log('Component setup complete')<br/>    },<br/>    mounted() {<br/>        console.log(this.$el)<br/>    },<br/>}</span></pre><p id="97a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，另一种方法是使用组合API函数在<code class="fe mn mo mp mc b">setup()</code>函数本身中定义挂钩。如果我们这样做，钩子的命名会稍有不同:</p><ul class=""><li id="a583" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated"><code class="fe mn mo mp mc b">beforeMount()</code>变为<code class="fe mn mo mp mc b">onBeforeMount()</code></li><li id="f0a2" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><code class="fe mn mo mp mc b">mounted()</code>变为<code class="fe mn mo mp mc b">onMounted()</code></li><li id="ce8c" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><code class="fe mn mo mp mc b">beforeUpdate()</code>变为<code class="fe mn mo mp mc b">onBeforeUpdate()</code></li><li id="5cc5" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><code class="fe mn mo mp mc b">updated()</code>变为<code class="fe mn mo mp mc b">onUpdated()</code></li><li id="0a1b" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><code class="fe mn mo mp mc b">beforeUnmount()</code>变为<code class="fe mn mo mp mc b">onBeforeUnmount()</code></li><li id="0d8c" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><code class="fe mn mo mp mc b">unmounted()</code>变成了<code class="fe mn mo mp mc b">onUnmounted()</code></li></ul><p id="582d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些函数做的事情与我在上一节中描述的完全一样，但是它们的调用略有不同。所有这些钩子都必须在<code class="fe mn mo mp mc b">setup()</code>函数中或者在<code class="fe mn mo mp mc b">setup</code>脚本中被调用。例如，您必须在如下设置函数中运行钩子:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fed7" class="mg ku in mc b gy mh mi l mj mk">export default {<br/>    setup() {<br/>        // All hooks must go here<br/>    }<br/>}</span></pre><p id="e69e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，在带有<code class="fe mn mo mp mc b">setup</code>属性的脚本标签中，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="68a0" class="mg ku in mc b gy mh mi l mj mk">&lt;script setup&gt;<br/>// All hooks must go within this setup script<br/>&lt;/script&gt;</span></pre><p id="2a26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果您想使用这种方法调用钩子，您的代码应该是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8b87" class="mg ku in mc b gy mh mi l mj mk">export default {<br/>    setup() {<br/>        // All hooks must go here<br/>        onBeforeMount(() =&gt; {<br/>            // Code for beforeMount()<br/>        });<br/>        onBeforeUpdate(() =&gt; {<br/>            // Code for beforeUpdate()<br/>        })<br/>    }<br/>}</span></pre><p id="5fd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有根本性的性能改进，也没有更好的理由。这只是另一种方式——在某些情况下，它会使你的代码更容易阅读和维护。对于其他实例，使用<strong class="jx io">选项API </strong>可能会更好，所以使用您觉得更舒服的选项。</p><h1 id="bcfd" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="383e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Vue的生命周期非常复杂，但它给了我们很多工具来运行代码、更新数据，并确保我们的组件以我们希望的方式显示。在本指南中，我们已经介绍了它是如何工作的，何时使用生命周期的每个部分，以及在生命周期挂钩方面，组合API与选项API的工作方式有何不同。</p><p id="95a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢这个，你可能会喜欢我的其他Vue内容。以下是一些相关链接:</p><ul class=""><li id="8256" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated"><a class="ae lw" href="https://fjolt.com/article/vue-using-components" rel="noopener ugc nofollow" target="_blank">Vue组件如何工作</a></li><li id="7359" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><a class="ae lw" href="https://fjolt.com/article/vue-how-to-watch-for-changes" rel="noopener ugc nofollow" target="_blank">如何在Vue中使用观察器</a></li><li id="e2c5" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><a class="ae lw" href="https://fjolt.com/article/vue-how-to-set-up-a-websocket-server" rel="noopener ugc nofollow" target="_blank">在Vue中创建Websocket服务器</a></li></ul><p id="f351" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ne">更多内容请看</em> <a class="ae lw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ne">说白了。报名参加我们的</em> <a class="ae lw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ne">免费周报</em> </strong> </a> <em class="ne">。关注我们</em><a class="ae lw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ne">Twitter</em></strong></a><em class="ne">和</em><a class="ae lw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ne">LinkedIn</em></strong></a><em class="ne">。加入我们的</em> <a class="ae lw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ne">社区不和谐</em> </strong> </a> <em class="ne">。</em></strong></a></p></div></div>    
</body>
</html>