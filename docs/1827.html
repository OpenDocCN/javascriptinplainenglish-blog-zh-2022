<html>
<head>
<title>Demystifying “this” in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开JavaScript中“this”的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-this-in-javascript-5a38d920f216?source=collection_archive---------7-----------------------#2022-04-22">https://javascript.plainenglish.io/demystifying-this-in-javascript-5a38d920f216?source=collection_archive---------7-----------------------#2022-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ba25" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解JavaScript中“这”是如何工作的</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ca334f67b498aff36e98bacfb0465b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdb5KbeYhmRjSCR7nPckgg.png"/></div></div></figure><p id="b600" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在面向对象编程中，你通常用属性和方法创建这个蓝图，称为<strong class="kq io">类</strong>，基于这个类，你能够创建新的对象。现在，从一个类派生的每个对象都将具有相似的结构，但是它们的值可能不同。例如，你和我都来自于一个<strong class="kq io"> Person </strong>类，我们每个人都有一个行走、交谈和进食的方法。但是有一些属性，比如姓名、年龄或性别，对我们两个来说可能相同，也可能不同。</p><p id="4595" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">你可以在这里观看这篇文章的视频版本:</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div></figure><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="c5ea" class="ls lt in lo b gy lu lv l lw lx">class Person {<br/>    constructor(name, age, gender) {<br/>        this.name = name;<br/>        this.age = age;<br/>        this.gender = gender;<br/>    }</span><span id="be03" class="ls lt in lo b gy ly lv l lw lx">    eat() { console.log(`${this.name} is eating`) }<br/>    walk() { console.log(`${this.name} is walking`) }<br/>    talk() { console.log(`${this.name} is talking`) }<br/>}</span><span id="5acb" class="ls lt in lo b gy ly lv l lw lx">const johnObj = new Person("John", 20, "Male");<br/>johnObj.eat()  //John is eating</span></pre><p id="2afc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以，在这个例子中，所有的方法中都有一个<code class="fe lz ma mb lo b"><strong class="kq io">this</strong></code>关键字。<code class="fe lz ma mb lo b"><strong class="kq io">this</strong></code>这里的关键字指的是该类的一个实例，即一个将从该类中创建的对象。<br/>当你使用<code class="fe lz ma mb lo b"><strong class="kq io">new</strong></code>关键字从一个类中创建一个对象时，它调用构造函数并创建一个新的对象。<br/>现在，如果我们试图在类实例上运行eat方法，<code class="fe lz ma mb lo b"><strong class="kq io">this</strong></code>关键字将指向john对象。所以<code class="fe lz ma mb lo b"><strong class="kq io">this.name</strong></code>基本上会看起来像<code class="fe lz ma mb lo b"><strong class="kq io">johnObj.name</strong></code> <strong class="kq io"> </strong>，在这里就是<strong class="kq io">约翰</strong>。所以我们得到<strong class="kq io">约翰正在吃</strong>作为输出。</p><p id="ce26" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，简而言之，<code class="fe lz ma mb lo b"><strong class="kq io">this</strong></code>关键字代表了该类的一个实例。但是，由于我们使用的是Javascript，显然还有更多的东西。<code class="fe lz ma mb lo b"><strong class="kq io">this</strong></code>在不同的场景中表现不同，虽然在开始时看起来有点混乱，但在这篇博文的结尾，一切都变得有意义了。所以让我们开始吧。</p><h2 id="a212" class="ls lt in bd mc md me dn mf mg mh dp mi kx mj mk ml lb mm mn mo lf mp mq mr ms bi translated">1.全球语境中的“这个”</h2><p id="f3f5" class="pw-post-body-paragraph ko kp in kq b kr mt jo kt ku mu jr kw kx mv kz la lb mw ld le lf mx lh li lj ig bi translated">在全局上下文中，<code class="fe lz ma mb lo b">this</code>总是指窗口对象。仅此而已。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="12a4" class="ls lt in lo b gy lu lv l lw lx">//Global context<br/>console.log(window == this)  //true</span></pre><h2 id="295f" class="ls lt in bd mc md me dn mf mg mh dp mi kx mj mk ml lb mm mn mo lf mp mq mr ms bi translated">2.函数中的“这个”</h2><p id="ca25" class="pw-post-body-paragraph ko kp in kq b kr mt jo kt ku mu jr kw kx mv kz la lb mw ld le lf mx lh li lj ig bi translated">函数内部是事情变得有点棘手的地方。函数内<code class="fe lz ma mb lo b"><strong class="kq io">this</strong></code>的值将取决于<strong class="kq io">该函数如何被调用</strong>。如果一个函数是一个方法，即一个对象的一部分，那么<code class="fe lz ma mb lo b">this</code>将引用调用该方法的对象。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="6202" class="ls lt in lo b gy lu lv l lw lx">let person = {<br/>  name : "John",<br/>  walk : function(){ console.log(<strong class="lo io">this.name</strong> + " walking") }<br/>}</span><span id="cf68" class="ls lt in lo b gy ly lv l lw lx">person.walk(); //John walking </span></pre><p id="a7e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相反，如果我们有一个简单的函数而不是方法，那么默认情况下，<code class="fe lz ma mb lo b">this</code>将被设置为<strong class="kq io">窗口的</strong>对象。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="7345" class="ls lt in lo b gy lu lv l lw lx">function test(){<br/>   console.log(this);    //Returns the window object   <br/>   return this;<br/>}</span><span id="5476" class="ls lt in lo b gy ly lv l lw lx">test() === window;  //true</span></pre><p id="c1db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您在<strong class="kq io">严格模式</strong>下运行相同的测试功能，这将被设置为<code class="fe lz ma mb lo b"><strong class="kq io">undefined</strong></code>。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="5aa0" class="ls lt in lo b gy lu lv l lw lx">function test(){<br/>   'use strict'; <br/>   console.log(this);  //undefined<br/>   return this;<br/>}</span><span id="f9a3" class="ls lt in lo b gy ly lv l lw lx">test() === window;  //false</span></pre><p id="a2b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它返回<code class="fe lz ma mb lo b">undefined</code>的原因是该函数被直接调用，而不是作为一个对象的属性，在本例中，该对象是<strong class="kq io">窗口</strong>对象。<br/>因为它是在严格模式下运行的，所以你需要调用方法的对象被完美地映射到上下文中(<code class="fe lz ma mb lo b">this</code>)。所以当<code class="fe lz ma mb lo b">test() === window</code>可能返回false时，<code class="fe lz ma mb lo b"><strong class="kq io">window.test()</strong> == window</code>将返回true。</p><h2 id="9740" class="ls lt in bd mc md me dn mf mg mh dp mi kx mj mk ml lb mm mn mo lf mp mq mr ms bi translated">3.“这个”在一个类里面</h2><p id="a181" class="pw-post-body-paragraph ko kp in kq b kr mt jo kt ku mu jr kw kx mv kz la lb mw ld le lf mx lh li lj ig bi translated">类内部的<code class="fe lz ma mb lo b">this</code>的行为几乎类似于函数的行为，因为类本质上是幕后的函数。在一个类构造函数中，<code class="fe lz ma mb lo b">this</code>将是创建的实例，就像我们在这篇博文的第一个例子中看到的一样。</p><p id="24fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果用关键字<code class="fe lz ma mb lo b">new</code>调用，你在下面的例子中看到的函数将作为一个构造函数。因此，虽然它在这里看起来不像一个类，但它会产生相同的结果。</p><p id="42d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我之所以在这里包含这个类函数的例子，而不是一个合适的类，是因为当你使用和不使用<code class="fe lz ma mb lo b">new</code>关键字调用这个函数时，<code class="fe lz ma mb lo b">this</code>的值会改变。对于一个类，没有<code class="fe lz ma mb lo b">new</code>关键字就不能运行它。JS引擎将抛出一个错误。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="259f" class="ls lt in lo b gy lu lv l lw lx">function Employee(name) {<br/>    this.name = name;<br/>}  //implicitly returns the object instance if called with the new keyword</span><span id="4c18" class="ls lt in lo b gy ly lv l lw lx">let e1 = new Employee("Abcd");   //{ name : "Abcd" }</span></pre><p id="2cb9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果调用Employee函数时没有使用<code class="fe lz ma mb lo b">new</code>关键字，那么<code class="fe lz ma mb lo b">this</code>值将不会是类实例。而是将<code class="fe lz ma mb lo b">this</code>的值设置为默认值，即<strong class="kq io">窗口</strong>对象。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="8797" class="ls lt in lo b gy lu lv l lw lx">function Employee(name) {<br/>    this.name = name;<br/>}  //implicitly return the object instance if called with the new keyword</span><span id="e5ce" class="ls lt in lo b gy ly lv l lw lx">let e1 = Employee("Abcd");  //undefined because the function only implicitly returns an object if called with the new keyword</span></pre><p id="6b8b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以通过在窗口对象中查找<strong class="kq io">名称属性</strong>来验证<code class="fe lz ma mb lo b">this</code>是否引用了窗口对象。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/ed14761cfb99653ede2baf4dcaa3d3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFZhvqZj7BsKGTFc9fJtyg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">name property attached to the window object</figcaption></figure><h2 id="9403" class="ls lt in bd mc md me dn mf mg mh dp mi kx mj mk ml lb mm mn mo lf mp mq mr ms bi translated">4.“这个”内部箭头功能</h2><p id="d8cd" class="pw-post-body-paragraph ko kp in kq b kr mt jo kt ku mu jr kw kx mv kz la lb mw ld le lf mx lh li lj ig bi translated">arrow functions中的<code class="fe lz ma mb lo b">this</code>关键字是指包含该函数的词法范围。所以如果你在全局范围内创建箭头函数，<code class="fe lz ma mb lo b">this</code>将总是被设置为全局(窗口)对象。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="376e" class="ls lt in lo b gy lu lv l lw lx">//Global scope <br/>let global = this  //window object inside this variable<br/>var foo = () =&gt; this;<br/>foo() == global //true   </span></pre><p id="6f59" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你看下面的例子，我们有一个箭头函数作为对象内部的方法。现在，当这个方法试图寻找<code class="fe lz ma mb lo b">this.model</code>时，<code class="fe lz ma mb lo b">this</code>值寻找封闭的词法范围，在本例中是全局范围。所以它将<code class="fe lz ma mb lo b">this</code>的值设置为窗口对象。它还返回undefined，因为没有将<strong class="kq io">模型</strong>属性附加到窗口对象。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="521a" class="ls lt in lo b gy lu lv l lw lx">const car = {<br/>  model : "BMW",<br/>  start : () =&gt; console.log(`${this.model} go brrr`)<br/>}</span><span id="2167" class="ls lt in lo b gy ly lv l lw lx">car.start()  //undefined go brrr</span></pre><p id="0cac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">解决这个问题的一个方法是对arrow函数使用一个包装函数，然后在包装函数内部调用它。</p><pre class="kd ke kf kg gt ln lo lp lq aw lr bi"><span id="ed9a" class="ls lt in lo b gy lu lv l lw lx">const car = {<br/>  model : "BMW",<br/>  <strong class="lo io">start(){<br/>   const f = () =&gt; console.log(`${this.model} go brrr`);<br/>   f();<br/>  }</strong> <br/>}<br/>car.start()  //BMW go brrr</span></pre><p id="59e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，当您调用arrow函数时，它将查看其父级的词法范围，在本例中是start方法，由于start方法的上下文指向car对象，您的方法将返回<code class="fe lz ma mb lo b">this.model</code>的预期值。</p><h2 id="27d8" class="ls lt in bd mc md me dn mf mg mh dp mi kx mj mk ml lb mm mn mo lf mp mq mr ms bi translated">结论</h2><p id="5fdb" class="pw-post-body-paragraph ko kp in kq b kr mt jo kt ku mu jr kw kx mv kz la lb mw ld le lf mx lh li lj ig bi translated">这主要总结了<code class="fe lz ma mb lo b">this</code>在JavaScript中的工作方式。你可以看到，它不仅仅是一个类实例的引用，就像Java一样。这不是你马上就能理解的话题之一。尝试在不同的场景中使用它，以便更好地掌握它。<br/> <br/> <a class="ae nd" href="https://youtu.be/KLq5nihWRVg" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">如果你通过看视频学得更好，我有这篇博文的视频版，你可以在youtube上看。</strong>T12】</a></p><p id="5cbf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何其他疑问或建议，你可以在评论中提出，或者通过我的任何社交媒体渠道与我联系。干杯！</p><p id="4fcc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae nd" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/><a class="ae nd" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae nd" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/>T22】GitHub</p><p id="8dc0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容请看</em><a class="ae nd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a><em class="lk">。报名参加我们的</em> <a class="ae nd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。关注我们关于</em><a class="ae nd" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">Twitter</em></strong></a><em class="lk">和</em><strong class="kq io"><em class="lk"/></strong><a class="ae nd" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">。加入我们的</em> <a class="ae nd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">社区</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>