<html>
<head>
<title>How to Check Whether an Element is in the Viewport or Not?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检查一个元素是否在视口中？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-check-whether-an-element-is-in-the-viewport-or-not-eb5de51c0201?source=collection_archive---------6-----------------------#2022-07-29">https://javascript.plainenglish.io/how-to-check-whether-an-element-is-in-the-viewport-or-not-eb5de51c0201?source=collection_archive---------6-----------------------#2022-07-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1419" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用一种简洁的方式(交叉点观察器API)来确定元素在视口中的可见性。</h2></div><p id="e46f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在开发网站/web应用程序时，您可能会遇到一个重复出现的问题，即您希望根据元素是否在视口中来执行一些操作。这种情况在交互式网站中很常见。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/9ff49079284a7a1da69db015661f8fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q_To5bW2DnGsddC6"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@mattseymour?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Seymour</a> on <a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3be8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将探索一种在视口中检查元素可见性的方法。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="4327" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了确定元素的可见性，我们将使用一个名为<code class="fe lw lx ly lz b">Intersection Observer API</code>的浏览器API。</p><p id="9b60" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在浏览器中引入<code class="fe lw lx ly lz b">Intersection Observer API</code>之前，人们已经使用了元素的方法，如<code class="fe lw lx ly lz b">Element.getBoundingClientRect()</code>、事件等..确定元素的可见性。这种方法也带来了一些性能问题，因为我们必须监听事件并相应地不断调用方法。如果我们增加检查可见性的元素数量，性能过载就会增加。</p><h1 id="b287" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated"><strong class="ak">路口观察器API </strong></h1><p id="15e6" class="pw-post-body-paragraph kc kd in ke b kf ms jo kh ki mt jr kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">它提供了一种异步观察目标元素与祖先元素或顶级文档视窗的交集变化的方法。</p><h2 id="bbb8" class="mx mb in bd mc my mz dn mg na nb dp mk kl nc nd mm kp ne nf mo kt ng nh mq ni bi translated">检查兼容性</h2><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nj"><img src="../Images/aa2e6c81a9bc8840ac9a5d41952e8cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vhaItH04dQvZpaWRt-DWQ.png"/></div></div></figure><p id="9b9a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上图可以看出，除了IE (Internet Explorer)之外，几乎所有浏览器的最新版本都支持交叉点观察器API。不会有支持不支持的问题</p><p id="ee9d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以在<code class="fe lw lx ly lz b">https://caniuse.com</code>或点击下面提供的链接，探索交叉点观察器API的其他方面。</p><div class="nk nl gp gr nm nn"><a href="https://caniuse.com/?search=Intersection%20Observer%20API" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">“交叉点观察器API”|我可以使用吗...HTML5、CSS3等的支持表</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">“我可以使用吗”提供了最新的浏览器支持表，以支持桌面和移动设备上的前端web技术…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">caniuse.com</p></div></div></div></a></div><h2 id="c95a" class="mx mb in bd mc my mz dn mg na nb dp mk kl nc nd mm kp ne nf mo kt ng nh mq ni bi translated">路口观测器的实现</h2><p id="a7c2" class="pw-post-body-paragraph kc kd in ke b kf ms jo kh ki mt jr kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">为了实现交集观察者，我们需要一个目标元素&amp;交集观察者来观察目标元素的可见性。</p><p id="f92d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里了解更多关于十字路口观察器的信息</p><div class="nk nl gp gr nm nn"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">交叉点观察器API-Web API | MDN</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">交叉点观察器API提供了一种异步观察目标元素交叉点变化的方法…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">developer.mozilla.org</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob li nn"/></div></div></a></div><p id="32e9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过这些简单的步骤实现交叉点观察器。</p><ol class=""><li id="1381" class="oc od in ke b kf kg ki kj kl oe kp of kt og kx oh oi oj ok bi translated">创建一个观察者</li></ol><pre class="kz la lb lc gt ol lz om on aw oo bi"><span id="dfff" class="mx mb in lz b gy op oq l or os">const options = {<br/>    root: null,<br/>    threshold: 0.5<br/>};<br/>const callback = function(entries, observer) {<br/>     entries.forEach((entry) =&gt; {<br/>        console.log(entry.isIntersecting);<br/>     });<br/>}</span><span id="5731" class="mx mb in lz b gy ot oq l or os">let observer = new <!-- -->IntersectionObserver(callback, options);</span></pre><p id="e7dd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里你可以看到我们已经通过了<code class="fe lw lx ly lz b">options</code>和<code class="fe lw lx ly lz b">callback</code>来创建一个观察者。在选项中，<code class="fe lw lx ly lz b">root</code>的值是<code class="fe lw lx ly lz b">null</code>，这意味着它将视口作为参考来确定可见性。<code class="fe lw lx ly lz b">threshold</code>值为<code class="fe lw lx ly lz b">0.5</code>，表示如果目标可见性超过50%，则<code class="fe lw lx ly lz b">callback</code>将被调用。</p><p id="a989" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回调函数有两个参数，<code class="fe lw lx ly lz b">entries</code>和<code class="fe lw lx ly lz b">observer</code>。<code class="fe lw lx ly lz b">entries</code>是<code class="fe lw lx ly lz b">IntersectionObserverEntry</code>类型对象的列表。</p><p id="7bc7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.选择一个目标并观察它</p><pre class="kz la lb lc gt ol lz om on aw oo bi"><span id="8839" class="mx mb in lz b gy op oq l or os">const target = document.getElementById("target");<br/>observer.observe(target);</span></pre><p id="03ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仅此而已。</p><h1 id="a807" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">检查元素对视口是否可见</h1><p id="d7fd" class="pw-post-body-paragraph kc kd in ke b kf ms jo kh ki mt jr kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">为了检查一个元素是否在视口中，我们将<code class="fe lw lx ly lz b">threshold</code>的值设置为<code class="fe lw lx ly lz b">0</code>。这样，元素一进入或离开视口，回调就被调用</p><pre class="kz la lb lc gt ol lz om on aw oo bi"><span id="d40a" class="mx mb in lz b gy op oq l or os">const target = document.getElementById("target");<br/>function callback(entries, observer) {<br/>     entries.forEach((entry) =&gt; {<br/>       if(entry.isIntersecting) {<br/>         console.log("visible"); <br/>       } else {<br/>         console.log("not visible");<br/>       }<br/>    });<br/>}<br/>function createObserver(target, callback) {<br/>   const options = {<br/>      root: null,<br/>      threshold: <strong class="lz io">0</strong><br/>   };<br/>   const observer = new IntersectionObserver(callback, options);<br/>   observer.observe(target);<br/>}<br/>  <br/>createObserver(target, callback);</span></pre><p id="c651" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查看此处的工作示例:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Check if the element is visible or not</figcaption></figure><h1 id="65bb" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">检查元素在视口中是否完全可见</h1><p id="88c0" class="pw-post-body-paragraph kc kd in ke b kf ms jo kh ki mt jr kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">为了检查一个元素是否完全可见，我们将<code class="fe lw lx ly lz b">threshold</code>的值设置为<code class="fe lw lx ly lz b">1</code>。这样，一旦整个元素进入视口或完全离开视口，回调就会被调用。</p><pre class="kz la lb lc gt ol lz om on aw oo bi"><span id="25f1" class="mx mb in lz b gy op oq l or os">const target = document.getElementById("target");</span><span id="dece" class="mx mb in lz b gy ot oq l or os">function callback(entries, observer) {<br/>     entries.forEach((entry) =&gt; {<br/>       if(entry.isIntersecting) {<br/>         console.log("Fully visible"); <br/>       } else {<br/>         console.log("not fully visible");<br/>       }<br/>    });<br/>}</span><span id="29d5" class="mx mb in lz b gy ot oq l or os">function createObserver(target, callback) {<br/>   const options = {<br/>      root: null,<br/>      threshold: 1<br/>   };<br/>   const observer = new IntersectionObserver(callback, options);<br/>   observer.observe(target);<br/>}<br/>  <br/>createObserver(target, callback);</span></pre><p id="ec3b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查看此处的工作示例。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Check if the element is fully visible or not</figcaption></figure><p id="da12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你喜欢这篇文章。</p><p id="79df" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读。坚持阅读，坚持解决问题。谢谢你。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="cb0b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ow">更多内容请看</em><a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ow">plain English . io</em></strong></a><em class="ow">。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ow">免费周报</em> </strong> </a> <em class="ow">。关注我们关于</em><a class="ae lo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ow">Twitter</em></strong></a><strong class="ke io"><em class="ow"/></strong><em class="ow">和</em><a class="ae lo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ow">LinkedIn</em></strong></a><em class="ow">。查看我们的</em> <a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ow">社区不和谐</em> </strong> </a> <em class="ow">加入我们的</em> <a class="ae lo" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ow">人才集体</em> </strong> </a> <em class="ow">。</em></p></div></div>    
</body>
</html>