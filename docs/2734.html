<html>
<head>
<title>What the Heck is a ‘Thunk’ and What’s ‘Currying’ in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的“Thunk”和“Currying”到底是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-the-heck-is-a-thunk-and-what-s-currying-5b166c8a25a9?source=collection_archive---------5-----------------------#2022-06-30">https://javascript.plainenglish.io/what-the-heck-is-a-thunk-and-what-s-currying-5b166c8a25a9?source=collection_archive---------5-----------------------#2022-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/a0308b41b4ab2bdd682e72fb62afbe84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_RIWl_ZAYLta9G9QtBbsA.png"/></div></div></figure><div class=""/><div class=""><h2 id="c6ee" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">揭开Thunks和Currying的神秘面纱JavaScript中一些最重要的函数式编程概念！</h2></div><p id="0694" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我敢肯定，当你第一次听说编程中的<strong class="kp iz"> thunks </strong>或<strong class="kp iz">curry</strong>这样的术语时，你的反应应该是这样的:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/abef492815caa2b487658c0bf9c6983c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*pgVEo6kDkCq0BiqW.gif"/></div></figure><p id="7528" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">好吧，别担心，当我第一次听到这些术语时，我也有同样的感觉，特别是从编程方面，直到我意识到它们有多么有用！</p><p id="c79e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在我们开始之前，这篇博文假设您对JavaScript和使用承诺和回调的异步编程有基本的了解。一些关于JavaScript函数式编程的知识对于更好地理解这两个概念也很有帮助。对于JavaScript中的<strong class="kp iz">函数式编程</strong>，Thunks 和<strong class="kp iz">curry</strong>是非常有用的概念。</p><p id="3a00" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们更深入地了解这些概念，理解它们是什么，以及如何使用它们！</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="2a35" class="lv lw iy bd lx ly lz ma mb mc md me mf ke mg kf mh kh mi ki mj kk mk kl ml mm bi translated">关于JavaScript中的<code class="fe mn mo mp mq b">thunks</code></h1><p id="fdf7" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">我们在JavaScript中几乎到处都在使用<strong class="kp iz">回调</strong>，用于各种用例，比如<strong class="kp iz">异步编程</strong>、<strong class="kp iz">监听事件</strong>、<strong class="kp iz">处理错误</strong>等等。Thunks基本上<em class="mw">扩展了回调</em>的功能，在JavaScript的异步编程中非常有用，尽管它们在某些涉及同步编程的场景中仍然非常有用。</p><h1 id="81c2" class="lv lw iy bd lx ly mx ma mb mc my me mf ke mz kf mh kh na ki mj kk nb kl ml mm bi translated">什么是<code class="fe mn mo mp mq b">thunk</code>？</h1><p id="684e" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">一个<strong class="kp iz"> thunk </strong>只是一个延迟一个值或一些逻辑的计算的函数。</p><blockquote class="nc nd ne"><p id="cfd1" class="kn ko mw kp b kq kr jz ks kt ku kc kv nf kx ky kz ng lb lc ld nh lf lg lh li ig bi translated">单词“thunk”是一个编程术语，意思是“一段做一些延迟工作的代码”。</p></blockquote><p id="d05f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们可以写一个函数体或代码，用于以后执行工作，而不是现在执行一些逻辑。许多使用React的人可能知道一个非常棒的简单的库，叫做redux-thunk，顾名思义，它是基于thunks的，在使用redux进行状态管理时非常有用。</p><p id="4480" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">有两种视角可以使用thunks: <strong class="kp iz">同步</strong>，和<strong class="kp iz">异步</strong>。</p><h1 id="a668" class="lv lw iy bd lx ly mx ma mb mc my me mf ke mz kf mh kh na ki mj kk nb kl ml mm bi translated">同步使用方式<code class="fe mn mo mp mq b">thunks</code></h1><p id="735e" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">让我们来谈谈如何使用<strong class="kp iz">同步thunk </strong>，</p><pre class="lk ll lm ln gt ni mq nj nk aw nl bi"><span id="6e65" class="nm lw iy mq b gy nn no l np nq">const power = (base, exponent) =&gt; {<br/>  return Math.pow(base, exponent);<br/>};<br/><br/>// `power` function is evaluated<br/>// and the result is returned immediately<br/>console.log(power(99, 9)); // 913517247483640800<br/><br/>// This is a thunk<br/>const powerThunk = () =&gt; {<br/>  return power(99, 9);<br/>};<br/><br/>// Returns the same result as calling the `power` function<br/>console.log(powerThunk()); // 913517247483640800</span></pre><p id="bf5a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上面的代码片段<code class="fe mn mo mp mq b">power</code>是一个简单的函数，它计算一个数的幂并立即返回计算出的值。<code class="fe mn mo mp mq b">powerThunk</code>是一个<strong class="kp iz">同步thunk </strong>，它延迟这个结果直到我们调用它。您可能已经注意到，<code class="fe mn mo mp mq b">powerThunk</code>在内部使用<code class="fe mn mo mp mq b">power</code>函数来计算并返回计算出的值。</p><p id="7522" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">重要的是，这个thunk已经成为某个特定状态的包装器。在这种情况下，这是一个潜在的昂贵操作的结果。这种模式允许我们隐藏计算的内部细节，类似于<strong class="kp iz">面向对象编程</strong>范例的<a class="ae nr" href="https://www.sumologic.com/glossary/encapsulation/#:~:text=What%20does%20encapsulation%20mean%3A%20In,in%20the%20form%20of%20classes." rel="noopener ugc nofollow" target="_blank">封装</a>的原理。</p><p id="c9dc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在让我们从异步编程的角度来谈谈如何使用thunks。</p><h1 id="272e" class="lv lw iy bd lx ly mx ma mb mc my me mf ke mz kf mh kh na ki mj kk nb kl ml mm bi translated">异步<code class="fe mn mo mp mq b">thunks</code></h1><p id="67d5" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">那么我们如何描述一个<strong class="kp iz">异步thunk </strong>？这只是一个简单的函数，除了一个<strong class="kp iz">回调函数</strong>，不需要任何额外的参数。在异步thunks的情况下，我们可以引入一个延迟来处理一个同步函数，比如前面例子中的<code class="fe mn mo mp mq b">power</code>函数，或者用它来处理异步API调用。</p><p id="1f85" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们来看看这两种情况。为了更好地理解这一点，我们可以修改前面的<strong class="kp iz">同步thunk </strong>示例。</p><pre class="lk ll lm ln gt ni mq nj nk aw nl bi"><span id="a4f8" class="nm lw iy mq b gy nn no l np nq">const powerAsync = (base, exponent, callback) =&gt; {<br/>  return setTimeout(() =&gt; callback(Math.pow(base, exponent)), 1000);<br/>};<br/><br/>// This is an async thunk<br/>const powerAsyncThunk = (callback) =&gt; {<br/>  return function () {<br/>    powerAsync(99, 9, callback);<br/>  };<br/>};<br/><br/>// This async thunk now returns a function that <br/>// can be called later on to calculate power.<br/>const calculatePower = powerAsyncThunk((result) =&gt; console.log(result));<br/>calculatePower();</span></pre><p id="17f0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在上面的代码片段中，我们将<code class="fe mn mo mp mq b">power</code>函数修改为<code class="fe mn mo mp mq b">powerAsync</code>函数，即<strong class="kp iz">使用<code class="fe mn mo mp mq b">setTimeout</code>伪造一个异步函数</strong>，并带一个附加参数<code class="fe mn mo mp mq b">callback</code>。现在，我们的异步thunk <code class="fe mn mo mp mq b">powerAsyncThunk</code>通过返回一个函数来延迟<code class="fe mn mo mp mq b">powerAsync</code>函数的执行。这使得它非常有用，因为我们现在可以在以后的代码中随时调用这个由<code class="fe mn mo mp mq b">powerAsyncThunk</code>返回的函数。</p><p id="6cab" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在，我们来谈谈如何使用<strong class="kp iz">异步thunks </strong>来处理<strong class="kp iz">异步API调用</strong>。</p><pre class="lk ll lm ln gt ni mq nj nk aw nl bi"><span id="4eb2" class="nm lw iy mq b gy nn no l np nq">const fetchCurrenciesData = (callback) =&gt; {<br/>  fetch("https://cdn.jsdelivr.net/gh/fawazahmed0/currency-api@1/latest/currencies.json")<br/>  .then(res =&gt; res.json())<br/>  .then(res =&gt; callback(res));<br/>}<br/><br/>// This is an async thunk<br/>const asyncThunk = (callback) =&gt; {<br/>  return function () {<br/>    fetchCurrenciesData(callback);<br/>  }<br/>}<br/><br/>// This async thunk now returns a function that <br/>// can be called later on to fetch data from the API.<br/>const fetchCurrencies = asyncThunk((res) =&gt; console.log(res));<br/>fetchCurrencies();</span></pre><p id="74dc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><code class="fe mn mo mp mq b">fetchCurrenciesData</code>函数调用一个API来获取不同国家的所有货币，并接受一个<code class="fe mn mo mp mq b">callback</code>函数作为参数。async thunk <code class="fe mn mo mp mq b">asyncThunk</code>返回一个函数，以后只要我们想在代码中使用这个函数，就可以从API中获取数据。</p><p id="145b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">调用<code class="fe mn mo mp mq b">fetchCurrencies</code>函数后的数据如下:</p><pre class="lk ll lm ln gt ni mq nj nk aw nl bi"><span id="5915" class="nm lw iy mq b gy nn no l np nq">{<br/>aave: "Aave"<br/>ada: "Cardano"<br/>aed: "United Arab Emirates Dirham"<br/>afn: "Afghan afghani"<br/>algo: "Algorand"<br/>doge: "Dogecoin"<br/>dop: "Dominican peso"<br/>dot: "Dotcoin"<br/>dzd: "Algerian dinar"<br/>egld: "Elrond"<br/>egp: "Egyptian pound"<br/>enj: "Enjin Coin"<br/>eos: "EOS"<br/>ern: "Eritrean nakfa"<br/>etb: "Ethiopian birr"<br/>ils: "Israeli New Shekel"<br/>imp: "CoinIMP"<br/>inj: "Injective"<br/>inr: "Indian rupee"<br/>iqd: "Iraqi dinar"<br/>irr: "Iranian rial"<br/>isk: "Icelandic króna"<br/>jep: "Jersey Pound"<br/>jmd: "Jamaican dollar"<br/>jod: "Jordanian dinar"<br/>jpy: "Japanese yen"<br/>kava: "Kava"<br/>kcs: "Kucoin"<br/>kda: "Kadena"<br/>kes: "Kenyan shilling"<br/>...<br/>}<!-- --> </span></pre><h1 id="bc30" class="lv lw iy bd lx ly mx ma mb mc my me mf ke mz kf mh kh na ki mj kk nb kl ml mm bi translated"><code class="fe mn mo mp mq b">thunks</code>到底用在哪里？💡</h1><p id="92b8" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">既然你已经学习了很多关于thunks的知识，你可能想知道<strong class="kp iz"> thunks </strong>到底用在哪里。</p><ul class=""><li id="97be" class="ns nt iy kp b kq kr kt ku kw nu la nv le nw li nx ny nz oa bi translated">JavaScript中的<strong class="kp iz">承诺</strong>是基于<strong class="kp iz"> thunks </strong>的概念，在幕后，它使用thunks。看看这个<a class="ae nr" href="https://youtu.be/EhyuWntGA8s" rel="noopener ugc nofollow" target="_blank">视频</a>，它讲述了如何使用<strong class="kp iz"> thunks </strong>对异步函数调用进行排序。</li><li id="5259" class="ns nt iy kp b kq ob kt oc kw od la oe le of li nx ny nz oa bi translated"><a class="ae nr" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>中间件<strong class="kp iz">内部广泛使用thunk</strong>。这使我们能够使用带有异步逻辑的<strong class="kp iz"> thunks </strong>，它可以<strong class="kp iz">与Redux store的</strong> <code class="fe mn mo mp mq b">dispatch</code>和<code class="fe mn mo mp mq b">getState</code>方法进行交互，以便React应用程序使用<strong class="kp iz"> Redux </strong>进行状态管理。</li></ul></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="5ff0" class="lv lw iy bd lx ly lz ma mb mc md me mf ke mg kf mh kh mi ki mj kk mk kl ml mm bi translated">关于JavaScript中的Currying</h1><p id="ea1b" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">让我们看看JavaScript函数式编程中另一个非常有用的概念。</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/0cb5f370613a36ce0c594134f5714997.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*YAzCood4uEqML5X7.gif"/></div></figure><p id="5683" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><strong class="kp iz"> Currying </strong>是一种使用函数的高级技术。它不仅在JavaScript中使用，也在其他语言中使用！</p><h1 id="8a1b" class="lv lw iy bd lx ly mx ma mb mc my me mf ke mz kf mh kh na ki mj kk nb kl ml mm bi translated">什么是Currying？</h1><blockquote class="nc nd ne"><p id="1449" class="kn ko mw kp b kq kr jz ks kt ku kc kv nf kx ky kz ng lb lc ld nh lf lg lh li ig bi translated"><strong class="kp iz"><em class="iy">Currying</em></strong><em class="iy">是将一个函数从可调用的</em> <code class="fe mn mo mp mq b"><em class="iy">f(a, b, c)</em></code> <em class="iy">转换为可调用的</em> <code class="fe mn mo mp mq b"><em class="iy">f(a)(b)(c)</em></code> <em class="iy">的函数转换。</em></p></blockquote><p id="30a1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们正在<strong class="kp iz">通过<strong class="kp iz">分解</strong>来转换</strong>函数，这样就可以一步一步地调用<strong class="kp iz">函数</strong>，而不是立即用所有的参数调用它。这种技术非常有用，特别是当你不能立刻访问所有需要的参数来执行函数中的逻辑时。</p><p id="8465" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们看一个例子来更好地理解这一点。假设，我们创建一个简单的函数<code class="fe mn mo mp mq b">multiplyTwoNos</code>，将两个no相乘并返回计算出的值。</p><pre class="lk ll lm ln gt ni mq nj nk aw nl bi"><span id="aa75" class="nm lw iy mq b gy nn no l np nq">const multiplyTwoNos = (no1, no2) =&gt; {<br/>  return no1 * no2;<br/>};<br/><br/>console.log(multiplyTwoNos(3, 5)); // 15<br/><br/>// A curried function to multiple two nos<br/>const curriedMultiplyTwoNos = function (no1) {<br/>  return function (no2) {<br/>    return no1 * no2;<br/>  };<br/>};<br/><br/>console.log(curriedMultiplyTwoNos(3)(5)); // 15</span></pre><p id="8394" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在上面的代码片段中，<code class="fe mn mo mp mq b">curriedMultiplyTwoNos</code>是一个使用<strong class="kp iz">curry</strong>将<code class="fe mn mo mp mq b">multiplyTwoNos(3, 5)</code>函数调用转换成类似于<code class="fe mn mo mp mq b">curriedMultiplyTwoNos(3)(5)</code>的函数调用。输出基本上是相同的，但是当我们可以访问两个数时，currying<strong class="kp iz">给了我们更多的灵活性来计算两个数的乘积。</strong></p><h1 id="138a" class="lv lw iy bd lx ly mx ma mb mc my me mf ke mz kf mh kh na ki mj kk nb kl ml mm bi translated">高级Currying实现</h1><p id="97fc" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">现在，让我们来看看多参数函数的<strong class="kp iz">的<strong class="kp iz">高级实现</strong>。我们将首先创建一个通用的<strong class="kp iz"> currying </strong>函数，然后使用上面的例子将一些数字相乘并得到计算值。</strong></p><pre class="lk ll lm ln gt ni mq nj nk aw nl bi"><span id="79e0" class="nm lw iy mq b gy nn no l np nq">// A function that takes a callback function `func` <br/>// that defines the kind of operation that will be curried.</span><span id="84b8" class="nm lw iy mq b gy og no l np nq">const curry = function (func) {<br/>  return function curried (...args) {<br/>    // Ensure that we apply the operation defined by `func` <br/>    // with the max number of arguments supported by `func`.</span><span id="e179" class="nm lw iy mq b gy og no l np nq">    if(args.length &gt;= func.length) {<br/>      return func.apply(this, args);<br/>    } else {<br/>      // If number of parameters are insufficient to call `func` to <br/>      // perform the operation, recursively call `curried` with previously passed<br/>      // parameters as well as new parameters. <br/>      return function (...args2) {<br/>        return curried.apply(this, args.concat(args2));<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="8d75" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上面的代码中发生了很多事情！😅</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b328eb3e816f0aa31dff850d1f2a3f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/0*yO3B7mMoWDhlVzZJ.gif"/></div></figure><p id="3d2c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">但是，不要因为看到上面的代码而不知所措，它实际上非常简单！让我们用一个例子来看看它是如何工作的，然后我们会正确地理解它。</p><pre class="lk ll lm ln gt ni mq nj nk aw nl bi"><span id="4fb3" class="nm lw iy mq b gy nn no l np nq">const multiplyThreeNos = (no1, no2, no3) =&gt; {<br/>  return no1 * no2 * no3;<br/>};<br/><br/>let curriedMultiplication = curry(multiplyThreeNos);<br/><br/>console.log(curriedMultiplication(4, 5, 6)); // 120, still callable normally<br/>console.log(curriedMultiplication(4)(5, 6)); // 120, currying of 1st arg<br/>console.log(curriedMultiplication(4)(5)(6)); // 120, full currying</span></pre><p id="5955" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><code class="fe mn mo mp mq b">curry(func)</code>调用的结果是包装器<code class="fe mn mo mp mq b">curried</code>,如下所示:</p><pre class="lk ll lm ln gt ni mq nj nk aw nl bi"><span id="e38f" class="nm lw iy mq b gy nn no l np nq">function curried(...args) {<br/>    // Ensure that we apply the operation defined by `func`<br/>    // with the max number of arguments supported by `func`.</span><span id="d8f1" class="nm lw iy mq b gy og no l np nq">    if (args.length &gt;= func.length) {<br/>      return func.apply(this, args);<br/>    } else {<br/>      // If number of parameters are insufficient to call `func` to<br/>      // perform the operation, recursively call `curried` with previously passed<br/>      // parameters as well as new parameters.<br/>      return function (...args2) {<br/>        return curried.apply(this, args.concat(args2));<br/>      };<br/>    }<br/>  };</span></pre><p id="20a1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在上面的代码中，我们使用了一些概念，如<a class="ae nr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest参数</a>、<strong class="kp iz">递归</strong>和<a class="ae nr" href="https://www.freecodecamp.org/news/understand-call-apply-and-bind-in-javascript-with-examples/" rel="noopener ugc nofollow" target="_blank">。应用()</a>。</p><p id="cd77" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">基本上有两个代码分支，因为有了<code class="fe mn mo mp mq b">if</code>语句，其中一个可以在<code class="fe mn mo mp mq b">curried</code>函数中执行。</p><ul class=""><li id="20cc" class="ns nt iy kp b kq kr kt ku kw nu la nv le nw li nx ny nz oa bi translated">如果传递给<code class="fe mn mo mp mq b">curried</code>的参数数量<strong class="kp iz">大于或等于</strong>为<code class="fe mn mo mp mq b">func</code>定义的参数数量，那么只需将调用传递给<code class="fe mn mo mp mq b">func.apply(this, args);</code>，它将忽略传递的额外参数(如果有)。</li><li id="455f" class="ns nt iy kp b kq ob kt oc kw od la oe le of li nx ny nz oa bi translated">否则，如果传递给<code class="fe mn mo mp mq b">curried</code>的参数数量较少，那么我们通过使用<code class="fe mn mo mp mq b">.concat()</code>方法，用<strong class="kp iz">先前传递的参数</strong>以及<strong class="kp iz">新的参数</strong>递归调用<code class="fe mn mo mp mq b">curried</code>，直到<code class="fe mn mo mp mq b">curried</code>的参数数量不足以满足<code class="fe mn mo mp mq b">func</code>的定义。</li></ul><blockquote class="nc nd ne"><p id="f36a" class="kn ko mw kp b kq kr jz ks kt ku kc kv nf kx ky kz ng lb lc ld nh lf lg lh li ig bi translated"><strong class="kp iz"> <em class="iy">注</em></strong><em class="iy">:</em><strong class="kp iz"><em class="iy"/></strong><em class="iy">要求函数要有一个</em><strong class="kp iz"><em class="iy"/></strong><em class="iy">固定个数的自变量。一个使用rest参数的函数，比如</em> <code class="fe mn mo mp mq b"><em class="iy">f(...args)</em></code> <em class="iy">，不能像上面实现的那样进行编译。</em></p></blockquote><h1 id="b44c" class="lv lw iy bd lx ly mx ma mb mc my me mf ke mz kf mh kh na ki mj kk nb kl ml mm bi translated">什么时候以及为什么要使用Currying？💡</h1><p id="86bb" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">谄媚对以下情况很有用:</p><ul class=""><li id="51af" class="ns nt iy kp b kq kr kt ku kw nu la nv le nw li nx ny nz oa bi translated">当您想要创建一个只接收单个参数的函数或者稍后在代码中接收参数的函数时，可以使用Currying。</li><li id="f1c6" class="ns nt iy kp b kq ob kt oc kw od la oe le of li nx ny nz oa bi translated">它可用于触发事件侦听器。</li></ul><p id="55f8" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们看看为什么你可能需要使用Currying的一些原因:</p><ul class=""><li id="0a3b" class="ns nt iy kp b kq kr kt ku kw nu la nv le nw li nx ny nz oa bi translated">Currying提供了一种方法，可以确保在执行函数的核心逻辑之前，函数接收到所有的参数。</li><li id="a0dc" class="ns nt iy kp b kq ob kt oc kw od la oe le of li nx ny nz oa bi translated">它将您的职能划分为多个较小的职能，可以处理一项职责。这使得你的函数更纯粹，更不容易出错和产生副作用。</li><li id="c49c" class="ns nt iy kp b kq ob kt oc kw od la oe le of li nx ny nz oa bi translated">它在函数式编程范例中用于创建<a class="ae nr" href="https://dmitripavlutin.com/javascript-higher-order-functions/" rel="noopener ugc nofollow" target="_blank">高阶函数</a>。</li></ul></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="8499" class="lv lw iy bd lx ly lz ma mb mc md me mf ke mg kf mh kh mi ki mj kk mk kl ml mm bi translated">结论</h1><p id="3d7c" class="pw-post-body-paragraph kn ko iy kp b kq mr jz ks kt ms kc kv kw mt ky kz la mu lc ld le mv lg lh li ig bi translated">在这篇博客中，我们学习了<strong class="kp iz"> thunks </strong>和<strong class="kp iz">curry</strong>，这是JavaScript中函数式编程的一些最有用但有点先进的概念。我们详细的讨论了<strong class="kp iz"> thunks </strong>像什么是<strong class="kp iz"> thunks </strong>，怎么用，什么时候用，用在什么地方。同样，我们学习了<strong class="kp iz">curring</strong>，如何实现<strong class="kp iz">curring</strong>，<strong class="kp iz">curring</strong>的<strong class="kp iz">高级实现</strong>，以及何时使用。</p><p id="5f9d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我说的就是这些，非常感谢你们阅读我的博客！🙌我希望这篇博客对你有所帮助，让你深入了解了thunks和T42，以及如何在你的JavaScript应用中使用这些非常有用的函数式编程范例的概念。😄</p><p id="764d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在我们结束之前，</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/5e8dc53a7961479f7531ae1e143f6ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*HeoLTq1noQPUanwM.gif"/></div></figure><blockquote class="nc nd ne"><p id="cf4a" class="kn ko mw kp b kq kr jz ks kt ku kc kv nf kx ky kz ng lb lc ld nh lf lg lh li ig bi translated"><em class="iy">随时联系我:<br/></em><a class="ae nr" href="https://twitter.com/DevanshYtweets" rel="noopener ugc nofollow" target="_blank"><em class="iy">Twitter</em></a><em class="iy"><br/></em><a class="ae nr" href="https://www.linkedin.com/in/devansu-yadav/" rel="noopener ugc nofollow" target="_blank"><em class="iy">Linkedin</em></a><em class="iy"><br/></em><a class="ae nr" href="https://github.com/Devansu-Yadav" rel="noopener ugc nofollow" target="_blank"><em class="iy">GitHub</em></a></p></blockquote></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="dec4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><em class="mw">更多内容请看</em><a class="ae nr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kp iz"><em class="mw">plain English . io</em></strong></a><em class="mw">。报名参加我们的</em> <a class="ae nr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae nr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kp iz"><em class="mw">Twitter</em></strong></a><em class="mw">和</em><a class="ae nr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kp iz"><em class="mw">LinkedIn</em></strong></a><em class="mw">。查看我们的</em> <a class="ae nr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> <em class="mw">社区不和谐</em> </strong> </a> <em class="mw">加入我们的</em> <a class="ae nr" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> <em class="mw">人才集体</em> </strong> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>