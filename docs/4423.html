<html>
<head>
<title>How to Change an Element’s Style on Hover in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中改变悬停时的元素样式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-change-style-on-hover-96e53178ce12?source=collection_archive---------9-----------------------#2022-12-01">https://javascript.plainenglish.io/react-change-style-on-hover-96e53178ce12?source=collection_archive---------9-----------------------#2022-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/455bcfe3f83c534a3b928c8e87af62e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4g5KGXRuv0pcak6RxaVng.png"/></div></div></figure><p id="2f1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在React中的悬停上更改元素的样式，请在元素上设置一个<code class="fe kt ku kv kw b">className</code>，并设置其<code class="fe kt ku kv kw b">:hover</code>伪类的样式。</p><p id="e7e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><p id="ce2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">App.js</code></p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="cd17" class="lf lg in kw b be lh li l lj lk">import './App.css';<br/><br/>export default function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div className="box"&gt;<br/>        &lt;p&gt;Coding Beauty&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b5cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">App.css</code></p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="44e3" class="lf lg in kw b be lh li l lj lk">.box {<br/>  height: 100px;<br/>  width: 100px;<br/>  background-color: blue;<br/>  color: white;<br/>  font-weight: bold;<br/>  padding: 8px;<br/>  text-align: center;<br/>}<br/><br/>.box:hover {<br/>  background-color: yellow;<br/>  color: black;<br/>}</span></pre><figure class="kx ky kz la gt jo gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/260c19f742f2bb3e35c46692487f5d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/0*t9yccSq--EkQ4aOU.gif"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Hovering over the element changes its style.</figcaption></figure><p id="e15d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户将鼠标指针悬停在元素上时，我们使用<code class="fe kt ku kv kw b">:hover</code>伪类来设计元素的样式。</p><h1 id="dffe" class="lq lg in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用内嵌样式更改悬停时的元素样式</h1><p id="600a" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">我们还可以在悬停时使用内嵌样式和元素的<code class="fe kt ku kv kw b">style</code>属性来改变元素的样式。为此，我们需要创建一个状态来决定是否将悬停样式应用于元素。我们还需要为<code class="fe kt ku kv kw b">mouseenter</code>和<code class="fe kt ku kv kw b">mouseleave</code>添加事件监听器，并更改其中的状态值。</p><p id="fed6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><p id="5ff7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">App.js</code></p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="d333" class="lf lg in kw b be lh li l lj lk">import { useState } from 'react';<br/><br/>export default function App() {<br/>  const [hover, setHover] = useState(false);<br/><br/>  const handleMouseEnter = () =&gt; {<br/>    setHover(true);<br/>  };<br/><br/>  const handleMouseLeave = () =&gt; {<br/>    setHover(false);<br/>  };<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div<br/>        style={{<br/>          height: '100px',<br/>          width: '100px',<br/>          backgroundColor: hover ? 'yellow' : 'blue',<br/>          color: hover ? 'black' : 'white',<br/>          fontWeight: 'bold',<br/>          padding: '8px',<br/>          textAlign: 'center',<br/>        }}<br/>        onMouseEnter={handleMouseEnter}<br/>        onMouseLeave={handleMouseLeave}<br/>      &gt;<br/>        &lt;p&gt;Coding Beauty&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="ca94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<code class="fe kt ku kv kw b"><a class="ae ms" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">useState</a></code>钩子来创建布尔状态变量，该变量将决定悬停样式是否应该应用于元素。<code class="fe kt ku kv kw b">useState</code>返回两个值的数组。第一个是存储状态的变量，第二个是在被调用时更新状态的函数。</p><p id="c6d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<code class="fe kt ku kv kw b">onMouseEnter</code>属性来监听<code class="fe kt ku kv kw b"><a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event" rel="noopener ugc nofollow" target="_blank">mouseenter</a></code>事件，以检测鼠标何时进入元素的边界。</p><p id="4fd7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:虽然我们也可以监听<code class="fe kt ku kv kw b">mouseover</code>事件来检测悬停，但是这个事件是在DOM树中的一个元素和它的每一个祖先元素上触发的(即它冒泡)，这可能会在深层层次结构中导致严重的性能问题。<code class="fe kt ku kv kw b">mouseenter</code>不会冒泡，所以我们可以放心使用。</p><p id="c391" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，我们使用<code class="fe kt ku kv kw b">onMouseLeave</code>属性监听<code class="fe kt ku kv kw b"><a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event" rel="noopener ugc nofollow" target="_blank">mouseleave</a></code>来检测鼠标何时离开元素的边界。</p><p id="35d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用三元运算符根据布尔状态有条件地设置样式。</p><h1 id="9811" class="lq lg in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用自定义组件在悬停时更改元素样式</h1><p id="fe09" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">如果您经常使用内联样式方法来更改悬停时的元素样式，那么将逻辑封装到自定义组件中会更好，这样您就可以在代码库中的多个位置重用它，并避免不必要的重复。</p><p id="c374" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种组件应该是这样的:</p><p id="1182" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Hover.jsx</code></p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="fdb1" class="lf lg in kw b be lh li l lj lk">import { useState } from 'react';<br/><br/>export default function Hover({ children }) {<br/>  const [hover, setHover] = useState();<br/><br/>  const handleMouseEnter = () =&gt; {<br/>    setHover(true);<br/>  };<br/><br/>  const handleMouseLeave = () =&gt; {<br/>    setHover(false);<br/>  };<br/><br/>  return (<br/>    &lt;div<br/>      style={{ display: 'contents' }}<br/>      onMouseEnter={handleMouseEnter}<br/>      onMouseLeave={handleMouseLeave}<br/>    &gt;<br/>      {children(hover)}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="1106" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Hover</code>组件将一个回调函数作为其子组件。它将存储悬停状态的状态变量传递给这个回调，以便您可以使用它来更改从回调返回的元素的样式。<code class="fe kt ku kv kw b">Hover</code>调用回调来呈现这个元素。</p><p id="8d61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它用一个<code class="fe kt ku kv kw b">div</code>包装元素，在元素上监听<code class="fe kt ku kv kw b">mouseenter</code>和<code class="fe kt ku kv kw b">mouseleave</code>事件来更新状态变量。我们在包装器上将<code class="fe kt ku kv kw b"><a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/CSS/display-box" rel="noopener ugc nofollow" target="_blank">display</a></code> CSS属性设置为<code class="fe kt ku kv kw b">contents</code>，因为它在页面上没有视觉作用。它只是用来探测悬停的。</p><p id="04ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我们如何使用定制的<code class="fe kt ku kv kw b">Hover</code>组件。</p><p id="3fa1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Hover.jsx</code></p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="a8c5" class="lf lg in kw b be lh li l lj lk">import Hover from './Hover';<br/><br/>export default function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Hover&gt;<br/>        {(hover) =&gt; (<br/>          &lt;div<br/>            style={{<br/>              height: '100px',<br/>              width: '100px',<br/>              backgroundColor: hover ? 'yellow' : 'blue',<br/>              color: hover ? 'black' : 'white',<br/>              fontWeight: 'bold',<br/>              padding: '8px',<br/>              textAlign: 'center',<br/>            }}<br/>          &gt;<br/>            &lt;p&gt;Coding Beauty&lt;/p&gt;<br/>          &lt;/div&gt;<br/>        )}<br/>      &lt;/Hover&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="a02e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mt">原载于</em><a class="ae ms" href="https://cbdev.link/f48f00" rel="noopener ugc nofollow" target="_blank"><em class="mt">codingbeautydev.com</em></a></p><h1 id="ee61" class="lq lg in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">JavaScript做的每一件疯狂的事情</h1><p id="e18c" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">一本关于JavaScript微妙的警告和鲜为人知的部分的迷人指南。</p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/143ee152ba78025ea8643ba5b9726a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*YS5Oub8REWy8vnOEqBnsyQ.png"/></div></figure><p id="7d6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ms" href="https://cbdev.link/d3c4eb" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">报名</strong> </a>立即免费领取一份。</p></div></div>    
</body>
</html>