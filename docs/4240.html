<html>
<head>
<title>Better Polling API in React with requestAnimationFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用requestAnimationFrame改进了轮询API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/better-polling-api-in-react-with-requestanimationframe-983d02ff048?source=collection_archive---------1-----------------------#2022-11-13">https://javascript.plainenglish.io/better-polling-api-in-react-with-requestanimationframe-983d02ff048?source=collection_archive---------1-----------------------#2022-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4e0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><code class="fe kf kg kh ki b">useRafPolling</code>自定义挂钩可以更好地做到这一点</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/25809d4012d74f3a848a74095aff0cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yvL_D1Ud2aQYOqk0"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/es/@eagleboobs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Elliott Stallion</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c9d2" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在React应用程序开发中，您可能需要轮询API来持续更新页面数据，那么我们可以简单地使用<code class="fe kf kg kh ki b">useInterval</code>自定义钩子来完成这项工作:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f92d" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但我认为它有两个不完美之处:</p><ul class=""><li id="bf03" class="ly lz iq lc b ld le lg lh lj ma ln mb lr mc lv md me mf mg bi translated">由于<code class="fe kf kg kh ki b">setInterval</code>的特性，当用户将这个Web APP放在后台时，它也会不断轮询这个API，但此时用户的注意力已经不在你的Web APP上了，这无疑是一种浪费，页面数据更新却无人问津，也消耗了用户的设备电量。</li><li id="37d6" class="ly lz iq lc b ld mh lg mi lj mj ln mk lr ml lv md me mf mg bi translated">这个钩子对于同步回调来说很好，但是请求API是异步的。所以我们不能保证API返回的数据会很快到达，可能会因为各种网络原因延迟很久。也就是说，你设置的轮询间隔严格来说是针对后端服务轮询间隔，而不是更新你页面的间隔。</li></ul><p id="7e1a" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所以我准备写一个<code class="fe kf kg kh ki b">useRafPolling</code>自定义钩子来解决这个问题:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="96f8" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先我定义了一个<code class="fe kf kg kh ki b">setRafTimeout</code>而不是<code class="fe kf kg kh ki b">setTimeout</code>。这是因为<code class="fe kf kg kh ki b">requestAnimationFrame</code>在web应用程序处于后台时暂停呼叫，这提高了性能和电池寿命。</p><p id="dd11" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后我用<code class="fe kf kg kh ki b">async...await</code>执行异步回调，然后开始计时。虽然这并不能保证页面数据更新的时间间隔，但是我们减少无用的重复API请求，保证每个请求都是有效的，数据是最新的。</p><p id="6ec7" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">此外，编码中还有两个提示点。一种是我们使用<code class="fe kf kg kh ki b">RafHandle</code>来存储<code class="fe kf kg kh ki b">requestAnimationFrame</code>每次返回的<code class="fe kf kg kh ki b">id</code>，保证了在访问<code class="fe kf kg kh ki b">timerRef</code>时能够检索到最新的<code class="fe kf kg kh ki b">id</code>。第二，<code class="fe kf kg kh ki b">endedRef</code>用来标识当前是否已经结束，因为当异步任务完成时，这个钩子可能已经被卸载或者<code class="fe kf kg kh ki b">end</code>。从长远来看，如果React的状态在这个异步函数中被更新，那么您需要小心地确定当前组件是否已经被卸载。下面是一个完整的例子:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mm lx l"/></div></figure><p id="9821" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="mn">不是中等会员？</em> <a class="ae kz" href="https://medium.com/@hellostephanie2022/membership" rel="noopener"> <em class="mn">支持我在这里成为一个</em> </a> <em class="mn">。</em></p><p id="a43c" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="mn">更多内容请看</em><a class="ae kz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mn">plain English . io</em></strong></a><em class="mn">。报名参加我们的</em> <a class="ae kz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="mn">免费周报</em> </strong> </a> <em class="mn">。关注我们上</em><a class="ae kz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mn">Twitter</em></strong></a><a class="ae kz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mn">LinkedIn</em></strong></a><strong class="lc ir"><em class="mn"/></strong><a class="ae kz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="mn">YouTube</em></strong></a><strong class="lc ir"><em class="mn"/></strong><em class="mn">和</em> <a class="ae kz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="mn">不和</em> </strong> </a>  <em class="mn">对成长黑客感兴趣？检查</em> <a class="ae kz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="mn">电路</em> </strong> </a> <strong class="lc ir"> <em class="mn">。</em> </strong></p></div></div>    
</body>
</html>