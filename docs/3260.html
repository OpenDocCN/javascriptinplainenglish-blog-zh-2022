<html>
<head>
<title>Automate Dependency Updates With Renovate, Not With Dependabot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用renew而不是Dependabot自动更新依赖关系</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/automate-dependency-updates-by-renovate-not-by-dependabot-6efddd549a3e?source=collection_archive---------0-----------------------#2022-08-13">https://javascript.plainenglish.io/automate-dependency-updates-by-renovate-not-by-dependabot-6efddd549a3e?source=collection_archive---------0-----------------------#2022-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d20a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何用renew自动化依赖项更新的指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d5118dd46700c1b875281de2bcd9190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ET76wpsAttl8KFtTuL9hYg.png"/></div></div></figure><p id="6861" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">持续的依赖更新是软件开发中最大的主题之一。尽管旧的依赖关系存在安全风险，并且在最坏的情况下您可能得不到支持，但是持续更新非常耗时。</p><p id="5868" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">于是就有了一些依赖管理工具，比如<a class="ae ln" href="https://github.com/dependabot" rel="noopener ugc nofollow" target="_blank">依赖机器人</a>和<a class="ae ln" href="https://docs.renovatebot.com/" rel="noopener ugc nofollow" target="_blank">翻新</a>。它们自动检测依赖性更新，并通常创建依赖性更新PRs。</p><p id="ca30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，因为即使在一个应用程序中也有许多依赖项，所以您将面临永无止境的更新。所以仅仅使用依赖管理是不够的，你需要更多的自动化！</p><p id="b83b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在是时候考虑使用renew了。renewal比Dependabot更能自动化依赖性管理。所以这篇文章解释道:</p><ul class=""><li id="16a8" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">为什么你应该选择更新作为依赖管理</li><li id="beb4" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">翻新装置</li><li id="380d" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">更多自动化依赖关系管理的推荐设置</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="8f34" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">依赖性管理工具</h1><p id="5ef0" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">正如我所解释的，依赖性管理工具的主要目标是持续的依赖性更新。因此，主要功能是检测相关性更新并创建相关性更新PRs，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/26f8bda6e2e65240ae760463d07f0e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sLU5TUiPJc1PZftUhWF7A.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">PRs created by Dependabot</figcaption></figure><p id="d46c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，最流行的工具之一是由GitHub官方支持的<a class="ae ln" href="https://github.com/dependabot" rel="noopener ugc nofollow" target="_blank">依赖机器人</a>。因为它非常容易设置，您将在10分钟内获得依赖关系更新PRs。只需添加如下所示的简单配置:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="3b6d" class="nq mk iq nm b gy nr ns l nt nu">// <!-- -->.github/dependabot.yml</span><span id="dacd" class="nq mk iq nm b gy nv ns l nt nu">version: 2<br/>updates:<br/>  - package-ecosystem: 'npm'<br/>    directory: '/'<br/>    schedule:<br/>      interval: 'daily'</span></pre><p id="ec76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦你引入了依赖机器人，你就会感受到自动化的力量🤖如果你自己检查依赖项更新，就没有时间开发你的应用程序了。</p><p id="a609" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但实际上，依赖机器人产生了一个新问题。因为你会收到许多依赖关系更新PR，并且你需要审查每一个PR，所以你会觉得“这仍然很费时间，令人不知所措”。</p><p id="ff83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么为什么即使有了Dependabot还是很费时间呢？主要原因如下:</p><ol class=""><li id="94a7" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm nw lu lv lw bi translated">您必须以相同的方式检查所有相关性，因为相关性更新PRs是在每个相关性上创建的。有些需要认真审查，但有些不需要。</li><li id="9404" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm nw lu lv lw bi translated">您必须不同地检查相关的依赖关系，因为Dependabot不关心依赖关系。</li></ol><p id="31c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为Dependeabot太简单了，所以没有太多的灵活性来解决这些问题。所以现在，翻新出现了。🚀</p><h1 id="6e88" class="mj mk iq bd ml mm nx mo mp mq ny ms mt jw nz jx mv jz oa ka mx kc ob kd mz na bi translated">革新</h1><p id="f0a5" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">Renovate也是一个自动创建依赖关系更新PRs的依赖关系管理应用程序。但是除此之外，renewal比Dependabot具有更大的灵活性。</p><p id="efd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，renewal具有自动合并功能。您可以指定相关性，当更新请购单通过测试等状态检查时，它将被合并。</p><p id="e9ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，renew可以批量依赖更新PRs。这对于需要同时更新的依赖组来说非常好。对于像<code class="fe oc od oe nm b">@babel</code>这样的monorepo依赖项也是如此。</p><p id="d8be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管还有其他令人兴奋的特性，我想你已经感觉到Renovate在自动化依赖管理方面有巨大的潜力。</p><p id="6d81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，从下一节开始，我将介绍Renovate的安装，并分享推荐的设置来自动化依赖关系管理。</p><h1 id="c1fd" class="mj mk iq bd ml mm nx mo mp mq ny ms mt jw nz jx mv jz oa ka mx kc ob kd mz na bi translated">安装翻新</h1><p id="5c2f" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">翻新的设置流程如下所示:</p><ol class=""><li id="4d01" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm nw lu lv lw bi translated">在您的存储库上安装更新应用程序</li><li id="1c93" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm nw lu lv lw bi translated">自动更新创建配置PR</li><li id="521c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm nw lu lv lw bi translated">自定义配置PR</li><li id="dbde" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm nw lu lv lw bi translated">一旦您合并了一个配置PR，更新创建依赖关系更新PR</li></ol><p id="c985" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，我们安装翻新app吧！请进入GitHub <a class="ae ln" href="https://github.com/apps/renovate" rel="noopener ugc nofollow" target="_blank">翻新app </a>页面，点击安装。我建议只在选定的存储库上安装它，因为它会在每个存储库上创建安装PR。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/0dc292c14c79c8849e82e5312608be6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYSpmsxlb0NUEZDDXRI8rg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Install Renovate on GitHub</figcaption></figure><p id="cdc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我上面所说，安装后的初始设置如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/eaf795377333f234d4138900ef7fd86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WuStpqv9My_PIy0m-3dOQQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Initial setup PR on GitHub</figcaption></figure><p id="d750" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">翻新的默认设置如下。很简单。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="28a5" class="nq mk iq nm b gy nr ns l nt nu">// renovate.json</span><span id="d70e" class="nq mk iq nm b gy nv ns l nt nu">{<br/>  "$schema": "<a class="ae ln" href="https://docs.renovatebot.com/renovate-schema.json" rel="noopener ugc nofollow" target="_blank">https://docs.renovatebot.com/renovate-schema.json</a>",<br/>  "extends": [<br/>    "config:base"<br/>  ]<br/>}</span></pre><p id="3c0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，它有<code class="fe oc od oe nm b">extends</code>选项，选项中有<code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-config/#configbase" rel="noopener ugc nofollow" target="_blank">config:base</a></code>。<code class="fe oc od oe nm b">config:base</code>覆盖如下一些默认设置:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="b1e0" class="nq mk iq nm b gy nr ns l nt nu">{   <br/>  "extends": [<br/>     ":dependencyDashboard",<br/>     ":semanticPrefixFixDepsChoreOthers",<br/>     ":ignoreModulesAndTests",<br/>     ":autodetectPinVersions",<br/>     ":prHourlyLimit2",<br/>     ":prConcurrentLimit10",<br/>     "group:monorepos",<br/>     "group:recommended",<br/>     "workarounds:all"<br/>  ]<br/>}</span></pre><p id="57e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-default/#dependencydashboard" rel="noopener ugc nofollow" target="_blank">:dependencyDashboard</a></code>启用作为问题创建的<a class="ae ln" href="https://docs.renovatebot.com/key-concepts/dashboard/" rel="noopener ugc nofollow" target="_blank">相关性仪表板</a>。它显示了当前相关性更新状态的概述。您也可以检查关闭的依赖项更新。用Dependabot是做不到的。</p><p id="a728" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-default/#ignoremodulesandtests" rel="noopener ugc nofollow" target="_blank">:ignoreModulesAndTests</a></code>防止从类似node_modules和vendor创建更新请购单。</p><p id="a449" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-default/#autodetectpinversions" rel="noopener ugc nofollow" target="_blank">:autodetectPinVersions</a></code>将<a class="ae ln" href="https://docs.renovatebot.com/configuration-options/#rangestrategy" rel="noopener ugc nofollow" target="_blank">范围策略</a>设置为<code class="fe oc od oe nm b">auto</code>。意思是怎么修改版本就看翻新了。</p><p id="ac7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-default/#prhourlylimit2" rel="noopener ugc nofollow" target="_blank">:prHourlyLimit2</a></code>很容易理解。它将一小时内创建的PRs更新数量限制为2个。虽然这是为了CI堆叠，但2个PRs可能太小了。</p><p id="8b97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-default/#prconcurrentlimit10" rel="noopener ugc nofollow" target="_blank">:prConcurrentLimit10</a></code>任何时候最多限制10个PRs。也许它也太小了。</p><p id="70f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-group/#groupmonorepos" rel="noopener ugc nofollow" target="_blank">group:monorepos</a></code>是一个超级有用的更新分组预置。它批量更新众所周知的monorepo软件包的PR。</p><p id="a9da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-group/#grouprecommended" rel="noopener ugc nofollow" target="_blank">group:recommended</a></code>与<code class="fe oc od oe nm b">group:monorepo</code>非常相似。这是非monorepo包的批量预设。</p><p id="bb1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-workarounds/#workaroundsall" rel="noopener ugc nofollow" target="_blank">workaround:all</a></code>是一个针对软件包的错误修复方法。</p><p id="d579" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">都是关于renew的默认设置。我想你已经了解了翻新的基本知识。</p><h1 id="6d54" class="mj mk iq bd ml mm nx mo mp mq ny ms mt jw nz jx mv jz oa ka mx kc ob kd mz na bi translated">编辑初始设置</h1><p id="a547" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">在继续之前，我建议添加一些配置。</p><p id="36d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，设置<a class="ae ln" href="https://docs.renovatebot.com/key-concepts/scheduling/" rel="noopener ugc nofollow" target="_blank">翻新计划</a>使翻新在办公时间之外进行。如果在开发过程中更新创建了大量的pr，那么CI(持续集成)就很容易被卡住。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="3748" class="nq mk iq nm b gy nr ns l nt nu">// renovate.json</span><span id="d81b" class="nq mk iq nm b gy nv ns l nt nu">{<br/>  "$schema": "<a class="ae ln" href="https://docs.renovatebot.com/renovate-schema.json" rel="noopener ugc nofollow" target="_blank">https://docs.renovatebot.com/renovate-schema.json</a>",<br/>  "extends": [<br/>    "config:base",<br/>    "schedule:daily"   // ADD<br/>  ],<br/>  "timezone": "Japan"  // ADD<br/>}</span></pre><p id="cfbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-schedule/#scheduledaily" rel="noopener ugc nofollow" target="_blank">schedule:daily</a></code>是一个预设的更新计划，更新会在凌晨2点前创建PRs。此外，您应该设置<code class="fe oc od oe nm b">timezone</code>,因为默认情况下，计划工作在UTC时间。</p><p id="d8a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，您应该取消创建每小时PRs的速率限制和开放PRs的数量。也许你认为你的PRs页面会被更新的PRs填满🤔</p><p id="71aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其实是真的。但是请不要忘记依赖管理的主要目的。是为了不断升级依赖。如果减贫战略的数量有限，主要目的就无法实现。</p><p id="67e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你感到不知所措，是时候考虑进一步自动化，而不是停止升级。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="4f83" class="nq mk iq nm b gy nr ns l nt nu">// renovate.json</span><span id="4b5f" class="nq mk iq nm b gy nv ns l nt nu">{<br/>  "$schema": "<a class="ae ln" href="https://docs.renovatebot.com/renovate-schema.json" rel="noopener ugc nofollow" target="_blank">https://docs.renovatebot.com/renovate-schema.json</a>",<br/>  "extends": [<br/>    "config:base",<br/>    "schedule:daily",<br/>    ":disableRateLimiting"  // ADD<br/>  ],<br/>  "timezone": "Japan"<br/>}</span></pre><p id="f649" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以用<code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-default/#disableratelimiting" rel="noopener ugc nofollow" target="_blank">:disableRateLimiting</a></code>来代替。它取消了创建每小时PRs和打开PRs数量的速率限制。</p><h1 id="fb6f" class="mj mk iq bd ml mm nx mo mp mq ny ms mt jw nz jx mv jz oa ka mx kc ob kd mz na bi translated">更多自动化的推荐设置</h1><p id="c385" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">正如我上面所说的，使用依赖关系管理不足以自动化依赖关系更新，因为会有许多PRs需要审查。所以让我们尽可能地自动化它。</p><h1 id="7016" class="mj mk iq bd ml mm nx mo mp mq ny ms mt jw nz jx mv jz oa ka mx kc ob kd mz na bi translated">自动合并</h1><p id="cbb3" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">首先，你应该设置<a class="ae ln" href="https://docs.renovatebot.com/key-concepts/automerge/" rel="noopener ugc nofollow" target="_blank">自动合并</a>。当您审查每个依赖项时，您会注意到有些依赖项需要认真审查，但有些不需要，尤其是开发依赖项。renew auto merge是一个特性，当状态检查(如测试)通过时，renew试图合并更新PR。</p><p id="0220" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一个例子，我将展示<code class="fe oc od oe nm b">@types</code>、linters和锁文件变更的自动合并设置。</p><h2 id="0eda" class="nq mk iq bd ml oh oi dn mp oj ok dp mt la ol om mv le on oo mx li op oq mz or bi translated">@types的自动合并设置</h2><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="8aad" class="nq mk iq nm b gy nr ns l nt nu">// renovate.json</span><span id="887e" class="nq mk iq nm b gy nv ns l nt nu">{<br/>  ...<br/>  "packageRules": [<br/>    {<br/>      "matchPackagePrefixes": ["@types/"],<br/>      "automerge": true,<br/>      // If you need<br/>      "major": {<br/>        "automerge": false<br/>      }" <br/>    }<br/>  ]<br/>}</span></pre><p id="4e6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe nm b">packageRules</code> key是一个很棒的特性，你可以创建自定义规则并使用regex指定依赖关系。</p><p id="1f14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以对于<code class="fe oc od oe nm b">@types</code>依赖项，你可以指定<code class="fe oc od oe nm b">@types/</code>作为依赖项的前缀，并设置<code class="fe oc od oe nm b">automerge</code>为真。如果不想自动合并<code class="fe oc od oe nm b">@types</code>的主版本，可以用<code class="fe oc od oe nm b">major</code>选项将其排除。</p><p id="3ab1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很简单！😀</p><p id="31c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，请记住，如果您需要对每个请购单进行请购单审核，review不能自动合并更新请购单。在这种情况下，就该用<a class="ae ln" href="https://github.com/apps/renovate-approve" rel="noopener ugc nofollow" target="_blank">改审批</a>了。通过更新-批准，更新的PRs可以自动合并。可以用翻新app的方法安装。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/4671ec1231d2ef7de42281d2dc509c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-Ndlfkb_nlXbhVilSXnvg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">renovate-approve</figcaption></figure><h2 id="8f9d" class="nq mk iq bd ml oh oi dn mp oj ok dp mt la ol om mv le on oo mx li op oq mz or bi translated">棉绒自动融合设置</h2><p id="7703" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">这个设置几乎与@types相同。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="62f1" class="nq mk iq nm b gy nr ns l nt nu">// renovate.json</span><span id="d408" class="nq mk iq nm b gy nv ns l nt nu">{<br/>  ...<br/>  "packageRules": [<br/>    ...<br/>    {<br/>      "matchDepTypes": ["devDependencies"],<br/>      "matchPackagePatterns": ["lint", "prettier"],<br/>      "automerge": true,<br/>    }<br/>  ]<br/>}</span></pre><p id="e5d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为有一个名为<a class="ae ln" href="https://docs.renovatebot.com/presets-packages/#packageslinters" rel="noopener ugc nofollow" target="_blank"> package:linters </a>的linter预置，您可以通过扩展它来实现同样的事情。但对我来说，自定义设置比读取预置简单。</p><h2 id="d40f" class="nq mk iq bd ml oh oi dn mp oj ok dp mt la ol om mv le on oo mx li op oq mz or bi translated">锁定文件更改的自动合并设置</h2><p id="a91c" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">依赖项更新不仅可以在项目依赖项定义中使用(比如package.json)，也可以在锁文件中使用(比如yarn.lock)。可能不像dependencies和devDependencies那么重要，但是有时候它们也会有安全问题。所以我也建议更新它们。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="cf7e" class="nq mk iq nm b gy nr ns l nt nu">// renovate.json</span><span id="76e8" class="nq mk iq nm b gy nv ns l nt nu">{<br/>  ...<br/>  "packageRules": [<br/>    ...<br/>  ],<br/>  "lockFileMaintenance": {<br/>     "enabled": true,<br/>     "automerge": true<br/>  }<br/>}</span></pre><p id="27c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为自动合并设置取决于您的依赖项，所以您也可以添加其他设置。实际上，我也使用automerge来测试库(比如Jest)和GraphQL代码生成器(比如@graphql-codegen/cli)。</p><h1 id="4f12" class="mj mk iq bd ml mm nx mo mp mq ny ms mt jw nz jx mv jz oa ka mx kc ob kd mz na bi translated">包装分组</h1><p id="2b8c" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">其次，你要设置<a class="ae ln" href="https://docs.renovatebot.com/noise-reduction/#package-grouping" rel="noopener ugc nofollow" target="_blank">打包</a>。即使在设置了自动合并之后，您可能仍然有许多pr。您可能会注意到，您应该使用不同的依赖项更新PRs多次查看同一发行说明。monorepo依赖通常会发生这种情况。</p><p id="6aea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，您可以将它们的更新PR组合成一个PR。比如我用它做<a class="ae ln" href="https://www.npmjs.com/package/@sentry/tracing" rel="noopener ugc nofollow" target="_blank"> @sentry/tracing </a>和<a class="ae ln" href="https://www.npmjs.com/package/@sentry/react" rel="noopener ugc nofollow" target="_blank"> @sentry/react </a>。由于类型问题，它们需要同时更新，所以我将它们的PRs归为一组。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="b927" class="nq mk iq nm b gy nr ns l nt nu">// renovate.json</span><span id="e147" class="nq mk iq nm b gy nv ns l nt nu">{<br/>  "packageRules": [<br/>    ...<br/>    {<br/>      "matchSourceUrlPrefixes": [<br/>        "https://github.com/getsentry/sentry-javascript"<br/>      ],<br/>      "groupName": "sentry-javascript"<br/>    },<br/>  ],<br/>  ...<br/>}</span></pre><p id="fcb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我猜你想出了许多类型的分组。但是通常你不必定制包分组，因为初始设置中的<code class="fe oc od oe nm b">config:base</code>已经扩展了<code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-group/#groupmonorepos" rel="noopener ugc nofollow" target="_blank">group:monorepos</a></code>和<code class="fe oc od oe nm b"><a class="ae ln" href="https://docs.renovatebot.com/presets-group/#grouprecommended" rel="noopener ugc nofollow" target="_blank">group:recommended</a></code>。因此，您可以在几个星期后更新安装时设置包分组。</p><p id="cd34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了🚀没有那么多配置👏请合并配置PR，您将在存储库中看到更新的PRs。</p><p id="f96b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，一件重要的事情！在合并配置PR之后，您可能会注意到仍然有许多PR。这是因为每个应用程序的依赖关系都非常不同。因此，您应该不断地调整您的配置。</p><h1 id="0c9d" class="mj mk iq bd ml mm nx mo mp mq ny ms mt jw nz jx mv jz oa ka mx kc ob kd mz na bi translated">技巧</h1><p id="974b" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">读完这篇文章，做了翻新设置，我猜你会自定义翻新更多。为了进一步定制，我介绍一些小技巧。</p><p id="41ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，<code class="fe oc od oe nm b">renovate-config-validator</code>对于本地编辑很有用。如果你想在本地环境中运行，通过npx使用它，而不需要在你的应用中安装这个包。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="0e7f" class="nq mk iq nm b gy nr ns l nt nu">$ npx --package renovate -c 'renovate-config-validator'</span></pre><p id="d66b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，您可以使用<a class="ae ln" href="https://github.com/marketplace/actions/renovate-config-validator" rel="noopener ugc nofollow" target="_blank">renew-config-validator</a>在GitHub操作中检查更新配置。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="7de3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文解释了如何使用renew自动化依赖项更新。随着革新，我希望你能更喜欢软件工程！</p><h1 id="0dbf" class="mj mk iq bd ml mm nx mo mp mq ny ms mt jw nz jx mv jz oa ka mx kc ob kd mz na bi translated">参考</h1><ul class=""><li id="e4e0" class="lo lp iq kt b ku nb kx nc la ot le ou li ov lm lt lu lv lw bi translated"><a class="ae ln" href="https://docs.renovatebot.com/" rel="noopener ugc nofollow" target="_blank">翻新</a></li><li id="b019" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="https://github.com/dependabot" rel="noopener ugc nofollow" target="_blank">依赖机器人</a></li><li id="5620" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="https://github.com/marketplace/actions/renovate-config-validator" rel="noopener ugc nofollow" target="_blank">更新配置验证器</a></li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="6bbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ow">更多内容看</em> <a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ow">说白了。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ow">免费周报</em> </strong> </a> <em class="ow">。关注我们关于</em> <a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ow">推特</em></strong></a><a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ow">LinkedIn</em></strong></a><em class="ow"/><a class="ae ln" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ow">YouTube</em></strong></a><em class="ow"/><a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ow">不和</em> </strong> </a> <em class="ow">。</em></strong></a></p></div></div>    
</body>
</html>