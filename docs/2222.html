<html>
<head>
<title>How to use React’s useCallback with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将React的useCallback与TypeScript一起使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-reacts-usecallback-with-typescript-355afc82c77f?source=collection_archive---------9-----------------------#2022-05-23">https://javascript.plainenglish.io/how-to-use-reacts-usecallback-with-typescript-355afc82c77f?source=collection_archive---------9-----------------------#2022-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f06ee887d331f9597af57541f15d6664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYR33of76ICXWBnRLsuJSg.png"/></div></div></figure><p id="1b71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React开发中最常用的钩子之一是<code class="fe kw kx ky kz b">useCallback</code>。钩子允许开发人员容易地实现回调的记忆化，这可以用于各种性能优化的原因。它最突出的用例是避免组件不必要的重新渲染。</p><p id="fbc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于TypeScript的广泛使用和流行，人们将不可避免地遇到使用TypeScript键入<code class="fe kw kx ky kz b">useCallback</code>用法的任务。然而，有各种方法可以做到这一点，每种方法都有自己不同的优点和缺点。本文涵盖了这些不同的方法，以及它们的特点和潜在问题。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="47ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们深入研究不同的选项之前，让我们看看典型的<code class="fe kw kx ky kz b">useCallback</code>调用是什么样子的，以及我们希望正确输入它的原因之一。<code class="fe kw kx ky kz b">useCallback</code>钩子的一个常见用例是创建一个事件处理程序，它在重新渲染时保持稳定，除非它的依赖关系发生变化。</p><p id="d21c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们还想访问回调中的交互事件。不幸的是，没有正确的类型，TypeScript不知道回调参数的类型。因此，它将默认为<code class="fe kw kx ky kz b">any</code>类型。然而，这意味着我们在开发过程中没有关于<code class="fe kw kx ky kz b">event</code>变量的有用的类型信息。</p><p id="a53e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们希望在<code class="fe kw kx ky kz b">useCallback</code>调用中正确输入的原因之一。虽然这个原因将是本文中探索不同的类型<code class="fe kw kx ky kz b">useCallback</code>调用方法的主要驱动力，但是还有其他原因。考虑返回类型或函数类型本身的对齐，这在回调用作属性值时是相关的。</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="a574" class="lp lq iq kz b gy lr ls l lt lu">import { useCallback } from "react";<br/>import { doSomething } from "./utils";</span><span id="c126" class="lp lq iq kz b gy lv ls l lt lu">const ComponentA = ({ content, depA, depB }: ComponentProps) =&gt; {<br/>  const handleClick = useCallback(<br/>    (event) =&gt; {<br/>      doSomething(depA, depB, event);<br/>    },<br/>    [depA, depB]<br/>  );</span><span id="e463" class="lp lq iq kz b gy lv ls l lt lu">  return &lt;div onClick={handleClick}&gt;{content}&lt;/div&gt;;<br/>};</span></pre><h1 id="a85f" class="lw lq iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">键入回调参数</h1><p id="da6d" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">获取回调参数类型的最直接的方法是将类型直接放在回调参数上。这可以通过直接告诉TypeScript参数的类型来实现，在本例中是<code class="fe kw kx ky kz b">MouseEvent&lt;HTMLElement&gt;</code>。</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="b921" class="lp lq iq kz b gy lr ls l lt lu">import { MouseEvent, MouseEventHandler, useCallback } from "react";<br/>import { doSomething } from "./utils";</span><span id="a5fb" class="lp lq iq kz b gy lv ls l lt lu">const ComponentB = ({ content, depA, depB }: ComponentProps) =&gt; {<br/>  const handleClick = useCallback(<br/>    (event: MouseEvent&lt;HTMLElement&gt;) =&gt; {<br/>      doSomething(depA, depB, event);<br/>    },<br/>    [depA, depB]<br/>  );</span><span id="51d6" class="lp lq iq kz b gy lv ls l lt lu">  return &lt;div onClick={handleClick}&gt;{content}&lt;/div&gt;;<br/>};</span></pre><p id="12b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这是向函数回调参数添加类型的短期解决方案，但它并不是真正可伸缩的解决方案。如果将来添加了任何参数，就需要对所有参数进行额外的输入。最重要的是，这样做并不会将类型引入到整个回调中。因此，TypeScript无法根据回调所使用的属性类型来正确验证回调的类型。</p><h1 id="2e8a" class="lw lq iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">键入返回的回调</h1><p id="ffc9" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们可以用适当的类型来输入返回的回调，而不是单独输入函数参数。这避免了前一种方法的缺点，因为将类型放在回调中会覆盖函数类型定义中的任何更改，并且有一个类型来验证它所用于的属性的类型。</p><p id="ff17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个解决方案唯一的缺点是它需要一个变量来存储<code class="fe kw kx ky kz b">useCallback</code>值。没有它，就没有办法将输入转换成回调。在钩子被内联使用或者作为自定义钩子的返回值的情况下，这可能会有问题。</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="2955" class="lp lq iq kz b gy lr ls l lt lu">import { MouseEvent, MouseEventHandler, useCallback } from "react";<br/>import { doSomething } from "./utils";</span><span id="c96f" class="lp lq iq kz b gy lv ls l lt lu">const ComponentD = ({ content, depA, depB }: ComponentProps) =&gt; {<br/>  const handleClick: MouseEventHandler&lt;HTMLElement&gt; = useCallback(<br/>    (event) =&gt; {<br/>      doSomething(depA, depB, event);<br/>    },<br/>    [depA, depB]<br/>  );</span><span id="5f3c" class="lp lq iq kz b gy lv ls l lt lu">  return &lt;div onClick={handleClick}&gt;{content}&lt;/div&gt;;<br/>};</span></pre><h1 id="dc45" class="lw lq iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">键入useCallback调用</h1><p id="8963" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">一个非常相似的结果可以通过一种不同的并且可以说稍微干净一点的方式来实现，那就是键入<code class="fe kw kx ky kz b">useCallback</code>调用。就类型而言，我还没有发现TypeScript处理这种方法与前一种方法有什么不同，在前一种方法中，我们将类型放在返回值上。然而，这种方法确实解决了以前方法的所有不便。</p><p id="c922" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就我个人而言，我发现这种方法更具可读性和结构化，因为<code class="fe kw kx ky kz b">useCallback</code>调用与其输入捆绑得更紧密。不涉及类型转换，与自然阅读流程顺利集成，具有所有类型的优点，并避免了其他方法的所有不便。</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="441b" class="lp lq iq kz b gy lr ls l lt lu">import { MouseEvent, MouseEventHandler, useCallback } from "react";<br/>import { doSomething } from "./utils";</span><span id="facd" class="lp lq iq kz b gy lv ls l lt lu">const ComponentC = ({ content, depA, depB }: ComponentProps) =&gt; {<br/>  const handleClick = useCallback&lt;MouseEventHandler&lt;HTMLElement&gt;&gt;(<br/>    (event) =&gt; {<br/>      doSomething(depA, depB, event);<br/>    },<br/>    [depA, depB]<br/>  );</span><span id="30c0" class="lp lq iq kz b gy lv ls l lt lu">  return &lt;div onClick={handleClick}&gt;{content}&lt;/div&gt;;<br/>};</span></pre><h1 id="dae6" class="lw lq iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">最后的想法</h1><p id="76ec" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">每个React开发人员都知道<code class="fe kw kx ky kz b">useCallback</code>钩子，并试图将其与TypeScript集成。然而，有各种方法可以做到这一点。本文介绍了三种不同的方法，即只键入回调参数、键入返回值或调用本身。它们中的每一个都建立在前一个的特征、潜在问题和不便之上。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="e033" class="lp lq iq kz b gy lr ls l lt lu"><strong class="kz ir">Want to Connect?</strong></span><span id="7f7d" class="lp lq iq kz b gy lv ls l lt lu">If you liked this article, consider checking out the other entries in the <a class="ae my" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">Uncommon React</a> newsletter and my <a class="ae my" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank">Twitter</a> for future updates.</span></pre><p id="9e01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz">更多内容请看</em><a class="ae my" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mz">plain English . io</em></strong></a><em class="mz">。报名参加我们的</em> <a class="ae my" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mz">免费周报</em> </strong> </a> <em class="mz">。关注我们关于</em><a class="ae my" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mz">Twitter</em></strong></a><em class="mz">和</em><a class="ae my" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mz">LinkedIn</em></strong></a><em class="mz">。查看我们的</em> <a class="ae my" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mz">社区不和谐</em> </strong> </a> <em class="mz">加入我们的</em> <a class="ae my" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mz">人才集体</em> </strong> </a> <em class="mz">。</em></p></div></div>    
</body>
</html>