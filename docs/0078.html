<html>
<head>
<title>Create a REST API with Azure Functions and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Azure函数和Node.js创建REST API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-rest-api-with-azure-functions-ee5ad3f61482?source=collection_archive---------0-----------------------#2022-01-06">https://javascript.plainenglish.io/creating-a-rest-api-with-azure-functions-ee5ad3f61482?source=collection_archive---------0-----------------------#2022-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1c38" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分—获取、上传、删除</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/d09fcb0e724762d7443cd0aeef810a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oh4XgZJiz8aSfTHyTn2ZAw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Azure Functions with Node.js</figcaption></figure><p id="5405" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本系列的第1部分中，我们设置了API并实现了POST请求。在本文中，我们将研究如何实现获取所有帖子的GET请求和另一个按id获取帖子的GET请求。我们还将实现一个更新帖子的PUT请求和一个设置删除帖子的DELETE请求。</p><h1 id="76b9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">获取所有帖子</h1><p id="64fb" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">要创建获取所有帖子的GET方法，请在VS代码中导航到Azure选项卡。由于我们已经在Azure Functions项目中，我们只需点击闪电图标。单击它之后，在命令面板中选择HTTP trigger，将您的函数命名为GetAllPosts，并将Authorization设置为Anonymous。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/99a670ceca95f27be2d9124f9eae9c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*giQekJSOMzMVED87TllJQQ.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Create New Function</figcaption></figure><h2 id="2d44" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">函数. json</h2><p id="b202" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在GetAllPosts函数文件夹中，导航到function.json文件并删除方法数组中的“post”。这将只允许对函数的GET请求。</p><p id="4604" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果有成千上万的帖子，抓取表格中的每一个帖子将不会是高效的。因此，我们将指定一个路径，在那里我们可以传递带有博客名称的URL参数，这样我们就可以获取特定分区键下的所有内容。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6f36" class="mm lp iq mz b gy nd ne l nf ng">"route": "GetAllPosts/{blog}"</span></pre><p id="c60e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加这两个属性后，function.json应该如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="14f0" class="mm lp iq mz b gy nd ne l nf ng">{<br/> "bindings": [<br/>  {<br/>   "authLevel": "anonymous",<br/>   "type": "httpTrigger",<br/>   "direction": "in",<br/>   "name": "req",<br/>   "methods": [<br/>    "get"<br/>   ],<br/>   "route": "GetAllPosts/{blog}"<br/>  },<br/>  {<br/>   "type": "http",<br/>   "direction": "out",<br/>   "name": "res"<br/>  }<br/> ]<br/>}</span></pre><h2 id="9c3d" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">表格客户端</h2><p id="a2c8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在我们已经设置了绑定，让我们使用一个表客户机方法来获取特定博客的所有帖子。转到services，table-service.js并创建一个名为<em class="nh"> queryEntities的新方法。</em>我们将向该方法传递一个表名和查询，使其通用化<em class="nh"> c. </em>就像插入实体方法一样，我们将把一切都包装在承诺中，这样我们就可以使用async/await。</p><p id="3dbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们将使用SDK来调用<em class="nh"> queryEntities </em>方法。我们将向表服务方法传递tableName、query、null(这是延续标记所在的位置)和以下选项，以更易读的格式返回数据:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b049" class="mm lp iq mz b gy nd ne l nf ng">{<em class="nh"> payloadFormat</em>:<em class="nh"> </em>"application/json;odata=nometadata"<em class="nh"> </em>}</span></pre><p id="c210" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，您的方法应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="6f7d" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">索引. js</h2><p id="3f41" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在回到GetAllPosts文件夹中的index.js文件。在这里，我们将在文件顶部导入azure和我们的queryEntities方法:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="83b5" class="mm lp iq mz b gy nd ne l nf ng">const<em class="nh"> azure </em>=<em class="nh"> require</em>("azure-storage");<br/>const<em class="nh"> </em>{<em class="nh"> queryEntities </em>}<em class="nh"> </em>=<em class="nh"> require</em>("../services/table-service");</span></pre><p id="cfa0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，让我们将整个方法包装在一个try-catch中。在try块中，我们将抓取blog并添加一个检查以确保它通过。之后，我们将使用Azure Table Storage SDK创建一个新的查询，然后调用<em class="nh"> queryEntities </em>方法。如果我们得到了良好的响应，我们将在<em class="nh"> context.res </em>的body属性中返回它们。在catch块中，我们将使用<em class="nh"> context.res </em>返回一个状态500和一个错误消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">GetAllPosts</figcaption></figure><h1 id="7a33" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">区别详解</h1><p id="35a0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">要为一篇博客文章创建GET方法，请在VS代码中点击Azure选项卡，然后点击Functions下的闪电图标。然后选择HTTP trigger，将您的函数命名为GetPost，并选择Anonymous作为授权级别。</p><h2 id="1e0a" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">函数. json</h2><p id="b63e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在GetPost文件夹中，打开function.json并删除方法数组中的“Post”。然后，在bindings数组中的第一个对象上添加此路由:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2826" class="mm lp iq mz b gy nd ne l nf ng">"route": "GetPost/{blog}/{id}"</span></pre><p id="610e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成所有这些后，您的文件应该如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="3e59" class="mm lp iq mz b gy nd ne l nf ng">{<br/> "bindings": [<br/>  {<br/>   "authLevel": "anonymous",<br/>   "type": "httpTrigger",<br/>   "direction": "in",<br/>   "name": "req",<br/>   "methods": [<br/>    "get"<br/>   ],<br/>   "route": "GetPost/{blog}/{id}"<br/>  },<br/>  {<br/>   "type": "http",<br/>   "direction": "out",<br/>   "name": "res"<br/>  }<br/> ]<br/>}</span></pre><h2 id="7414" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">索引. js</h2><p id="ccc7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">接下来，打开index.js。在文件中，我们将从表客户端导入azure-storage和queryEntities方法:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2330" class="mm lp iq mz b gy nd ne l nf ng">const<em class="nh"> azure </em>=<em class="nh"> require</em>("azure-storage");<br/>const<em class="nh"> </em>{<em class="nh"> queryEntities </em>}<em class="nh"> </em>=<em class="nh"> require</em>("../services/table-service");</span></pre><p id="5bb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们将把所有内容包装在一个try-catch中，并从绑定数据中获取blog和id:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="0a14" class="mm lp iq mz b gy nd ne l nf ng">module<em class="nh">.</em>exports = <em class="nh">async</em> function (context, req) { <br/> <em class="nh">try</em> {<br/>  const<em class="nh"> </em>{<em class="nh"> blog</em>,<em class="nh"> id </em>}<em class="nh"> </em>=<em class="nh"> context.bindingData</em>;</span><span id="54ca" class="mm lp iq mz b gy nk ne l nf ng"> } <em class="nh">catch</em> (error) {<br/>  <em class="nh">context.</em>res = {<br/>   status: 500,<br/>   body: <em class="nh">error.</em>message,<br/>  };<br/> }<br/>};</span></pre><p id="f737" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将检查blog和id是否被传递:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="acf2" class="mm lp iq mz b gy nd ne l nf ng">if (!blog || !id) {<br/> <em class="nh">context.</em>res = {<br/>  status: 400,<br/>  body: "Blog and Post ID are required",<br/> };</span><span id="2cb9" class="mm lp iq mz b gy nk ne l nf ng"><em class="nh"> return</em>;<br/>}</span></pre><p id="6cef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们将使用Azure storage SDK创建一个查询，并调用我们的queryEntities方法。最后，我们返回结果。将所有这些放在一起，您的文件将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">GetPost — index.js</figcaption></figure><h1 id="e218" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">更新帖子</h1><p id="6fce" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们像上一个方法一样创建我们的方法，方法是转到Azure选项卡并单击Functions旁边的闪电图标。然后选择HTTP trigger，将您的函数命名为UpdatePost，并选择Anonymous作为授权级别。</p><h2 id="e9d6" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">函数. json</h2><p id="676f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在function.json中，删除方法数组中的所有内容，并替换为“put”。接下来，添加以下路线:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="5e3a" class="mm lp iq mz b gy nd ne l nf ng">"route": "UpdatePost/{blog}/{id}"</span></pre><p id="91e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的文件应该如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="264d" class="mm lp iq mz b gy nd ne l nf ng">{<br/> "bindings": [<br/>  {<br/>   "authLevel": "anonymous",<br/>   "type": "httpTrigger",<br/>   "direction": "in",<br/>   "name": "req",<br/>   "methods": [<br/>    "put"<br/>   ],<br/>   "route": "UpdatePost/{blog}/{id}"<br/>  },<br/>  {<br/>   "type": "http",<br/>   "direction": "out",<br/>   "name": "res"<br/>  }<br/> ]<br/>}</span></pre><h2 id="1ad2" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">表格客户端</h2><p id="b814" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在去餐桌客户端。在这里，我们将把更新写入表中。但是，首先，你应该知道，根据文档，我们可以用几种不同的方法来做到这一点:</p><blockquote class="nl nm nn"><p id="3f3f" class="kr ks nh kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">有多种方法可用于更新现有实体:</p><p id="398e" class="kr ks nh kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated"><code class="fe nr ns nt mz b">replaceEntity</code> -通过替换现有实体来更新它。</p><p id="80e1" class="kr ks nh kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated"><code class="fe nr ns nt mz b">mergeEntity</code> -通过将新的属性值合并到现有实体中来更新现有实体。</p><p id="6593" class="kr ks nh kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated"><code class="fe nr ns nt mz b">insertOrReplaceEntity</code> -通过替换现有实体来更新它。如果实体不存在，将插入一个新实体。</p><p id="77fd" class="kr ks nh kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated"><code class="fe nr ns nt mz b">insertOrMergeEntity</code> -通过将新的属性值合并到现有实体中来更新现有实体。如果实体不存在，将插入一个新实体。</p></blockquote><p id="a015" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于我们的目的，我们将使用<code class="fe nr ns nt mz b"><em class="nh">mergeEntity</em></code> <em class="nh"> </em>方法。</p><p id="b7f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们将创建一个名为updateEntity的新方法，将所有内容包装在一个承诺中，使用SDK调用mergeEntity，并解析或拒绝该承诺:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="e1ef" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">索引. js</h2><p id="4081" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在index.js文件的顶部，让我们导入刚刚创建的方法:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b132" class="mm lp iq mz b gy nd ne l nf ng">const<em class="nh"> </em>{<em class="nh"> updateEntity </em>}<em class="nh"> </em>=<em class="nh"> require</em>("../services/table-service");</span></pre><p id="f1a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，让我们将所有内容包装在一个try-catch中，在请求体上添加一些验证，创建我们的实体并调用updateEntity方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">UpdatePost — index.js</figcaption></figure><h1 id="de68" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">删除帖子</h1><p id="32f6" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在你应该是专家了😉。因此，我们将轻松地处理这个问题:Azure Tab = &gt; Functions = &gt; Lightning Blot = &gt; HTTP Trigger = &gt; Delete Post = &gt; Anonymous。</p><h2 id="5523" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">函数. json</h2><p id="dfa8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">将方法替换为“删除”并添加一条路线:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="288c" class="mm lp iq mz b gy nd ne l nf ng">{<br/> "bindings": [<br/> {<br/>  "authLevel": "anonymous",<br/>  "type": "httpTrigger",<br/>  "direction": "in",<br/>  "name": "req",<br/>  "methods": [<br/>   "delete"<br/>  ],<br/>  "route": "DeletePost/{blog}/{id}"<br/>  },<br/>  {<br/>   "type": "http",<br/>   "direction": "out",<br/>   "name": "res"<br/>  }<br/> ]<br/>}</span></pre><h2 id="4286" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">表格客户端</h2><p id="2aab" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">添加以下方法并导出到表客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">deleteEntity</figcaption></figure><h2 id="edf6" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">索引. js</h2><p id="9679" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">将以下代码添加到index.js中以删除实体:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">DeletePost — index.js</figcaption></figure><h1 id="c8c9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">视频教程</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Video Tutorial</figcaption></figure><h1 id="0262" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="f330" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如你所见，用Azure函数和存储表编写REST API极其容易。如果你计划在你的下一个项目中使用它，请在下面的评论区告诉我们。下次再见，祝编码愉快！</p><p id="f5b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nh">更多内容看</em> <a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">说白了。报名参加我们的</em> </a><a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">免费每周简讯</em> </a> <em class="nh">。在我们的</em> <a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nh">社区</em> </a> <em class="nh">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>