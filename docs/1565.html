<html>
<head>
<title>Advanced Page Transitions in Next.js with Router Events and GSAP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js中带有路由器事件和GSAP的高级页面过渡</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-page-transitions-in-next-js-with-router-events-and-gsap-e8435d2410bb?source=collection_archive---------0-----------------------#2022-04-03">https://javascript.plainenglish.io/advanced-page-transitions-in-next-js-with-router-events-and-gsap-e8435d2410bb?source=collection_archive---------0-----------------------#2022-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5a4f235b923f488d16d5ba4accffd01f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76gCHITGeI83-tuqiCxqEw.jpeg"/></div></div></figure><p id="47f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">页面转换很酷，此外，页面转换在Next.js网站中也很有用。正如我们所知，静态生成的网站(比如用Next.js制作的网站)非常快，这意味着从一个页面转到另一个页面几乎是即时的；但是如果你在你的站点中混合了SSG、SSR、ISR，一些页面会比其他的更快，有时检索数据或者重新生成一个页面会花费更多的时间，给用户一种有什么地方不能正常工作的印象(你让你的用户习惯了快速的页面切换！).</p><h2 id="db27" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">如何在Next.js中实现转换</h2><p id="3ad9" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Next.js允许您监听其Router对象中的各种事件，这些事件发生在页面到页面路由操作的生命周期中。例如，<code class="fe lu lv lw lx b">routeChangeStart()</code>在路由开始改变时被触发(例如当您单击一个链接时),而<code class="fe lu lv lw lx b">routeChangeCompleted()</code>在路由完成时被触发(例如新页面被完全加载)。获取这些事件并使用它们来显示/隐藏组件(例如加载的)是Next.js转换的方法。</p><h2 id="76ae" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">我们将如何在应用中实现过渡</h2><p id="4631" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们利用Next.js的基本布局功能将我们的转换逻辑保存在一个共享的<em class="ly"> Header </em>组件中，当路由器从一个页面移动到另一个页面时，我们将使用GSAP来制作动画。我们将只为“缓慢”的页面到页面路由激活动画(在我们的例子中，我们将模拟一个缓慢加载的页面)</p><h2 id="7f06" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">我们将建造什么</h2><p id="c657" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们将创建一个有四个虚拟页面(主页，我们做什么，关于，联系)的网站，所有这些页面将共享一个页眉(与菜单链接)和页脚。从一个页面传递到另一个页面将触发一个动画(如果页面加载时间超过300毫秒),该动画将隐藏当前页面，并显示目标页面。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/980d923480c34bc31be029e19647c4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MKfLLHK8VUCDxK8787rldw.gif"/></div></div></figure><h2 id="a139" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">先决条件</h2><p id="2f84" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">要学习本教程，您需要:</p><ul class=""><li id="b8b8" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">Next.js的基本知识，它的文件结构，它的路由，它使用布局的方式</li><li id="b609" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">React、NPM、模块安装等基础知识</li><li id="f74f" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">可选地，你需要对GSAP有一个基本的了解(但是你可以使用任何种类的动画包或者只使用CSS动画)和Tailwind CSS(我们首选的CSS框架)</li></ul><p id="4223" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以下载这个项目的源代码:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/popeating/transition" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">GitHub-pop eating/过渡</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">这是一个用create-next-app引导的Next.js项目。首先，运行开发服务器:打开…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jw mv"/></div></div></a></div><h2 id="2487" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">设置项目</h2><p id="ea23" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">创建新的Next.js项目:</p><pre class="ma mb mc md gt nk lx nl nm aw nn bi"><span id="0666" class="kw kx iq lx b gy no np l nq nr"><strong class="lx ir">npx create-next-app transition</strong></span></pre><p id="48dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进入<code class="fe lu lv lw lx b"><strong class="ka ir">transition</strong></code> <strong class="ka ir"> </strong>文件夹，安装需要的动画模块(我们这里是GSAP):</p><pre class="ma mb mc md gt nk lx nl nm aw nn bi"><span id="2c69" class="kw kx iq lx b gy no np l nq nr"><strong class="lx ir">npm i gsap</strong></span></pre><p id="c013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照官方指南安装和配置顺风CSS <a class="ae ns" href="https://tailwindcss.com/docs/guides/nextjs" rel="noopener ugc nofollow" target="_blank">:</a></p><div class="ms mt gp gr mu mv"><a href="https://tailwindcss.com/docs/guides/nextjs" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">用Next.js - Tailwind CSS安装Tailwind CSS</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">顺风CSS框架的文档。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">tailwindcss.com</p></div></div><div class="ne l"><div class="nt l ng nh ni ne nj jw mv"/></div></div></a></div><p id="d83c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们构建我们的四个页面，在<code class="fe lu lv lw lx b">pages</code>文件夹中创建4个文件(index.js、about.js、contacts.js和whatwedo.js)，并按照该模式对每个文件进行编码(根据页面更改函数的名称和文件的内容，在下面的示例中，我有index.js的代码):</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cffc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唯一不同的页面是:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="23bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将模拟一个需要2秒钟才能完成的服务器请求。</p><h2 id="107f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">构建布局</h2><p id="fb65" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们现在正在构建页面的布局，每个页面都将有一个页眉，一个页脚，以及在这两者之间的页面内容。</p><p id="ab00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，创建一个名为<code class="fe lu lv lw lx b"><strong class="ka ir">components</strong></code> <strong class="ka ir"> </strong>的文件夹，在这个文件夹里面添加一个名为<code class="fe lu lv lw lx b"><strong class="ka ir">header.js</strong></code>的文件:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9f0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这真的是一个基本的页眉，左边有一个logo，右边有一个到我们页面的链接菜单，页眉绝对定位居中；链接是用<code class="fe lu lv lw lx b"><strong class="ka ir">next/link</strong></code> <strong class="ka ir"> Link </strong>实现的，这样我们就可以使用Next.js内置路由器了。</p><p id="e6ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们创建一个页脚:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a6bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是更基本的，但仍然是绝对的。</p><p id="7d30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建包含页眉和页脚的主布局:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cd2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过这样修改Next.js应用程序的<code class="fe lu lv lw lx b">_app.js</code>来实现布局系统:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4065" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，如果您使用</p><pre class="ma mb mc md gt nk lx nl nm aw nn bi"><span id="4ae9" class="kw kx iq lx b gy no np l nq nr"><strong class="lx ir">npm run dev</strong></span></pre><p id="9146" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你把浏览器指向:<code class="fe lu lv lw lx b"><strong class="ka ir">http://localhost:3000</strong></code>你应该有一个工作菜单的基本网站:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/687d1d98a01fc53eaf44fc8257676961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUOZVZN5rP2VpkVCu1BHkw.png"/></div></div></figure><p id="6341" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">页面之间的导航是即时的(这非常好！)但是当您导航到“我们做什么”时，需要2秒钟(我们在服务器请求模拟中设置的时间)。因为一切都很快，一个缓慢加载的页面可能会破坏我们的用户体验。这就是为什么我们现在添加一个过渡，如果页面加载超过300毫秒，单击菜单链接就会触发这个过渡。在这种情况下，过渡将由4个彩色条组成，它们将覆盖屏幕(来自顶部)，然后再次显示屏幕(移回底部)。点击300毫秒后，覆盖动画将开始播放，如果目标页面未加载，一旦目标页面完全加载(如果页面被覆盖)，打开动画将开始播放。我们将在Header组件中保留动画逻辑和所有动画元素(动画Div ),以便它们在页面之间共享，并且不需要重新加载。</p><h2 id="3acb" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">构建动画</h2><p id="190e" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">首先，我们将创建覆盖屏幕的“外观”(第一个动画完成后页面的外观，第二个动画准备开始)。正如我们之前提到的，有4个不同颜色的条(每个25%宽)，覆盖整个屏幕，绝对位于所有内容的顶部:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/013387be1fe9684f649fbcdc55894c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sY6wtm4xxcSqniHXtCqlA.png"/></div></div></figure><p id="c988" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们的header.js将如下所示:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b0cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们希望条从顶部向下，所以我们在我们的<code class="fe lu lv lw lx b"><strong class="ka ir">global.css</strong></code>文件中添加了一个CSS规则</p><pre class="ma mb mc md gt nk lx nl nm aw nn bi"><span id="a1cf" class="kw kx iq lx b gy no np l nq nr"><strong class="lx ir">.cover {<br/>   transform: translateY(-100%);<br/>}</strong></span></pre><p id="e0cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以便条在屏幕外向上移动。</p><p id="bafa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们要监听路由器事件，我们感兴趣的事件是在我们离开页面之前触发的<code class="fe lu lv lw lx b"><strong class="ka ir">routeChangeStart</strong></code> <strong class="ka ir"> </strong>(这样我们就可以开始我们的“覆盖”动画)和一旦目的页面完全加载时触发的<code class="fe lu lv lw lx b"><strong class="ka ir">routeChangeCompleted</strong></code> <strong class="ka ir"> </strong>(这样我们就可以播放动画以显示页面)。我们还检查错误(例如双击链接)。</p><p id="905b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用useEffect钩子在Header组件上实例化这些事件侦听器。目前(而不是动画)，我们控制台记录事件。让我们通过添加以下逻辑来修改header.js文件:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们有两个函数(<code class="fe lu lv lw lx b">aniStart()</code>和<code class="fe lu lv lw lx b">aniEnd()</code>)用作事件监听器的回调函数，每次路由器改变时，事件监听器都使用useEffect钩子连接(并清理)到我们的应用程序。</p><p id="00af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您现在测试应用程序并在页面之间移动，如果您打开控制台，您将看到<code class="fe lu lv lw lx b">aniStart()</code>和<code class="fe lu lv lw lx b">aniEnd()</code>功能的记录。</p><p id="9303" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，只是一个在适当的时间动画酒吧的问题。当用户点击一个链接(<code class="fe lu lv lw lx b">aniStart()</code>)时，我们将使用GSAP一个接一个地将条形Y移动到0%，然后一旦加载了目标页面(<code class="fe lu lv lw lx b">aniEnd()</code>)，我们就将它们发送回Y -100%。我们还将启用延迟300毫秒的动画(将其包装在一个<em class="ly"> </em> <code class="fe lu lv lw lx b">setTimeout()</code>)，如果动画开始，我们将设置一个状态，通知我们的应用程序在加载完成后播放动画。最后，我们重置计时器和我们的状态。</p><p id="3a2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在GSAP构建动画会将header.js修改为:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9e11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了动画的技术方面(这主要与GSAP的工作方式有关)主要的概念是从点击开始有一个300毫秒的延迟(或多或少，取决于你的情况)如果动画被触发，我们设置一个状态<code class="fe lu lv lw lx b"><strong class="ka ir">isActive</strong></code> <strong class="ka ir"> </strong>为真，一旦目标页面被加载，如果<code class="fe lu lv lw lx b"><strong class="ka ir">isActive</strong></code>被设置为真，我们动画显示页面，否则，我们除了重置计时器什么也不做。</p><p id="10cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您现在运行您的项目，您可以看到导航到“我们做什么”将触发一个动画，覆盖屏幕，然后显示新页面。尽管如此，其他页面导航不需要动画，因为加载是即时的:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/980d923480c34bc31be029e19647c4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MKfLLHK8VUCDxK8787rldw.gif"/></div></div></figure><h2 id="c743" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">下一步是什么</h2><p id="88d2" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">使用这种技术，您可以使用GSAP或您喜欢的动画方法/包来实现任何类型的过渡(甚至可以使用路由器事件在单个页面上实现任何类型的动画)。</p><p id="5ef7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以在所有页面之间实现动画(但是我更喜欢延迟的方法，让快速加载的页面没有过渡)。</p><p id="0195" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们使用路由器，我们的应用程序总是知道我们要离开的页面和我们要去的页面，您可以使用这些信息来实现基于路由的不同动画。</p><p id="c8cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以通过<a class="ae ns" href="buymeacoffee.com/popland" rel="noopener ugc nofollow" target="_blank">请我喝咖啡</a>来支持我的工作</p><h2 id="1476" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">进一步阅读</h2><div class="ms mt gp gr mu mv"><a href="https://blog.bitsrc.io/next-js-13-what-do-the-new-bleeding-edge-features-actually-do-d3e5fd418563" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">Next.js 13:新的前沿特性实际上是做什么的？</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">你听说过Next.js 13是一个游戏改变者，但是为什么？让我们看看有哪些新功能，有哪些变化，以及它们…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">blog.bitsrc.io</p></div></div><div class="ne l"><div class="nx l ng nh ni ne nj jw mv"/></div></div></a></div><p id="e02b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">更多内容请看</em><a class="ae ns" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ly">plain English . io</em></strong></a><em class="ly">。报名参加我们的</em> <a class="ae ns" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ly">免费周报</em> </strong> </a> <em class="ly">。关注我们关于</em><a class="ae ns" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ly">Twitter</em></strong></a><a class="ae ns" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ly">LinkedIn</em></strong></a><em class="ly"/><a class="ae ns" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ly">YouTube</em></strong></a><em class="ly"/><a class="ae ns" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ly">不和</em> </strong> </a> <em class="ly">。对增长黑客感兴趣？检查</em> <a class="ae ns" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ly">电路</em> </strong> </a> <em class="ly">。</em></p></div></div>    
</body>
</html>