<html>
<head>
<title>6 Ways to Implement the JavaScript Extends Keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现JavaScript Extends关键字的6种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/6-ways-to-implement-the-javascript-extends-7fa1fc6a6b3e?source=collection_archive---------1-----------------------#2022-03-14">https://javascript.plainenglish.io/6-ways-to-implement-the-javascript-extends-7fa1fc6a6b3e?source=collection_archive---------1-----------------------#2022-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="75e4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">轻松实现JavaScript extends关键字的6种方法。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ba20186a609f459832b0e8ad575f0970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cgB8lfdqiatT6PvA"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c591" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript是一种奇怪的语言。一个需求可以通过多种方式实现(免费！)，这真的很神奇！</p><p id="3a7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将帮助您学习如何用6种方式在JavaScript中实现扩展的概念</p><h2 id="6cd2" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">1.原型链延伸</h2><p id="f439" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">构造函数、原型和实例的关系:每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，实例包含一个指向原型对象的指针。</p><p id="3dad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">继承的本质是复制，即重写原型对象，用新类型的实例替换。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Prototype Chain Extends</figcaption></figure><h2 id="f9c3" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">不足之处</h2><p id="ecf0" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">多个实例对引用类型的操作可能被篡改。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="6092" class="mw lq in bd lr mx my mz lu na nb nc lx jt nd ju ma jw ne jx md jz nf ka mg ng bi translated">2.借用构造函数扩展</h1><p id="57c4" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">使用父类的构造函数来增强子类实例，相当于将父类的实例复制到子类中(不使用原型)</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Borrowing Constructor Extends</figcaption></figure><p id="d5a5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">核心代码是<code class="fe nh ni nj nk b"> Parent.call(this)</code>，父构造函数在创建子类实例时被调用，所以Child的每个实例都会复制Parent中的属性。</p><h2 id="1685" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">不足之处</h2><ul class=""><li id="b6c7" class="nl nm in kv b kw mi kz mj lc nn lg no lk np lo nq nr ns nt bi translated">只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li id="1c9c" class="nl nm in kv b kw nu kz nv lc nw lg nx lk ny lo nq nr ns nt bi translated">无法实现重用，每个子类都有一个父类实例函数的副本，这会影响性能</li></ul></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="74c3" class="mw lq in bd lr mx my mz lu na nb nc lx jt nd ju ma jw ne jx md jz nf ka mg ng bi translated">3.原型扩展</h1><p id="5582" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">实现原理是用一个空对象作为中介，直接把一个对象赋给空对象构造器的原型。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Core</figcaption></figure><p id="b564" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nh ni nj nk b">func()</code>函数执行传入对象的浅层复制，将<strong class="kv io">构造函数F的原型指向传入对象</strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Prototypal Extends</figcaption></figure><h2 id="8cad" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">不足之处</h2><ul class=""><li id="7b51" class="nl nm in kv b kw mi kz mj lc nn lg no lk np lo nq nr ns nt bi translated">原型链继承了指向同一的多个实例的引用类型属性，存在被篡改的可能。</li><li id="a71b" class="nl nm in kv b kw nu kz nv lc nw lg nx lk ny lo nq nr ns nt bi translated">无法传递参数。</li></ul><p id="e6c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另外，<code class="fe nh ni nj nk b"> Object.create()</code>方法存在于ES5中，可以代替上面的<code class="fe nh ni nj nk b">func method.</code></p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="8558" class="mw lq in bd lr mx my mz lu na nb nc lx jt nd ju ma jw ne jx md jz nf ka mg ng bi translated">4.寄生延伸</h1><p id="a525" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">核心实现原理:在原型继承的基础上，增强对象并返回构造函数</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Parasitic Extends</figcaption></figure><p id="397f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个函数的主要功能是在构造函数中添加属性和方法来增强函数</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6cb7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">缺点:与原型继承相同</strong></p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="bac2" class="mw lq in bd lr mx my mz lu na nb nc lx jt nd ju ma jw ne jx md jz nf ka mg ng bi translated">5.寄生成分扩展</h1><p id="2513" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">通过借用的构造函数传递参数和寄生模式的组合来实现扩展</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Parasitic Compositional Extends</figcaption></figure><p id="4bfc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个例子的效率在于它只调用了一次<code class="fe nh ni nj nk b">SuperType </code>构造函数，因此避免了在<code class="fe nh ni nj nk b">SubType.prototype</code>上创建不必要的、多余的属性。</p><p id="6a3d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同时，原型链保持不变；因此，<code class="fe nh ni nj nk b">instanceof </code>和<code class="fe nh ni nj nk b">isPrototypeOf()</code>可以正常使用</p><p id="34ac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">顺便说一下，<strong class="kv io">这是最成熟的方法，也是现在库实现的方法</strong></p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="776e" class="mw lq in bd lr mx my mz lu na nb nc lx jt nd ju ma jw ne jx md jz nf ka mg ng bi translated">6.ES6类继承扩展</h1><p id="50da" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Glossary/Class" rel="noopener ugc nofollow" target="_blank"> extends关键字</a>主要用于类声明或类表达式中，以创建一个类，该类是另一个类的子类。</p><p id="1132" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其中，<code class="fe nh ni nj nk b">constructor </code>代表建造者。一个类中只能有一个构造函数。如果超过一个，将报告<code class="fe nh ni nj nk b">SyntaxError </code>。如果没有显式指定构造函数，将添加默认的<code class="fe nh ni nj nk b">constructor </code>方法。使用示例如下</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Final Version</figcaption></figure><h1 id="eda5" class="mw lq in bd lr mx nz mz lu na oa nc lx jt ob ju ma jw oc jx md jz od ka mg ng bi translated">总结</h1><ol class=""><li id="4bb9" class="nl nm in kv b kw mi kz mj lc nn lg no lk np lo oe nr ns nt bi translated">函数声明和类声明的区别。<br/>函数声明被提升，而类声明没有。首先，您需要声明您的类，然后访问它，否则，代码将抛出一个ReferenceError</li><li id="8b75" class="nl nm in kv b kw nu kz nv lc nw lg nx lk ny lo oe nr ns nt bi translated">ES5扩展和ES6扩展的区别</li></ol><ul class=""><li id="131f" class="nl nm in kv b kw kx kz la lc of lg og lk oh lo nq nr ns nt bi translated">ES5中的扩展本质上是先创建子类的一个实例对象，然后将超类的方法添加到this (Parent.call(this))。</li><li id="0f7f" class="nl nm in kv b kw nu kz nv lc nw lg nx lk ny lo nq nr ns nt bi translated">ES6的扩展是不同的。本质上，首先创建父类的实例对象this，然后使用子类的构造函数来修改this。因为子类没有自己的this对象，所以必须先调用<code class="fe nh ni nj nk b">superclass </code>的<code class="fe nh ni nj nk b">super() method</code>，否则新实例会报错。</li></ul><p id="b121" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="oi">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oi">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oi">免费周报</em> </strong> </a> <em class="oi">。关注我们</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oi">Twitter</em></strong></a><em class="oi">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oi">LinkedIn</em></strong></a><em class="oi">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oi">社区</em> </strong> </a> <em class="oi">。</em></strong></a></p></div></div>    
</body>
</html>