<html>
<head>
<title>Angular Testing — The Easiest Way To Start Writing Unit Test Case</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度测试——开始编写单元测试用例的最简单方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-testing-the-easiest-way-to-start-writing-unit-test-case-74b6c8df26d6?source=collection_archive---------9-----------------------#2022-11-29">https://javascript.plainenglish.io/angular-testing-the-easiest-way-to-start-writing-unit-test-case-74b6c8df26d6?source=collection_archive---------9-----------------------#2022-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="44de" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@kushsavani" rel="noopener">角度单元测试指南</a></h2><div class=""/><div class=""><h2 id="aca7" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">如果你是angular开发人员，并且从单元测试用例开始。那么这肯定会是你的初学者指南。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e573a043c948b8c0f956427261d0ad09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XcODE4s9jeQkJWyx"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/es/@blakeconnally?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Blake Connally</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4ae2" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">去年圣诞节前后，我作为一名Angular开发人员开始了我的旅程，我工作的一个重要部分是单元测试。我知道在开始时，我犯了很多新手的错误，并在StackOverflow和GitHub上花费了大量的时间来寻找合适的解决方案以及如何为不同的场景编写正确的测试用例。经历了几次精疲力尽之后。我发现了一种构建单元测试用例的理想方法。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="a800" class="mf mg in bd mh mi mj mk ml mm mn mo mp kc mq kd mr kf ms kg mt ki mu kj mv mw bi translated">让我们从介绍开始</h1><p id="a722" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">自从<strong class="le ix"> Kent Beck </strong>开发或者重新发现<a class="ae lb" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank"> <em class="nc">测试驱动开发</em> </a> <em class="nc">以来已经快20年了。这给了软件开发人员更多的责任来为他们的应用程序编写自动化测试。</em></p><p id="2088" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">Angular从一开始就是为了可测试而构建的。Angular帮助您将应用程序架构定义为松散耦合组件的集合，以及基于依赖注入的Typescript，这使得模仿依赖更加容易。有了这个好处，angular中的单元测试就可以用DOM和功能来测试整个组件。在这部伟大的作品中，茉莉和业力帮助angular完成这个角色。</p><h2 id="956d" class="nd mg in bd mh ne nf dn ml ng nh dp mp ll ni nj mr lp nk nl mt lt nm nn mv it bi translated">一些关键词和基本描述</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><ul class=""><li id="76b5" class="nq nr in le b lf lg li lj ll ns lp nt lt nu lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">describe</code> :-使用“描述”功能对一系列测试进行分组。这个函数有两个参数，一个字符串和一个回调函数。</li><li id="f21d" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">beforeEach</code> :-这将在每个测试用例执行之前运行。在这里，它每次都会提供一个PersonClass的新实例。</li><li id="d5bd" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">it</code> :-该功能用于创建特定的测试。其进入所描述的块内部。这个函数有两个参数，一个字符串和一个回调函数。</li><li id="c4c7" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">expect</code> :-该功能确认测试正确运行并得到预测的结果。<code class="fe nz oa ob oc b">expect</code>有两部分，第一部分是作为测试结果的结果值，第二部分是我们在测试结束时想要的期望值。</li><li id="63bb" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">afterEach</code> :- <strong class="le ix"> </strong>该函数在每个测试用例运行后执行。大多数情况下，我们使用afterEach进行测试用例执行后的清理工作。</li></ul><p id="89a8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">请记住，当您编写断言时，您应该尝试每个测试只有一个断言。当我们在一个测试中放置多个断言时，调试会变得复杂，并且每个断言必须为真，测试才能通过。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="48be" class="mf mg in bd mh mi mj mk ml mm mn mo mp kc mq kd mr kf ms kg mt ki mu kj mv mw bi translated">浅层测试vs隔离测试vs集成测试</h1><p id="5d0c" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">当我们开始测试角度组件时，我们有三种可能的方法来设计测试用例:集成、浅层和隔离测试。我们不会深入探讨，但让我简化一下这项技术。</p><h2 id="8af7" class="nd mg in bd mh ne nf dn ml ng nh dp mp ll ni nj mr lp nk nl mt lt nm nn mv it bi translated"><strong class="ak">浅层测试</strong></h2><blockquote class="oi"><p id="6640" class="oj ok in bd ol om on oo op oq or lx dk translated">浅层测试关注组件的类和模板，而不是通过模仿它们的依赖关系。</p></blockquote><p id="abb9" class="pw-post-body-paragraph lc ld in le b lf os jx lh li ot ka lk ll ou ln lo lp ov lr ls lt ow lv lw lx ig bi translated">当我们谈论浅层测试时，我们主要测试组件类逻辑和模板。我们将模仿模板中的所有其他组件，或者我们可以称之为子组件。</p><p id="e837" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">举个例子，我们有<code class="fe nz oa ob oc b">PersonComponent</code>。在组件模板中，存在一些自定义元素和指令。如果我们以正确的方式测试它，angular将抛出告诉我们它不知道一些模板语法。另一方面，我们只想测试不包括元素的主要组件。</p><p id="c1ca" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">为了只关注组件的模板而不是它的依赖项，我们需要告诉angular不要试图编译那些定制元素。而这里由<code class="fe nz oa ob oc b">schemas: [NO_ERRORS_SCHEMA]</code>扮演主角。这将在测试床配置中进行配置，并告诉Angular当它不能识别自定义元素时不要抛出任何错误。</p><h2 id="2c84" class="nd mg in bd mh ne nf dn ml ng nh dp mp ll ni nj mr lp nk nl mt lt nm nn mv it bi translated">孤立测试</h2><blockquote class="oi"><p id="f989" class="oj ok in bd ol om on oo op oq or lx dk translated">独立测试只关注组件的类。</p></blockquote><p id="a25e" class="pw-post-body-paragraph lc ld in le b lf os jx lh li ot ka lk ll ou ln lo lp ov lr ls lt ow lv lw lx ig bi translated">当我们为组件选择隔离测试时，我们首先主要测试组件逻辑。我们不必关注模板。即使组件包含定制元素和指令，因为隔离测试只关注组件的逻辑，模板是不相关的。</p><h2 id="d16e" class="nd mg in bd mh ne nf dn ml ng nh dp mp ll ni nj mr lp nk nl mt lt nm nn mv it bi translated">综合测试</h2><blockquote class="oi"><p id="8a26" class="oj ok in bd ol om on oo op oq or lx dk translated">一个集成的测试将覆盖组件及其依赖项的整体。</p></blockquote><p id="df96" class="pw-post-body-paragraph lc ld in le b lf os jx lh li ot ka lk ll ou ln lo lp ov lr ls lt ow lv lw lx ig bi translated">当我们为一个组件选择集成测试时，我们必须测试组件逻辑、它的模板以及它所有的依赖项。这意味着如果模板包含定制组件和指令，我们需要在测试床配置中注入这些依赖关系。这个测试维护起来可能更昂贵，调试起来也更困难，因为我们需要处理它所有的依赖关系。这看起来像是肤浅的测试，但我们测试更多的设计，更深入。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="36c2" class="mf mg in bd mh mi mj mk ml mm mn mo mp kc mq kd mr kf ms kg mt ki mu kj mv mw bi translated">真实世界的组件测试</h1><p id="0f1f" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">在一个真实的项目中，你需要测试更复杂的组件。例如，我们想测试包含菜单的<code class="fe nz oa ob oc b">NavigationComponent</code>。因此，您希望只测试主要组件，而不用担心菜单。在这种情况下，我们可以使用<em class="nc">浅层</em>测试。让我们开始吧🏃…</p><h2 id="6027" class="nd mg in bd mh ne nf dn ml ng nh dp mp ll ni nj mr lp nk nl mt lt nm nn mv it bi translated">导入依赖项</h2><p id="3271" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">当我们测试一个功能完整的组件时，它需要大量的依赖项。让我们按以下顺序导入它们:</p><ul class=""><li id="2f3a" class="nq nr in le b lf lg li lj ll ns lp nt lt nu lx nv nw nx ny bi translated">测试来自角度的依赖关系</li><li id="85a6" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated">从属关系包含在角度</li><li id="4409" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated">您为此项目创建的依赖项</li></ul><p id="8815" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这些依赖项是测试模块工作所必需的。创建新组件时，Angular已经添加了其中的一些。</p><p id="6508" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">测试来自角度的依赖关系</strong></p><ol class=""><li id="ec7e" class="nq nr in le b lf lg li lj ll ns lp nt lt nu lx ox nw nx ny bi translated"><code class="fe nz oa ob oc b">import { DebugElement } from '@angular/core';</code> —在这里，我们可以在测试过程中使用<code class="fe nz oa ob oc b">DebugElement</code>来检查元件。我们可以认为它是原生的<code class="fe nz oa ob oc b">HTMLElement</code>,带有一些额外的方法和属性。</li><li id="55ac" class="nq nr in le b lf od li oe ll of lp og lt oh lx ox nw nx ny bi translated"><code class="fe nz oa ob oc b">import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';</code> <br/> - <code class="fe nz oa ob oc b">ComponentFixture</code> :-我们可以用它来创建一个组件的夹具，然后用它来调试。<br/> - <code class="fe nz oa ob oc b">TestBed</code> :-我们可以使用这个类来设置和配置我们的测试。这是Angular为测试提供的最重要的工具之一。推荐参观<a class="ae lb" href="https://angular.io/api/core/testing/TestBed" rel="noopener ugc nofollow" target="_blank"> Doc </a>。<br/> - <code class="fe nz oa ob oc b">fakeAsync</code> :-使用<code class="fe nz oa ob oc b">fakeAsync</code>将确保所有异步任务在执行断言之前完成。在使用<code class="fe nz oa ob oc b">fakeAsync</code>的时候，我们可以用<code class="fe nz oa ob oc b">tick</code>来模拟时间的流逝。它接受一个参数:向前移动时间的毫秒数，默认值为零毫秒。</li><li id="ca5e" class="nq nr in le b lf od li oe ll of lp og lt oh lx ox nw nx ny bi translated"><code class="fe nz oa ob oc b">import { By } from '@angular/platform-browser';</code> —我们可以使用<code class="fe nz oa ob oc b">By</code>类来选择DOM元素。这个类提供了三个方法:<br/> - <code class="fe nz oa ob oc b">all</code> :-这将返回所有的元素。没有参数需要通过<br/> - <code class="fe nz oa ob oc b">css</code> :-使用CSS属性，可以选择某些元素。接受一个参数:CSS属性。<br/> - <code class="fe nz oa ob oc b">directive</code> :-使用指令名，选择元素。接受一个参数:指令名。</li><li id="5635" class="nq nr in le b lf od li oe ll of lp og lt oh lx ox nw nx ny bi translated"><code class="fe nz oa ob oc b">import { NoopAnimationsModule } from '@angular/platform-browser/animations';</code> —这个模块类将模拟动画，这允许测试快速运行，而不需要等待动画结束。</li><li id="3417" class="nq nr in le b lf od li oe ll of lp og lt oh lx ox nw nx ny bi translated"><code class="fe nz oa ob oc b">import { BrowserDynamicTestingModule } from '@angular/platform-browser-dynamic/testing';</code> —该模块帮助引导用于测试的浏览器。</li><li id="87f0" class="nq nr in le b lf od li oe ll of lp og lt oh lx ox nw nx ny bi translated"><code class="fe nz oa ob oc b">import { RouterTestingModule } from '@angular/router/testing';</code> —该模块类将为测试设置路由。我们将它包括在测试中，因为一些动作将涉及改变路线。</li></ol><p id="cc9a" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">依赖关系包含在角度</strong>中</p><p id="e14d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这种依赖性直接来自于您在组件中使用的<code class="fe nz oa ob oc b">@angular</code>。<br/> <code class="fe nz oa ob oc b">import { FormsModule } from '@angular/forms';</code> —这里的<code class="fe nz oa ob oc b">FormsModule</code>是用于组件逻辑和测试的模块之一。</p><p id="6025" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">您为此项目创建的依赖关系<strong class="le ix"/></p><p id="b870" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">您可以添加完成测试所需的其余依赖项。您可以添加第三方模块，如材料UI模块、其他组件、常量、指令、接口等。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="c585" class="nd mg in bd mh ne nf dn ml ng nh dp mp ll ni nj mr lp nk nl mt lt nm nn mv it bi translated">设置测试</h2><p id="48f7" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">因此，设置的第一步是添加<code class="fe nz oa ob oc b">describe</code>块，它将作为所有测试的父，并声明我们需要的实例变量。<code class="fe nz oa ob oc b">describe</code>方法创建一个包含所有测试的测试套件。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><ul class=""><li id="d847" class="nq nr in le b lf lg li lj ll ns lp nt lt nu lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">fixture</code> :-这将存储一个<code class="fe nz oa ob oc b">ComponentFixture</code>的实例，它包含帮助您调试和测试组件的方法</li><li id="707a" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">component</code> :-这将存储我们组件的实例。</li><li id="6798" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">rootElement</code> :-这将为我们的组件存储<code class="fe nz oa ob oc b">DebugElement</code>，在这里我们可以访问它的子组件。</li></ul><p id="2982" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在这个声明之后，如果我们真正的服务进行HTTP调用，我们可以创建一个假的服务。这将允许我们集中精力测试组件，而不用担心处理服务。<code class="fe nz oa ob oc b">beforeEach</code>的重要部分</p><p id="2f1d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">现在，您声明变量和假服务，添加两个<code class="fe nz oa ob oc b">beforeEach</code>块，它们将在每次测试之前执行。第一个<code class="fe nz oa ob oc b">beforeEach</code>将设置<code class="fe nz oa ob oc b">TestBed</code>配置。第二个将设置我们的实例变量。把它们分开是个好习惯。</p><p id="63ae" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">首先</strong> <code class="fe nz oa ob oc b"><strong class="le ix">beforeEach</strong></code> <strong class="le ix">设置</strong></p><p id="d2e8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><code class="fe nz oa ob oc b">TestBed</code>类有一个名为<code class="fe nz oa ob oc b">configureTestingModule</code>的方法。也就是配置测试模块。类似于我们在app.module.ts文件中使用的<code class="fe nz oa ob oc b">NgModule</code>类。唯一的区别是这里的对象是一个<code class="fe nz oa ob oc b">TestModuleMetadata</code>类型别名的格式。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a695" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这里，我们使用<code class="fe nz oa ob oc b">overrideModule</code>来表示那些延迟加载组件。<br/>让我们大致了解一下<code class="fe nz oa ob oc b">TestModuleMetadata</code>可选字段。</p><ul class=""><li id="97b9" class="nq nr in le b lf lg li lj ll ns lp nt lt nu lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">declarations</code> :-您可以在这里列出需要添加的组件</li><li id="3f91" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated">你可以在这里列出模块</li><li id="d85a" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">providers</code> :-这是用于依赖注入的</li><li id="b5d1" class="nq nr in le b lf od li oe ll of lp og lt oh lx nv nw nx ny bi translated"><code class="fe nz oa ob oc b">schemas</code> :-添加模式以允许某些属性，如<code class="fe nz oa ob oc b">NO_ERRORS_SCHEMA</code>。</li></ul><p id="50e5" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">第二个</strong>T3<strong class="le ix">设置</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="36ea" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><code class="fe nz oa ob oc b">fixture</code>变量存储了来自<code class="fe nz oa ob oc b">TestBed.createComponent</code>方法的类似组件的对象，您可以使用它进行调试和测试。<code class="fe nz oa ob oc b">component</code>变量保存从<code class="fe nz oa ob oc b">fixture.componentInstance</code>属性获得的组件。</p><p id="a007" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><code class="fe nz oa ob oc b">detectChanges</code>方法触发组件的变化检测周期。在初始化组件或更改数据绑定属性后，需要调用它。这也会渲染DOM。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="885d" class="nd mg in bd mh ne nf dn ml ng nh dp mp ll ni nj mr lp nk nl mt lt nm nn mv it bi translated">添加测试</h2><p id="47be" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">您已经准备好编写测试用例了。现在一切都解决了，您可以开始测试组件功能了。如果我们的组件拥有一个私有方法，我们不需要测试它，因为测试组件的公共API会测试它们。一般来说，你不需要测试私有方法。如果一个方法重要到需要测试，你应该考虑把它公开。</p><p id="6592" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">对于每一个测试用例来说，<code class="fe nz oa ob oc b">detectChanges</code>都会起到重要的作用。在产品中，Angular使用运行变更检测的区域，但是在单元测试中，我们没有这种机制。相反，我们需要在对组件进行更改后，在测试中频繁调用<code class="fe nz oa ob oc b">detectChanges</code>。</p><p id="3ff1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">关于在测试用例中写什么，这完全基于你的组件逻辑和模板。你可以在这里找到更多的<a class="ae lb" href="https://angular.io/guide/testing-components-basics" rel="noopener ugc nofollow" target="_blank"/>。您需要在测试覆盖结果中覆盖整个组件。这里是<a class="ae lb" href="https://angular.io/guide/testing-code-coverage" rel="noopener ugc nofollow" target="_blank">角度代码覆盖</a>的指南。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="d34e" class="mf mg in bd mh mi mj mk ml mm mn mo mp kc mq kd mr kf ms kg mt ki mu kj mv mw bi translated">结论</h1><p id="162c" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">如果你理解角度测试模块的核心特性，单元测试角度应用程序是很有趣的。我们已经浏览了一堆特性和例子，试图理解如何编写一个好的和合适的角度组件测试用例。我个人推荐你阅读<a class="ae lb" href="https://www.oreilly.com/library/view/testing-angular-applications/9781617293641/" rel="noopener ugc nofollow" target="_blank">测试角度应用</a>书，了解更多更深入的知识。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="4651" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> <em class="nc">感谢您的阅读，如果您发现这很有用，请为它鼓掌，并帮助其他人找到它。更多有趣的故事请关注我。</em>T24】</strong></p><p id="7e94" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="nc">更多内容请看</em><a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="nc">plain English . io</em></strong></a><em class="nc">。</em></p><p id="9725" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="nc">报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> <em class="nc">免费每周简讯</em> </strong> </a> <em class="nc">。关注我们关于</em> <a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> <em class="nc">推特</em></strong></a><a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="nc">LinkedIn</em></strong></a><em class="nc"/><a class="ae lb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="nc">YouTube</em></strong></a><em class="nc"/><a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="nc">不和</em> </strong> </a> <strong class="le ix"> <em class="nc">。</em>T51】</strong></p><p id="3f83" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> <em class="nc">对缩放您的软件启动感兴趣</em> </strong> <em class="nc">？检查</em> <a class="ae lb" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> <em class="nc">电路</em> </strong> </a> <em class="nc">。</em></p></div></div>    
</body>
</html>