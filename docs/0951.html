<html>
<head>
<title>GraphQL, Node.js, and MongoDB — Made Easy with NestJS and Mongoose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL、Node.js和MongoDB——使用NestJS和Mongoose变得很容易</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/graphql-nodejs-mongodb-made-easy-with-nestjs-and-mongoose-29f9c0ea7e1d?source=collection_archive---------1-----------------------#2022-02-23">https://javascript.plainenglish.io/graphql-nodejs-mongodb-made-easy-with-nestjs-and-mongoose-29f9c0ea7e1d?source=collection_archive---------1-----------------------#2022-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6359" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是一个关于如何使用NestJS和Mongoose模块轻松构建带有MongoDB连接的GraphQL的教程。</h2></div><p id="5613" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将展示如何使用NestJS和Mongoose模块以一种非常简单的方式用MongoDB连接搭建GraphQL。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/aa3f29fb8ff915eaa54a8b80c7985b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSMocU476Tzx-E2ZRV-v_g.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://www.pexels.com/@gabby-k?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Monstera</a> from <a class="ae lr" href="https://www.pexels.com/photo/crop-clever-woman-writing-in-book-6237959/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="a846" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你好！今天，我决定简单解释一下如何在一个真正的NestJS应用程序中使用MongoDB。我已经写了一篇文章来解释如何将GraphQL与TypeORM一起使用，这篇文章每月都有很好的阅读量，这促使我使用相同的方法，但使用Mongoose，这是后端领域的必备知识，作为非关系数据库。</p><p id="0615" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想查看我的<a class="ae lr" href="https://medium.com/r?url=https%3A%2F%2Fmakinhs.medium.com%2Fgraphql-nodejs-postgres-made-easy-with-nestjs-and-typeorm-4daff3c516d" rel="noopener"> TypeORM文章</a>，请保存后阅读；)</p><div class="ls lt gp gr lu lv"><a href="https://makinhs.medium.com/graphql-nodejs-postgres-made-easy-with-nestjs-and-typeorm-4daff3c516d" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">graph QL+NodeJS+Postgres——使用NestJS和TypeORM使之变得简单</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">使用TypeORM在NestJS GraphQL后端添加Postgres模块，并创建一个基本的CRUD</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">makinhs.medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ll lv"/></div></div></a></div><p id="62c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样…如果你够懒，在文章的结尾你可以在一个公共的Git库中找到所有的源代码。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="a485" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>附带了一个易于使用的<a class="ae lr" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>在本文中，我们将连接到一个本地MongoDB。动机是因为MongoDB比关系数据库更容易开始，编码速度更快，而且根据我过去的经验，对初学者来说非常友好。</p><p id="f857" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，MongoDB是一个非关系数据库，比正式的关系数据库更加灵活，适应性更强。在本文中，我不会深入解释什么是什么，我们可以马上动手操作。我推荐阅读其他文章中关于关系数据库和非关系数据库的内容，比如本文<a class="ae lr" href="https://www.pluralsight.com/blog/software-development/relational-vs-non-relational-databases" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="78c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始编码之前，请确保安装了与我相同或更高版本的:</p><ul class=""><li id="fe96" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated"><a class="ae lr" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>已安装(v14+)</li><li id="dacf" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">嵌套CLI版本为:8.2.0</li><li id="871f" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">yarn版本:1.22.10(我还是喜欢yarn over npm)</li></ul><p id="a019" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了编码和开始，让我们看看我在上一篇文章中使用的前一个<a class="ae lr" href="https://github.com/makinhs/nestjs-with-graphql" rel="noopener ugc nofollow" target="_blank">项目</a>。我以前的文章，可以在我的<a class="ae lr" href="https://github.com/makinhs/nestjs-with-graphql/tree/001" rel="noopener ugc nofollow" target="_blank"> 001 </a>分支中找到。</p><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/graphql-backend-in-nodejs-made-easy-with-nestjs-1489be18b994"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用NestJS简化Node.js中的GraphQL后端</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在本文中，我将向您展示如何以一种非常非常简单的方式开始一个GraphQL后端项目…使用NestJS！</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="me l"><div class="nf l mg mh mi me mj ll lv"/></div></div></a></div><p id="a1d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你得到了<a class="ae lr" href="https://github.com/makinhs/nestjs-with-graphql/tree/001" rel="noopener ugc nofollow" target="_blank"> 001 </a>分支，我们就已经有了最小的NestJS配置集。如果你不知道我在NestJS谈论什么，请检查我的<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/graphql-backend-in-nodejs-made-easy-with-nestjs-1489be18b994">以前的文章</a>。</p><p id="14a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的项目是一个简单的搭建项目，已经安装了GraphQL模块和一些额外的功能，比如我们将使用mongoose实现一个基本的CRUD的用户模块。</p><p id="a88f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的上一篇文章中，我们直接在<em class="ng"> app.module.ts. </em>中配置了GraphQL模块。在这篇文章中，我想分享另一个模式，您可以在您的项目中使用它，它使app.module.ts对于共享库来说更小一些。为此，我们将在您的根项目终端中使用以下nest-cli命令创建一个公共模块:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="de0f" class="nm nn iq ni b gy no np l nq nr">nest g module common</span></pre><p id="1ace" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将导致类似于以下内容的结果:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="fb97" class="nm nn iq ni b gy no np l nq nr">➜ nest g module common<br/>CREATE src/common/common.module.ts (83 bytes)<br/>UPDATE src/app.module.ts (560 bytes)</span></pre><p id="07e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为我们创建一个新模块，我们将使用它来共享GraphQL和Mongoose模块。先说GraphQL那个。</p><p id="097b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只需创建一个名为graphql.module.ts的文件，并添加以下内容:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="0f96" class="nm nn iq ni b gy no np l nq nr">import { Module } from '@nestjs/common';<br/>import { GraphQLModule } from '@nestjs/graphql';<br/><br/>@Module({<br/>  imports: [<br/>    GraphQLModule.<em class="ng">forRoot</em>({<br/>      autoSchemaFile: './schema.gql',<br/>      debug: true,<br/>      playground: true,<br/>    }),<br/>  ],<br/>})<br/>export class GraphqlModule {}</span></pre><p id="e1d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在您的common.module.ts中</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="2748" class="nm nn iq ni b gy no np l nq nr">import { Module } from '@nestjs/common';<br/>import { GraphqlModule } from './graphql.module';<br/><br/>@Module({<br/>  imports: [GraphqlModule],<br/>  exports: [GraphqlModule],<br/>})<br/>export class CommonModule {}</span></pre><p id="19af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后但同样重要的是，在app.module.ts中:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="fe2d" class="nm nn iq ni b gy no np l nq nr">import { Module } from '@nestjs/common';<br/>import { AppController } from './app.controller';<br/>import { AppService } from './app.service';<br/>import { UsersModule } from './users/users.module';<br/>import { CommonModule } from './common/common.module';<br/><br/>@Module({<br/>  imports: [CommonModule, UsersModule],<br/>  controllers: [AppController],<br/>  providers: [AppService],<br/>})<br/>export class AppModule {}</span></pre><p id="0580" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意CommonModule是第一个…让我们配置一个本地mongo数据库，并设置我们的Mongoose来使用它！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="5080" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在安装Mongoose模块之前，我们需要确保我们有一个Mongo实例在本地运行和/或在互联网上可访问(比如<a class="ae lr" href="https://www.mongodb.com/pt-br/cloud/atlas/register" rel="noopener ugc nofollow" target="_blank"> Mongo Atlas </a>)。在本文中，我将展示一种使用<a class="ae lr" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>轻松运行mongo实例的方法。</p><p id="8cdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的计算机上安装Docker之后，只需在您的根项目中创建一个docker-compose.yaml，如下所示:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="8aaf" class="nm nn iq ni b gy no np l nq nr">version: '3'<br/>services:<br/>  mongo:<br/>    image: mongo<br/>    restart: unless-stopped<br/>    ports:<br/>      - '27017:27017'<br/>    volumes:<br/>      - .docker-data/mongo:/data/medium-db</span></pre><p id="ae61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，要运行此实例，请运行以下命令:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="da67" class="nm nn iq ni b gy no np l nq nr">docker compose up -d</span></pre><p id="9a1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">意思是(从你的终端)分离，你可以做其他的任务。</p><p id="2478" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们现在安装猫鼬模块。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="211a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经搭建好了基本的NestJS，并且Mongo数据库已经在本地使用Docker运行，那么让我们安装Mongoose模块，当我们的应用程序与Mongo数据库连接时，它将简化我们的开发人员的工作。</p><p id="379d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要安装mongose模块以及NestJS mongoose模块:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="2e65" class="nm nn iq ni b gy no np l nq nr">yarn add mongoose <a class="ae lr" href="http://twitter.com/nestjs/mongoose" rel="noopener ugc nofollow" target="_blank">@nestjs/mongoose</a></span></pre><p id="80c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在我们的公共文件夹中，让我们用以下内容创建一个mongo.module.ts文件:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="1296" class="nm nn iq ni b gy no np l nq nr">import { Module } from '@nestjs/common';<br/>import { MongooseModule } from '@nestjs/mongoose';<br/><br/>@Module({<br/>  imports: [<br/>    MongooseModule.<em class="ng">forRootAsync</em>({<br/>      useFactory: async () =&gt; ({<br/>        uri: 'mongodb://localhost/medium-db',<br/>      }),<br/>    }),<br/>  ],<br/>})<br/>export class MongoModule {}</span></pre><p id="f7e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们以一种可以异步加载模块的方式使用forRootAsync。这个的最大用途是加载。模块中的env变量，您可以部署相同的代码，但目标是阶段/生产或您想要使用的任何其他环境。</p><p id="9abe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使我们的文章对您更有成效，让我们使用这种方法，从创建/使用您的。根项目中的env文件，包含以下内容:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="d6a6" class="nm nn iq ni b gy no np l nq nr">MONGODB_URL=mongodb://localhost/medium-db</span></pre><p id="1eb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，NestJS允许我们使用他们的配置服务，该服务可以安装在:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="a576" class="nm nn iq ni b gy no np l nq nr">yarn add @nestjs/config</span></pre><p id="4ec5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来的解释我就不深究了，但是为了控制你的”。env "文件并在那里实际设置一些业务逻辑，请使用如下所示的config.module.ts:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="a2af" class="nm nn iq ni b gy no np l nq nr">import { Module } from '@nestjs/common';<br/>import { ConfigModule as NestConfigModule } from '@nestjs/config';<br/><br/>@Module({<br/>  imports: [<br/>    NestConfigModule.<em class="ng">forRoot</em>({<br/>      envFilePath: ['.env'],<br/>      isGlobal: true,<br/>    }),<br/>  ],<br/>})<br/>export class ConfigModule {}</span></pre><p id="cff9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在您的common.module.ts中:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="474f" class="nm nn iq ni b gy no np l nq nr">import { Module } from '@nestjs/common';<br/>import { GraphqlModule } from './graphql.module';<br/>import { MongoModule } from './mongo.module';<br/>import { ConfigModule } from './config.module';<br/><br/>@Module({<br/>  imports: [ConfigModule, GraphqlModule, MongoModule],<br/>  exports: [ConfigModule, GraphqlModule, MongoModule],<br/>})<br/>export class CommonModule {}</span></pre><p id="4db0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，回到你的mongo.module.ts:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="d650" class="nm nn iq ni b gy no np l nq nr">import { Module } from '@nestjs/common';<br/>import { ConfigService } from '@nestjs/config';<br/>import { MongooseModule } from '@nestjs/mongoose';<br/><br/>@Module({<br/>  imports: [<br/>    MongooseModule.<em class="ng">forRootAsync</em>({<br/>      useFactory: async (configService: ConfigService) =&gt; ({<br/>        uri: configService.get&lt;string&gt;('MONGODB_URL'),<br/>      }),<br/>      inject: [ConfigService],<br/>    }),<br/>  ],<br/>})<br/>export class MongoModule {}</span></pre><p id="4877" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="726c" class="nm nn iq ni b gy no np l nq nr">yarn start</span></pre><p id="5f6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出如下:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="1eb8" class="nm nn iq ni b gy no np l nq nr">$ nest start<br/>[Nest] 51083  - 02/02/2022, 10:19:03 PM     LOG [NestFactory] Starting Nest application...<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] CommonModule dependencies initialized +53ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] ConfigModule dependencies initialized +0ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] GraphqlModule dependencies initialized +1ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] MongoModule dependencies initialized +0ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] MongooseModule dependencies initialized +1ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] ConfigHostModule dependencies initialized +0ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] UsersModule dependencies initialized +0ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] AppModule dependencies initialized +1ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] ConfigModule dependencies initialized +0ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] GraphQLSchemaBuilderModule dependencies initialized +15ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] GraphQLModule dependencies initialized +1ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [InstanceLoader] MongooseCoreModule dependencies initialized +19ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [RoutesResolver] AppController {/}: +4ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [RouterExplorer] Mapped {/, GET} route +3ms<br/>[Nest] 51083  - 02/02/2022, 10:19:04 PM     LOG [NestApplication] Nest application successfully started +108ms</span></pre><p id="b9d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，我们可以从我们的。env文件，我们的NestJS连接到MongoDB。</p><p id="e868" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在mongoose的帮助下创建我们的用户CRUD！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="9286" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我之前的<a class="ae lr" href="https://makinhs.medium.com/graphql-nodejs-postgres-made-easy-with-nestjs-and-typeorm-4daff3c516d" rel="noopener"> Postgres + NestJS + GraphQL文章</a>中，我们使用了一个用户实体，我们将在本文中重用它，但是目标是Mongoose模型，它基本上有名字、姓氏、电子邮件和角色。</p><p id="41e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更新我们的user.entity.ts，我们需要意识到我们想要绑定GraphQL类型和mongoose类型，这将使用NestJS装饰器，并且结尾将类似如下:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="08d0" class="nm nn iq ni b gy no np l nq nr">import { ObjectType, Field } from '@nestjs/graphql';<br/>import { Schema as MongooseSchema } from 'mongoose';<br/>import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';<br/>@Schema()<br/>@ObjectType()<br/>export class User {<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>)<br/>  _id: MongooseSchema.Types.ObjectId;<br/>  @Prop()<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>, { description: 'User firstName ' })<br/>  firstName: string;<br/>  @Prop()<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>, { description: 'User lastName ' })<br/>  lastName: string;<br/>  @Prop()<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>, { description: 'User email ' })<br/>  email: string;<br/>  @Prop()<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>, { description: 'User role' })<br/>  role: string;<br/>}<br/><br/>export const <strong class="ni ir"><em class="ng">UserSchema </em></strong>= SchemaFactory.<em class="ng">createForClass</em>(User);</span></pre><p id="a19d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了公开mongoose实体，我们需要用以下内容更新我们的users.module.ts:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="6d81" class="nm nn iq ni b gy no np l nq nr">import { Module } from '@nestjs/common';<br/>import { UsersService } from './users.service';<br/>import { UsersResolver } from './users.resolver';<br/>import { MongooseModule } from '@nestjs/mongoose';<br/>import { User, <strong class="ni ir"><em class="ng">UserSchema </em></strong>} from './entities/user.entity';<br/><br/>@Module({<br/>  imports: [<br/>    MongooseModule.<em class="ng">forFeature</em>([<br/>      {<br/>        name: User.name,<br/>        schema: <strong class="ni ir"><em class="ng">UserSchema</em></strong>,<br/>      },<br/>    ]),<br/>  ],<br/>  providers: [UsersResolver, UsersService],<br/>})<br/>export class UsersModule {<br/>}</span></pre><p id="5c97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为生活并不容易…如果你运行<code class="fe ns nt nu ni b">yarn start</code>，项目仍然会失败…这将会发生，因为我们使用Typescript，我们的解析器、服务和dto期望用户实体有不同的类型。我们现在需要更新它们…适当地。</p><h2 id="0111" class="nm nn iq bd nv nw nx dn ny nz oa dp ob ko oc od oe ks of og oh kw oi oj ok ol bi translated">重构我们的dto</h2><p id="d75d" class="pw-post-body-paragraph kf kg iq kh b ki om jr kk kl on ju kn ko oo kq kr ks op ku kv kw oq ky kz la ij bi translated">DTO是数据传输对象的快捷方式，它非常常用于将来自请求的输入翻译到我们的应用程序中。在NestJS中，这允许我们定义我们想要接受的输入，并且能够用decorators以一种简单的方式在GraphQL上定义输入类型，以及添加一些本文没有涉及的<a class="ae lr" href="https://docs.nestjs.com/techniques/validation#validation" rel="noopener ugc nofollow" target="_blank">验证</a>。</p><p id="4b86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先重构我们的dto将有助于支持稍后对解析器和服务的更改。我们开始吧</p><p id="a05b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在create-user.input.ts上，我们将添加新的用户字段:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="09d3" class="nm nn iq ni b gy no np l nq nr">import { InputType, Field } from '@nestjs/graphql';<br/><br/>@InputType()<br/>export class CreateUserInput {<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>, { description: 'first name of the user' })<br/>  firstName: string;<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>, { description: 'last name of the user' })<br/>  lastName: string;<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>, { description: 'email of the user' })<br/>  email: string;<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>, { description: 'role of the user' })<br/>  role: string;<br/>}</span></pre><p id="72cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在update-user.input.ts中，我们只需要用NestJS提供的PartialType扩展CreateUserInput，并添加user _id，其值为:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="1638" class="nm nn iq ni b gy no np l nq nr">import { CreateUserInput } from './create-user.input';<br/>import { InputType, Field, PartialType } from '@nestjs/graphql';<br/><br/>@InputType()<br/>export class UpdateUserInput extends PartialType(CreateUserInput) {<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">String</em></strong>)<br/>  _id: string;<br/>}</span></pre><p id="2a32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们现在改变我们的服务:</p><h2 id="831d" class="nm nn iq bd nv nw nx dn ny nz oa dp ob ko oc od oe ks of og oh kw oi oj ok ol bi translated">重构用户服务</h2><p id="a83d" class="pw-post-body-paragraph kf kg iq kh b ki om jr kk kl on ju kn ko oo kq kr ks op ku kv kw oq ky kz la ij bi translated">NestJS CLI创建了一个最小的CRUD框架，对于我们的例子，我们现在需要编辑两个主要内容:输入和添加逻辑。</p><p id="9cda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，您应该已经在users.module.ts中设置了Mongoose模型。</p><p id="91ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，您需要注意的是，您需要能够使用Mongoose中已经设置好但没有注入到您的users.service.ts中的用户模型，然后我们需要添加所有需要的逻辑，以使整个CRUD能够工作。最终结果将如下所示:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="a616" class="nm nn iq ni b gy no np l nq nr">import { Injectable, NotFoundException } from '@nestjs/common';<br/>import { CreateUserInput } from './dto/create-user.input';<br/>import { UpdateUserInput } from './dto/update-user.input';<br/>import { User } from './entities/user.entity';<br/>import { <strong class="ni ir"><em class="ng">InjectModel </em></strong>} from '@nestjs/mongoose';<br/>import { <strong class="ni ir"><em class="ng">Model </em></strong>} from 'mongoose';<br/><br/>@Injectable()<br/>export class UsersService {<br/>  constructor(<br/>    @InjectModel(User.name)<br/>    private readonly userModel: <strong class="ni ir"><em class="ng">Model</em></strong>&lt;User&gt;,<br/>  ) {}<br/><br/>  create(createUserInput: CreateUserInput) {<br/>    const user = new this.userModel(createUserInput);<br/>    return user.save();<br/>  }<br/><br/>  findAll() {<br/>    return this.userModel.find().exec();<br/>  }<br/><br/>  async findOne(id: string) {<br/>    const user = await this.userModel.findOne({ _id: id }).exec();<br/>    if (!user) {<br/>      throw new NotFoundException(`User ${id} not found`);<br/>    }<br/>    return user;<br/>  }<br/><br/>  async update(id: string, updateUserInput: UpdateUserInput) {<br/>    const existingUser = await this.userModel<br/>      .findOneAndUpdate({ _id: id }, { $set: updateUserInput }, { new: true })<br/>      .exec();<br/><br/>    if (!existingUser) {<br/>      throw new NotFoundException(`User ${id} not found`);<br/>    }<br/>    return existingUser;<br/>  }<br/><br/>  async remove(id: string) {<br/>    const user = await this.findOne(id);<br/>    return user.remove();<br/>  }<br/>}</span></pre><p id="4542" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以更新解析器了</p><h2 id="c745" class="nm nn iq bd nv nw nx dn ny nz oa dp ob ko oc od oe ks of og oh kw oi oj ok ol bi translated">重构user . resolver . ts</h2><p id="4a6a" class="pw-post-body-paragraph kf kg iq kh b ki om jr kk kl on ju kn ko oo kq kr ks op ku kv kw oq ky kz la ij bi translated">这里我们只需要修改输入，主要是当来自数字的id现在是字符串时:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="4575" class="nm nn iq ni b gy no np l nq nr">import { Resolver, Query, Mutation, Args } from '@nestjs/graphql';<br/>import { UsersService } from './users.service';<br/>import { User } from './entities/user.entity';<br/>import { CreateUserInput } from './dto/create-user.input';<br/>import { UpdateUserInput } from './dto/update-user.input';<br/><br/>@Resolver(() =&gt; User)<br/>export class UsersResolver {<br/>  constructor(private readonly usersService: UsersService) {}<br/><br/>  @Mutation(() =&gt; User)<br/>  createUser(@Args('createUserInput') createUserInput: CreateUserInput) {<br/>    return this.usersService.create(createUserInput);<br/>  }<br/><br/>  @Query(() =&gt; [User], { name: 'users' })<br/>  findAll() {<br/>    return this.usersService.findAll();<br/>  }<br/><br/>  @Query(() =&gt; User, { name: 'user' })<br/>  findOne(@Args('_id', { type: () =&gt; <strong class="ni ir"><em class="ng">String </em></strong>}) id: string) {<br/>    return this.usersService.findOne(id);<br/>  }<br/><br/>  @Mutation(() =&gt; User)<br/>  updateUser(@Args('updateUserInput') updateUserInput: UpdateUserInput) {<br/>    return this.usersService.update(updateUserInput._id, updateUserInput);<br/>  }<br/><br/>  @Mutation(() =&gt; User)<br/>  removeUser(@Args('_id', { type: () =&gt; <strong class="ni ir"><em class="ng">String </em></strong>}) id: string) {<br/>    return this.usersService.remove(id);<br/>  }<br/>}</span></pre><p id="b524" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些改变，我们终于可以运行<code class="fe ns nt nu ni b">yarn start</code></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="dcbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们测试一些代码。为此，在浏览器中打开localhost:3000/graphql，并使用GraphQL Playground:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi or"><img src="../Images/c1e71d0dc36df29129aa2bd5bed439f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Za1z18bc72UpYJln6UUZLw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Creating an user</figcaption></figure><p id="0010" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有动态变量的简单变化如下:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="c830" class="nm nn iq ni b gy no np l nq nr">mutation{<br/>  createUser(createUserInput:{<br/>    firstName:"Marcos",<br/>    lastName:"Silva",<br/>    email:"<a class="ae lr" href="mailto:my_email@gmail.com" rel="noopener ugc nofollow" target="_blank">my_email@gmail.com</a>",<br/>    role:"User"<br/>  }){<br/>    _id<br/>    firstName<br/>    lastName<br/>    email<br/>    role<br/>  }<br/>}</span></pre><p id="75d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按id获取用户:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi os"><img src="../Images/d0ac2573b0133fc586277c1e06633b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3y_ry0gBYxoABd3OimJdA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">getting the user by id</figcaption></figure><p id="b8de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加另一个用户，然后查询用户:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ot"><img src="../Images/00d211cdaed46d7592df43fb8cceef85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9_iq6QMVrE7B-lQkgRKRQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Listing users</figcaption></figure><p id="65e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于用户自己的id更新其中一个用户:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ou"><img src="../Images/809a8d1eb27da7ec3615ffba251dad2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxS7uIvYjB5-VCN-jOF4Ow.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Updating the user by _id</figcaption></figure><p id="7d8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让用户验证信息是否已更新:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ov"><img src="../Images/788b8727306df9738ad44e69333a9fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcKUCJJHx07wHyDbfODixA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">getting updated user</figcaption></figure><p id="8b72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在尝试删除用户:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ow"><img src="../Images/b87d42d3f1f0e8e422019dcd4494a450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Pug01y2ih1j6ZkyBYLK6g.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">deleting the user</figcaption></figure><p id="7fd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，获取所有用户并验证John Doe不再存在:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ox"><img src="../Images/4620f23b7737816393f03c9654fac57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UyJpnE5Q5Ae7NX1GiS0iWA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">list users without the removed user</figcaption></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="a389" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！现在我们有了一个包含GraphQL和MongoDB的基本CRUD集。在结束这篇文章之前，让我来指导你在你的个人项目中应该考虑做的一些快速的额外设置。</p><h2 id="88e2" class="nm nn iq bd nv nw nx dn ny nz oa dp ob ko oc od oe ks of og oh kw oi oj ok ol bi translated">偏移分页</h2><p id="b83b" class="pw-post-body-paragraph kf kg iq kh b ki om jr kk kl on ju kn ko oo kq kr ks op ku kv kw oq ky kz la ij bi translated">如果您最近开始使用GraphQL进行项目，您可能会考虑在传统的限制/偏移中添加分页。为此，只需添加一个引用您可能需要的限制/偏移的d to，并将您的列表用户查询升级为如下所示:</p><p id="6827" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于列表用户，输入DTO:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="de54" class="nm nn iq ni b gy no np l nq nr">import { Field, InputType } from '@nestjs/graphql';<br/><br/>@InputType()<br/>export class ListUsersInput {<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">Number</em></strong>, { description: 'classical limit' })<br/>  limit: number;<br/>  @Field(() =&gt; <strong class="ni ir"><em class="ng">Number</em></strong>, { description: 'classical offset' })<br/>  offset: number;<br/>}</span></pre><p id="9388" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于findAll函数:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="85cf" class="nm nn iq ni b gy no np l nq nr">findAll(paginationQuery: ListUsersInput) {<br/>  const { limit, offset } = paginationQuery;<br/>  return this.userModel.find().skip(offset).limit(limit).exec();<br/>}</span></pre><p id="c676" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重构解析器来接收这些输入:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="d12f" class="nm nn iq ni b gy no np l nq nr">@Query(() =&gt; [User], { name: 'users' })<br/>findAll(@Args('listUsersInput') listUsersInput: ListUsersInput) {<br/>  return this.usersService.findAll(listUsersInput);<br/>}</span></pre><p id="bb72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于简单的场景来说，这样做应该是可行的，但是由于我们使用的是GraphQL，我相信我应该展示如何实现光标分页方法，这也是Apollo官方文档推荐的用于编号页面的方法。</p><p id="102a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“我们建议对带编号的页面使用<strong class="kh ir">基于光标的分页</strong>，因为它消除了跳过一个项目或多次显示同一项目的可能性。在基于光标的分页中，常量指针(或光标)用于在获取下一组结果时跟踪数据集中的起始位置”(Apollo Documentation，<a class="ae lr" href="https://www.apollographql.com/docs/tutorial/resolvers/#paginated-queries" rel="noopener ugc nofollow" target="_blank"> link </a></p><p id="5add" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们直接从基于光标的分页开始吧！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h2 id="9e00" class="nm nn iq bd nv nw nx dn ny nz oa dp ob ko oc od oe ks of og oh kw oi oj ok ol bi translated">实现基于光标的分页</h2><p id="8f75" class="pw-post-body-paragraph kf kg iq kh b ki om jr kk kl on ju kn ko oo kq kr ks op ku kv kw oq ky kz la ij bi translated">在开始之前，这一部分是从弹弓实验室的一篇文章<a class="ae lr" href="https://slingshotlabs.io/blog/cursor-pagination-graphql-mongodb/" rel="noopener ugc nofollow" target="_blank">中得到的<em class="ng">大量</em> <em class="ng">灵感</em>。如果这部分对你来说是一个很好的阅读，请不要忘记阅读他们的文章，并通过喜欢或评论他们的帖子来支持他们。</a></p><p id="8883" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要将graphql-relay库添加进来:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="0a72" class="nm nn iq ni b gy no np l nq nr">yarn add graphql-relay<br/>yarn add -D @types/graphql-relay</span></pre><p id="f193" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">什么是接力赛？检查<a class="ae lr" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="22f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从添加一个通用的DTO开始，我们可以用它来处理页面，在common/dto/page-data.dto.ts中我们称之为page-data.dto.ts</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="01f1" class="nm nn iq ni b gy no np l nq nr">import { Field, ObjectType } from '@nestjs/graphql';<br/><br/>@ObjectType()<br/>export class PageDataDto {<br/>  @Field()<br/>  public count: number;<br/><br/>  @Field()<br/>  public limit: number;<br/><br/>  @Field()<br/>  public offset: number;<br/>}</span></pre><p id="6db8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将为中继创建一些类型。同样在通用文件夹中，我们创建一个名为relay with relay.types.ts的文件夹:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="6379" class="nm nn iq ni b gy no np l nq nr">import * as Relay from 'graphql-relay';<br/>import { ObjectType, Field } from '@nestjs/graphql';<br/>import { PageDataDto as PageData } from '../dto/page-data.dto';<br/>import { Type } from '@nestjs/common';<br/><br/>const typeMap = {};<br/>export function RelayTypes&lt;T&gt;(type: Type&lt;T&gt;): any {<br/>  const { name } = type;<br/>  if (typeMap[`${name}`]) return typeMap[`${name}`];<br/><br/>  @ObjectType(`${name}Edge`, { isAbstract: true })<br/>  class Edge implements Relay.Edge&lt;T&gt; {<br/>    public name = `${name}Edge`;<br/><br/>    @Field({ nullable: true })<br/>    public cursor!: Relay.ConnectionCursor;<br/><br/>    @Field(() =&gt; type, { nullable: true })<br/>    public node!: T;<br/>  }<br/><br/>  @ObjectType(`${name}PageInfo`, { isAbstract: true })<br/>  class PageInfo implements Relay.PageInfo {<br/>    @Field({ nullable: true })<br/>    public startCursor!: Relay.ConnectionCursor;<br/><br/>    @Field({ nullable: true })<br/>    public endCursor!: Relay.ConnectionCursor;<br/><br/>    @Field(() =&gt; <strong class="ni ir"><em class="ng">Boolean</em></strong>)<br/>    public hasPreviousPage!: boolean;<br/><br/>    @Field(() =&gt; <strong class="ni ir"><em class="ng">Boolean</em></strong>)<br/>    public hasNextPage!: boolean;<br/>  }<br/><br/>  @ObjectType(`${name}Connection`, { isAbstract: true })<br/>  class Connection implements Relay.Connection&lt;T&gt; {<br/>    public name = `${name}Connection`;<br/><br/>    @Field(() =&gt; [Edge], { nullable: true })<br/>    public edges!: Relay.Edge&lt;T&gt;[];<br/><br/>    @Field(() =&gt; PageInfo, { nullable: true })<br/>    public pageInfo!: Relay.PageInfo;<br/>  }<br/><br/>  @ObjectType(`${name}Page`, { isAbstract: true })<br/>  abstract class Page {<br/>    public name = `${name}Page`;<br/><br/>    @Field(() =&gt; Connection)<br/>    public page!: Connection;<br/><br/>    @Field(() =&gt; PageData, { nullable: true })<br/>    public pageData!: PageData;<br/>  }<br/><br/>  typeMap[`${name}`] = Page;<br/>  return typeMap[`${name}`];<br/>}</span></pre><p id="dea4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后但同样重要的是，在同一个中继文件夹中，我们将添加一个connection.args.ts，其中包含:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="71c0" class="nm nn iq ni b gy no np l nq nr">import { ConnectionArguments, ConnectionCursor, fromGlobalId } from 'graphql-relay';<br/>import { Field, InputType } from '@nestjs/graphql';<br/><br/>type PagingMeta =<br/>  | { pagingType: 'forward'; after?: string; first: number }<br/>  | { pagingType: 'backward'; before?: string; last: number }<br/>  | { pagingType: 'none' };<br/><br/>function checkPagingSanity(args: ConnectionArgs): PagingMeta {<br/>  const { first = 0, last = 0, after, before } = args;<br/><br/>  const isForwardPaging = !!first || !!after;<br/>  const isBackwardPaging = !!last || !!before;<br/>  if (isForwardPaging &amp;&amp; isBackwardPaging) {<br/>    throw new <strong class="ni ir"><em class="ng">Error</em></strong>('Relay pagination cannot be forwards AND backwards!');<br/>  }<br/>  if ((isForwardPaging &amp;&amp; before) || (isBackwardPaging &amp;&amp; after)) {<br/>    throw new <strong class="ni ir"><em class="ng">Error</em></strong>('Paging must use either first/after or last/before!');<br/>  }<br/>  if ((isForwardPaging &amp;&amp; first &lt; 0) || (isBackwardPaging &amp;&amp; last &lt; 0)) {<br/>    throw new <strong class="ni ir"><em class="ng">Error</em></strong>('Paging limit must be positive!');<br/>  }<br/>  if (last &amp;&amp; !before) {<br/>    throw new <strong class="ni ir"><em class="ng">Error</em></strong>('When paging backwards, a \'before\' argument is required!');<br/>  }<br/><br/>  // eslint-disable-next-line no-nested-ternary<br/>  return isForwardPaging<br/>    ? { pagingType: 'forward', after, first }<br/>    : isBackwardPaging<br/>      ? { pagingType: 'backward', before, last }<br/>      : { pagingType: 'none' };<br/>}<br/><br/>const getId = (cursor: ConnectionCursor) =&gt;<br/>  parseInt(fromGlobalId(cursor).id, 10);<br/>const nextId = (cursor: ConnectionCursor) =&gt; getId(cursor) + 1;<br/><br/>export function getPagingParameters(args: ConnectionArgs) {<br/>  const meta = checkPagingSanity(args);<br/><br/>  switch (meta.pagingType) {<br/>    case 'forward': {<br/>      return {<br/>        limit: meta.first,<br/>        offset: meta.after ? nextId(meta.after) : 0,<br/>      };<br/>    }<br/>    case 'backward': {<br/>      const { last, before } = meta;<br/>      let limit = last;<br/>      let offset = getId(before!) - last;<br/><br/>      if (offset &lt; 0) {<br/>        limit = <strong class="ni ir"><em class="ng">Math</em></strong>.max(last + offset, 0);<br/>        offset = 0;<br/>      }<br/><br/>      return { offset, limit };<br/>    }<br/>    default:<br/>      return {};<br/>  }<br/>}<br/><br/>@InputType()<br/>export default class ConnectionArgs implements ConnectionArguments {<br/>  @Field({ nullable: true, description: 'Paginate before opaque cursor' })<br/>  public before?: ConnectionCursor;<br/><br/>  @Field({ nullable: true, description: 'Paginate after opaque cursor' })<br/>  public after?: ConnectionCursor;<br/><br/>  @Field({ nullable: true, description: 'Paginate first' })<br/>  public first?: number;<br/><br/>  @Field({ nullable: true, description: 'Paginate last' })<br/>  public last?: number;<br/>}</span></pre><p id="f78d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上是您只需做一次的最低配置，并且可以在您想要对中继使用光标分页的任何时候在您的代码中重用。我们现在需要做的是创建GraphQL可以理解的响应对象，以及调整我们的解析器和服务来支持它。</p><p id="2a45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在我们的users/dto文件夹中创建响应对象，我们将使用以下内容创建list-users.response.ts:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="e385" class="nm nn iq ni b gy no np l nq nr">import { User } from '../entities/user.entity';<br/>import { ObjectType } from '@nestjs/graphql';<br/>import { RelayTypes } from '../../common/relay/relay.types';<br/><br/>@ObjectType()<br/>export class ListUsersResponse extends RelayTypes&lt;User&gt;(User) {}</span></pre><p id="7e77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们回到users.service.ts并创建以下内容:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="8706" class="nm nn iq ni b gy no np l nq nr">async getUsers(paginationQuery: ListUsersInput) {<br/>  const count = await this.userModel.count();<br/>  const users = await this.findAll(paginationQuery);<br/>  return { users, count };<br/>}</span></pre><p id="0d10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后创建一个新的查询来处理光标分页:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="fb94" class="nm nn iq ni b gy no np l nq nr">@Query(() =&gt; ListUsersResponse, { name: 'listUsersWithCursor' })<br/>async findAllWithCursor(@Args('args') args: ConnectionArgs): Promise&lt;ListUsersResponse&gt; {<br/>  const { limit, offset } = getPagingParameters(args);<br/>  const { users, count } = await this.usersService.getUsers({<br/>    limit,<br/>    offset,<br/>  });<br/>  const page = connectionFromArraySlice(users, args, {<br/>    arrayLength: count,<br/>    sliceStart: offset || 0,<br/>  });<br/><br/>  return { page, pageData: { count, limit, offset } };<br/>}</span></pre><p id="f801" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们准备测试:</p><p id="4678" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用创建用户变异添加了一些用户，从那里我们可以开始玩:</p><p id="4917" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取前两个用户:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="5ca4" class="nm nn iq ni b gy no np l nq nr">query {<br/>  listUsersWithCursor(args: { first: 2 }) {<br/>    page {<br/>      edges {<br/>        node {<br/>          _id<br/>          firstName<br/>          lastName<br/>          email<br/>          role<br/>        }<br/>      }<br/>      pageInfo {<br/>        startCursor<br/>        endCursor<br/>        hasPreviousPage<br/>        hasNextPage<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="951c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回应是:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oy"><img src="../Images/ff2061ab54b9d88e4fd222286864f2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEiznzQuovBV45ixkXt-Ag.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">first 2 users</figcaption></figure><p id="c5e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获得“endCursor”将允许我们转移到下两个用户:</p><pre class="lc ld le lf gt nh ni nj nk aw nl bi"><span id="1847" class="nm nn iq ni b gy no np l nq nr">query {<br/>  listUsersWithCursor(args: { first: 2, after: "YXJyYXljb25uZWN0aW9uOjE=" }) {<br/>    page {<br/>      edges {<br/>        node {<br/>          _id<br/>          firstName<br/>          lastName<br/>          email<br/>          role<br/>        }<br/>      }<br/>      pageInfo {<br/>        startCursor<br/>        endCursor<br/>        hasPreviousPage<br/>        hasNextPage<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="a186" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了想要的输出:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oz"><img src="../Images/1504fc016e8121f72aaf1f049e51e295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBXg2lQytYXWV3vWcQIg3g.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Getting 2 more users after the first 2 ones</figcaption></figure><p id="1198" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上就是这样。一个具有NestJS、GraphQL、Mongoose和游标分页的全功能CRUD！如果您需要关于光标分页实现的更详细的解释，请阅读这篇<a class="ae lr" href="https://slingshotlabs.io/blog/cursor-pagination-graphql-mongodb/" rel="noopener ugc nofollow" target="_blank">友好的文章</a></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="57c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们改编了我以前的文章“GraphQL + NodeJS + Postgres —使用NestJS和TypeORM使之变得容易”“，改编为使用MongoDB和Mongoose，并且已经添加了光标分页作为额外的步骤。这篇文章看起来比我以前的文章要大得多，但是它提醒了我，大部分内容都是准备好复制和粘贴代码来帮助你做研究的。</p><p id="0d11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，要说“生产就绪”，您需要做几件事情，例如:</p><ul class=""><li id="6325" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated">将授权/许可添加到您的查询/变异中</li><li id="a47b" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">散列敏感数据，以防你胆敢在你的MongoDB中存储密码(我建议使用Auth0或任何其他自动为你做这件事的服务)</li><li id="559d" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">具有不同关系、索引和其他酷东西的更复杂的文档</li><li id="a61f" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">在搜索用户时添加一些过滤选项</li><li id="0cf2" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">使用验证管道</li><li id="3d61" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">还有很多其他的东西…</li></ul><p id="53b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">源代码可以在<a class="ae lr" href="https://github.com/makinhs/nestjs-with-graphql/tree/003-mongoose" rel="noopener ugc nofollow" target="_blank">这个链接</a>中找到，在我提交它的时候一切正常！</p><p id="e745" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的第二部分，目标单元测试，已经可以在这里找到<a class="ae lr" href="https://makinhs.medium.com/unit-testing-made-easy-with-nestjs-part-02-for-graphql-mongodb-backend-article-series-b37f147e2a9e" rel="noopener"/>:</p><div class="ls lt gp gr lu lv"><a href="https://makinhs.medium.com/unit-testing-made-easy-with-nestjs-part-02-for-graphql-mongodb-backend-article-series-b37f147e2a9e" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用NestJS简化单元测试——graph QL+MongoDB后端文章系列的第2部分！</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">使用NestJS、GraphQL和MongoDB简化单元测试。在这篇文章中，我们将深入单元测试！</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">makinhs.medium.com</p></div></div><div class="me l"><div class="pa l mg mh mi me mj ll lv"/></div></div></a></div><p id="d37d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢你到目前为止的阅读，如果这篇文章对你的学习有用，请给我一个赞/评论！下一集再见！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><div class="lc ld le lf gt lv"><a href="https://makinhs.medium.com/graphql-nodejs-postgres-made-easy-with-nestjs-and-typeorm-4daff3c516d" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">graph QL+NodeJS+Postgres——使用NestJS和TypeORM使之变得简单</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">使用TypeORM在NestJS GraphQL后端添加Postgres模块，并创建一个基本的CRUD</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">makinhs.medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ll lv"/></div></div></a></div><p id="274d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对固体还一无所知？查看我的SOLID教程中的TypeScript:</p><div class="ls lt gp gr lu lv"><a href="https://makinhs.medium.com/how-to-apply-solid-principles-with-typescript-in-an-easy-way-b91b53bc9853" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">如何以简单的方式应用Typescript的坚实原理</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在本文中，我们将讨论坚实的原则以及如何在您的Typescript项目中使用它！</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">makinhs.medium.com</p></div></div><div class="me l"><div class="pb l mg mh mi me mj ll lv"/></div></div></a></div><h2 id="c632" class="nm nn iq bd nv nw nx dn ny nz oa dp ob ko oc od oe ks of og oh kw oi oj ok ol bi translated">进一步阅读</h2><div class="ls lt gp gr lu lv"><a href="https://plainenglish.io/blog/how-to-build-a-graphql-ecommerce-app-from-scratch" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">如何从头开始构建一个GraphQL电子商务应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">这就是你要建造的东西！埃森哲的一项调查(19个国家的20，000多名消费者)发现，47%的人…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">简明英语. io</p></div></div><div class="me l"><div class="pc l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://plainenglish.io/blog/how-to-compose-and-integrate-apis-together-as-if-you-were-using-npm-for-apis" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">如何将API组合和集成在一起，就像您正在使用API的NPM一样</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">将两个API整合到一个应用程序中，该应用程序显示了历史上最大的音乐会，按国家首都排列。与……</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">简明英语. io</p></div></div><div class="me l"><div class="pd l mg mh mi me mj ll lv"/></div></div></a></div><p id="708b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ng">更多内容请看</em><a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ng">plain English . io</em></strong></a><em class="ng">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们关于</em><a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ng">Twitter</em></strong></a><a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ng">LinkedIn</em></strong></a><em class="ng"/><a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ng">YouTube</em></strong></a><em class="ng"/><a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ng">不和</em> </strong> </a> <em class="ng">。对增长黑客感兴趣？检查</em> <a class="ae lr" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ng">电路</em> </strong> </a> <em class="ng">。</em></p></div></div>    
</body>
</html>