<html>
<head>
<title>3 Ways to Improve TypeScript Type Safety</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高打字稿类型安全性的3种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/runtime-type-checking-in-typescript-c725d83e12c1?source=collection_archive---------5-----------------------#2022-09-09">https://javascript.plainenglish.io/runtime-type-checking-in-typescript-c725d83e12c1?source=collection_archive---------5-----------------------#2022-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0322" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">修正这个打字稿缺陷，有利弊</h2></div><p id="62db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript已经成为JavaScript的首选。它具有出色的IDE支持，简化了大型代码库的工作，改善了团队协作，并防止了错误。然而，与传统的类型语言相比，它也有明显的差距。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/fbef0b02ff664d75acee0ae926b25928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XzDIjxbET011RoSH"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@sushioutlaw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brian McGowan</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a0ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript不同于其他传统的类型化语言。在C#和Java中，类型是一等公民，这些语言内置了类型，而TypeScript是常规JavaScript之上的语法层。面向OOP开发人员的TypeScript页面是很好的读物；以下摘自<a class="ae lr" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html" rel="noopener ugc nofollow" target="_blank">那页</a>:</p><p id="964c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ls">在C#或Java中，任何给定的值或对象都有一个确切的类型——要么是</em> <code class="fe lt lu lv lw b"><em class="ls">null</em></code> <em class="ls">、原语，要么是已知的类类型。我们可以调用类似</em> <code class="fe lt lu lv lw b"><em class="ls">value.GetType()</em></code> <em class="ls">或</em> <code class="fe lt lu lv lw b"><em class="ls">value.getClass()</em></code> <em class="ls">的方法在运行时查询确切的类型。这种类型的定义将驻留在某个具有某个名称的类中，并且我们不能使用两个具有相似形状的类来代替彼此，除非有显式的继承关系或共同实现的接口。</em></p><p id="5476" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ls">这些方面描述了一个具体化的、名义上的类型系统。我们在代码中编写的类型在运行时存在，并且这些类型通过它们的声明而不是它们的结构相关联。</em></p><p id="538b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它继续以下内容:</p><p id="5115" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ls">在C#或Java中，认为运行时类型和它们的编译时声明</em>  <em class="ls">一一对应是很有意义的。</em></p><p id="9c47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，在TypeScript中，所有类型信息都会在运行时丢失。这种一对一的对应是不存在的。这意味着我们不能像在。例如NET core。更重要的是，<strong class="kh ir">typescript在运行时不提供任何类型安全。</strong></p><p id="409d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有运行时类型，应用程序就会暴露在一个最常见的错误中:I/O数据与预期的不同。无论是来自POST请求的用户数据、来自外部API的数据，还是来自数据库的数据，您的应用程序都可能以意想不到的方式崩溃，并且很难找到问题的根源。如何才能预防这些问题？以下是强化运行时类型脚本代码的三种方法。</p><h1 id="c022" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">类型验证库</h1><p id="8914" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">NPM上有几个库可以验证用户生成的数据。<a class="ae lr" href="https://joi.dev/" rel="noopener ugc nofollow" target="_blank"> JOI </a>是我过去用的最多的图书馆，但是<a class="ae lr" href="https://www.npmjs.com/search?q=keywords:validation" rel="noopener ugc nofollow" target="_blank">还有其他的</a>。</p><p id="8408" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像这样的库依赖于模式来验证数据，通常用于web服务器上的后期数据验证。模式可以非常精确，允许像电子邮件和UUID这样的事情，允许字符验证，并包括字段和复杂复合字段的可选、最小和最大长度。完美，以确保用户提供了一个有效的电子邮件地址，而不是试图做任何SQL注入。</p><p id="b9f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">精确的模式意味着错误也可以是描述性的，因此我们可以向服务的用户提供有价值的反馈。</p><p id="ecf0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些库的缺点是在我们的类型之上需要一个单独的模式。这意味着您必须在两个地方维护类型。</p><p id="ba96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文档中的<a class="ae lr" href="https://joi.dev/api/?v=17.6.0" rel="noopener ugc nofollow" target="_blank">示例很好地展示了不同的特性。最小和最大长度、模式、整数等。</a></p><pre class="lc ld le lf gt mu lw mv mw aw mx bi"><span id="a591" class="my ly iq lw b gy mz na l nb nc">const Joi = require('joi');<br/><br/>const schema = Joi.object({<br/>    username: Joi.string()<br/>        .alphanum()<br/>        .min(3)<br/>        .max(30)<br/>        .required(),<br/><br/>    password: Joi.string()<br/>        .pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')),<br/><br/>    repeat_password: Joi.ref('password'),<br/><br/>    access_token: [<br/>        Joi.string(),<br/>        Joi.number()<br/>    ],<br/><br/>    birth_year: Joi.number()<br/>        .integer()<br/>        .min(1900)<br/>        .max(2013),<br/><br/>    email: Joi.string()<br/>        .email({ minDomainSegments: 2, tlds: { allow: ['com', 'net'] } })<br/>})<br/>    .with('username', 'birth_year')<br/>    .xor('password', 'access_token')<br/>    .with('password', 'repeat_password');<br/><br/><br/>schema.validate({ username: 'abc', birth_year: 1994 });<br/>// -&gt; { value: { username: 'abc', birth_year: 1994 } }</span></pre><h2 id="e0b1" class="my ly iq bd lz nd ne dn md nf ng dp mh ko nh ni mj ks nj nk ml kw nl nm mn nn bi translated">优点:</h2><ul class=""><li id="405c" class="no np iq kh b ki mp kl mq ko nq ks nr kw ns la nt nu nv nw bi translated">非常详细的输入数据检查包括电子邮件地址的验证</li><li id="744d" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">非常适合用户生成的表单数据</li><li id="1b20" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">良好的错误处理/报告</li></ul><h2 id="dfad" class="my ly iq bd lz nd ne dn md nf ng dp mh ko nh ni mj ks nj nk ml kw nl nm mn nn bi translated">缺点:</h2><ul class=""><li id="7278" class="no np iq kh b ki mp kl mq ko nq ks nr kw ns la nt nu nv nw bi translated">类型的重复，因为我们已经在typescript中定义了类型</li></ul><h1 id="e946" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">使用编译器插件进行运行时类型检查</h1><p id="f930" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated"><a class="ae lr" href="https://github.com/cevek/ttypescript" rel="noopener ugc nofollow" target="_blank">TTypescript</a>(Transformer Typescript)是一个替代的TypeScript编译器，允许在编译TypeScript代码的同时执行插件。插件可以处理应用程序中的类型，并将它们编译成具体的运行时代码。我们需要做的就是更新编译器并安装一个NPM包来进行类型检查。</p><p id="356a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TTypeScript要求我们将编译器从<em class="ls"> tsc </em>更新为<em class="ls"> ttsc </em>或者添加一个类似<code class="fe lt lu lv lw b">ts-node --compiler ttypescript</code>的编译器标志。</p><p id="d95d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NPM包<a class="ae lr" href="https://github.com/woutervh-/typescript-is" rel="noopener ugc nofollow" target="_blank"><em class="ls">TypeScript-is</em></a><em class="ls"/>提供基于您现有的类型脚本类型的类型检查，并提供描述性错误。我发现对express服务器的所有输出使用typescript-is很有帮助。它在单元和集成测试之上提供了额外的信心层。下面是一个直接来自文档的示例:</p><pre class="lc ld le lf gt mu lw mv mw aw mx bi"><span id="4dcc" class="my ly iq lw b gy mz na l nb nc">import { assertType } from 'typescript-is';<br/><br/>const object: any = 42;<br/>assertType&lt;number&gt;(object).toFixed(2); // "42.00"<br/><br/>try {<br/>    const asString = assertType&lt;string&gt;(object); // throws error: object is not a string<br/>    asString.toUpperCasse(); // never gets here<br/>} catch (error) {<br/>    // ...<br/>}</span></pre><p id="a7a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，当我们传入的对象不是正确的类型时，函数assertType抛出一个错误。这个库的用途不仅限于此，它还可以在if语句中用作简单的类型保护。</p><p id="2e8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个库的缺点是我们只能通过简单的类型进行测试，我们不能通过字符串长度、最大数量或验证电子邮件地址或电话号码来测试任何东西。</p><h2 id="45a6" class="my ly iq bd lz nd ne dn md nf ng dp mh ko nh ni mj ks nj nk ml kw nl nm mn nn bi translated">赞成的意见</h2><ul class=""><li id="90c3" class="no np iq kh b ki mp kl mq ko nq ks nr kw ns la nt nu nv nw bi translated">使用现有的TypeScript类型</li><li id="2cb8" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">没有额外的编译步骤</li><li id="61a3" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">支持类型保护和类型验证</li></ul><h2 id="dc22" class="my ly iq bd lz nd ne dn md nf ng dp mh ko nh ni mj ks nj nk ml kw nl nm mn nn bi translated">骗局</h2><ul class=""><li id="d0ca" class="no np iq kh b ki mp kl mq ko nq ks nr kw ns la nt nu nv nw bi translated">例如，与JOI相比，基于原语的类型检查具有有限的特异性。</li><li id="962e" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">需要更新的TypeScript编译器</li></ul><p id="25d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想更深入地了解TypeScript编译器插件，<a class="ae lr" href="https://github.com/madou/typescript-transformer-handbook" rel="noopener ugc nofollow" target="_blank">这本手册</a>是一个极好的开始。</p><h1 id="1efe" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">打字稿自动防护</h1><div class="oc od gp gr oe of"><a href="https://github.com/rhys-vdw/ts-auto-guard" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">从TypeScript接口生成类型保护函数</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">从TypeScript接口生成类型保护函数一个为…自动生成类型保护的工具</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ll of"/></div></div></a></div><p id="7890" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个包与TypeScript-is相当，它生成运行时代码来根据TypeScript接口定义验证变量。不同之处在于，自动防护使用单独的编译步骤来生成包含类型检查代码的*.guard.ts文件。</p><h2 id="868a" class="my ly iq bd lz nd ne dn md nf ng dp mh ko nh ni mj ks nj nk ml kw nl nm mn nn bi translated">赞成的意见</h2><ul class=""><li id="05f3" class="no np iq kh b ki mp kl mq ko nq ks nr kw ns la nt nu nv nw bi translated">使用现有的TypeScript类型</li><li id="ff31" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">生成的类型保护被生成并包含在源代码中</li><li id="2665" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">修改类型保护的可能性</li></ul><h2 id="2407" class="my ly iq bd lz nd ne dn md nf ng dp mh ko nh ni mj ks nj nk ml kw nl nm mn nn bi translated">骗局</h2><ul class=""><li id="3b5b" class="no np iq kh b ki mp kl mq ko nq ks nr kw ns la nt nu nv nw bi translated">例如，与JOI相比，类型检查的定义是有限的。</li><li id="19c9" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">需要额外的编译步骤</li><li id="d84b" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">类型定义和保护可能会不同步</li></ul><p id="31e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读，希望您对这篇文章感兴趣。请支持我，在媒体上关注我，在<a class="ae lr" href="https://twitter.com/laurent_zw" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，或者在<a class="ae lr" href="https://www.linkedin.com/in/laurentzuijdwijk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。</p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><h2 id="fe52" class="my ly iq bd lz nd ne dn md nf ng dp mh ko nh ni mj ks nj nk ml kw nl nm mn nn bi translated">资源</h2><p id="cbe4" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">[1]打字稿手册<a class="ae lr" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/TypeScript-in-5-minutes-OOP . html</a></p><p id="beb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]https://www.npmjs.com/search?q=keywords:validation NPM验证库<a class="ae lr" href="https://www.npmjs.com/search?q=keywords:validation" rel="noopener ugc nofollow" target="_blank"/></p><p id="45d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3]乔伊<a class="ae lr" href="https://joi.dev/" rel="noopener ugc nofollow" target="_blank">https://joi.dev/</a></p><p id="0d03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[4]t打字稿<a class="ae lr" href="https://github.com/cevek/ttypescript" rel="noopener ugc nofollow" target="_blank">https://github.com/cevek/ttypescript</a></p><p id="9b76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://github.com/madou/typescript-transformer-handbook" rel="noopener ugc nofollow" target="_blank">https://github.com/madou/typescript-transformer-handbook</a></p><p id="caba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[6]TypeScript decorators<a class="ae lr" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/decorators . html</a></p><p id="e983" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[7]<a class="ae lr" href="https://github.com/woutervh-/typescript-is" rel="noopener ugc nofollow" target="_blank">https://github.com/woutervh-/typescript-is</a></p><p id="a272" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[8]https://github.com/madou/typescript-transformer-handbook<a class="ae lr" href="https://github.com/madou/typescript-transformer-handbook" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><p id="783d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ls">更多内容看</em> <a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ls">说白了就是</em> </strong> </a> <em class="ls">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。关注我们关于</em> <a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ls">推特</em> </strong> </a>，<a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ls">领英</em> </strong> </a> <em class="ls">，</em><a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ls">YouTube</em></strong></a><em class="ls">，以及</em> <a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ls">不和</em> </strong> </a> <em class="ls">。</em></p></div></div>    
</body>
</html>