<html>
<head>
<title>Composition: The Right Tool for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合成:React的正确工具</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/composition-the-right-tool-for-react-57f6ca9ed32?source=collection_archive---------13-----------------------#2022-03-15">https://javascript.plainenglish.io/composition-the-right-tool-for-react-57f6ca9ed32?source=collection_archive---------13-----------------------#2022-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8aa7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解什么是构图以及何时使用构图——用例子解释。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3168db315961b71983d2a6a44d3ddc47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7aYATwuXO0U4AryL"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@juliakadel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Julia Kadel</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="67ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我第一次开始学习React时，我努力制作一些可重用的组件或避免创建太多特定的组件，这在我的项目中是一个大问题，直到我学习了composition。</p><p id="e0a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">构图是一个非常众所周知的概念，但有时解释只是肤浅地涵盖了这个概念隐藏的真正力量。在这篇文章中，我将向你展示许多具体的例子，在这些例子中，组合是一个巨大的胜利，并且根据什么时候使用组合是一个好主意，什么时候我更喜欢使用另一种策略，给出一些个人意见。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="7136" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">什么是作文？</h2><p id="f147" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">组合是一个非常简单的概念，不仅在React中使用，在一般编程中也使用。例如，您可以组合许多函数:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="344a" class="lw lx in mv b gy mz na l nb nc">def sum(a, b):<br/>  return a + b</span><span id="c284" class="lw lx in mv b gy nd na l nb nc">def pow2(a):<br/>  return a * a</span><span id="ee0d" class="lw lx in mv b gy nd na l nb nc">def getScore(a):<br/>  return sum(a, 2) + pow2(a)</span></pre><p id="3929" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简而言之，您可以组合许多函数(sum和pow2)来产生第三个函数(getScore ),该函数使用低级函数来产生更高级别的结果。</p><p id="138c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这种情况下为什么要用构图？</strong></p><p id="f4e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一种方法是创建一个函数，只完成你需要的工作，例如:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="5120" class="lw lx in mv b gy mz na l nb nc">def getScore(a, b):<br/>  return a * a + b * 2</span></pre><p id="5a62" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">出现的问题</strong></p><ul class=""><li id="813b" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">当所有的实现只存在一个大函数时，推理就更具挑战性了。</li><li id="46ee" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">测试一个大功能比测试几个小功能更困难。</li><li id="2aa4" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">遵循单一责任原则，每个职能只有一个改变的理由。当问题被分解成小函数，每个函数只关注一个问题时，这种情况更为真实。</li><li id="61ae" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">如果你做同样的过程得到某个数的幂或者复制一个数，你需要重新实现逻辑。</li></ul><p id="18df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注。</strong>这只是一个简单的例子，说明合成术语不仅仅是反应，它是一个更抽象的概念。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="7357" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">反应中的成分</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/51538078ca8ed05cf626f1395bf4c1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-5-KLFfyO_4JyR_M"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3f67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在react中，您可以以稍微不同的方式使用复合。要使用构图，首先，重要的是要知道它是什么<code class="fe nt nu nv mv b">children</code>道具。</p><p id="f1ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">默认情况下，所有React组件都会收到一个参数，按照惯例，该参数通常被命名为props。这个参数总是有一个名为<code class="fe nt nu nv mv b">children</code>的特殊属性，这个属性包含当前组件的内部标签中传递的所有组件，例如:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="e17d" class="lw lx in mv b gy mz na l nb nc">function Grid (props) { }</span><span id="a724" class="lw lx in mv b gy nd na l nb nc">function Item (props) { }</span><span id="1923" class="lw lx in mv b gy nd na l nb nc"># ...<br/># Inside another component<br/># ...<br/>&lt;Grid&gt;<br/><strong class="mv io">  &lt;Item/&gt;<br/>  &lt;Item/&gt;  // Components inside the Grid component, they are refered<br/>  &lt;Item/&gt;  // as props.children in the Grid component</strong><br/>&lt;/Grid&gt;</span></pre><p id="28ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，<code class="fe nt nu nv mv b">Grid</code>组件中的<code class="fe nt nu nv mv b">props.children</code>将成为一个包含三个类型为<code class="fe nt nu nv mv b">Item</code>的元素的对象数组。</p><p id="30ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">了解子属性并不总是数组类型非常重要，例如:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="f44f" class="lw lx in mv b gy mz na l nb nc">&lt;Grid /&gt;                              <strong class="mv io"># props.children = Undefined</strong><br/>&lt;Grid&gt;&lt;h1&gt;Title&lt;h1&gt;&lt;/Grid&gt;            <strong class="mv io"># props.children = Object</strong><br/>&lt;Grid&gt;&lt;h1&gt;Title1&lt;/h1&gt;&lt;h1&gt;Title2&lt;/h1&gt;  <strong class="mv io"># props.children = [Object, Object]</strong></span></pre><p id="9f3d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意。</strong>重要的一点是，所有的组件可能不会只返回<code class="fe nt nu nv mv b">undefined</code>作为值，所以当你的函数只返回<code class="fe nt nu nv mv b">props.children</code>的值时要小心，因为在这种情况下，<code class="fe nt nu nv mv b">props.children</code>应该是强制的。</p><p id="be75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">构图的简单情况</strong></p><p id="20a5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，在react中，你用HTML标签创建一个组合，例如，在这个例子中，我用<code class="fe nt nu nv mv b">h1</code>和<code class="fe nt nu nv mv b">p</code>标签组成了<code class="fe nt nu nv mv b">div</code>标签。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="1472" class="lw lx in mv b gy mz na l nb nc">function HomePage = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Home page&lt;/h1&gt;<br/>      &lt;p&gt;Content of page&lt;p/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="1378" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个想法可以用你自己的组件来扩展。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="b5b8" class="lw lx in mv b gy mz na l nb nc"><strong class="mv io">function Container() { ... }<br/>function Paragraph() { ... }</strong></span><span id="05ae" class="lw lx in mv b gy nd na l nb nc">function HomePage = () =&gt; {<br/>  return (<br/>    &lt;Container&gt;<br/><strong class="mv io">      &lt;Heading&gt;</strong>Home page<strong class="mv io">&lt;/Heading&gt;<br/>      &lt;Paragraph&gt;</strong>Content of page<strong class="mv io">&lt;Paragraph/&gt;</strong><br/>    &lt;/Container&gt;<br/>  )<br/>}</span></pre><p id="f2d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个简单的例子中，优势并不明显，但现在我们将看到一个现实的例子，尤其是当您利用自定义组件和<code class="fe nt nu nv mv b">children</code>道具时。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="724c" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">实践写作</h2><p id="ed91" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">假设您有一个需要在屏幕上显示的文章列表。在第一个实现中，您决定创建一个<code class="fe nt nu nv mv b">ListArticle</code>组件，它在内部定义了<code class="fe nt nu nv mv b">className</code>来生成布局，在本例中，是一些网格(1)，同时定义了网格将包含一个<code class="fe nt nu nv mv b">ArticleCard</code>组件列表(2)。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="900d" class="lw lx in mv b gy mz na l nb nc">function ArticleCard(props) {<br/>  # Show the information of the article in a card<br/>  return (<br/>    &lt;div className='article-card'&gt;<br/>      article: props.article.name<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="cf0e" class="lw lx in mv b gy nd na l nb nc">function ListArticle(props) {<br/>  # Show a grid of articles<br/>  return (<br/>    &lt;div <strong class="mv io">className='article-grid'</strong>&gt;                            <strong class="mv io">// (1)</strong><br/>      <strong class="mv io">{props.articles.map(a =&gt; &lt;ArticleCard article={a} /&gt;)}  // (2)</strong><br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="6cb1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这听起来很棒，但存在一个主要问题。如果你的文章是从一个外部REST API获取的，有可能你想在获取数据的同时显示<a class="ae ks" href="https://chakra-ui.com/docs/components/feedback/skeleton" rel="noopener ugc nofollow" target="_blank">骨架</a>网格，所以，你被迫创建两个新组件。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="037b" class="lw lx in mv b gy mz na l nb nc">function ArticleCardSkeleton(props) {<br/>  return (<br/>    &lt;div className='article-card-skeleton'&gt;<br/>      ...<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="fd68" class="lw lx in mv b gy nd na l nb nc">function ListArticleSkeleton(props) {<br/>  return (<br/>    &lt;div <strong class="mv io">class='article-grid'</strong>&gt;            <strong class="mv io">// (1)</strong><br/>      <strong class="mv io">&lt;ArticleCardSkeleton /&gt;             // (2)<br/>      ...<br/>  </strong>  &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="49ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是你看到问题了吗？。<code class="fe nt nu nv mv b">ListArticleSkeleton</code>与<code class="fe nt nu nv mv b">ListArticle</code>组件非常相似，网格布局<strong class="kv io"> (1) </strong>都是一样的，唯一的变化是它里面的组件类型<strong class="kv io"> (2) </strong>。你可能会开始认为这种方法有问题，是的，有可能做得更好，你只需要使用构图。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="8161" class="lw lx in mv b gy mz na l nb nc">function ArticleCardSkeleton(props) { ... }</span><span id="2f5c" class="lw lx in mv b gy nd na l nb nc">function ArticleCard(props) { ... }</span><span id="2464" class="lw lx in mv b gy nd na l nb nc">function <strong class="mv io">GridArticle</strong>(props) {        <strong class="mv io">// 1</strong><br/>  # Show a grid of articles<br/>  return (<br/>    &lt;div class='article-grid'&gt;<br/>      <strong class="mv io">{props.children}               // 2</strong><br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="414e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我将<code class="fe nt nu nv mv b">ListArticle</code>重命名为<code class="fe nt nu nv mv b">GridArticle</code> (1)组件，以更清楚地表明它是一个文章网格，并且我将权力授予<code class="fe nt nu nv mv b">GridArticle</code>组件的用户，以定义哪些元素将通过<code class="fe nt nu nv mv b">children</code> prop (2)呈现在网格内。</p><p id="f259" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此时，您只有一个<code class="fe nt nu nv mv b">GridArticle</code>组件可以在两种情况下使用。这意味着使用组件的用户定义了网格中包含的组件，而<code class="fe nt nu nv mv b">GridArticle</code>只负责定义布局，我试图将这些组件视为组件布局。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="53f5" class="lw lx in mv b gy mz na l nb nc">// Grid of normal cards<strong class="mv io"><br/></strong>&lt;GridArticle&gt;<br/>  &lt;ArticleCard /&gt;<br/>  &lt;ArticleCard /&gt;<br/>  &lt;ArticleCard /&gt;<br/>&lt;/GridArticle&gt;</span><span id="45ff" class="lw lx in mv b gy nd na l nb nc">// Grid of skeleton cards<br/>&lt;GridArticle&gt;<br/>  &lt;ArticleCardSkeleton /&gt;<br/>  &lt;ArticleCardSkeleton /&gt;<br/>  &lt;ArticleCardSkeleton /&gt;<br/>&lt;/GridArticle&gt;</span></pre><p id="bbf6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这并不是这个例子的全部，T2还有一个额外的问题。您的第一个实现假设卡的页脚没有任何按钮，但是随着时间的推移，您需要添加一些额外的按钮，比如购物车或显示有优惠的消息。这是一个问题，你需要定义一个新的<code class="fe nt nu nv mv b">ArticleCard</code>来复制相同的用户界面，但是添加这些可能的按钮和信息，或者更糟的是，你开始添加诸如<code class="fe nt nu nv mv b">hasButton</code>、<code class="fe nt nu nv mv b">message</code>、<code class="fe nt nu nv mv b">offer</code>之类的道具，并有条件地渲染不同的部分。</p><p id="3d21" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有这些都是不好的方法，但是构图概念和<code class="fe nt nu nv mv b">children</code>道具在这种情况下可以帮助我们。</p><p id="0f2e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们需要<code class="fe nt nu nv mv b">ArticleCard</code>组件允许我们定义卡片的一些抽象部分，例如，卡片的“页脚”。按照上面的例子，我们可以使用<code class="fe nt nu nv mv b">children</code>道具，并且可以传递任何组件，比如按钮、消息、链接等，作为卡片的“页脚”部分。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="5875" class="lw lx in mv b gy mz na l nb nc">function ArticleCard(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;props.article.name&lt;/div&gt;<br/>      &lt;div&gt;props.article.price&lt;/div&gt;<br/>      <strong class="mv io">{props.children}</strong><br/>     &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="9626" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个好的解决方案，但有时还不够。如果您想在卡片的“标题”部分留言，会发生什么？。<code class="fe nt nu nv mv b">children</code>道具的主要优势在于，它是由React定义的道具，允许您以自然的方式指定内部组件(标签内的所有组件)，但是现在，您需要两个“区域”，所以，您需要定义另一个可以模拟第二个区域的道具，即“头部”区域。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="2b0e" class="lw lx in mv b gy mz na l nb nc">function ArticleCard(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      <strong class="mv io">{props.header}</strong><br/>      &lt;div&gt;props.article.name&lt;/div&gt;<br/>      &lt;div&gt;props.article.price&lt;/div&gt;<br/>      <strong class="mv io">{props.children}</strong><br/>     &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="3d8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">毕竟<code class="fe nt nu nv mv b">children</code>道具只是一个标准道具，但是可以创建更多的道具来表示组件中的某个区域，在这种情况下，我们定义了一个<code class="fe nt nu nv mv b">header</code>道具。我尽量使用最适合这种情况的通用术语，<code class="fe nt nu nv mv b">header</code>只代表卡中的上级区域，通过分配一个通用术语，我保证正确的名称对于组件的未来使用来说是更清晰的，并且不仅仅是针对我目前的用例。</p><p id="05cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，您可以在许多情况下使用您的组件。</p><ul class=""><li id="9df6" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">您只能定义<code class="fe nt nu nv mv b">children</code>道具:</li></ul><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="34a8" class="lw lx in mv b gy mz na l nb nc">&lt;ArticleCard&gt;<br/>  <strong class="mv io">&lt;div class='footer-card'&gt;<br/>    I am the footer content<br/>  &lt;/div&gt;</strong><br/>&lt;/ArticleCard&gt;</span></pre><ul class=""><li id="933a" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">您只能定义<code class="fe nt nu nv mv b">header</code>道具。</li></ul><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="7b7d" class="lw lx in mv b gy mz na l nb nc">&lt;ArticleCard<br/>  <strong class="mv io">header={<br/>    &lt;div class='header-card'&gt;<br/>      I am the header content<br/>    &lt;/div&gt;<br/>  }</strong><br/>/&gt;</span></pre><ul class=""><li id="c009" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">您可以定义两者。</li></ul><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="f917" class="lw lx in mv b gy mz na l nb nc">&lt;ArticleCard<br/>  <strong class="mv io">header={<br/>    &lt;div class='header-card'&gt;<br/>      I am the header content<br/>    &lt;/div&gt;<br/>  }</strong><br/>&gt;<br/>  <strong class="mv io">&lt;div class='footer-card'&gt;<br/>    I am the footer content<br/>  &lt;/div&gt;</strong><br/>&lt;/ArticleCard&gt;</span></pre><p id="1d70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您愿意，可以将<code class="fe nt nu nv mv b">children</code>道具重命名为<code class="fe nt nu nv mv b">footer</code>。这使得意义更加明显，唯一的问题是在使用时视觉上有点难看。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="163f" class="lw lx in mv b gy mz na l nb nc">&lt;ArticleCard<br/>  <strong class="mv io">header={<br/>    &lt;div class='header-card'&gt;<br/>      I am the header content<br/>    &lt;/div&gt;<br/>  }<br/>  footer={<br/>    &lt;div class='footer-card'&gt;<br/>      I am the footer content<br/>    &lt;/div&gt;<br/>  }<br/></strong>/&gt;</span></pre></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="ae00" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">组合不仅仅是可重用的组件</h2><p id="f704" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">构图不仅仅是UI。组件的组合可以帮助您以更简洁的方式在应用程序的子组件中传播您的状态。</p><p id="d26b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设你有一个电子商务网站，你有一个购物车。购物车只是一个商品列表，用户保存这些商品以便在下一个时刻支付，但是你需要将这个状态传递给页面的许多部分，例如，导航栏(显示购物车中商品的计数器)，在<code class="fe nt nu nv mv b">ArticleCard</code>中当用户点击商品时将商品添加到购物车，以及其他一些地方。目前，我们将注意力集中在期待购物车状态的<code class="fe nt nu nv mv b">ArticleCard</code>组件上，我们将看看当我们不使用组合时会发生什么:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="073b" class="lw lx in mv b gy mz na l nb nc">function NavBar() { ... }</span><span id="edf2" class="lw lx in mv b gy nd na l nb nc">function ArticleList(props) {<br/>  return props.articles.map((article) =&gt; &lt;ArticleCard article={article} /&gt;);<br/>}</span><span id="a272" class="lw lx in mv b gy nd na l nb nc">function ArticleCard(props) {<br/>  return (<br/>    &lt;ArticleCardHeader article={props.article} /&gt;<br/>    &lt;ArticleCardBody article={props.article} /&gt;<br/>    &lt;ArticleCardFooter cart={props.cart}/&gt;<br/>  }<br/>)</span><span id="258f" class="lw lx in mv b gy nd na l nb nc">function ArticleCardFooter(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;...&lt;/div&gt;<br/>      &lt;ShoppingCartButton article={props.article} cart={props.cart}<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="dde7" class="lw lx in mv b gy nd na l nb nc"><strong class="mv io">// The only component that requires the cart state<br/>function ShoppingCartButton(props) {<br/>  return &lt;button onClick={() =&gt; cart.addItem(article)}&gt;Add&lt;/button&gt;;<br/>}</strong></span><span id="c5e9" class="lw lx in mv b gy nd na l nb nc">function Page() {<br/>  const cart = useCart();<br/>  const articles = useArticles();</span><span id="a7d8" class="lw lx in mv b gy nd na l nb nc">return (<br/>    &lt;div&gt;<br/>      &lt;NavBar cart={cart} /&gt;<br/>      &lt;ArticleList cart={t} articles={articles} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="be98" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，问题在于唯一需要知道购物车信息的组件是<code class="fe nt nu nv mv b">ShoppingCartButton</code>，但是<code class="fe nt nu nv mv b">ArticleList</code>、<code class="fe nt nu nv mv b">ArticleCard</code>和<code class="fe nt nu nv mv b">ArticleCardFooter</code>需要接收那个道具，唯一的目的是传递给<code class="fe nt nu nv mv b">ShoppingCartButton</code>。</p><p id="b04a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意。</strong>这个问题一般称为<a class="ae ks" href="https://kentcdodds.com/blog/prop-drilling" rel="noopener ugc nofollow" target="_blank">支柱钻孔</a>。</p><p id="445f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个更具层次性的问题模式:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="8d0b" class="lw lx in mv b gy mz na l nb nc">Page  <strong class="mv io">(I have the shopping cart state!)</strong><br/>  -- NavBar<br/>  -- ArticleList<br/>       -- ArticleCard<br/>            -- ArticleCardHeader<br/>            -- ArticleCardBody<br/>            -- ArticleCardFooter<br/>                 -- <strong class="mv io">ShoppingCartButton  (I need the shopping cart state!)</strong></span></pre><p id="c881" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们没有在组件的内容中定义完整的实现，而是将其定义为一个组件布局，允许我们在<code class="fe nt nu nv mv b">children</code> prop中传递内容。结果是这样的:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="143e" class="lw lx in mv b gy mz na l nb nc">function Page() {<br/>  const cart = useCart();<br/>  const articles = useArticles();</span><span id="5828" class="lw lx in mv b gy nd na l nb nc">return (<br/>    &lt;div&gt;<br/>      &lt;NavBar cart={cart} /&gt;<br/>      &lt;ArticleList&gt;<br/>        &lt;ArticleCard article={article}&gt;<br/>          &lt;div&gt;...&lt;/div&gt;<br/><strong class="mv io">          &lt;ShoppingCartButton article={article} cart={props.cart} /&gt;</strong><br/>        &lt;/ArticleCard&gt;<br/>        ...<br/>      &lt;/ArticleList&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="e87a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，所有组件只接收它们真正需要的，唯一接收购物车状态的组件是<code class="fe nt nu nv mv b">ShoppingCartButton</code>。</p><p id="fe15" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你对React有一点经验，你可能会考虑使用上下文。<a class="ae ks" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Context </a>允许你在你的app里放一个全局状态，并以一种快速的方式访问它，有什么问题？</p><ul class=""><li id="ca11" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated"><strong class="kv io">跟踪误差很困难。</strong> React上下文是一个<strong class="kv io">全局状态</strong>。提供者内部的任何组件都可以访问它，并且根据情况的不同，任何组件都可以改变它的值，换句话说，跟踪问题是非常困难的。</li><li id="2b00" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><strong class="kv io">可重用组件较少。</strong>您避免了prop drilling噪音，但是现在，您只能在自定义提供者内部使用您的组件，您不能在de提供者外部重用它们，因为他们需要访问他。</li><li id="3128" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><strong class="kv io">来源歧义。</strong>有时不清楚哪些信息是可用的或者信息来自哪里，与此相反，显式道具是传递所有信息的更显式的方式，并且确切地知道哪些信息是可用的以及它们的来源。</li></ul><p id="bd36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">推荐你看<a class="ae ks" href="https://www.youtube.com/watch?v=3XaXKiXtNjw" rel="noopener ugc nofollow" target="_blank">迈克尔杰克逊</a>的视频。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="ab95" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">作文并不总是正确的工具(个人观点)</h2><p id="abac" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">合成并不总是正确的工具，React Context是一种选择。</p><p id="98ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我个人的观点是在两种特殊情况下使用React上下文:</p><ol class=""><li id="459d" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nw nk nl nm bi translated">当它是应用程序上的一个真正的全局状态时，比如身份验证状态。</li><li id="cde1" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nw nk nl nm bi translated">当你制造一些需要作为一个单元工作的组件组时，例如:</li></ol><p id="f41d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设您定义了一个<code class="fe nt nu nv mv b">Switch</code>和<code class="fe nt nu nv mv b">Case</code>组件，它根据传递给<code class="fe nt nu nv mv b">Switch</code>元素的值有条件地呈现一些元素。</p><p id="0c83" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该组件的预期用途是:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="5b90" class="lw lx in mv b gy mz na l nb nc">// ...<br/>&lt;Switch value={status}&gt;<br/>  &lt;Case match='loading'&gt;<br/>    &lt;p&gt;Loading...&lt;/&gt;<br/>  &lt;/Case&gt;<br/>  &lt;Case match='done'&gt;<br/>    &lt;p&gt;Done...&lt;/p&gt;<br/>  &lt;/Case&gt;<br/>  &lt;Case match='error'&gt;<br/>    &lt;p&gt;Error...&lt;/p&gt;<br/>  &lt;/Case&gt;<br/>&lt;/Switch&gt;</span></pre><p id="feef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，所有组件作为一个整体工作。在<code class="fe nt nu nv mv b">Switch</code>组件之外声明<code class="fe nt nu nv mv b">Case</code>组件是没有意义的。</p><p id="3504" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nt nu nv mv b">Switch</code>组件将隐藏提供传递给它的值的提供者。所有的<code class="fe nt nu nv mv b">Case</code>组件都将从中获取值，如果当前值与case值匹配，则决定呈现<code class="fe nt nu nv mv b">children</code>属性。</p><p id="70df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">正确的粒度级别</strong></p><p id="7464" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种组合的一个副作用是可以看到包含每个组件的完整图片。如果用户界面很复杂，您可以得到如下结果:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="7c0d" class="lw lx in mv b gy mz na l nb nc">const HomePage = () =&gt; {<br/>  return (<br/>    &lt;Container&gt;<br/>      &lt;Header&gt;<br/>        &lt;Logo /&gt;<br/>        &lt;Menu&gt;<br/>          &lt;MenuItem /&gt;<br/>          &lt;MenuItem /&gt;<br/>          &lt;MenuItem /&gt;<br/>          &lt;MenuItem /&gt;<br/>        &lt;/Menu&gt;<br/>      &lt;/Header&gt;<br/>    <br/>      &lt;Body&gt;<br/>        &lt;Controls&gt;<br/>         &lt;SearchBar /&gt;<br/>         &lt;Filters&gt;<br/>           &lt;Filter /&gt;<br/>           &lt;Filter /&gt;<br/>           &lt;Filter /&gt;<br/>           &lt;Filter /&gt;<br/>         &lt;/Filters&gt;<br/>         &lt;ArticleGrid&gt;<br/>           &lt;Article&gt;<br/>             &lt;ArticleLink/&gt;<br/>             &lt;LikeButton/&gt;<br/>         &lt;/ArticleGrid&gt;<br/>         &lt;PaginationControls /&gt;<br/>      &lt;/Body&gt;<br/>    <br/>      &lt;Footer&gt;<br/>        &lt;ContactInfo&gt;<br/>          &lt;SocialNetwork /&gt;<br/>          &lt;SocialNetwork /&gt;<br/>          &lt;SocialNetwork /&gt;<br/>        &lt;/ContactInfo&gt;<br/>        &lt;Politicts /&gt;<br/>      &lt;/Footer&gt;<br/>    &lt;/Container&gt;<br/>  );<br/>}</span></pre><p id="5a82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当您定义组件的状态和完整实现时，这可能更糟，但问题是这是<code class="fe nt nu nv mv b">HomePage</code>组件。在大多数情况下，当你进入一个页面组件时，你只需要改变页面的某个特定部分，你不一定需要看到页面每个部分的完整实现。</p><p id="3458" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我遇到一些具有高级组件的情况时，我更喜欢创建单独的组件来定义页面的高级部分，并在这些组件中的每一个上委托合成:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="a146" class="lw lx in mv b gy mz na l nb nc">const Header = () =&gt; {<br/>  return (<br/>      &lt;HeaderContainer&gt;<br/>        &lt;Logo /&gt;<br/>        &lt;Menu&gt;<br/>          &lt;MenuItem /&gt;<br/>          &lt;MenuItem /&gt;<br/>          &lt;MenuItem /&gt;<br/>          &lt;MenuItem /&gt;<br/>        &lt;/Menu&gt;<br/>      &lt;/HeaderContainer&gt;<br/>  );<br/>}</span><span id="4c6e" class="lw lx in mv b gy nd na l nb nc">const Body = () =&gt; {<br/>  return (<br/>      &lt;Body&gt;<br/>        &lt;Controls&gt;<br/>         &lt;SearchBar /&gt;<br/>         &lt;Filters&gt;<br/>           &lt;Filter /&gt;<br/>           &lt;Filter /&gt;<br/>           &lt;Filter /&gt;<br/>           &lt;Filter /&gt;<br/>         &lt;/Filters&gt;<br/>         &lt;ArticleGrid&gt;<br/>           &lt;Article&gt;<br/>             &lt;ArticleLink/&gt;<br/>             &lt;LikeButton/&gt;<br/>         &lt;/ArticleGrid&gt;<br/>         &lt;PaginationControls /&gt;<br/>      &lt;/Body&gt;<br/>  );<br/>}</span><span id="e014" class="lw lx in mv b gy nd na l nb nc">const Footer = () =&gt; {<br/>  return (<br/>      &lt;Footer&gt;<br/>        &lt;ContactInfo&gt;<br/>          &lt;SocialNetwork /&gt;<br/>          &lt;SocialNetwork /&gt;<br/>          &lt;SocialNetwork /&gt;<br/>        &lt;/ContactInfo&gt;<br/>        &lt;Politicts /&gt;<br/>      &lt;/Footer&gt;<br/>    &lt;/Container&gt;<br/>  );<br/>}</span><span id="2075" class="lw lx in mv b gy nd na l nb nc">const HomePage = () =&gt; {<br/>  return (<br/>    &lt;Container&gt;<br/>      &lt;Header /&gt;<br/>      &lt;Body /&gt;<br/>      &lt;Footer /&gt;<br/>    &lt;/Container&gt;<br/>  );<br/>}</span></pre><p id="40a8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这有许多优点:</p><ul class=""><li id="1588" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">根据组件的抽象级别，您只显示必要的细节。</li><li id="9e62" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">如果您像第一个实现一样向应用程序添加一个状态，那么每次状态改变时，您都要重新呈现所有的页面组件，如果该状态只对页面的一部分是必需的，则是独立的。</li></ul></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="09fc" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">结论</h2><ul class=""><li id="0932" class="ne nf in kv b kw mp kz mq lc nx lg ny lk nz lo nj nk nl nm bi translated">作文不仅仅是一个反应的概念。可以用函数，类等做作文。</li><li id="41f4" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">儿童道具是制作组件组合的良好资源。</li><li id="f807" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">组合允许您定义可重用的组件。</li><li id="7bcd" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">组件的组成可以改善你的状态流。</li><li id="f196" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">合成的一种替代方法是使用带有React上下文的全局状态。</li><li id="9db5" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">更喜欢作文而不是反应上下文。</li><li id="5dc2" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">使用复合时，要注意抽象的粒度级别。</li><li id="1223" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">道具演练并不总是不好的，有时候构图并不是合适的工具。</li></ul></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="56f8" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">参考</h2><ul class=""><li id="f114" class="ne nf in kv b kw mp kz mq lc nx lg ny lk nz lo nj nk nl nm bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=3XaXKiXtNjw" rel="noopener ugc nofollow" target="_blank">反应成分</a></li><li id="3fc1" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><a class="ae ks" href="https://kentcdodds.com/blog/prop-drilling" rel="noopener ugc nofollow" target="_blank">支柱钻孔</a></li></ul><p id="ef54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="oa">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oa">说白了就是</em> </strong> </a> <em class="oa">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oa">免费周报</em> </strong> </a> <em class="oa">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oa">Twitter</em></strong></a><em class="oa">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="oa">LinkedIn</em></strong></a><em class="oa">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="oa">社区</em> </strong> </a> <em class="oa">。</em></p></div></div>    
</body>
</html>