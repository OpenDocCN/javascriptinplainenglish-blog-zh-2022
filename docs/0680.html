<html>
<head>
<title>The var, let, const, and Undeclared Variables in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的var、let、const和未声明的变量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/var-let-const-and-undeclared-variables-in-javascript-32d3c72442ba?source=collection_archive---------6-----------------------#2022-02-07">https://javascript.plainenglish.io/var-let-const-and-undeclared-variables-in-javascript-32d3c72442ba?source=collection_archive---------6-----------------------#2022-02-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4a10" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">您需要了解的关于JavaScript中不同变量声明的一切，以及与它们相关的最佳实践。</h2></div><p id="e3f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最近在审查Node.js存储库中的一些代码时，遇到了一个forEach循环，其中迭代器变量缺少声明。我一直认为声明我们在JavaScript中使用的所有变量是必需的，所以对我来说，代码能够工作并投入生产是一个奇迹。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/2b9bed8d3ba076d21bb2cfb80e221f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*z6P5NeC0lPHtMRKMkO_NmQ.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Screenshot from my own device :P</figcaption></figure><p id="6a0d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在阅读W3Schools的页面时，我意识到发生了什么。</p><h1 id="4ee0" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="ebeb" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">未声明的变量是那些没有使用关键字标记、<code class="fe mi mj mk ml b">var</code>、<code class="fe mi mj mk ml b">let</code>或<code class="fe mi mj mk ml b">const</code>显式声明的变量。</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="55df" class="mq lm in ml b gy mr ms l mt mu">// undeclared variable<br/>undeclaredVar = “Dummy Text”;<br/>console.log(undeclaredVar);</span><span id="994c" class="mq lm in ml b gy mv ms l mt mu">// declared variables<br/>var a = 1;<br/>let b = "yes";<br/>const Pi = 3.141</span></pre><p id="f313" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是所有这三种类型的变量声明的快速比较图表:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Scope and access of variables with different kinds of declarations</figcaption></figure><p id="1d6f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以使用下面的脚本来试验这些声明类型。改变<code class="fe mi mj mk ml b">a</code>、<code class="fe mi mj mk ml b">b</code>和<code class="fe mi mj mk ml b">c</code>三个变量的声明，测试不同类型声明提供的作用域和访问权限:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Try editing lines 1, 4, 11 or 6 by adding one of the keywords (var, let, const or nothing)</figcaption></figure><p id="a9dd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="my">注意:在代码中使用未声明的变量是非常不安全的，完全不建议使用。拥有全局作用域意味着你的变量可以在任何地方被访问和修改，这可能是一个调试的噩梦。</em></p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="5878" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们分别研究这些变量声明类型的每个属性。</p><h1 id="8d21" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">范围</h1><p id="29af" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">未声明的变量在范围上自动是全局的，不管它们在哪里声明。所有其他变量都可以在其定义的范围内访问。请注意，所有变量都可以在一个函数内部访问，这个函数是在它自己的作用域中定义的。</p><p id="00f2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，需要注意的是，使用<code class="fe mi mj mk ml b">var</code>和较新的ES6声明(<em class="my"> let </em>和<em class="my"> const </em>)定义范围的方式有一个细微的区别。<a class="ae lk" href="https://stackoverflow.com/a/11444416/4677052" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出答案</a>在解释这个问题上做了大量工作。我强烈建议浏览一下。</p><div class="ng nh gp gr ni nj"><a href="https://stackoverflow.com/a/11444416/4677052" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">用“let”和“var”有什么区别？</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用var语句定义的变量在整个函数中是已知的，从…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">stackoverflow.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx le nj"/></div></div></a></div><p id="aaa6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，<code class="fe mi mj mk ml b">let</code>和<code class="fe mi mj mk ml b">const</code>变量的作用域仅限于定义它们的代码块。<code class="fe mi mj mk ml b">var</code>变量在定义它们的整个函数中都可用。</p><p id="6e18" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下脚本准确地演示了每个变量声明的范围:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1c67" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这会产生以下输出:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="3e89" class="mq lm in ml b gy mr ms l mt mu">Happy Birthday to you<br/>a: Happy<br/>b: Birthday<br/>c is not defined in this scope<br/>d is not defined in this scope<br/>a: Happy<br/>b is not defined in this scope<br/>c is not defined in this scope<br/>d is not defined in this scope</span></pre><h1 id="3202" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">重新申报</h1><p id="f486" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">重新声明意味着在相同的范围内再次声明相同的变量。</p><p id="5f5f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于未声明的变量，由于没有特殊的声明语法，因此“可重复声明”的属性是多余的真。</p><p id="c2da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在已声明的变量中，<code class="fe mi mj mk ml b">var</code>允许重新声明，而<code class="fe mi mj mk ml b">let</code>和<code class="fe mi mj mk ml b">const</code>在你试图重新声明它们时抛出一个<code class="fe mi mj mk ml b">SyntaxError</code>。</p><h2 id="1c51" class="mq lm in bd ln ny nz dn lr oa ob dp lv kl oc od lx kp oe of lz kt og oh mb oi bi translated">定义变量</h2><p id="e556" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">以下代码运行时不会引发任何错误:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="da6f" class="mq lm in ml b gy mr ms l mt mu">var a = "Hello, World!";<br/>console.log(a);</span><span id="7605" class="mq lm in ml b gy mv ms l mt mu">var a = 12;<br/>console.log(a);</span></pre><p id="429d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是上面代码的输出:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="03be" class="mq lm in ml b gy mr ms l mt mu">Hello, World!<br/>12</span></pre><h2 id="1724" class="mq lm in bd ln ny nz dn lr oa ob dp lv kl oc od lx kp oe of lz kt og oh mb oi bi translated">保持不变</h2><p id="7aed" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">如果用<code class="fe mi mj mk ml b">let</code>或<code class="fe mi mj mk ml b">const</code>替换上述<code class="fe mi mj mk ml b">var</code>中的<strong class="ke io">中的任何一个</strong>，将会出现以下错误:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="f103" class="mq lm in ml b gy mr ms l mt mu">var a = 12;<br/>    ^</span><span id="19c4" class="mq lm in ml b gy mv ms l mt mu">SyntaxError: Identifier 'a' has already been declared</span></pre><p id="4b66" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更清楚地说，下面的每一个都会抛出一个语法错误:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="b3c4" class="mq lm in ml b gy mr ms l mt mu">let a = "Hello, World!";<br/>let a = 12;               // this is a syntax error</span></pre><p id="7277" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">—</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="f27d" class="mq lm in ml b gy mr ms l mt mu">const a = "Hello, World!";<br/>const a = 12;               // this is a syntax error</span></pre><p id="db42" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即使您在其中一个声明中使用了<code class="fe mi mj mk ml b">var</code>(以下示例仅针对<code class="fe mi mj mk ml b">let</code>给出，但同样适用于<code class="fe mi mj mk ml b">const</code>)。</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="f016" class="mq lm in ml b gy mr ms l mt mu">let a = "Hello, World!";<br/>var a = 12;               // this is a syntax error</span></pre><p id="dbd6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">—</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="9eff" class="mq lm in ml b gy mr ms l mt mu">var a = "Hello, World!";<br/>let a = 12;               // this is a syntax error</span></pre><h1 id="c4da" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">提升</h1><p id="d6f6" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">提升意味着你可以在声明变量之前使用它，解释器并不介意。换句话说，解释器将声明“提升”到变量的所有用法之上。</p><p id="a5c1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于未声明的变量，由于没有特殊的声明语法，因此“提升”属性是多余的。</p><p id="13ea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，<code class="fe mi mj mk ml b">var</code>允许提升，而<code class="fe mi mj mk ml b">let</code>和<code class="fe mi mj mk ml b">const</code>会抛出一个<code class="fe mi mj mk ml b">ReferenceError </code>如果你在声明前使用这个变量。从块的开始直到声明完成，变量被称为处于“时间死区”(TDZ)。</p><p id="12e6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">未声明的变量:</strong></p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="1752" class="mq lm in ml b gy mr ms l mt mu">function test() {<br/>    a = "Hello, World!";<br/>    console.log(a);               // output: "Hello, World!"<br/>    a = 12;<br/>    console.log(a);               // output: "12"<br/>}</span><span id="78b6" class="mq lm in ml b gy mv ms l mt mu">test();<br/>console.log("a: " + a);           // output: "a: 12"</span></pre><p id="5372" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> var: </strong></p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="db62" class="mq lm in ml b gy mr ms l mt mu">function test() {<br/>    a = "Hello, World!";<br/>    console.log(a);               // output: "Hello, World!"<br/>    var a = 12;<br/>    console.log(a);               // output: "12"<br/>}</span><span id="076e" class="mq lm in ml b gy mv ms l mt mu">test();<br/>console.log("a: " + a);           // ReferenceError: a is not defined</span></pre><p id="eedc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> let或const: </strong></p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="abf2" class="mq lm in ml b gy mr ms l mt mu">function test() {<br/>    a = "Hello, World!";<br/>    console.log(a);               // ReferenceError: Cannot access 'a' before initialization<br/>    let a = 12;<br/>    console.log(a);<br/>}</span><span id="98e0" class="mq lm in ml b gy mv ms l mt mu">test();<br/>console.log("a: " + a);</span></pre><h1 id="f7bb" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">易变的</h1><p id="03b2" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">可变性是区别<code class="fe mi mj mk ml b">let</code>和<code class="fe mi mj mk ml b">const</code>的一点。除了<code class="fe mi mj mk ml b">const</code>，所有的声明类型都创建可变变量。</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="d197" class="mq lm in ml b gy mr ms l mt mu">a = "Happy";<br/>var b = "Birthday";<br/>let c = "to";<br/>const d = "you";</span><span id="ecab" class="mq lm in ml b gy mv ms l mt mu">console.log(`${a} ${b} ${c} ${d}`);  // output: "Happy Birthday to you"</span><span id="369c" class="mq lm in ml b gy mv ms l mt mu">a = 10;                              // works<br/>b = 11;                              // works<br/>c = 12;                              // works<br/>d = 13;                              // TypeError: Assignment to constant variable.</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="8c5f" class="ll lm in bd ln lo oj lq lr ls ok lu lv jt ol ju lx jw om jx lz jz on ka mb mc bi translated">结论</h1><p id="ef21" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">现在您已经理解了所有不同的变量声明类型，我想把您的注意力吸引到最佳实践和您应该做的事情上来。未声明的变量和<code class="fe mi mj mk ml b">var</code>变量在ES6发布之前就已经是JavaScript的一部分，而<code class="fe mi mj mk ml b">let</code>和<code class="fe mi mj mk ml b">const</code>是在ES6中引入的(<em class="my">ECMAScript标准的第6版)。引入它们是为了在保持遗留代码工作的同时修复某些问题。</em></p><p id="39f8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我建议你<strong class="ke io">总是</strong>只使用<code class="fe mi mj mk ml b">const</code>和<code class="fe mi mj mk ml b">let</code>声明。在我看来，如果你能很好地编写代码，这应该能满足你的所有需求。这也将使您的代码在更长的时间内保持可读性和可维护性。</p><p id="7408" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="my">总是</em> </strong> <em class="my">只使用</em> <code class="fe mi mj mk ml b"><em class="my">const </em></code> <em class="my">和</em> <code class="fe mi mj mk ml b"><em class="my">let </em></code> <em class="my">声明。</em></p><p id="cead" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除此之外，您应该尽可能优先使用不可变类型声明，<code class="fe mi mj mk ml b">const</code>而不是可变类型，<code class="fe mi mj mk ml b">let</code>。它具有可读性、可维护性以及性能优势。</p><p id="29a8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是变量声明类型的最终首选顺序:</p><p id="75f5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="my">const&gt;let&gt;&gt;var&gt;&gt;未声明</em></p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="f4c4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢读这篇文章，请点击几下拍手按钮。它鼓励我写更多的东西，在每篇文章中投入更多的精力。此外，请浏览我的其他文章，如果您觉得它们与您相关，请关注我。</p><p id="8e83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="my">更多内容请看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="my">说白了就是</em> </strong> </a> <em class="my">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="my">免费每周简讯</em> </strong> </a> <em class="my">。关注我们</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="my">Twitter</em></strong></a><em class="my">和</em><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="my">LinkedIn</em></strong></a><em class="my">。查看我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="my">社区不和谐</em> </strong> </a> <em class="my">加入我们的</em> <a class="ae lk" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="my">人才集体</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>