<html>
<head>
<title>5 JavaScript Concepts to Make You an Excellent Front-end Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你成为优秀前端开发人员的5个JavaScript概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-javascript-concepts-to-make-you-an-excellent-front-end-developer-994676aa2431?source=collection_archive---------2-----------------------#2022-07-08">https://javascript.plainenglish.io/5-javascript-concepts-to-make-you-an-excellent-front-end-developer-994676aa2431?source=collection_archive---------2-----------------------#2022-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="17fe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第5部分:了解JavaScript中的这些概念可以帮助您成为一名优秀的前端开发人员。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a0c07bd951a567ecd585444ef1218a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCRwxvrg9UTrqdbXFfhgQA.jpeg"/></div></div></figure><p id="b3e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是不是有很多朋友会发现，嗯嗯，改了标题？没错，标题确实是改了，但是分享的内容在之前的内容之后继续分享。第四次分享文章后，有朋友私信说标题能不能改一下，增加一些新鲜感。和这些伙伴沟通后，我觉得可以试试。</p><p id="aa74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，希望新标题也能被大家喜欢，也希望新分享的内容能被更多的朋友讨论。</p><p id="8556" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这次我们继续分享JavaScript的知识点:</p><p id="e235" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln"> 1。先说传承</em> </strong></p><p id="55c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面将讨论几种继承方式，包括它们的特征:</p><p id="a5b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(1)原型链继承:覆盖对象。</p><p id="7f48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它有两个缺点:1)对象实例共享所有继承的属性和方法。2)不能传递参数</p><p id="b278" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(2)构造函数继承:在子类构造函数内部调用超类型构造函数。使用apply()和call()方法</p><p id="9940" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其缺点是:(a)功能复用性不高。每个实例都是一个重新实例化的构造函数，没有共享属性。(b)只能继承实例上的属性，原型上的方法不可见。</p><p id="02c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(3)复合继承:原型链+构造函数父调用(this) new parent()避免了上述缺点。</p><p id="bf43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优点:可以传递参数，不会与父类引用属性共享</p><p id="2a1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺点:继承父类的函数时，调用父类的构造函数，导致子类原型上没有必要的父类属性，浪费内存。</p><p id="4bf8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(4)原型继承:object()函数执行传入对象的浅层复制</p><p id="acae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(5)寄生继承:使用构造函数继承属性，通过原型链的混合形式继承方法</p><p id="dea4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(6)寄生复合只调用构造函数一次，结合了寄生继承和复合继承的优点。它是实现基于类型的继承的最有效的方法。就是将父类的原型赋给子类，并将构造函数设置为子类，解决了无用的父属性问题，parent call + Object.create()</p><p id="98c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">2<em class="ln">。先来简单了解一下这个关键词</em> </strong></p><p id="f4ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">这有五个场景:</strong></p><p id="5830" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(1)绑定事件指向事件本身</p><p id="f110" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(2)普通函数，指向方法体</p><p id="5235" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(3)新函数指向当前类</p><p id="b90a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(4)箭头功能，指向父上下文</p><p id="ee1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(5)调用/应用/绑定</p><p id="44b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln"> 3。你对类型判断了解多少？</em>T3】</strong></p><p id="6a84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">说到js类型判断，我们可以想到typeof，instanceof，constructor，Object.prototype.toString.call()。</p><p id="4879" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那我们来对比一下它的门的功能和区别。</p><p id="a714" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">typeof显示除null之外的基元类型的正确类型。但是对于对象来说，除了函数之外，对象都会被显示出来，所以它的功能只是判断原始类型，而不是判断对象。</p><p id="a771" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">instanceof用于判断变量是否是对象的实例，通过原型链判断内部机制。他确实能判断出类型是否正确。但值得注意的是，instanceof检测原型，原型链上的每个类型都会返回true。所以只能用来判断两个对象是否属于一个实例关系，而不能判断一个对象实例属于哪种类型。</p><p id="2d3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构造函数是原型的一个属性。定义函数时，js引擎会给函数添加原型，这个原型中的构造函数属性指向函数引用，所以重写原型会丢失原来的构造函数。</p><p id="b317" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但它也有明显的缺陷:</p><p id="eca5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(null和undefined没有构造函数，这个方法无法判断。</p><p id="8f26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(2)如果在开发人员重写原型后定制对象，那么原来的构造函数就会丢失。因此，为了规范开发，在重写对象原型时，一般需要重新分配构造函数，以保证对象实例的类型不被改变。篡改。</p><p id="9764" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">toString是几个方案中比较好的一个。推荐使用。toString()是Object的原型方法，调用这个方法默认返回当前对象的[[Class]]。这是一个格式为[对象Xxx]的内部属性，其中Xxx是对象的类型。</p><p id="6f66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln"> 4。下面我们一起来了解一下</em> </strong>的转换</p><p id="9801" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln"> js类型转换可分为三种情况:</em> </strong></p><p id="cd12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">转换为布尔值</p><p id="08c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">转换成数字</p><p id="5518" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">转换为字符串</p><p id="642a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中，转换为boolean，除了undefined，null，false，NaN，''，0，-0，其他所有值都转换为true。我们可以每天使用它来确定一个对象是否未被赋值</p><p id="0260" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln"> 5。比较运算符，我们对</em> </strong>了解多少</p><p id="2673" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">比较运算符是常用的。如果它们都是数字类型，并且比较值的大小，那么当然就简单了。如果是非数字值呢？</p><p id="284c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顺序如下:将值转换为原语(to primitive方法)转换为数字(valueOf方法)转换为字符串(to string方法)</p><p id="75ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里都解释了，我再补充一下我提到的。关于top primitive过程，top primitive有两种情况，一种是数字，一种是字符串。</p><p id="09ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果是一个数字，执行如下:</p><p id="cf71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(1)如果输入的是原值，直接返回这个值；</p><p id="aae4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(2)否则，如果输入是对象，则调用input.valueOf()，如果结果是基元值，则返回结果；</p><p id="d249" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(3)否则，调用input.toString()。如果结果是原始值，则返回结果；</p><p id="c0a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(4)否则，抛出一个错误。</p><p id="48a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果是字符串，则步骤2和3交换。</p><p id="ca56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以当原始类型是字符串，类型是数字时</p><p id="eee0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">好了，这次分享到此结束，我们下次继续分享，欢迎大家一起讨论。</strong></p><p id="8cce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">感谢您的阅读，期待您的关注，让我们共同进步。</em> </strong></p><p id="6fcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">更多内容看</em> <a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">说白了就是io </em> </strong> </a> <em class="ln">。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">免费周报</em> </strong> </a> <em class="ln">。关注我们关于</em><a class="ae lo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ln">Twitter</em></strong></a><em class="ln">和</em><a class="ae lo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ln">LinkedIn</em></strong></a><em class="ln">。查看我们的</em> <a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">社区不和谐</em> </strong> </a> <em class="ln">加入我们的</em> <a class="ae lo" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">人才集体</em> </strong> </a> <em class="ln">。</em></p></div></div>    
</body>
</html>