<html>
<head>
<title>An Introduction to JavaScript Promise for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的JavaScript Promise介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-javascript-promise-7b5e03d06bdf?source=collection_archive---------9-----------------------#2022-01-09">https://javascript.plainenglish.io/what-is-javascript-promise-7b5e03d06bdf?source=collection_archive---------9-----------------------#2022-01-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c94d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是JavaScript Promise？它表示异步操作的最终完成(或失败)及其结果值。</h2></div><p id="2649" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不要被击碎😟在定义上。我可以<strong class="ke io"> <em class="ky">承诺🤝</em> </strong>你最后会明白这个定义的。</p><p id="e0b0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在去in🤿潜水吧，因为。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/094ff723931e9007e22dc2072363c3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4w7tUctOSE6uaauEeu2JrA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">A proverb in JS style</figcaption></figure><p id="bd94" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，JavaScript是一种同步单线程语言。因此，它不会等到ajax请求完成。我们用JavaScript泡个茶来理解这个问题。</p><p id="4436" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用JavaScript做一个tea🫖。</p><pre class="la lb lc ld gt lp lq lr ls aw lt bi"><span id="f5bf" class="lu lv in lq b gy lw lx l ly lz">function makeTea(){<br/>   TakeWater();<br/>   boilIt();<br/>   AddTeaPowder();<br/>   ServeItInTheGlass();<br/>}</span><span id="e288" class="lu lv in lq b gy ma lx l ly lz">function TakeWater(){ <br/>   console.log("Take water💧 in a bowl🥣 ");<br/>}</span><span id="8ee0" class="lu lv in lq b gy ma lx l ly lz">function boilIt(){ <br/>  console.log("Boil the water🔥");<br/>}</span><span id="7bbb" class="lu lv in lq b gy ma lx l ly lz">function AddTeaPowder(){ <br/>  console.log("Add your favourite Tea powder");<br/>}</span><span id="bf54" class="lu lv in lq b gy ma lx l ly lz">function ServeIt(){ <br/>  console.log("Serve the Tea in a pot🫖☕️");<br/>}</span></pre><p id="0b5b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在这种情况下，AddTeaPowder()&amp; ServeItInTheGlass()步骤不会等到水烧开🤦。</p><p id="1fae" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，我们可以在完成请求后使用回调来执行函数。在回调函数中，该函数也将作为参数传递。</p><p id="7a12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，试着用同样的茶来回拨。</p><pre class="la lb lc ld gt lp lq lr ls aw lt bi"><span id="a256" class="lu lv in lq b gy lw lx l ly lz">function makeTea(){<br/>   TakeWater();<br/>   boilIt(AddTeaPowder,serveIt); <br/>}</span><span id="5a05" class="lu lv in lq b gy ma lx l ly lz">function TakeWater(){ <br/>  console.log("Take water💧 in a bowl🥣 ");<br/>}</span><span id="6369" class="lu lv in lq b gy ma lx l ly lz">function boilIt(nextFunction,lastFunction){ <br/>  console.log("Boil the water🔥");<br/>  // after boiling<br/>  nextFunction(lastFunction);   //nextFunction(ServeIt())<br/>}</span><span id="6f4d" class="lu lv in lq b gy ma lx l ly lz">function AddTeaPowder(nextFunction){ <br/>  console.log("Add your favourite Tea powder");<br/>  // After adding Tea powder<br/>  nextFunction();   //ServeIt()<br/>}</span><span id="4aa0" class="lu lv in lq b gy ma lx l ly lz">function serveIt(){ <br/>  console.log("Serve the Tea in a pot🫖☕️");<br/>}</span><span id="d572" class="lu lv in lq b gy ma lx l ly lz">makeTea();</span></pre><p id="04c0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有很多功能，那就像</p><p id="9ed3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">T5【第一功能(第二功能(第三功能(第四功能(第五功能……………)..)))))， </strong></p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="63b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">什么鬼……是啊，所以我们叫它<a class="ae md" href="http://callbackhell.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">回调地狱</strong> </a> <strong class="ke io">。</strong></p><p id="a3cb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了避免这种回调地狱，在<a class="ae md" href="https://medium.com/@udhaykumarbala/what-is-es6-5691a98811c0" rel="noopener"> Javascript ES6 </a>中引入了Promise。现在试试同样的茶。</p><pre class="la lb lc ld gt lp lq lr ls aw lt bi"><span id="a3e6" class="lu lv in lq b gy lw lx l ly lz">function makeTea(){<br/>   TakeWater()<br/>   .then(boilIt())<br/>   .then(AddTeaPowder())<br/>   .finally(serveIt())<br/>}</span><span id="8ca4" class="lu lv in lq b gy ma lx l ly lz">makeTea();</span></pre><p id="6e38" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以添加尽可能多的函数，我们也有参数来处理任何错误，这样更好！🤩</p><p id="92ed" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，让我们看看承诺里面有什么。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7933" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">承诺对象有:</p><ul class=""><li id="646b" class="me mf in ke b kf kg ki kj kl mg kp mh kt mi kx mj mk ml mm bi translated">承诺的现状</li><li id="46ff" class="me mf in ke b kf mn ki mo kl mp kp mq kt mr kx mj mk ml mm bi translated">承诺<strong class="ke io">值</strong>(或)承诺<strong class="ke io">结果</strong></li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ms"><img src="../Images/4ed54d49c17df7745ef57f1b371f2235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f0hDSKT5fT70g-W-"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Structure of Promise Object</figcaption></figure><p id="4841" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">承诺将处于<strong class="ke io">未决状态</strong>并且<strong class="ke io">承诺结果</strong>在发起时未定义。</p><p id="b637" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">承诺有三种不同的状态:</p><ul class=""><li id="6ff1" class="me mf in ke b kf kg ki kj kl mg kp mh kt mi kx mj mk ml mm bi translated"><strong class="ke io">待定</strong> —承诺的<strong class="ke io">初始状态</strong>。</li><li id="1693" class="me mf in ke b kf mn ki mo kl mp kp mq kt mr kx mj mk ml mm bi translated"><strong class="ke io">完成</strong>——代表<strong class="ke io">成功</strong>操作的承诺状态。</li><li id="966f" class="me mf in ke b kf mn ki mo kl mp kp mq kt mr kx mj mk ml mm bi translated"><strong class="ke io">拒绝</strong> —代表<strong class="ke io">操作失败</strong>的承诺状态。</li></ul><p id="bb35" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以通过调用以下命令来修改承诺结果和承诺状态:</p><ul class=""><li id="05a1" class="me mf in ke b kf kg ki kj kl mg kp mh kt mi kx mj mk ml mm bi translated"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">解决(值)</strong> </a> —将承诺更改为<strong class="ke io">履行状态</strong><strong class="ke io"/>将值存储在承诺结果中。</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mt"><img src="../Images/e0e0cfaf6ed854abfc42e8f42980cb7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeVRuvOeNZHE5d9-8oVd8w.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Promise Object on Fulfilment</figcaption></figure><ul class=""><li id="0ec3" class="me mf in ke b kf kg ki kj kl mg kp mh kt mi kx mj mk ml mm bi translated"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">拒绝(值)</strong> </a> —将承诺更改为<strong class="ke io">拒绝状态</strong><strong class="ke io"/>将值存储在承诺结果中。</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mt"><img src="../Images/f193d3071d49a3dca4a8cffb2cb8c377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqNc5-fqaXlg7d9JyunQHw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Promise Object on Rejection</figcaption></figure><p id="926c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">承诺一旦兑现或拒绝，就不可改变(即永远不能再改变)。</strong></p><p id="26a3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">成功或失败后，一个承诺会返回一个新的承诺，可以调用下一个函数。这被称为承诺链</p><p id="17c3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有三个选项来链接承诺中的功能，即:</p><ul class=""><li id="1012" class="me mf in ke b kf kg ki kj kl mg kp mh kt mi kx mj mk ml mm bi translated"><strong class="ke io">然后(</strong> onFulfillment()、onRejection() <strong class="ke io"> ) </strong></li><li id="da6f" class="me mf in ke b kf mn ki mo kl mp kp mq kt mr kx mj mk ml mm bi translated"><strong class="ke io">catch(</strong>on rejection()<strong class="ke io">)</strong></li><li id="be6e" class="me mf in ke b kf mn ki mo kl mp kp mq kt mr kx mj mk ml mm bi translated"><strong class="ke io">最后(</strong>功能()<strong class="ke io"> ) </strong></li></ul><h2 id="26df" class="lu lv in bd mu mv mw dn mx my mz dp na kl nb nc nd kp ne nf ng kt nh ni nj nk bi translated">然后(完成时，弹出时)</h2><p id="1213" class="pw-post-body-paragraph kc kd in ke b kf nl jo kh ki nm jr kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">有两个参数都是函数，第一个参数将在完成时执行，第二个参数将在拒绝时执行。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1d9f0582768d6b73d00b4b95d1934bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*NRJ46xllu6hjk_hA.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Flow of then()</figcaption></figure><pre class="la lb lc ld gt lp lq lr ls aw lt bi"><span id="c33d" class="lu lv in lq b gy lw lx l ly lz">makeTea().then(<br/>  handleSuccess,<br/>  handleError<br/>);</span></pre><h2 id="e1fb" class="lu lv in bd mu mv mw dn mx my mz dp na kl nb nc nd kp ne nf ng kt nh ni nj nk bi translated">捕捉(弹射时)</h2><p id="5dc9" class="pw-post-body-paragraph kc kd in ke b kf nl jo kh ki nm jr kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">你可能会问，我们在then()方法上有成功和错误处理程序，那么为什么我们需要<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" rel="noopener ugc nofollow" target="_blank"> catch() </a>方法。</p><p id="ab14" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果<strong class="ke io"> handleSuccess() </strong>抛出一个错误会怎么样呢？承诺从。那么()将被拒绝，但是这里没有任何东西来捕捉拒绝。我们需要一个只接受错误处理程序的方法。</p><p id="8c27" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">顾名思义，catch()捕捉错误&amp; bug。</p><p id="173a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出于这个原因，有些人认为上面的代码是反模式的，并建议使用下面的代码:</p><pre class="la lb lc ld gt lp lq lr ls aw lt bi"><span id="4065" class="lu lv in lq b gy lw lx l ly lz">makeTea()<br/>  .then(handleSuccess)<br/>  .catch(handleError)<br/>;</span></pre><p id="e168" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种差别很微妙，但很重要。在第一个例子中，源于<code class="fe nr ns nt lq b">save()</code>操作的错误将被捕获，但源于<code class="fe nr ns nt lq b">handleSuccess()</code>函数的错误将被接受。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/72576005d26f034c927a5912e94faeaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*EHxi_VsxNPnaipeC.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Flow of catch()</figcaption></figure><p id="9c88" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有。catch()，成功处理程序中的错误未被捕获。</p><p id="0fc3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第二个例子中，<code class="fe nr ns nt lq b">.catch()</code>将处理来自<code class="fe nr ns nt lq b">save()</code>或<code class="fe nr ns nt lq b">handleSuccess()</code>的拒绝。</p><h2 id="ea37" class="lu lv in bd mu mv mw dn mx my mz dp na kl nb nc nd kp ne nf ng kt nh ni nj nk bi translated">最后(功能)</h2><p id="d5b1" class="pw-post-body-paragraph kc kd in ke b kf nl jo kh ki nm jr kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">最后😜最后，<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally" rel="noopener ugc nofollow" target="_blank">()</a>也接受一个函数，该函数将在成功和拒绝的情况下被执行。一旦<code class="fe nr ns nt lq b">Promise</code>处理完毕，无论承诺是成功履行还是被拒绝，这都为代码的运行提供了一种方式。</p><p id="d5e8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这有助于避免在promise的<code class="fe nr ns nt lq b"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">then()</a></code>和<code class="fe nr ns nt lq b"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" rel="noopener ugc nofollow" target="_blank">catch()</a></code>处理程序中重复代码。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nu"><img src="../Images/e4d0da342ab6d1e4e868fd8d8b47fbae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKmaWBsonf7NsXXqs2ufIA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Promise control flow</figcaption></figure><p id="a683" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比如，解决和拒绝，我们有其他的方法，比如<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> all()，race()… </a></p><p id="50e7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我相信，现在你能理解这个承诺了。</p><p id="dac4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过这种方式，我们将尝试找到本系列中许多JavaScript面试问题的答案。订阅以在本系列的下一篇文章发布时获得通知。</p><pre class="la lb lc ld gt lp lq lr ls aw lt bi"><span id="807b" class="lu lv in lq b gy lw lx l ly lz">ReadBlog().then(<br/>  handleSuccess,<br/>  handleError<br/>);</span><span id="1022" class="lu lv in lq b gy ma lx l ly lz">function <!-- -->handleSuccess(){<br/>   // 50 claps👏👏👏👏👏<br/>}</span><span id="f960" class="lu lv in lq b gy ma lx l ly lz">function <!-- -->handleError(){<br/>   // 49 claps😜😜😜😜😜<br/>   // comment your feedback<br/>}</span></pre><p id="0719" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">鼓掌<strong class="ke io">👏👏👏</strong>要欣赏这篇文章，请不吝赐教💬这就去。</p><p id="70bc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> JavaScript Q &amp; A系列:</strong></p><ol class=""><li id="906f" class="me mf in ke b kf kg ki kj kl mg kp mh kt mi kx nv mk ml mm bi translated"><a class="ae md" href="https://medium.com/@udhaykumarbala/what-is-es6-5691a98811c0" rel="noopener">JavaScript ES6是什么？</a></li><li id="fcf0" class="me mf in ke b kf mn ki mo kl mp kp mq kt mr kx nv mk ml mm bi translated">什么是JavaScript Promise？</li></ol><p id="ade5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em> <a class="ae md" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ky">说白了。报名参加我们的</em> <a class="ae md" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ky">免费周报</em> </strong> </a> <em class="ky">。在我们的</em> <a class="ae md" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ky">社区不和谐</em> </strong> </a> <em class="ky">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>