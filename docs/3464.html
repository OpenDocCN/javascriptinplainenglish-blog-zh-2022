<html>
<head>
<title>How to Create Nested and Reusable Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建嵌套和可重用的表单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/indepth-guide-for-creating-nested-and-reusable-forms-a9da9d651f1?source=collection_archive---------11-----------------------#2022-08-30">https://javascript.plainenglish.io/indepth-guide-for-creating-nested-and-reusable-forms-a9da9d651f1?source=collection_archive---------11-----------------------#2022-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="59ba" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于创建嵌套和可重用表单的深入教程&amp;通过使用复合ControlValueAccessor实现完全的可靠性。</h2></div><p id="5027" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程中，您将学习如何创建和使用窗体组。我们还将了解如何通过使用复合ControlValueAccessor来实现完全的可靠性。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/29259a8ff98453e45192b60d6f7195ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJhIS-4hjdWfyipkHg2NKg.jpeg"/></div></div></figure><h2 id="bdd4" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">介绍</h2><p id="ab52" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在web应用程序中，我们可以拥有大型表单，如帐户注册表单、配置文件创建表单、信用卡表单、地址表单等。这些大型表单通常有一组重复的字段。</p><p id="9eb9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，所有注册表中通常都有地址字段。在本教程中，我们将学习如何将这样的字段包装在一个可重用的表单中，以便它们可以作为嵌套表单在任何其他表单中使用。</p><p id="de3b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程中，我们将讨论创建表单的4种方法，并了解每种方法的优缺点:</p><ol class=""><li id="dc86" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated">如何创建和使用表单组</li><li id="97c1" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">如何创建嵌套的窗体组</li><li id="57e4" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">如何使用嵌套窗体组的子组件</li><li id="c4b9" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">如何用Composite <code class="fe mw mx my mz b">ControlValueAccessor</code>创建可重用表单</li></ol><h2 id="d41e" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">如何创建和使用表单组</h2><p id="a893" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">窗体通常包含几个相关的控件。<a class="ae na" href="https://angular.io/guide/reactive-forms" rel="noopener ugc nofollow" target="_blank">反应式表单</a>提供了两种将多个相关控件组合成单一输入表单的方法:<code class="fe mw mx my mz b"><a class="ae na" href="https://angular.io/api/forms/FormGroup" rel="noopener ugc nofollow" target="_blank">FormGroup</a></code>和<code class="fe mw mx my mz b"><a class="ae na" href="https://angular.io/api/forms/FormArray" rel="noopener ugc nofollow" target="_blank">FormArray</a></code>。对于本教程，我们将重点关注<code class="fe mw mx my mz b">FormGroup</code>。</p><p id="909d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如表单控件实例使您可以控制单个输入字段一样，表单组实例跟踪一组表单控件实例(例如，表单)的表单状态。创建窗体组时，窗体组实例中的每个控件都按名称进行跟踪。</p><p id="7126" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将以Profile表单为例，它将包含姓名、电子邮件、地址行、城市、州、邮政编码和国家的输入字段。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/db1566857364c6d5c934de40cf50ebdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/0*13kVmWStmZSMumhn.png"/></div></figure><p id="45d0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相同的表单组如下所示:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="3c9c" class="lk ll in mz b gy ng nh l ni nj">// src/app/simple-form-group/simple-form-group.component.ts<br/><br/>@Component({<br/>  selector: "app-simple-form-group",<br/>  templateUrl: "simple-form-group.component.html",<br/>})<br/>export class SimpleFormGroupComponent {<br/>  profileFormGroup = new FormGroup&lt;SimpleProfileForm&gt;({<br/>    name: new FormControl("", {<br/>      validators: [Validators.required],<br/>      nonNullable: true,<br/>    }),<br/>    email: new FormControl("", {<br/>      validators: [Validators.email, Validators.required],<br/>      nonNullable: true,<br/>    }),<br/>    line1: new FormControl("", {<br/>      validators: [Validators.required],<br/>      nonNullable: true,<br/>    }),<br/>    // other address form controls<br/>  });<br/><br/>  readonly COUNTRIES = COUNTRIES;<br/>  constructor() {}<br/><br/>  get nameFC() {<br/>    return this.profileFormGroup.get("name");<br/>  }<br/>  get emailFC() {<br/>    return this.profileFormGroup.get("email");<br/>  }<br/>  get line1FC() {<br/>    return this.profileFormGroup.get("line1");<br/>  }<br/>  // other form-control getters<br/>}<br/><br/>export type SimpleProfileForm = {<br/>  name: FormControl&lt;string&gt;;<br/>  email: FormControl&lt;string&gt;;<br/>  line1: FormControl&lt;string&gt;;<br/>  line2?: FormControl&lt;string | null&gt;;<br/>  zipCode: FormControl&lt;string&gt;;<br/>  city: FormControl&lt;string&gt;;<br/>  state: FormControl&lt;string&gt;;<br/>  country: FormControl&lt;string&gt;;<br/>};</span></pre><p id="85d9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，我们还利用了在Angular 14 中引入的严格类型表单特性<a class="ae na" href="https://github.com/angular/angular/pull/43834" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="07e2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，我们简单地创建了一个所有字段都为<code class="fe mw mx my mz b"><a class="ae na" href="https://angular.io/api/forms/FormControl" rel="noopener ugc nofollow" target="_blank">FormControl</a></code>的<code class="fe mw mx my mz b">FormGroup</code>。HTML模板代码可能如下所示:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="5fbe" class="lk ll in mz b gy ng nh l ni nj">&lt;!-- src/app/simple-form-group/simple-form-group.component.html --&gt;<br/><br/>&lt;form [formGroup]="profileFormGroup"&gt;<br/>  &lt;h2&gt;Basic Information&lt;/h2&gt;<br/>  &lt;div&gt;<br/>    &lt;label for="name"&gt;Name*&lt;/label&gt;<br/>    &lt;input<br/>      type="name"<br/>      formControlName="name"<br/>      id="name"<br/>      required<br/>      [ngClass]="{<br/>        'is-invalid': nameFC?.invalid &amp;&amp; (nameFC?.touched || nameFC?.dirty)<br/>      }"<br/>    /&gt;<br/>    &lt;div class="invalid-feedback"&gt;Name is required&lt;/div&gt;<br/>  &lt;/div&gt;<br/>  &lt;!-- other basic information fields --&gt;<br/>  &lt;div&gt;<br/>    &lt;h2&gt;Address&lt;/h2&gt;<br/>    &lt;div&gt;<br/>      &lt;label for="line1"&gt;Line 1*&lt;/label&gt;<br/>      &lt;input<br/>        [id]="'line1'"<br/>        [name]="'line1'"<br/>        autocomplete="address-line1"<br/>        formControlName="line1"<br/>        required<br/>        type="text"<br/>        [ngClass]="{<br/>          'is-invalid': line1FC?.invalid &amp;&amp; (line1FC?.touched || line1FC?.dirty)<br/>        }"<br/>      /&gt;<br/>      &lt;div class="invalid-feedback"&gt;Address line 1 is required&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;!-- other address fields --&gt;<br/>  &lt;/div&gt;<br/>  &lt;button type="submit" [disabled]="profileFormGroup.invalid"&gt;<br/>    Submit form<br/>  &lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="dd9b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由<code class="fe mw mx my mz b"><a class="ae na" href="https://angular.io/api/forms/FormControlName" rel="noopener ugc nofollow" target="_blank">FormControlName</a></code>指令提供的<code class="fe mw mx my mz b">formControlName</code>输入将每个单独的输入绑定到在<code class="fe mw mx my mz b">FormGroup</code>中定义的表单控件。表单控件与其各自的元素进行通信。它们还将更改传达给表单组实例，该实例为模型值提供了真实的来源。</p><p id="ffc0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">优点</strong></p><ol class=""><li id="f972" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated">简单明了的模板和表单组</li></ol><p id="ed64" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">缺点</strong></p><ol class=""><li id="8f1c" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated">难以创建和维护复杂的表单模型</li><li id="631d" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">字段集之间缺少逻辑隔离</li></ol><h2 id="cba3" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">如何创建嵌套的窗体组</h2><p id="49dd" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">构建复杂表单时，在较小的部分中管理不同的信息区域更容易。使用嵌套的窗体组实例可以将大型窗体组分成更小、更易于管理的窗体组。</p><p id="ede0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将地址相关字段分组到一个嵌套组中:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="df3f" class="lk ll in mz b gy ng nh l ni nj">// src/app/nested-from-group/nested-from-group.component.ts<br/><br/>@Component({<br/>  selector: "app-nested-form-group",<br/>  templateUrl: "nested-form-group.component.html",<br/>})<br/>export class NestedFormGroupComponent {<br/>  profileFormGroup = new FormGroup&lt;ProfileForm&gt;({<br/>    name: new FormControl("", {<br/>      validators: [Validators.required],<br/>      nonNullable: true,<br/>    }),<br/>    email: new FormControl("", {<br/>      validators: [Validators.email, Validators.required],<br/>      nonNullable: true,<br/>    }),<br/>    address: new FormGroup&lt;AddressForm&gt;({<br/>      line1: new FormControl("", {<br/>        validators: [Validators.required],<br/>        nonNullable: true,<br/>      }),<br/>      // other address fields...<br/>    }),<br/>  });<br/>}<br/><br/>type ProfileForm = {<br/>  name: FormControl&lt;string&gt;;<br/>  email: FormControl&lt;string&gt;;<br/>  address: FormGroup&lt;AddressForm&gt;;<br/>};<br/><br/>type AddressForm = {<br/>  line1: FormControl&lt;string&gt;;<br/>  line2?: FormControl&lt;string | null&gt;;<br/>  zipCode: FormControl&lt;string&gt;;<br/>  city: FormControl&lt;string&gt;;<br/>  state: FormControl&lt;string&gt;;<br/>  country: FormControl&lt;string&gt;;<br/>};</span></pre><p id="9d49" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，现在在<code class="fe mw mx my mz b">profileForm</code>中，与地址相关的字段被分组到<code class="fe mw mx my mz b">address</code>元素中。我们还创建了一个<code class="fe mw mx my mz b">AddressForm</code>类型来获得更好的类型安全性，以及ide中更好的自动完成功能。让我们分组模板中的嵌套表单:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="38dd" class="lk ll in mz b gy ng nh l ni nj">&lt;!-- src/app/nested-from-group/nested-form-group.component.html --&gt;<br/><br/>&lt;form [formGroup]="profileFormGroup"&gt;<br/>  &lt;h2&gt;Basic Information&lt;/h2&gt;<br/>  &lt;!-- basic information fields --&gt;<br/>  &lt;!-- notice the usage of formGroupName below --&gt;<br/>  &lt;div formGroupName="address"&gt;<br/>    &lt;h2&gt;Address&lt;/h2&gt;<br/>    &lt;div&gt;<br/>      &lt;label for="line1"&gt;Line 1*&lt;/label&gt;<br/>      &lt;input<br/>        [id]="'line1'"<br/>        [name]="'line1'"<br/>        autocomplete="address-line1"<br/>        formControlName="line1"<br/>        required<br/>        type="text"<br/>        [ngClass]="{<br/>          'is-invalid': line1FC?.invalid &amp;&amp; (line1FC?.touched || line1FC?.dirty)<br/>        }"<br/>      /&gt;<br/>      &lt;div class="invalid-feedback"&gt;Address line 1 is required&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;!-- other address related fields --&gt;<br/>  &lt;/div&gt;<br/>  &lt;button type="submit" [disabled]="profileFormGroup.invalid"&gt;<br/>    Submit form<br/>  &lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="945e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们添加了<code class="fe mw mx my mz b"><a class="ae na" href="https://angular.io/api/forms/FormGroupName" rel="noopener ugc nofollow" target="_blank">formGroupName</a></code>指令来表明子窗体控件是<code class="fe mw mx my mz b">address</code>窗体组的一部分。</p><p id="ca26" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">优点</strong></p><ol class=""><li id="b8a7" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated">易于创建和维护复杂的表单模型</li><li id="d4f9" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">字段集之间存在逻辑隔离</li></ol><p id="e4bd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">缺点</strong></p><ol class=""><li id="6e17" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated">由于更多的字段和复杂的表单，模板更大</li></ol><h2 id="b733" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">如何使用嵌套窗体组的子组件</h2><p id="a1f5" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在上一节中，我们在类中实现了逻辑分离，但是我们的模板仍然很复杂。我们将创建另一个组件来处理模板复杂性。</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="9c88" class="lk ll in mz b gy ng nh l ni nj">// src/app/nested-form-group-child/address-form/address-form.component.ts<br/><br/>@Component({<br/>  selector: "app-address-form",<br/>  templateUrl: "address-form.component.html",<br/>})<br/>export class AddressFormComponent {<br/>  @Input("formGroup") addressFormGroup!: FormGroup;<br/><br/>  get line1FC() {<br/>    return this.addressFormGroup.get("line1");<br/>  }<br/>  // other form-control getters...<br/>}</span></pre><p id="aae7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们创造了<code class="fe mw mx my mz b">AddressFormComponent</code>。它有一个名为<code class="fe mw mx my mz b">formGroup</code>的输入属性，父组件可以通过它传递表单组。让我们来看看模板:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="f1e2" class="lk ll in mz b gy ng nh l ni nj">&lt;!-- src/app/nested-form-group-child/address-form/address-form.component.html --&gt;<br/><br/>&lt;div [formGroup]="addressFormGroup"&gt;<br/>  &lt;h2&gt;Address&lt;/h2&gt;<br/>  &lt;div&gt;<br/>    &lt;label for="line1"&gt;Line 1*&lt;/label&gt;<br/>    &lt;input<br/>      [id]="'line1'"<br/>      [name]="'line1'"<br/>      autocomplete="address-line1"<br/>      formControlName="line1"<br/>      required<br/>      type="text"<br/>      [ngClass]="{<br/>        'is-invalid': line1FC?.invalid &amp;&amp; (line1FC?.touched || line1FC?.dirty)<br/>      }"<br/>    /&gt;<br/>    &lt;div class="invalid-feedback"&gt;Address line 1 is required&lt;/div&gt;<br/>  &lt;/div&gt;<br/>  &lt;!-- other address fields --&gt;<br/>&lt;/div&gt;</span></pre><p id="4c68" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模板非常简单，它只有与地址相关的字段。下面是我们如何在父组件中使用它:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="39f6" class="lk ll in mz b gy ng nh l ni nj">&lt;!-- src/app/nested-form-group-child/nested-form-group-child.component.html --&gt;<br/><br/>&lt;form [formGroup]="profileFormGroup"&gt;<br/>  &lt;!-- basic fields →<br/><br/>  &lt;!-- notice the usage of child component --&gt;<br/>  &lt;app-address-form [formGroup]="addressFormGroup"&gt;&lt;/app-address-form&gt;<br/><br/>  &lt;button type="submit" [disabled]="profileFormGroup.invalid"&gt;<br/>    Submit form<br/>  &lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="0f11" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在课堂上，我们会得到如下的地址形式组:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="4cc5" class="lk ll in mz b gy ng nh l ni nj">// src/app/nested-from-group/nested-from-group.component.ts<br/><br/>@Component({<br/>  // ...<br/>})<br/>export class NestedFormGroupChildComponent {<br/>  profileFormGroup = new FormGroup&lt;ProfileForm&gt;({ /*...*/ });<br/><br/>  get addressFormGroup() {<br/>    return this.profileFormGroup.get("address") as FormGroup;<br/>  }<br/>}</span></pre><p id="bd3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">优点</strong></p><ol class=""><li id="5278" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated">更简单的模板a .使用这种方法，我们现在可以处理与<code class="fe mw mx my mz b">AddressFormComponent</code>中的地址相关的一切，这样我们的主要组件就更容易处理了。</li></ol><p id="b491" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">缺点</strong></p><ol class=""><li id="03b8" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated">不完全可重用a .如果您想将此组件用作独立的表单组件，目前还不可能。</li></ol><h2 id="0780" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">如何用Composite <code class="fe mw mx my mz b">ControlValueAccessor</code>创建可重用表单</h2><p id="7a26" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在上一节中，我们创建了一个组件，并将地址表单的模板移入其中。但是，它仍然不是完全可重复使用的。我所说的完全可重复使用是指:</p><ol class=""><li id="7c39" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated">逻辑、错误处理和地址格式创建应该是地址组件的一部分，而不是父组件的一部分。</li><li id="c8bb" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">该组件应该可以在任何表单中使用。</li><li id="6489" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">该组件应该可用于模板驱动和反应式表单。</li><li id="bfe5" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">该组件应该支持本机表单控制功能，以便父组件或消费者组件可以利用这一点，例如，如果整个地址表单无效，则显示错误。</li></ol><p id="7b12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一节中，我们将学习如何创建一个完全可重用的表单，既可以在其他表单中使用，也可以作为一个独立的表单使用。我们将要使用的技术称为“复合控制值访问器”，引用自<a class="ae na" href="https://youtu.be/CD_t3m2WMM8?t=1523" rel="noopener ugc nofollow" target="_blank"> Kara Erickson在AngularConnect 2017 </a>中的观点。</p><p id="da1d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的目标是使用类似下面的地址形式:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="7d7f" class="lk ll in mz b gy ng nh l ni nj">&lt;!-- src/app/reusable-form/reusable-form-wrapper/reusable-form-wrapper.component.html --&gt;<br/><br/>&lt;form [formGroup]="profileFormGroup"&gt;<br/>  &lt;!-- other basic information fields --&gt;<br/>  &lt;app-reusable-form formControlName="address"&gt;&lt;/app-reusable-form&gt;<br/>&lt;/form&gt;</span></pre><h2 id="0f71" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">ControlValueAccessor</h2><p id="f618" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">一个<code class="fe mw mx my mz b">ControlValueAccessor</code>充当了Angular forms API和DOM中一个本地元素之间的桥梁。通过实现<code class="fe mw mx my mz b">ControlValueAccessor</code>接口并将自己注册为<code class="fe mw mx my mz b">NG_VALUE_ACCESSOR</code>提供者，任何组件或指令都可以变成表单控件。</p><p id="60e6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其中，该接口定义了两个重要的方法— <code class="fe mw mx my mz b">writeValue</code>和<code class="fe mw mx my mz b">registerOnChange</code>。</p><p id="e5cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">formControl使用writeValue方法将值设置为本机窗体控件。formControl使用registerOnChange方法注册一个回调，该回调预计在每次更新本机窗体控件时触发。将更新后的值传递给这个回调函数是您的责任，以便更新相应的角度形状控件的值。registerOnTouched方法用于指示用户与控件进行了交互。</p><p id="e3cb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是演示交互的图表:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/bbc9f8c186a7e1bd79d166f86fe1021f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*YBYvXH4O5DGVeDjj.jpeg"/></div></figure><p id="c29f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl"> From </em> <a class="ae na" href="https://indepth.dev/posts/1055/never-again-be-confused-when-implementing-controlvalueaccessor-in-angular-forms" rel="noopener ugc nofollow" target="_blank"> <em class="nl">在角度形式中实现ControlValueAccessor时再也不会混淆——角度深度</em> </a></p><p id="ed8b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要了解更多关于<code class="fe mw mx my mz b">ControlValueAccessor</code>的信息，你可以阅读这篇<a class="ae na" href="https://indepth.dev/posts/1055/never-again-be-confused-when-implementing-controlvalueaccessor-in-angular-forms" rel="noopener ugc nofollow" target="_blank">深度指南</a>。如果你正在寻找一个实际的例子，你可以参考我之前的<a class="ae na" href="https://indepth.dev/posts/1467/how-to-use-controlvalueaccessor-to-enhance-date-input-with-automatic-conversion-and-validation" rel="noopener ugc nofollow" target="_blank">关于日期输入的文章</a>和<a class="ae na" href="https://indepth.dev/tutorials/angular/object-in-formcontrol" rel="noopener ugc nofollow" target="_blank">关于在表单控件</a>中管理对象的教程。</p><h2 id="c8cd" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">复合控件值访问器</h2><p id="f226" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在之前的文章和教程中，我们看到了<code class="fe mw mx my mz b">ControlValueAccessor</code>和一个<code class="fe mw mx my mz b">&amp;lt;input&gt;</code>的用法。但是，使用<code class="fe mw mx my mz b">ControlValueAccessor</code>的好处是，如果你愿意，你可以有更多的输入。</p><p id="f65f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们只需要处理该接口的所有4个必需的方法，不管我们如何在内部处理它，它都会正常工作。</p><h2 id="7565" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">可重复使用的表单</h2><p id="6865" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">上一节中有一点很清楚，我们希望使用相同的模板，在内部，我们将使用表单组管理字段的状态，因此我们的模板将如下所示:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="72ec" class="lk ll in mz b gy ng nh l ni nj">&lt;!-- src/app/reusable-form/reusable-form.component.html --&gt;<br/><br/>&lt;div role="group" [formGroup]="form"&gt;<br/>  &lt;div&gt;<br/>    &lt;label for="line1"&gt;Line 1*&lt;/label&gt;<br/>    &lt;input<br/>      id="line1"<br/>      name="line1"<br/>      autocomplete="address-line1"<br/>      formControlName="line1"<br/>      required<br/>      type="text"<br/>      [ngClass]="{<br/>        'is-invalid': line1FC?.invalid &amp;&amp; (line1FC?.touched || line1FC?.dirty)<br/>      }"<br/>    /&gt;<br/>    &lt;div class="invalid-feedback"&gt;Address line 1 is required&lt;/div&gt;<br/>  &lt;/div&gt;<br/>  &lt;!-- other address fields --&gt;<br/>&lt;/div&gt;</span></pre><p id="7106" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了管理地址对象，我们将创建一个类。这将在上面模板的类的后期使用:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="df93" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/address.ts<br/><br/>export class Address {<br/>  constructor(<br/>    public line1: string = "",<br/>    public zipCode: string = "",<br/>    public city: string = "",<br/>    public state: string = "",<br/>    public country: string = "",<br/>    public line2?: string | null<br/>  ) {}<br/><br/>  isValid() {<br/>    return (<br/>      this.line1 &amp;&amp; this.city &amp;&amp; this.country &amp;&amp; this.state &amp;&amp; this.zipCode<br/>    );<br/>  }<br/>}</span></pre><p id="24ee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将上面的<code class="fe mw mx my mz b">Address</code>类作为表单的值。就像<code class="fe mw mx my mz b">string</code>、<code class="fe mw mx my mz b">number</code>和<code class="fe mw mx my mz b">boolean</code>一样，我们也可以在表单控件中存储对象。你可以在关于在表单控件中管理对象的教程<a class="ae na" href="https://indepth.dev/tutorials/angular/object-in-formcontrol" rel="noopener ugc nofollow" target="_blank">中了解更多。</a></p><p id="d094" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于验证，您可以有自己的逻辑来验证地址，但现在我们将保持简单。我们将在实现验证时使用它。</p><p id="e22c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，基于之前关于<code class="fe mw mx my mz b">ControlValueAccessor</code>的文章，我们将从实现<code class="fe mw mx my mz b">ControlValueAccessor</code>接口和作为提供者的<code class="fe mw mx my mz b">NG_VALUE_ACCESSOR</code>开始:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="8fdb" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>@Component({<br/>  selector: "app-reusable-form",<br/>  templateUrl: "reusable-form.component.html",<br/>  providers: [<br/>    {<br/>      provide: NG_VALUE_ACCESSOR,<br/>      useExisting: ReusableFormComponent,<br/>      multi: true,<br/>    },<br/>  ],<br/>})<br/>export class ReusableFormComponent implements ControlValueAccessor {<br/>  form = new FormGroup&lt;AddressForm&gt;({<br/>    line1: new FormControl("", {<br/>      validators: Validators.required,<br/>      nonNullable: true,<br/>    }),<br/>    // other address fields' form-controls<br/>  });<br/><br/>  writeValue(value: Address | null): void {}<br/><br/>  registerOnChange(fn: (val: Partial&lt;Address&gt; | null) =&gt; void): void {}<br/><br/>  registerOnTouched(fn: () =&gt; void): void {}<br/><br/>  setDisabledState(disabled: boolean) {}<br/>}</span></pre><h2 id="3174" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">writeValue</h2><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="15f9" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>  writeValue(value: Address | null): void {<br/>    const address = this.createAddress(value);<br/>    this.form.patchValue(address);<br/>  }<br/><br/>  private createAddress(value: Partial&lt;Address&gt; | null) {<br/>    return new Address(<br/>      value?.line1 || "",<br/>      value?.zipCode || "",<br/>      value?.city || "",<br/>      value?.state || "",<br/>      value?.country || "",<br/>      value?.line2<br/>    );<br/>  }</span></pre><p id="8d63" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我们将首先转换进入<code class="fe mw mx my mz b">Address</code>实例的值，然后调用<code class="fe mw mx my mz b">form.patchValue</code>，它将更新所有字段，其中的值被更新。</p><h2 id="9524" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">寄存器转换</h2><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="163a" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>registerOnChange(fn: (val: Partial&lt;Address&gt; | null) =&gt; void): void {<br/>    this.form.valueChanges.subscribe((value) =&gt; {<br/>      const address = this.createAddress(value);<br/>      fn(address);<br/>    });<br/>  }</span></pre><p id="780c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用<code class="fe mw mx my mz b">valueChanges</code>可观察值来处理<code class="fe mw mx my mz b">registerOnChange</code>。<code class="fe mw mx my mz b">valueChanges</code> observable为所有子表单域发射，所以它非常适合<code class="fe mw mx my mz b">registerOnChange</code>。</p><p id="6aa5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，当我们在监听<code class="fe mw mx my mz b">valueChanges</code>时，我们将不得不重新访问并修复<code class="fe mw mx my mz b">writeValue</code>的<code class="fe mw mx my mz b">patchValue</code>，因为每次调用<code class="fe mw mx my mz b">patchValue</code>时，<code class="fe mw mx my mz b">valueChanges</code>都会触发，这是我们不希望的。</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="63e6" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>  writeValue(value: Address | null): void {<br/>    const address = this.createAddress(value);<br/>    this.form.patchValue(address, { emitEvent: false });<br/>  }</span></pre><p id="e958" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你在上面注意到的，我们将<code class="fe mw mx my mz b">emitEvent</code>设置为<code class="fe mw mx my mz b">false</code>，这样它就不会触发<code class="fe mw mx my mz b">valueChanges</code>。</p><h2 id="6572" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">registerOnTouched</h2><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="acc3" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>onTouched: any;<br/><br/>registerOnTouched(fn: () =&gt; void): void {<br/>    this.onTouched = fn;<br/>  }</span></pre><p id="e2e5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望窗体被触摸，任何时候任何子窗体控件被触摸。因此，我们将在模板中调用<code class="fe mw mx my mz b">onTouched</code>,以及所有子表单控件:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="48df" class="lk ll in mz b gy ng nh l ni nj">&lt;!-- src/app/reusable-form/reusable-form.component.html --&gt;<br/><br/>&lt;div role="group" [formGroup]="form"&gt;<br/>  &lt;div&gt;<br/>    &lt;label for="line1"&gt;Line 1*&lt;/label&gt;<br/>    &lt;!-- removed other attributes/properties for brevity --&gt;<br/>    &lt;input<br/>      (blur)="onTouched()"<br/>    /&gt;<br/>  &lt;/div&gt;<br/>  &lt;!-- other address fields --&gt;<br/>&lt;/div&gt;</span></pre><h2 id="b29e" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">setDisabledState</h2><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="e4c7" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>setDisabledState(disabled: boolean) {<br/>    disabled ? this.form.disable() : this.form.enable();<br/>  }</span></pre><h2 id="064a" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">确认</h2><p id="83df" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">为了处理验证，我们将首先添加一个提供者，并实现<code class="fe mw mx my mz b">Validator</code>接口:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="3fc1" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>@Component({<br/>  // ...<br/>  providers: [<br/>    // ...<br/>    {<br/>      provide: NG_VALIDATORS,<br/>      useExisting: ReusableFormComponent,<br/>      multi: true,<br/>    },<br/>  ],<br/>})<br/>export class ReusableFormComponent implements ControlValueAccessor, Validator {<br/><br/>  // ...<br/>  validate(control: AbstractControl&lt;Address&gt;): ValidationErrors | null {}<br/>}</span></pre><h2 id="2442" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">使生效</h2><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="7c6e" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>validate(control: AbstractControl&lt;Address&gt;): ValidationErrors | null {<br/>    const value = control.value;<br/>    return value &amp;&amp; value.isValid() ? null : { address: true };<br/>  }</span></pre><p id="c647" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们将使用<code class="fe mw mx my mz b">Address</code>类的<code class="fe mw mx my mz b">isValid</code>方法，并基于此返回错误。</p><h2 id="0cf5" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">多个实例</h2><p id="d8eb" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">虽然我们的表单现在已经可以使用了，但是还有一个问题。如果在同一个UI中使用这个组件，那么表单控件可能无法正常工作，因为它们都有相同的<code class="fe mw mx my mz b">name</code>和<code class="fe mw mx my mz b">id</code>属性。并且，这个组件本身没有<code class="fe mw mx my mz b">id</code>，可以帮助测试。</p><p id="d07d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，首先让我们引入一个名为<code class="fe mw mx my mz b">id</code>的<code class="fe mw mx my mz b"><a class="ae na" href="https://angular.io/api/core/Directive#host" rel="noopener ugc nofollow" target="_blank">host</a></code>属性:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="ff53" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>@Component({<br/>  // ...<br/>  host: {<br/>    "[id]": "id",<br/>  },<br/>})<br/>export class ReusableFormComponent {<br/>  id = `address-input`;<br/>}</span></pre><p id="3c4c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们将添加一个静态计数器，它将随着该组件的每个实例而递增:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="7339" class="lk ll in mz b gy ng nh l ni nj">// src/app/reusable-form/reusable-form.component.ts<br/><br/>@Component({<br/>  // ...<br/>})<br/>export class ReusableFormComponent {<br/><br/>  static nextId = 0;<br/>  id = `address-input-${ReusableFormComponent.nextId++}`;<br/><br/>}</span></pre><p id="d3de" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们将使用这个<code class="fe mw mx my mz b">id</code>和所有的<code class="fe mw mx my mz b">input</code>s’<code class="fe mw mx my mz b">id</code>和<code class="fe mw mx my mz b">name</code>属性。并且还在它们的<code class="fe mw mx my mz b">&amp;lt;label&gt;</code>s’<code class="fe mw mx my mz b">for</code>属性中:</p><pre class="kz la lb lc gt nc mz nd ne aw nf bi"><span id="0df8" class="lk ll in mz b gy ng nh l ni nj">&lt;!-- src/app/reusable-form/reusable-form.component.html --&gt;<br/><br/>&lt;div role="group" [formGroup]="form"&gt;<br/>  &lt;div&gt;<br/>    &lt;label [htmlFor]="id + '-line1'"&gt;Line 1*&lt;/label&gt;<br/>    &lt;!-- other attributes removed for brevity --&gt;<br/>    &lt;input<br/>      [id]="id + '-line1'"<br/>      [name]="id + '-line1'"<br/>    /&gt;<br/>  &lt;/div&gt;<br/>  &lt;!-- other address fields --&gt;<br/>&lt;/div&gt;</span></pre><p id="8be9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，我们完全可重复使用的地址表单就准备好了。</p><h2 id="9455" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">结论</h2><p id="cb63" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在本教程中，我们学习了如何创建和使用表单组。然后我们学习了如何创建嵌套表单组，以及如何将它们用于子组件。对于每一种方法，我们也了解了它们的优缺点。</p><p id="e841" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在最后但非常重要的部分，我们学习了如何用composite <code class="fe mw mx my mz b">ControlValueAccessor</code>创建一个完全可重用的表单组件。</p><p id="8874" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经把代码上传到了<a class="ae na" href="https://github.com/shhdharmen/nested-reusable-form" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，你也可以在<a class="ae na" href="https://stackblitz.com/github/shhdharmen/nested-reusable-form" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>上看看。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="b642" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">最初发布于</em> <a class="ae na" href="https://indepth.dev/tutorials/angular/indepth-guide-for-nested-and-reusable-form" rel="noopener ugc nofollow" target="_blank"> <em class="nl">创建嵌套和可重用表单的深度指南—角度教程|深度开发</em> </a></p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="5cbe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">更多内容看</em> <a class="ae na" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nl">说白了。报名参加我们的</em> <a class="ae na" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nl">免费周报</em> </strong> </a> <em class="nl">。关注我们关于</em> <a class="ae na" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nl">推特</em> </strong> </a>，<a class="ae na" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nl">LinkedIn</em></strong></a><em class="nl">，</em><a class="ae na" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nl">YouTube</em></strong></a><em class="nl">，以及</em> <a class="ae na" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nl">不和</em> </strong> </a> <em class="nl">。</em></strong></a></p></div></div>    
</body>
</html>