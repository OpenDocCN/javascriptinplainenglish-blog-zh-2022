<html>
<head>
<title>The Simplest Case for Unit Tests: Pure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试最简单的例子:纯函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-simplest-case-for-unit-tests-pure-functions-d80a583dbe0f?source=collection_archive---------15-----------------------#2022-08-04">https://javascript.plainenglish.io/the-simplest-case-for-unit-tests-pure-functions-d80a583dbe0f?source=collection_archive---------15-----------------------#2022-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c1b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">纯函数是单元测试中最简单的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ebc5b3cb35400f42f83fcf4c8c1c516c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v8jj1dJC593pCkWa"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Illustration by the author</figcaption></figure><p id="c9cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整个行业的开发团队都在使用单元测试来维护他们代码的质量。然而，似乎许多面向初学者的材料并没有真正涵盖单元测试。这很不幸——添加单元测试是我喜欢交给团队新同事的一项完美的入职任务。通过习惯单元测试，他们可以开始熟悉代码库并取得显著的进步，同时不会面临与构建面向客户的更改相关的风险或压力。</p><h1 id="77d7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么是单元测试</h1><p id="69d0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">单元测试是根据明确的预期来验证代码单元的小段代码。您编写它们是为了给自己一种自动检查代码的方法。因此，当您继续处理代码库时，可以快速检查事情是否按预期运行。</p><p id="6fa0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在现实世界的JavaScript项目中，人们通常使用这些开源框架之一进行测试:</p><ul class=""><li id="2155" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">茉莉</li><li id="321f" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">玩笑</li><li id="87e0" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">摩卡</li></ul><p id="be13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，为了简单起见，我将使用受这些框架启发的伪代码。</p><h1 id="55ef" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么是纯函数？</h1><p id="8efb" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">纯函数是其结果仅取决于所提供的参数的函数。它们不保持内部状态，也不读取除参数之外的外部值。它们在数学意义上与函数相同。例如:</p><ul class=""><li id="c6b6" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated"><code class="fe nc nd ne nf b">sin(x)</code>，</li><li id="76f1" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><code class="fe nc nd ne nf b">cos(x)</code>，</li><li id="7b98" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><code class="fe nc nd ne nf b">f(x) = 4 * x + 5</code>。</li></ul><h1 id="3f2a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数据操作</h1><p id="bfda" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们定义一个问候函数:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="4a67" class="nk ls iq nf b gy nl nm l nn no">function greet(name, surname) {<br/>  return `Hello ${name} ${surname}!`;<br/>}</span></pre><p id="6957" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个纯函数:每次当我运行<code class="fe nc nd ne nf b">greet('Marcin', 'Wosinek')</code>时，它都会返回‘Hello Marcin Wosinek！’。</p><h1 id="f35b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">测试一下！</h1><p id="5e00" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如何测试这个功能？</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="90a4" class="nk ls iq nf b gy nl nm l nn no">expect(greet('Lorem', 'Ipsum')).toEqual('Hello Lorem Ipsum!');</span></pre><p id="90a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">测试框架将上面的代码变成类似于:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="b253" class="nk ls iq nf b gy nl nm l nn no">if(greet(‘Lorem’, ‘Ipsum’) !== ‘Hello Lorem Ipsum!’) {<br/>  throw new Error(“greet(‘Lorem’, ‘Ipsum’) doesn’t equal ‘Hello Lorem Ipsum!’”)<br/>}</span></pre><p id="0dc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并向您显示他们运行的所有检查的结果报告。</p><h1 id="e919" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">边缘案例</h1><p id="c182" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">编写单元测试让你思考边缘案例。例如，如果我们的函数只有一个参数被调用，那么会发生什么<em class="np">？称呼对方的名字听起来是最合理的事情，但是当前的实现做了不同的事情:</em></p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="d7e9" class="nk ls iq nf b gy nl nm l nn no">greet(‘Marcin’); // returns “Hello Marcin undefined!”</span></pre><p id="637b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想做仅支持名字的调用，我们可以添加下面的测试用例:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="6410" class="nk ls iq nf b gy nl nm l nn no">expect(greet(‘Lorem’)).toEqual(‘Hello Lorem!’);</span></pre><p id="b6c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将需要改进我们的实施:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="c757" class="nk ls iq nf b gy nl nm l nn no">function greet(name, surname) {<br/>  if (surname) {<br/>    return `Hello ${name} ${surname}!`;<br/>  } else {<br/>    return `Hello ${name}!`;<br/>  }<br/>}</span></pre><p id="29ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，我们可以继续添加其他边缘案例。例如，应该发生什么:</p><ul class=""><li id="aeb4" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">当我们问候只有姓氏的人时</li><li id="31fb" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">没有名字或姓氏</li><li id="decc" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">当用三个参数调用该方法时——用中间名或第二个姓</li></ul><p id="d07d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过考虑这些情况并为它们添加测试，我们可以构建更具弹性的代码。</p><h1 id="56e3" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">折扣计算</h1><p id="0d5d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们用钱来尝试一些操作。假设我们正在构建一个商店系统，我们想要一个对价格应用折扣的方法。一个快速而肮脏的解决方法是:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="01f7" class="nk ls iq nf b gy nl nm l nn no">function calculateDiscountedPrice(originalPrice, discount) {<br/>  return originalPrice - originalPrice * discount;<br/>};</span></pre><h1 id="14c8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">测试一下！</h1><p id="4a41" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们考虑几个可以测试的案例:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="ca67" class="nk ls iq nf b gy nl nm l nn no">// case 1<br/>expect(calculateDiscountedPrice(10, 1/4)).toBe(7.5);<br/><br/>// case 2<br/>calculateDiscountedPrice(0.9, 2/3).toBe(0.3)<br/><br/>// case 3<br/>expect(calculateDiscountedPrice(10, 1/3)).toBe(6.67);<br/>expect(calculateDiscountedPrice(10, 2/3)).toBe(3.33);</span></pre><p id="f6cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些例子看起来有点重复吗？实际上，它们是非常不同的，只有<em class="np">案例1 </em>在我们当前的实现中会像预期的那样工作。</p><h1 id="88c9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">边缘案例</h1><p id="653c" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在我们的边缘案例中会发生什么？在<em class="np">案例2 </em>中，我们遇到了由数字在JavaScript中的存储方式引起的舍入误差。JavaScript只有<em class="np">浮点</em>数字，所以每一个舍入小数在内存中用一个近似值表示，这个近似值会引入一个微小的舍入误差。当您对数字进行运算时，这些错误会累积起来，最终得到的结果会与您的预期略有出入。在我们的案例中:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="1384" class="nk ls iq nf b gy nl nm l nn no">calculateDiscountedPrice(0.9, 2/3)<br/>0.30000000000000004</span></pre><p id="7b43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和<code class="fe nc nd ne nf b">0.3</code>很接近，但不是同一个值。对于我们处理货币的应用程序来说，以一种清除这些错误的方式实现货币操作是有意义的。</p><p id="8dfe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="np">情况3 </em>测试将因缺少舍入而失败——函数返回<code class="fe nc nd ne nf b">6.666666666666667</code>和<code class="fe nc nd ne nf b">3.333333333333334</code>。在大多数系统中，我们只关心精确到小数点后第二位的值——精确到分。</p><p id="a9de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两个问题都可以通过相同的实现调整来解决:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="3349" class="nk ls iq nf b gy nl nm l nn no">function calculateDiscountedPrice(originalPrice, discount) {<br/>  const newPrice = originalPrice - originalPrice * discount;<br/>  return Math.round(newPrice * 100) / 100<br/>};</span></pre><p id="0261" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它总是按预期工作吗？不一定——你可以查看这个<a class="ae nq" href="https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary" rel="noopener ugc nofollow" target="_blank">堆栈溢出线程</a>来了解边缘情况。如果可能的话，您可能希望使用一些第三方库来为您进行舍入。</p><h1 id="bdc6" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数学运算</h1><p id="f924" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们考虑一些纯数学运算:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="3d90" class="nk ls iq nf b gy nl nm l nn no">function power(base, exponent) {<br/>  return base ** exponent;<br/>};</span></pre><p id="a5b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有什么我们可以测试的有趣的东西吗？</p><h1 id="edbd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">测试一下！</h1><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="aa8e" class="nk ls iq nf b gy nl nm l nn no">// case 1<br/>expect(power(2, 2)).toBe(4);<br/>expect(power(2, 10)).toBe(1024);<br/>expect(power(2, 0)).toBe(1);<br/><br/>// case 2<br/>expect(power(0, 0)).toBe(NaN);</span></pre><p id="a7e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="np">案例1 </em>按预期工作，而<em class="np">案例2 </em>失败:JS返回1，这和我们在数学里学的不一样。</p><h1 id="8c6e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">边缘案例</h1><p id="1f22" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们还能在这里测试什么？我们可以扩展我们的测试，覆盖不正确参数的情况，例如:</p><ul class=""><li id="f0b1" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated"><code class="fe nc nd ne nf b">power()</code>，</li><li id="6acf" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><code class="fe nc nd ne nf b">power(‘lorem’, ‘ipsum’)</code>，</li><li id="9d16" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><code class="fe nc nd ne nf b">power({}, 0)</code>。</li></ul><p id="1fad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么要测试那些案例？因为它们可能发生在应用程序中，你的程序会对它们做些什么。如果您花一些时间思考在您的应用程序环境中什么是最有意义的，您会更好:</p><ul class=""><li id="85e8" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">返回<code class="fe nc nd ne nf b">NaN</code>，</li><li id="6399" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">抛出错误，或者</li><li id="11db" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">默认为某个合理的值，例如<code class="fe nc nd ne nf b">1</code></li></ul><p id="4558" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论您做出什么决定，您都可以在单元测试中将其明确化。</p><h1 id="1f7b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">想了解更多？</h1><p id="69b4" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我在博客上写了更多关于单元测试的内容:</p><ul class=""><li id="cd66" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated"><a class="ae nq" href="https://how-to.dev/how-to-write-unit-tests" rel="noopener ugc nofollow" target="_blank">如何编写单元测试</a>，</li><li id="780d" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">单元测试有什么意义？</li></ul><h1 id="3ef1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">摘要</h1><p id="67a0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">纯函数是单元测试中最简单的。尽管如此，写它们会让你有正确的心态去发现边缘案例，否则就不会被正确地考虑。对于初学编程的人来说，这是一项有价值的练习和技能:它教会你以一种非常精确的、类似机器的方式思考；提高单元测试覆盖率对许多项目来说是一个受欢迎的贡献。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="42f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="np">最初发布于</em><a class="ae nq" href="https://how-to.dev/the-simplest-case-for-unit-tests-pure-functions" rel="noopener ugc nofollow" target="_blank"><em class="np">https://how-to . dev</em></a><em class="np">。</em></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="f9cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="np">更多内容看</em> <a class="ae nq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="np">说白了。报名参加我们的</em> <a class="ae nq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="np">免费周报</em> </strong> </a> <em class="np">。关注我们关于</em> <a class="ae nq" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="np">推特</em> </strong> </a>，<a class="ae nq" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="np">领英</em> </strong> </a>，<strong class="kx ir"> <em class="np"> </em> </strong> <em class="np">和</em> <a class="ae nq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="np">不和</em> </strong> </a> <em class="np">。</em></strong></a></p></div></div>    
</body>
</html>