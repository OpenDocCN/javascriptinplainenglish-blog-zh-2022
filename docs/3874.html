<html>
<head>
<title>A Brief Guide on Worker Threads in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中工作线程的简要指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-brief-guide-on-worker-threads-in-node-js-80bd1e7846cb?source=collection_archive---------1-----------------------#2022-10-05">https://javascript.plainenglish.io/a-brief-guide-on-worker-threads-in-node-js-80bd1e7846cb?source=collection_archive---------1-----------------------#2022-10-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2625" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在Node.js中使用工作线程</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ca77b52465d5ced7ed93255f7efb6319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkGnM89zMCXD-l5_0ya_Pw.png"/></div></div></figure><p id="9222" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Node.js在处理数据密集型I/O调用时非常有效，但是CPU密集型任务(图像/视频处理或解析大型JSON)可能会阻塞单线程实例，从而影响整体响应时间。在这种情况下，多线程应用将具有明显的优势，因为当一个线程忙于处理繁重的计算任务时，其他线程可以简单地处理其余的请求。一个潜在的解决方案是使用子流程，但是创建一个新的流程实例在时间和内存方面都很昂贵。这就是工作线程出现的原因<strong class="kq io">。</strong></p><p id="ac74" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">核心思想还是一样的，<strong class="kq io">并行执行JavaScript</strong>。工作线程也称为工作线程是同一个进程的一部分。这些线程中的每一个都有自己的JS引擎实例、自己的Node.js实例和自己的事件循环，这样它就可以独立工作，而不会干扰其他线程。由于它们是同一个进程的一部分，它们可以共享分配给那个特定进程的内存，这就是为什么它们比子进程更有效。</p><p id="be6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意，这不是JavaScript语言的一部分。它是Node.js中的一个实现，利用了JavaScript workers。好的，让我们看看如何实现这个目标。</p><p id="5293" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我在Youtube上也有一些关于这篇文章的视频，一定要看看。  </p><h2 id="2db7" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">基本设置</h2><p id="6807" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">在空文件夹中，使用<code class="fe mk ml mm mn b">npm init -y</code>创建Node.js应用程序。另外，通过输入<code class="fe mk ml mm mn b">npm i express</code>来安装express。现在创建一个服务器文件(<strong class="kq io"> app.js </strong>)，并在文件中复制以下代码:</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="a34a" class="lm ln in mn b gy ms mt l mu mv">const app = require("express")()</span><span id="1cb8" class="lm ln in mn b gy mw mt l mu mv">app.get("/light", (req, res) =&gt; {<br/>   res.send(`Request successful!\n`);<br/>})</span><span id="1e97" class="lm ln in mn b gy mw mt l mu mv">app.get("/heavy", (req, res) =&gt; {<br/>   let counter = 0;<br/>   while (counter &lt; 900000000) {<br/>      counter++;<br/>   }<br/>   res.send(`${counter} iterations completed!`);<br/>})</span><span id="3ad4" class="lm ln in mn b gy mw mt l mu mv">app.listen(3000, () <em class="ll">=&gt;</em> console.log("Listening to port 3000"));</span></pre><p id="4ec7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您运行这个Express应用程序，尝试向<code class="fe mk ml mm mn b">/heavy</code>端点发出请求，然后立即向<code class="fe mk ml mm mn b">/light</code>端点发出请求，您将看到<code class="fe mk ml mm mn b">/heavy</code>端点阻塞了事件循环。因此，当<code class="fe mk ml mm mn b">/heavy </code>端点计算请求并获得响应时，<code class="fe mk ml mm mn b">/light</code>请求必须在那里等待。这肯定是一个问题，我们将使用工作线程来解决这个问题。</p><p id="b347" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从Node.js中的<code class="fe mk ml mm mn b">worker_threads</code>模块导入<code class="fe mk ml mm mn b">Worker</code>类，在<code class="fe mk ml mm mn b">/heavy</code>端点中，使用<code class="fe mk ml mm mn b">Worker</code>类创建一个worker。当创建一个实例时，您可以向该类传递两个参数。</p><ol class=""><li id="288f" class="mx my in kq b kr ks ku kv kx mz lb na lf nb lj nc nd ne nf bi translated">工人文件的URL(<strong class="kq io">worker . js</strong>)。这个文件现在将拥有执行繁重计算的代码。</li><li id="3772" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated">一个选项对象(我们将在后面讨论)</li></ol><p id="60af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将计算结果复制到worker文件中。现在你的代码应该是这样的。</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="663a" class="lm ln in mn b gy ms mt l mu mv">//app.js</span><span id="bc7a" class="lm ln in mn b gy mw mt l mu mv"><strong class="mn io">const {Worker} = require(”worker_threads”)</strong></span><span id="fdfe" class="lm ln in mn b gy mw mt l mu mv">...</span><span id="c348" class="lm ln in mn b gy mw mt l mu mv">app.get("/heavy", (req, res) =&gt; {<br/>   <strong class="mn io">const worker = new Worker("./worker.js")</strong><br/>})</span><span id="c7b5" class="lm ln in mn b gy mw mt l mu mv">...</span></pre><p id="11b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">工人文件将如下所示:</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="bb05" class="lm ln in mn b gy ms mt l mu mv">//.worker.js</span><span id="1985" class="lm ln in mn b gy mw mt l mu mv">let counter = 0;<br/>while (counter &lt; 900000000) {<br/>   counter++;<br/>}</span></pre><p id="5679" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，无论何时调用<code class="fe mk ml mm mn b">/heavy</code>端点，我们都会创建一个新的worker，它将单独进行计算。一旦计算完成，工作线程就使用可以从<code class="fe mk ml mm mn b">worker_threads</code>模块中获得的<code class="fe mk ml mm mn b">parentPort.postMessage</code>方法将响应发送回主线程。</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="5197" class="lm ln in mn b gy ms mt l mu mv">//worker.js <br/><strong class="mn io">const {parentPort} = require("worker_threads")</strong></span><span id="b6db" class="lm ln in mn b gy mw mt l mu mv">let counter = 0;<br/>while (counter &lt; 900000000) {<br/>   counter++;<br/>}<br/><strong class="mn io">parentPort.postMessage(`${counter} iterations completed!)</strong></span></pre><p id="c6ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">来自工人的任何消息都需要在主线程中捕获。我们在<code class="fe mk ml mm mn b">/heavy</code>端点中创建的worker实例是Node.js中的<code class="fe mk ml mm mn b">EventEmitter</code>类的扩展。这意味着它可以发送或侦听事件，而我们将侦听<code class="fe mk ml mm mn b">message</code>事件。</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="1bb0" class="lm ln in mn b gy ms mt l mu mv">//app.js</span><span id="3b0b" class="lm ln in mn b gy mw mt l mu mv">app.get("/heavy", (req, res) =&gt; {<br/>   const worker = new Worker("./worker.js");<!-- -->   <br/>   <strong class="mn io">worker.on("message", data =&gt; {<br/>      res.send(data)<br/>   })</strong><br/>})</span></pre><p id="5554" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在应该可以了。如果您重启服务器并尝试点击<code class="fe mk ml mm mn b">/heavy</code>端点，然后点击<code class="fe mk ml mm mn b">/light</code>端点，这一次它将按预期工作。<code class="fe mk ml mm mn b">/heavy</code>端点计算现在被转移到一个单独的工作线程，这使得事件循环对其他请求保持空闲。</p><h2 id="dd20" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">选项参数</h2><p id="6acd" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">在创建工作者时，您还可以将一组配置传递给工作者。</p><ul class=""><li id="7def" class="mx my in kq b kr ks ku kv kx mz lb na lf nb lj nl nd ne nf bi translated"><strong class="kq io"> argv </strong> —允许您将自定义参数追加到原始process.argv对象</li><li id="8606" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nl nd ne nf bi translated"><strong class="kq io"> env </strong> —允许您添加特定于线程的环境变量。这些变量被克隆，因此父线程和工作线程将拥有这些变量的单独副本。</li><li id="2e13" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nl nd ne nf bi translated"><strong class="kq io"> eval — </strong>允许您将字符串作为JavaScript表达式进行计算。</li><li id="8024" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nl nd ne nf bi translated"><strong class="kq io"> resourceLimits — </strong>为工作进程设置资源限制，以便一旦工作进程达到该限制，它将自动终止。</li><li id="5606" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nl nd ne nf bi translated"><strong class="kq io"> workerData — </strong>克隆并传递给员工的数据。</li></ul><p id="a916" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以从官方<a class="ae lk" href="https://nodejs.org/api/worker_threads.html#new-workerfilename-options" rel="noopener ugc nofollow" target="_blank">文档</a>中查看其余选项。</p><h2 id="7044" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">使用工人的另一种方式</h2><p id="aa1f" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">我们可以使用同一个(app.js)文件来分离我们的主线程和工作线程功能，而不是为我们的工作代码创建一个单独的文件。有一个名为<code class="fe mk ml mm mn b">isMainThread</code>的属性，它告诉你代码是在工作线程还是父线程中运行。</p><p id="e6de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果它在主线程中，我们将设置我们的Express服务器和端点。但是当我们发出繁重的请求时，我们会产生一个新的线程并卸载繁重的操作。将这些CPU密集型操作卸载到worker才有意义，因为API调用等I/O操作已经由本机async Node.js APIs进行了优化处理。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dbd8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以现在每次我们创建一个新的worker，它都会重新加载这个app.js文件，并在worker线程内部运行它。一旦计算完成，我们就像前面一样使用<code class="fe mk ml mm mn b">postMessage</code>方法发送回响应。</p><p id="3b80" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就我个人而言，我并不喜欢这种方法，因为我喜欢把事情分开，我总是试图减少主服务器文件中的混乱。</p><h2 id="5354" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">其他员工事件</h2><p id="2f25" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">现在，worker实例有几个它可以监听的其他事件。</p><ul class=""><li id="34ad" class="mx my in kq b kr ks ku kv kx mz lb na lf nb lj nl nd ne nf bi translated"><strong class="kq io">错误</strong> —如果工作线程抛出未捕获的异常，则发出该错误。</li><li id="1cd8" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nl nd ne nf bi translated"><strong class="kq io">退出</strong> —一旦工人停止，发出退出信号。它也是任何<code class="fe mk ml mm mn b">Worker</code>实例发出的最终事件。</li><li id="05c8" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nl nd ne nf bi translated"><strong class="kq io">在线</strong> —当工作线程开始执行JavaScript代码时发出。</li></ul><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="65a5" class="lm ln in mn b gy ms mt l mu mv">worker.on("error", err =&gt; { throw err })<br/>worker.on("exit", () =&gt; console.log("Thread exiting"))<br/>worker.on("online", () =&gt; console.log("I am online"))<br/>worker.on("message", data =&gt; res.send(data))</span></pre><h2 id="3744" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">线程间的通信</h2><p id="91bf" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">子进程和工作线程之间的一个核心区别是工作线程可以共享内存，因为它们本质上是同一个进程的一部分。谈到线程通信，有两个主要的实体。一个<code class="fe mk ml mm mn b">MessageChannel</code>和<code class="fe mk ml mm mn b">MessagePorts</code>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/4ba7fb235a24d9bda481be9332d4ad8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtfsJUhDqWxkhwTnUR2HuA.png"/></div></div></figure><p id="f65f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们只是使用了<code class="fe mk ml mm mn b">parentPort</code>实例向工人发回一条消息。当工人使用<code class="fe mk ml mm mn b">worker.postMessage</code>发送消息时，默认情况下，它在幕后使用<code class="fe mk ml mm mn b">MessagePort</code>类。工作线程和父线程都是<code class="fe mk ml mm mn b">MessagePort</code>的实例。</p><p id="2cd8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从<code class="fe mk ml mm mn b">worker_threads</code>模块导入<code class="fe mk ml mm mn b">MessageChannel</code>类。这个类本质上没有方法。当我们实例化这个类时，它返回一个具有两个属性的对象，<code class="fe mk ml mm mn b">port1</code>和<code class="fe mk ml mm mn b">port2</code>。这两个端口是<code class="fe mk ml mm mn b">MessagePort</code>类的实例。现在，我们将使用其中一个端口发送消息，另一个端口将侦听此消息。</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="90e9" class="lm ln in mn b gy ms mt l mu mv">const { MessageChannel } = require("worker_threads")<br/>const { port1, port2 } = new MessageChannel()</span><span id="859b" class="lm ln in mn b gy mw mt l mu mv">port1.on("message", msg =&gt; console.log(`Port 2 sent me: ${msg}`))</span><span id="a743" class="lm ln in mn b gy mw mt l mu mv">port2.postMessage("hello")</span></pre><p id="81c7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我运行这个，您会看到控制台上打印的消息。还有一个<code class="fe mk ml mm mn b">close</code>事件，当通道的任何一端断开连接时就会触发该事件。这些端口不会自动关闭。您可以使用<code class="fe mk ml mm mn b">close</code>方法关闭端口。</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="7eac" class="lm ln in mn b gy ms mt l mu mv">port1.on("message", msg =&gt; console.log(`Port 2 sent me: ${msg}`))<br/>port1.on('close', () =&gt; console.log('Channel closed!'));</span><span id="91b3" class="lm ln in mn b gy mw mt l mu mv">port2.postMessage("hello")<br/>port2.close()</span></pre><p id="32bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mk ml mm mn b">postMessage</code>方法有一个额外的参数，即<strong class="kq io">传送列表</strong>。这个转移名单到底是什么，我们为什么需要这个？让我解释一下。</p><p id="f853" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在在<code class="fe mk ml mm mn b">postMessage</code>中发送的值是一个简单的字符串。这也可能是一个具有深层嵌套结构的非常复杂的对象。默认情况下，我们发送的数据正在被克隆。所以发送者和接收者将有两个不同的副本。这种克隆是使用结构化克隆算法完成的，该算法是一种递归算法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/fd917469571d4bc052fce373b303a7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCXy5zkLiuUbTYcxRicDuw.png"/></div></div></figure><p id="6ed6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，如果你有一个深度嵌套的对象作为消息发送，克隆它将花费大量的时间和计算能力，这是不理想的。</p><p id="dedc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是<strong class="kq io">转移列表</strong>出现的原因。当您使用传输列表时，您不是在克隆数据。基本上就是将数据从一个线程转移到另一个线程。当你这样做时，你将失去对发送者端数据的访问，因为它实际上是把数据交给了接收者。</p><p id="6648" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在转移列表中传递3样东西。<br/>-<code class="fe mk ml mm mn b">MessagePort</code>-<br/>-<code class="fe mk ml mm mn b">ArrayBuffer</code>-<br/>-<code class="fe mk ml mm mn b">FileHandle</code></p><h2 id="37df" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">传输列表中的消息端口</h2><p id="8423" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">您想要转移消息端口的原因是，这样您就可以通过在不同线程之间传递端口来重用同一个消息通道。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/93c998c2a78fa47ed21ced6844877547.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/1*j9NkhraIsDbUzaIlh2xnHg.gif"/></div></figure><p id="bbb7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们在主线程中有一个通道，有两个端口。现在，当应用程序启动时，我们创建一个工人。我们的目标是将我们的一个端口转移到worker，以便这个worker现在可以与父端口通信。</p><blockquote class="nr"><p id="dd4f" class="ns nt in bd nu nv nw nx ny nz oa lj dk translated">它可以通过使用<code class="fe mk ml mm mn b">parentPort</code>直接与父线程通信，但我只想向您展示如何使用<code class="fe mk ml mm mn b">postMessage</code>转移端口。</p></blockquote><p id="0776" class="pw-post-body-paragraph ko kp in kq b kr ob jo kt ku oc jr kw kx od kz la lb oe ld le lf of lh li lj ig bi translated">现在简单用<code class="fe mk ml mm mn b">worker.postMessage(port2, [port2])</code>。第一个参数是您希望与worker共享的值，在本例中是端口。第二个参数是转移列表。因为我们已经将<code class="fe mk ml mm mn b">port2</code>添加到了转移列表中，所以它将被转移到worker中，一旦它被转移，你将无法在父线程中使用它。所以本质上我们现在已经把<code class="fe mk ml mm mn b">port2</code>从主线程转移到了工作线程。</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="155f" class="lm ln in mn b gy ms mt l mu mv">//app.js</span><span id="2366" class="lm ln in mn b gy mw mt l mu mv">const app = require("express")()<br/>const { Worker } = require("worker_threads")<br/>const { MessageChannel } = require("worker_threads")<br/>const { port1, port2 } = new MessageChannel()</span><span id="50bf" class="lm ln in mn b gy mw mt l mu mv">const worker = new Worker("./worker.js") <strong class="mn io">//Step 1</strong><br/>port1.on("message", msg =&gt; console.log(`Calculated complex iteration: ${msg}`)) <strong class="mn io">//Step 4</strong></span><span id="262d" class="lm ln in mn b gy mw mt l mu mv">worker.postMessage(port2, [port2])  <strong class="mn io">//Step 2</strong></span></pre><p id="34ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">工人文件将如下所示:</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="35ba" class="lm ln in mn b gy ms mt l mu mv">//worker.js<br/>const { parentPort, workerData } = require("worker_threads")</span><span id="eb7b" class="lm ln in mn b gy mw mt l mu mv">const complexCalc = () =&gt; {<br/>    let counter = 0;<br/>    while (counter &lt; 900000000) {<br/>        counter++;<br/>    }<br/>    return counter;<br/>}</span><span id="d7bf" class="lm ln in mn b gy mw mt l mu mv">parentPort.on("message", msg =&gt; {<br/>    //msg is the port that we're sending from the main thread<br/>    msg.postMessage(complexCalc())  <strong class="mn io">//Step 3</strong><br/>})</span></pre><p id="b491" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注释中的步骤是本例中的执行顺序。</p><h2 id="fff6" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">传输列表中的数组缓冲区</h2><p id="b2fd" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">现在我们可以在传递列表中传递的第二个项目是一个<code class="fe mk ml mm mn b">Array Buffer</code>。你可以把数组缓冲区想象成一个<strong class="kq io">固定长度的连续内存</strong>区域。您不能直接访问<code class="fe mk ml mm mn b">ArrayBuffer</code>中的元素。我们需要一个叫做<strong class="kq io">数据视图</strong>的东西，它基本上是我们创建的<code class="fe mk ml mm mn b">ArrayBuffer</code>的解释。</p><p id="16d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我们想要创建一个<code class="fe mk ml mm mn b">16-byte ArrayBuffer</code>。现在每个字节是8位。所以总共有128比特的空间。现在我可以把这个缓冲区看作16，8位整数。因此，每个块将能够容纳0-255之间的数字，因为8位数字最多只能容纳255。我也可以把这个缓冲区看作8位和16位整数。它仍将占用相同的128位，但这次每个块可以容纳更大的数，因为16位整数的范围很广，从0到65535。这也可以被看作是4，32位整数。所以基本上你可以对一个数组缓冲区使用不同的数据视图。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/ce1b14a5dda1813c0e5b96801d5a53db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRJ2ZtvR1nRoB83hg7J0ug.png"/></div></div></figure><p id="711c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们回到工作线程。现在，这个数组缓冲区也可以包含在传递列表中。就实现而言，这与我们看到的消息端口非常相似。</p><p id="2779" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将首先创建一个16字节的<code class="fe mk ml mm mn b">ArrayBuffer</code>。我要使用的数据视图将是一个8位有符号整数数组，这意味着缓冲区中的每个元素应该在-128到127之间。这些数组数据视图称为类型化数组。我们将数据视图发送到工作线程(在值参数和传输列表中传递它),在工作线程内部，我们将只记录它的控制台日志。</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="e745" class="lm ln in mn b gy ms mt l mu mv">//app.js<br/>const app = require("express")()<br/>const { Worker } = require("worker_threads")<br/>const { MessageChannel } = require("worker_threads")<br/>const { port1, port2 } = new MessageChannel()</span><span id="8b3b" class="lm ln in mn b gy mw mt l mu mv">const worker = new Worker("./worker.js")<br/><strong class="mn io">const ab = new ArrayBuffer(8);<br/>const dv = new Int8Array(ab, 0, 8)</strong></span><span id="4950" class="lm ln in mn b gy mw mt l mu mv">//We need to transfer the buffer property and not the typed array<strong class="mn io"><br/>worker.postMessage(dv, [dv.buffer])</strong></span></pre><p id="fa22" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">工人文件将如下所示。</p><pre class="kd ke kf kg gt mo mn mp mq aw mr bi"><span id="501e" class="lm ln in mn b gy ms mt l mu mv">//worker.js<br/>const { parentPort, workerData } = require("worker_threads")</span><span id="f158" class="lm ln in mn b gy mw mt l mu mv">const complexCalc = () =&gt; {<br/>    let counter = 0;<br/>    while (counter &lt; 900000000) {<br/>        counter++;<br/>    }<br/>    return counter;<br/>}</span><span id="c0d0" class="lm ln in mn b gy mw mt l mu mv">parentPort.on("message", msg =&gt; {<br/>    console.log(msg)  <strong class="mn io">//Logs the buffer in the console</strong><br/>})</span></pre><p id="8009" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦<code class="fe mk ml mm mn b">ArrayBuffer</code>被转移到worker，你将无法在主线程中使用它。它变得毫无用处。</p><p id="426d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Node.js希望我们传输这些实体而不是克隆它们的原因是两个线程可能同时对数据进行一些操作。这可能会造成不一致，因为在中，每个线程对于该段数据都有不同的值。在共享内存的情况下，这是一个关键问题。现在，尽管这可能会导致问题，但有一种方法可以让您在线程之间共享数据，而无需克隆/传输数据。我们可以使用<code class="fe mk ml mm mn b">SharedArrayBuffer</code>。只需将当前示例中的<code class="fe mk ml mm mn b">ArrayBuffer</code>替换为<code class="fe mk ml mm mn b">SharedArrayBuffer</code>，并从<code class="fe mk ml mm mn b">postMessage</code>方法中移除传输列表。这将在线程间共享<code class="fe mk ml mm mn b">ArrayBuffer</code>,而无需克隆或转移它。</p><h2 id="4f66" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">传输列表中的文件句柄</h2><p id="c508" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">还有一种类型的数据可以传输，那就是<code class="fe mk ml mm mn b">Filehandle</code>。文件句柄是对系统中文件的数字引用。您可以向这个<code class="fe mk ml mm mn b">Filehandle</code>实例写入、读取、追加数据或做一系列其他事情。这个实例只能被转移到不同的工作线程，这是有意义的，因为你不希望两个不同的线程同时对同一个文件进行更改。</p><p id="8adf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以在promises部分的文件系统模块中使用<code class="fe mk ml mm mn b">open</code>方法创建一个文件句柄实例。这个open方法将接受文件名、文件的标志和文件的模式。这个实例现在可以转移到另一个worker，就像我们在数组缓冲区或消息端口的情况下所做的那样。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/90f0463d8b01668326f80d21323d3c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zQF04-mZbEPkLIePGZMtw.png"/></div></div></figure><h2 id="3a7b" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">结论</h2><p id="207f" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">这就是本教程的基本内容。这些概念有点复杂，因为它们有很多细节和错综复杂的地方需要你去处理。试着用你自己的一套例子来玩一玩，我相信它会对你更有意义。</p><p id="b62c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://youtu.be/kDr7YycaZ5E" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">我在Youtube上也有几个关于这个帖子的视频，你可以去看看。</em> </strong> </a></p><p id="4f60" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这篇文章是我们研究Node.js中多任务处理的系列文章的一部分。</p><ul class=""><li id="2d8e" class="mx my in kq b kr ks ku kv kx mz lb na lf nb lj nl nd ne nf bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/multitasking-in-node-js-with-child-process-d82841fd8d29"><strong class="kq io">node . js中多任务带子进程</strong> </a></li><li id="b69f" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nl nd ne nf bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/multitasking-in-node-js-with-the-cluster-module-ee8480208f86"> <strong class="kq io">使用集群模块</strong> </a>在Node.js中进行多任务处理</li><li id="1444" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nl nd ne nf bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/process-management-in-node-js-with-pm2-ca32d75c94af"><strong class="kq io">node . js中的流程管理与PM2 </strong> </a></li></ul><p id="89f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何疑问或建议，你可以在评论中提出，或者通过我的任何一个社交网站与我联系。干杯！</p><p id="a1c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/><a class="ae lk" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae lk" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae lk" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">GitHub</a></p></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><p id="5ca9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">更多内容请看</em><a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">plain English . io</em></strong></a><em class="ll">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">免费周报</em> </strong> </a> <em class="ll">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">Twitter</em></strong></a><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">LinkedIn</em></strong></a><em class="ll"/><a class="ae lk" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">YouTube</em></strong></a><em class="ll"/><a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">不和</em> </strong> </a> <em class="ll">。对增长黑客感兴趣？检查</em> <a class="ae lk" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">电路</em> </strong> </a> <em class="ll">。</em></p></div></div>    
</body>
</html>