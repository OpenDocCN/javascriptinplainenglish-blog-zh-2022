<html>
<head>
<title>JavaScript Interview Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试备忘单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/all-about-javascript-interview-54f1c6c782b8?source=collection_archive---------8-----------------------#2022-03-28">https://javascript.plainenglish.io/all-about-javascript-interview-54f1c6c782b8?source=collection_archive---------8-----------------------#2022-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c233" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在即将到来的JavaScript面试中，您应该知道这些</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a5b4a44757fbfb19c00ed7563309975f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JCouIElHZaElg4PcduYFg.jpeg"/></div></div></figure><p id="1163" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天、明天或下周，如果你有一个javascript面试，不要担心，在这里我将分享所有重要的主题、备忘单和文档，为即将到来的面试做好准备。</p><p id="a4e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我会尽量用概念这个最重要的因素使每个话题都简洁，以丰富你的知识。</p><p id="017d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将在本文中涉及的主题。</p><ol class=""><li id="f024" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">“这个”</li><li id="3b8b" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">关闭</li><li id="a3a8" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">异步JavaScript(承诺、异步等待、生成器)</li><li id="d920" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">吊装和TDZ</li><li id="87c9" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">函数调用和回调</li><li id="93e3" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">高阶函数</li></ol><p id="2746" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">可选和高级主题</p><ol class=""><li id="e27c" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">数字正射影像图</li><li id="166d" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">JS引擎(主堆栈、微队列、宏队列)</li><li id="4e42" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">模式</li><li id="0927" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">原型</li></ol><p id="a110" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在前进之前，你必须对“这个”有一个适当的理解。</p><h1 id="4cef" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">1.“这个”是什么？</h1><p id="b556" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">“this”是javascript中的保留关键字。我们不允许使用“this”作为标识符。“this”关键字根据用例改变其行为。</p><p id="447c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">严格模式设置“this”关键字上下文未定义。但是我们有一个替代方法，通过使用call、apply和bind函数来改变它的上下文。</p><h2 id="c00e" class="mv lz in bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo ng bi translated">调用、应用和绑定的“这种”行为</h2><p id="aac6" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">调用、应用和绑定函数通常用于改变该关键字的上下文，或者这种行为有助于构建更通用的函数。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="d0f7" class="mv lz in ni b gy nm nn l no np">const name = "Hyy"</span><span id="c909" class="mv lz in ni b gy nq nn l no np">function foo() {<br/>    'use strict'<br/>    console.log(this.name)<br/>}</span><span id="f988" class="mv lz in ni b gy nq nn l no np">const context = {<br/>    name: "Ritik"<br/>}</span><span id="72fb" class="mv lz in ni b gy nq nn l no np">foo.call(context)  // Ritik<br/>foo.apply(context) // Ritik<br/>foo()              // Cannot read properties of undefined (reading 'name')</span></pre><p id="f7ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">call和apply的区别在于，call期望参数作为单独的参数，而apply期望参数作为数组。</p><p id="8a07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">bind改变“this”的上下文，返回一个新函数。它不会立即执行像调用和应用这样的功能。</p><h2 id="8c59" class="mv lz in bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo ng bi translated">具有功能的“这”行为</h2><p id="ae35" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">使用Arrow函数样式的函数定义，其中该关键字指最近的上下文或空的/未定义的。</p><p id="8052" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用Function关键字定义函数，其中该关键字指的是全局上下文或父级。</p><h1 id="9b32" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">2.关闭</h1><p id="24c0" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">闭包是JavaScript中的一个特性，返回的函数可以访问作用域链中的外部函数变量和属性。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="d24e" class="mv lz in ni b gy nm nn l no np">function foo(){<br/>    var name = "baar"<br/>    return function () {<br/>        console.log(name); <br/>    }<br/>}<br/>foo()() // function currying</span></pre><h1 id="b89b" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">3.异步JavaScript</h1><p id="614e" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">函数与其他一些进程并行运行称为异步。异步Javascript利用异步计算。</p><h2 id="345b" class="mv lz in bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo ng bi translated">1.承诺</h2><p id="0f3f" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">Promises是一种在JavaScript中实现异步计算的方法promises也像人类的promises用更普通的话来说promises意味着它向你保证它将来会返回某个东西要么通过要么失败用更专业的话来说我们可以说要么成功要么被拒绝。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="115c" class="mv lz in ni b gy nm nn l no np">var foo = new Promise((resolve, reject) =&gt; {<br/>    if(true) {<br/>        resolve<br/>    } else {<br/>        reject<br/>    }<br/>})</span></pre><h2 id="5e7e" class="mv lz in bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo ng bi translated">2.异步等待</h2><p id="8b20" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">Async-await是在JavaScript中启用异步计算的另一种方式。Async-await的工作方式类似于promises，它们是通过使用promises来实现的。我们使用async-await只是因为它优雅而简单的语法，它不会产生回调地狱(嵌套承诺)。</p><h2 id="8c07" class="mv lz in bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo ng bi translated">3.发电机</h2><ul class=""><li id="8767" class="lk ll in kq b kr mq ku mr kx nr lb ns lf nt lj nu lq lr ls bi translated">在JavaScript中，常规函数是基于运行完成模型执行的。它不能中途暂停，然后从暂停的地方继续。</li><li id="f661" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj nu lq lr ls bi translated">生成器可以中途暂停，然后从暂停的地方继续运行。</li><li id="1382" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj nu lq lr ls bi translated">生成器对象是可迭代的，我们使用<em class="nv"> next </em>函数和<em class="nv"> yield </em>关键字来存档生成器属性。</li></ul><h1 id="dd3d" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">4.吊装和TDZ</h1><ul class=""><li id="8ac6" class="lk ll in kq b kr mq ku mr kx nr lb ns lf nt lj nu lq lr ls bi translated">JavaScript生命的默认行为——将声明的范围提升到顶层，这种性质被称为<em class="nv">提升</em> (var，function)。</li></ul><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="fb40" class="mv lz in ni b gy nm nn l no np">console.log(foo);  // undefined (Hoisted)<br/>console.log(bar()) // bar       (Hoisted)<br/>var foo = "foo";<br/>console.log(foo);  // foo</span><span id="3eb0" class="mv lz in ni b gy nq nn l no np">function bar() {<br/>    return "bar";<br/>}</span></pre><ul class=""><li id="1db9" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj nu lq lr ls bi translated">在声明之前访问和它的不可到达是一种<em class="nv">临时死区</em>情况(let，const)。</li></ul><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="3395" class="mv lz in ni b gy nm nn l no np">console.log(foo) // ReferenceError: Cannot access 'foo' before initialization "TDZ"<br/>console.log(bar) // ReferenceError: Cannot access 'foo' before initialization "TDZ"</span><span id="4ce8" class="mv lz in ni b gy nq nn l no np">let foo = "foo";<br/>const bar = "bar";</span><span id="5880" class="mv lz in ni b gy nq nn l no np">console.log(foo) // foo<br/>console.log(bar) // bar</span></pre><h1 id="0189" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">5.函数调用和回调</h1><p id="4037" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">Currying是将具有多个参数的函数转换成一系列嵌套函数调用的过程。它返回一个新函数，该函数需要内联的下一个参数。</p><p id="db8f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一级函数特性支持回调。回调函数是作为参数传递给另一个函数的函数，它将在外层函数内部被调用以完成某个动作。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="2478" class="mv lz in ni b gy nm nn l no np"><em class="nv">function simpleFunction(param1, param2, param3, …..) =&gt; function curriedFunction(param1)(param2)(param3)(….)</em></span><span id="36f3" class="mv lz in ni b gy nq nn l no np">function calculateVolume(length) {<br/>    return function (breadth) {<br/>        return function (height) {<br/>            return length * breadth * height;<br/>        }<br/>    }<br/>}<br/>console.log(calculateVolume(4)(5)(6)); // 120</span></pre><h1 id="6bbd" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">6.高阶函数</h1><p id="7264" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">高阶函数接受一个函数或一系列函数作为参数，并返回一个函数。返回的函数可能包含一些附加属性或常数，用于进一步计算。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="9c32" class="mv lz in ni b gy nm nn l no np">//Assign a function to a variable originalFunc<br/>const originalFunc = (num) =&gt; { return num + 2 };<br/> <br/>//Re-assign the function to a new variable newFunc<br/>const newFunc = originalFunc;<br/> <br/>//Access the function's name property<br/>newFunc.name; //'originalFunc'<br/> <br/>//Return the function's body as a string<br/>newFunc.toString(); //'(num) =&gt; { return num + 2 }'<br/> <br/>//Add our own isMathFunction property to the function<br/>newFunc.isMathFunction = true;<br/> <br/>//Pass the function as an argument<br/>const functionNameLength = (func) =&gt; { return func.name.length }; <br/>functionNameLength(originalFunc); //12<br/> <br/>//Return the function<br/>const returnFunc = () =&gt; { return newFunc };<br/>returnFunc(); //[Function: originalFunc]</span></pre><h1 id="980c" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">可选和高级主题</h1><h1 id="1f4c" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">1.数字正射影像图</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ae5096b9d33c6e76b66c7a167569609d.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*l7zB_om5eG4B6Z8G"/></div></figure><ul class=""><li id="da71" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj nu lq lr ls bi translated">DOM是HTML结构的表示。DOM使得以编程方式操作网页成为可能。文档对象代表浏览器选项卡上加载的网页。文档对象是全局窗口对象的一部分。由<code class="fe nx ny nz ni b">window.document</code>或文档访问。在DOM中，每个HTML标签都是一个对象。嵌套标签是封闭标签的“子标签”。标签内的文本也是一个对象。</li></ul><p id="ed22" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="nv">元素</em> </strong></p><ul class=""><li id="ebea" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj nu lq lr ls bi translated"><strong class="kq io">选择器:</strong><code class="fe nx ny nz ni b">getElementById</code><code class="fe nx ny nz ni b">getElementByTagName</code><code class="fe nx ny nz ni b">querySelector</code><em class="nv"/><code class="fe nx ny nz ni b">querySelectorAll</code>；</li><li id="f7a0" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj nu lq lr ls bi translated"><strong class="kq io">导航:</strong> <code class="fe nx ny nz ni b">children</code>(元素):<code class="fe nx ny nz ni b">childNodes</code>(节点)<code class="fe nx ny nz ni b">firstElementChild</code><code class="fe nx ny nz ni b">lastElementChild</code><code class="fe nx ny nz ni b">parentElement</code><code class="fe nx ny nz ni b">previousElementSibling</code><code class="fe nx ny nz ni b">nextElementSibling</code>；</li><li id="98ec" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj nu lq lr ls bi translated"><strong class="kq io">属性:</strong><code class="fe nx ny nz ni b">classList</code><code class="fe nx ny nz ni b">clientHeight</code><code class="fe nx ny nz ni b">clientWidth</code><code class="fe nx ny nz ni b">childElementCount</code><em class="nv"/><code class="fe nx ny nz ni b">setAttribute(attrName, value)</code><code class="fe nx ny nz ni b">removeAttribute(attrName)</code><code class="fe nx ny nz ni b">removeAttribute(attrName)</code>；</li></ul><p id="ead5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="nv">操纵</em> </strong></p><p id="cf86" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe nx ny nz ni b">createElement(‘div’)</code>、<code class="fe nx ny nz ni b">append</code>、<code class="fe nx ny nz ni b">prepend</code>、<code class="fe nx ny nz ni b">el.cloneNode(true)</code>、<code class="fe nx ny nz ni b">remove()</code>、<code class="fe nx ny nz ni b">insertBefore(newNode, beforeNode)</code>、<code class="fe nx ny nz ni b">insertAfter(newNode, afterNode);</code></p><p id="8970" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae oa" href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nv">文档片段</em> </strong> </a> <em class="nv"> — </em>创建文档的虚拟副本，可以存储多个元素。通过在DOM中插入一个<em class="nv">文档片段</em>，它变成空的，并且只引起一次<a class="ae oa" href="https://itnext.io/frontend-interview-cheatsheet-that-helped-me-to-get-offer-on-amazon-and-linkedin-cba9584e33c7#5178" rel="noopener ugc nofollow" target="_blank">重排</a>；</p><p id="dd3c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae oa" href="https://programmingwithmosh.com/javascript/javascript-event-bubbling-and-event-delegation/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nv">事件委托和冒泡</em> </strong> </a></p><ul class=""><li id="5b89" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj nu lq lr ls bi translated">当我们发出一个<em class="nv">事件时，</em> ex。<code class="fe nx ny nz ni b">click</code>，事件通过<code class="fe nx ny nz ni b">parentElement.</code>冒泡到<code class="fe nx ny nz ni b">&lt;html&gt;</code>元素</li><li id="8b57" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj nu lq lr ls bi translated"><em class="nv">委托</em>用于提高性能。假设我们有一个结构，我们想要将一个<code class="fe nx ny nz ni b">addEventListener</code>分配给<code class="fe nx ny nz ni b">.child</code>，在这种情况下，我们必须将一个事件附加到3个元素。相反，我们可以只将事件附加到<code class="fe nx ny nz ni b">.parent</code>并解析逻辑。</li></ul><h1 id="b9e4" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">JS引擎</h1><p id="6ae1" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">在这里您将获得关于<a class="ae oa" href="https://medium.com/nerd-for-tech/crucial-facts-about-javascript-engine-7b264c17f36d" rel="noopener"> JsEngine </a>的所有详细信息。</p><h1 id="661e" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">模式</h1><ol class=""><li id="537a" class="lk ll in kq b kr mq ku mr kx nr lb ns lf nt lj lp lq lr ls bi translated">用方法列表扩展一个对象的功能。</li><li id="8659" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq io">工厂<em class="nv"> —一个</em> </strong>类<em class="nv"> </em>，可以创建一个或多个不同的对象(如果你想在单元测试中生成不同的模拟数据，这很有用)。</li><li id="eedd" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq io">Singleton-C</strong>class，其中您可以直接调用方法，而无需创建对象。</li><li id="23c9" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq io">门面<em class="nv"> — </em> </strong>抽象更复杂的逻辑，包装在类中。例如，位于组件和API层之间的服务。</li><li id="551f" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq io"> <em class="nv"> MVC，MVVM — </em> </strong> <a class="ae oa" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">模型视图控制器</strong> </a>和<a class="ae oa" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">模型视图模型</strong> </a> <strong class="kq io">。</strong></li></ol><h1 id="eb5d" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">原型</h1><p id="a892" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">默认情况下，原型是在JavaScript中与每个函数和对象相关联的对象，其中函数的prototype属性是可访问和可修改的，而对象的prototype属性(aka属性)是不可见的。</p><p id="27c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">原型对象是一种特殊类型的可枚举对象，附加的属性可以附加到该对象上，这些属性将在其构造函数的所有实例中共享。</p><p id="4a31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它把我们带到了最后！非常感谢您通读这篇文章——如果这篇文章在某种意义上有所帮助，我将感谢一位追随者帮助我实现我的目标:)</p><p id="c79d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请随意访问我的网站，如果您有任何与JS/DevOps相关的疑问，请随意与我联系。</p><p id="6712" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae oa" href="https://ritikchopra.netlify.app/" rel="noopener ugc nofollow" target="_blank">https://ritikhopra . netlify . app</a></p></div><div class="ab cl ob oc hr od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ig ih ii ij ik"><p id="1a37" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">祝你好运！<br/> Ritik Chopra😘</p><p id="d02d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nv">更内容于</em><a class="ae oa" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nv"/></strong></a><em class="nv">。为我们报名</em> <a class="ae oa" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nv">免费周报</em> </strong> </a> <em class="nv">。在</em> <a class="ae oa" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nv">推特</em> </strong> </a> <em class="nv">和</em> <a class="ae oa" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nv">领英</em> </strong> </a> <em class="nv">上跟随我们。加入我们的</em> <a class="ae oa" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nv">社群不和</em> </strong> </a> <em class="nv">。</em></p></div></div>    
</body>
</html>