<html>
<head>
<title>Create Your Own JavaScript Runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自己的JavaScript运行时</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-your-own-javascript-runtime-5929bf1c894e?source=collection_archive---------10-----------------------#2022-09-01">https://javascript.plainenglish.io/create-your-own-javascript-runtime-5929bf1c894e?source=collection_archive---------10-----------------------#2022-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2df8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分:处理由输入JavaScript代码抛出的异常。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3a2d56a7ba09e5f599266f9f7f4405e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0qh-tiEiBo-Ulo0G"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@mitchel3uo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mitchell Luo</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="33d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了快速回顾我们上次取得的进展，我们初始化了我们的项目，并开始使用V8运行JavaScript。我们创建了一个通过命令行使用的REPL(读取-评估-打印循环)。今天，我们将通过处理输入JavaScript代码抛出的异常来增加我们的REPL。</p><h1 id="ee5b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">获取异常</strong></h1><p id="315c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">今天的代码将存在于<code class="fe mp mq mr ms b">src</code>目录下的一个单独的<code class="fe mp mq mr ms b">errors.rs</code>文件中。我们将用一个<code class="fe mp mq mr ms b">print_error</code>函数来处理打印错误。</p><p id="fdbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建新的<code class="fe mp mq mr ms b">errors.rs</code>文件。导入V8机箱并创建功能<code class="fe mp mq mr ms b">print_error</code>。如果在传递给函数的范围内存在异常，我们可以继续，否则，我们将打印一个错误，指出不存在异常。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a5ff" class="mx lt iq ms b gy my mz l na nb">use v8;</span><span id="2b23" class="mx lt iq ms b gy nc mz l na nb">pub fn print_error(mut scope: v8::TryCatch&lt;v8::HandleScope&gt;) {<br/>  if let Some(exception) = scope.exception() {<br/>    ...<br/>  } else {<br/>    eprintln!("Internal error: no exception");<br/>  }<br/>}</span></pre><h1 id="f89e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">构造错误</strong></h1><p id="99de" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在“if”语句中，我们将获取异常字符串，如果可以的话，还将从异常中获取消息对象。如果我们得不到消息，我们将只打印出简单的异常字符串并返回它。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="bb69" class="mx lt iq ms b gy my mz l na nb">    let exception_string = exception.to_string(&amp;mut scope).unwrap().to_rust_string_lossy(&amp;mut scope);</span><span id="e62b" class="mx lt iq ms b gy nc mz l na nb">    let message = if let Some(message) = scope.message() {<br/>      message<br/>    } else {<br/>      eprintln!("{}", exception_string);<br/>      return;<br/>    };</span></pre><p id="11b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的错误消息的第1行应该由文件名、行号、抛出异常的令牌列以及异常文本组成。消息对象为我们提供了所需的细节。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d2e9" class="mx lt iq ms b gy my mz l na nb">    let filename = message<br/>    .get_script_resource_name(&amp;mut scope)<br/>    .map_or_else(<br/>      || "(unknown)".into(),<br/>      |s| {<br/>        s.to_string(&amp;mut scope)<br/>          .unwrap()<br/>          .to_rust_string_lossy(&amp;mut scope)<br/>      },<br/>    );<br/>    let line_number = message.get_line_number(&amp;mut scope).unwrap_or_default();<br/>    let start_column = message.get_start_column();<br/>    let end_column = message.get_end_column();</span><span id="3f6f" class="mx lt iq ms b gy nc mz l na nb">    eprintln!("{}:{}:{}: {}", filename, line_number, start_column, exception_string);</span></pre><h2 id="afaa" class="mx lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated"><strong class="ak">有问题的代码</strong></h2><p id="d445" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">接下来，让我们展示抛出异常的代码，并指出该行中的特定标记。正如我们在上面看到的，消息对象为我们提供了一些关于错误的信息。开始和结束列表示令牌的开始和结束位置。</p><p id="165e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们打印源代码中的这一行，前面是行号。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="8411" class="mx lt iq ms b gy my mz l na nb">    let source_line = message<br/>    .get_source_line(&amp;mut scope)<br/>    .map(|s| {<br/>      s.to_string(&amp;mut scope)<br/>        .unwrap()<br/>        .to_rust_string_lossy(&amp;mut scope)<br/>    })<br/>    .unwrap();<br/>    eprintln!("{}: {}", line_number, source_line);</span></pre><p id="96ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以打印一些指向有问题的令牌的carets，记住添加填充来说明行号。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="e40d" class="mx lt iq ms b gy my mz l na nb">    eprint!("{}", " ".repeat(line_number.to_string().len()+2));</span><span id="75ba" class="mx lt iq ms b gy nc mz l na nb">    for _ in 0..start_column {<br/>      eprint!(" ");<br/>    }</span><span id="72be" class="mx lt iq ms b gy nc mz l na nb">    for _ in start_column..end_column {<br/>      eprint!("^");<br/>    }</span><span id="1880" class="mx lt iq ms b gy nc mz l na nb">    eprintln!();</span></pre><h2 id="6dcb" class="mx lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated"><strong class="ak">堆栈跟踪</strong></h2><p id="3a41" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，我们将打印堆栈跟踪。这暂时不是很有用，因为所有的错误都会出现在REPL的输入行上，但是它仍然是错误消息的重要部分，以后会很有用。我们可以从作用域中获取堆栈跟踪，并将其转换为V8字符串。然后打印堆栈跟踪。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="cb50" class="mx lt iq ms b gy my mz l na nb">    let stack_trace = if let Some(stack_trace) = scope.stack_trace() {<br/>      stack_trace<br/>    } else {<br/>      return;<br/>    };<br/>    let stack_trace = unsafe { v8::Local::&lt;v8::String&gt;::cast(stack_trace) };<br/>    let stack_trace = stack_trace<br/>      .to_string(&amp;mut scope)<br/>      .map(|s| s.to_rust_string_lossy(&amp;mut scope));</span><span id="fb78" class="mx lt iq ms b gy nc mz l na nb">    if let Some(stack_trace) = stack_trace {<br/>      eprintln!("{}", stack_trace);<br/>    }</span></pre><p id="b29d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">实现错误打印</strong></p><p id="d284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到<code class="fe mp mq mr ms b">main.rs</code>文件，找到下面这行代码的两个实例。这是第1部分中的临时错误处理代码。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a609" class="mx lt iq ms b gy my mz l na nb">eprintln!("An error occured when compiling the JavaScript!");</span></pre><p id="ef0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导入<code class="fe mp mq mr ms b">print_error</code>功能。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="92d8" class="mx lt iq ms b gy my mz l na nb">mod error;<br/>use error::print_error;</span></pre><p id="0824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用函数调用替换print语句(在两种情况下),传递作用域。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c93c" class="mx lt iq ms b gy my mz l na nb">print_error(scope);</span></pre><h1 id="9ff2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="649a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">错误完成后，我们现在可以在REPL中识别重要的调试信息。下一次，我们将开始添加文件支持的旅程，在我们的设备上运行文件中的代码。从那里，我们可以扩展到多个文件，并构建运行时的其余部分。如果您需要帮助，请查看下面的完整源代码。</p><h1 id="5c3c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">资源</strong></h1><p id="d3be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">——<a class="ae kv" href="https://github.com/TheOtterlord/v8-runtime-tutorial/tree/main/02-handling-errors" rel="noopener ugc nofollow" target="_blank">教程源代码</a></p><p id="f7e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">- <a class="ae kv" href="https://github.com/nodejs/node/tree/main/src#helpful-concepts" rel="noopener ugc nofollow" target="_blank">有用的概念— Node.js GitHub库</a></p><p id="338e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">- <a class="ae kv" href="https://docs.rs/v8/latest/v8/index.html" rel="noopener ugc nofollow" target="_blank"> V8锈绑定文档— Docs.rs </a></p><p id="4872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">- <a class="ae kv" href="https://github.com/denoland/rusty_v8/tree/main/examples" rel="noopener ugc nofollow" target="_blank"> V8生锈绑定示例—生锈的V8 GitHub </a></p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="bc7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nv">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nv">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nv">免费周报</em> </strong> </a> <em class="nv">。关注我们关于</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nv">推特</em> </strong> </a>，<a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nv">LinkedIn</em></strong></a><em class="nv">，</em><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nv">YouTube</em></strong></a><em class="nv">，以及</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nv">不和</em> </strong> </a> <em class="nv">。</em></strong></a></p></div></div>    
</body>
</html>