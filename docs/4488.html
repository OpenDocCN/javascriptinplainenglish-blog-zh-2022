<html>
<head>
<title>Build a Twitter Scheduler for Free with Next.js and Upstash Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Next.js和Upstash Redis免费构建一个Twitter调度器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-twitter-scheduler-for-free-with-next-js-aa57d73eaa4d?source=collection_archive---------2-----------------------#2022-12-08">https://javascript.plainenglish.io/build-a-twitter-scheduler-for-free-with-next-js-aa57d73eaa4d?source=collection_archive---------2-----------------------#2022-12-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b201992aba61f77429e5c4675cc0a302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S-0yI5dbLPL-2t98"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@rswebsols?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Souvik Banerjee</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="42db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Twitter是一个流行的社交媒体平台，开发者可以通过它与全球观众分享他们的想法、想法和观点。这是与其他开发人员联系、了解最新趋势和技术以及向全世界展示他们的工作的好方法。</p><p id="917d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了充分利用Twitter，你需要定期发帖。通过提前计划和安排你的推文，你可以节省时间并增加你的参与度。有许多付费SaaS(软件即服务)解决方案允许用户在社交媒体平台上安排帖子。然而，这些服务可能很贵，并且需要订阅。</p><p id="6d48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将使用Next.js构建自己的解决方案，这是一个用于构建全栈应用程序的React框架。首先，我们需要将我们的tweets保存到Redis数据库中，在T1之上。然后，我们将创建一个Next.js API路由来从数据库中获取tweets。最后，我们将使用Twitter API将推文发布到我们的帐户。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="ebf7" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak"> UI和表单</strong></h1><p id="9bf0" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们首先创建一个简单的UI来安排我们的推文。作为Next.js样板文件的创建者，我使用自己的样板文件开始。Next.js样板是一个Next.js starter模板，它包括一个完全配置的项目，其中包含构建生产就绪应用程序所需的所有工具。这个项目的源代码可以在GitHub的<a class="ae jz" href="https://github.com/ixartz/Next-js-Boilerplate" rel="noopener ugc nofollow" target="_blank"> Next.js样板</a>上找到。</p><p id="5c98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了开始，我们需要向我们的项目添加以下依赖项:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="38e5" class="mr lg in mn b be ms mt l mu mv">npm install react-hook-form @upstash/redis @upstash/qstash axios</span></pre><p id="ed7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用<em class="mw"> react-hook-form </em>库来处理表单状态。在<em class="mw"> src/pages </em>文件夹中，我们创建一个新的页面<em class="mw"> add-tweet.tsx </em>并添加一个简单的表单:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="69f0" class="mr lg in mn b be ms mt l mu mv">import axios from 'axios';<br/>import { useForm } from 'react-hook-form';<br/><br/>const AddTweet = () =&gt; {<br/>  const { register, handleSubmit, reset } = useForm();<br/><br/>  const onSubmit = handleSubmit(async (data) =&gt; {<br/>    await axios.post('/api/add-tweet/', {<br/>      ...data,<br/>    });<br/><br/>    reset();<br/>  });<br/><br/>  return (<br/>    &lt;form onSubmit={onSubmit}&gt;<br/>      &lt;label&gt;<br/>        Message:<br/>        &lt;input type="text" {...register('message')} /&gt;<br/>      &lt;/label&gt;<br/><br/>      &lt;label&gt;<br/>        Scheduled date:<br/>        &lt;input<br/>          type="datetime-local"<br/>          {...register('scheduledDate', { valueAsDate: true })}<br/>        /&gt;<br/>      &lt;/label&gt;<br/><br/>      &lt;input type="submit" value="Submit" /&gt;<br/>    &lt;/form&gt;<br/>  );<br/>};<br/><br/>export default AddTweet;</span></pre></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="15af" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">全球Redis数据库</strong></h1><p id="183c" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">对于数据库部分，我们使用<a class="ae jz" href="https://upstash.com/?utm_source=remi2" rel="noopener ugc nofollow" target="_blank"> Upstash </a>，一个完全托管的Redis数据库。Upstash是为那些希望构建应用程序而无需担心和管理数据库的开发人员提供的解决方案。Upstash的另一个优点是它可以在边缘运行，这导致了更快的响应时间。它与Edge API路由配合得非常好。</p><p id="ddba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要在Upstash上创建一个新帐户。一旦你创建了一个帐户，你就可以创建一个新的数据库。我们对这个项目使用免费计划，其中包括每月10，000个请求(2，000个用于全局数据库)。</p><p id="7839" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦创建了一个Upstash帐户，您需要创建一个新的数据库:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/836e76bd38bb00d006cdc8bc9978bb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*NKYRE6KGsKth2EtGsUsKwA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Redis global database on Upstash</figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="1dda" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">连接到Redis数据库</strong></h1><p id="48ee" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">为了连接到Upstash Redis数据库，我们使用了<em class="mw"> @upstash/redis </em>包。我们还需要创建一个名为<em class="mw"> src/utils/Redis.ts </em>的新文件:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="85da" class="mr lg in mn b be ms mt l mu mv">import { Redis } from '@upstash/redis';<br/><br/>export const redis = new Redis({<br/>  url: process.env.UPSTASH_REDIS_REST_URL || '',<br/>  token: process.env.UPSTASH_REDIS_REST_TOKEN || '',<br/>});</span></pre><p id="cabf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要访问<em class="mw">upstresh _ REDIS _ REST _ URL</em>值，请转到您的upstresh仪表板。一旦你复制了Redis REST的URL，你可以把它粘贴到<em class="mw">中。env </em>文件。</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="26e9" class="mr lg in mn b be ms mt l mu mv">UPSTASH_REDIS_REST_URL=https://XXXXXXXX.upstash.io</span></pre><p id="9f1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了<em class="mw">upstresh _ REDIS _ REST _ URL</em>值之外，您还需要从您的upstresh仪表板中复制<em class="mw">upstresh _ REDIS _ REST _ TOKEN</em>变量。但是，这一次，请将该值传递到` . env.local `文件中:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="c3a6" class="mr lg in mn b be ms mt l mu mv">UPSTASH_REDIS_REST_TOKEN=XXXXXXXX</span></pre><p id="90bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了保证我们的秘密变量的安全，将它们存储在<em class="mw"> .env.local </em>文件中是一个很好的做法。因为这个文件没有提交给Git存储库，所以我们的秘密不会暴露给任何可以访问存储库的人。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="f002" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">存储在数据库中的Edge API路由</strong></h1><p id="0791" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们需要通过创建一个新文件<em class="mw"> src/types/Tweet.ts </em>来定义一个模式:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="edcb" class="mr lg in mn b be ms mt l mu mv">export type IAddTweet = {<br/>  message: string;<br/>  scheduledDate: string;<br/>};</span></pre><p id="6525" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们创建一个新文件<em class="mw">src/pages/API/add-tweet . ts</em>来处理表单提交。我们使用<em class="mw"> @upstash/redis </em>库连接到我们的redis数据库并保存tweet。</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="2880" class="mr lg in mn b be ms mt l mu mv">import type { NextRequest } from 'next/server';<br/><br/>import type { IAddTweet } from '@/types/Tweet';<br/>import { redis } from '@/utils/Redis';<br/><br/>export default async function handler(req: NextRequest) {<br/>  const reqJson: IAddTweet = await req.json();<br/><br/>  await redis.zadd('tweet', {<br/>    score: new Date(reqJson.scheduledDate).getTime() / 1000, // convert to seconds<br/>    member: reqJson.message,<br/>  });<br/><br/>  return new Response(<br/>    JSON.stringify({<br/>      success: true,<br/>    }),<br/>    {<br/>      status: 200,<br/>      headers: {<br/>        'content-type': 'application/json',<br/>      },<br/>    }<br/>  );<br/>}<br/><br/>export const config = {<br/>  runtime: 'experimental-edge',<br/>};</span></pre><p id="3e45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了使我们的API路由可以非常快速地访问，我们使用Next.js的Edge API路由功能。Edge API路由是在边缘上运行的无服务器函数。这意味着我们的API路由将在靠近用户的地方执行，这导致了更快的响应时间。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="750e" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">使用代码</strong>在Twitter上发帖</h1><p id="9114" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们已经成功地以编程方式创建了我们的第一条tweet，但是为了更进一步，我们需要将我们的tweet安排在未来的特定时间。这样，我们可以确保我们的推文在最有效的时间发出，以获得最大的参与度和影响力。</p><p id="a028" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，只有当我们手动运行API路由时，它才起作用。为了自动化这个过程，我们需要使用cron作业。cron作业是在指定时间定期运行的任务。而且，对于无服务器功能，我们无法访问cron作业。为了解决这个问题，我们可以使用一个像Upstash QStash这样的外部服务。QStash是一个无服务器应用程序的调度解决方案。</p><p id="851b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们需要更新API端点，我们可以从数据库中检索推文，并检查是否有任何推文计划发布。在<em class="mw">src/pages/API/schedule-tweet . ts</em>中，我们添加以下代码:</p><pre class="mi mj mk ml gt mm mn mo bn mp mq bi"><span id="aadc" class="mr lg in mn b be ms mt l mu mv">import { verifySignature } from '@upstash/qstash/nextjs';<br/>import axios from 'axios';<br/>import type { NextApiRequest, NextApiResponse } from 'next';<br/><br/>import { redis } from '@/utils/Redis';<br/><br/>async function handler(_req: NextApiRequest, res: NextApiResponse) {<br/>  const currentTimestamp = Date.now() / 1000;<br/>  const list = await redis.zrange('tweet', 0, currentTimestamp, {<br/>    byScore: true,<br/>  });<br/><br/>  for (let i = 0; i &lt; list.length; i += 1) {<br/>    // Run sequentially the requests to prevent overloading Twitter API<br/>    await axios.post(<br/>      'https://api.twitter.com/2/tweets',<br/>      {<br/>        text: list[i],<br/>      },<br/>      {<br/>        headers: {<br/>          Authorization: `Bearer ${process.env.TWITTER_BEARER_TOKEN}`,<br/>        },<br/>      }<br/>    );<br/>  }<br/><br/>  await redis.zremrangebyscore('tweet', 0, currentTimestamp);<br/><br/>  res.status(200).json({<br/>    success: true,<br/>  });<br/>}<br/><br/>export default verifySignature(handler);<br/><br/>export const config = {<br/>  api: {<br/>    bodyParser: false,<br/>  },<br/>};</span></pre><p id="8e64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mw">验证签名</em>需要两个环境变量:<em class="mw">QSTASH _ CURRENT _ SIGNING _ KEY</em>和<em class="mw">QSTASH _ NEXT _ SIGNING _ KEY</em>。这些变量用于验证请求的签名。因此，我们可以确保请求来自QStash，而不是来自一个坏演员。您可以从您的仪表板上获取这些变量值。</p><p id="9e7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您还需要将Next.js应用程序部署到可公开访问的URL。例如，您可以在Vercel上部署。因此，QStash可以向API端点<em class="mw"> api/schedule-tweet </em>发送请求。</p><p id="0bc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">部署完Next.js应用程序后，在Upstash仪表板中，您可以转到QStash部分并创建一个新的<em class="mw">请求构建器</em>。您还需要添加端点URL和cron作业的频率。在本例中，它将每天运行cron作业。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/d6d395eebbe1a11bbfa971fa22bd600f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYEVNFGGCPG5QszQy092GQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">QStash Next.js Cron job</figcaption></figure><p id="1443" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，您可以根据需要更改cron作业的频率。例如，您可以将其更改为每分钟或每小时。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="6b71" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">结论</strong></h1><p id="eac3" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在本文中，我们使用Next.js和<a class="ae jz" href="https://upstash.com/?utm_source=remi2" rel="noopener ugc nofollow" target="_blank"> Upstash </a>构建了一个Twitter调度器。我们使用Next.js API路由将tweets存储在Redis数据库中，并在未来的特定时间对它们进行调度。我们还使用Twitter API将推文发布到我们的帐户。</p><p id="6935" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过构建自己的Twitter调度程序，你可以避免使用昂贵的SaaS解决方案，节省资金。您也可以将此项目作为起点，并根据您的需求进行改进。</p><p id="a7b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mw">报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mw">免费每周简讯</em> </strong> </a> <em class="mw">。关注我们关于</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mw">推特</em> </strong> </a>，<a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mw">领英</em> </strong> </a> <em class="mw">，</em><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mw">YouTube</em></strong></a><em class="mw">，以及</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mw">不和</em> </strong> </a> <strong class="kc io"> <em class="mw">。</em>T47】</strong></p></div></div>    
</body>
</html>