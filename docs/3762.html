<html>
<head>
<title>Introduction to Web Components in JavaScript: Create a Hello-World Web Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Web组件简介:创建Hello-World Web组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-web-components-in-javascript-create-a-hello-world-web-component-e624874ec3b1?source=collection_archive---------5-----------------------#2022-09-23">https://javascript.plainenglish.io/introduction-to-web-components-in-javascript-create-a-hello-world-web-component-e624874ec3b1?source=collection_archive---------5-----------------------#2022-09-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3c26" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何使用JavaScript创建Hello-World web组件的教程。</h2></div><p id="418a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Web组件是一套不同的技术，允许您创建可重用的自定义HTML元素。它的伟大之处在于组件的逻辑和风格的封装。我们可以保持一个元素的特性是私有的，所以它们可以被脚本化和样式化，而不用担心与文档的其他部分冲突。</p><p id="e872" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Web组件由三种主要技术组成:</p><ul class=""><li id="34b6" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="ke io">定制元素</strong>:一组JavaScript APIs，允许你定义新的定制HTML标签或者改进现有的标签。</li></ul><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="1438" class="lq lr in lm b gy ls lt l lu lv">class MyComponent extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    this.innerHTML = `&lt;p&gt;My Web Component&lt;/p&gt;`;<br/>  }<br/>}<br/>    <br/>customElements.define('my-component', MyComponent);</span></pre><ul class=""><li id="d8ee" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="ke io">影子DOM: </strong>一组JavaScript APIs，用于将封装的“影子”DOM树附加到独立于主文档DOM呈现的元素上。Shadow DOM确保我们为web组件定义的样式或JavaScript不会泄露出去，也不会影响应用程序的其他部分。<br/>您可以使用Element.attachShadow()方法将阴影根附加到任何元素。</li></ul><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="9b01" class="lq lr in lm b gy ls lt l lu lv">const shadow = this.attachShadow({mode: 'open'});</span></pre><figure class="lh li lj lk gt lx gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/162b4b1a4cc10d2874adfa6ee3aa75a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*4bvf4SBwrUA6vjbSY6o-Xw.png"/></div></figure><ul class=""><li id="8c6e" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">HTML模板:模板允许你在你的页面中定义你的web组件可以使用的HTML。模板及其内容不在DOM中呈现，但仍然可以使用JavaScript引用。<br/> <strong class="ke io">注意</strong>:还有一个&lt;槽&gt;元素，你可以用它来管理一个元素的内容。</li></ul><h1 id="e575" class="ma lr in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">生命周期方法</h1><p id="d4e5" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在Web组件状态的整个生命周期中，浏览器会自动调用六种方法。</p><ol class=""><li id="b5c4" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx mw le lf lg bi translated"><strong class="ke io"> constructor() </strong>:组件初始化时调用。它必须调用super()，并且可以设置任何默认值或执行其他预渲染过程。</li><li id="4e00" class="ky kz in ke b kf mx ki my kl mz kp na kt nb kx mw le lf lg bi translated"><strong class="ke io"> connectedCallback() </strong>:当自定义元素第一次连接到文档的DOM时调用。</li><li id="90db" class="ky kz in ke b kf mx ki my kl mz kp na kt nb kx mw le lf lg bi translated"><strong class="ke io"> disconnectedCallback() </strong>:当自定义元素与文档的DOM断开连接时调用。</li><li id="e20c" class="ky kz in ke b kf mx ki my kl mz kp na kt nb kx mw le lf lg bi translated"><strong class="ke io"> adoptedCallback() </strong>:当Web组件从一个文档移动到另一个文档时，调用这个函数。</li><li id="faaf" class="ky kz in ke b kf mx ki my kl mz kp na kt nb kx mw le lf lg bi translated"><strong class="ke io">attributeChangedCallback()</strong>:添加、删除或更改定制元素的属性之一时调用。</li><li id="7744" class="ky kz in ke b kf mx ki my kl mz kp na kt nb kx mw le lf lg bi translated"><strong class="ke io">static observed attributes()</strong>:返回浏览器将观察到的属性数组。</li></ol><h1 id="865d" class="ma lr in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">创建一个 web组件:</h1><h1 id="edf7" class="ma lr in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">自定义元素</h1><p id="e19d" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们需要定义一个类来控制元素。它可以取任何名字，姑且叫它HelloWorld吧。它必须扩展HTMLElement接口，该接口表示每个HTML元素的默认属性和方法。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="375f" class="lq lr in lm b gy ls lt l lu lv">class HelloWorld extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    this.textContent = 'Hello World!';<br/>  }<br/>}</span></pre><p id="4847" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该类必须向CustomElementRegistry注册，以将其定义为特定元素的处理程序。名称必须包含破折号，以免与HTML规范中正式支持的元素冲突。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="1175" class="lq lr in lm b gy ls lt l lu lv">customElements.define( 'hello-world', HelloWorld );</span></pre><h1 id="42bb" class="ma lr in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">添加属性</h1><p id="ac1a" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">到目前为止，我们的组件只是在屏幕上打印hello world。为了使问候语动态，我们可以添加HTML属性:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="7951" class="lq lr in lm b gy ls lt l lu lv">&lt;hello-world name="Ankit"&gt;&lt;/hello-world&gt;</span></pre><p id="478b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并且textContent将发生如下变化:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="2f58" class="lq lr in lm b gy ls lt l lu lv">class HelloWorld extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    this.textContent = `Hello ${this.getAttribute("name")}!`;<br/>  }<br/>}</span></pre><figure class="lh li lj lk gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/1f55e7973e40e33c35ea4d03fa7e5065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrcVrBo4aOQOA5QzdSV1yg.png"/></div></div></figure><h1 id="b075" class="ma lr in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">阴影Dom</h1><p id="8a0a" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">虽然我们在上面构建的Web组件可以工作，但是它不能免受外部干扰，CSS或JavaScript可以修改它。我们为组件定义的样式可能会泄露出来并影响文档的其他部分。为了防止这种情况，我们需要创建一个影子dom。影子DOM通过将一个单独的DOM附加到Web组件来解决这个封装问题。阴影DOM可以像任何其他DOM元素一样进行操作。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="1e36" class="lq lr in lm b gy ls lt l lu lv">this.shadow = this.attachShadow({ mode: "open" });</span></pre><ul class=""><li id="d55d" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">{ mode: "open" } —这意味着我们可以使用在主页面上下文中使用Element.shadowRoot属性编写的JavaScript来访问影子DOM。</li><li id="4cee" class="ky kz in ke b kf mx ki my kl mz kp na kt nb kx ld le lf lg bi translated">{ mode:“closed”}—这意味着只能在Web组件中访问影子DOM。如果您使用{ mode: "closed"}将影子根附加到自定义元素，您将无法从外部访问影子DOM，即Element.shadowRoot将返回null。</li></ul><h1 id="ad6c" class="ma lr in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">HTML模板:</h1><p id="12ee" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在这里，我们可以为web组件定义HTML和CSS。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="31a8" class="lq lr in lm b gy ls lt l lu lv">const template = document.createElement("template");<br/>template.innerHTML = `<br/>  &lt;style&gt;<br/>     .hello-world h1 {<br/>      font-weight: bold;<br/>      font-family: sans-serif;<br/>      color: red;<br/>    }<br/>  &lt;/style&gt;<br/>  &lt;div class="hello-world"&gt;<br/>  &lt;h1&gt;Hello &lt;span id="name"&gt;&lt;/span&gt;!&lt;/h1&gt; <br/>  &lt;/div&gt;<br/>`;</span></pre><p id="c635" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更新构造函数以将我们的模板附加到影子DOM，并将name的初始值设置为“World”:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="f795" class="lq lr in lm b gy ls lt l lu lv">constructor() {<br/>    super();<br/>    this.shadow = this.attachShadow({ mode: "open" });<br/>    this.shadowRoot.appendChild(template.content.cloneNode(true));<br/>    this.shadowRoot.querySelector("#name").innerText = "World";<br/>  }</span></pre><p id="6928" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，当我们的web组件被添加到DOM时，我们还可以使用observedAttributes和attributeChangedCallback方法来更新名称。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="d62f" class="lq lr in lm b gy ls lt l lu lv">static get observedAttributes() {<br/>    return ["name"];<br/>  }<br/>attributeChangedCallback(property, oldValue, newValue) {<br/>    if (oldValue === newValue) return;<br/>    this[property] = newValue;<br/>  }<br/>connectedCallback() {<br/>    this.shadowRoot.querySelector("#name").innerText = this.name;<br/>  }</span></pre><figure class="lh li lj lk gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nh"><img src="../Images/dbe0d889d725e3fb32f5244a75d6b5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ai9SMt2pTGIDvCQ7h0sphg.gif"/></div></div></figure><p id="4b3c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整的JS代码:</p><figure class="lh li lj lk gt lx"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f26c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整代码:<a class="ae nk" href="https://codepen.io/AnkitSaxena2605/pen/dyeNYNN?editors=1010" rel="noopener ugc nofollow" target="_blank"> Codepen演示</a></p><p id="ffc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更多web组件示例:</p><ol class=""><li id="71aa" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx mw le lf lg bi translated">计数器:<a class="ae nk" href="https://codepen.io/AnkitSaxena2605/pen/OJZgOdg" rel="noopener ugc nofollow" target="_blank"> Codepen Demo </a></li><li id="64e4" class="ky kz in ke b kf mx ki my kl mz kp na kt nb kx mw le lf lg bi translated">编辑单词:<a class="ae nk" href="https://codepen.io/AnkitSaxena2605/pen/GRdEOzr" rel="noopener ugc nofollow" target="_blank"> Codepen演示</a></li></ol></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="242f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ns">更多内容请看</em><a class="ae nk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ns">plain English . io</em></strong></a><em class="ns">。报名参加我们的</em> <a class="ae nk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ns">免费周报</em> </strong> </a> <em class="ns">。关注我们关于</em><a class="ae nk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ns">Twitter</em></strong></a><a class="ae nk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ns">LinkedIn</em></strong></a><em class="ns"/><a class="ae nk" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ns">YouTube</em></strong></a><em class="ns"/><a class="ae nk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ns">不和</em> </strong> </a> <em class="ns">。对增长黑客感兴趣？检查</em> <a class="ae nk" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ns">电路</em> </strong> </a> <em class="ns">。</em></p></div></div>    
</body>
</html>