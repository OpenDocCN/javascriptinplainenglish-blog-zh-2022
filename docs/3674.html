<html>
<head>
<title>React Functional Components Using Refs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用引用对功能组件进行反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-functional-components-using-refs-a5ad1d2817d4?source=collection_archive---------2-----------------------#2022-09-16">https://javascript.plainenglish.io/react-functional-components-using-refs-a5ad1d2817d4?source=collection_archive---------2-----------------------#2022-09-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d460" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">forwardRef和useImperativeHandle的示例</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/be348ed520b4d053aaa9e0c6d1e8b9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjuZnAsQiGFIuE_-X-wGPQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">逆境中成长 — grow in adversity</figcaption></figure></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="d35a" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">我一直不清楚<em class="lv"> ref </em>和<em class="lv"> forwardRef </em>，在做了一些研究后，我想写一篇文章，用两个小例子来记录这个学习过程。</p><p id="236b" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">现在我们开门见山吧！</p><p id="e3dd" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在React的典型数据流中，<strong class="lb io">道具</strong>是父子组件交互的唯一方式，要修改一个孩子，你用新的道具重新渲染。</p><p id="5d21" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">当然，如<a class="ae lw" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> React官网</a>所述，除了React典型的数据流，在某些情况下(例如，聚焦一个DOM元素等。)为了修改子组件，我们可能需要另一种方式:<strong class="lb io"> Ref </strong>方式。Refs提供了一种访问DOM节点或React元素的方法。</p><p id="ba81" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><em class="lv">*由于本文使用了功能组件，所以我将重点介绍它们。</em></p><p id="49f8" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">让我们从第一个例子开始，这样我们可以更好地理解。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="c5ab" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="lb io">例一:焦点输入</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/55e3e48f6238ffa81ec961b0e8fc6e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*8IqanvZtylmFBWuUrZS72A.png"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ly"><img src="../Images/b223ac69f4dbd5a50aef93c48e9f1ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXnSEgIyTxlcvzSlRv_OUA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">cursor focused on input when a user clicks a button</figcaption></figure><p id="5a78" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">假设我们有一个输入字段，当用户开始输入或点击按钮时，我们希望光标聚焦在它上面。更有意义的是只修改<strong class="lb io">输入字段</strong>，而不是改变状态(通过<em class="lv"> props </em>)导致组件重新渲染，这可以通过创建一个引用来完成。</p><p id="2853" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">我们可以使用<em class="lv"> useRef() </em>钩子来创建一个Ref，它返回一个可变对象，其<strong class="lb io"> current </strong>属性设置为我们传递给钩子的初始值，并在DOM元素&lt;输入&gt;上使用它:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="2d88" class="me mf in ma b gy mg mh l mi mj">const inputRef = <strong class="ma io">useRef</strong>(null);</span><span id="f1a8" class="me mf in ma b gy mk mh l mi mj">&lt;input ref={<strong class="ma io">inputRef</strong>} type=”text” /&gt;</span><span id="98a7" class="me mf in ma b gy mk mh l mi mj">inputRef.current.focus() =&gt; focus input</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ml"><img src="../Images/733852025feea2ed103fb67d1495ec94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-J7qHQGYgHD0JlJ8Q9hUw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">console.log(inputRef)</figcaption></figure><p id="c9f9" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">非常简单，当用户开始输入时，输入字段会获得焦点，但是假设由于某种原因，当用户单击按钮时，这个输入字段也应该获得焦点，我们的输入字段位于名为<strong class="lb io"> InputWrapper </strong>的react子组件中。</p><p id="4781" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">也许我们会试着这样做:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="e72f" class="me mf in ma b gy mg mh l mi mj">const <strong class="ma io">Input</strong><strong class="ma io">Wrapper</strong> = <!-- -->({ref,...}) =&gt; &lt;&gt;<!-- -->&lt;input ref={<strong class="ma io">ref</strong>} .../&gt;...&lt;/&gt;</span><span id="d1b4" class="me mf in ma b gy mk mh l mi mj">export default function <strong class="ma io">App</strong>() {<br/>   const <strong class="ma io">inputRef</strong> = useRef(null);<br/>   const focusInput = () =&gt; inputRef.current.focus();<br/>   <!-- -->return (<br/>     // This will <strong class="ma io">NOT</strong> work!💥<br/>     &lt;<strong class="ma io">Input</strong><strong class="ma io">Wrapper</strong> ref={<strong class="ma io">inputRef</strong>}&gt;<br/>        <!-- -->&lt;button onClick={focusInput}&gt;...&lt;/button&gt;<br/>     &lt;/<strong class="ma io">Input</strong><strong class="ma io">Wrapper&gt;</strong>   <br/>)}}</span></pre><p id="4dba" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">👉这是行不通的，因为默认情况下，引用只在本地HTML元素中起作用，我们不能提供一个引用给React组件(在我们的例子中是<strong class="lb io"> InputWrapper) </strong>，而且由于函数组件没有实例，我们也不能在它上面使用<code class="fe mm mn mo ma b">ref</code>属性，这意味着:</p><blockquote class="mp mq mr"><p id="1ad5" class="kz la lv lb b lc ld jo le lf lg jr lh ms lj lk ll mt ln lo lp mu lr ls lt lu ig bi translated">常规函数或类组件不接收<code class="fe mm mn mo ma b">ref</code>参数，ref在<strong class="lb io"> props </strong>中也不可用。</p></blockquote><p id="81be" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">所以我们需要将我们的InputWrapper <strong class="lb io"> </strong>传递给<em class="lv"> forwardRef </em>，它接收props和传递给功能组件的refs，并返回JSX。它的元素。</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="cb04" class="me mf in ma b gy mg mh l mi mj">const InputWrapper = forwardRef((props, ref) =&gt; {…})</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/c8bcdac1fcb9c6d831274bf1dd2afb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQxg6JI1XU5671-1CiKMDg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">create and pass ref to InputWrapper inside App component</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/d44a26c54426ae39ef8eeade608f52dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N04EDKERR_COx7eBpINwJw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">button event handler inside App which triggers focus</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/33565ba7b708c0f9f853bb35a3b1ac38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWagJHiJiKsGF7eLtbGy5A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">forwarding ref to input DOM element</figcaption></figure><p id="2620" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">通过这样做，我们告诉React这个组件可以接受一个ref，我们的第二个参数<code class="fe mm mn mo ma b">InputWrapper</code>将是传入的ref。👉当我们用<code class="fe mm mn mo ma b">forwardRef</code>调用定义一个组件时，第二个<code class="fe mm mn mo ma b">ref</code>参数<strong class="lb io">只有</strong>存在。</p><p id="84b9" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><em class="lv">*引用转发在类组件</em>上也是可能的</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="fe22" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="lb io">例二:播放/暂停视频和焦点输入</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a96f68a1198443d8256293e7c39c59e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*fN_Eg9klA0Jsf0nrQNq7WA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">using useImperativeHandle for multiple refs</figcaption></figure><p id="478e" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在本例中，我们有一个视频播放器和两个按钮<strong class="lb io">播放/暂停</strong>视频，我们还希望在单击播放按钮时<strong class="lb io">聚焦</strong>下面的输入字段，这意味着我们将有多个引用(视频、输入)。</p><p id="8f60" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">如何转发多个引用？</p><p id="d0c2" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">🦋第一种解决方案:我们可以创建refs并把它们传递给一个对象，然后使用与上面例子中相同的逻辑。</p><p id="7444" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">父应用程序:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="631d" class="me mf in ma b gy mg mh l mi mj">export default function <strong class="ma io">App</strong>() {<br/>       const <strong class="ma io">videoRef</strong> = useRef();<br/>       const <strong class="ma io">focusRef</strong> = useRef();</span><span id="cc0e" class="me mf in ma b gy mk mh l mi mj">const focusInput = () =&gt; inputRef.current.focus();<br/>       const handlePlay = () =&gt; {<br/>           videoRef.current.play();<br/>           focusRef.current.focus();<br/>       };<br/>       const handlePause = () =&gt; {<br/>           videoRef.current.pause();<br/>       };</span><span id="c12f" class="me mf in ma b gy mk mh l mi mj">return (<br/>      &lt;<strong class="ma io">VideoWrapper</strong> <strong class="ma io">ref={{ videoRef, focusRef }}</strong>&gt; // 👉 pass refs<br/>         &lt;button onClick={handlePlay}&gt;Play&lt;/button&gt;<br/>         &lt;button onClick={handlePause}&gt;Pause&lt;/button&gt;<br/>      &lt;/<strong class="ma io">VideoWrapper</strong>&gt;<br/>   )</span></pre><p id="d399" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">子视频包装:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="1bb2" class="me mf in ma b gy mg mh l mi mj">function VideoWrapper(props, ref) {<br/>      <strong class="ma io">const { videoRef, focusRef } = ref; // 👉 </strong>destructure refs<br/>      return (<br/>       &lt;&gt; <br/>          &lt;video<br/>             ref={<strong class="ma io">videoRef</strong>}<br/>             width="..."<br/>             height="..."<br/>             controls<br/>             src={"..."}<br/>          /&gt;<br/>          {props.children}<br/>          &lt;input ref={<strong class="ma io">focusRef</strong>} ... /&gt;<br/>        &lt;/&gt;<br/>      );<br/>export default <strong class="ma io">forwardRef</strong>(VideoWrapper);</span></pre></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="8f9e" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">🦋第二种解决方案:使用React钩子<code class="fe mm mn mo ma b">useImperativeHandle</code></p><blockquote class="mp mq mr"><p id="cbfa" class="kz la lv lb b lc ld jo le lf lg jr lh ms lj lk ll mt ln lo lp mu lr ls lt lu ig bi translated">useImperativeHandle定制使用ref时暴露给父组件的实例值，应该与<strong class="lb io"> forwardRef </strong>一起使用。</p></blockquote><p id="e74d" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这听起来可能令人困惑，让我们首先更新组件:</p><p id="aa53" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在应用程序内部创建一个ref，并将其传递给VideoWrapper:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="85ac" class="me mf in ma b gy mg mh l mi mj">export default function App() {<br/><strong class="ma io">     const ref = useRef(null);<br/></strong>     const handlePlay = () =&gt; {<br/>        ref.current.<strong class="ma io">playVideo</strong>(); // 👉 exposed method <em class="lv"><br/>        </em>ref.current.<strong class="ma io">focusThisInput</strong>();<br/>      };<br/>     const handlePause = () =&gt; ref.current.<strong class="ma io">pauseMe</strong>();<br/>   return (<br/>     &lt;<strong class="ma io">VideoWrapper</strong> <strong class="ma io">ref={ref}</strong>&gt; // 👉 pass ref<br/>        &lt;button onClick={handlePlay}&gt;Play&lt;/button&gt;<br/>        &lt;button onClick={handlePause}&gt;Pause&lt;/button&gt;<br/>     &lt;/<strong class="ma io">VideoWrapper</strong>&gt;<br/>  )}</span></pre><p id="c76d" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在VideoWrapper组件内部，我们可以用<strong class="lb io">useImperativeHandle</strong>Hook确定哪些属性将在ref上公开(你可以随意称呼它们:<em class="lv"> playVideo </em>、<em class="lv"> focusThisInput、pauseMe </em>等。)</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="b728" class="me mf in ma b gy mg mh l mi mj">import { forwardRef, useImperativeHandle, useRef } from "react";</span><span id="c84c" class="me mf in ma b gy mk mh l mi mj">function VideoWrapper(props, ref) {<br/>    const <strong class="ma io">videoRef</strong> = useRef();<br/>    const <strong class="ma io">inputRef</strong> = useRef();</span><span id="40f7" class="me mf in ma b gy mk mh l mi mj"><strong class="ma io">    useImperativeHandle</strong>(<strong class="ma io">ref</strong>, () =&gt; ({<br/>        👇 <em class="lv">you can call them whatever you like<br/></em>         <strong class="ma io">playVideo</strong>: () =&gt; { <br/>             videoRef.current.play();<br/>       },<br/>         <strong class="ma io">pauseMe</strong>: () =&gt; {<br/>             videoRef.current.pause();<br/>       },<br/>         <strong class="ma io">focusThisInput</strong>: () =&gt; {<br/>             inputRef.current.focus();<br/>       }<br/>   }),[]);</span><span id="c302" class="me mf in ma b gy mk mh l mi mj">   return (<br/>      &lt;&gt;<br/>          &lt;video<br/>             ref={<strong class="ma io">videoRef</strong>}<br/>             width="..."<br/>             height="..."<br/>             controls<br/>             src={"..."}<br/>          /&gt;<br/>           {props.children}<br/>          &lt;input ref={<strong class="ma io">inputRef</strong>} .../&gt;<br/>      &lt;/&gt;<br/>  );<br/>}<br/>export default <strong class="ma io">forwardRef</strong>(VideoWrapper);</span></pre><p id="b1e1" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">上面的代码是什么意思？我们在<code class="fe mm mn mo ma b">useImperativeHandle</code>钩子内部添加方法，然后它们将被其父级公开和使用。🙌</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="e204" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">如上面的例子所示，我们可以使用钩子<em class="lv"> forwardRef </em>访问React功能子组件的底层DOM元素，我们可以处理多个引用，甚至可以通过使用<em class="lv"> useImperativeHandle将引用传递给其子组件来修改父组件可以访问的引用。</em></p><p id="7c9e" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">💡注意:<em class="lv"> useImperativeHandle </em>启用命令式代码，这违背了React的声明性本质，这使得React非常独特。因为这个原因，除非绝对需要，一般建议避免这个钩子。</p><p id="e19d" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">你可以在这里看到结果并尝试一下<a class="ae lw" href="https://codesandbox.io/s/ref-fowardref-2ocgbh?file=/src/App.js:1226-1250" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="5b92" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">就是这样！我相信有更好的方法和解决方案，这里我只是想分享我到目前为止学到的东西，希望你对这些例子感兴趣。感谢您的宝贵时间！⏰</p><p id="d49f" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">如果你也对我的其他文章感兴趣，这里有一些链接:</p><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/create-a-simple-express-server-node-js-for-react-application-e2b2bd0c7e93"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">为React应用程序创建一个简单的Express服务器(Node.js)</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">关于如何创建一个简单的Express服务器(Node.js)、将其连接到React应用程序以及解决错误的教程…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nl l"><div class="nm l nn no np nl nq km nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/use-session-storage-to-persist-state-within-a-react-component-206867ef2269"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">使用会话存储来保持React组件中的状态</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">当页面会话结束时，sessionStorage中的数据将被清除。</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nl l"><div class="nr l nn no np nl nq km nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://medium.com/geekculture/hide-and-replace-sticky-element-on-scrolling-in-a-react-way-8bc3f04e2a81" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">以反应方式隐藏和替换滚动时的粘性元素</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">—棘手但有趣🍡</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="ns l nn no np nl nq km nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://enlear.academy/create-responsive-iframe-embed-in-a-react-way-f52075bf3b04" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">创建以反应方式嵌入的响应iframe</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">—令人惊讶的是，YouTube没有相应的嵌入代码🦄，我们来玩css吧…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">enlear .学院</p></div></div><div class="nl l"><div class="nt l nn no np nl nq km nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/create-a-simple-react-custom-hook-fc733d7b977a"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">创建一个简单的React自定义挂钩</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">关于如何创建一个简单的React自定义钩子的教程</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nl l"><div class="nu l nn no np nl nq km nc"/></div></div></a></div></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="4970" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><em class="lv">更多内容请看</em><a class="ae lw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="lv">plain English . io</em></strong></a><em class="lv">。报名参加我们的</em> <a class="ae lw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="lv">免费周报</em> </strong> </a> <em class="lv">。关注我们关于</em><a class="ae lw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="lv">Twitter</em></strong></a><a class="ae lw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="lv">LinkedIn</em></strong></a><em class="lv"/><a class="ae lw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="lv">YouTube</em></strong></a><em class="lv"/><a class="ae lw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="lv">不和</em> </strong> </a> <em class="lv">。对增长黑客感兴趣？检查</em> <a class="ae lw" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="lv">电路</em> </strong> </a> <em class="lv">。</em></p></div></div>    
</body>
</html>