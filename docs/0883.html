<html>
<head>
<title>TypeScript Accessor Decorators In-Depth: Take Control Over 'get' and 'set' Accessor Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入的TypeScript访问器装饰器:控制“get”和“set”访问器方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9?source=collection_archive---------13-----------------------#2022-02-18">https://javascript.plainenglish.io/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9?source=collection_archive---------13-----------------------#2022-02-18</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="a1e8" class="pw-subtitle-paragraph js iq ir bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">探索访问器装饰器的使用和开发。</h2></div><figure class="kl km kn ko gu kp gi gj paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gi gj kk"><img src="../Images/318355d102b8b4b2baa9c4f6f83c3285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QzKCJni2nMM_MMtB.png"/></div></div></figure><p id="b990" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">Decorators允许我们在TypeScript中向类或方法添加额外的信息，类似于Java中的注释。访问器装饰器应用于TypeScript中的访问器方法定义，可以观察或修改通过<em class="ls"> get/set </em>函数访问的数据。只要小心，它们可以用于高级功能，如运行时数据验证。</p><p id="b937" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在本文中，我们将探索访问器装饰器的使用和开发。一个访问器是<code class="fe jo jp jq jr b">get</code>或<code class="fe jo jp jq jr b">set</code>方法，我们通过它使用代码来创建或多或少的属性。也就是说，通常我们对现有属性使用<code class="fe jo jp jq jr b">get</code>和/或<code class="fe jo jp jq jr b">set</code>，但是它们也可以与属性分开使用。计算出的值可以通过<code class="fe jo jp jq jr b">get</code>函数传递，例如，一个圆形对象可以存储半径，而<code class="fe jo jp jq jr b">get area</code>访问器可以通过计算<code class="fe jo jp jq jr b">PI*R**2</code>告诉我们圆形的面积。要使用decorator，必须在TypeScript中启用它们，所以请务必<a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">阅读本系列的decorator介绍文章</a>。</p><p id="ca48" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">访问器装饰器被附加到<code class="fe jo jp jq jr b">get</code>或<code class="fe jo jp jq jr b">set</code>方法上，无论哪一个在文本中最先出现，都会影响这两个方法。</p><p id="e842" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">实际上，它们看起来像这样:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="5c58" class="ly lz ir jr b gz ma mb l mc md">class Example {<br/><br/>    #name: string;<br/><br/>    @Decorator<br/>    set name(n: string) { this.#name = n; }<br/>    get name() { return #name; }<br/><br/>    #width: number;<br/>    #height: number;<br/><br/>    @Decorator<br/>    get area() { return this.#width * this.#height; }<br/>}</span></pre><p id="5af2" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如果您没有意识到这一点，那么<code class="fe jo jp jq jr b">#fieldName</code>是JavaScript中的一个新特性，TypeScript也支持它，可以为字段数据提供适当的隐私。这些私有字段只能从类内部访问。</p><p id="b7aa" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于<code class="fe jo jp jq jr b">name</code>,访问器函数与同名的现有属性直接相关。对于<code class="fe jo jp jq jr b">area</code>，访问函数基于另外两个属性计算其值。这个具体的例子是不完整的，因为<code class="fe jo jp jq jr b">#width</code>和<code class="fe jo jp jq jr b">#height</code>不能设置它们的值。</p><p id="1932" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文是系列文章的一部分:</p><ul class=""><li id="60bb" class="me mf ir ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">装修工介绍</a></li><li id="5662" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae lt" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装修工</a></li><li id="c0a7" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">物业装修工</a></li><li id="fc1e" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><strong class="ky is">访问者装饰者</strong> <em class="ls">本文</em></li><li id="53f4" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">参数装饰器</a></li><li id="502e" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">方法装饰者</a></li><li id="a03f" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0">混合装修工</a></li><li id="b88b" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7">通过装饰器使用反射和反射API</a></li></ul><h1 id="e99a" class="ms lz ir bd mt mu mv mw mx my mz na nb kb nc kc nd ke ne kf nf kh ng ki nh ni bi translated">TypeScript中的访问器装饰函数</h1><p id="7d0d" class="pw-post-body-paragraph kw kx ir ky b kz nj jw lb lc nk jz le lf nl lh li lj nm ll lm ln nn lp lq lr ik bi translated">访问器装饰器附加到访问器方法上。访问器可能与同名的属性关联，也可能不关联。</p><p id="86cc" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">访问器装饰函数接收三个参数:</p><ol class=""><li id="1743" class="me mf ir ky b kz la lc ld lf mg lj mh ln mi lr no mk ml mm bi translated">静态成员的类的构造函数或实例成员的类的原型。</li><li id="0e81" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr no mk ml mm bi translated">成员的名称。</li><li id="7f14" class="me mf ir ky b kz mn lc mo lf mp lj mq ln mr lr no mk ml mm bi translated">成员的属性描述符。</li></ol><p id="7281" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这些参数与属性装饰器的参数相同，但是增加了<em class="ls"> PropertyDescriptor </em>对象。对于<a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">属性装饰器</a>，我们遇到了一些限制，因为它们不接收这个对象。这使得访问器装饰器在应用程序必须有这个描述符的情况下非常有用。</p><p id="a58d" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">属性描述符</em>的定义如下:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="cbfa" class="ly lz ir jr b gz ma mb l mc md">interface PropertyDescriptor {<br/>    configurable?: boolean;<br/>    enumerable?: boolean;<br/>    value?: any;<br/>    writable?: boolean;<br/>    get?(): any;<br/>    set?(v: any): void;<br/>}</span></pre><p id="8f08" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在实现decorators时，我们将以几种方式使用这个对象。</p><h1 id="04b0" class="ms lz ir bd mt mu mv mw mx my mz na nb kb nc kc nd ke ne kf nf kh ng ki nh ni bi translated">TypeScript中访问器修饰符的简单示例</h1><p id="3117" class="pw-post-body-paragraph kw kx ir ky b kz nj jw lb lc nk jz le lf nl lh li lj nm ll lm ln nn lp lq lr ik bi translated">让我们从一个简单的例子开始探索，这个例子打印了装饰函数接收到的信息。</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="eb3a" class="ly lz ir jr b gz ma mb l mc md">function LogAccessor(target: Object, propertyKey: string,<br/>                    descriptor: PropertyDescriptor) {<br/><br/>    console.log(`LogAccessor`, {<br/>        target, propertyKey, descriptor<br/>    });<br/>}<br/><br/>class Simple {<br/><br/>    #num: number;<br/><br/>    @LogAccessor<br/>    set num(w: number) { this.#num = w; }<br/>    get num() { return this.#num; }<br/>}</span></pre><p id="cb6f" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">访问器装饰器附加到这两个方法之一。不允许向两者都添加装饰器。取而代之的是，您将一个装饰器附加到文档顺序中出现的第一个。</p><p id="a682" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如果您将一个装饰器附加到两者上，您将得到以下错误消息:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="1d98" class="ly lz ir jr b gz ma mb l mc md">error TS1207: Decorators cannot be applied to multiple get/set accessors of the same name.</span></pre><p id="20d8" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">所以，不要那么做。</p><p id="cf2a" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">若要测试此代码，请添加以下内容:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="94f7" class="ly lz ir jr b gz ma mb l mc md">const s1 = new Simple();<br/>const s2 = new Simple();<br/><br/>s1.num = 1;<br/>s2.num = 1;<br/>console.log(`${s1.num} ${s2.num}`);<br/><br/>s1.num = s1.num + s2.num;<br/>s2.num = s1.num + s2.num;<br/>console.log(`${s1.num} ${s2.num}`);<br/><br/>s1.num = s1.num + s2.num;<br/>s2.num = s1.num + s2.num;<br/>console.log(`${s1.num} ${s2.num}`);<br/><br/>s1.num = s1.num + s2.num;<br/>s2.num = s1.num + s2.num;<br/>console.log(`${s1.num} ${s2.num}`);<br/><br/>s1.num = s1.num + s2.num;<br/>s2.num = s1.num + s2.num;<br/>console.log(`${s1.num} ${s2.num}`);<br/><br/>s1.num = s1.num + s2.num;<br/>s2.num = s1.num + s2.num;<br/>console.log(`${s1.num} ${s2.num}`);</span></pre><p id="7ecc" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们可以运行它来查看输出:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="827e" class="ly lz ir jr b gz ma mb l mc md">$ npx ts-node lib/accessors/first.ts <br/>LogAccessor {<br/>  target: {},<br/>  propertyKey: 'num',<br/>  descriptor: {<br/>    get: [Function: get num],<br/>    set: [Function: set num],<br/>    enumerable: false,<br/>    configurable: true<br/>  }<br/>}<br/>1 1<br/>2 3<br/>5 8<br/>13 21<br/>34 55<br/>89 144</span></pre><p id="0882" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如果你认识到这里计算的数学序列，那就太棒了。</p><p id="c0aa" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">无论如何，我们看到<code class="fe jo jp jq jr b">target</code>是一个空对象，而<code class="fe jo jp jq jr b">propertyKey</code>是属性的名称。<code class="fe jo jp jq jr b">descriptor</code>包含<code class="fe jo jp jq jr b">get</code>和<code class="fe jo jp jq jr b">set</code>功能，标记为<code class="fe jo jp jq jr b">non-enumerable</code>和<code class="fe jo jp jq jr b">configurable</code>。<code class="fe jo jp jq jr b">get</code>和<code class="fe jo jp jq jr b">set</code>字段的内容是我们在代码中编写的函数。</p><p id="14da" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们用一个计算的访问函数得到什么描述符对象？为了找到答案，让我们创建一个新的简单示例:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="59a6" class="ly lz ir jr b gz ma mb l mc md">function LogAccessor(target: Object,<br/>    propertyKey: string,<br/>    descriptor: PropertyDescriptor) { .. as above }<br/><br/>class Rectangle {<br/>    #width: number;<br/>    #height: number;<br/><br/>    @LogAccessor<br/>    get area() { <br/>        return this.#width * this.#height;<br/>    }<br/><br/>    constructor(width: number, height: number) {<br/>        this.#width = width;<br/>        this.#height = height;<br/>    }<br/>}<br/><br/>const r1 = new Rectangle(3, 5);<br/>console.log(r1.area);</span></pre><p id="f818" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">矩形</em>类没有名为<code class="fe jo jp jq jr b">area</code>的属性，并且<code class="fe jo jp jq jr b">get area</code>函数的值是从<code class="fe jo jp jq jr b">width</code>和<code class="fe jo jp jq jr b">height</code>值计算出来的。</p><p id="753b" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">运行它，我们得到:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="5947" class="ly lz ir jr b gz ma mb l mc md">$ npx ts-node lib/accessors/rectangle.ts <br/>LogAccessor {<br/>  target: {},<br/>  propertyKey: 'area',<br/>  descriptor: {<br/>    get: [Function: get area],<br/>    set: undefined,<br/>    enumerable: false,<br/>    configurable: true<br/>  }<br/>}<br/>15</span></pre><p id="09bd" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在这种情况下，生成的PropertyDescriptor只有一个<code class="fe jo jp jq jr b">get</code>函数，其他方面与前面的示例相同。由于只创建了一个<code class="fe jo jp jq jr b">get</code>函数，这是意料之中的。</p><h1 id="0bcd" class="ms lz ir bd mt mu mv mw mx my mz na nb kb nc kc nd ke ne kf nf kh ng ki nh ni bi translated">监视类中的访问器活动</h1><p id="4691" class="pw-post-body-paragraph kw kx ir ky b kz nj jw lb lc nk jz le lf nl lh li lj nm ll lm ln nn lp lq lr ik bi translated">作为我们可以用PropertyDescriptor做什么的第一个探索，让我们实现一个装饰器，它通过访问器打印<code class="fe jo jp jq jr b">get</code> / <code class="fe jo jp jq jr b">set</code>活动。</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="4771" class="ly lz ir jr b gz ma mb l mc md">function AccessorSpy&lt;T&gt;() {<br/>    return function (target: Object, propertyKey: string,<br/>                    descriptor: PropertyDescriptor) {<br/><br/>        const originals = {<br/>            get: descriptor.get,<br/>            set: descriptor.set<br/>        };<br/>        if (originals.get) {<br/>            descriptor.get = function (): T {<br/>                const ret: T = originals.get.call(this);<br/>                console.log(`AccessorSpy get ${String(propertyKey)}`, ret);<br/>                return ret;<br/>            };<br/>        }<br/>        if (originals.set) {<br/>            descriptor.set = function(newval: T) {<br/>                console.log(`AccessorSpy set ${String(propertyKey)}`, newval);<br/>                originals.set.call(this, newval);<br/>            };<br/>        }<br/>    }<br/>}</span></pre><p id="097a" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是从存储库中的<code class="fe jo jp jq jr b"><a class="ae lt" href="https://github.com/robogeek/typescript-decorators-examples/tree/main/decorator-inspectors" rel="noopener ugc nofollow" target="_blank">decorator-inspectors</a></code>包中复制的。</p><p id="c5fa" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们使用泛型语法来传递访问器应该使用的数据类型。这个修饰器可以和任何访问器一起使用，所以我们必须使用正确的数据类型。</p><p id="b4a4" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们也尊重现有的访问函数。我们将<code class="fe jo jp jq jr b">set</code>和<code class="fe jo jp jq jr b">get</code>都保存到<code class="fe jo jp jq jr b">originals</code>对象中。然后，对于这两者，我们用一个调用原始函数的函数替换任何现有的函数，然后打印其结果。</p><p id="44cf" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这个替换函数要求，当调用原始函数时，<code class="fe jo jp jq jr b">this</code>具有正确的值。<code class="fe jo jp jq jr b">this</code>的值必须是调用getter或setter访问器所针对的对象实例。经过几次变化之后——例如，箭头函数不能作为替换函数使用——这里显示的模式被发现能够正确工作。</p><p id="9bc1" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">内部函数中<code class="fe jo jp jq jr b">this</code>的值与内部函数相关。但是，<code class="fe jo jp jq jr b">descriptor.get</code>和<code class="fe jo jp jq jr b">descriptor.set</code>替换函数，以及<code class="fe jo jp jq jr b">originals.get</code>和<code class="fe jo jp jq jr b">originals.set</code>，必须在<code class="fe jo jp jq jr b">this</code>设置为正确的对象实例的情况下执行。使用<code class="fe jo jp jq jr b">call</code>方法让我们在为<code class="fe jo jp jq jr b">this</code>设置值的同时调用一个函数。</p><p id="2c86" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要测试这一点:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="c42d" class="ly lz ir jr b gz ma mb l mc md">class ToSpy {<br/>    #num: number;<br/><br/>    @AccessorSpy&lt;number&gt;()<br/>    set num(w: number) { this.#num = w; }<br/>    get num() { return this.#num; }<br/><br/>}<br/><br/>const tsp1 = new ToSpy();<br/>const tsp2 = new ToSpy();<br/><br/>tsp1.num = 1;<br/>tsp2.num = 2;<br/>console.log(`${tsp1.num} ${tsp2.num}`);<br/><br/>tsp1.num = tsp1.num + tsp2.num;<br/>tsp2.num = tsp1.num + tsp2.num;<br/>console.log(`${tsp1.num} ${tsp2.num}`);<br/><br/>tsp1.num = tsp1.num + tsp2.num;<br/>tsp2.num = tsp1.num + tsp2.num;<br/>console.log(`${tsp1.num} ${tsp2.num}`);<br/><br/>tsp1.num = tsp1.num + tsp2.num;<br/>tsp2.num = tsp1.num + tsp2.num;<br/>console.log(`${tsp1.num} ${tsp2.num}`);</span></pre><p id="9649" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们希望确定，当我们设置属性的值时，它只影响给定的对象实例，并且每个对象实例都有不同的值。</p><p id="9358" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">当执行时，我们得到这个:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="0d0a" class="ly lz ir jr b gz ma mb l mc md">$ npx ts-node lib/accessors/spy.ts <br/>AccessorSpy set num 1<br/>AccessorSpy set num 2<br/>AccessorSpy get num 1<br/>AccessorSpy get num 2<br/>1 2<br/>AccessorSpy get num 1<br/>AccessorSpy get num 2<br/>AccessorSpy set num 3<br/>AccessorSpy get num 3<br/>AccessorSpy get num 2<br/>AccessorSpy set num 5<br/>AccessorSpy get num 3<br/>AccessorSpy get num 5<br/>3 5<br/>AccessorSpy get num 3<br/>AccessorSpy get num 5<br/>AccessorSpy set num 8<br/>AccessorSpy get num 8<br/>AccessorSpy get num 5<br/>AccessorSpy set num 13<br/>AccessorSpy get num 8<br/>AccessorSpy get num 13<br/>8 13<br/>AccessorSpy get num 8<br/>AccessorSpy get num 13<br/>AccessorSpy set num 21<br/>AccessorSpy get num 21<br/>AccessorSpy get num 13<br/>AccessorSpy set num 34<br/>AccessorSpy get num 21<br/>AccessorSpy get num 34<br/>21 34</span></pre><p id="8ebb" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">事实上，我们可以看到AccessorSpy函数为我们提供了一个关于这个对象的<code class="fe jo jp jq jr b">get</code> / <code class="fe jo jp jq jr b">set</code>活动的很好的视图。而且，我们看到这两个实例之间的值仍然不同。</p><h1 id="a931" class="ms lz ir bd mt mu mv mw mx my mz na nb kb nc kc nd ke ne kf nf kh ng ki nh ni bi translated">使用访问器装饰器控制可枚举设置</h1><p id="bb57" class="pw-post-body-paragraph kw kx ir ky b kz nj jw lb lc nk jz le lf nl lh li lj nm ll lm ln nn lp lq lr ik bi translated">我们希望将一些访问器视为任何其他属性。到目前为止，PropertyDescriptor的<code class="fe jo jp jq jr b">enumerable</code>字段是<code class="fe jo jp jq jr b">false</code>。但是，如果我们希望访问器返回的值包含在由<code class="fe jo jp jq jr b">for...in</code>或<code class="fe jo jp jq jr b">for..of</code>循环扫描的字段中，那该怎么办呢？这意味着将<code class="fe jo jp jq jr b">enumerable</code>设置为<code class="fe jo jp jq jr b">true</code>。</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="ffd0" class="ly lz ir jr b gz ma mb l mc md">export function Enumerable(val: boolean) {<br/>    return (target: Object, propertyKey: string,<br/>        descriptor: PropertyDescriptor)  =&gt; {<br/><br/>        if (typeof val !== 'undefined') {<br/>            descriptor.enumerable = val;<br/>        }<br/>    }<br/>}<br/><br/>class SetEnumerable {<br/><br/>    #num: number;<br/><br/>    @LogAccessor<br/>    @Enumerable(true)<br/>    @LogAccessor<br/>    @AccessorSpy&lt;number&gt;()<br/>    set num(w: number) { this.#num = w; }<br/>    get num() { return this.#num; }<br/><br/>}<br/><br/>const en1 = new SetEnumerable();<br/><br/>en1.num = 1;<br/>for (let key in en1) {<br/>    console.log(`en1 ${key} ${en1[key]}`);<br/>}</span></pre><p id="979a" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">好吧，我们可能有点喜欢装修。但是，我们使用我们的工具来打印每个步骤的有用信息。</p><p id="fd52" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">可枚举的</em>装饰器简单地在描述符中设置<code class="fe jo jp jq jr b">enumerable</code>标志。我们传入<code class="fe jo jp jq jr b">true</code>或者<code class="fe jo jp jq jr b">false</code>，很简单。我们在之前和之后都使用了<em class="ls"> LogAccessor </em>来确保看到设置被更改。并且，我们使用<em class="ls"> AccessorSpy </em>来跟踪<code class="fe jo jp jq jr b">num</code>访问器上的活动。</p><p id="d68f" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">然后，我们生成一个实例并设置一个值。实际上,<code class="fe jo jp jq jr b">for..in</code>循环让我们知道访问器是否是可枚举的。如果是，<code class="fe jo jp jq jr b">num</code>将作为循环中扫描的一个键出现。</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="1194" class="ly lz ir jr b gz ma mb l mc md">$ npx ts-node lib/accessors/enumerable.ts <br/>LogAccessor {<br/>  target: {},<br/>  propertyKey: 'num',<br/>  descriptor: {<br/>    get: [Function (anonymous)],<br/>    set: [Function (anonymous)],<br/>    enumerable: false,<br/>    configurable: true<br/>  }<br/>}<br/>LogAccessor {<br/>  target: {},<br/>  propertyKey: 'num',<br/>  descriptor: {<br/>    get: [Function (anonymous)],<br/>    set: [Function (anonymous)],<br/>    enumerable: true,<br/>    configurable: true<br/>  }<br/>}<br/>AccessorSpy set num 1<br/>AccessorSpy get num 1<br/>en1 num 1</span></pre><p id="e0cc" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">事实上，第二个<code class="fe jo jp jq jr b">LogAccessor</code>输出显示<code class="fe jo jp jq jr b">enumerable</code>被设置为<code class="fe jo jp jq jr b">true</code>。然后，在底部我们看到循环内部的打印输出，表明<code class="fe jo jp jq jr b">num</code>作为一个键被返回。为了验证这一点，设置<code class="fe jo jp jq jr b">Enumerable(false)</code>并重新运行脚本以确保当<code class="fe jo jp jq jr b">enumerable</code>为<code class="fe jo jp jq jr b">false</code>时不打印最后一行。</p><h1 id="57c2" class="ms lz ir bd mt mu mv mw mx my mz na nb kb nc kc nd ke ne kf nf kh ng ki nh ni bi translated">使用访问器装饰器的简单运行时数据验证</h1><p id="71c9" class="pw-post-body-paragraph kw kx ir ky b kz nj jw lb lc nk jz le lf nl lh li lj nm ll lm ln nn lp lq lr ik bi translated">我们刚刚证明的是，一个访问器装饰器可以用我们将在运行时执行的代码覆盖<code class="fe jo jp jq jr b">get</code> / <code class="fe jo jp jq jr b">set</code>函数。我们用这个来监视进出房产的数据。</p><p id="0d58" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">但是，我们可以用这种新发现的力量做更多的事情。也就是说，我们可以实现运行时数据验证。</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="4bab" class="ly lz ir jr b gz ma mb l mc md">function Validate&lt;T&gt;(validator: Function) {<br/>    return (target: Object, propertyKey: string,<br/>        descriptor: PropertyDescriptor) =&gt; {<br/>        <br/>        const originals = {<br/>            get: descriptor.get,<br/>            set: descriptor.set<br/>        };<br/>        if (originals.set) {<br/>            descriptor.set = function(newval: T) {<br/>                console.log(`Validate set ${String(propertyKey)}`, newval);<br/>                if (validator) {<br/>                    if (!validator(newval)) {<br/>                        throw new Error(`Invalid value for ${propertyKey} -- ${newval}`);<br/>                    }<br/>                }<br/>                originals.set.call(this, newval);<br/>            };<br/>        }<br/>    }<br/>}<br/><br/>class CarSeen {<br/><br/>    #speed: number;<br/><br/>    @Validate&lt;number&gt;((speed: number) =&gt; {<br/>        console.log(`Validate speed ${speed}`);<br/>        if (typeof speed !== 'number') return false;<br/>        if (speed &lt; 10 || speed &gt; 65) return false;<br/>        return true;<br/>    })<br/>    set speed(speed) {<br/>        console.log(`set speed ${speed}`);<br/>        this.#speed = speed; }<br/>    get speed() { return this.#speed; }<br/><br/>}</span></pre><p id="485c" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls"> Validate </em>是一个装饰器工厂，它接受一个我们将用于验证的函数。在内部函数中，我们只覆盖了<code class="fe jo jp jq jr b">set</code>访问器。这是因为我们想确保不正确的值永远不会到达这个属性。</p><p id="842f" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在我们的<code class="fe jo jp jq jr b">set</code>函数中，如果<code class="fe jo jp jq jr b">validator</code>函数存在，我们称之为提供候选值。如果返回<code class="fe jo jp jq jr b">true</code>，我们说一切都好，继续调用最初的setter，否则我们抛出一个错误。</p><p id="aa1c" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们在每个地方都添加了<code class="fe jo jp jq jr b">console.log</code>语句，以确保所有步骤都按预期进行。</p><p id="2337" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要测试它，请将以下内容添加到脚本中:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="5b7d" class="ly lz ir jr b gz ma mb l mc md">const cs1 = new CarSeen();<br/>cs1.speed = 22;<br/>console.log(cs1.speed);<br/><br/>cs1.speed = 33;<br/>console.log(cs1.speed);<br/><br/>cs1.speed = 44;<br/>console.log(cs1.speed);<br/><br/>cs1.speed = 55;<br/>console.log(cs1.speed);<br/><br/>cs1.speed = 66;<br/>console.log(cs1.speed);</span></pre><p id="62a3" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">当执行时，我们得到这个:</p><pre class="kl km kn ko gu lu jr lv lw aw lx bi"><span id="233d" class="ly lz ir jr b gz ma mb l mc md">$ npx ts-node lib/accessors/validation.ts <br/>Validate set speed 22<br/>Validate speed 22<br/>set speed 22<br/>22<br/>Validate set speed 33<br/>Validate speed 33<br/>set speed 33<br/>33<br/>Validate set speed 44<br/>Validate speed 44<br/>set speed 44<br/>44<br/>Validate set speed 55<br/>Validate speed 55<br/>set speed 55<br/>55<br/>Validate set speed 66<br/>Validate speed 66<br/>.../simple/lib/accessors/validation.ts:16<br/>                        throw new Error(`Invalid value for ${propertyKey} -- ${newval}`);<br/>                              ^<br/>Error: Invalid value for speed -- 66</span></pre><p id="73ad" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们可以设置任何我们想要的速度，直到设置一个超出指定范围的值。</p><p id="1aae" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是运行时数据验证。我们分配了一个无效值，验证装饰器确保防止该值污染属性。跟随消息，你会看到每一步都被执行了。对于我们的无效值，执行了前两步，但是，因为抛出了异常，所以最后一步没有执行。因此，属性的值未被修改。</p><h1 id="c5dd" class="ms lz ir bd mt mu mv mw mx my mz na nb kb nc kc nd ke ne kf nf kh ng ki nh ni bi translated">摘要</h1><p id="f26e" class="pw-post-body-paragraph kw kx ir ky b kz nj jw lb lc nk jz le lf nl lh li lj nm ll lm ln nn lp lq lr ik bi translated">从创建和使用访问器装饰器，到自动化运行时数据验证的基础，我们已经了解了很多。</p><p id="5eaf" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">因为访问器装饰器给了我们PropertyDescriptor对象，所以我们可以做很多事情，只要我们小心地去做。特别是，当更换<code class="fe jo jp jq jr b">get</code>和<code class="fe jo jp jq jr b">set</code>功能时，我们必须仔细确保更换功能在<code class="fe jo jp jq jr b">this</code>设置正确的情况下执行。</p><p id="cee8" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这种数据验证的方法是最成熟的。其他数据验证包要求程序员显式编码数据验证。这使得它成为一件很容易忘记去做的事情，对吗？使用这种方法，您可以附加decorators，然后对属性的每个赋值都运行验证，并且您可以确信疯狂的数据值不会进入任何受保护的属性。</p><h1 id="bc1e" class="ms lz ir bd mt mu mv mw mx my mz na nb kb nc kc nd ke ne kf nf kh ng ki nh ni bi translated">关于作者</h1><p id="da71" class="pw-post-body-paragraph kw kx ir ky b kz nj jw lb lc nk jz le lf nl lh li lj nm ll lm ln nn lp lq lr ik bi translated"><a class="ae lt" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">大卫·赫伦</em> </strong> </a> <em class="ls">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl np nq hv nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ik il im in io"><p id="c550" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">最初发表于</em><a class="ae lt" href="https://techsparx.com/nodejs/typescript/decorators/accessors.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://techsparx.com</em></a><em class="ls">。</em></p><p id="59f5" class="pw-post-body-paragraph kw kx ir ky b kz la jw lb lc ld jz le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="ls">更多内容请看</em> <a class="ae lt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">说白了就是</em> </strong> </a> <em class="ls">。报名参加我们的</em> <a class="ae lt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">免费每周简讯</em> </strong> </a> <em class="ls">。在我们的</em> <a class="ae lt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="ls">社区不和谐</em> </strong> </a> <em class="ls">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>