<html>
<head>
<title>Patterns And Best Practices In JavaScript: Dealing With Callback Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的模式和最佳实践:处理回调函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/patterns-and-best-practices-in-javascript-dealing-with-callback-functions-dbf5d7303261?source=collection_archive---------4-----------------------#2022-06-07">https://javascript.plainenglish.io/patterns-and-best-practices-in-javascript-dealing-with-callback-functions-dbf5d7303261?source=collection_archive---------4-----------------------#2022-06-07</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="49c8" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">与任何其他编程语言一样，JavaScript有许多最佳实践和相关的不良实践。由于其动态特性，JavaScript也有各种各样的陷阱。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/cc13be0fc8a5659ba5e201ef796d6e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIPNoJF9WkwdoddofBCxaw.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@carlheyerdahl?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Carl Heyerdahl</a> / <a class="ae kw" href="https://unsplash.com/s/photos/technology-software-deve?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fb12" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与任何其他编程语言一样，JavaScript有许多最佳实践和相关的不良实践。由于其动态特性，JavaScript也有各种各样的陷阱。</p><p id="7019" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">回调函数是作为参数传递给其他函数并由它们调用的函数。它们是异步JavaScript开发中常见的设计模式。这种设计模式的基本(还不是最佳)结构如下:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><p id="b526" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lv lw lx ly b">doStuff()</code>函数需要一个函数作为参数，并在特定的时间点调用它:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><h1 id="850d" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">检查回调函数类型</h1><p id="1862" class="pw-post-body-paragraph kx ky ir kz b la mr js lc ld ms jv lf lg mt li lj lk mu lm ln lo mv lq lr ls ik bi translated">由于JavaScript的弱类型，一个期望(回调)函数作为参数的函数原则上也可以被传递任何其他值(或者根本没有值)。但是，调用这个假定的函数不可避免地会导致类型错误(“回调不是函数”)。根据上面的示例，以下调用是可能的，但不可取:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><p id="7a3e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，首先检查函数内部回调参数的类型并确保它确实是一个函数是很重要的。这可以通过使用<code class="fe lv lw lx ly b">typeof</code>操作符来实现，如下面的清单所示。如果它为所传递的参数返回值“function ”,那么它就是一个函数，没有任何东西会妨碍它的调用:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><p id="25f8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果在一个函数中有几个地方可以调用回调函数，那么这个检查必须在所有这些地方之前进行:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><p id="d4d5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果在函数的开头执行检查，并且在回调参数不是函数的情况下，简单地用一个匿名的空函数重新定义它，就可以避免这种情况，如下所示。这个简单而有效的技巧一下子保护了对回调函数的所有以下调用:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><p id="fb94" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在条件操作符的帮助下，整个事情甚至可以简化为一行代码:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><h1 id="7bde" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">回调函数的参数</h1><p id="9c10" class="pw-post-body-paragraph kx ky ir kz b la mr js lc ld ms jv lf lg mt li lj lk mu lm ln lo mv lq lr ls ik bi translated">因为回调函数是异步调用的，既不能提供直接返回值也不能抛出错误，所以至少应该为这两种情况提供适当的参数:</p><ol class=""><li id="d650" class="mw mx ir kz b la lb ld le lg my lk mz lo na ls nb nc nd ne bi translated">一个参数包含关于在错误事件中发生的错误的信息，</li><li id="5789" class="mw mx ir kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated">一个通常包含异步计算结果的参数。</li></ol><p id="5626" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">即使这两个参数的顺序原则上并不重要，但它已经成为一种约定——尤其是在开发Node.js模块时——将错误列为第一个参数，将结果列为第二个参数(如果没有错误，第一个参数对应零)。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><p id="7b99" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可以在回调函数中使用简单的if查询来确定是否发生了错误:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><h1 id="637d" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">回叫呼叫的返回</h1><p id="68bf" class="pw-post-body-paragraph kx ky ir kz b la mr js lc ld ms jv lf lg mt li lj lk mu lm ln lo mv lq lr ls ik bi translated">在某些情况下，调用前面例子中显示的回调函数会导致意外的程序行为。例如，在倒数第二个清单中，回调函数被调用两次，以防出现错误。</p><p id="b433" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面是代码:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><p id="df33" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里的问题是，try-catch块之后的代码总是会被调用。即使catch块先前由于错误而被跳转，并且在那里调用了回调函数。这是一个你在阅读源代码时很容易忽略的事实。因此，您应该在每次调用回调函数之前放置一个“return ”,它直接跳出调用函数。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><p id="d52a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当然，这样做的先决条件是调用函数的结构是相应的，并且回调函数的调用总是表示函数的结束。</p><p id="088b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">例如，下面的代码片段显示了错误的做法:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><h1 id="6de5" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">回调函数的执行上下文</h1><p id="a37d" class="pw-post-body-paragraph kx ky ir kz b la mr js lc ld ms jv lf lg mt li lj lk mu lm ln lo mv lq lr ls ik bi translated">当通过<code class="fe lv lw lx ly b">this</code>将函数作为访问执行上下文的回调参数传递时，需要特别小心。在这种情况下，您必须利用<code class="fe lv lw lx ly b">bind()</code>函数并使用它来创建一个绑定到所需执行上下文的新函数。</p><p id="6bca" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后，这个新函数作为回调参数传递:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lt lu l"/></div></figure><h1 id="243f" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">结论</h1><p id="f429" class="pw-post-body-paragraph kx ky ir kz b la mr js lc ld ms jv lf lg mt li lj lk mu lm ln lo mv lq lr ls ik bi translated">使用回调函数时，应该考虑几个最佳实践，包括类型检查、回调参数的顺序、调用回调函数一次以及设置执行上下文。</p><p id="6c40" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">关于异步编程是使用承诺、生成器函数还是async/await组合来代替回调函数的基本问题将在下面的文章中讨论。</p></div><div class="ab cl nk nl hv nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ik il im in io"><p id="0d09" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">关于JavaScript中回调函数的解释到此结束。请随时在我的<a class="ae kw" href="https://www.paulsblog.dev" rel="noopener ugc nofollow" target="_blank">个人简讯/博客</a>、<a class="ae kw" href="https://www.linkedin.com/in/paulknulst/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kw" href="https://twitter.com/paulknulst" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kw" href="https://github.com/paulknulst" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上与我联系。</p><p id="bd49" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="nr">更多内容请看</em><a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="nr">plain English . io</em></strong></a><em class="nr">。报名参加我们的</em> <a class="ae kw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz is"> <em class="nr">免费周报</em> </strong> </a> <em class="nr">。关注我们关于</em><a class="ae kw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="nr">Twitter</em></strong></a><em class="nr">和</em><a class="ae kw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="nr">LinkedIn</em></strong></a><em class="nr">。查看我们的</em> <a class="ae kw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kz is"> <em class="nr">社区不和谐</em> </strong> </a> <em class="nr">加入我们的</em> <a class="ae kw" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kz is"> <em class="nr">人才集体</em> </strong> </a> <em class="nr">。</em></p></div></div>    
</body>
</html>