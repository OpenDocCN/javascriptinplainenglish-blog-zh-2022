<html>
<head>
<title>React, Don’t Let Meta Developers Down</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">做出反应，不要让元开发者失望</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reactjs-dont-let-meta-developers-down-99f8d24b497?source=collection_archive---------3-----------------------#2022-03-20">https://javascript.plainenglish.io/reactjs-dont-let-meta-developers-down-99f8d24b497?source=collection_archive---------3-----------------------#2022-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2770" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">2022年你应该知道的React编码模式。你不会想错过它们的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d69e44bbb3884124e73997e44cd9b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVXtu1LHOf8f4JMBdL1IzA.png"/></div></div></figure><p id="43d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React仍然是最受欢迎的前端库，用于构建令人惊叹的用户界面和用户体验。从<a class="ae ln" href="https://www.npmtrends.com/@angular/core-vs-react-vs-vue" rel="noopener ugc nofollow" target="_blank">npmtrends.com</a>你可以很容易地看到，React的下载量是Angular和Vue.js等其他流行前端框架/库下载量的3倍以上</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/3ec0dfece61a5542c51695642b99a85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJrrIRpQ_NwmQ2iKtn75ig.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Chart data comparing Angular/Vue/React from npmtrends.com</figcaption></figure><p id="4d54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使这种惊人的趋势正在上升，我们作为React开发人员，也需要意识到React的常见陷阱，并不惜一切代价避免它。让我们开始吧！🏊🏼‍♂️🏊🏼‍♀️</p><h1 id="1277" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">1.避免过度优化✅</h1><p id="1bd3" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">不要通过将每一个<code class="fe mq mr ms mt b">div</code>重构到它自己的JS文件中来开始构建你的应用程序。由于多层嵌套，过度优化React组件会导致许多渲染问题。相反，应该基于小节构建应用程序框架。例如，<code class="fe mq mr ms mt b">header</code>、<code class="fe mq mr ms mt b">body</code>和<code class="fe mq mr ms mt b">footer</code>就是一个很好的起点。并且在每一节检测重复的组件，比如<code class="fe mq mr ms mt b">button</code>或者<code class="fe mq mr ms mt b">input</code>或者<code class="fe mq mr ms mt b">form field</code>，然后重构为可复用的组件，避免重复代码。为了更容易地将重复的代码重构为可重用的组件，我建议使用<strong class="kt ir"> VS代码</strong>中的<code class="fe mq mr ms mt b">glean</code>扩展来加快您的重构过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/056a71674f6ab48e2949b673ebb71139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDJHhUxcBe0tjTn1P6tcDw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">glean extension from vs code</figcaption></figure><p id="900a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦你下载了扩展，你可以突出显示文件中重复的代码块，然后点击显示的灯泡，就会有额外的重构助手可供你选择。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/d09a7d2be89be706dfe8316ab2019763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*U7dgS2QmQWw5Ab1hzal8_Q.png"/></div></figure><h1 id="e47e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">2.避免过度使用用户的浏览器内存🏃🏼‍♂️🏃🏼‍♀️</h1><p id="97ab" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">如果你在你的组件中操作多个<code class="fe mq mr ms mt b">useState</code>钩子，并且你在那个组件中运行昂贵的计算。请注意，即使昂贵的计算方法仅依赖于一个特定的<code class="fe mq mr ms mt b">useState</code>钩子，昂贵的计算方法也将在该组件的任何状态改变时运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e1ce8fba5f55e704ed6ae8da52daaec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*9dz5D990WR-pZiQcELk_1A.png"/></div></figure><p id="6b2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了防止组件出现潜在的性能瓶颈，可以使用<code class="fe mq mr ms mt b">useMemo</code>钩子将昂贵的计算方法放在回调函数中，并显式声明该方法所依赖的变量状态。以这种方式，<code class="fe mq mr ms mt b">useMemo</code>钩子将记忆计算的值，并在其它非从属状态改变时返回先前计算的值，并且仅在从属状态改变时重新运行昂贵的计算。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/a3cac5f055f46244f364d3283b09c4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odW71gmmZ4gox6vZi1lEOw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">apply useMemo hook to prevent function</figcaption></figure><h1 id="1677" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">3.避免声明不必要的div</h1><p id="8a5e" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">你在你的IDE中遇到过这个错误吗？它指出在你的JSX返回方法中不能有多个兄弟组件，并且你只能有一个根元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/a23e6aaeedfec5a8eebe5d7bce62929a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hunGqbRc7VAV3M_brGzTZg.png"/></div></div></figure><p id="4f29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解决这个问题的一个快速或糟糕的方法是将这些兄弟元素用一个<code class="fe mq mr ms mt b">div</code>包围起来。然而，拥有太多不必要的<code class="fe mq mr ms mt b">div(s)</code>会导致DOM结构和CSS样式的问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/60c20ba033533c4f9ec63eba0c1e165c.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*YmKdUMoQ5E6ZQXhcDTUCxw.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Quick or bad fix 💩</figcaption></figure><p id="7e98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相反，尝试使用由<strong class="kt ir"> React </strong>实现的方法来正确解决这个问题。您可以尝试使用<code class="fe mq mr ms mt b">&lt;React.Fragment&gt;</code>或空的<code class="fe mq mr ms mt b">&lt;&gt;</code>元素标签来解决这个问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9f8203b6ecc02ddc5e59049bbcf1478c.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*LEKrX1RNcYu41-ivPr78Sg.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Cleaner and better way 👍</figcaption></figure><h1 id="34b6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">4.没有文件夹管理，避免混乱的文件结构</h1><p id="f9d1" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">避免在一个文件中包含多个导出功能。相反，每个文件一个导出函数将是一个更好的实践。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1ec39ad6d940529a67560445a497163b.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*jV0uZFMDyd1eHpfDSBlOKA.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Bad practice to export multiple components in 1 file</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/2f47f9ea00a4273f21ac693337f53929.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*u3jblzPQ_vkk2YpxSs0M1A.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Better practice to export 1 component 1 file</figcaption></figure><p id="dee2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，您也可能会面临一些问题，比如在一个目录中有太多的小组件文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/430ab8167943f5cc134bdf0a1c1dfcaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*DwCndc84JYn5ncrDCZQaQQ.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Messy file management</figcaption></figure><p id="c429" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我建议更进一步，将每个组件放入它的目录中，你可以创建它自己的CSS模块或另一个专门针对该组件的测试文件，并通过创建一个<code class="fe mq mr ms mt b">index.tsx</code>文件正常导出它们，以便无缝地从其他组件导入它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e22db9f9ad43f497e40150f964fee620.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*m6peNe-MYuBKxPeffVJyLg.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Shift Navbar into its directory</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0361637ee611d2a27e50c8fab1419605.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*IgIqVYssAdKU9jht2lxBJQ.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Export Navbar normally as you would</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/142856654490ce89cbdedc4e72879866.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*FZzbA_3yPF_J6TGCgHwBxQ.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Declare export default from index.tsx</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/417091d67aaf0459a4f93b84f019cf46.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*2RnsvmAI93h-j_xMR5Mxhw.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Seamlessly import Navbar as usual in other component</figcaption></figure><h1 id="fed2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">5.使用多个使用状态时混乱的状态管理</h1><p id="1c84" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">React开发人员遇到的一个常见问题是在一个组件文件中处理多个<code class="fe mq mr ms mt b">useState</code>钩子。当将不同的状态解耦到不同的<code class="fe mq mr ms mt b">useState</code>钩子时，单一责任原则(SRP)的想法很棒，但是当你有太多的<code class="fe mq mr ms mt b">useState</code>钩子逻辑要在一个文件中处理时，噩梦就来了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/fedba9b009623fc7f88ba31fb75a3dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*I29FhSwi25MTDpjau4Zotw.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Multiple useStates declared in 1 component file</figcaption></figure><p id="9e39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要解决这个问题，您可以将一些<code class="fe mq mr ms mt b">useState</code>挂钩组合成一个自定义挂钩，并在自定义挂钩中执行其自定义逻辑，以避免单一组件文件过度拥挤。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/311de96225d2dd9f1e36099320f07fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*XizNWMMz59vBJJoxyVHmPA.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Refactor and group relevant useState hooks into a custom hook</figcaption></figure><h1 id="4830" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">摘要</h1><p id="c415" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">希望这篇文章已经教会了你一些有用的东西，并且增加了你对React开发的一些常见陷阱的认识。React是一个非常灵活的库，我们有权在React中使用自己的最佳实践。我希望这些技巧能够让整个React社区受益，从而开发出更好、更高性能的React应用程序。请在下面的评论中让我知道React中是否有其他要避免的陷阱，这样我们就可以通过采用正确的实践让元开发者和开源社区感到自豪。干杯。</p><div class="nj nk gp gr nl nm"><a href="https://medium.com/@devjo/membership" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">用我的推荐链接- DevJo加入媒体</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kp nm"/></div></div></a></div><p id="897a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ob">更多内容请看</em><a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ob">plain English . io</em></strong></a><em class="ob">。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ob">免费周报</em> </strong> </a> <em class="ob">。关注我们关于</em><a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ob">Twitter</em></strong></a><em class="ob">和</em><a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ob">LinkedIn</em></strong></a><em class="ob">。加入我们的</em> <a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ob">社区不和谐</em> </strong> </a> <em class="ob">。</em></p></div></div>    
</body>
</html>