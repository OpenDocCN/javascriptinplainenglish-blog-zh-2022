<html>
<head>
<title>How to Use Angular 14+ and Intersection Observer to Create An Infinite Scrolling List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Angular 14+和交集观察者创建无限滚动列表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-infinite-loading-with-angular-14-and-intersection-observer-3e0e679ade4c?source=collection_archive---------1-----------------------#2022-07-03">https://javascript.plainenglish.io/how-to-create-infinite-loading-with-angular-14-and-intersection-observer-3e0e679ade4c?source=collection_archive---------1-----------------------#2022-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/134804bc08b2133d3117b60b9a168384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEbKqHtjEXZqvA6J0YkMkQ.png"/></div></div></figure><div class=""/><p id="b290" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您经常开发Angular应用程序，那么您迟早会遇到这样的需求，即当用户滚动到列表末尾时，应该动态获取新元素。</p><p id="a6c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种行为也被称为<strong class="ka jc">无限滚动</strong>。</p><p id="9c0c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，你可以用good ol ' T0来做这件事。然而，这种解决方案相当糟糕，此外，在2022年已经有了一种更优雅的方法:T1。</p><div class="ip iq gp gr ir la"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd jc gy z fp lf fr fs lg fu fw ja bi translated">交叉点观察器API-Web API | MDN</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">交叉点观察器API提供了一种异步观察目标元素交叉点变化的方法…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">developer.mozilla.org</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo ix la"/></div></div></a></div><p id="2b06" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">IntersectionObserver</code>你还可以做其他事情，比如通过<code class="fe kw kx ky kz b">lazyload</code>重新加载图像，但是现在有一个更好的方法:</p><div class="ip iq gp gr ir la"><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading#images_and_iframes" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd jc gy z fp lf fr fs lg fu fw ja bi translated">延迟加载- Web性能| MDN</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">通常情况下，网页包含许多图像，这些图像会影响数据的使用和页面加载的速度。这些中的大多数…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">developer.mozilla.org</p></div></div><div class="lj l"><div class="lp l ll lm ln lj lo ix la"/></div></div></a></div><p id="2d55" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下文中，我将向您展示如何自己构建一个<code class="fe kw kx ky kz b">Directive</code>，它将在用户到达列表末尾时触发一个事件:</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h2 id="705b" class="lx ly jb bd lz ma mb dn mc md me dp mf kj mg mh mi kn mj mk ml kr mm mn mo mp bi translated">该指令</h2><p id="76db" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">确切地说，有两个指令，稍后我会更详细地解释。第一个做实际工作，第二个仅作为(可选)标记，如果事件不应该附加到<code class="fe kw kx ky kz b">document</code>。</p><pre class="mv mw mx my gt mz kz na nb aw nc bi"><span id="3d51" class="lx ly jb kz b gy nd ne l nf ng">// scroll-end.directive.ts</span><span id="e8da" class="lx ly jb kz b gy nh ne l nf ng">import { Directive, ElementRef, <strong class="kz jc"><em class="ni">EventEmitter</em></strong>, Input, OnDestroy, OnInit, Optional, Output } from '@angular/core';<br/>import { ScrollEndRootDirective } from './scroll-end-root.directive';</span><span id="30ff" class="lx ly jb kz b gy nh ne l nf ng">export enum SCROLLEND_DIRECTION {<br/>  <em class="ni">DOWN </em>= 'down',<br/>  <em class="ni">UP </em>= 'UP',<br/>}<br/><br/>@Directive({<br/>  selector: '[scrollEnd]',<br/>})<br/>export class ScrollEndDirective implements OnInit, OnDestroy {<br/>  @Output() scrollEnd: <strong class="kz jc"><em class="ni">EventEmitter</em></strong>&lt;any&gt; = new <strong class="kz jc"><em class="ni">EventEmitter</em></strong>();<br/><br/>  @Input() rootMargin = '0px 0px 0px 0px';<br/>  @Input('direction') desiredDirection: SCROLLEND_DIRECTION = SCROLLEND_DIRECTION.<em class="ni">DOWN</em>;<br/><br/>  observer: IntersectionObserver;<br/>  previousEntry: IntersectionObserverEntry;<br/>  scrollDirection: SCROLLEND_DIRECTION;<br/><br/>  constructor(<br/>    private el: ElementRef,<br/>    @Optional() private scrollEndRoot: ScrollEndRootDirective,<br/>  ) { }<br/><br/>  ngOnInit(): void {<br/>    this.observer = new IntersectionObserver(entries =&gt; {<br/>      entries.forEach(entry =&gt; {<br/>        this.scrollDirection = this.previousEntry?.boundingClientRect.bottom &gt; entry.boundingClientRect.bottom ? SCROLLEND_DIRECTION.<em class="ni">DOWN </em>: SCROLLEND_DIRECTION.<em class="ni">UP</em>;<br/><br/>        if (!this.previousEntry?.isIntersecting &amp;&amp; entry.isIntersecting &amp;&amp; this.scrollDirection === this.desiredDirection) {<br/>          this.scrollEnd.emit();<br/>        }<br/><br/>        this.previousEntry = entry;<br/>      });<br/>    }, {<br/>      root: this.scrollEndRoot?.el.nativeElement,<br/>      rootMargin: this.rootMargin,<br/>    });<br/><br/>    this.observer.observe(this.el.nativeElement);<br/>  }<br/><br/>  ngOnDestroy(): void {<br/>    this.observer.disconnect();<br/>  }<br/>}</span><span id="5c20" class="lx ly jb kz b gy nh ne l nf ng"><br/>// scroll-end-root.directive.ts</span><span id="2d6c" class="lx ly jb kz b gy nh ne l nf ng">import { Directive, ElementRef } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[scrollEndRoot]',<br/>})<br/>export class ScrollEndRootDirective {<br/>  constructor(<br/>    public el: ElementRef,<br/>  ) {<br/>  }<br/>}</span></pre><h2 id="fd27" class="lx ly jb bd lz ma mb dn mc md me dp mf kj mg mh mi kn mj mk ml kr mm mn mo mp bi translated">使用</h2><p id="9dcc" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">例如，让我们假设一个要动态重新加载的通知列表:</p><pre class="mv mw mx my gt mz kz na nb aw nc bi"><span id="45ca" class="lx ly jb kz b gy nd ne l nf ng">&lt;div class="notifications" scrollEndRoot&gt;<br/>  &lt;div *ngFor="let notification of notifications$ | async"&gt;...&lt;/div&gt;<br/>  &lt;div (scrollEnd)="loadMore()" rootMargin="0px 0px 100px 0"&gt;<br/>    &lt;loading-spinner *ngIf="loading$ | async)"&gt;&lt;/loading-spinner&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h2 id="c152" class="lx ly jb bd lz ma mb dn mc md me dp mf kj mg mh mi kn mj mk ml kr mm mn mo mp bi translated">它是如何工作的？</h2><p id="82b3" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">关于整个事情如何运作的问题仍然存在:</p><p id="caae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的示例中，<code class="fe kw kx ky kz b">div.notifications</code>具有固定的高度(例如500px)和<code class="fe kw kx ky kz b">overflow: auto</code>。当<code class="fe kw kx ky kz b">notifications$</code>列表结束时，带有<code class="fe kw kx ky kz b">&lt;loading-spinner&gt;</code>的<code class="fe kw kx ky kz b">div</code>出现。一旦发生这种情况，<code class="fe kw kx ky kz b">scroll-end.directive.ts</code>中的<code class="fe kw kx ky kz b">IntersectionObserver</code>被触发，并将事件传递给<code class="fe kw kx ky kz b">(scrollEnd)</code>。</p><p id="a449" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意确保只有当用户向相反方向滚动或者元素至少一次被滚出屏幕时才触发该事件。</p><p id="1850" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句，在<code class="fe kw kx ky kz b">desiredDirection="UP"</code>的帮助下，你也可以逆转这个行为。</p><p id="a3d0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，你可以在<code class="fe kw kx ky kz b">rootMargin</code>的帮助下使用一个缓冲到边距。在我们的例子中,<code class="fe kw kx ky kz b">0px 0px 100px 0px</code>确保了当列表的结尾仍然在<code class="fe kw kx ky kz b">100px</code>视窗之外时，事件已经被触发。</p><p id="a5e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也可以省去<code class="fe kw kx ky kz b">scrollEndRoot</code>。然后<code class="fe kw kx ky kz b">IntersectionObserver</code>会自动附加到浏览器的视窗中。这很有用，例如，如果整个页面上只有一个全屏幕表格。</p><h1 id="ff2c" class="nj ly jb bd lz nk nl nm mc nn no np mf nq nr ns mi nt nu nv ml nw nx ny mo nz bi translated">摘要</h1><p id="ce48" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">如您所见，使用角度指令和<code class="fe kw kx ky kz b">IntersectionObserver</code>开发一个无限负载并不困难。</p><p id="719d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有任何问题，不要害怕给我回复或在Twitter上联系我，电话:<a class="ae oa" href="http://twitter.com/saschawolff1" rel="noopener ugc nofollow" target="_blank"> @saschawolff1 </a>。</p><p id="a0a0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想看更多精彩的文章，试试这篇:</p><p id="d5ac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae oa" href="https://medium.com/@sascha.wolff/utility-first-css-ridiculously-fast-front-end-development-for-almost-every-design-503130d8fefc" rel="noopener">https://medium . com/@ sascha . Wolff/utility-first-CSS-snally-fast-front-end-development-for-almost-every-design-503130 D8 fefc</a></p><p id="83a1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ni">更多内容看</em> <a class="ae oa" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="ni">说白了。报名参加我们的</em> <a class="ae oa" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="ni">免费周报</em> </strong> </a> <em class="ni">。关注我们关于</em><a class="ae oa" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="ni">Twitter</em></strong></a><em class="ni">和</em><a class="ae oa" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="ni">LinkedIn</em></strong></a><em class="ni">。查看我们的</em> <a class="ae oa" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="ni">社区不和谐</em> </strong> </a> <em class="ni">加入我们的</em> <a class="ae oa" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="ni">人才集体</em> </strong> </a> <em class="ni">。</em></strong></a></p></div></div>    
</body>
</html>