<html>
<head>
<title>Customize the Apostrophe Admin UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义撇号管理用户界面</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/customizing-the-apostrophe-admin-ui-e2d5e1929d3b?source=collection_archive---------18-----------------------#2022-01-10">https://javascript.plainenglish.io/customizing-the-apostrophe-admin-ui-e2d5e1929d3b?source=collection_archive---------18-----------------------#2022-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="68dd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何定制撇号的管理用户界面的指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5cd8d1eeb131faf32c7018bd58301f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_WAnOrvsUNGNHHVC.png"/></div></div></figure><p id="a45f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本指南重点介绍如何定制撇号的管理用户界面或“管理用户界面”内置功能涵盖了大多数情况，但有时您会想要添加或更改功能。</p><h1 id="3421" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">警告</h1><ul class=""><li id="f319" class="mc md in kq b kr me ku mf kx mg lb mh lf mi lj mj mk ml mm bi translated">改变用户界面应该很少，而且要小心。如果可能，添加新功能，如自定义模式字段类型和自定义管理器视图列。除非绝对必要，否则避免完全重写组件。</li><li id="87c8" class="mc md in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated">覆盖UI组件会阻止项目从将来的UI改进和与该组件相关的错误修复中受益。</li><li id="6f3d" class="mc md in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated">确定没有更好的方法可以达到预期的目标。这包括<a class="ae ms" href="https://chat.apostrophecms.org/" rel="noopener ugc nofollow" target="_blank">不和谐地求助</a>和<a class="ae ms" href="https://portal.productboard.com/apostrophecms/1-product-roadmap/tabs/1-under-consideration" rel="noopener ugc nofollow" target="_blank">请求</a>或<a class="ae ms" href="https://github.com/apostrophecms/apostrophe/blob/main/CONTRIBUTING.md#apostrophecms-contribution-guide" rel="noopener ugc nofollow" target="_blank">为核心贡献</a>新功能。</li><li id="8df2" class="mc md in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated">在撇号3.x生命周期的某个时刻，我们打算迁移到Vue.js 3.x。我们将尽可能向后兼容，并让社区了解时间表，但在编写自定义管理UI组件时，必须理解将来可能需要进行微小的更改。</li></ul><h1 id="bc4e" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">撇号管理用户界面文件结构</h1><p id="3ab6" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">撇号的管理用户界面是用Vue.js实现的。它是由跨越各种撇号模块的许多<code class="fe mw mx my mz b">.vue</code>文件构建的。这些通常在撇号核心中找到，但是它们可以在项目中的任何地方。这意味着我们可以通过将<code class="fe mw mx my mz b">.vue</code>文件添加到任何撇号模块的<code class="fe mw mx my mz b">ui/apos/components</code>子目录中，将我们自己的Vue组件引入到管理UI中。如下所述，还可以通过提供同名组件来覆盖现有组件。</p><h1 id="0969" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">当我们做出改变时重建用户界面</h1><p id="3252" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">出于性能原因，撇号项目没有配置为在每次代码更改时自动重新构建管理UI。这是有意义的，因为在大多数项目中没有定制的管理UI代码，并且需要时间来构建。</p><p id="bc5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，我们可以在每次代码更改时“选择”重新构建UI，就像这样:</p><pre class="kd ke kf kg gt na mz nb nc aw nd bi"><span id="09af" class="ne ll in mz b gy nf ng l nh ni">APOS_DEV=1 npm run dev</span></pre><p id="33cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为方便起见，您可能希望为终端会话的生存期设置此环境变量:</p><pre class="kd ke kf kg gt na mz nb nc aw nd bi"><span id="04d2" class="ne ll in mz b gy nf ng l nh ni"><strong class="mz io">export</strong> APOS_DEV=1</span></pre><p id="87d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，在部署时，管理UI总是会重新构建。生产使用不需要特殊的更改或环境设置。</p><h1 id="61c6" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">注册自定义字段类型</h1><p id="b3ad" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">撇号的<a class="ae ms" href="https://v3.docs.apostrophecms.org/guide/content-schema.html" rel="noopener ugc nofollow" target="_blank">模式字段类型</a>涵盖了许多情况，但是我们可能希望添加一个新的。</p><p id="cdb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于这是一个更大的主题，涉及的不仅仅是UI，我们已经创建了一篇关于如何添加自定义字段类型的文章<a class="ae ms" href="https://v3.docs.apostrophecms.org/guide/custom-schema-field-types.html#implementing-the-server-side-part" rel="noopener ugc nofollow" target="_blank">。但是，请注意，如果您先阅读这篇文章，您会发现阅读本文的其余部分会更容易。</a></p><h1 id="18d5" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">将自定义列添加到片段类型管理器</h1><p id="83f3" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">另一个常见的扩展是片类型管理器的自定义列。默认情况下，管理器模式显示标题、某些标志和最后一次更新的时间。我们可以扩展它来显示我们的自定义星级。</p><h1 id="b268" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">实现服务器端部分</h1><p id="3614" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">让我们看一个简单的片段类型模块<code class="fe mw mx my mz b">review</code>，它利用了我们在另一篇文章中定义的<a class="ae ms" href="https://v3.docs.apostrophecms.org/guide/custom-schema-field-types.html#implementing-the-server-side-part" rel="noopener ugc nofollow" target="_blank">星号字段类型。我们将为piece类型的模式添加一个<code class="fe mw mx my mz b">rating</code>字段，并添加一个列以在管理器模式中显示它:</a></p><pre class="kd ke kf kg gt na mz nb nc aw nd bi"><span id="45a0" class="ne ll in mz b gy nf ng l nh ni">module.exports = {<br/>  extend: '@apostrophecms/piece-type',<br/>  fields: {<br/>    add: {<br/>      rating: {<br/>        type: 'starRating',<br/>        label: 'Star Rating',<br/>        required: true<br/>      }<br/>    }<br/>  },<br/>  columns: {<br/>    <em class="nj">// 👇 Columns are a "cascade" just like fields,</em><br/>    <em class="nj">// we have an "add" property with a subproperty</em><br/>    <em class="nj">// for each column</em><br/>    add: {<br/>      rating: {<br/>        <em class="nj">// 👇 Each column has a label property and a</em><br/>        <em class="nj">// component property. The component name must</em><br/>        <em class="nj">// exist as a Vue component</em><br/>        label: 'Rating',<br/>        component: 'ColumnStarRating'<br/>      }<br/>    }<br/>  }<br/>};</span></pre><h1 id="8281" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">实现浏览器端部分</h1><p id="e421" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">这段代码引用了一个尚不存在的Vue组件<code class="fe mw mx my mz b">ColumnStarRating</code>。接下来，我们将介绍该组件:</p><pre class="kd ke kf kg gt na mz nb nc aw nd bi"><span id="e86d" class="ne ll in mz b gy nf ng l nh ni">&lt;template&gt;<br/>  &lt;p<br/>    class="apos-table__cell-field"<br/>    :class="`apos-table__cell-field--${header.name}`"<br/>  &gt;<br/>    &lt;span v-if="hasValue"&gt;<br/>      &lt;span v-for="index in 5" :key="index" class="rating"&gt;{{ isActive(index) ? '☆' : '★' }}&lt;/span&gt;<br/>    &lt;/span&gt;<br/>    &lt;span v-else&gt;<br/>      None<br/>    &lt;/span&gt;<br/>  &lt;/p&gt;<br/>&lt;/template&gt;</span><span id="cdfd" class="ne ll in mz b gy nk ng l nh ni">&lt;script&gt;<br/><strong class="mz io">import</strong> AposCellMixin <strong class="mz io">from</strong> 'Modules/@apostrophecms/ui/mixins/AposCellMixin';</span><span id="901c" class="ne ll in mz b gy nk ng l nh ni"><strong class="mz io">export</strong> <strong class="mz io">default</strong> {<br/>  name: 'AposCellBasic',<br/>  mixins: [ AposCellMixin ],<br/>  computed: {<br/>    <strong class="mz io">hasValue</strong>() {<br/>      <strong class="mz io">return</strong> this.get(this.header.name) != null;<br/>    }<br/>  },<br/>  methods: {<br/>    <strong class="mz io">isActive</strong>(index) {<br/>      <strong class="mz io">return</strong> index &lt;= (this.get(this.header.name) || 0);<br/>    }<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="2363" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然Vue组件可以放在任何模块中，但是将它分组到<code class="fe mw mx my mz b">star-range-field</code>模块中是最有意义的，因为它可以在任何块类型中用作列，而不仅仅是一个<code class="fe mw mx my mz b">review</code>。</p><p id="fd82" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个组件使用<code class="fe mw mx my mz b">AposCellMixin</code>来做两件重要的事情:</p><ul class=""><li id="c7b8" class="mc md in kq b kr ks ku kv kx nl lb nm lf nn lj mj mk ml mm bi translated">组件通过访问由mixin自动声明的<code class="fe mw mx my mz b">header</code>属性来访问列的配置。</li><li id="0c6d" class="mc md in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated">组件可以通过调用带有任何属性名的<code class="fe mw mx my mz b">this.get</code>从片段中获取属性。按照撇号的约定，如果存在的话，这个方法自动从文章的出版版本中获取，否则从草稿中获取。</li></ul><h1 id="0202" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">按名称覆盖标准Vue.js组件</h1><p id="d39c" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">大多数时候，我们不需要覆盖带撇号的管理UI组件。但是如果我们有需要，我们可以通过<strong class="kq io">将一个与标准组件同名的文件放在项目级模块的</strong> <code class="fe mw mx my mz b">ui/apos/components</code> <strong class="kq io">子目录中。</strong>您也可以在定制的npm模块中这样做，以实现跨项目的重用。</p><p id="063e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Apostrophe将仅使用它在启动期间找到的组件的最后一个版本。一般启动顺序为:</p><ol class=""><li id="253f" class="mc md in kq b kr ks ku kv kx nl lb nm lf nn lj no mk ml mm bi translated">核心单引号模块</li><li id="fda7" class="mc md in kq b kr mn ku mo kx mp lb mq lf mr lj no mk ml mm bi translated">已安装模块和项目级模块，按照它们在<code class="fe mw mx my mz b">app.js</code>中配置的顺序</li></ol><p id="9570" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，如果项目的<code class="fe mw mx my mz b">app.js</code>模块列表中的最后一个模块包含一个<code class="fe mw mx my mz b">ui/apos/components/AposLogPadless.vue</code>文件，则该徽标将在管理栏中使用，而不是通常从Apostrophe core加载的版本或在之前配置的任何模块中使用。</p><p id="18e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="nj">注</em> </strong> <em class="nj">有关覆盖现有核心组件所使用的模式、提供的道具和需要的API的更多信息，有必要研究原始的源代码。</em></p><h1 id="e40f" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">通过配置覆盖标准Vue.js组件</h1><p id="dbc9" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">一个项目中只能有一个<code class="fe mw mx my mz b">AposDocsManager</code>组件定义，但有时我们需要为特定的块类型定义不同的行为。我们可以通过重写一个核心组件并添加条件逻辑来解决这个问题，但这将导致代码难以维护，同时也意味着我们只能维护一个复杂组件的副本，而错过了bug修复和改进。<strong class="kq io">最好指定一个不同的自定义零部件名称，以在</strong>中用于管理特定的块类型。</p><p id="fedb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是一个示例:</p><pre class="kd ke kf kg gt na mz nb nc aw nd bi"><span id="519b" class="ne ll in mz b gy nf ng l nh ni">module.exports = {<br/>  extend: '@apostrophecms/piece-type',<br/>  options: {<br/>    components: {<br/>      managerModal: 'AnnouncementManager'<br/>    }<br/>  }<br/>}</span></pre><p id="7640" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种配置下，当用户绕过<code class="fe mw mx my mz b">AposDocManager</code>从管理栏中选择“notifications”时，Apostrophe将查找名为<code class="fe mw mx my mz b">AnnouncementManager</code>的Vue.js组件。</p><p id="e746" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">至于真正的Vue.js代码，我们将其放在<code class="fe mw mx my mz b">modules/announcement/ui/apos/components/AnnouncementManager.vue</code>中。</p><p id="576e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，还有其他一些组件可以用这种方法覆盖，而且这个列表还会随着时间的推移而不断增长。以下是当前可以通过配置覆盖的组件:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/248c11b8291038b57b33a823ecab393a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XkyMf4ouKvISR1Qk.png"/></div></div></figure><p id="5b6f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了便于阅读，上表中使用了<code class="fe mw mx my mz b">.</code>来分隔选项的子属性(实际配置看起来像什么，请参见上面的示例)。如果<code class="fe mw mx my mz b">@apostrophecms/piece-type</code>存在一个选项，则该选项可用于扩展该选项的任何模块。</p><h1 id="fd87" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">总结说明</h1><p id="7671" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">由于现有页面的类型可以更改，所有页面只有一个管理器模式和一个编辑器模式，这些组件名称是在<code class="fe mw mx my mz b">@apostrophecms/page</code>模块上配置的。块和小部件类型可以有自己的特定于类型的替代。</p><p id="c11a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果一个选项以<code class="fe mw mx my mz b">Modal</code>结尾，则要求该组件嵌入<code class="fe mw mx my mz b">AposModal</code>组件。例如，看看上面列出的默认组件的源代码。</p><p id="3e78" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">AposWidgetEditor</code>组件已经提供了一个模态对话框，可以在其中编辑任何小部件的模式，所以我们不需要配置替换组件，除非我们想支持直接在页面上编辑。<code class="fe mw mx my mz b">AposRichTextWidgetEditor</code>是如何做到这一点的一个例子。</p><p id="2fd7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mw mx my mz b">AposWidget</code>组件与典型的网站访问者体验没有任何关系。它仅在页面处于编辑模式时显示我们的小部件时使用。虽然很少覆盖这个组件，但是<code class="fe mw mx my mz b">@apostrophecms/rich-text-widget</code>模块这样做是为了给富文本小部件提供“点击文本进行编辑”的体验。如果你只是想用前端JavaScript增强你的小部件，你应该写一个<a class="ae ms" href="https://v3.docs.apostrophecms.org/guide/custom-widgets.html#client-side-javascript-for-widgets" rel="noopener ugc nofollow" target="_blank">小部件播放器</a>来代替。</p><p id="942d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在重写编辑器模式之前，考虑用<a class="ae ms" href="https://v3.docs.apostrophecms.org/guide/custom-schema-field-types.html#implementing-the-server-side-part" rel="noopener ugc nofollow" target="_blank">添加一个定制模式字段类型</a>来代替。</p><p id="64d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nj">更多内容看</em> <a class="ae ms" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nj">说白了。报名参加我们的</em> <a class="ae ms" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nj">免费周报</em> </strong> </a> <em class="nj">。在我们的</em> <a class="ae ms" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nj">社区不和谐</em> </strong> </a> <em class="nj">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>