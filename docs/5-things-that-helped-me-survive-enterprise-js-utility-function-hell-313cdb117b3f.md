# 帮助我度过 JS 实用函数地狱的 5 件事

> 原文：<https://javascript.plainenglish.io/5-things-that-helped-me-survive-enterprise-js-utility-function-hell-313cdb117b3f?source=collection_archive---------5----------------------->

## 为什么开发人员应该将 JavaScript 实用函数重构为独立的组件，正确共享实用函数而不是复制粘贴，等等。

![](img/fb239aa3e67c5ceba9709a1905f5c644.png)

[Photo](https://www.pexels.com/photo/woman-sitting-in-front-of-macbook-313690/) by energepic.com @ Pexels

陪审团可能不知道究竟什么构成了企业应用程序(剧透一下:*企业*是一个松散定义的架构特性集的管理术语；这与技术指标或代码质量无关)，但几乎所有和我一起工作过的人都同意一件事。

边缘案例。边缘案例*比比皆是*。

有些东西会坏掉。相信我，在如此大规模的代码基础上，非标准的网络配置、压迫性的安全策略、过时的软件和分散/非统一的系统都生活在一个混乱、丑陋的生态系统中，这一切会发生什么？

你*不想*站在错误的一边:杂乱无章的项目结构。

所以很自然地，以我的运气，那就是*恰好*发生在我身上的事。

具体来说:这个特定的工作场所如何处理其助手/实用程序功能集合的组织和共享(或者更准确地说，*没有*)。

因此，这更像是一篇开发日记，而不是一篇教程，讲述了我如何使开发这个代码库变得更容易——并在整个过程中保持理智。

# “休斯顿？我们有一个问题。”

我所在的团队将他们的物流跟踪套件从本地 PySide 应用移植到 React 17。

它有大约 24 个实用程序/助手函数——位于一个`/tools`目录中，由于不存在维护，这个目录已经不再是一个实用程序函数的集合，而更像是一个函数的转储场，过去的开发人员无法决定逻辑上放在哪里。

当其中一些需要共享时，最常用的解决方案是从 repos 中复制粘贴旧代码，这造成了版本管理的混乱。更糟糕的是，其中一些有嵌套依赖，所以测试是一场噩梦，调试更糟糕。

如果这些描述了你目前正在从事的项目，我向你致以最深切的同情。下面是我做的一些实际上有帮助的事情，希望它们也能为你服务。

## 1.将实用函数重构到每个上下文的一个专用组件中。

所以第一件事是从`/tools`目录中提取实用函数，并按照上下文/功能对它们进行分类。

现在你可以把它们命名为`string-utils.js`、`form-utils.js` ，并在每个组中有相关的功能。这样做没问题，但我发现非常有用的是一个更细粒度的结构/命名标准，它使浏览文件结构一眼就能判断是否有满足我需要的实现，而不是猜测和查看每个 utils 文件。

这将意味着更冗长的文件名，如`sanitize-string.js`、`check-deep-equality.js`和`validate-input.js`，但是你将使每个人的生活更容易——包括你自己。

每个上下文都有**一个专用组件，一旦看到**，你就会**确切地知道它** **做什么。第一个概念[坚实的原理](https://en.wikipedia.org/wiki/SOLID)在起作用。**

理论上，你可以想多深就多深，但是收益递减规律在这里很强。运用常识，保持名称简短易读，使用一致的茶色或烤肉串色；仅为组件保留 PascalCase。

## 2.共享实用程序功能正常，而不是复制粘贴旧代码

天哪，这是最难熬的一次了。

如果您从本文中学到了什么，那就是:从以前的项目中复制粘贴代码是一种幼稚的解决方案，不仅扩展性差，而且还会产生许多问题。

下面的文章是如何避免这种情况的一个很好的例子！

[](/better-developer-velocity-with-shared-javascript-utility-functions-8a528d8d1319) [## 利用共享的 JavaScript 实用函数提高开发速度

### 保持代码干爽的实用指南，以及跨…正确重用 JS helper 函数的最佳实践

javascript.plainenglish.io](/better-developer-velocity-with-shared-javascript-utility-functions-8a528d8d1319) 

你会在不同的回复中有相同代码的多个版本，每个人都有自己的想法。

可读性和代码维护的噩梦！

但是，如何在企业项目中“正确地”分享它们呢？首先，你需要安全的访问控制。很少有企业项目实际上是开源的——即使它们使用了 F/OSS 工具——所以你不能通过 NPM 把它们作为一个模块发布。

你可以在一个秘密的 URL 上传 tarballs，共享链接，然后通过一个包管理器从那里安装，但是这样你就放弃了 semver 和自动更新的好处。

**从我的研究来看，** [**钻头**](https://bit.cloud/) **是两全其美的。**这是一个开源工具链，一个上传、共享和发现组件和 Node.js 模块的伟大平台，对丰富的 [MDX](https://mdxjs.com/) 文档的完全支持，在团队中的任何人导入它们之前在模拟的真实场景中预览我们所有功能的 TSX/JSX“组合”，具有深度依赖图的语义版本，以及确保每个实用函数*对任何导入它们的人都有效的捆绑单元测试*。

至关重要的是，细粒度的访问控制意味着我可以制作真正私有的、未列出的模块，并在需要知道的基础上添加任何人作为合作者。

我让它通过了我们的审批程序，很快就通过了，几天后我就开始使用它了。

> *💡*不过，在这一点上，您的里程可能会有所不同。大公司通常需要法律部门来研究和签署第三方技术。在这一点上，这是一个完全的抛掷。\_(ツ)_/

## 3.有时，一个专用组件比三个实用功能要好。

模块化和抽象是伟大的，但是当你一天工作八到十个小时的时候，[代码*可读性*](https://en.wikipedia.org/wiki/Computer_programming#Readability_of_source_code) 要重要得多。

可读代码是编写良好的代码的一个功能，它的长期好处包括更容易测试和调试，更容易对现有代码进行迭代，从而提高可维护性。

这对于使用像 React 这样的非独立复合框架的团队来说尤其重要。

这在实践中会是什么样子？这个项目有一堆不同的助手函数，它们基本上做同样的事情:导出数据。

我没有用`export-CSV`、`export-XLS`、`export-PDF`等等来扩充我的 utils 目录，而是发现将这些功能整合到一个大约 80 行的`ExportButton`组件中(使用一个定制的钩子来获取数据)更容易。

可读性、直观性和可发现性都大大提高了，因为我不必保留一堆相同但略有不同的实用函数。

另外，由于我已经在使用 Bit，我可以在 Bit 工作空间中逻辑地隔离我的“哑”表示组件(所有无状态的原子 UI 组件，除了 UI 库之外没有任何依赖关系)和我的“智能”容器组件(操纵数据的有状态组件，称为 API、Redux 和其他库)，并在我需要的地方挑选我需要的东西。

## **4。使用 Lodash。**

或者，更有说服力地说:“您不会错过您没有编写的 JavaScript 的测试”。

保留您的特定领域的实用函数，但是对于一般用途的东西，如深度相等、克隆、数组操作和去抖动，请使用经过战斗测试的、有大量文档记录的、可读性更好的实用函数库，如 [Lodash](https://lodash.com/) 。

决定很简单。我不想重新发明轮子。我不希望在我的代码库或版本控制中有数百个实用程序/助手方法。我想要模块化的、独立的、久经考验的、一劳永逸的。

再一次，这一切都回到了优先考虑可读性，而不是通过滚动自己的本机函数获得的性能提升。更重要的是，通过一些工作，你可以让洛达什[变得可树摇动](https://en.wikipedia.org/wiki/Tree_shaking)(使用`[babel-plugin-lodash](https://github.com/lodash/babel-plugin-lodash)`，或者仅仅是`[lodash-es](https://www.npmjs.com/package/lodash-es)` 代替)，所以我可以只使用我需要的函数，避免代码膨胀。

> *💡*如果你不想使用巴别塔插件或者管理`lodash` 和`lodash-es`之间的依赖冲突，使用 Bit 代替。那里共享的任何东西都是现成的——您可以检查每个组件/模块的依赖关系图，选择要导入和安装的组件/模块，直到最小的原子，因为所有的组件/模块都是可组合的代码。

## **5。**知道何时使用助手函数，以及何时使用反作用钩子。

有人告诉我，在 React 中使用助手函数最简单的方法是在任何地方使用定制钩子来代替。

请不要这样做。

当你刚开始的时候，把定制钩子看作特殊的实用功能是有帮助的，是的，但是它们是**而不是**相同的。有疑问时；运用 [YAGNI](https://en.wikipedia.org/wiki/You_aren't_gonna_need_it) 原理。

不要为未来设计；只有当您的助手函数需要跨组件重用有状态逻辑、用其他钩子重用逻辑或者组合/封装普通的反应钩子时，才编写钩子。

如果您有纯实用函数，比如这个:

```
function sum(a, b) {return a + b;}
```

别管他们了。

钩子必须始终遵守钩子的[规则](https://reactjs.org/docs/hooks-rules.html)，限制了它们的使用方式，如果你过早地优化并试图将钩子融入到你的设计模式中，你会减慢开发速度并可能使代码中其他不相关的部分变得复杂。

一个简单的助手函数可以在任何地方，任何时间，不受限制地使用。另外，现在您可以查看项目文件夹，并立即知道哪些不使用 state(在 utils 目录中)，哪些使用 state(在 hooks 目录中)。

> *💡*顺便说一下，如果你真的决定了 bits，你可以将你的定制的 react hooks 食谱分享给 bits . cloud(bits 为 React hooks 提供了一个模板)，并且更容易进行分布式开发。

# *工作出问题；不要通过猜测让事情变得更糟。”*

很容易找到轶事证据说“Framework X 对于企业或生产来说是有史以来最糟糕的！”。但是大多数时候，这不是框架的问题，而是对一个好的项目结构能为可维护的代码做些什么的不完美的理解。

当然，正确地执行效用函数可能只是冰山一角，但它*仍然是朝着正确方向迈出的*一步，因为我们都陷入了继承另一个团队的工作并将你的工作传递给下一个团队的恶性循环中。

忽视这一点是导致“现在这样做，我们以后再解决”变成[技术债务](https://en.wikipedia.org/wiki/Technical_debt)的原因，然后是六个月的有毒 scrum 来实际“解决”。

谁知道呢？即使在极其保守的企业代码环境中，也许通过这种方式，您会发现这些工具在不仅仅是助手功能的领域中也有一些用途？

# 了解更多信息

[](https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc) [## 我们如何构建微前端

### 构建微前端来加速和扩展我们的 web 开发过程。

blog.bitsrc.io](https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc) [](https://blog.bitsrc.io/how-we-build-our-design-system-15713a1f1833) [## 我们如何构建一个组件设计系统

### 用组件构建一个设计系统来标准化和扩展我们的 UI 开发过程。

blog.bitsrc.io](https://blog.bitsrc.io/how-we-build-our-design-system-15713a1f1833) [](https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l3bhezsg) [## 如何在项目中重用 React 组件

### 最后，您完成了在应用程序中为时事通讯创建一个奇妙的输入字段的任务。你对…很满意

比特云](https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l3bhezsg) [](https://bit.cloud/blog/painless-monorepo-dependency-management-with-bit-l4f9fzyw) [## 使用 Bit 进行无痛 monorepo 依赖管理

### 简化 monorepo 中的依赖关系管理，以避免虚拟依赖关系和版本问题。了解…

比特云](https://bit.cloud/blog/painless-monorepo-dependency-management-with-bit-l4f9fzyw)