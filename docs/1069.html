<html>
<head>
<title>Promise.all() vs. Promise.allSettled() vs. for await…of</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Promise.all()与Promise.allSettled()与for await…of</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/promise-all-vs-promise-allsettled-vs-for-await-of-c32e1a327a20?source=collection_archive---------1-----------------------#2022-03-02">https://javascript.plainenglish.io/promise-all-vs-promise-allsettled-vs-for-await-of-c32e1a327a20?source=collection_archive---------1-----------------------#2022-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3ebe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何处理异步迭代</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f1a4cdc8a96001c63baa66ac2250c85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rsuq3J3_0398ladQ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@radowanrehan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Radowan Nakif Rehan</a> on <a class="ae kv" href="https://unsplash.com/s/photos/computer-science?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4b9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写现代JavaScript大部分时间都涉及处理承诺。通常情况下，这涉及到处理大量的问题。处理承诺的选择是多方面的。武器装备里有很多枪。虽然你可能会用狙击手近距离击中目标，但选择正确的武器会让这项工作容易得多。</p><p id="76eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了帮助你正确瞄准，我将讨论三种处理承诺的方法:<code class="fe lt lu lv lw b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>、<code class="fe lt lu lv lw b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" rel="noopener ugc nofollow" target="_blank">Promise.allSettled()</a></code>和<code class="fe lt lu lv lw b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of" rel="noopener ugc nofollow" target="_blank">for await...of</a></code>。</p><h2 id="5865" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">等待…的</h2><p id="aa2c" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">异步<code class="fe lt lu lv lw b">For await...of</code>和它的同步兄弟<code class="fe lt lu lv lw b">for of</code>非常相似:你可以像<code class="fe lt lu lv lw b">Array</code>、<code class="fe lt lu lv lw b">Map</code>或<code class="fe lt lu lv lw b">Set</code>一样循环遍历一个可迭代的对象。<code class="fe lt lu lv lw b">For await of</code>其与众不同之处在于能够在循环内处理异步代码。</p><p id="5a6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们假设我们有一个包含5个口袋妖怪id的数组。使用for await…of，我们可以逐个循环id，并使用<a class="ae kv" href="https://pokeapi.co/" rel="noopener ugc nofollow" target="_blank"> PokéApi </a>获取相关Pokemon的名称。如果其中一个调用出错，我们可以捕捉并处理它，然后继续循环的剩余部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/26be7af3f09ee5814dd76941cfba7bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBUl2xK7Z9YlsPVwxN-niA.png"/></div></div></figure><h2 id="e65e" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">Promise.all()</h2><p id="37ff" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">那么我们如何使用<code class="fe lt lu lv lw b">Promise.all()</code>来获取口袋妖怪的名字呢？这个函数接受一个可迭代的承诺作为它的输入参数。因此我们可以<code class="fe lt lu lv lw b">.map</code>遍历id，获取名称，并将异步映射作为输入提供给<code class="fe lt lu lv lw b">Promise.all</code>。当所有承诺都实现时，该函数返回一个包含所有承诺结果的数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/07d43a6420f4d70a049553a3d26d0d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBLkTmad2mTaEjoK20ZTng.png"/></div></div></figure><h2 id="cd18" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">“for await…of”和“Promise.all()”的主要区别</h2><p id="0dc9" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">那么，<em class="ls">除了返回值略有不同外，</em><code class="fe lt lu lv lw b"><em class="ls">for await...of</em></code><em class="ls"/><code class="fe lt lu lv lw b"><em class="ls">Promise.all()</em></code><em class="ls">有什么大的区别呢。</em>最重要的区别是<code class="fe lt lu lv lw b">Promise.all()</code>同时处理它的输入承诺，而<code class="fe lt lu lv lw b">for await...of</code>一次解决一个。因此，例如，使用<code class="fe lt lu lv lw b">for await...of</code>，一旦我们找到小火龙，我们将能够停止调用<em class="ls"> pokeApi </em>，而<code class="fe lt lu lv lw b">Promise.all()</code>将同时创建所有承诺，并且仅在所有承诺都解决后才完成。</p><p id="6b64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe lt lu lv lw b">for await...of</code>，你可以更细致地控制承诺。因此，如果完成承诺的顺序对您很重要，那么<code class="fe lt lu lv lw b">for await...of</code>是您的首选。然而，增强的控制并不是免费的。<code class="fe lt lu lv lw b">for await...of</code>一个接一个地处理承诺，这使得它慢了很多。事实上，在我们的口袋妖怪抓取的情况下，几乎<a class="ae kv" href="https://perf.link/#eyJpZCI6IjFnc2V2YnkwMGlvIiwidGl0bGUiOiJGaW5kaW5nIG51bWJlcnMgaW4gYW4gYXJyYXkgb2YgMTAwMCIsImJlZm9yZSI6ImNvbnN0IHBva2VBcGkgPSAnaHR0cHM6Ly9wb2tlYXBpLmNvL2FwaS92Mi8nO1xuY29uc3QgcG9rZW1vbklkcyA9IFsxLCAyLCAzLCA0LCA1XTtcblxuXG5cbiIsInRlc3RzIjpbeyJuYW1lIjoiUHJvbWlzZS5hbGwoKSIsImNvZGUiOiJhd2FpdCBQcm9taXNlLmFsbChcblx0XHRwb2tlbW9uSWRzLm1hcChhc3luYyBwb2tlSWQgPT4ge1xuXHRcdFx0ICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7cG9rZUFwaX1wb2tlbW9uLyR7cG9rZUlkfWApO1xuXHRcdFx0XHRcdGNvbnN0IHtuYW1lfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9KSAgXHRcbiAgKSIsInJ1bnMiOls2OSw3Myw3Myw2OSw2OSw3Myw3Myw2OSw3Myw2OSw2OSw3Myw2OSw3Myw3Myw3Myw3Myw3Myw3Myw2OSw2OSw3Myw2OSw3Myw3Myw3Myw3Myw2OSw2OSw3Myw2OSw3Myw3Myw3Myw2OSw2OSw2OSw2OSw2OSw3Myw2OSw2OSw2OSw2OSw2NCw2NCw2NCw2NCw2MCw2NCw2NCw2MCw2NCw2NCw1Niw2OSw0Myw0Myw2MCw0Myw2OSw0Nyw2OSw2OSw1Niw2NCw2NCw2NCw2NCw2NCw2NCw2NCw2NCw0Nyw2OSw2NCw2MCwzNCw2NCw1MSwzNCw2MCw2OSw0Nyw2NCw2NCw1Niw0Nyw2NCw2NCw2NCw2NCw1Niw0Nyw1Niw1Niw2MCw2MCw2MCw2OV0sIm9wcyI6NjR9LHsibmFtZSI6IkZvciBhd2FpdCBvZiIsImNvZGUiOiJmb3IgYXdhaXQgKGNvbnN0IHBva2VJZCBvZiBwb2tlbW9uSWRzKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtwb2tlQXBpfXBva2Vtb24vJHtwb2tlSWR9YCk7XG5cdFx0Y29uc3Qge25hbWV9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gIFx0Y29uc29sZS5sb2coZS5tZXNzYWdlKTtcbiAgfVxuXHR9IiwicnVucyI6WzM4LDM4LDM4LDM4LDM0LDM0LDM4LDM4LDM4LDM0LDM4LDM4LDM0LDM4LDM4LDM4LDM4LDM4LDM4LDM0LDM4LDM4LDM4LDM4LDM4LDM4LDM4LDM0LDM4LDM4LDM4LDM4LDM0LDM4LDM4LDM4LDM0LDM0LDM0LDM4LDM0LDM4LDM0LDM0LDMwLDM0LDMwLDM0LDMwLDMwLDM0LDMwLDMwLDM0LDI1LDM4LDE3LDIxLDMwLDIxLDM0LDI1LDM0LDM4LDMwLDMwLDMwLDMwLDMwLDMwLDM0LDMwLDM0LDIxLDM0LDMwLDMwLDE3LDMwLDI1LDE3LDMwLDM4LDIxLDMwLDMwLDI1LDIxLDM0LDMwLDMwLDMwLDI1LDIxLDI1LDMwLDI1LDI1LDMwLDM0XSwib3BzIjozMn1dLCJ1cGRhdGVkIjoiMjAyMi0wMi0yN1QwOTo1MjoxNy4yNzRaIn0%3D" rel="noopener ugc nofollow" target="_blank">比</a>慢两倍，如下图所示。所以作为一个经验法则，我推荐使用<code class="fe lt lu lv lw b">Promise.all()</code>，只有在承诺的并发处理导致问题时才切换到<code class="fe lt lu lv lw b">for await...of</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/1a082e4a12197b40987a7cfd65a15253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-H2fVr-jIy6FqOmIqf9Rg.png"/></div></div></figure><h2 id="dcae" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">“Promise.all()”对“Promise.allSettled()”</h2><p id="082e" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">到目前为止，我们对PokéApi的所有调用都是成功的。但是如果在获取一个口袋妖怪的时候出错了呢？使用<code class="fe lt lu lv lw b">for await of</code>我们在每次迭代中捕捉错误。例如，如果获取id为2的口袋妖怪失败了，我们可以处理错误并进入下一次迭代。</p><p id="b671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相比之下，<code class="fe lt lu lv lw b">Promise.all()</code>默认情况下会快速失败，这意味着如果调用失败，整个承诺都会被拒绝。因此，如果在获取第三个口袋妖怪时发生错误，执行就会停止，我们会收到一条错误消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/a95b3691e9b95419974c29fc2b2aed42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEaUvElCTpjXOtCamtKdUw.png"/></div></div></figure><p id="69c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某些情况下<em class="ls">快速失效</em>非常方便。例如，假设需要所有口袋妖怪名称来执行后续操作。在这种情况下，快速失败是好的，因为您不想在剩余的调用上浪费资源。</p><p id="6553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在其他情况下，您希望所有电话要么被拒绝，要么被满足。例如，如果获取的口袋妖怪被用于一个单独的后续任务，或者我们想要显示和访问每个调用的错误信息，快速失败是很麻烦的。</p><p id="e7f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，<code class="fe lt lu lv lw b">Promise.allSettled()</code>是更明智的选择。这个函数非常类似于<code class="fe lt lu lv lw b">Promise.all()</code>，但是它不是快速失败，而是返回一个承诺，该承诺在所有给定的承诺完成或被拒绝后解决。前一个例子的结果，在<code class="fe lt lu lv lw b">index === 2</code>有一个错误的调用，使用<code class="fe lt lu lv lw b">Promise.allSettled()</code>将如下所示。我们看到四个呼叫被完成，但是索引为2的呼叫被拒绝。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="bf66" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">结论</h2><p id="5c07" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">总之，这三种方法都能够处理可重复的承诺，但在功能上略有不同。如果解决承诺的顺序对你很重要，使用<code class="fe lt lu lv lw b">for await of</code>。如果订单不重要，并且您需要所有电话都成功，请使用<code class="fe lt lu lv lw b">Promise.all()</code>。如果订单不重要，并且您并不绝对需要所有的单独电话才能成功，请使用<code class="fe lt lu lv lw b">Promise.allSettled()</code>。</p><h2 id="bea8" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">资源</h2><ul class=""><li id="95d4" class="na nb iq ky b kz mq lc mr lf nc lj nd ln ne lr nf ng nh ni bi translated">Promise . all():<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Promise/all</a></li><li id="ad49" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">Promise . all settled():<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Promise/all settled</a></li><li id="1b4a" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">for await…of:<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...</a>的</li><li id="401c" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">https://pokeapi.co/<a class="ae kv" href="https://pokeapi.co/" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="6fcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">说白了就是</em> </strong> </a> <em class="ls">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">Twitter</em></strong></a><em class="ls">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">LinkedIn</em></strong></a><em class="ls">。加入我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">社区</em> </strong> </a> <em class="ls">。</em></p></div></div>    
</body>
</html>