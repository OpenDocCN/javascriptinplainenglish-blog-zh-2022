<html>
<head>
<title>The 4 Creational Patterns You Need To Know To Become A Senior Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成为高级开发人员需要知道的4种创造模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-4-creational-patterns-you-need-to-know-to-become-a-senior-developer-e2d8c0a26b8f?source=collection_archive---------2-----------------------#2022-03-17">https://javascript.plainenglish.io/the-4-creational-patterns-you-need-to-know-to-become-a-senior-developer-e2d8c0a26b8f?source=collection_archive---------2-----------------------#2022-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8280" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">代码的目标不仅仅是工作。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1657d803d6b751901847a823e2d89999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2B-p77pN9DvfHB197xxn5A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image Made By Author via Canva</figcaption></figure><p id="6bba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在编码的早期，有效的代码是你的单一目标。当坚持这种态度时，你的代码看起来就像意大利面食。发展你的技能意味着遇到<strong class="kx ir">软件设计模式</strong>，你的代码将看起来像罗马的万神殿。</p><p id="eded" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您使用软件模式来解决与现代开发人员相关的常见问题。</p><p id="bcdd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">设计模式分为<code class="fe ls lt lu lv b">creational</code>、<code class="fe ls lt lu lv b">structural</code>、&amp;、<code class="fe ls lt lu lv b">behavioral</code>。本文主要关注4种<code class="fe ls lt lu lv b">creational</code>设计模式以及使用它们的优缺点。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="af30" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Singleton —已经在JavaScript中实现</h1><p id="8891" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">第一种模式非常容易理解。</p><p id="15ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一种只能实例化一次的对象。在<em class="lr"> TypeScript </em>中，你可以实现一个名为<code class="fe ls lt lu lv b">Config</code>的类。它代表全局应用程序配置数据。因此，您给它一个静态实例属性，然后在构造函数前面添加private。它不能再用关键字<code class="fe ls lt lu lv b">new</code>实例化。</p><p id="d9f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后创建一个静态的<code class="fe ls lt lu lv b">getInstance()</code>方法来检查实例是否已经创建。如果没有，它将创建一个新的，确保只有一个对象可以存在。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="0704" class="nc me iq bd mf nd ne dn mj nf ng dp mn le nh ni mp li nj nk mr lm nl nm mt nn bi translated">听起来很棒！但是细节决定成败。</h2><p id="48f3" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated"><em class="lr"> JavaScript </em>允许你创建<strong class="kx ir">对象文字</strong>。此外，它持有全局数据的概念。用通过引用传递的对象将两者结合起来。💣！</p><p id="c16e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">通过创建一个简单的全局对象，您可以获得该模式的基本特征。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="07c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用JavaScript意味着这种模式对你没有用。它会转换成你不需要的样板文件。</p><blockquote class="no np nq"><p id="cae2" class="kv kw lr kx b ky kz jr la lb lc ju ld nr lf lg lh ns lj lk ll nt ln lo lp lq ij bi translated"><em class="iq">🔥在面向对象语言中，这是一个完全不同的故事。在到处传播设计模式之前，依靠你的语言的内置特性。</em></p></blockquote></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="3143" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">原型—在扁平的层次结构中共享功能</h1><p id="0870" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">“原型”只是克隆人<em class="lr">的一个通俗词汇。</em></p><p id="727b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">你知道面向对象编程吗？你应该对继承很熟悉。<strong class="kx ir">如果不是</strong> —一个类可以用一个子类来扩展。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2aa4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">简单。但是继承的主要问题是它会导致复杂的代码层次:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/c6148dcafd83e1d339054897046d4201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fObSWIdCDDEwTzWP.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Complex Hierarchy (picture by <a class="ae nv" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.researchgate.net%2Ffigure%2FClass-hierarchy-of-the-framework_fig1_220420202&amp;psig=AOvVaw1yM_J7Y60meeYnhrg82g5N&amp;ust=1647542462236000&amp;source=images&amp;cd=vfe&amp;ved=0CAwQjhxqFwoTCJCn1Iyky_YCFQAAAAAdAAAAABAO" rel="noopener ugc nofollow" target="_blank">ResearchGate</a>)</figcaption></figure><p id="4349" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">原型模式解决了提到的<em class="lr">主要问题</em>。它通过使用两个方面来做到这一点:</p><ul class=""><li id="38e3" class="nw nx iq kx b ky kz lb lc le ny li nz lm oa lq ob oc od oe bi translated">来自一个已经存在的物体</li><li id="9d34" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">创建平面原型链</li></ul><p id="337e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两者都使得在对象之间共享功能变得更加容易。</p><p id="bf38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">主要是</em>支持原型继承的动态语言。<br/>🤫:<em class="lr"> JavaScript支持原型。</em></p><p id="e0f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">开箱即用，</strong>假设我们有一个名为<code class="fe ls lt lu lv b">hero</code>的对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="46f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们的原型。</p><p id="eb39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在您想基于它创建一个新的对象，它也有一个<code class="fe ls lt lu lv b">name</code>。你可以通过将<code class="fe ls lt lu lv b">hero</code>作为原型，用<code class="fe ls lt lu lv b">Object.create()</code>来实现。最后，指定更多属性。对于新的对象，我们坚持使用<code class="fe ls lt lu lv b">name</code>→<code class="fe ls lt lu lv b">Mario</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2ad7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您记录这个对象，您将只能看到名称而不能看到<code class="fe ls lt lu lv b">findPrincess()</code>方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/0c099cf39a9f3859fcabe3ddf1cf4721.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*49Rp33hoZoh3FPJ9MCOq6w.png"/></div></figure><p id="8269" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，如果你试着调用那个方法，它甚至会工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/e6d36b3cedcd5dff208422d0bb33323d.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*1rzJRYIlNFttMwjQJvHt3w.png"/></div></figure><p id="0012" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么？因为JavaScript沿着原型链向上，直到到达根。您总是可以通过使用这个<code class="fe ls lt lu lv b">__proto__</code>属性从一个对象获得原型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/cea5ec363411cb84fc415a93cbc6d44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*dcpY6R-YAWRBGwouXU1SyA.png"/></div></figure><p id="3399" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但这也不是现代的最佳实践。棉绒已经用黄色做了标记。你应该用<code class="fe ls lt lu lv b">Object.getPrototypeOf()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="684e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对类使用prototype将总是引用它的构造函数。这意味着如果你愿意，你可以用额外的函数来扩展一个类。Ups，那也是<a class="ae nv" href="https://stackoverflow.com/questions/14034180/why-is-extending-native-objects-a-bad-practice" rel="noopener ugc nofollow" target="_blank">一般认为不好的做法</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d0d3ce2a9eb2bf17717a6dfa542ccc21.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*NAQZVdnTXyYpwNJfoO5qPg.png"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="7ca6" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">构建器—在逐步构建时使用</h1><p id="7eb3" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">注意构建器模式。</p><p id="7273" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想象一下，经营一家汉堡店，每个顾客都要下单。转折:他们需要告诉你汉堡上的每一种配料。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a9bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样的逻辑也适用于<strong class="kx ir">构造函数</strong>。虽然这很有效，但是跟踪所有这些成分很烦人，特别是如果你想把每一步推迟到以后。</p><p id="787d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用构建器模式，您只需一步一步地创建对象。使用多个方法，而不是单个大型构造函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5b92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您甚至可以将构建逻辑委托给不同的类。</p><p id="8383" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对对象实例的引用是您想要的回报。在JavaScript中，<code class="fe ls lt lu lv b">this</code>。这允许您实现方法链接。简单地实例化一个对象，链接方法调用，但是总是得到这个东西作为返回值。</p><p id="b012" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">这个模式太棒了，你不需要调用所有的步骤。您可以只调用那些必要的方法来创建对象的特定配置。</em></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="75d2" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">工厂—避免不必要的环境检查</h1><p id="d915" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">您可能会发现另一个非常有用的模式。</p><p id="cd57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常使用<code class="fe ls lt lu lv b">new</code>关键字来实例化对象。但是现在，您将使用一个<em class="lr">函数</em>或一个<em class="lr">方法</em>来实现。</p><p id="d508" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这听起来微不足道，但这里有一个实际的例子:想象你正在开发一个跨平台的应用程序，可以在T2的iPad和T4的iPhone上运行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c9b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它们都有相同的界面。您可能会做一些条件检查来决定在我们的代码中显示哪个布局。</p><p id="a453" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">不可维护</strong>😔</p><p id="ca9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对你来说，更好的选择是创建一个工厂来决定实例化哪个对象。您不用重复相同的逻辑，而是使用这个子类来决定应该呈现哪个布局。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="7ea7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">模式都很棒，但是你需要开动脑筋去应用。从堆栈溢出复制粘贴不起作用。以下是成为一名合格的精神开发者的8条规则。</em>T15】</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/33267b77f55e37ac1e3b520c9213d2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*IxqcyL2gohmFZlnYoG0nyw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">8 Rules To Become A Succesful Developer</figcaption></figure><p id="7e58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">更多内容请看</em> <a class="ae nv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">说白了就是</em> </strong> </a> <em class="lr">。报名参加我们的</em> <a class="ae nv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">免费每周简讯</em> </strong> </a> <em class="lr">。关注我们</em> <a class="ae nv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">推特</em> </strong> </a> <em class="lr">和</em><a class="ae nv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="lr">LinkedIn</em></strong></a><em class="lr">。加入我们的</em> <a class="ae nv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">社区不和谐</em> </strong> </a> <em class="lr">。</em></p></div></div>    
</body>
</html>