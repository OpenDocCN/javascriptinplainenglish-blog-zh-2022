<html>
<head>
<title>How to Implement the SOLID Principle in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中如何贯彻固体原理？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solid-principle-in-react-11272c41b529?source=collection_archive---------4-----------------------#2022-08-03">https://javascript.plainenglish.io/solid-principle-in-react-11272c41b529?source=collection_archive---------4-----------------------#2022-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="350e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于SOLID原理的基础以及如何在React中实现它的初学者教程。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/43d1f16d8ffb5f310b94942418fb9eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dKcAxO8y5cEv0Bs4"/></div></div></figure><p id="9fbc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本文将为您提供SOLID原则的基本概述，以及如何在React中实现它。对于每项技术，我们都有不同的方式来遵循这一原则。但是，使用React，很难在代码中应用这个原则。</p><p id="77a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">先来简单定义一下固体原理。这一原则有助于我们构建有助于以下目标的软件:</p><ul class=""><li id="007e" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><strong class="kq io"> <em class="lt">代码复用性。</em>T3】</strong></li><li id="3296" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><strong class="kq io">中的<em class="lt">便于在特性中进行代码修改。</em> </strong></li><li id="6382" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><strong class="kq io"> <em class="lt">使代码易于维护。</em>T11】</strong></li><li id="3ef2" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><strong class="kq io"> <em class="lt">易于编写的测试用代码。</em>T15】</strong></li></ul><h2 id="3887" class="lz ma in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">固体代表什么？</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/2d84b71e3aef8726aec1b014ea2564be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fyqq4IR08t72HzBEbjNo9g.png"/></div></div></figure><p id="8e70" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将详细讨论单词中的每一个字母。</p><h2 id="0d67" class="lz ma in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">单一责任</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/96cf05b13ba8872284783d03838f9317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*7ogrUFLNORaBCd4AD9W_fA.png"/></div></figure><blockquote class="mu"><p id="95fa" class="mv mw in bd mx my mz na nb nc nd lj dk translated">一个好的组件应该只有一个职责</p></blockquote><p id="0c01" class="pw-post-body-paragraph ko kp in kq b kr ne jo kt ku nf jr kw kx ng kz la lb nh ld le lf ni lh li lj ig bi translated">例如，将一个大部件分成几个小块:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/aa41dbd8ee5136f0c1456b4d34f8e2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgwIsqSbOUoZk2lgHq0dHw.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/b7ac3ae78bf34f34bcd77e4543fab666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utMGFAa9QHb9oZTADRVM-g.png"/></div></div></figure><p id="b74f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lt">这个原则的目标是</em> </strong>:</p><ul class=""><li id="e012" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">将做太多事情的大组件分解成小组件</li><li id="e419" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">将与主要组件功能无关的代码提取到单独的实用函数中(DateUtils，有些业务可以在不同的地方使用)</li><li id="9273" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">将组件的所有业务逻辑移动到定制钩子中(useEffect、handlers、states)</li></ul></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h2 id="ad0f" class="lz ma in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">o:打开-关闭</h2><blockquote class="mu"><p id="439e" class="mv mw in bd mx my ns nt nu nv nw lj dk translated">对扩展开放，但对修改关闭</p></blockquote><figure class="ny nz oa ob oc kh gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b15a9bf75c8adebf87212cc62dcd7498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*nWT3Jvuc6MtnEHKe1T0Ibw.png"/></div></figure><p id="f2c3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个原则与代码维护和新代码更改有关。为了便于理解系统中的原理示例，我们有一个现有的通用组件，它被用在我们项目的许多地方。</p><p id="307c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的组件应该有办法从外部改变，而不是修改自己。当你试图改变现有的组件，可能会有副作用，从其他地方使用它。</p><p id="8c56" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">代码示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/858389f49892a401fcf2d02272639c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*2texkSD6cQXi-dbi2sXnZw.png"/></div></figure><p id="568c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lt">这个原则的目标是:</em> </strong></p><p id="b106" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">新的代码改变不应该影响类的存在，或者它的影响应该尽可能的最小化。它有助于新特性(新代码变更)避免导致错误和影响原始类。相反，要直接修改按钮组件，我们应该应用一些模式，并确保可以从外部覆盖该组件:</p><ul class=""><li id="fb40" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">如果你想访问DOM元素<a class="ae oe" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/forwarding-refs.html</a>就使用forwardRef</li><li id="256b" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">通过有条件地将类名连接在一起，使样式易于从外部覆盖。<a class="ae oe" href="https://github.com/JedWatson/classnames" rel="noopener ugc nofollow" target="_blank">https://github.com/JedWatson/classnames</a></li><li id="24cf" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">使用“儿童”适当支持来自外部的动态内容，而不是仅固定文本值</li><li id="08d0" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">当我们试图编写一个新的测试用例并找到组件时，添加一个“data-testid”属性非常有用。</li></ul></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h2 id="2b42" class="lz ma in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">利斯科夫的替代和界面分离</h2><p id="2f8e" class="pw-post-body-paragraph ko kp in kq b kr of jo kt ku og jr kw kx oh kz la lb oi ld le lf oj lh li lj ig bi translated"><strong class="kq io"> <em class="lt">这个原则坚持OOP和继承概念(我们将跳过)</em> </strong></p><p id="5966" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以看看为什么我们不应该使用继承来重用React中组件之间的代码。</p><div class="ok ol gp gr om on"><a href="https://reactjs.org/docs/composition-vs-inheritance.html" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">组合vs继承-反应</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">React有一个强大的组合模型，我们建议使用组合而不是继承来重用代码…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">reactjs.org</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb km on"/></div></div></a></div><p id="bed6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，我们可以以不同的方式理解这两个原则如何使代码可重用，以及如何更有效地定义prop(组件的接口)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pc"><img src="../Images/8f10a11ad653b7fdc8d882336e9d88b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqEGj9jovXqMB4IGyqUyJQ.png"/></div></div></figure><p id="1255" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在示例中，您可以看到实现对话框和避免重复代码的最佳方式(基本对话框和错误/警告对话框—类似于类中的继承)。我们需要更有效地定义道具(接口)。</p><p id="8c40" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回到对话框中的例子，我们可以很容易地定义一个基本对话框，如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pd"><img src="../Images/63cc547d71da463ff91f190f3ed4d18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*ALYRzncsv8fPKXWZ62kzXA.png"/></div></div></figure><p id="c6b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么现在我们如何实现警告和错误对话框呢？我们不想对基本对话框组件产生副作用。从需求中，我们可以看到(页眉、内容和页脚)在不同的情况下非常复杂。一个好的做法是，我们应该将如何构建的内容传递给父组件，而不是。</p><p id="2ae0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">解决方案:</p><ul class=""><li id="7b1f" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">标题/内容应该作为React元素而不是文本来传递。</li><li id="27d3" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">公开一个新类型(default | error | warning)来处理基本组件中的某些特定样式(颜色、文本样式、页脚)。</li><li id="6b58" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">更有效地定义接口(组件属性)。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pe"><img src="../Images/22aa695222797f157fc7332282f90fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAvkDZWz5puKWM6dqrrkSg.png"/></div></div></figure><p id="59e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lt">这些原则的目标是</em> : </strong></p><ol class=""><li id="9734" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj pf lq lr ls bi translated">在React中，我们不使用继承来减少组件之间的重复代码。我们建议使用组合而不是继承来重用组件之间的代码。</li><li id="546d" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj pf lq lr ls bi translated">接口意味着父类和子类之间的连接。在React中，这类似于我们定义组件属性的方式。在React中，我们不使用继承来减少带有having关键字的组件之间的重复代码。如果在React中使用TypeScript，可以使用prop-types库(<a class="ae oe" href="https://github.com/facebook/prop-types" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/prop-types</a>)，这有助于查看组件属性是如何定义的。我们应该更有效地定义组件属性，使它们易于阅读和维护。</li></ol></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h2 id="049c" class="lz ma in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">依赖性倒置</h2><blockquote class="mu"><p id="4433" class="mv mw in bd mx my ns nt nu nv nw lj dk translated">一个人应该“依赖抽象，而不是具体。”-维基百科</p></blockquote><figure class="ny nz oa ob oc kh gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/6240240b1eaf15a97a70be6d731d8efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*H2BE0hCbvN4XZU9M-NJKyg.png"/></div></figure><p id="7533" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">换句话说，你可以认为一个组件本身不应该包含依赖(外部服务API调用)。我们不得不重新使用另一个地方的组件。外部服务应该以单一的方式工作，以减少相互之间的依赖，使代码变得清晰，易于其他组件使用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ph"><img src="../Images/cba27bae162b090d5cf141f7f9a0a7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9aURbfSxjRYcCL85ZLaUqg.png"/></div></div></figure><p id="a134" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">示例代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/0ee95baf6a1306d740250bc2300f2cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*UvuYeP4UQQlF4JoO9NgXqA.png"/></div></figure><p id="3b69" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">移动之后，所有的API调用组件:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/65a7d43f880bb983812116b5ed82e577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*jLuUev7aSn61ZRtoGgg3mw.png"/></div></figure><p id="5727" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在您看到容器是保存数据和控制组件间集成的地方。组件只对self-it的视图和行为做出响应。使组件可以重用，减少对它的依赖。</p><p id="dd73" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一个解决方案减少了API调用。我们可以使用一些技巧来解决这个问题:</p><ul class=""><li id="277c" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">特设高阶组件:<a class="ae oe" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/higher-order-components.html</a>。</li><li id="dc76" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">自定义钩子:在组件之间共享公共钩子。</li><li id="a1e0" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">Redux &amp; Reselector:管理应用程序状态以避免组件中的大量依赖。</li><li id="2aee" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">组件间集成的提供者。</li></ul></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h2 id="5a4a" class="lz ma in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">结论</h2><p id="8e98" class="pw-post-body-paragraph ko kp in kq b kr of jo kt ku og jr kw kx oh kz la lb oi ld le lf oj lh li lj ig bi translated">固不是万能的，用每一种语言你都会有办法处理这个问题。一些坚持OOP(类、接口、抽象)的原则不能应用于GUI编程(函数式编程)</p><p id="6b8e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不是一条规则，不要强迫你去想它。它帮助你思考如何使你的代码易于阅读和维护。</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="1e7e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lt">更多内容看</em> <a class="ae oe" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lt">说白了。报名参加我们的</em> <a class="ae oe" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lt">免费周报</em> </strong> </a> <em class="lt">。关注我们关于</em><a class="ae oe" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lt">Twitter</em></strong></a><a class="ae oe" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lt">LinkedIn</em></strong></a><em class="lt">，以及</em> <a class="ae oe" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lt">不和</em> </strong> </a> <em class="lt">。</em></strong></a></p></div></div>    
</body>
</html>