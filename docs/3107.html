<html>
<head>
<title>Analyzing TypeScript: Utility Types Under The Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析TypeScript:幕后的实用程序类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/analyzing-typescript-utility-types-under-the-hood-9855b8a33d28?source=collection_archive---------4-----------------------#2022-08-01">https://javascript.plainenglish.io/analyzing-typescript-utility-types-under-the-hood-9855b8a33d28?source=collection_archive---------4-----------------------#2022-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ccf5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们研究一下内置实用程序类型是如何实现的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f00c7c8dbea67f02a3bf1061e9f5607f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N_ACwbuyQMh3qcon"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@emilianovittoriosi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Emiliano Vittoriosi</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeScript <a class="ae kv" href="https://medium.com/@mariusbongarts/advanced-typescript-with-code-challenges-utility-types-e8c30efd9021" rel="noopener">实用程序类型</a>旨在让开发者的生活更轻松。它们随着每个TypeScript版本的发展而发展，并且添加了新的版本。</p><p id="304f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看内置实用工具类型的实现是掌握高级TypeScript功能的一个很好的练习。虽然我已经详细讨论了大多数高级TypeScript特性，但是我可以通过撰写本文来学习和重申我的知识。</p><blockquote class="ls"><p id="fba4" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">即使是打字稿的创作者也只用水做饭。</p></blockquote><p id="9787" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">如果您想在阅读本文之前复习一下知识，这里有一个关于许多高级TypeScript特性的文章的概述:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Overview Typescript Features</figcaption></figure><div class="mj mk gp gr ml mm"><a href="https://web-highlights.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">网络亮点- PDF和网络荧光笔</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">Web Highlights是一个在Web上突出显示文本的工具，可以更有效地组织您的研究。提升你的…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">web-highlights.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na kp mm"/></div></div></a></div></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="57c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ni">免责声明:</em> </strong> <em class="ni">本文假设您已经掌握了TypeScript实用工具类型的知识。如果你还没有，可以在本文</em>   <strong class="ky ir"> <em class="ni">中进一步了解他们</em> <a class="ae kv" href="https://medium.com/@mariusbongarts/advanced-typescript-with-code-challenges-utility-types-e8c30efd9021" rel="noopener"> <strong class="ky ir"> <em class="ni">。</em> </strong></a></strong></p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="5ff4" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">部分的</h1><p id="e69f" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated"><code class="fe og oh oi oj b">Partial&lt;Type&gt;</code>接受一个<a class="ae kv" href="https://medium.com/@mariusbongarts/advanced-typescript-generics-1b30d6b5dd49" rel="noopener">泛型类型</a>，并使所有属性<strong class="ky ir">成为可选属性</strong>。</p><p id="b11b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是TypeScript的实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/87a68971fb55b1f6da2771cfb469d34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijRsjeyr0pTg-AeBR3uMfg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd ol">Partial</strong> utility type</figcaption></figure><p id="b661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Partial的实现中，我们看到TypeScript使用了<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/advanced-typescript-with-code-challenges-mapped-types-6825c7fc984a">映射类型</a>。剧透:这不会是最后一个使用映射类型的<a class="ae kv" href="https://medium.com/@mariusbongarts/advanced-typescript-with-code-challenges-utility-types-e8c30efd9021" rel="noopener">实用程序类型</a>。因此，理解这一特性至关重要。</p><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/advanced-typescript-with-code-challenges-mapped-types-6825c7fc984a"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">具有代码挑战的高级类型脚本:映射类型</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">学习高级的TypeScript特性，并将它们应用到实际的代码练习中。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mv l"><div class="om l mx my mz mv na kp mm"/></div></div></a></div><p id="9b29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，<code class="fe og oh oi oj b">Partial&lt;T&gt;</code>接受了一个类型<code class="fe og oh oi oj b">T</code>，并遍历它的键，使用<code class="fe og oh oi oj b">?</code>使所有属性都是可选的。最后，使用类型索引来获取迭代属性的类型。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="2f7f" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">需要</h1><p id="4e64" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated">如果你理解了<code class="fe og oh oi oj b">Partial</code>类型，那么<code class="fe og oh oi oj b">Required&lt;Type&gt;</code>助手很简单，因为它做了相反的事情——使得所有属性都是<strong class="ky ir">必需的。</strong></p><p id="72f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是实现过程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/95236f1f97246679f947c70cf9ca6cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpMYsi9TSQPCJROcra2kXQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd ol">Required</strong> utility type</figcaption></figure><p id="75b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，映射类型用于遍历泛型类型<code class="fe og oh oi oj b">T</code>的键。与<code class="fe og oh oi oj b">Partial</code>类型相比，我们希望所有属性都是必需的。这就是为什么TypeScript通过使用减号<code class="fe og oh oi oj b">-</code>去掉了<code class="fe og oh oi oj b">?</code>修饰符。</p><p id="af22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还没有看到这个语法，那么理解您可以通过添加前缀<code class="fe og oh oi oj b">-</code>或<code class="fe og oh oi oj b">+</code>来删除或添加修饰语可能会有所帮助。如果不添加前缀，则假定为<code class="fe og oh oi oj b">+</code>。</p><p id="74e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，这两个接口是相同的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="cad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有那两个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="2f8d" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">挑选</h1><p id="c0ca" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated"><code class="fe og oh oi oj b">Pick&lt;Type, Keys&gt;</code>类型通过从<code class="fe og oh oi oj b">Type</code>中挑选一组属性<code class="fe og oh oi oj b">Keys</code>(字符串文字或字符串文字的<a class="ae kv" href="https://medium.com/@mariusbongarts/advanced-typescript-with-code-challenges-union-types-2474c6e62097" rel="noopener">联合</a>)来构造类型。</p><p id="2f41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种类型是如何设置的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/c3952ebfad125e9b47d45c5b927c86ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAjicOZ4wVKl9xUKIANd6g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd ol">Pick</strong> utility type</figcaption></figure><p id="3e66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这变得有点复杂，但是如果我们理解TypeScript <a class="ae kv" href="https://medium.com/@mariusbongarts/advanced-typescript-generics-1b30d6b5dd49" rel="noopener">泛型</a>和<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/advanced-typescript-with-code-challenges-mapped-types-6825c7fc984a">映射类型</a>，这就非常简单了。</p><p id="dbd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">泛型<code class="fe og oh oi oj b">Pick</code>类型接受两个泛型<code class="fe og oh oi oj b">T</code>和<code class="fe og oh oi oj b">K</code>。虽然<code class="fe og oh oi oj b">T</code>可以是任何东西，但是第二个泛型<code class="fe og oh oi oj b">K</code>联合类型需要是<code class="fe og oh oi oj b">T</code>的一个键。</p><p id="618a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦客户机提供了有效的泛型类型，它就简单地遍历所提供的联合类型<code class="fe og oh oi oj b">K</code>的键，并通过使用索引来访问它的属性类型。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="4229" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">省略</h1><p id="9930" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated">理解<code class="fe og oh oi oj b">Omit&lt;Type, Keys&gt;</code>类型很容易，因为它与<code class="fe og oh oi oj b">Pick</code>类型相反。我们没有将<code class="fe og oh oi oj b">Keys</code>添加到我们的类型中，而是从原来的类型中选择了<code class="fe og oh oi oj b">Keys</code>。</p><p id="283d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一下实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/7948694a6e563aaea98e4c4feefd83cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xyavrotiNSVHvRmHGuiFQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd ol">Omit</strong> utility type</figcaption></figure><p id="1efe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不可否认，它变得有点复杂。就像<code class="fe og oh oi oj b">Pick</code>类型一样，<code class="fe og oh oi oj b">Omit</code>类型接受两个泛型<code class="fe og oh oi oj b">T</code>和<code class="fe og oh oi oj b">K</code>。这里的区别是第二个泛型<code class="fe og oh oi oj b">K</code>需要是<code class="fe og oh oi oj b">any</code>的一个键。<code class="fe og oh oi oj b">any</code>的按键有:<code class="fe og oh oi oj b">string</code>、<code class="fe og oh oi oj b">number</code>或<code class="fe og oh oi oj b">symbol</code>。</p><p id="1c64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它利用<code class="fe og oh oi oj b">Pick</code>类型并使用<code class="fe og oh oi oj b">Exclude</code>助手类型来删除那些可分配给给定<code class="fe og oh oi oj b">K</code>联合类型的类型。</p><p id="ec9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">为什么</strong> <code class="fe og oh oi oj b"><strong class="ky ir">K</strong></code> <strong class="ky ir">是从</strong> <code class="fe og oh oi oj b"><strong class="ky ir">any</strong></code> <strong class="ky ir">延伸而来而不是</strong> <code class="fe og oh oi oj b"><strong class="ky ir">T</strong></code> <strong class="ky ir">？</strong></p><p id="57b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还在关注，你可能会遇到同样的问题。至少我很迷茫，觉得自己错过了什么。从<code class="fe og oh oi oj b">T</code>扩展会给我们更好的自动完成和类型安全。</p><p id="86d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我做了谷歌研究，发现有一个公开的<a class="ae kv" href="https://github.com/microsoft/TypeScript/issues/30825" rel="noopener ugc nofollow" target="_blank"> Github问题</a>有相同的想法。尽管如此，仍然有很多讨论，因为当从<code class="fe og oh oi oj b">T</code>继承时，可能会有可能导致问题的边缘情况。</p><p id="a25c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你对此有什么看法？就个人而言，我希望有一个更严格版本的<code class="fe og oh oi oj b">Omit</code>类型。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="5bcd" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated"><strong class="ak">记录</strong></h1><p id="6fc3" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated"><code class="fe og oh oi oj b">Record&lt;Keys, Type&gt;</code>类型对于定义具有特定键和值类型的类型很有用。</p><p id="8ba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/8074072e97986dbe34f917c0b46b78eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ul5L13vLnbqgBtyIODsUSQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd ol">Record</strong> utility type</figcaption></figure><p id="b71d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个泛型参数<code class="fe og oh oi oj b">K</code>定义了对象的键，这些键继承自<code class="fe og oh oi oj b">keyof any</code> <strong class="ky ir">(字符串，数字，符号)</strong>。第二个泛型定义了我们的属性键的类型。</p><p id="8210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，它再次简单地遍历提供的类型<code class="fe og oh oi oj b">K</code>的键，并且类型<code class="fe og oh oi oj b">T</code>被赋值。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="3303" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">排除</h1><p id="cf68" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated">类型从联合中移除类型。这种类型是前面提到的第一种利用<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/advanced-typescript-with-code-challenges-conditional-types-8dd4e63818a5">条件类型</a>的实用程序类型。</p><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/advanced-typescript-with-code-challenges-conditional-types-8dd4e63818a5"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">具有代码挑战的高级类型脚本:条件类型</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">学习高级的TypeScript特性，并将它们应用到实际的代码练习中</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mv l"><div class="om l mx my mz mv na kp mm"/></div></div></a></div><p id="4e92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/advanced-typescript-with-code-challenges-conditional-types-8dd4e63818a5">条件类型</a>是理解实用程序类型实现的另一个关键类型脚本特性。下面是<code class="fe og oh oi oj b">Exclude</code>类型的实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/cf0dbb5ee295579033ad899c9e45458d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ChMxyN3bOgInE5XPuZoDg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd ol">Exclude</strong> utility type</figcaption></figure><p id="ace9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该类型采用两个泛型:</p><ul class=""><li id="c3a4" class="os ot iq ky b kz la lc ld lf ou lj ov ln ow lr ox oy oz pa bi translated"><code class="fe og oh oi oj b">T</code>代表任何工会类型</li><li id="3a1c" class="os ot iq ky b kz pb lc pc lf pd lj pe ln pf lr ox oy oz pa bi translated"><code class="fe og oh oi oj b">K</code>哪一个表示应该排除的联合类型</li></ul><p id="f6b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在条件类型中，检查联合类型<code class="fe og oh oi oj b">T</code>是否继承自联合类型<code class="fe og oh oi oj b">U</code>。如果是这种情况，我们返回<code class="fe og oh oi oj b">never</code>，这将导致从<code class="fe og oh oi oj b">T</code>中删除给定的类型。否则，返回<code class="fe og oh oi oj b">T</code></p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="529a" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">ReturnType</h1><p id="88d2" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated"><code class="fe og oh oi oj b">ReturnType&lt;Type&gt;</code>实用程序类型提取函数类型的返回类型。</p><p id="9e62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提前一件事:它变得更加复杂。要理解<code class="fe og oh oi oj b">ReturnType</code>，我们需要理解一件主要的事情——推断关键词<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/advanced-typescript-with-code-challenges-infer-keyword-5ef686d77a3c"><strong class="ky ir"/></a>。</p><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/advanced-typescript-with-code-challenges-infer-keyword-5ef686d77a3c"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">具有代码挑战的高级类型脚本:推断关键字</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">学习高级的TypeScript特性，并将它们应用到实际的代码练习中。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mv l"><div class="om l mx my mz mv na kp mm"/></div></div></a></div><p id="e1a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe og oh oi oj b">ReturnType</code>的实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/a3de697212dd515bffa58d8185bf51cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPAPd9xD3XMfQb-jeHJKOA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd ol">ReturnType</strong> utility type</figcaption></figure><p id="2c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该类型接受从任何函数继承的类型<code class="fe og oh oi oj b">T</code>。之后，它检查<code class="fe og oh oi oj b">T</code>是否从任何函数类型继承，<strong class="ky ir">推断</strong>它的返回类型，并将类型<code class="fe og oh oi oj b">R</code>赋给它。如果提供的类型<code class="fe og oh oi oj b">T</code>继承自任何函数，则返回<strong class="ky ir">推断的</strong>返回类型<code class="fe og oh oi oj b">R</code>。否则返回<code class="fe og oh oi oj b">any</code>。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="2e2c" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">因素</h1><p id="014d" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated"><code class="fe og oh oi oj b">Parameters&lt;Type&gt;</code>助手从函数参数中使用的类型构造一个元组类型。</p><p id="e214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe og oh oi oj b">ReturnType&lt;Type&gt;</code>实用程序类型相比，<code class="fe og oh oi oj b">Parameters&lt;Type&gt;</code>类型不提取任何函数的返回类型，只提取<strong class="ky ir">参数</strong>。</p><p id="b0a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，实现看起来非常相似:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/afd8d4d23884c5e92644d0f040ee9308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZK2SUy9Q1EKF_bKoJwT4w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd ol">Parameters</strong> utility type</figcaption></figure><p id="a419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，该类型接受一个从任何函数继承的类型<code class="fe og oh oi oj b">T</code>。之后，它检查<code class="fe og oh oi oj b">T</code>是否继承自任何函数类型。现在不是推断返回类型，参数<code class="fe og oh oi oj b">P</code>是<strong class="ky ir">推断</strong>。如果提供的类型<code class="fe og oh oi oj b">T</code>继承自任何函数，则返回<strong class="ky ir">推断的</strong>参数<code class="fe og oh oi oj b">P</code>。否则返回<code class="fe og oh oi oj b">never</code>。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="96ce" class="nj nk iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">最后的想法</h1><p id="7ff5" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated">不一定需要理解内置实用程序的实现，因为开发它们是为了帮助我们更容易地编写代码。尽管如此，分析它们有助于我们更好地理解更高级的TypeScript特性。详细了解TypeScript将有助于您编写更好的未来代码。</p><p id="4696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢阅读这篇文章。我总是乐于回答问题，并乐于接受批评。随时欢迎联系我！通过<strong class="ky ir"/><a class="ae kv" href="https://www.linkedin.com/in/marius-bongarts-6b3638171/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">LinkedIn</strong></a><strong class="ky ir">，</strong>关注我<strong class="ky ir"/><a class="ae kv" href="https://twitter.com/MariusBongarts" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Twitter</strong></a>或<a class="ae kv" href="https://medium.com/subscribe/@mariusbongarts" rel="noopener"> <strong class="ky ir">订阅</strong> </a>通过电子邮件获取我的故事。</p><p id="7d66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@mariusbongarts/membership" rel="noopener"> <strong class="ky ir">这里是无限制访问介质上每一个内容的链接</strong> </a>。如果你注册使用这个链接，我会赚一小笔钱，不需要你额外付费。</p><div class="mj mk gp gr ml mm"><a href="https://medium.com/@mariusbongarts/membership" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">通过我的推荐链接加入Medium-Marius bong arts</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="pi l mx my mz mv na kp mm"/></div></div></a></div></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h2 id="4bee" class="pj nk iq bd nl pk pl dn np pm pn dp nt lf po pp nv lj pq pr nx ln ps pt nz pu bi translated">关于作者</h2><p id="206e" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated">我是埃森哲软件工程分析师宋。我们一直在寻找最好的开发人员，所以如果你有兴趣加入我们，请随时联系我们！</p><p id="3fe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最驱动我的是我想创造一些对他人有帮助和改变生活的东西的冲动🙌比如你是否厌倦了浏览自己的历史来寻找前几天看到的信息？我的<a class="ae kv" href="https://chrome.google.com/webstore/detail/web-highlights-%20-bookmark/hldjnlbobkdkghfidgoecgmklcemanhm" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">网站重点介绍Chrome扩展</strong> </a>覆盖了你，并将通过以结构化和高效的方式组织你的研究来提高你的生产力。就像你在书和文章上做的那样，突出显示任何网页或PDF上的文本。你的精彩片段会直接同步到web-highlights.com<a class="ae kv" href="https://web-highlights.com/" rel="noopener ugc nofollow" target="_blank">的网络应用上，你可以在任何地方找到它们。</a></p><div class="mj mk gp gr ml mm"><a href="https://chrome.google.com/webstore/detail/web-highlights-pdf-web-hi/hldjnlbobkdkghfidgoecgmklcemanhm" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">Web亮点— PDF和Web荧光笔</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">在每个网站或PDF上创建亮点、书签、标签和文件夹。以结构化的方式组织您的想法和研究…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">chrome.google.com</p></div></div><div class="mv l"><div class="pv l mx my mz mv na kp mm"/></div></div></a></div></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h2 id="d206" class="pj nk iq bd nl pk pl dn np pm pn dp nt lf po pp nv lj pq pr nx ln ps pt nz pu bi translated">进一步阅读</h2><div class="mj mk gp gr ml mm"><a href="https://medium.com/@mariusbongarts11/my-journey-to-the-first-9-99-with-my-side-project-3edc13dd1f2d" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">我的第一个9.99美元之旅与我的副业</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">Chrome扩展带来的被动收入</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="pw l mx my mz mv na kp mm"/></div></div></a></div><div class="mj mk gp gr ml mm"><a href="https://medium.com/@mariusbongarts/will-web-components-replace-frontend-frameworks-535891d779ba" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">Web组件会取代前端框架吗？</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">它们是为解决不同的问题而构建的。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="px l mx my mz mv na kp mm"/></div></div></a></div><div class="mj mk gp gr ml mm"><a href="https://levelup.gitconnected.com/are-web-components-dead-12e404e0f4b0" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">Web组件死了吗？</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">最近，我发表了一篇关于类似主题的不同问题的文章:Web组件会取代前端吗…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mv l"><div class="py l mx my mz mv na kp mm"/></div></div></a></div><p id="3253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">说白了就是io </em> </strong> </a> <em class="ni">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">免费周报</em> </strong> </a> <em class="ni">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ni">Twitter</em></strong></a><em class="ni">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ni">LinkedIn</em></strong></a><em class="ni">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">社区不和谐</em> </strong> </a> <em class="ni">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">人才集体</em> </strong> </a> <em class="ni">。</em></p></div></div>    
</body>
</html>