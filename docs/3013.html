<html>
<head>
<title>Find the Closest Value in a Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在二叉查找树中查找最接近的值</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/closest-value-in-binary-search-tree-3969bf8dfb03?source=collection_archive---------11-----------------------#2022-07-21">https://javascript.plainenglish.io/closest-value-in-binary-search-tree-3969bf8dfb03?source=collection_archive---------11-----------------------#2022-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="97ff" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">解决AlgoExpert的实践问题:在二叉查找树中寻找最接近的值。</h2></div><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div></figure><p id="0c2d" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我坚持我的二叉树是棕榈树…</p><p id="37ae" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">最近，我开始解决AlgoExpert的练习题，我真的很喜欢它。在我看来，提供的解决方案和界面的整体感觉比LeetCode更令人愉快。</p><p id="6618" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">今晚的问题是让我找出二叉查找树中最接近的值(目标值)。</p><p id="8e39" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io">深思熟虑(天真的解决方案)</strong></p><p id="07a8" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">首先，我将从树中收集所有的值。</p><p id="7967" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">然后遍历它们，检查它们与目标的接近程度。</p><p id="f470" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">返回离目标最近的一个。</p><p id="0279" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io">实施</strong></p><p id="1752" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">听起来很简单，就时间和空间复杂性值得怀疑的天真、简单的解决方案而言，它是可行的。</p><p id="a5e6" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们从BST类开始:</p><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div></figure><p id="5eba" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在伪代码是:</p><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div></figure><p id="e6a5" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在是完整的代码:</p><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div></figure><p id="d189" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这是一种非常简单的方法，实现起来也很有趣，但是在时间和空间复杂度方面，我们肯定可以做得更好。</p><p id="5ed5" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在这一点上，因为我们正在访问和存储每个值，我们正在寻找O(n)的时间和空间复杂度。</p><p id="00d6" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io">优化</strong></p><p id="1621" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">二叉查找树结构的一个最好的方面是它允许我们O(log n)的搜索时间复杂度。所以我想尝试，至少尽可能接近这一点。</p><p id="9386" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io">通过</strong>重新思考</p><p id="31d2" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这一次，我没有遍历树的整个DFS，而是使用二叉树规则来标记具有最接近目标值的分支的路径:</p><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi lf"><img src="../Images/be9f9c005be26140663b6205444e55d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8iVsEM3omzYfI0Z2F2gjA.jpeg"/></div></div></figure><p id="ff2d" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我基本上将使用我的目标值(在本例中为12)来指导我的遍历。我将沿途保存我访问过的节点，然后简单地遍历它们，并确定哪一个最接近12。</p><p id="0513" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，我已经有效地将遍历的时间复杂度缩小到O(log n ),但是通过对以前访问过的节点进行额外的迭代，我实际上可能更接近O(n log n)。</p><p id="bb17" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这是我想到的方法:</p><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div></figure><p id="99a8" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">虽然它的工作，我很高兴对优化的尝试，我想听听其他人的想法，所以如果有什么突出了你，请随时给我发消息！</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="7a24" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lt">更多内容请看</em><a class="ae lu" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kl io"><em class="lt">plain English . io</em></strong></a><em class="lt">。报名参加我们的</em> <a class="ae lu" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl io"> <em class="lt">免费周报</em> </strong> </a> <em class="lt">。关注我们关于</em><a class="ae lu" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kl io"><em class="lt">Twitter</em></strong></a><em class="lt">和</em><a class="ae lu" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kl io"><em class="lt">LinkedIn</em></strong></a><em class="lt">。查看我们的</em> <a class="ae lu" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kl io"> <em class="lt">社区不和谐</em> </strong> </a> <em class="lt">加入我们的</em> <a class="ae lu" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kl io"> <em class="lt">人才集体</em> </strong> </a> <em class="lt">。</em></p></div></div>    
</body>
</html>