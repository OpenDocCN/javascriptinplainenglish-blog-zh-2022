<html>
<head>
<title>A Look at the Redux connect() Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看看Redux connect()函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-look-at-the-redux-connect-function-8b7c1fb8e357?source=collection_archive---------9-----------------------#2022-01-11">https://javascript.plainenglish.io/a-look-at-the-redux-connect-function-8b7c1fb8e357?source=collection_archive---------9-----------------------#2022-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6a2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">众所周知，React是当今构建用户界面(ui)最流行的库之一。我相信阅读这篇博客的大多数人在之前的项目中都使用过Redux来管理应用程序的整体状态。</p><p id="0971" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想知道redux connect()函数是如何工作的吗？或者说编写connect()函数涉及的各种JavaScript概念是什么？</p><p id="7d38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我将向您介绍编写我们自己的connect()函数所涉及的JavaScript概念，然后可以将该函数集成到Redux库中并结合使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96e48e2be88309dc0aca5d328aed444a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLxChyEPVgf4ArNA_Ibl0A.jpeg"/></div></div></figure><h2 id="237c" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak"> <em class="ln">根据Redux文档，connect()函数返回</em> </strong></h2><blockquote class="lo"><p id="4330" class="lp lq in bd lr ls lt lu lv lw lx kh dk translated">connect()的返回是一个包装器函数，它接受您的组件并返回一个包装器组件及其注入的附加属性。大多数情况下，包装器函数会被立即调用，而不会保存在临时变量:<code class="fe ly lz ma mb b">export default connect(mapStateToProps, mapDispatchToProps)(Component)</code>中。</p></blockquote><p id="b13b" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">首先，让我们看看JavaScript中的高阶函数。</p><blockquote class="mh mi mj"><p id="6670" class="jk jl mk jm b jn jo jp jq jr js jt ju ml jw jx jy mm ka kb kc mn ke kf kg kh ig bi translated"><strong class="jm io">什么是高阶函数？</strong></p></blockquote><p id="ec54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript将函数视为一等公民，这意味着一个函数可以返回另一个函数，或者一个函数可以作为参数传递给其他函数，甚至可以将函数作为值存储在变量中。</p><p id="4859" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，高阶函数只是返回另一个函数或接受一个函数作为参数的函数。</p><p id="635d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mk"> Redux的connect()函数是一个高阶函数，它以两个函数作为参数(mapStateToProps和mapDispatchToProps)，它还返回一个包装组件的函数。</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="804b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经看到了Redux的connect()函数的上述实现，我们知道connect()是一个高阶函数。在编写我们自己的connect()函数之前，我们需要了解闭包和curry。</p><h2 id="36d2" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">阿谀奉承</strong></h2><p id="8ea0" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">Currying是函数式编程中的一个过程，在这个过程中，我们可以将一个具有多个参数的函数转换成一系列嵌套函数。它返回一个新函数，该函数需要内联的下一个参数。</p><p id="81f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个JavaScript的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7713" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">迷茫？这个概念如何应用于现实世界的场景。让我给你一个场景。</p><p id="42d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">在我们的应用中，有些计算结果需要加倍。我们通常通过以下方式将带有2的结果作为参数传递给multiply函数:multiply(result，2)；</em></p><p id="1263" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">一个函数可以从currying返回，因此如果需要，它可以被存储并与其他参数集一起使用。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d0d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望您已经了解了redux如何使用currying实现connect()()函数。</p><pre class="kj kk kl km gt mv mb mw mx aw my bi"><span id="7555" class="ku kv in mb b gy mz na l nb nc">export default connect(mapStateToProps, mapDispatchToProps)(OurComponent);</span></pre><h2 id="db21" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">关闭</strong></h2><p id="58a1" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">闭包只是指内部函数可以访问外部函数的范围，即使在外部函数已经被执行并从调用栈中移除之后。</p><p id="c298" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有一个外函数A和一个内函数b。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="adc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从高阶函数Currying的概念中，我们了解到connect()()函数是一个HOF(高阶函数),它接受两个函数作为参数，并返回一个匿名函数，我们通过使用Currying调用它来包装我们的组件。</p><p id="7ac2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">因此connect()是一个外部函数，而返回的匿名函数是一个内部函数，所以传递给connect()的属性可以被匿名内部函数访问，即使在connect()使用闭包完成执行之后。</em></p><p id="1621" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">现在所有这些都准备好了，让我们继续编写我们自己的connect()函数</em></p><p id="5fd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mk">我们自己写connect()函数</em> </strong></p><p id="ed5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">我们将使用一个starter应用程序计数器，它具有连接到redux存储的递增/递减操作。所以计划是先编写我们自己的connect函数，然后将工作应用程序与它集成。</em></p><p id="eef3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">计数器应用程序的GitHub链接如下:</p><p id="ba88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae nd" href="https://github.com/itzzmeakhi/blog-code-rep/tree/main/own-connect-fn-starter" rel="noopener ugc nofollow" target="_blank">T13】Github-own _ connect _ fn _ starterT15】</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/5d9e0c2215d48bbf06c003fd40cd4904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0FItl_vyKwXwOoKIvI4tQ.jpeg"/></div></div></figure><p id="2463" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">一个简单的计数器应用程序，其中的计数器值存储在redux store中，可以通过调度redux操作和更新reducer来递增或递减。计数器组件使用react-redux connect()函数连接到redux存储。</em></p><p id="e768" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的理解是connect()是一个HOF(高阶函数)，以两个函数为自变量，返回一个匿名函数。让我们以这个想法为基础。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="54fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，匿名函数接收我们的组件作为参数，我们可以通过Currying传递它。接下来，我们将在匿名函数中创建匿名类组件，该类将由匿名函数返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dc43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们使用一个匿名类来返回基于HOF模式的匿名函数中的WrappedComponent。</p><p id="cf89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在可以传递组件属性以及mapStateToProps和mapDispatchToProps生成的属性。该实现声明mapStateToProps需要一个总体redux状态和组件属性作为参数，而mapDispatchToProps需要一个调度函数和组件属性作为参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a2f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以用this.props访问组件props，但是我们如何获得redux store的状态和分派方法呢？</p><p id="a6f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在将redux集成到我们的应用程序的过程中，将会创建一个商店。我们将导出该存储并将其导入到我们的connectFn文件中。我们可以使用存储对象来访问它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="acbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有工作要做。此时，您可能会观察到屏幕上显示的组件没有任何错误，但是当单击递增/递减时，计数器的值不会更新。这是因为每当组件的状态改变时，我们都必须重新渲染它。</p><p id="4ac7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过订阅存储并在状态发生变化时呈现它来做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a6fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以导入连接Fn，并且可以如下使用:</p><pre class="kj kk kl km gt mv mb mw mx aw my bi"><span id="b9eb" class="ku kv in mb b gy mz na l nb nc">export default connectFn(mapStateToProps, mapDispatchToProps)(Counter);</span></pre><p id="0889" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！我们构建了自己的connect()函数，并将其与Redux存储集成在一起。</p><p id="d467" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae nd" href="https://github.com/itzzmeakhi/blog-code-rep/tree/main/own-connect-fn-final" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中的最终代码</p><p id="aede" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这是有用的<br/>❤️将是真棒😊</p><h1 id="47d8" class="nf kv in bd kw ng nh ni kz nj nk nl lc nm nn no lf np nq nr li ns nt nu ll nv bi translated">快乐编码</h1><p id="3002" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated"><em class="mk">更多内容尽在</em> <a class="ae nd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mk">说白了. io </em> </strong> </a> <em class="mk">。报名参加我们的</em> <a class="ae nd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mk">免费周报</em> </strong> </a> <em class="mk">。在我们的</em> <a class="ae nd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mk">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="mk">。</em></p></div></div>    
</body>
</html>