<html>
<head>
<title>Hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中提升</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hoisting-in-javascript-d469541fda3c?source=collection_archive---------14-----------------------#2022-11-21">https://javascript.plainenglish.io/hoisting-in-javascript-d469541fda3c?source=collection_archive---------14-----------------------#2022-11-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/12a63f4e862243f60da7c3ba2f7716ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjUFSAd3le7OY25tdZcbaQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The above image is created by Divyojyoti Ghosh(me) on <a class="ae jz" href="http://www.canva.com/" rel="noopener ugc nofollow" target="_blank">www.canva.com</a> using different elements available for making designs.</figcaption></figure><p id="acf8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript中的提升是一种机制，允许甚至在执行变量声明之前访问一些变量。</p><p id="a369" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们借助一个例子来理解——</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Code Snippet 1</figcaption></figure><p id="9c06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于上面的代码片段，与其他编程语言一样，JavaScript也将为console.log语句输出a和b的值。</p><p id="a38f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们将<code class="fe le lf lg lh b">console.log(a)</code>语句移到声明变量a之前的代码顶部，让我们看看会发生什么。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Code Snippet 2</figcaption></figure><p id="b22e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与任何其他编程语言不同，第一条语句(即在声明前访问变量a)不会产生任何错误，但它会打印出<code class="fe le lf lg lh b">undefined</code>。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi li"><img src="../Images/4d6d38a7c2a877d466cb5d8306583814.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*INnFOZHrMT3FT5czysWjrg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">output for the Code Snippet 2</figcaption></figure><p id="6238" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">发生这种情况是因为提升的机制，使用var声明的JavaScript变量在执行之前被提升，换句话说，它们被提升到其作用域的顶部，这就是为什么它不会产生任何错误。</p><p id="1669" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript中的提升是由于执行上下文中的可变环境而发生的(在<a class="ae jz" href="https://medium.com/javascript-in-plain-english/execution-context-in-javascript-abe424d000b" rel="noopener">的执行上下文文章</a>中详细讨论)。执行上下文中代码的执行分两个阶段，创建阶段和执行阶段。</p><p id="76a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<strong class="kc io"> var </strong>定义的变量存储在变量环境中，默认值为‘未定义’。在执行阶段，代码的执行是逐行进行的，所以代码为一个在声明前被访问的变量打印<code class="fe le lf lg lh b">undefined</code>。</p><h1 id="e44e" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">功能提升</h1><p id="efd9" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">JavaScript中的命名函数也被提升，这就是为什么它们可以在声明上面的代码中被调用。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Code Snippet 3</figcaption></figure><p id="c178" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码输出27，但是当我们试图在声明之前打印函数而不是调用它时会发生什么？</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Code Snippet 4</figcaption></figure><p id="c630" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于上面的代码片段，代码直接打印了函数定义。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/48e614172134b701ee2b59fe50149797.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*Giu49_RjfNaFQx1ZA8TRCQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Output for Code Snippet 4</figcaption></figure><p id="fb01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在执行上下文的创建阶段，函数作为它们的文字声明保存在变量环境中，所以当函数名被控制台记录时，整个函数被打印出来。函数只有在被调用时才会执行，例如<code class="fe le lf lg lh b">getAge();</code>会开始执行getAge函数。</p><h1 id="4e93" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">时间死区(TDZ)</h1><p id="e112" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">我们可以在变量声明之前访问var变量，但不能访问let和const变量，从技术上来说，所有类型的变量都是提升的，但在let和const的情况下，变量声明上方的变量范围内的区域被认为是临时死区，在那里这些变量不能被访问，如果代码试图从该区域访问，它们会抛出ReferenceError。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Code Snippet 5</figcaption></figure><p id="bc93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，第5行抛出一个ReferenceError，因为currentYear是从它的TDZ访问的。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e1a8900fa570f524a6caaedfbbd09323.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*kl4Ld_gSwUKxc2OfJRp_GQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Output for Code Snippet 5</figcaption></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/5ecf82c744a8e2a8b1914430fc87db51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIRAovXt39nrKl67P-H7WQ.png"/></div></div></figure><h1 id="2918" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">为什么是TDZ？</h1><p id="c705" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">时间死区是随着ES6中的let和const变量的引入而引入的。TDZ使得let和const变量在声明之前不可访问，这使得代码不容易出错。</p><p id="23ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，这也使得常量变量成为真正的常量变量，因为如果没有TDZ，它会把初始值显示为<code class="fe le lf lg lh b">undefined</code>，然后在声明之后赋值。但是对于TDZ，如果从TDZ访问，它只会一直显示一个值或一个错误。</p><h1 id="99e9" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">参考</h1><p id="3448" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated"><a class="ae jz" href="https://www.udemy.com/course/the-complete-javascript-course/" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/the-complete-JavaScript-course/</a></p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mp ld l"/></div></figure><div class="mq mr gp gr ms mt"><a href="https://gist.github.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">发现要点</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">我做这个要点是为了展示一些你可以用discord.py做的事情的例子，也是因为…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">gist.github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh jt mt"/></div></div></a></div><p id="bb8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">更多内容尽在</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ni">说白了. io </em> </strong> </a> <em class="ni">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ni">免费周报</em> </strong> </a> <em class="ni">。关注我们上</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ni">推特</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ni">领英</em></strong></a><strong class="kc io"><em class="ni"/></strong><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ni">YouTube</em></strong></a><strong class="kc io"><em class="ni"/></strong><em class="ni">和</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ni">不和</em> </strong> </a>  <em class="ni">对成长黑客感兴趣？检查出</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ni">电路</em> </strong> </a> <strong class="kc io"> <em class="ni">。</em> </strong></p></div></div>    
</body>
</html>