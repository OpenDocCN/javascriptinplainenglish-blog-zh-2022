<html>
<head>
<title>Iterators and Generators in JavaScript: A Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的迭代器和生成器:完全指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/iterators-and-generators-in-javascript-a-complete-guide-cd91566ae864?source=collection_archive---------7-----------------------#2022-02-17">https://javascript.plainenglish.io/iterators-and-generators-in-javascript-a-complete-guide-cd91566ae864?source=collection_archive---------7-----------------------#2022-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="939d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们将深入探讨JavaScript迭代器和生成器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/81f00de17cd49027d3fe5bb07625c1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wZaixpEo8hzRjhSg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@marc_schulte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marc Schulte</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fe22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着<a class="ae kv" href="https://262.ecma-international.org/6.0/" rel="noopener ugc nofollow" target="_blank"> ES6 </a>的出现，迭代器和生成器被正式添加到JavaScript中。迭代器和生成器内置于核心语言中，提供了一种定制<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">for…of</a></code>循环行为的方式。</p><p id="e31e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">迭代器</strong>让你可以遍历任何符合规范的对象。在第一节中，我们将学习如何利用迭代器使任何对象都是可迭代的。</p><p id="2fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文的第二部分，我们将深入探讨<strong class="ky ir">生成器</strong>:它们是什么，如何使用它们，以及它们什么时候有用。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="5db6" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">什么是迭代器？</h2><p id="c746" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在理解生成器之前，我们必须先掌握JavaScript中的迭代器，因为这两个概念是交织在一起的。阅读完本节后，很明显生成器是编写迭代器的一种更安全的方法。</p><p id="5b0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迭代器，顾名思义，允许你遍历一个对象(数组也是对象)。</p><p id="5565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能以前使用过JavaScript迭代器。例如，每次迭代数组时都会用到迭代器，但是它们也可以用来迭代<code class="fe ls lt lu lv b">Map</code>对象甚至<code class="fe ls lt lu lv b">string</code>。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="c27f" class="md me iq lv b gy nf ng l nh ni">for (let i of 'abc') {<br/>  console.log(i);<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5475bbe1b31a3d1c9e706fbc45683b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*vK5UqXvUdl5C7j9-oJRq2A.png"/></div></figure><p id="904b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">for…of</code>可用于迭代任何实现<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">可迭代协议</a>的对象。</p><p id="272f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果再深入一点，返回迭代器对象的<code class="fe ls lt lu lv b">@@iterator</code>方法可以用来使任何对象可迭代。</p><h2 id="1ab0" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">使任何对象都是可迭代的</h2><p id="b1c2" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">最好看一个构造常规对象iterable的例子来理解这一点。</p><p id="bf3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从一个按城市组织的用户名集合开始，<strong class="ky ir">就像Money Heist :) </strong>:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="dd76" class="md me iq lv b gy nf ng l nh ni">const userNamesGroupedByLocation = {<br/>  <em class="nk">Tokyo</em>: [<br/>    'Aiko',<br/>    'Chizu',<br/>    'Fushigi',<br/>  ],<br/>  'Nairobi': [<br/>    'Santiago',<br/>    'Valentina',<br/>    'Lola',<br/>  ],<br/>  'Moscow': [<br/>    'Sonja',<br/>    'Dunja',<br/>    'Iwan',<br/>    'Tanja',<br/>  ],<br/>};</span></pre><p id="e7f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择这个例子的原因是很难用这种数据结构迭代用户；我们不得不使用许多循环来检索它们。</p><p id="837a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们尝试在此对象的当前状态下对其进行迭代，我们将收到以下错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f1b3427ad160b49908a3d26277d8d68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*B0bgqC_sgxSoe5b_UX8o1w.png"/></div></figure><p id="3e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为它明确指出<code class="fe ls lt lu lv b">userNamesGroupedByLocation</code>是不可迭代的。</p><blockquote class="nm nn no"><p id="0a18" class="kw kx nk ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">我们必须首先添加<code class="fe ls lt lu lv b">@@iterator</code>函数来使这个对象可迭代。<code class="fe ls lt lu lv b">Symbol.iterator</code>让我们接触到这个符号。</p></blockquote><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="4098" class="md me iq lv b gy nf ng l nh ni">userNamesGroupedByLocation[Symbol.iterator] = function() {<br/>  // ...<br/>}</span></pre><p id="d3a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，迭代器函数返回一个迭代器对象。在<code class="fe ls lt lu lv b">next</code>下，object有一个函数，返回一个有两个属性的对象:<code class="fe ls lt lu lv b">done</code>和<code class="fe ls lt lu lv b">value</code>。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="e88c" class="md me iq lv b gy nf ng l nh ni">userNamesGroupedByLocation[Symbol.iterator] = function() {<br/>  return {<br/>    next: () =&gt; {<br/>      return {<br/>        done: true,<br/>        value: 'hi',<br/>      };<br/>    },<br/>  };<br/>}</span></pre><p id="f3cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迭代的当前值存储在<code class="fe ls lt lu lv b">value</code>中，<code class="fe ls lt lu lv b">done</code>是一个布尔值，表示执行是否完成。</p><blockquote class="nm nn no"><p id="fd01" class="kw kx nk ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">开发这个函数的时候，一定要非常注意<code class="fe ls lt lu lv b">done</code>的值，好像总是<code class="fe ls lt lu lv b">false</code>，就会出现无限循环。</p></blockquote><p id="4213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码示例已经展示了如何正确实现iterable协议。我们可以通过调用迭代器对象的<code class="fe ls lt lu lv b">next</code>函数来测试它。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="68da" class="md me iq lv b gy nf ng l nh ni">// Calling the iterator function returns the iterator object<br/>const iterator = userNamesGroupedByLocation[Symbol.iterator]();<br/>console.log(iterator.next().value);<br/>// "hi"</span></pre><blockquote class="nm nn no"><p id="8142" class="kw kx nk ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">在底层，使用<code class="fe ls lt lu lv b">for…of</code>迭代一个对象使用了<code class="fe ls lt lu lv b">next</code>函数。</p></blockquote><p id="52ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们立即将<code class="fe ls lt lu lv b">done</code>设置为<code class="fe ls lt lu lv b">false</code>，在这种情况下使用<code class="fe ls lt lu lv b">for…of</code>将不会产生任何结果。通过这样做，我们也不会获得任何用户名，这就是为什么我们首先要使这个对象可迭代。</p><h2 id="f4c7" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">实现迭代器函数</h2><p id="5a04" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">首先，我们必须能够访问表示城市的对象的键。这可以通过对<code class="fe ls lt lu lv b">this</code>关键字执行<code class="fe ls lt lu lv b">Object.keys</code>来获得，该关键字对应于函数的父对象，在本例中是<code class="fe ls lt lu lv b">userNamesGroupedByLocation</code>对象。</p><p id="16bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们用关键字<code class="fe ls lt lu lv b">function</code>定义了iterable函数，我们只能通过<code class="fe ls lt lu lv b">this</code>访问这些键。如果我们使用一个箭头函数，这将不起作用，因为它们继承了它们的父类的作用域。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="cf77" class="md me iq lv b gy nf ng l nh ni">const cityKeys = Object.keys(this);</span></pre><p id="e5d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要两个变量来跟踪我们的迭代:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="fd5b" class="md me iq lv b gy nf ng l nh ni">let cityIndex = 0;<br/>let userIndex = 0;</span></pre><blockquote class="nm nn no"><p id="7f72" class="kw kx nk ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">这些变量在迭代器函数中的<code class="fe ls lt lu lv b">next</code>函数之外定义，允许我们在迭代中保存数据。</p></blockquote><p id="7a1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用我们之前设置的索引，我们必须首先在<code class="fe ls lt lu lv b">next</code>函数中收集当前城市和当前用户的用户数组。</p><p id="29e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以使用这些信息来调整返回值。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="f834" class="md me iq lv b gy nf ng l nh ni">return {<br/>  next: () =&gt; {<br/>    const users = this[cityKeys[cityIndex]];<br/>    const user = users[userIndex];<br/><br/>    return {<br/>      done: false,<br/>      value: user,        <br/>    };<br/>  },<br/>};</span></pre><p id="d87c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，索引必须随着每次迭代而递增，除非我们到达了特定城市的最后一个用户，在这种情况下，我们将<code class="fe ls lt lu lv b">userIndex</code>设置为<code class="fe ls lt lu lv b">0</code>，并递增城市索引。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="097e" class="md me iq lv b gy nf ng l nh ni">return {<br/>  next: () =&gt; {<br/>    const users = this[cityKeys[cityIndex]];<br/>    const user = users[userIndex];<br/><br/>    const isLastUser = userIndex &gt;= users.length - 1;<br/>    if (isLastUser) {<br/>      // Reset user index<br/>      userIndex = 0;<br/>      // Jump to next city<br/>      cityIndex++<br/>    } else {<br/>      userIndex++;<br/>    }<br/><br/>    return {<br/>      done: false,<br/>      value: user,        <br/>    };<br/>  },<br/>};</span></pre><p id="948b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确保不要使用<code class="fe ls lt lu lv b">for…of</code>来迭代这个对象。这将导致无限循环，因为<code class="fe ls lt lu lv b">done</code>总是等于<code class="fe ls lt lu lv b">false</code>。</p><p id="c263" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是包含一个将<code class="fe ls lt lu lv b">done</code>设置为<code class="fe ls lt lu lv b">true</code>的退出条件。当我们遍历完所有的城市后，我们将离开这个循环。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="151a" class="md me iq lv b gy nf ng l nh ni">if (cityIndex &gt; cityKeys.length - 1) {<br/>  return {<br/>    value: undefined,<br/>    done: true,<br/>  };<br/>}</span></pre><p id="cc70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们把所有的东西放在一起之后，我们的函数看起来会像这样:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="7599" class="md me iq lv b gy nf ng l nh ni">userNamesGroupedByLocation[Symbol.iterator] = function() {<br/>  const cityKeys = Object.keys(this);<br/>  let cityIndex = 0;<br/>  let userIndex = 0;<br/><br/>  return {<br/>    next: () =&gt; {<br/>      // We already iterated over all cities<br/>      if (cityIndex &gt; cityKeys.length - 1) {<br/>        return {<br/>          value: undefined,<br/>          done: true,<br/>        };<br/>      }<br/><br/>      const users = this[cityKeys[cityIndex]];<br/>      const user = users[userIndex];<br/><br/>      const isLastUser = userIndex &gt;= users.length - 1;<br/><br/>      userIndex++;<br/>      if (isLastUser) {<br/>        // Reset user index<br/>        userIndex = 0;<br/>        // Jump to next city<br/>        cityIndex++<br/>      }<br/><br/>      return {<br/>        done: false,<br/>        value: user,        <br/>      };<br/>    },<br/>  };<br/>};</span></pre><p id="3f9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，使用一个<code class="fe ls lt lu lv b">for…of</code>循环，我们可以有效地从我们的对象中提取所有的名字。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="fe84" class="md me iq lv b gy nf ng l nh ni">for (let name of userNamesGroupedByLocation) {<br/>  console.log('name', name);<br/>}</span></pre><p id="5417" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行这个<code class="fe ls lt lu lv b">for</code>循环后，我们将得到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/678bd48937f80f69bd206fc9ea4827b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*r-vqv_LuLxmwHDKukc-vjA.png"/></div></figure><p id="8cb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，构造一个对象iterable并不神奇。然而，必须小心，因为<code class="fe ls lt lu lv b">next</code>函数中的错误很容易导致无限循环。</p><p id="37e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想了解更多关于该行为的信息，我建议您尝试构建一个自己的iterable对象。</p><p id="8bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了总结我们为实现可迭代所做的工作，我们采取了以下步骤:</p><ul class=""><li id="ddd9" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><code class="fe ls lt lu lv b">@@iterator</code>键(通过<code class="fe ls lt lu lv b">Symbol.iterator</code>可用)可用于向对象添加迭代器函数。</li><li id="efa7" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">这个函数返回一个带有<code class="fe ls lt lu lv b">next</code>函数的对象。</li><li id="f6f8" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><code class="fe ls lt lu lv b">next</code>函数返回一个包含<code class="fe ls lt lu lv b">done</code>和<code class="fe ls lt lu lv b">value</code>属性的对象。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="56a0" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">什么是发电机？</h2><p id="7ffc" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们已经学习了如何迭代任何对象，但是这和生成器有什么关系呢？</p><p id="bc78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然迭代器是一个有用的工具，但它们并不像我们在这个例子中那样经常被使用。当编程迭代器时，我们必须非常小心，因为缺陷可能有重大影响，并且管理内部逻辑可能很困难。</p><p id="0c56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成器是一个有用的特性，它允许我们定义一个函数并利用它来构建迭代器。</p><p id="3419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法不容易出错，并且允许我们更快地生成迭代器。</p><p id="9d01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成器和迭代器最重要的特性之一是，它们允许您根据需要暂停和恢复执行。在这一部分中，我们将看一些如何使用这个特性的例子。</p><h2 id="59bb" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">声明生成器函数</h2><p id="6bb9" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">创建生成器函数的过程与创建普通函数的过程非常相似。我们现在要做的就是在名字前加一个星号<code class="fe ls lt lu lv b">*</code>。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="0e13" class="md me iq lv b gy nf ng l nh ni">function *generator() {<br/>  // ...<br/>}</span></pre><p id="edd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们希望构建一个匿名的生成器函数，这个星号将被移到关键字<code class="fe ls lt lu lv b">function</code>的末尾。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="6be7" class="md me iq lv b gy nf ng l nh ni">function* () {<br/>  // ...<br/>}</span></pre><h2 id="6eac" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">使用<code class="fe ls lt lu lv b">yield</code>关键字</h2><p id="fbea" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">声明一个生成器函数只是工作的一半，并不是真的有用。</p><p id="0c8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，生成器使得生成可迭代对象变得更加容易。然而，迭代器如何知道要迭代函数的哪一部分呢？有必要迭代每一行吗？</p><p id="546c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下使用<code class="fe ls lt lu lv b">yield</code>关键字。您可能认为它是JavaScript Promises中关键字<code class="fe ls lt lu lv b">await</code>的特定于生成器的版本。</p><p id="f4ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个关键字可以添加到我们希望迭代结束的每一行。然后，<code class="fe ls lt lu lv b">next</code>函数将返回该行语句的结果，作为迭代器对象<code class="fe ls lt lu lv b">{ done: false, value: 'something' }</code>的一部分。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="1a24" class="md me iq lv b gy nf ng l nh ni">function* stringGenerator() {<br/>  yield 'hi';<br/>  yield 'hi';<br/>  yield 'hi';<br/>}<br/><br/>const strings = stringGenerator();<br/><br/>console.log(strings.next());<br/>console.log(strings.next());<br/>console.log(strings.next());<br/>console.log(strings.next());</span></pre><p id="28ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行此代码后，您将看到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b26ec1223113f88a956c02c56e618cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*BHVALuSiTqa1MPUwmlyaAA.png"/></div></figure><p id="5ae7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">StringGenerator</code>不会自行执行任何操作，因为它会在第一条yield语句处停止执行。</p><blockquote class="nm nn no"><p id="8bf5" class="kw kx nk ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">当功能结束时，<code class="fe ls lt lu lv b">value</code>等于<code class="fe ls lt lu lv b">undefined</code>，自动将<code class="fe ls lt lu lv b">done</code>设置为<code class="fe ls lt lu lv b">true</code>。</p></blockquote><h2 id="005f" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">使用产量*</h2><p id="43f0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如果我们给<code class="fe ls lt lu lv b">yield</code>关键字添加一个星号，我们就把执行传递给另一个迭代器对象。</p><p id="67e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用它来委托给另一个函数或数组，例如:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="c0eb" class="md me iq lv b gy nf ng l nh ni">function* nameGenerator() {<br/>  yield 'Iwan';<br/>  yield 'Aiko';<br/>}<br/><br/>function* stringGenerator() {<br/>  yield* nameGenerator();<br/>  yield* ['one', 'two'];<br/>  yield 'hi';<br/>  yield 'hi';<br/>  yield 'hi';<br/>}<br/><br/>const strings = stringGenerator();<br/><br/>for (let value of strings) {<br/>  console.log(value);<br/>}</span></pre><p id="8846" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是代码的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/fb9a7a8f9630b0b52b0356bbf5526399.png" data-original-src="https://miro.medium.com/v2/resize:fit:258/format:webp/1*LHfmakQrS00jNsHLCmtakA.png"/></div></figure><h2 id="ca11" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">将值传递给生成器</h2><p id="bb18" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">迭代器用于生成器的<code class="fe ls lt lu lv b">next</code>方法有一个额外的特性:它允许您覆盖返回值。</p><p id="80ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用前面的例子，我们可以覆盖<code class="fe ls lt lu lv b">yield</code>返回的值。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="5641" class="md me iq lv b gy nf ng l nh ni">function* overrideValue() {<br/>  const result = yield 'hi';<br/>  console.log(result);<br/>}<br/><br/>const overrideIterator = overrideValue();<br/>overrideIterator.next();<br/>overrideIterator.next('bye');</span></pre><blockquote class="nm nn no"><p id="c49b" class="kw kx nk ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">在提供一个值来启动发生器之前，我们必须首先调用<code class="fe ls lt lu lv b">next</code>。</p></blockquote><h2 id="deaf" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">生成器方法</h2><p id="2719" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">除了任何迭代器都需要的<code class="fe ls lt lu lv b">next</code>方法之外，生成器还提供了一个<code class="fe ls lt lu lv b">return</code>和<code class="fe ls lt lu lv b">throw</code>函数。</p><h2 id="0cdd" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">1.返回函数</h2><p id="d9b1" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">当在迭代器上调用<code class="fe ls lt lu lv b">return</code>而不是<code class="fe ls lt lu lv b">next</code>时，循环将在下一次迭代时结束。</p><p id="6f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe ls lt lu lv b">return</code>后，之后的每次迭代都会将<code class="fe ls lt lu lv b">done</code>设置为<code class="fe ls lt lu lv b">true</code>并将<code class="fe ls lt lu lv b">value</code>设置为<code class="fe ls lt lu lv b">undefined</code>。</p><p id="6a8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们给这个函数提供一个值，迭代器对象上的<code class="fe ls lt lu lv b">value</code>属性将被替换。</p><p id="ef6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个来自<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return" rel="noopener ugc nofollow" target="_blank"> Web MDN文档</a>的例子很好地说明了这一点:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="4351" class="md me iq lv b gy nf ng l nh ni">function* gen() {<br/>  yield 1;<br/>  yield 2;<br/>  yield 3;<br/>}<br/><br/>const g = gen();<br/><br/>g.next(); // { value: 1, done: false }<br/>g.return('foo'); // { value: "foo", done: true }<br/>g.next(); // { value: undefined, done: true }</span></pre><h2 id="d0a5" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">2.投掷功能</h2><p id="29c0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">生成器额外提供了一个<code class="fe ls lt lu lv b">throw</code>函数，该函数不是继续循环，而是抛出一个错误并结束执行:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="4b4b" class="md me iq lv b gy nf ng l nh ni">function* errorGenerator() {<br/>  try {<br/>    yield 'one';<br/>    yield 'two';<br/>  } catch(e) {<br/>    console.error(e);<br/>  }<br/>}<br/><br/>const errorIterator = errorGenerator();<br/><br/>console.log(errorIterator.next()); <br/>console.log(errorIterator.throw('Bam!'));</span></pre><p id="7230" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码产生以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e8c5838ba58a6021c39d5ee4a401e69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*fb6NDSnl-nBsSTxToMjrZg.png"/></div></figure><p id="4efe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在一个错误后继续迭代，结果值将是未定义的，并且<code class="fe ls lt lu lv b">done</code>将被设置为<code class="fe ls lt lu lv b">true</code>。</p><h2 id="afda" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">为什么要用发电机？</h2><p id="2998" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们可以利用生成器来生成可迭代的对象，正如我们在本文中所展示的。这个主题可能看起来有点抽象，我必须承认我自己很少使用生成器。</p><p id="f2ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，该功能在特定情况下非常有用。这些场景通常利用了生成器可以暂停和恢复的事实。</p><h2 id="701b" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">唯一ID生成器</h2><p id="33f6" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">这可能是生成器最适合的最佳用例之一。</p><p id="6b0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在创建唯一和增量id时，您必须跟踪已经生成的id。您可以使用生成器来创建一个无限循环，每次迭代都会生成一个新的ID。</p><p id="413e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当您需要一个新的ID时，您都可以调用下一个函数，生成器会处理剩下的事情:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="c6cb" class="md me iq lv b gy nf ng l nh ni">function* idGenerator() {<br/>  let i = 0;<br/>  while (true) {<br/>    yield i++;<br/>  }<br/>}<br/><br/>const ids = idGenerator();<br/><br/>console.log(ids.next().value); // 0<br/>console.log(ids.next().value); // 1<br/>console.log(ids.next().value); // 2<br/>console.log(ids.next().value); // 3<br/>console.log(ids.next().value); // 4</span></pre><h2 id="78eb" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">发电机的其他用例</h2><p id="cc94" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">还有许多其他的应用。正如我在这篇<a class="ae kv" href="https://evan-brass.medium.com/finite-state-machines-and-js-c9b55fc3f8f9" rel="noopener">文章</a>中了解到的，发电机可以被有限状态机使用。</p><p id="00fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包括<a class="ae kv" href="https://mobx-state-tree.js.org/intro/welcome" rel="noopener ugc nofollow" target="_blank"> Mobx-State-Tree </a>和<a class="ae kv" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>在内的几个库都使用了生成器。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="f89c" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">结论</h2><p id="338b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">虽然我们可能不需要每天都使用生成器和迭代器，但是当出现需要它们的特殊特性的情况时，知道如何使用它们是非常有益的。</p><p id="6a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们学习了迭代器以及如何使任何对象可迭代。在第二部分中，我们学习了什么是发电机，如何使用发电机，以及何时可以使用发电机。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="72a0" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">资源</h2><ul class=""><li id="7c96" class="nt nu iq ky b kz mw lc mx lf ok lj ol ln om lr ny nz oa ob bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank"> JavaScript迭代器和生成器</a> — Web MDN文档</li><li id="fa78" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><a class="ae kv" href="https://dev.to/rfornal/use-cases-for-javascript-generators-1npc" rel="noopener ugc nofollow" target="_blank">JavaScript生成器的用例</a> —开发到</li><li id="cdc1" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><a class="ae kv" href="https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e" rel="noopener" target="_blank">JavaScript中ES6迭代器的简单指南及示例</a> — CodeBurst.io</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="429b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是这篇文章的内容。我希望你今天学到了一些新东西。你可以在<a class="ae kv" href="https://gouravkajal.medium.com/membership" rel="noopener">媒体</a>上<a class="ae kv" href="https://gouravkajal.medium.com" rel="noopener">关注我</a>或者在LinkedIn上与我联系。想看更多这样的文章，敬请期待！</p><p id="bad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><p id="7beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nk">更多内容看</em> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nk">说白了就是</em> </strong> </a> <em class="nk">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nk">免费周报</em> </strong> </a> <em class="nk">。在我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nk">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="nk">。</em></p></div></div>    
</body>
</html>