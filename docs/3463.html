<html>
<head>
<title>How to Build a GraphQL + MongoDB Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个GraphQL + MongoDB系列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fieldresolver-and-data-loader-made-easy-with-nestjs-part-5-of-how-to-build-a-graphql-mongodb-e0d3d6f7eeec?source=collection_archive---------10-----------------------#2022-08-30">https://javascript.plainenglish.io/fieldresolver-and-data-loader-made-easy-with-nestjs-part-5-of-how-to-build-a-graphql-mongodb-e0d3d6f7eeec?source=collection_archive---------10-----------------------#2022-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f802" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第5部分:使用NestJS简化FieldResolver和数据加载器</h2></div><p id="5e5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您已经有了用NestJS构建的带认证的GraphQL API是时候讨论数据加载器和批处理了！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/83aa39e8df2668795accfc9f7a4829ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ybqqoBFDvp2RzLH5HlBrQ.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by ThisIsEngineering: <a class="ae lr" href="https://www.pexels.com/photo/female-software-engineer-coding-on-computer-3861972/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/female-software-engineer-coding-on-computer-3861972/</a></figcaption></figure><p id="211c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎回到我的带有NestJS系列的GraphQL！如果你是第一次来这里，请务必阅读我以前的文章:</p><ul class=""><li id="cf6f" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/graphql-nodejs-mongodb-made-easy-with-nestjs-and-mongoose-29f9c0ea7e1d">https://JavaScript . plain English . io/graph QL-nodejs-MongoDB-made-easy-with-nestjs-and-mongose-29 F9 c 0 ea 7 E1 d</a></li><li id="7f9a" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lr" href="https://makinhs.medium.com/unit-testing-made-easy-with-nestjs-part-02-for-graphql-mongodb-backend-article-series-b37f147e2a9e" rel="noopener">https://makin hs . medium . com/unit-testing-made-easy-with-nestjs-part-02-for-graph QL-MongoDB-back end-article-series-b37f 147 e2a 9 e</a></li><li id="ccea" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lr" href="https://makinhs.medium.com/e2e-testing-made-easy-with-nestjs-part-3-of-graphql-nodejs-mongodb-series-ba913bad7cf2" rel="noopener">https://makin hs . medium . com/e2e-testing-made-easy-with-nestjs-part-3-of-graph QL-nodejs-MongoDB-series-ba 913 bad 7 cf 2</a></li><li id="a051" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lr" href="https://makinhs.medium.com/authentication-made-easy-with-nestjs-part-4-of-how-to-build-a-graphql-mongodb-d6057eae3fdf" rel="noopener">https://makin hs . medium . com/authentic ation-made-easy-with-nestjs-part-4-of-how-to-build-a-graph QL-MongoDB-d 6057 EAE 3 fdf</a></li></ul><p id="697d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很高兴阅读了以前的文章来跟进这篇文章。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="1372" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将讨论一些更高级的GraphQL主题，尽管它被认为是某种开发人员(即数据加载者)的基础</p><p id="9139" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这里的目标不是判断这个题目有多难，而是展示如何在NestJS中使用它。</p><h2 id="c53f" class="mo mp iq bd mq mr ms dn mt mu mv dp mw ko mx my mz ks na nb nc kw nd ne nf ng bi translated">GraphQL和解析器快速回顾</h2><p id="30fb" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">请记住，当我们使用GraphQL时，我们可以选择我们想要解析的字段，并且我们还可以有一种方法来解析一个只有在查询中被选择的字段，以防止不必要的数据库查询。</p><p id="07f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们以前的文章中，我们设法创建了一个简单的用户实体，它没有其他需要解析的字段:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="5f0b" class="mo mp iq nn b gy nr ns l nt nu">@Schema()<br/>@ObjectType()<br/>export class User {<br/>  @Field(() =&gt; String)<br/>  _id: <strong class="nn ir"><em class="mn">MongooseSchema</em></strong>.Types.ObjectId | string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'User firstName ' })<br/>  firstName: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'User lastName ' })<br/>  lastName: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'User email ' })<br/>  email: string;<br/>  @Prop()<br/>  password: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'User role' })<br/>  role: string;<br/>}</span></pre><p id="107c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想把我们的用户链接到一个更详细的地址，可能不止一个地址，会发生什么？</p><p id="5f3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这一点，我们需要对代码进行一些修改。</p><p id="ef06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始在users/entities文件夹中创建一个地址实体，并创建一个名为<code class="fe nv nw nx nn b">address.entity.ts</code>的文件。</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="dfc8" class="mo mp iq nn b gy nr ns l nt nu">import { ObjectType, Field } from '@nestjs/graphql';<br/>import { Schema as MongooseSchema } from 'mongoose';<br/>import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';<br/><br/>@Schema()<br/>@ObjectType('address')<br/>export class Address {<br/>  @Field(() =&gt; String)<br/>  _id: <strong class="nn ir"><em class="mn">MongooseSchema</em></strong>.Types.ObjectId | string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'Street' })<br/>  street: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'City' })<br/>  city: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'State address ' })<br/>  state: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'ZIP address ' })<br/>  zip: string;<br/>}<br/><br/>export const <strong class="nn ir"><em class="mn">AddressSchema </em></strong>= SchemaFactory.<em class="mn">createForClass</em>(Address);</span></pre><p id="dffc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，更新我们的user.entity.ts:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="aef7" class="mo mp iq nn b gy nr ns l nt nu">import { ObjectType, Field } from '@nestjs/graphql';<br/>import { Schema as MongooseSchema } from 'mongoose';<br/>import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';<br/>import * as mongoose from 'mongoose';<br/>import { Address } from './address.entity';<br/><br/>@Schema()<br/>@ObjectType('user')<br/>export class User {<br/>  @Field(() =&gt; String)<br/>  _id: <strong class="nn ir"><em class="mn">MongooseSchema</em></strong>.Types.ObjectId | string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'User firstName ' })<br/>  firstName: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'User lastName ' })<br/>  lastName: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'User email ' })<br/>  email: string;<br/>  @Prop()<br/>  password: string;<br/>  @Prop()<br/>  @Field(() =&gt; String, { description: 'User role' })<br/>  role: string;<br/>  @Prop({ type: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Address' }] })<br/>  @Field(() =&gt; [Address], { description: 'User addresses' })<br/>  addresses: Array&lt;Address&gt;;<br/>}<br/><br/>export const <strong class="nn ir"><em class="mn">UserSchema </em></strong>= SchemaFactory.<em class="mn">createForClass</em>(User);</span></pre><p id="33e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们需要在users.module.ts中注册它:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="ab60" class="mo mp iq nn b gy nr ns l nt nu">import { Module } from '@nestjs/common';<br/>import { UsersService } from './users.service';<br/>import { UsersResolver } from './users.resolver';<br/>import { MongooseModule } from '@nestjs/mongoose';<br/>import { User, <strong class="nn ir"><em class="mn">UserSchema </em></strong>} from './entities/user.entity';<br/>import { Address, <strong class="nn ir"><em class="mn">AddressSchema </em></strong>} from './entities/address.entity';<br/>import { CommonModule } from '../common/common.module';<br/>import { UsersAddressesResolver } from './users-addresses.resolver';<br/><br/>@Module({<br/>  imports: [<br/>    CommonModule,<br/>    MongooseModule.<em class="mn">forFeature</em>([<br/>      {<br/>        name: User.name,<br/>        schema: <strong class="nn ir"><em class="mn">UserSchema</em></strong>,<br/>      },<br/>      {<br/>        name: Address.name,<br/>        schema: <strong class="nn ir"><em class="mn">AddressSchema</em></strong>,<br/>      },<br/>    ]),<br/>  ],<br/>  providers: [UsersResolver, UsersService, UsersAddressesResolver],<br/>  exports: [UsersService],<br/>})<br/>export class UsersModule {}</span></pre><p id="373f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，更新create-user-input.ts(出于本文的考虑，在其中添加了地址):</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="8a1e" class="mo mp iq nn b gy nr ns l nt nu">import { InputType, Field } from '@nestjs/graphql';<br/><br/>@InputType()<br/>export class Address {<br/>  @Field(() =&gt; String)<br/>  street: string;<br/>  @Field(() =&gt; String)<br/>  city: string;<br/>  @Field(() =&gt; String)<br/>  state: string;<br/>  @Field(() =&gt; String)<br/>  zip: string;<br/>}<br/><br/>@InputType()<br/>export class CreateUserInput {<br/>  @Field(() =&gt; String, { description: 'first name of the user' })<br/>  firstName: string;<br/>  @Field(() =&gt; String, { description: 'last name of the user' })<br/>  lastName: string;<br/>  @Field(() =&gt; String, { description: 'email of the user' })<br/>  email: string;<br/>  @Field(() =&gt; String, { description: 'role of the user' })<br/>  role: string;<br/>  @Field(() =&gt; String, { description: 'password of the user' })<br/>  password: string;<br/>  @Field(() =&gt; [Address])<br/>  addresses: Array&lt;Address&gt;;<br/>}</span></pre><p id="40c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们快速重构构造函数中的users.service.ts:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="1d0b" class="mo mp iq nn b gy nr ns l nt nu">constructor(<br/>  @InjectModel(User.name)<br/>  private readonly userModel: <strong class="nn ir"><em class="mn">Model</em></strong>&lt;User&gt;,<br/>  @InjectModel(Address.name)<br/>  private readonly addressModel: <strong class="nn ir"><em class="mn">Model</em></strong>&lt;Address&gt;,<br/>  private readonly authService: AuthService,<br/>) {}</span></pre><p id="4b20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe nv nw nx nn b">create</code>功能:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="8312" class="mo mp iq nn b gy nr ns l nt nu">async create(createUserInput: CreateUserInput) {<br/>  const saltOrRounds = 10;<br/>  const password = createUserInput.password;<br/>  createUserInput.password = await bcrypt.hash(password, saltOrRounds);<br/>  let addresses = [];<br/>  createUserInput.addresses.forEach((address) =&gt; {<br/>    addresses.push((new this.addressModel(address).save()));<br/>  });<br/>  addresses = await <strong class="nn ir"><em class="mn">Promise</em></strong>.all(addresses);<br/>  const user = new this.userModel({ ...createUserInput, addresses });<br/>  return user.save();<br/>}</span></pre><p id="daea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使做了这些改变，我们仍然会有一个错误…因为我们仍然需要为地址添加<code class="fe nv nw nx nn b">ResolveField</code>。为了方便起见，让我们创建一个特定的解析器:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="1223" class="mo mp iq nn b gy nr ns l nt nu">nest g resolver users/users-addresses --flat</span></pre><p id="8a0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Mongoose负责处理地址的用户关系。我们应该已经有了地址id，所以我们的解析器应该简单如下:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="cbbe" class="mo mp iq nn b gy nr ns l nt nu">import { Parent, ResolveField, Resolver } from '@nestjs/graphql';<br/>import { InjectModel } from '@nestjs/mongoose';<br/>import { Address } from './entities/address.entity';<br/>import { <strong class="nn ir"><em class="mn">Model </em></strong>} from 'mongoose';<br/>import { User } from './entities/user.entity';<br/><br/>@Resolver(() =&gt; User)<br/>export class UsersAddressesResolver {<br/>  constructor(<br/>    @InjectModel(Address.name)<br/>    private readonly addressModel: <strong class="nn ir"><em class="mn">Model</em></strong>&lt;Address&gt;,<br/>  ) {}<br/><br/> @ResolveField('addresses', () =&gt; [Address])<br/> async getUserAddresses(@Parent() user: User) {<br/>   return this.addressModel<br/>    .find({<br/>       _id: { $in: user.addresses },<br/>     })<br/>     .exec();<br/> }<br/>}</span></pre><p id="6010" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该是好的去！</p><p id="0c5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们运行<code class="fe nv nw nx nn b">yarn start</code>并在操场上测试我们的变化:<a class="ae lr" href="http://localhost:3000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/graph QL</a></p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="1cab" class="mo mp iq nn b gy nr ns l nt nu">mutation CreateUser($createUserInput: CreateUserInput!) {<br/>  createUser(createUserInput: $createUserInput) {<br/>    _id<br/>    firstName<br/>    lastName<br/>    email<br/>    addresses{<br/>      street<br/>    }<br/>  }<br/>}</span></pre><p id="3e83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后是变量:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="13f0" class="mo mp iq nn b gy nr ns l nt nu">{<br/>  "createUserInput":{<br/>    "email":"<a class="ae lr" href="mailto:tio.makin+medium4@gmail.com" rel="noopener ugc nofollow" target="_blank">tio.makin+medium4@gmail.com</a>",<br/>    "password":"medium!23",<br/>    "firstName": "marcos",<br/>    "lastName": "silva",<br/>    "role": "admin",<br/>    "addresses": [<br/>      {<br/>      "street": "fake street 1",<br/>      "city": "curitiba",<br/>      "state": "pr",<br/>      "zip": 81630130<br/>      },<br/>      <br/>      {<br/>      "street": "fake street 2",<br/>      "city": "curitiba",<br/>      "state": "pr",<br/>      "zip": 81630130<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="ab7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">登录以获取访问令牌:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="9033" class="mo mp iq nn b gy nr ns l nt nu">mutation LoginUser($loginCredentials:LoginUserInput!){<br/>  loginUser(loginUserInput:$loginCredentials){<br/>  access_token<br/>  }<br/>}</span></pre><p id="57f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变量:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="5ec6" class="mo mp iq nn b gy nr ns l nt nu">{<br/>  "loginCredentials": {<br/>    "email": "<a class="ae lr" href="mailto:tio.makin+medium5@gmail.com" rel="noopener ugc nofollow" target="_blank">tio.makin+medium5@gmail.com</a>",<br/>    "password": "medium!23"<br/>  }<br/>}</span></pre><p id="b2da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取access_token，然后，为了简单起见，获取所有用户:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="686c" class="mo mp iq nn b gy nr ns l nt nu">query ListUsers($args:ConnectionArgs!){<br/>  listUsersWithCursor(args: $args) {<br/>    page {<br/>      edges {<br/>        node {<br/>          _id<br/>          firstName<br/>          lastName<br/>          email<br/>          role<br/>          addresses{<br/>            street<br/>          }<br/>        }<br/>      }<br/>      pageInfo {<br/>        startCursor<br/>        endCursor<br/>        hasPreviousPage<br/>        hasNextPage<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="b52d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">HTTP头变量:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="d9f1" class="mo mp iq nn b gy nr ns l nt nu">{<br/>  "Authorization":"Bearer ADD_HERE_YOUR_ACCESS_TOKEN_WITH_BEARER"<br/>}</span></pre><p id="cdd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的结果应该类似于:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="2350" class="mo mp iq nn b gy nr ns l nt nu">{<br/>  "data": {<br/>    "listUsersWithCursor": {<br/>      "page": {<br/>        "edges": [<br/>          {<br/>            "node": {<br/>              "_id": "630d26de625c1256b8deb6ed",<br/>              "firstName": "marcos",<br/>              "lastName": "silva",<br/>              "email": "<a class="ae lr" href="mailto:tio.makin+medium4@gmail.com" rel="noopener ugc nofollow" target="_blank">tio.makin+medium5@gmail.com</a>",<br/>              "role": "admin",<br/>              "addresses": [<br/>                {<br/>                  "street": "fake street 1"<br/>                },<br/>                {<br/>                  "street": "fake street 2"<br/>                }<br/>              ]<br/>            }<br/>          }<br/>        ],<br/>        "pageInfo": {<br/>          "startCursor": "YXJyYXljb25uZWN0aW9uOjA=",<br/>          "endCursor": "YXJyYXljb25uZWN0aW9uOjA=",<br/>          "hasPreviousPage": false,<br/>          "hasNextPage": false<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="3824" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们终于有了开始这篇文章的一切！问题已经设置好了，您可能很好奇，想通过添加更多用户并调用相同的用户查询列表来测试它，尤其是控制台记录ResolveField…将会发生的是，对于每个用户,“addresses”的@ResolveField将被调用，对于我们编写的内容，我们将为每个找到的用户调用mongose find函数。</p><p id="d24b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，在简历中:</p><ul class=""><li id="e24a" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">数据库中有一个用户，我们有一个地址调用</li><li id="ea7d" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">数据库中有两个用户，我们有两个地址调用</li><li id="712a" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">有3个-&gt; 3个</li><li id="1a58" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">有N -&gt; N</li></ul><p id="df26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，这会导致N+1问题</p><p id="967a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mn">“当数据访问框架执行N条额外的SQL语句来获取在执行主SQL查询时本可以检索到的相同数据时，就会出现N+1查询问题。”(</em> <a class="ae lr" href="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping" rel="noopener ugc nofollow" target="_blank"> <em class="mn">参考</em> </a> <em class="mn"> ) </em></p><p id="c43f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们如何组合FieldResolver以避免不必要的数据库调用呢？使用数据加载器！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="79bf" class="mo mp iq bd mq mr ms dn mt mu mv dp mw ko mx my mz ks na nb nc kw nd ne nf ng bi translated">数据加载器的用途和优点</h2><p id="ac0d" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">带有<a class="ae lr" href="https://www.npmjs.com/package/dataloader" rel="noopener ugc nofollow" target="_blank"> dataloader </a>库的NestJS允许我们一次解析额外的字段，最大限度地减少对数据库的过多查询。简而言之，它允许我们控制何时调用数据库查询(或外部API，或您需要做的任何事情)。</p><p id="45c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们用以下代码添加<a class="ae lr" href="https://www.npmjs.com/package/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>库:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="d60c" class="mo mp iq nn b gy nr ns l nt nu">yarn add dataloader</span></pre><p id="0774" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于NestJS文档，让我们为数据加载器创建一个提供者:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="4993" class="mo mp iq nn b gy nr ns l nt nu">nest g provider users/data-loader/addresses-from-user.loader</span></pre><p id="4e8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该在用户内部创建一个名为<code class="fe nv nw nx nn b">data-loader</code>的文件夹和“addresses-from-user.loader.ts”文件:</p><p id="da97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们必须更改请求范围:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="6018" class="mo mp iq nn b gy nr ns l nt nu">import { Injectable, Scope } from '@nestjs/common';<br/><br/>@Injectable({ scope: Scope.<em class="mn">REQUEST</em>})<br/>export class AddressesFromUserLoader {}</span></pre><p id="26ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在构造函数内部，我们需要设置我们想要使用来自MongoDB的地址模型，并设置要使用的函数:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="2ed3" class="mo mp iq nn b gy nr ns l nt nu">constructor(<br/>  @InjectModel(Address.name)<br/>  private readonly addressModel: <strong class="nn ir"><em class="mn">Model</em></strong>&lt;Address&gt;,<br/>) {<br/>  super((keys) =&gt; this.batchLoad(keys));<br/>}</span></pre><p id="3608" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> batchLoad </strong>是我们正在扩展的数据加载器中已经存在的一个函数。batchLoad还接收我们需要设置的id数组，这些id已经由NestJS排序。</p><p id="4330" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个简单的实现是:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="50ba" class="mo mp iq nn b gy nr ns l nt nu">private async batchLoad(userAddresses: readonly string[]): Promise&lt;ArrayLike&lt;Address&gt;&gt; {<br/>  const addresses = await this.addressModel<br/>    .find({<br/>      _id: { $in: userAddresses },<br/>    })<br/>    .exec();<br/><br/>  const parsedResults = [];<br/>  for (let i = 0; i &lt; userAddresses.length; i++) {<br/>    const addressesId = userAddresses[i];<br/>    parsedResults.push(addresses.find(({ id }) =&gt; id === addressesId));<br/>  }<br/>  return parsedResults;<br/>}</span></pre><p id="f8bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们基本上做的是接收一个地址id数组，只调用一次Mongoose，然后将结果过滤到一个与接收到的订单相匹配的数组中。</p><blockquote class="ny nz oa"><p id="42b2" class="kf kg mn kh b ki kj jr kk kl km ju kn ob kp kq kr oc kt ku kv od kx ky kz la ij bi translated"><strong class="kh ir">免责声明</strong>:这可能不是提取地址并进行过滤的最佳方式。暂时为了继续写这篇文章，我仓促地采用了这个解决方案。</p></blockquote><p id="8b5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经设置了数据加载器，我们需要通过调用数据加载器来重构<strong class="kh ir">users-addresses . resolver . ts</strong>文件中的UsersAddressesResolver。</p><p id="32d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先将构造函数改为:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="28d0" class="mo mp iq nn b gy nr ns l nt nu">constructor(private readonly addressesFromUserLoader: AddressesFromUserLoader) {}</span></pre><p id="542f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后重构我们的getUserAddresses函数:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="f829" class="mo mp iq nn b gy nr ns l nt nu">@ResolveField('addresses', () =&gt; [Address])<br/>async getUserAddresses(@Parent() user: User) {<br/>  return this.addressesFromUserLoader.loadMany(user.addresses.toString().split(','));<br/>}</span></pre><p id="a7ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终文件应该是:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="5499" class="mo mp iq nn b gy nr ns l nt nu">import { Parent, ResolveField, Resolver } from '@nestjs/graphql';<br/>import { Address } from './entities/address.entity';<br/>import { User } from './entities/user.entity';<br/>import { AddressesFromUserLoader } from './data-loader/addresses-from-user.loader';<br/><br/>@Resolver(() =&gt; User)<br/>export class UsersAddressesResolver {<br/>  constructor(private readonly addressesFromUserLoader: AddressesFromUserLoader) {}<br/><br/>  @ResolveField('addresses', () =&gt; [Address])<br/>  async getUserAddresses(@Parent() user: User) {<br/>    return this.addressesFromUserLoader.loadMany(user.addresses.toString().split(','));<br/>  }<br/>}</span></pre><blockquote class="ny nz oa"><p id="8ac3" class="kf kg mn kh b ki kj jr kk kl km ju kn ob kp kq kr oc kt ku kv od kx ky kz la ij bi translated"><strong class="kh ir">免责声明</strong> *:你可以检查我们是否使用了一个名为<strong class="kh ir"> loadMany </strong>的函数，因为在我们的研究案例中，一个用户可以有不止一个地址。如果您只需要使用一个不是数组的字段，请使用<strong class="kh ir"> load </strong>函数。</p></blockquote><p id="0fea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本就是这样！我们准备再次测试。在我的测试场景中，我添加了3个用户，并为每个用户添加了2个地址:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oe"><img src="../Images/5ca2685ca702fb8e67aee5d394a77151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKEXzq9k_NHi_qEyq3VxpQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Users with addresses</figcaption></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi of"><img src="../Images/4192e9435eddea05c8e2bb28a4fbbc04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*non88QItQPZ5trwn8n0G1A.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Address sample from the database</figcaption></figure><p id="b693" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在调用与之前相同的用户列表查询:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="267d" class="mo mp iq nn b gy nr ns l nt nu">query ListUsers($args:ConnectionArgs!){<br/>  listUsersWithCursor(args: $args) {<br/>    page {<br/>      edges {<br/>        node {<br/>          _id<br/>          firstName<br/>          lastName<br/>          email<br/>          role<br/>          addresses{<br/>            _id<br/>            street<br/>            state<br/>            zip<br/>          }<br/>        }<br/>      }<br/>      pageInfo {<br/>        startCursor<br/>        endCursor<br/>        hasPreviousPage<br/>        hasNextPage<br/>      }<br/>    }<br/>  }<br/>}</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi og"><img src="../Images/0260ee5def914a85f70132c284ebc217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6L2cbk0X5Gp5sW1RfP1HA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">query to list users</figcaption></figure><p id="aa61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将会看到一切工作正常，但是如果我们记录我们的<strong class="kh ir"> getUserAddresses </strong>字段解析器和<strong class="kh ir"> batchLoad </strong>函数，我们可以看到以下内容:</p><ul class=""><li id="219b" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">字段解析器不断被找到的用户数量调用。</li></ul><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="c76e" class="mo mp iq nn b gy nr ns l nt nu">Received addresses field to resolve [<br/>  new ObjectId("630dd2f7fc39b866ee88eb2b"),<br/>  new ObjectId("630dd2f7fc39b866ee88eb2c")<br/>]<br/>Received addresses field to resolve [<br/>  new ObjectId("630dd308fc39b866ee88eb31"),<br/>  new ObjectId("630dd308fc39b866ee88eb32")<br/>]<br/>Received addresses field to resolve [<br/>  new ObjectId("630d26de625c1256b8deb6e9"),<br/>  new ObjectId("630d26de625c1256b8deb6ea")<br/>]</span></pre><ul class=""><li id="a8b1" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><strong class="kh ir"> batchLoad </strong>函数只被调用一次，接收所有要查找的id:</li></ul><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="7767" class="mo mp iq nn b gy nr ns l nt nu">received address to find [<br/>  '630dd2f7fc39b866ee88eb2b',<br/>  '630dd2f7fc39b866ee88eb2c',<br/>  '630dd308fc39b866ee88eb31',<br/>  '630dd308fc39b866ee88eb32',<br/>  '630d26de625c1256b8deb6e9',<br/>  '630d26de625c1256b8deb6ea'<br/>]</span></pre><p id="51a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，现在我们不是对我们发现的每个用户调用我们的数据库，而是组合所有的id，只调用我们的数据库一次来查找用户地址！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="0b7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我展示了如何使用<a class="ae lr" href="https://docs.nestjs.com/graphql/resolvers#query-type-names" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> ResolveField </strong> </a>以及如何向其添加<a class="ae lr" href="https://www.npmjs.com/package/dataloader" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> dataloader </strong> </a>。</p><p id="b55f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给出的例子可能很愚蠢，但这里的主要挑战是找到一个简单的例子，并展示如何应用它。</p><p id="f2b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在实际工作中，您可能会发现自己处于类似的情况，但是需要调用外部API来获取所需的字段，例如连接到不同的数据库，或者连接到不同的微服务。在这种情况下，调用次数总是会成为一个严重的问题，数据加载器方法将帮助您解决这个问题</p><p id="0583" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章对您在NestJS中的GraphQL知识有所帮助。这个项目的源代码可以在这个<a class="ae lr" href="https://github.com/makinhs/nestjs-with-graphql/tree/005-data-loader" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。</p><p id="15f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是一些值得继续阅读的有用文章:</p><div class="oh oi gp gr oj ok"><a href="https://makinhs.medium.com/a-beginner-introduction-to-algorithms-and-complexity-with-javascript-typescript-2c8fd2384a1f" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">Javascript/Typescript算法和复杂性入门</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">通过这篇关于算法和复杂性的介绍性文章，让您的Javascript/Typescript技能更上一层楼！</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">makinhs.medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ll ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://makinhs.medium.com/how-to-apply-solid-principles-with-typescript-in-an-easy-way-b91b53bc9853" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">如何以简单的方式应用Typescript的坚实原理</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">在本文中，我们将讨论坚实的原则以及如何在您的Typescript项目中使用它！</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">makinhs.medium.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy ll ok"/></div></div></a></div><p id="461f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，如果这篇文章对你有用，别忘了鼓掌 / <strong class="kh ir">评论</strong>！</p><p id="a945" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一集再见，</p><p id="22c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯</p><blockquote class="ny nz oa"><p id="469f" class="kf kg mn kh b ki kj jr kk kl km ju kn ob kp kq kr oc kt ku kv od kx ky kz la ij bi translated"><em class="iq">如果这类文章过于简单，而你又觉得自己准备了一次真正的冒险，特地在一个遥远的好报酬的基础上，请尝试加入</em> <a class="ae lr" href="https://topt.al/KncQD8" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Toptal </em> </a> <em class="iq">与我的引荐</em> <a class="ae lr" href="https://topt.al/KncQD8" rel="noopener ugc nofollow" target="_blank"> <em class="iq">链接</em></a><em class="iq"/><a class="ae lr" href="https://topt.al/KncQD8" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://topt.al/KncQD8</em></a><em class="iq">。Toptal是一个伟大的自由职业者社区，我很高兴在那里见到你！</em></p></blockquote></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="ff77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mn">更多内容请看</em><a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mn">plain English . io</em></strong></a><em class="mn">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mn">免费每周简讯</em> </strong> </a> <em class="mn">。关注我们</em> <a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mn">推特</em> </strong> </a>，<a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mn">LinkedIn</em></strong></a><em class="mn">，</em><a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mn">YouTube</em></strong></a><em class="mn">，</em> <a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mn">不和</em> </strong> </a> <em class="mn">。</em></p></div></div>    
</body>
</html>