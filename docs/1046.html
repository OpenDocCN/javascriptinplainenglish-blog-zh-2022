<html>
<head>
<title>Algorithm to Calculate “Time On Page” in JavaScript using sendBeacon()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用sendBeacon()在JavaScript中计算“页面时间”的算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-algorithm-to-implement-time-on-page-in-vanilla-javascript-using-sendbeacon-530bc8391ef5?source=collection_archive---------1-----------------------#2022-03-01">https://javascript.plainenglish.io/best-algorithm-to-implement-time-on-page-in-vanilla-javascript-using-sendbeacon-530bc8391ef5?source=collection_archive---------1-----------------------#2022-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a847405b10817582caf24ce096a73681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ea-O8Lom2sww1zVy1JHRXQ.png"/></div></div></figure><p id="673a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">声明:原文章发表于</em> <strong class="jx io"> <em class="kt">我的官方博客</em> </strong> <em class="kt">。查看</em> <a class="ae ku" href="https://nerdsway.herokuapp.com/blog/best-way-to-implement-time-on-page-in-vanilla-javascript-using-sendbeacon-vvwptpu/" rel="noopener ugc nofollow" target="_blank"> <em class="kt">这里</em> </a></p><p id="2d12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理想情况下，“<strong class="jx io">页面上的时间</strong>”是指一个人登陆一个网页和转到另一个网页之间的时间。请记住，如果这个人没有移动到第二页，在该页上的时间不会被计算或添加到平均值中。就好像这个人从来没有来过。但是您不应该将这个指标与会话持续时间混淆。</p><p id="a7e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，我们不会做类似谷歌分析的东西。这有两个原因。第一，我们不偷数据，第二，我们没那么聪明。此外，GA不允许将他们的数据用于开发用途。我们不会跟踪用户，相反，我们将创建一个算法，可以返回用户在该页面上花费的秒数(或分钟数)。</p><blockquote class="kv kw kx"><p id="9bf9" class="jv jw kt jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in">相信我，准确率高达98% </em></p></blockquote><p id="ad22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在做了大量的研究(Google/StackOverflow/Academia)后，我找到了解决这个问题的最佳方法。</p><p id="823c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这种方法有问题吗？当然了。是不是哪里都适用？大概吧。但是它能在小规模的实际应用中实现吗？是啊！</strong></p><p id="80a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个解决方案中使用的语言是JavaScript，因为这是我们知道DOM中发生了什么的唯一方法。还因为一位智者曾经说过<strong class="jx io">“任何可以用JavaScript编写的应用程序，最终都会用JavaScript编写。”——阿特伍德定律(杰夫·阿特伍德)</strong></p><h1 id="02a0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">理论解释</h1><p id="9f37" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">所以这是我们要做的—</p><p id="1680" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用户访问页面的时刻我们标记时间，比如说x，每当用户离开页面，我们标记时间，比如说Y，<br/>所以，花费的时间简单来说就是(Y-Z)秒，或者是？？？</p><p id="3527" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">答案是否定的，不是。因为用户没有必要把每一秒钟都花在阅读或阅读页面上。</p><p id="dd51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，为了抵消这一点，我们将从总持续时间中减去不活动的时间。</p><p id="15fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不活跃的时刻就像用户在滚动，或者已经过了30秒，而用户甚至没有移动光标、滚动或点击。</p><h2 id="4ca7" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">100%精确花费在页面上的时间</h2><p id="a35d" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">下面这段代码显示了帖子在页面上花费的确切时间，没有考虑任何变量。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3256" class="me lc in mv b gy mz na l nb nc">document.addEventListener("DOMContentLoaded", () =&gt; {<br/>    const start = new Date().getTime();</span><span id="4b09" class="me lc in mv b gy nd na l nb nc">    window.addEventListener("beforeunload", () =&gt; {<br/>        const end = new Date().getTime();<br/>        const totalTime = (end - start) / 1000<br/>	<br/>        console.log(totalTime)<br/>    });</span><span id="7fb2" class="me lc in mv b gy nd na l nb nc">});</span></pre><p id="116a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是<strong class="jx io">那不是</strong>，我们想要的，是基于实际使用案例的具体价值。</p><h2 id="1159" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">滚动花费的时间</h2><p id="442d" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">所以这段代码将最终消除滚动页面所花费的时间，因为用户在滚动页面时不会阅读是非常合理的。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="dafb" class="me lc in mv b gy mz na l nb nc">let timeSpentScrolling = 0;</span><span id="241f" class="me lc in mv b gy nd na l nb nc">window.addEventListener('scroll', () =&gt; {<br/>    timeSpentScrolling += 1.8;<br/>});</span></pre><p id="2e4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个<strong class="jx io">值“1.8”</strong>是经过大量的命中&amp;试验努力后发现的😅。请欣赏我的努力，为这篇文章鼓掌。谢了。</p><p id="6263" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:不要忘记更新总时间<code class="fe ne nf ng mv b">const totalTime = ((end - start) / 1000) - (timeSpentScrolling / 1000)</code></p><h2 id="c270" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">处于暂停状态的时间</h2><p id="b16f" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">这是所有案例中最重要的一个。如果用户站起来走开去撒尿怎么办。我们的JavaScript会认为他在忙着使用页面，而用户却在享受撒尿的乐趣。</p><p id="b124" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了避免这些情况，我们将暂时停止时间增量。<br/>我们可以创建一个名为<code class="fe ne nf ng mv b">haltedStartTime</code>、<code class="fe ne nf ng mv b">haltEndTime</code>和<code class="fe ne nf ng mv b">isHalted</code>的新变量。</p><p id="d20a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在做了一个小调查后，发现普通用户每39秒就会在<strong class="jx io">后滚动一次页面。</strong>(保持<strong class="jx io"> 200字/分钟</strong>阅读速度在估算中)</p><p id="726d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果已经过了39秒，而用户还没有滚动页面，这只能说明以下情况之一:</p><ul class=""><li id="fea2" class="nh ni in jx b jy jz kc kd kg nj kk nk ko nl ks nm nn no np bi translated">他/她不在那里</li><li id="8eeb" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">他/她花在理解内容上的时间超过了要求</li><li id="8545" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">他/她很慢</li></ul><p id="fdbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在任何一种情况下，计时器应停止计时。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="646b" class="me lc in mv b gy mz na l nb nc">...</span><span id="87a8" class="me lc in mv b gy nd na l nb nc">let isHalted = false;<br/>let haltedStartTime, haltedEndTime;<br/>let totalHaltedTime = 0;</span><span id="f500" class="me lc in mv b gy nd na l nb nc">const update_halt_state = () =&gt; {<br/>    if (isHalted) {<br/>	isHalted = false;<br/>        haltedEndTime = new Date().getTime()<br/>        totalHaltedTime += (haltedEndTime - haltedStartTime) / 1000<br/>    } else {<br/>        isHalted = true;<br/>        haltedStartTime = new Date().getTime()<br/>    }<br/>}</span><span id="5247" class="me lc in mv b gy nd na l nb nc">window.addEventListener('scroll', () =&gt; {<br/>    ...<br/>    update_halt_state()<br/>});</span><span id="02b6" class="me lc in mv b gy nd na l nb nc">document.addEventListener("DOMContentLoaded", () =&gt; {<br/>    ...<br/>    setInterval(() =&gt; {<br/>	if (new Date().getTime() - start &gt; 39000) {<br/>	    update_halt_state()<br/>	}<br/>    }, 39000)</span><span id="fc83" class="me lc in mv b gy nd na l nb nc">    ...<br/>});</span></pre><p id="a4bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:再次提醒，不要忘记更新总时间<br/> <code class="fe ne nf ng mv b">const totalTime = ((end - start) / 1000) - (timeSpentScrolling / 1000) - totalHaltedTime</code></p><h2 id="362f" class="me lc in bd ld mf mg dn lh mh mi dp ll kg mj mk lp kk ml mm lt ko mn mo lx mp bi translated">使用信标API —将数据发送到后端</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="63e7" class="me lc in mv b gy mz na l nb nc">window.addEventListener("beforeunload", () =&gt; {<br/>    ...<br/>    const totalTime = ((end - start) / 1000) - (timeSpentScrolling / 1000) - totalHaltedTime</span><span id="560d" class="me lc in mv b gy nd na l nb nc">    navigator.sendBeacon("https://topapi2.free.beeceptor.com", {"totalTime":totalTime})<br/>});</span></pre><p id="30ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">经过一堆麻烦之后，我发现了这个内置的JavaScript，它被用来向服务器发送小数据，甚至在页面被终止之后。</p><p id="17da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在有人可能会问，“为什么我们不总是使用<code class="fe ne nf ng mv b">navigator.sendBeacon()</code>而不是<code class="fe ne nf ng mv b">fetch()</code>？”。<br/>答案是数据的大小，我们只能通过<em class="kt">发送<strong class="jx io"> 64KB </strong>的有效载荷。sendBeacon() </em></p><h1 id="ed40" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">实际实现的代码</h1><p id="3688" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">如果您不理解代码部分(这是非常可能的)，这里是完整的代码</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl nx ny hr nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ig ih ii ij ik"><blockquote class="oe"><p id="100a" class="of og in bd oh oi oj ok ol om on ks dk translated">如果你觉得这有帮助，请鼓掌。</p><p id="4738" class="of og in bd oh oi oj ok ol om on ks dk translated">我也很感激有人跟踪我😊。</p><p id="def5" class="of og in bd oh oi oj ok ol om on ks dk translated">请在Instagram和LinkedIn上与我联系，我们将有一次聊天。</p><p id="ffae" class="of og in bd oh oi oj ok ol om on ks dk translated">insta gram/Twitter—@ mrvaibh 0<br/>LinkedIn—@ mrvaibh</p></blockquote><p id="4d39" class="pw-post-body-paragraph jv jw in jx b jy oo ka kb kc op ke kf kg oq ki kj kk or km kn ko os kq kr ks ig bi translated"><em class="kt">更多内容请看</em><a class="ae ku" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">plain English . io</em></strong></a><em class="kt">。报名参加我们的</em> <a class="ae ku" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">免费周报</em> </strong> </a> <em class="kt">。关注我们关于</em><a class="ae ku" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">Twitter</em></strong></a><em class="kt">和</em><a class="ae ku" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">LinkedIn</em></strong></a><em class="kt">。加入我们的</em> <a class="ae ku" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">社区不和谐</em> </strong> </a> <em class="kt">。</em></p></div></div>    
</body>
</html>