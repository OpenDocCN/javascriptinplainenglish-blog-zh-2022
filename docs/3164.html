<html>
<head>
<title>Theming and Theme Switching in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的主题化和主题切换</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/theming-and-theme-switching-in-react-the-right-way-51b679de9c72?source=collection_archive---------6-----------------------#2022-08-05">https://javascript.plainenglish.io/theming-and-theme-switching-in-react-the-right-way-51b679de9c72?source=collection_archive---------6-----------------------#2022-08-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b4bd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用设计令牌、React、上下文API和Bit来构建和切换模块化主题组件</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/9cdb5035a611e119d84c14a4c7bac282.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*OYNLT6U3SsuUGAx-fKNh7Q.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Who said Todos were boring? :-)</figcaption></figure><p id="b540" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">主题化在过去几年里真正起飞了，苹果和谷歌都采用了黑暗模式，Next.js等使得SSR <em class="lk">成为热门商品。主题有助于代码的可维护性和可伸缩性，因为它们是外观变化和组件逻辑之间真正的<a class="ae ll" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>，所以作为一名擅长样式化的前端开发人员从来没有得到更好的回报。</em></p><p id="816b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，这真的有趣吗？</p><p id="aa8a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你有多少次遇到队友链接了几十个CSS <code class="fe lm ln lo lp b">classNames</code>，扼杀了可读性？或者六个月前提交遗留下来的孤儿CSS<em class="lk"/>因为莫名其妙地被共享到其他地方而无法删除？或者发现您不能<em class="lk">实际上</em>重用您刚刚创建的“可重用”组件，因为它是一个3 MB的包？</p><p id="db4f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">够了。如果您可以<a class="ae ll" href="https://en.wikipedia.org/wiki/Hot_swapping" rel="noopener ugc nofollow" target="_blank">热插拔</a> <em class="lk"> </em>主题而不用担心这些，会怎么样？组件是否真正可重用，因为它们<em class="lk">基于Figma导出或消耗的道具动态</em>填充样式值——而不需要<em class="lk"> </em>到处使用<code class="fe lm ln lo lp b">!important</code>来“解决”冲突，拥有巨人Andre大小的包，或者一夜之间掌握PostCSS + Tailwind +模块？</p><h1 id="cf08" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">你的新朋友——上下文API</h1><div class="kd ke kf kg gt ab cb"><figure class="mi kh mj mk ml mm mn paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><img src="../Images/504667fd79355cd3e3c67d01605f31d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*ztAuDGH84ro8T6-M7jkaoA.png"/></div></figure><figure class="mi kh ms mk ml mm mn paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><img src="../Images/8ebf49d4e15140fc047ae9e7141d048d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*MgOCNn4umF_CzWJYMt-Ndw.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk mt di mu mv">Exact same components and logic under the hood, drastically different styles applied dynamically.</figcaption></figure></div><h2 id="a8f5" class="mw lr in bd ls mx my dn lw mz na dp ma kx nb nc mc lb nd ne me lf nf ng mg nh bi translated">全局存储选择的上下文…</h2><p id="e908" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">首先，我们需要一个全局状态变量(可以这么说)来跟踪和切换我们选择的主题——复古或现代。我们将使用<a class="ae ll" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Context API </a>作为解决方案，因为它就是为了做到这一点而构建的——让我们将值深入传递到组件树中，而不强迫组件接收它们不能使用的值。</p><p id="d72e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来呢？</p><p id="ac90" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">“我懂了！”你说。<em class="lk">使用context存储当前主题，然后动态分配预制的CSS类——复古或现代主题——作为组件的内嵌样式，使用简单的三元运算符，对吗？！</em></em></p><p id="b53b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">没有。</p><p id="5aac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们这样做了，我们就完全避免了我们刚刚谈到的任何问题。</p><h2 id="35bd" class="mw lr in bd ls mx my dn lw mz na dp ma kx nb nc mc lb nd ne me lf nf ng mg nh bi translated">…以及动态提供该选择的环境。</h2><p id="9256" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">解决方案是再次使用Context API<em class="lk"/>，但这一次是基于您的设计团队从Figma/Sketch导出的一组<strong class="kq io">值</strong>(记住这一点，我们将回头讨论它)为您动态生成一个主题(然后您可以<code class="fe lm ln lo lp b">import</code>并在需要的地方使用它),并让您以您需要的粒度应用和定制它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nn"><img src="../Images/68bc7bf7c2cc359b46acdf481cc25533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a07OIOu1ZYS2-DEEXY7FwQ.jpeg"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Bit and React is a match made in developer heaven</figcaption></figure><p id="895e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这正是<a class="ae ll" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank"> Bit的</a> <a class="ae ll" href="https://bit.cloud/teambit/base-react/theme/theme-provider" rel="noopener ugc nofollow" target="_blank"> ThemeProvider </a>组件所做的，返回一个<a class="ae ll" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>(一个提供者)——你可以将它导入到任何你需要主题化和包装组件的地方。通过这种方式，您可以访问这些子组件中的样式值，还可以在站点/应用范围内单独覆盖它们。</p><p id="eb2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于那些还没有尝试过Bit的人来说，<a class="ae ll" href="https://bit.cloud/" rel="noopener ugc nofollow" target="_blank"> Bit </a>是一个开源工具链和组件中心，它简化了组件的构建、发现和共享。你会感觉像一个在玩具店浏览组件的孩子，轻松地将它们导入并集成到你的应用中。</p><h1 id="ed34" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">等等…如果我想坚持香草反应呢？</h1><p id="76a9" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">如果你选择<em class="lk">而不是</em>使用Bit的ThemeProvider组件，这篇文章中解释的设计模式还是一样的，但是你会有一些工作要做，手动导入某种CSS-in-JS解决方案中的样式，并一次一个地应用它们，内联。</p><pre class="kd ke kf kg gt no lp np nq aw nr bi"><span id="822e" class="mw lr in lp b gy ns nt l nu nv">// styles (if you weren't using Bit)<br/>const todoButtonStyle = {</span><span id="1587" class="mw lr in lp b gy nw nt l nu nv">margin: modernMode? theme.todoButtonModern.margin : theme.todoButtonRetro.margin,</span><span id="1466" class="mw lr in lp b gy nw nt l nu nv">borderColor: modernMode? theme.todoButtonModern.borderColor : theme.todoButtonRetro.borderColor,</span><span id="0fe5" class="mw lr in lp b gy nw nt l nu nv">borderRadius: modernMode? theme.todoButtonModern.borderRadius : theme.todoButtonRetro.borderRadius,</span><span id="a8ac" class="mw lr in lp b gy nw nt l nu nv">…</span><span id="756f" class="mw lr in lp b gy nw nt l nu nv">}</span></pre><p id="42be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不是火箭科学，但是需要大量的打字工作。此外，使用所有这些内联样式，您的性能会受到影响。</p><p id="ab62" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们开始吧！</p><h1 id="0703" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">步骤0:配置</h1><p id="b90e" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">我们的项目没有任何依赖项，除了我们将从Bit导入的<code class="fe lm ln lo lp b">ThemeProvider</code>。</p><p id="297d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Bit中的组件被存储为<a class="ae ll" href="https://docs.npmjs.com/cli/v7/using-npm/scope" rel="noopener ugc nofollow" target="_blank">范围的注册表</a>。相关的包，发布在每个<code class="fe lm ln lo lp b">npm</code>用户/组织的名称空间下，确保与其他用户/组织创建的组件同名的组件可以无冲突地存在。一点点<a class="ae ll" href="https://bit.dev/docs/scope/scope-overview" rel="noopener ugc nofollow" target="_blank">作用域</a>的功能与<em class="lk">完全相同，基本上就是你的存储库。这样导入更符合逻辑。</em></p><p id="4bc7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，在我们可以从Bit安装组件之前，我们需要将该组件的范围配置为一个<code class="fe lm ln lo lp b">npm</code>注册表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4c29ac535f40dae564d8016e38faaf1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/0*c1ig6efV1_ykzKg4"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Every component published on Bit will list commands for install and scoped registry configuration, ready to copy-and-paste.</figcaption></figure><p id="82ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的例子中，这意味着像这样添加<code class="fe lm ln lo lp b">@teambit</code></p><pre class="kd ke kf kg gt no lp np nq aw nr bi"><span id="7973" class="mw lr in lp b gy ns nt l nu nv">&gt; npm config set ‘@teambit:registry’ <a class="ae ll" href="https://node.bit.cloud" rel="noopener ugc nofollow" target="_blank">https://node.bit.cloud</a></span></pre><p id="9dc7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">…然后安装我们需要的组件。如果前一步出现问题，这一步将会失败，所以一定要仔细检查。</p><pre class="kd ke kf kg gt no lp np nq aw nr bi"><span id="ec3b" class="mw lr in lp b gy ns nt l nu nv">&gt; npm i @teambit/base-react.theme.theme-provider</span></pre><p id="2f2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">注意:</em> </strong> <em class="lk">我们可以选择使用一个Bit工作空间，并将它们导入到自己的环境中。这通常是开发人员使用Bit的方式。对于那些喜欢这条路线的人来说，可以查看一下</em> <a class="ae ll" href="https://bit.cloud/blog/theming-in-components-with-react-and-bit-l386casw" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">这篇关于主题和主题化的文章</em> </strong> </a> <em class="lk">直接来自</em> <a class="ae ll" href="http://bit.cloud/blog" rel="noopener ugc nofollow" target="_blank"> <em class="lk">位博客</em> </a> <em class="lk">。</em></p><p id="4995" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">全部完成！现在，我们可以像往常一样使用ThemeProvider。</p><blockquote class="ny nz oa"><p id="5d35" class="ko kp lk kq b kr ks jo kt ku kv jr kw ob ky kz la oc lc ld le od lg lh li lj ig bi translated"><em class="in">💡</em>如果你想要一个复古/现代主题交换的更好的开关/开关，你也可以在这里得到类似于<a class="ae ll" href="https://bit.cloud/teambit/design/ui/input/toggle" rel="noopener ugc nofollow" target="_blank">开关</a>的东西(也是<code class="fe lm ln lo lp b"><em class="in">teambit</em></code>作用域注册表的一部分)。</p><p id="6607" class="ko kp lk kq b kr ks jo kt ku kv jr kw ob ky kz la oc lc ld le od lg lh li lj ig bi translated"><code class="fe lm ln lo lp b"><em class="in">npm i @teambit/design.ui.input.toggle</em></code></p><p id="55e8" class="ko kp lk kq b kr ks jo kt ku kv jr kw ob ky kz la oc lc ld le od lg lh li lj ig bi translated">现在，您可以将它包含在项目中的任何位置。看看用Bit进行组件驱动开发有多简单？</p></blockquote><h1 id="3375" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">步骤1A:用设计符号构建主题</h1><p id="d1bf" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">还记得ThemeProvider如何根据设计团队的一组值为您构建主题吗？这些值被称为<a class="ae ll" href="https://bit.cloud/blog/design-tokens-in-components-with-react-and-bit-l28qlxq6" rel="noopener ugc nofollow" target="_blank">设计记号</a>，它们是<strong class="kq io">你为达到最终外观</strong>所做的设计决策的集合。颜色、边距、填充、行高&amp;间距、字体系列、过渡、关键帧——任何你能想象到的重复使用的东西，都被整合并存储在这个位于你的应用之上的单一数据层中。</p><p id="739e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着基于设计令牌的方法是与库无关的，可以在任何地方部署，并且可以跨任何需要相同、一致设计的应用进行扩展。它们可能是JSON，YAML，普通的旧JavaScript，任何东西。</p><p id="e84e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，使用这种设计方法学来构建你的两个(或者更多个)主题。作为一个例子，这是我的现代主题的样子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="d61a" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">步骤1B:将令牌传递给你的主题提供者。</h1><p id="b125" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">拿到你的设计令牌了吗？很好。现在，ThemeProvider可以用它们构建一个上下文感知的主题。从技术上讲，这将是一个CSS-in-JS解决方案，但是ThemeProvider为您简化了整个过程。你给它输入你的设计符号——它生成一个主题(用一个定制的钩子— <code class="fe lm ln lo lp b">useTheme</code> —让你可以访问样式变量),你可以根据需要使用它。</p><p id="249a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是你需要担心的全部。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="fc1e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">步骤2:为主题切换建立上下文。</h1><p id="b0a6" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">我们的主题已经准备就绪，现在我们需要一个全局变量来跟踪我们选择的主题的状态——任何组件都可以访问它，而无需进行适当的处理。</p><p id="bb31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是游戏计划。</p><ol class=""><li id="b3bd" class="og oh in kq b kr ks ku kv kx oi lb oj lf ok lj ol om on oo bi translated">从React导入<code class="fe lm ln lo lp b">createContext</code>和<code class="fe lm ln lo lp b">useContext</code>挂钩，并定义您希望全局可用的变量。这是经典的getter/setter <code class="fe lm ln lo lp b">useState </code>模板。没什么特别的。</li></ol><pre class="kd ke kf kg gt no lp np nq aw nr bi"><span id="d8ff" class="mw lr in lp b gy ns nt l nu nv">const [modernMode, setModernMode] = useState(false);<br/>const toggleModernMode = () =&gt; { setModernMode(!modernMode) };</span></pre><p id="a23c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还将定义一个函数来处理这个布尔值的切换，即实际的主题切换。</p><p id="c6c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.用<code class="fe lm ln lo lp b">createContext</code>钩子创建上下文。这将返回一个对象。</p><pre class="kd ke kf kg gt no lp np nq aw nr bi"><span id="72f2" class="mw lr in lp b gy ns nt l nu nv">const ModernModeContext = createContext();</span></pre><p id="9bf5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个上下文对象都带有一个<a class="ae ll" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank">提供者</a>反应组件。您作为该组件的子/后代包含的任何内容都会自动订阅您定义的上下文变量的更改，并且每当变量(通过此处的<code class="fe lm ln lo lp b">value</code>属性提供给它)发生更改时，都会重新呈现。</p><p id="ac29" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的例子中，我们希望这些消费者组件是动态添加的，而不是此时此地定义的，所以我们将它编码为默认的<code class="fe lm ln lo lp b">props.children</code>。</p><pre class="kd ke kf kg gt no lp np nq aw nr bi"><span id="65b4" class="mw lr in lp b gy ns nt l nu nv">/* ‘value’ props = whatever variables must be global */</span><span id="fed3" class="mw lr in lp b gy nw nt l nu nv">return (</span><span id="1514" class="mw lr in lp b gy nw nt l nu nv">&lt;ModernModeContext.Provider value={{ modernMode, toggleModernMode }}&gt;</span><span id="20e8" class="mw lr in lp b gy nw nt l nu nv">{props.children}</span><span id="1656" class="mw lr in lp b gy nw nt l nu nv">&lt;/ModernModeContext.Provider&gt;</span><span id="4211" class="mw lr in lp b gy nw nt l nu nv">);</span></pre><p id="d13e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3.为了保持可重用性和最小化渲染，只创建一个返回该提供者的<a class="ae ll" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a> (HOC)。</p><p id="3841" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将所有这些放在一起，这是应用程序整体上下文的代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="8dd1" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">步骤3:构建您的组件</h1><p id="56bd" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">你的App.js将只需要你的主组件(这里称之为<code class="fe lm ln lo lp b">Content</code>)包装在你的上下文提供者中(如果你记得的话，这是特设的)。</p><p id="1537" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是我们解决方案的前半部分——使当前活动的主题(全局变量+它的切换函数)可以被我们拥有的每个组件访问和跟踪。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7fde" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">至于主组件本身，从它返回<code class="fe lm ln lo lp b">ThemeProvider</code>包装的JSX，并根据主题选择应用<code class="fe lm ln lo lp b">override</code>。</p><pre class="kd ke kf kg gt no lp np nq aw nr bi"><span id="89b0" class="mw lr in lp b gy ns nt l nu nv">const Content = () =&gt; {</span><span id="6d7e" class="mw lr in lp b gy nw nt l nu nv">// using the custom hook defined in Step 2</span><span id="88b3" class="mw lr in lp b gy nw nt l nu nv">const { modernMode } = useModernMode();</span><span id="d7a3" class="mw lr in lp b gy nw nt l nu nv">// ...and choosing a theme based on that.</span><span id="256c" class="mw lr in lp b gy nw nt l nu nv">const themeChoice = modernMode ? modernTheme : retroTheme;</span><span id="ab3f" class="mw lr in lp b gy nw nt l nu nv">return (</span><span id="5c66" class="mw lr in lp b gy nw nt l nu nv">&lt;Theme.ThemeProvider overrides={themeChoice}&gt;</span><span id="d2ae" class="mw lr in lp b gy nw nt l nu nv">{/* your components and JSX here */}</span><span id="56e5" class="mw lr in lp b gy nw nt l nu nv">&lt;/Theme.ThemeProvider&gt;</span><span id="6bd2" class="mw lr in lp b gy nw nt l nu nv">);</span><span id="a22b" class="mw lr in lp b gy nw nt l nu nv">};</span></pre><p id="6a2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是我们解决方案的第二部分——将样式(基于当前活动的主题)向下传播到<code class="fe lm ln lo lp b">Theme.ThemeProvider</code>中的每个子/后代组件。他们将有权选择主题<em class="lk">和</em>主题本身(由ThemeProvider生成的正确的上下文感知主题，而不仅仅是设计标记)，并可以根据需要进一步使用或修改值。</p><p id="7e07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这看起来是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d855" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在单个组件中，您可以做完全相同的事情。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Only need the context variable modernMode here for dynamically determining the text in the titlebar (‘TodoStation 5’ or ‘Todo.exe’)</figcaption></figure><p id="77e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里，您可以看到这种设计模式是多么简单——然而又是多么健壮。</p><ol class=""><li id="9ab0" class="og oh in kq b kr ks ku kv kx oi lb oj lf ok lj ol om on oo bi translated">导入<code class="fe lm ln lo lp b">useModernMode</code>钩子，如果需要的话获取全局值。</li><li id="edcd" class="og oh in kq b kr op ku oq kx or lb os lf ot lj ol om on oo bi translated">导入<code class="fe lm ln lo lp b">useTheme </code>钩子，从中获取想要的样式值(当前活动样式的)，并用CSS或普通JavaScript覆盖它们。</li><li id="902e" class="og oh in kq b kr op ku oq kx or lb os lf ot lj ol om on oo bi translated">返回JSX，裹上<code class="fe lm ln lo lp b">&lt;Theme.ThemeProvider&gt;</code></li><li id="5b3a" class="og oh in kq b kr op ku oq kx or lb os lf ot lj ol om on oo bi translated">根据需要重复。</li></ol><p id="1976" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">…我们完成了！用<code class="fe lm ln lo lp b">npm start</code>启动本地服务器，然后看着这一切走到一起。</p><h1 id="04ef" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">通过你的力量组合…</h1><p id="8db7" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">现在，您已经确切地知道了如何将React Context API和Bit的<code class="fe lm ln lo lp b">ThemeProvider</code>功能结合起来，从而产生一个不仅仅用于主题化，而且用于主题的适当热交换的非常强大的解决方案——一个允许您在运行时动态更改样式属性的解决方案。</p><p id="3bc9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你现在手头有多少权力？想想这个:</p><ul class=""><li id="7094" class="og oh in kq b kr ks ku kv kx oi lb oj lf ok lj ou om on oo bi translated">你的组件完全服务于你的需求，但是现在是以一种<em class="lk">完全独立于</em>并且<em class="lk">完全不知道</em>你使用它们的环境的方式构建的。然后，您可以通过将它们导出到Bit来创建您自己的“组件市场”,然后在未来的项目中使用它们——真正的可重用性。</li><li id="f6a7" class="og oh in kq b kr op ku oq kx or lb os lf ot lj ou om on oo bi translated">这些<em class="lk">也是</em>易于共享的单个文件组件(Styles + Markup + JS all-in-one)，具有动态样式，<em class="lk">不会失去根据需要覆盖值的能力。</em></li><li id="6e6c" class="og oh in kq b kr op ku oq kx or lb os lf ot lj ou om on oo bi translated">两个字:<strong class="kq io">打字风格</strong>。你可以确保你的团队使用你定义的“类”，并且只使用你定义的类。不再有失控的连锁。如果你想变得更精细，你可以强制样式精确到<em class="lk">精确值</em>。</li></ul><p id="ac63" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">世界是你的。</p></div></div>    
</body>
</html>