<html>
<head>
<title>Understand the Call Stack, Callbacks, and Higher-Order Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的调用栈、回调和高阶函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-call-stack-callbacks-and-higher-order-functions-9191302481a0?source=collection_archive---------6-----------------------#2022-02-10">https://javascript.plainenglish.io/the-call-stack-callbacks-and-higher-order-functions-9191302481a0?source=collection_archive---------6-----------------------#2022-02-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4f40" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解JavaScript的一些较难的部分。</h2></div><p id="07c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">进入JavaScript的复杂部分，首先会遇到高阶函数、回调函数和JavaScript调用栈。这些看似深奥的东西甚至会让有经验的开发人员出错。所以今天，我将以一种简单的方式来分解这些事情，以便我们在继续我们的JavaScript体验之前获得一个坚实的基础。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/937af9c9256bb1ac66e4316730336b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58WOIgPP89wBv6SLUPjCwQ.jpeg"/></div></div></figure><h2 id="8ec9" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">调用堆栈</h2><p id="bb29" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在讨论调用堆栈之前，我们需要首先了解JavaScript如何在我们的代码中运行。JavaScript有一个“执行线程”，这个执行线程一行一行地执行我们的代码，或者“做”我们的代码。当我们调用一个函数时，执行的线程织入到函数中，在继续执行之前，在函数中要执行代码的地方停下来。(注意:这里假设我们没有做异步代码)<br/> <br/>这是调用栈发挥作用的地方:JavaScript需要跟踪我们的执行线程在哪里&amp;什么函数当前正在运行。需要注意的是，在调用栈的最底层是<code class="fe mi mj mk ml b">global()</code>函数，它告诉JavaScript在没有其他函数运行时继续执行我们的全部代码。</p><p id="1c38" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当执行线程到达我们代码中的函数调用时，JavaScript获取该函数并将其推到调用堆栈的顶部，继续跟踪我们的执行线程在哪里以及它正在执行什么函数。现在这个函数在调用栈的顶部，JavaScript织入我们的函数，并开始运行调用栈顶部的函数中的代码。一旦我们完成了这个函数，它就从调用栈顶弹出，JavaScript返回运行下一个最高的操作(在我们的例子中是<code class="fe mi mj mk ml b">global()</code>)。<br/> <br/>假设我们有一个简单的Math.js文件，其中包含一些代码和一些数学表达式函数:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="4edf" class="lk ll in ml b gy mq mr l ms mt">const num1 = 10<br/>const num2 = 5</span><span id="621f" class="lk ll in ml b gy mu mr l ms mt">function multiply(param1, param2) {<br/> return param1 * param2<br/>}</span><span id="570d" class="lk ll in ml b gy mu mr l ms mt">function divide(param1, param2) {<br/> return param1 / param2<br/>}</span><span id="4e57" class="lk ll in ml b gy mu mr l ms mt">const product = multiply(num1, num2) // 50<br/>const quotient = divide(num1, num2) // 2</span></pre><p id="ebff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们运行这段代码时，我们的执行线程从最顶端开始，而<code class="fe mi mj mk ml b">global()</code>函数位于调用堆栈的顶端。当JavaScript随着执行线程一行一行地遍历代码时，它存储我们的常数<code class="fe mi mj mk ml b">num1</code>和<code class="fe mi mj mk ml b">num2</code>，我们的函数在内存中乘除，一行一行地执行<code class="fe mi mj mk ml b">global()</code>函数。</p><p id="4579" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们点击我们的<code class="fe mi mj mk ml b">product</code>声明。当我们声明<code class="fe mi mj mk ml b">product</code>时，我们告诉JavaScript它评估从函数<code class="fe mi mj mk ml b">multiply</code>返回的带有参数<code class="fe mi mj mk ml b">(num1, num2)</code>的内容——因此，我们的执行线程织入乘法，将<code class="fe mi mj mk ml b">multiply(4, 2)</code>推到调用堆栈的顶部。现在我们在乘法函数内部，JavaScript停止执行任何其他代码，直到我们从表达式<code class="fe mi mj mk ml b">4 * 2</code>返回结果，织出乘法函数，将其弹出调用堆栈，并将<code class="fe mi mj mk ml b">product</code>设置为返回值8。</p><p id="7794" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们回到了<code class="fe mi mj mk ml b">global()</code>函数。JavaScript移动到下一行，我们重复前面的过程，但是执行线程织入<code class="fe mi mj mk ml b">divide</code>函数并将<code class="fe mi mj mk ml b">divide</code>推到调用栈的顶部。一旦<code class="fe mi mj mk ml b">divide</code>完成运行，我们再次将其从调用堆栈中弹出，并且<code class="fe mi mj mk ml b">quotient</code>被评估为返回值2。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h2 id="ab2b" class="lk ll in bd lm ln lo dn lp lq lr dp ls kl lt lu lv kp lw lx ly kt lz ma mb mc bi translated">回调和高阶函数</h2><p id="cc42" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">现在我们对调用堆栈的工作原理有了一点了解，让我们编辑我们的示例Math.js文件，并用两个回调函数参数组成我们的高阶函数。但是在我们继续这个例子之前，记住调用栈是很重要的，因为它使得理解高阶函数和回调函数更加容易。</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="1030" class="lk ll in ml b gy mq mr l ms mt">const num1 = 10<br/>const num2 = 5</span><span id="8a16" class="lk ll in ml b gy mu mr l ms mt">function multiply(param1, param2) {<br/> return param1 * param2<br/>}</span><span id="a45b" class="lk ll in ml b gy mu mr l ms mt">function divide(param1, param2) {<br/> return param1 / param2<br/>}</span><span id="5ddf" class="lk ll in ml b gy mu mr l ms mt">function sumOfTwoMathFunctions(callbackOne, callbackTwo) {<br/> const res1 = callbackOne(num1, num2)<br/> const res2 = callbackTwo(num1, num2)<br/> return res1+res2<br/>}</span><span id="1d77" class="lk ll in ml b gy mu mr l ms mt">const num3 = sumOfTwoMathFunctions(multiply, divide) // 52</span></pre><p id="c4ea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们来看一下运行Math.js文件时它发生了什么。我们的执行线程从顶部开始，当我们声明<code class="fe mi mj mk ml b">num1</code>、<code class="fe mi mj mk ml b">num2</code>和我们的三个函数时，它保留在我们的<code class="fe mi mj mk ml b">global()</code>函数中。</p><p id="661c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是让我们暂停一下，谈谈我们的第三个功能。你注意到了吗，如果你看声明行，它看起来只是一个普通的函数。高阶函数只是普通的函数，在调用时以其他函数作为参数。哦，那些我们作为参数传递的函数呢？那些是回调函数！</p><p id="9e70" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们写函数的时候，在我们写完函数之后，我们唯一能在函数内部改变的是我们作为变量留下的内容，当函数被调用的时候，它将被参数填充。但是如果我们想改变一个函数的一些内部功能呢？例如，如果我们写了一个减法函数，我们想要得到<code class="fe mi mj mk ml b">multiply(num1, num2)</code>和<code class="fe mi mj mk ml b">subtract(num1, num2)</code>的和。我们所要做的就是将调用<code class="fe mi mj mk ml b">sumOfTwoMathFunctions</code>时的一个参数改为<code class="fe mi mj mk ml b">subtract</code>！以上例为基础:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="a57b" class="lk ll in ml b gy mq mr l ms mt">sumOfTwoMathFunction(multiply, subtract) // 55</span></pre><p id="e089" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一个函数中留下一些信息“空白”,以便我们的函数可以重用，这是我们都已经知道的事情。但是留下一些<em class="nc">功能</em>“空白”以使一个函数更加通用&amp;可重用，这就是高阶函数和回调函数发挥作用的地方。</p><p id="5191" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经理解了高阶函数和回调函数的原因和方法，让我们继续执行线程吧！一旦我们到达最后一行，我们的执行线程就必须编织到我们新创建的函数中，将<code class="fe mi mj mk ml b">sumOfTwoMathFunctions</code>推到调用堆栈的顶部。从那里，我们的下一行代码要求我们织入我们的第一个回调函数<code class="fe mi mj mk ml b">multiply</code>，把它推到栈顶，在我们的<code class="fe mi mj mk ml b">sumOfTwoMathFunctions</code>函数之上。我们的调用栈现在是这样的，从上到下:<code class="fe mi mj mk ml b">multiply(4, 2)</code>-&gt;-<code class="fe mi mj mk ml b">sumOfTwoMathFunctions(multiply, divide)</code>-&gt;<code class="fe mi mj mk ml b">global()</code>。正如我们现在所知道的，JavaScript正在执行我们在<code class="fe mi mj mk ml b">multiply</code>中的代码，直到我们从其中返回，从调用栈中弹出，允许它移动到我们的下一个回调函数。</p><p id="4c02" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这似乎是对调用堆栈的基本解释，但它展示了JavaScript如何“读取”和执行我们的代码。理解如何在多层函数中遵循执行线程是理解更复杂主题(如currying函数)的关键。</p><p id="5b13" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nc">更多内容请看</em> <a class="ae nd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nc">说白了。报名参加我们的</em> <a class="ae nd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。在我们的</em> <a class="ae nd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nc">社区不和谐</em> </strong> </a> <em class="nc">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>