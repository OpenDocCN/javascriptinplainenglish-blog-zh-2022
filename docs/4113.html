<html>
<head>
<title>Stop Executing Function on Angular HTML Template</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在Angular HTML模板上执行函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-executing-function-on-angular-html-template-c0fdd1d13b03?source=collection_archive---------4-----------------------#2022-10-26">https://javascript.plainenglish.io/stop-executing-function-on-angular-html-template-c0fdd1d13b03?source=collection_archive---------4-----------------------#2022-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8381" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Angular允许你在HTML模板中执行一个函数或getter。但是，你想过这是一个好方法吗？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c087acbd2da917f7b9262e2f5b0ee48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCyuIxAaK3p54NqfBBG4jA.jpeg"/></div></div></figure><p id="2bb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当你开发一个组件时，你也将编写一个已经支持<a class="ae lk" href="https://angular.io/guide/binding-overview" rel="noopener ugc nofollow" target="_blank">绑定</a>的HTML模板。绑定在从模板(DOM元素、指令或组件)创建的UI的一部分和组件的数据模型之间创建一个活动连接。你可以绑定一个变量，值，甚至是执行一个函数。</p><h1 id="54a8" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">问题是</h1><p id="2b2f" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">当Angular运行<a class="ae lk" href="https://angular.io/guide/change-detection" rel="noopener ugc nofollow" target="_blank">变化检测</a>时，它将从上到下遍历您的组件，寻找绑定值的变化，以便数据模型的变化反映在应用程序的视图中。这种机制允许Angular仅在改变的边界值和变量上智能地重新渲染。</p><p id="2a78" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相反，在HTML中执行一个方法时。Angular将总是盲目地重新执行一个绑定的函数，因为它不能确定什么条件被认为是函数中的变化。</p><p id="819b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有一个<a class="ae lk" href="https://codepen.io/sulha199/pen/XWqOKEj" rel="noopener ugc nofollow" target="_blank">的密码本</a>说明了这种情况:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk"><a class="ae lk" href="https://codepen.io/sulha199/pen/XWqOKEj" rel="noopener ugc nofollow" target="_blank">https://codepen.io/sulha199/pen/XWqOKEj</a></figcaption></figure><p id="4c08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如上图<a class="ae lk" href="https://codepen.io/sulha199/pen/XWqOKEj" rel="noopener ugc nofollow" target="_blank"> Codepen </a>所示，每次点击一个按钮，那么Angular就会一直执行直接传递给HTML的方法。然而，使用<a class="ae lk" href="https://angular.io/guide/pipes#detecting-pure-changes-to-primitives-and-object-references" rel="noopener ugc nofollow" target="_blank">纯管道</a>传递的方法只在输入值改变时执行。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="7893" class="mt lm in mp b gy mu mv l mw mx">"w/ pipe = executed 1x | w/o pipe = executed 4x"</span><span id="f712" class="mt lm in mp b gy my mv l mw mx">"w/ pipe = executed 1x | w/o pipe = executed 6x"</span><span id="7201" class="mt lm in mp b gy my mv l mw mx">"w/ pipe = executed 1x | w/o pipe = executed 8x"</span><span id="f729" class="mt lm in mp b gy my mv l mw mx">"update text"</span><span id="fe90" class="mt lm in mp b gy my mv l mw mx">"w/ pipe = executed 2x | w/o pipe = executed 12x"</span><span id="b642" class="mt lm in mp b gy my mv l mw mx">"w/ pipe = executed 2x | w/o pipe = executed 14x"</span><span id="47ea" class="mt lm in mp b gy my mv l mw mx">"w/ pipe = executed 2x | w/o pipe = executed 16x"</span></pre><p id="c8d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一个简单的函数如果一直被执行，相对来说不会带来什么伤害。然而，具有副作用的函数可能会导致意外的行为，因为副作用会在每次变更检测发生时产生。另一种情况是函数返回图像资源URL。当检测到变化时，它将重新请求图像。</p><h1 id="bfc4" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">管</h1><p id="4604" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><a class="ae lk" href="https://angular.io/guide/pipes-overview" rel="noopener ugc nofollow" target="_blank">管道</a>是在<a class="ae lk" href="https://angular.io/guide/glossary#template-expression" rel="noopener ugc nofollow" target="_blank">模板表达式</a>中使用的简单函数，用于接受输入值并返回转换后的值。<a class="ae lk" href="https://angular.io/guide/pipes#detecting-pure-changes-to-primitives-and-object-references" rel="noopener ugc nofollow" target="_blank">纯管道</a>有智能机制，所以只有当输入值改变时才执行。听起来我们可以通过将它们转换成管道来解决上面的函数重新执行。然而，<a class="ae lk" href="https://angular.io/guide/pipes-custom-data-trans#using-the-pipetransform-interface" rel="noopener ugc nofollow" target="_blank">创建管道</a>也不是一个有效的解决方案，因为您需要创建管道类本身，然后决定如何将它注入到您的组件中。</p><h1 id="a74c" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">各行各业的管道</h1><p id="a732" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">意识到上述问题，我编写了自己的管道，接受一个函数作为参数。令人惊讶的是，在Typescript的帮助下，管道还能够建议输入值的类型和额外管道的参数。</p><p id="d388" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里，我分享我的代码是什么样子的:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="9cd7" class="mt lm in mp b gy mu mv l mw mx">import { Pipe, PipeTransform } from '<a class="ae lk" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>'</span><span id="aa3a" class="mt lm in mp b gy my mv l mw mx">/** Obtain the arguments' types of a function except the first argument */<br/>type RestArgument&lt;T&gt; = T extends (first: unknown, ...args: infer Rest) =&gt; any<br/>  ? Rest<br/>  : never</span><span id="7c92" class="mt lm in mp b gy my mv l mw mx"><a class="ae lk" href="http://twitter.com/Pipe" rel="noopener ugc nofollow" target="_blank">@Pipe</a>({ name: 'apply' })<br/>export class ApplyFunctionPipe implements PipeTransform {<br/>  /**<br/>   * <a class="ae lk" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> callbackMethod method that is to be run using `ApplyFunctionPipe`.<br/>   ** If you require access to component's property, please pass an arrow function instead of class method<br/>   */<br/>  transform&lt;Callback extends (value: any, ...extra: any[]) =&gt; any&gt;(<br/>    value: Parameters&lt;Callback&gt;[0],<br/>    callbackMethod: Callback,<br/>    ...extra: RestArgument&lt;Callback&gt;<br/>  ): ReturnType&lt;Callback&gt; {<br/>    return callbackMethod(value, ...extra)<br/>  }<br/>}</span></pre><p id="9665" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">用法</strong>:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="edba" class="mt lm in mp b gy mu mv l mw mx">{{ someProperties | apply : 'someMethod' }}</span></pre><h1 id="6135" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">阵列管道</h1><p id="a2e8" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">作为奖励，我还将分享一个可以进行各种数组操作的管道</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="23e0" class="mt lm in mp b gy mu mv l mw mx">type AnyFunction = (...args: any[]) =&gt; any<br/>type GetParameters&lt;F&gt; = F extends AnyFunction ? Parameters&lt;F&gt; : never<br/>type GetReturn&lt;F&gt; = F extends AnyFunction ? ReturnType&lt;F&gt; : never</span><span id="18ee" class="mt lm in mp b gy my mv l mw mx">export type FirstArgs&lt;T, F = any&gt; = T extends [<br/>  first: infer First,<br/>  ...args: any<br/>] ? (First extends F ? First : never)<br/>  : never</span><span id="9a4f" class="mt lm in mp b gy my mv l mw mx"><a class="ae lk" href="http://twitter.com/Pipe" rel="noopener ugc nofollow" target="_blank">@Pipe</a>({ name: 'array', pure: false })<br/>export class ArrayPipe implements PipeTransform {<br/>  transform&lt;<br/>    ItemType, <br/>    ArrayType extends Array&lt;ItemType&gt;, <br/>    MethodName extends keyof ArrayType, <br/>    MethodArgs extends GetParameters&lt;ArrayType[MethodName]&gt;<br/>  &gt;(items: ArrayType, arrayMethod: MethodName, ...args: MethodArgs): MethodName extends 'map' ? ReturnType&lt;FirstArgs&lt;MethodArgs, AnyFunction&gt;&gt;[] : GetReturn&lt;ArrayType[MethodName]&gt; {<br/>    return typeof items[arrayMethod] === 'function' ? <br/>      (items[arrayMethod] as any)(...args as any) : <br/>      items[arrayMethod]<br/>  }<br/>}</span></pre><p id="7b04" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">用法</strong>:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="7613" class="mt lm in mp b gy mu mv l mw mx">{{ [ 1, 2] | array : 'join': ' | ' }} &lt;!-- will output "1 | 2" --&gt;</span></pre><h1 id="454e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">最后</h1><p id="f660" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><strong class="kq io">感谢阅读。我打算分享更多简单而有效的技巧。我期待着你的关注。</strong></p><p id="90d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mz">更多内容请看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mz">说白了就是</em> </strong> </a> <em class="mz">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mz">免费每周简讯</em> </strong> </a> <em class="mz">。关注我们关于</em> <a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mz">推特</em> </strong> </a>，<a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mz">LinkedIn</em></strong></a><em class="mz">，</em><a class="ae lk" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mz">YouTube</em></strong></a><em class="mz"/><a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mz">不和</em> </strong> </a> <strong class="kq io"> <em class="mz">。</em> </strong></p><p id="c9d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mz">有兴趣规模化你的软件创业</em> </strong> <em class="mz">？检查</em> <a class="ae lk" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mz">电路</em> </strong> </a> <em class="mz">。</em></p></div></div>    
</body>
</html>