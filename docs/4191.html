<html>
<head>
<title>How to Compose and Integrate APIs Together as if You Were Using NPM for APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将API组合和集成在一起，就像您正在使用API的NPM一样</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-compose-and-integrate-apis-together-as-if-you-were-using-npm-for-apis-4a6113108cb3?source=collection_archive---------7-----------------------#2022-11-07">https://javascript.plainenglish.io/how-to-compose-and-integrate-apis-together-as-if-you-were-using-npm-for-apis-4a6113108cb3?source=collection_archive---------7-----------------------#2022-11-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0588" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">了解如何将React的可组合性范式引入API、微服务和数据库领域——由Wundergraph、构建时GraphQL和BFF/API网关模式提供支持。</em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi kd"><img src="../Images/f75f7f4dac1215f1958a32227fa5419d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*U1yBi4jDu2iMaT5L"/></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">Bringing together two APIs for an app that shows the biggest concerts, historically, by country capital.</figcaption></figure><p id="db7a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">使用React/Next.js，你正在解决的基本问题是将一些“状态”的概念转化为DOM，重点是可组合性——使用较小的东西来构建较大的东西<em class="ll">。</em></p><p id="711e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">恭喜你，你已经找到了web开发的最终老板:构建可重复使用的“乐高积木”,可以无限扩展。如果您没有从一开始就使用React/Next.js来进行这场战斗，那么在某个时候，您将不可避免地重新实现一个更糟糕的、特别的jQuery“React”——并负责维护它。</p><p id="f771" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">但是构建可组合的ui只是成功的一半。如果没有数据<em class="ll"> </em>显示，世界上最具可伸缩性的用户界面将一无是处。那么，这里是另一半:使用API、数据库和微服务。如果我们要全力以赴开发可伸缩的、模块化的web应用，我们<strong class="kr io">也不能</strong>忘记这个问题空间中的可组合性。</p><p id="a249" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这就是WunderGraph(一个开源API开发平台)可以提供帮助的地方。在React心智模型中，您已经习惯于在<code class="fe ln lo lp lq b">package.json</code>文件中列出您的所有依赖项，并在您<code class="fe ln lo lp lq b">npm install &amp;&amp; npm start</code>一个项目时让包管理器来完成剩下的工作。<strong class="kr io"> WunderGraph让你保持这种直觉，并对你的数据源做同样的事情</strong>:</p><ol class=""><li id="719d" class="lr ls in kr b ks kt kv kw ky lt lc lu lg lv lk lw lx ly lz bi translated">以配置即代码的格式明确命名您需要的API、微服务和数据库，然后，</li><li id="7abb" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk lw lx ly lz bi translated">WunderGraph生成客户端代码，当您在前端工作时，这些代码为您提供了对所有这些数据源的一流的类型安全访问(通过Next.js/React钩子)。</li></ol><p id="216f" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在本教程中，我们将有点冒险，在一个Next.js应用程序中将两个完全不同、非常不同的API放在一起，以展示WunderGraph(没有其他依赖项)作为独立的服务器/API网关/ <a class="ae lm" href="https://learn.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends" rel="noopener ugc nofollow" target="_blank"> BFF </a>与您的前端一起运行，您可以针对多个REST、GraphQL、MySQL、Postgres、DBaaS(如Fauna、MongoDB等)<strong class="kr io">编写前端代码，就好像它们是一个单一的整体</strong>。</p><p id="31ac" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">不过，在我们开始之前，让我们快速了解一下TL；DR a概念:</p><h1 id="4935" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">“可组合性”对API意味着什么？</h1><p id="f174" class="pw-post-body-paragraph kp kq in kr b ks mx jo ku kv my jr kx ky mz la lb lc na le lf lg nb li lj lk ig bi translated">现在，您与数据源的交互完全是用代码实现的。您编写代码来调用API端点或数据库(在您的。env文件)，然后编写更多的代码。这一次，异步样板/胶水管理返回的数据。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/a06db9f8c7577c07acd8583c3900c0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XTo3mdd5HeaUHfAc"/></div></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">What’s wrong with this picture?</figcaption></figure><p id="4ff5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">代码本身是正确的，什么是“错误的”是现在<strong class="kr io">你把一个依赖项耦合到你的代码，而不是你的配置文件</strong>。当然，这个天气API不是axios或react-dom(库/框架包)，但它<strong class="kr io">仍然是</strong>一个依赖项，现在，一个只镜像临时数据的第三方API，已经被提交给你的回购，成为你的核心业务的一部分，你现在将支持它的整个生命周期。</p><p id="7a7d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">坚持乐高类比:这就像把你的玩具粘在一起。欢迎来到臃肿、可读性差、难以维护的硬约束代码库。</p><p id="302e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">你将在现代大中型应用程序上做上述十倍<em class="ll"> </em>的工作，这些应用程序被分成许多微服务，具有复杂的交互，并且每个应用程序都有独立的团队，每个团队都可能会相互影响。这还没有算上为获得所需数据而跨多个服务/API进行的所有连接。</p><p id="1882" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">那么，在不牺牲开发人员体验的情况下，API可组合性的可伸缩方法会是什么样的呢？</p><ol class=""><li id="b17d" class="lr ls in kr b ks kt kv kw ky lt lc lu lg lv lk lw lx ly lz bi translated">它需要支持各种数据，而不需要为每种类型提供单独的客户端，我们需要能够在我们的应用程序代码之外显式定义这些数据依赖关系——可能在一个配置文件中。</li><li id="470d" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk lw lx ly lz bi translated">它应该允许我们在需要时添加更多的数据源，<strong class="kr io"> </strong>从依赖数组中删除过时/失效的数据源，并自动更新客户端以反映这些变化。</li><li id="ff7c" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk lw lx ly lz bi translated">它应该允许我们将来自多个来源(API、数据库、Apollo联邦、微服务等)的数据缝合在一起。)所以我们可以完全避免在前端进行代码内连接。</li></ol><p id="bda9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">事实证明，这正是WunderGraph所实现的，它结合了API Gateway和BFF架构。</p><p id="6d50" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果您在WunderGraph配置中显式命名您的API依赖项，如右图所示，则如下所示:</p><div class="ke kf kg kh gt ab cb"><figure class="nh ki ni nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><img src="../Images/ba0df1328841392d8bdde544722d2d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*g62HvzS8zNIuXKUrRROKUQ.png"/></div></figure><figure class="nh ki nn nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><img src="../Images/02556fec64378b8c405f1bf3aef774ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*CcGIkmGDUjw70-DjJjC_Sw.png"/></div><figcaption class="kl km gj gh gi kn ko bd b be z dk no di np nq">Conceptually, what’s the difference? There are none; both are config files with a list of things your app needs. Sure, you’re writing a little more code on the right, but that’s just stuff React/Next.js does for you under the hood anyway<em class="kc"> </em>on the left.</figcaption></figure></div><p id="5e36" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">WunderGraph检查并合并这些数据源(不仅仅是端点)到一个命名空间的虚拟图中，并从中构建一个模式。</p><p id="ce59" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在，你不再关心:</p><ol class=""><li id="42c1" class="lr ls in kr b ks kt kv kw ky lt lc lu lg lv lk lw lx ly lz bi translated">您的数据依赖关系在幕后的工作方式有多么不同。</li><li id="639a" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk lw lx ly lz bi translated">将任何第三方客户端放在前端，以支持这些不同的数据源。</li><li id="b6a2" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk lw lx ly lz bi translated">你的团队应该如何跨域交流。</li></ol><p id="db7d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">因为现在你已经有了所有的数据依赖作为一个规范层，一个<strong class="kr io">真实的单一来源</strong> — <strong class="kr io"> GraphQL。</strong></p><p id="6bfc" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">正如您可能已经猜到的，接下来，只需编写操作(WunderGraph在IDE中为您提供的GraphQL查询/变异)就可以从这个标准化的数据层中获得您想要的数据。这些在构建时被编译到一个native client中，持久化，并使用JSON-RPC (HTTP)公开。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/dd34f0fb6b81199bca9cff6a44f73e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DkDa8WxIHdYbUxee"/></div></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">All the DevEx wins of using GraphQL without actually having a public GraphQL endpoint, so none of its security/caching/bundle size concerns on the client side.</figcaption></figure><p id="de53" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">最后，在您的前端代码中，您使用这个生成的客户端的类型安全数据获取挂钩。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/c361861ba35cb11d80291742a6f4dce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dzM6aBAfNZ8cwhi3"/></div></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">Clear, intuitive, and maintainable.</figcaption></figure><p id="28e7" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">最终结果？<strong class="kr io">一个码头工人或NPM式的集装箱化/包装管理器范例，但用于数据源</strong>。以及随之而来的所有好处:</p><ul class=""><li id="f90d" class="lr ls in kr b ks kt kv kw ky lt lc lu lg lv lk nr lx ly lz bi translated">API、数据库和微服务变成了<strong class="kr io">模块化、可组合的乐高积木</strong>，就像你的UI组件一样。</li><li id="df29" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated">前端的连接和过滤器不再有代码膨胀，大大提高了代码可读性，并且在尝试通过微服务进行事务处理时不再有竞争情况。</li><li id="780f" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated">最终的“端点”是良好的老式HTTP上的JSON-RPC；不管数据源是什么类型，缓存、权限、身份验证和安全性都成为需要解决的问题。</li></ul><p id="d41d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">但是为什么要拘泥于理论呢？让我们开始吧！</p><h1 id="07f6" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">像对待乐高那样对待API的冒险</h1><p id="d7db" class="pw-post-body-paragraph kp kq in kr b ks mx jo ku kv my jr kx ky mz la lb lc na le lf lg nb li lj lk ig bi translated">像在图书馆一样组合和汇集数据源的能力可以带你去非常有趣的地方，那里有任何普通的公共API都不能给你的想法。</p><p id="e60d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">比方说，如果你想找出最大的音乐事件——音乐会、独奏会、节日等等，该怎么办？历史上曾在某个国家的首都？</p><div class="ke kf kg kh gt ab cb"><figure class="nh ki ns nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><img src="../Images/81a2114b2dbc125a831d15eba31d898f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tsLRVO7ryxu6s7boWCN8dw.jpeg"/></div></figure><figure class="nh ki ns nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><img src="../Images/cc92d4eca0831410463ded50f7f14cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*HEuPRpTsbomnyF6_RbMzKA.jpeg"/></div><figcaption class="kl km gj gh gi kn ko bd b be z dk nt di nu nq">There’s literally<em class="kc"> </em>no API like this out there. You could build the first one. The world’s your oyster!</figcaption></figure></div><h1 id="f817" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">步骤1:决定数据</h1><p id="64f3" class="pw-post-body-paragraph kp kq in kr b ks mx jo ku kv my jr kx ky mz la lb lc na le lf lg nb li lj lk ig bi translated">所以我们在这里使用的两个API是<a class="ae lm" href="https://countries.trevorblades.com/" rel="noopener ugc nofollow" target="_blank">国家API </a>和<a class="ae lm" href="https://graphbrainz.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> MusicBrainz聚合器</a>。您可以随意使用失眠症/邮递员/游乐场，并感受一下使用这些API可以合理地查询哪些数据。您可能会发现大量额外的、创造性的用例。</p><h1 id="2cc6" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">第二步:快速启动WunderGraph + Next.js应用程序</h1><p id="2609" class="pw-post-body-paragraph kp kq in kr b ks mx jo ku kv my jr kx ky mz la lb lc na le lf lg nb li lj lk ig bi translated">当你准备好继续前进时，在WunderGraph的repo中使用starter模板，用于Next.js应用程序，该应用程序使用前者作为BFF/API网关。</p><p id="2130" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><code class="fe ln lo lp lq b">npx -y @wundergraph/wunderctl init — template nextjs-starter -o wg-concerts</code></p><p id="acb6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这将创建一个名为wg-concerts的新项目目录(或者您选择的文件夹名)，通过使用npm-run-all包，启动一个WunderGraph(位于localhost:9991)和一个Next.js服务器(位于localhost:3000)；特别是使用run-p别名来并行运行两者。</p><h1 id="1bf9" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">步骤3:Concerts by Capital——无需代码的跨API连接。</h1><p id="5ed7" class="pw-post-body-paragraph kp kq in kr b ks mx jo ku kv my jr kx ky mz la lb lc na le lf lg nb li lj lk ig bi translated">这是这本指南的要点。我已经详细讨论了跨源数据连接是如何在代码中完成的，现在，您将直接看到WunderGraph如何简化它们。</p><p id="f2ca" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">您可以将两个API响应缝合在一起——在我们的示例中，获取一个国家的首都，然后使用该信息<em class="ll"> </em>到<em class="ll"> </em>查询在那里举行的音乐会——如下所示:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">Imagine implementing this query in JavaScript. Truly, spooky season. 🎃</figcaption></figure><ul class=""><li id="1bc4" class="lr ls in kr b ks kt kv kw ky lt lc lu lg lv lk nr lx ly lz bi translated">args的<code class="fe ln lo lp lq b">@internal</code>指令表示，虽然这个参数在技术上是一个“输入”，但它只能在这个查询内部找到，在我们调用这个操作时不需要提供。</li><li id="a78f" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated"><code class="fe ln lo lp lq b">@export</code>指令与<code class="fe ln lo lp lq b">@internal</code>协同工作，无论您要导出什么(或者别名——这就是'<code class="fe ln lo lp lq b">as</code>'关键字的用途)都必须与您标记为内部的arg具有相同的名称和类型。</li><li id="8f06" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated"><code class="fe ln lo lp lq b">_join</code>表示实际的加入操作:</li><li id="4eee" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated">可以看出，第二个查询的输入(查询)使用了我们在GraphQL查询的顶层标记为internal的同一个参数。</li><li id="1fef" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated">虽然是可选的，但我们使用了<code class="fe ln lo lp lq b">@transform</code>指令(然后是指向我们需要的确切数据结构的“<code class="fe ln lo lp lq b">get</code>”字段)将第二个查询的响应别名为“concerts”，因为我们加入的任何额外查询当然会添加另一个复杂、烦人的嵌套结构，并且我们希望简化它，使其尽可能具有可读性。</li><li id="d0d2" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated">我们还(可选地)为每场音乐会包含了<code class="fe ln lo lp lq b">relationships </code>字段，以在这里获取<code class="fe ln lo lp lq b">mbid </code>(参与音乐会的艺术家的MusicBrainz内部ID ),因为我们仍然希望稍后单独查询艺术家实体(横幅、缩略图、bios等。同样，可选)。</li></ul><h1 id="50f6" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">步骤4:获取艺术家详细信息</h1><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">Speaking of developer experience…here’s a little gotcha with the <code class="fe ln lo lp lq b">artistId </code>variable being of type <code class="fe ln lo lp lq b">MBID! </code>and not <code class="fe ln lo lp lq b">String!</code>. Thanks to WunderGraph, you get code hinting for that in your IDE!</figcaption></figure><p id="38ed" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们的第二个和第三个操作分别是通过他们的MusicBrainz ID获得艺术家的1000x185像素横幅图像(来自音频数据库),然后是缩略图/传记。这只是为了美化我们的UI，如果您只想要音乐会的细节而不想要其他的，您可以跳过这些查询(可能因为您的用例根本不需要UI)。</p><h1 id="fe00" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">步骤5:在前端显示我们的数据</h1><p id="ee65" class="pw-post-body-paragraph kp kq in kr b ks mx jo ku kv my jr kx ky mz la lb lc na le lf lg nb li lj lk ig bi translated">我们在最后冲刺阶段！让我们不要在这里太疯狂，只是每个音乐会映射到<code class="fe ln lo lp lq b">&lt;ConcertCard&gt;</code>组件，和一个<code class="fe ln lo lp lq b">&lt;NavBar&gt;</code>与一个<code class="fe ln lo lp lq b">&lt;Dropdown&gt;</code>来选择一个国家在其首都获取音乐会。哦，当然还有造型用的TailwindCSS。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="37e6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">全部完成！启动<code class="fe ln lo lp lq b"> localhost:3000</code>，你将看到你的应用程序。</p><p id="481b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">但是在我们结束之前，这里有一个非常重要的问题。</p><h1 id="b713" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">如果我不用Next.js/React?呢</h1><p id="8ba4" class="pw-post-body-paragraph kp kq in kr b ks mx jo ku kv my jr kx ky mz la lb lc na le lf lg nb li lj lk ig bi translated">WunderGraph仍然作为一个简单的API网关/BFF工作，不需要自动生成前端客户端来获取数据。</p><p id="0668" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">不过，在这种情况下，您将无法访问WunderGraph为您的客户端生成的类型安全的React挂钩，因此您将不得不承担更多的问题——自己实现数据获取，注意类型安全，并手动进行内部GET/POST调用。</p><p id="e815" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">使用默认的WunderGraph配置，每个操作(。graphql文件)被公开为JSON-RPC (HTTP ),位于:</p><p id="9dec" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><code class="fe ln lo lp lq b"><a class="ae lm" href="http://localhost:9991/app/main/operations/[operation_name]?[params" rel="noopener ugc nofollow" target="_blank">http://localhost:9991/app/main/operations/[operation_name]</a></code></p><p id="9ced" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">因此，您的数据获取将如下所示:</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/829d173508b29b9056c443649c74a58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pEx5TGwuJfyghvJ7"/></div></div></figure><p id="2e2b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">其中<code class="fe ln lo lp lq b">Weather.graphql</code>是您的操作的文件名。</p><h1 id="9c4d" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">成就解锁:数据的可组合性</h1><p id="f005" class="pw-post-body-paragraph kp kq in kr b ks mx jo ku kv my jr kx ky mz la lb lc na le lf lg nb li lj lk ig bi translated">有了WunderGraph作为工具的一部分来整合所有的API、数据库和微服务——无论是作为BFF、API网关、只镜像只读数据的视图聚合器，还是其他什么——您就能在数据领域获得<strong class="kr io">UI可组合性的所有好处。</strong></p><ol class=""><li id="8cf2" class="lr ls in kr b ks kt kv kw ky lt lc lu lg lv lk lw lx ly lz bi translated"><strong class="kr io">渐进增强</strong>:随着业务需求的增长，随时修改代码以充实内容，或者添加新的部分。</li></ol><p id="7358" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io"> 2。灵活性</strong>:根据需要更换部件，这样您的技术组合就不会僵化。</p><p id="ae1e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">3.改进的端到端<strong class="kr io">开发人员体验</strong>:</p><ul class=""><li id="9488" class="lr ls in kr b ks kt kv kw ky lt lc lu lg lv lk nr lx ly lz bi translated"><strong class="kr io">所有数据的单一真实来源</strong> (GraphQL层)。</li><li id="9862" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated">通过代码生成实现的<strong class="kr io">完美塑造的客户端</strong>意味着每个团队在将操作编写为GraphQL查询或变体时，都确切地知道他们可以或不可以对数据做什么(通过IDE中的自动完成),从而允许您为您的用户精心制作您想要的准确的<em class="ll"> </em>体验，而不会出现试用&amp;错误。</li><li id="1533" class="lr ls in kr b ks ma kv mb ky mc lc md lg me lk nr lx ly lz bi translated">与Next.js一起，您可以在您的<code class="fe ln lo lp lq b">&lt;Suspense&gt; </code>边界中准备好查询，这样您就可以确切地知道每个边界中呈现了什么，以及它到底运行了哪些查询。这种知识导致<strong class="kr io">更好的修补和优化</strong>,因为您会确切地知道任何问题或瓶颈在哪里。</li></ul><p id="ec87" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">就现代的无服务器web开发而言，<strong class="kr io"> WunderGraph可以在任何可以运行Docker </strong>的设备上运行，因此可以无缝集成到您的技术堆栈中。</p><p id="f7bb" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">那是<em class="ll"> </em>神童的powerplay。所有依赖项的可组合性，允许您为现代网络构建模块化的数据密集型体验，而不会影响开发人员的体验。</p><p id="4d2d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><em class="ll">更多内容请看</em><a class="ae lm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="ll">plain English . io</em></strong></a><em class="ll">。报名参加我们的</em> <a class="ae lm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="ll">免费周报</em> </strong> </a> <em class="ll">。关注我们关于</em><a class="ae lm" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="ll">Twitter</em></strong></a><a class="ae lm" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="ll">LinkedIn</em></strong></a><strong class="kr io"><em class="ll"/></strong><a class="ae lm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="ll">YouTube</em></strong></a><strong class="kr io"><em class="ll">，以及</em></strong><em class="ll"/><a class="ae lm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="ll">不和</em> </strong> </a>  <em class="ll">对成长黑客感兴趣？检查</em> <a class="ae lm" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="ll">电路</em> </strong> </a> <strong class="kr io"> <em class="ll">。</em> </strong></p></div></div>    
</body>
</html>