<html>
<head>
<title>Using TypeScript Intersection Types Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专家一样使用TypeScript交集类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7?source=collection_archive---------1-----------------------#2022-08-23">https://javascript.plainenglish.io/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7?source=collection_archive---------1-----------------------#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你应该知道的关于TypeScript交集类型的细节——用动画解释。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d98b6883561fe6313f1379401e4c04da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0EDOgd63mgLUCcnj5sQWQ.jpeg"/></div></div></figure><p id="b5d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎来到<strong class="kt ir">掌握打字稿</strong>系列。本系列将以动画的形式介绍TypeScript的核心知识和技术。让我们一起学习吧！以前的文章如下:</p><ul class=""><li id="1de8" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener"><strong class="kt ir">TypeScript泛型中的K、T、V是什么？</strong> </a></li><li id="456b" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-mapped-types-like-a-pro-be10aef5511a"> <strong class="kt ir">使用TypeScript像Pro一样映射类型</strong> </a></li><li id="3b5a" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-conditional-types-like-a-pro-7baea0ad05c5"> <strong class="kt ir">使用TypeScript条件类型像亲</strong> </a></li><li id="6434" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://levelup.gitconnected.com/using-typescript-infer-like-a-pro-f30ab8ab41c7" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">使用打字稿像专家一样推断</strong> </a></li><li id="4d4a" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/javascript-in-plain-english/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac" rel="noopener"> <strong class="kt ir">使用TypeScript模板字面类型像亲</strong> </a></li><li id="f23a" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/15-utility-types-that-every-typescript-developer-should-know-6cf121d4047c"> <strong class="kt ir">可视化打字稿:15种最常用的实用类型</strong> </a></li></ul><p id="674a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">学习TypeScript时，您可以将类型理解为值的集合。比如你可以把number type想象成所有数字的集合，1.0，68属于这个集合，但是“bytefer”不属于这个集合，因为它属于string类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/6606d51a0ac1d28aeebc7dfcf200a888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wLwKxzn84reKQKK0oOn0Zg.gif"/></div></div></figure><p id="d833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，对于对象类型，我们也可以理解为对象的集合。例如，以下代码中的Point类型表示具有x和y属性的对象的集合，属性值的类型都是数字类型。命名类型表示包含name属性的对象集合，属性值的类型是字符串类型。</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="ace2" class="mi mj iq me b gy mk ml l mm mn">interface Point {<br/>  x: number;<br/>  y: number;<br/>}</span><span id="8380" class="mi mj iq me b gy mo ml l mm mn">interface Named {<br/>  name: string;<br/>}</span></pre><p id="bb65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在集合论中，假设A和B是集合，由属于集合A和属于集合B的所有元素组成的集合称为集合A和集合B的交。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/94e15904181fc5dbcdd06d48d2f381ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uCAgRXJm5Ng6gm1LuhNLPQ.gif"/></div></div></figure><p id="aa9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们将点类型和命名类型相交时，会创建一个新类型。此类型中包含的对象属于点类型和命名类型。</p><p id="d2fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在TypeScript中，为我们提供了<strong class="kt ir"> &amp; </strong>运算符来实现对多个类型的交集运算，得到的新类型称为交集类型。</p><p id="10f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面简单介绍一下<strong class="kt ir"> &amp; </strong>运算符，它满足以下规则:</p><ul class=""><li id="5157" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">身份:<code class="fe mp mq mr me b">A &amp; A</code>等同于<code class="fe mp mq mr me b">A</code>。</li><li id="385f" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">交换性:<code class="fe mp mq mr me b">A &amp; B</code>等同于<code class="fe mp mq mr me b">B &amp; A</code>(除了下面提到的调用和构造签名)。</li><li id="fbd7" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">关联性:<code class="fe mp mq mr me b">(A &amp; B) &amp; C</code>等同于<code class="fe mp mq mr me b">A &amp; (B &amp; C)</code>。</li><li id="e39b" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">超型折叠:<code class="fe mp mq mr me b">A &amp; B</code>如果<code class="fe mp mq mr me b">B</code>是<code class="fe mp mq mr me b">A</code>的超型，则等同于<code class="fe mp mq mr me b">A</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4ad780f6c00f875c93aa3c43e568bb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZiZDsFEd45fyqeqzF52zQ.jpeg"/></div></div></figure><p id="79c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，任何类型和从不类型都是特殊的。除了从不类型之外，任何与任何类型相交的类型都会导致任何类型。在介绍了<strong class="kt ir"> &amp; </strong>运算符后，我们来看看点类型和命名类型相交后会得到什么类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/85a2c36558c71c33708695c3f4aed082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mvY1GunoyiNUZY_9KC6mSQ.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3395cfcc58f9777eb900eec189a8fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDHeaGGStF7nS8S0JmN4Kg.jpeg"/></div></div></figure><p id="f71e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">新生成的名称点类型包含x、y和名称属性。<strong class="kt ir">但是当包含相同属性但属性不是同一类型的多个对象类型相交时会发生什么？</strong></p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="bf54" class="mi mj iq me b gy mk ml l mm mn">interface X {<br/>  c: string;<br/>  d: string;<br/>}</span><span id="84fb" class="mi mj iq me b gy mo ml l mm mn">interface Y {<br/>  c: number;<br/>  e: string<br/>}</span><span id="8dd8" class="mi mj iq me b gy mo ml l mm mn">type XY = X &amp; Y;<br/>type YX = Y &amp; X;</span></pre><p id="c6d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，接口X和接口Y都包含相同的c属性，但是它们的类型不同。在这种情况下，XY类型或YX类型中的c属性的类型可以是字符串类型还是数字类型？让我们验证一下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/ce57f307d677e11c4bab404aefa2c5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*839qzaoEMLKHSJo-7pPdZg.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c12f8989f00ecb483d646d3430dbd47a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtTBGsU2lWLuifGqPB55gg.jpeg"/></div></div></figure><p id="1742" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么在接口X和接口Y相交之后，c属性的类型永远不会变成类型？这是因为操作后c属性的类型是string &amp; number，也就是说，c属性的类型可以是string类型，也可以是number类型。显然，这个类型不存在，所以操作后c属性的类型是never类型。</p><p id="3b4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在前面的例子中，接口X和接口Y中的c属性的类型都是原始数据类型。那么，如果不同的对象类型包含相同的属性，并且属性类型是非原始数据类型，会发生什么呢？让我们看一个具体的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/22a38ae41c581d2bacfdb1eba0570f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6B2qxPKlY9kDs7LnrZ9lQ.jpeg"/></div></div></figure><p id="ec1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面的结果可以清楚地看出，当对多个类型执行相交时，如果存在相同的属性，并且属性类型是对象类型，则根据相应的规则合并属性。</p><p id="8b06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，除了对象类型，交集操作也可以在函数类型上执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3ee3fc53b925469abfc94d4f828f3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fby2o_l78g3ZaKYUXnD6OA.jpeg"/></div></div></figure><p id="02ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以上代码中的函数调用语句，只有<code class="fe mp mq mr me b">f(1, "bytefer")</code>的调用语句才会出错，其对应的错误信息如下:</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="48f3" class="mi mj iq me b gy mk ml l mm mn">No overload matches this call.<br/>  Overload 1 of 2, '(a: string, b: string): void', gave the following error.<br/>    Argument of type 'number' is not assignable to parameter of type 'string'.<br/>  Overload 2 of 2, '(a: number, b: number): void', gave the following error.<br/>    Argument of type 'string' is not assignable to parameter of type 'number'.ts(2769)</span></pre><p id="7d0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据上述错误消息，我们可以知道TypeScript编译器将使用函数重载功能来实现不同函数类型的交集操作。为了解决上述问题，我们可以定义一个新的函数类型F3，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a59639d9cc5443a88f08dbdb036c7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5qd-Idyvo8eUq7PBraJ4NQ.jpeg"/></div></div></figure><p id="7553" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">掌握了交集类型后，结合上一篇文章中介绍的映射类型:</p><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/using-typescript-mapped-types-like-a-pro-be10aef5511a"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">像专业人员一样使用TypeScript映射类型</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">映射类型—用动画解释。掌握TypeScript映射类型并理解TypeScript的内置…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj kp mv"/></div></div></a></div><p id="3674" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以根据工作需要实现一些自定义的实用程序类型。例如，实现一个<strong class="kt ir"> PartialByKeys </strong>实用程序类型，使对象类型中指定的键值成为可选的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b1aa3657a58e6791fcbc153e6cfcb475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rbpkUDYfl3NbH2jTxWj8A.jpeg"/></div></div></figure><p id="7d36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果要求您实现一个<strong class="kt ir"> RequiredByKeys </strong>实用程序类型，使对象类型中指定的键成为强制键，您知道如何实现吗？如果你知道答案，可以在评论区留言。</p><p id="05af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想学习打字，那么不要错过<strong class="kt ir">掌握打字</strong>系列。在<a class="ae lw" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或<a class="ae lw" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，阅读更多关于TS和JS的内容！</p><h1 id="e620" class="nk mj iq bd nl nm nn no np nq nr ns nt jw nu jx nv jz nw ka nx kc ny kd nz oa bi translated">资源</h1><div class="ms mt gp gr mu"><div role="button" tabindex="0" class="ab bv gv cb fp ob oc bn od kp ex"><div class="oe l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw of og fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l of og fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----a55da6a6a5f7--------------------------------" rel="noopener follow" target="_top">字节优先</a></p></div></div><div class="oj ok gw l"><h2 class="bd ir ua ln fp ub fr fs nb fu fw ip bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi uc au ud ue uf qm ug an eh ei uh ui uj el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----a55da6a6a5f7--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uk l fo"><span class="bd b dl z dk">47 stories</span></div></div></div><div class="ow dh ox fp ab oy fo di"><div class="di oo bv op oq"><div class="dh l"><img alt="" class="dh" src="../Images/8fba4cad7ae795f6abed5234e33e0356.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*l87u8lL_MzD5n4z_"/></div></div><div class="di oo bv or os ot"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di bv ou ov ot"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div></div></div></div><div class="ms mt gp gr mu mv"><a href="https://github.com/microsoft/TypeScript/pull/3622" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">ahejlsberg Pull请求的交叉点类型#3622 microsoft/TypeScript</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">这个PR实现交集类型，是联合类型的逻辑补充。联合类型A | B代表一个实体…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="pc l ng nh ni ne nj kp mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">文档-对象类型</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">TypeScript如何描述JavaScript对象的形状。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">www.typescriptlang.org</p></div></div><div class="ne l"><div class="pd l ng nh ni ne nj kp mv"/></div></div></a></div></div><div class="ab cl pe pf hu pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="ij ik il im in"><p id="36af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="pl">更多内容看</em> <a class="ae lw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="pl">说白了。报名参加我们的</em><strong class="kt ir"><em class="pl"/></strong><a class="ae lw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pl">免费每周简讯</em> </strong> </a> <em class="pl">。关注我们关于</em> <a class="ae lw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="pl">推特</em> </strong> </a>，<a class="ae lw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pl">LinkedIn</em></strong></a><em class="pl">，</em><a class="ae lw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pl">YouTube</em></strong></a><em class="pl"/><a class="ae lw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pl">不和</em> </strong> </a> <em class="pl">。</em></strong></a></p></div></div>    
</body>
</html>