<html>
<head>
<title>How to Get File Extensions with JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript获取文件扩展名？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-get-file-extensions-with-javascript-af4c6536b849?source=collection_archive---------5-----------------------#2022-01-01">https://javascript.plainenglish.io/how-to-get-file-extensions-with-javascript-af4c6536b849?source=collection_archive---------5-----------------------#2022-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dd47283a5cc03d3eec7ced9f49923017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gykOySChSBn8FFpK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Jordan</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="acf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，我们可能想从文件路径中获取文件扩展名。</p><p id="82ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何用JavaScript从路径中获取文件扩展名。</p><h1 id="b516" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">字符串.原型. split</h1><p id="73de" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用JavaScript字符串的<code class="fe me mf mg mh b">split</code>方法，通过获取路径中最后一个点之后的子字符串来获取文件路径的扩展名。</p><p id="aa0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e2ff" class="mq lc iq mh b gy mr ms l mt mu">const ext = '/home/foo/bar.txt'.split('.').pop();<br/>console.log(ext)</span></pre><p id="3df2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用点号调用<code class="fe me mf mg mh b">split</code>来按点号拆分字符串。</p><p id="9348" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们对它调用<code class="fe me mf mg mh b">pop</code>来移除拆分字符串中的最后一项并返回它。</p><p id="005c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe me mf mg mh b">ext</code>就是<code class="fe me mf mg mh b">'txt'</code>。</p><h1 id="cf4a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正则表达式匹配</h1><p id="cfbb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还可以用Regex匹配文件扩展名。</p><p id="5202" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5c04" class="mq lc iq mh b gy mr ms l mt mu">const filename = '/home/foo/bar.txt'<br/>const ext = (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename) : undefined;<br/>console.log(ext)</span></pre><p id="8d89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有带文件路径的<code class="fe me mf mg mh b">filename</code>。</p><p id="2065" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在带有<code class="fe me mf mg mh b">exec</code>的<code class="fe me mf mg mh b">filename</code>字符串中寻找点。</p><p id="5d1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果字符串中有任何点，那么我们检查任何以字符串末尾的点开始的内容。</p><p id="16b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">美元符号表示在字符串的末尾。</p><p id="106c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">^</code>的意思是开始于。</p><p id="0429" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将是文件扩展名。</p><p id="04fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到和以前一样的结果。</p><h1 id="3d57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">String.prototype.substring和String.prototype.lastIndexOf</h1><p id="0ecb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用一个字符串的<code class="fe me mf mg mh b">lastIndexOf</code>方法来获取一个子字符串的最后一个实例的索引。</p><p id="e26e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它与<code class="fe me mf mg mh b">substring</code>方法结合起来提取文件扩展名子串。</p><p id="ea1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5221" class="mq lc iq mh b gy mr ms l mt mu">const filename = '/home/foo/bar.txt'<br/>const ext = filename.substring(filename.lastIndexOf('.') + 1, filename.length) || filename;<br/>console.log(ext)</span></pre><p id="e536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们以<code class="fe me mf mg mh b">filename.lastIndexOf(‘.’) + 1</code>为起始索引调用<code class="fe me mf mg mh b">substring</code>。</p><p id="089f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">filename.length</code>是结束索引。</p><p id="35be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">ext</code>应该与另一个值相同。</p><h1 id="2fe9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">String.prototype.slice和String.prototype.lastIndexOf</h1><p id="f0a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">slice</code>而不是<code class="fe me mf mg mh b">substring</code>从JavaScript字符串中提取子串。</p><p id="5f63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以用它从一个文件路径中获取文件扩展名。</p><p id="572a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用它，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="447b" class="mq lc iq mh b gy mr ms l mt mu">const filename = '/home/foo/bar.txt'<br/>const ext = filename.slice((Math.max(0, filename.lastIndexOf(".")) || Infinity) + 1)<br/>console.log(ext)</span></pre><p id="24d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们找到索引0和由<code class="fe me mf mg mh b">lastIndexOf</code>返回的索引之间的最大值，以获得该点的最后一个索引。</p><p id="36e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">路径可以以点开始，所以索引可能是0。</p><p id="6c0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们加1得到不包括点本身的索引。</p><p id="489e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到和以前一样的结果。</p><h1 id="467d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1324" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用各种JavaScript字符串方法从字符串中提取文件扩展名。</p><p id="569c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mv">plain English . io</em></strong></a><em class="mv">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mv">免费周报</em> </strong> </a> <em class="mv">。在我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mv">社区</em> </strong> </a> <em class="mv">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>