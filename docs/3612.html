<html>
<head>
<title>Derive Constant Time Complexity O(1) Using Asymptotic Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用渐近分析导出常数时间复杂度O(1)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/derive-constant-time-complexity-o-1-using-asymptotic-analysis-e786df20fc7b?source=collection_archive---------6-----------------------#2022-09-11">https://javascript.plainenglish.io/derive-constant-time-complexity-o-1-using-asymptotic-analysis-e786df20fc7b?source=collection_archive---------6-----------------------#2022-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5525" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript算法基础第三部分:<strong class="ak">计算常数时间复杂度</strong>并找出如何导出<strong class="ak"> O(1) </strong></h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/62da37e28a08ea60d27b1622c07d6426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AjpyiHGTMI08UbDO"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="64b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上一篇文章中，我们了解了如何使用<strong class="kv io">渐近分析</strong>来<strong class="kv io">推导算法的时间复杂度/大O </strong>。并且，这种技术似乎是最可靠和最标准的方法<strong class="kv io">来推导任何算法的时间复杂度</strong>。如果你还没有读过上一篇文章，这里有它的链接。</p><p id="cb18" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://medium.com/@code.ceeker/basics-of-javascript-algorithms-part-2-a1b5a3ffcb71" rel="noopener">推导算法的时间复杂度/大O</a></p><p id="2f8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，既然我们知道如何使用<strong class="kv io">渐近分析</strong>来推导算法的<strong class="kv io">大O </strong>，那么让我们使用这些知识来<strong class="kv io">计算恒定时间复杂度</strong>并看看<strong class="kv io"> O(1) </strong>是如何推导出来的。让我们首先定义需要找到<strong class="kv io">最佳算法</strong>的例题，并推导出它的<strong class="kv io">大O </strong>。</p><h2 id="cb68" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">例题</strong></h2><p id="b3e8" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">编写一个函数，将一个数字作为输入，然后将所有数字相加得到该数字。举个例子，</p><p id="7599" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果输入是3，那么我们应该得到结果6(即3+2+1)。同样，如果我们提供的输入为5，那么我们应该得到的结果为15(即5 + 4 + 3 + 2 + 1)。</p><p id="158d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="mn">请注意</em> </strong> <em class="mn">，下面的函数不是一个常数时间算法，如果你想跳过这一部分那么你可以到"</em> <strong class="kv io"> <em class="mn">【导出常数时间复杂度】</em> </strong> <em class="mn">一节中进一步阐述。</em></p><h2 id="3342" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">功能</strong></h2><p id="5b88" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">好了，下面是对上述问题最明显最简单的解决方法。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="feee" class="lp lq in mp b gy mt mu l mv mw"><strong class="mp io">function sum(n) {<br/>  let total = 0;<br/>  for(let index = 1; index &lt;= n; index++) {<br/>    total = total + index;<br/>  }<br/>  return total;<br/>}</strong></span></pre><p id="0a1c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的函数很好地解决了我们定义的问题，而且很容易理解。因此，如果我们将<strong class="kv io"> n </strong>作为<strong class="kv io"> 3 </strong>和<strong class="kv io"> 5 </strong>传递，它将分别产生结果<strong class="kv io"> 6 </strong>和<strong class="kv io"> 15 </strong>，这是预期的输出。现在，让我们找出它的时间复杂度。</p><p id="7f57" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了找到时间复杂度，第一步<strong class="kv io">是定义函数。因此，我们将测试值为<strong class="kv io"> n = 1、n = 3和n = 5 </strong>的函数。根据<strong class="kv io">渐近分析</strong>，我们将<strong class="kv io">遍历我们代码</strong>中的每个表达式，并且<strong class="kv io">找出它将执行</strong>多少次。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/cfb59bdf4df362481bbd5649b9bbe7ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwZw9R433UY5YDXXHZ65ZQ.png"/></div></div></figure><p id="9062" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如我们在上面的输出中看到的，对于给定的<strong class="kv io"> n </strong>值，for循环内部的表达式执行<strong class="kv io"> n </strong>次。</p><p id="b70a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们得到了上述函数的模式。让我们推导出数学方程式。</p><p id="972d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">把时间看成<strong class="kv io"> T </strong>。寻找<strong class="kv io"> n </strong>输入的方程式:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="455a" class="lp lq in mp b gy mt mu l mv mw"><strong class="mp io">T = First Expression + Second Expression + Third Expression + Fourth Expression       // number of time each expression is executed</strong></span><span id="57b4" class="lp lq in mp b gy my mu l mv mw"><strong class="mp io">For n = 1,</strong><br/>T = 1 + 1 + <strong class="mp io">1</strong> + 1</span><span id="d4dc" class="lp lq in mp b gy my mu l mv mw"><strong class="mp io">For n = 3,</strong><br/>T = 1 + 1 + <strong class="mp io">3</strong> + 1</span><span id="00be" class="lp lq in mp b gy my mu l mv mw"><strong class="mp io">For n = 5,</strong><br/>T = 1 + 1 + <strong class="mp io">5</strong> + 1</span><span id="0a97" class="lp lq in mp b gy my mu l mv mw"><strong class="mp io">Therefore, for n = n,</strong><br/>T = 1 + 1 + <strong class="mp io">n</strong> + 1</span></pre><p id="ac1b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将所有常数相加，我们得到:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="3970" class="lp lq in mp b gy mt mu l mv mw"><strong class="mp io">T = n + 3</strong></span></pre><p id="9c5d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们得到了我们的等式，即<strong class="kv io"> T = n + 3 </strong>。我们知道，我们不必考虑方程中的具体值，所以我们可以忽略方程中的常数值。并且，我们得到:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="91ee" class="lp lq in mp b gy mt mu l mv mw">T = <strong class="mp io">n</strong> <br/>  = <strong class="mp io">O(n)</strong></span></pre><p id="7712" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个线性方程。但是等等，我们在寻找常数<strong class="kv io"> O(1) </strong>的时间复杂度，这似乎不是上述解决方案的情况。如果我们看到增长最快的项，在这种情况下是<strong class="kv io"> n </strong>，那么上面的等式似乎是正确的。</p><p id="541b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，作为一名程序员，我们知道一个问题可以有多个解决方案。上述案例是上述问题的解决方案之一。这意味着我们可以找到更多的解决方案，它可以有一个<strong class="kv io">恒定的时间复杂度</strong>或者可能又是一个<strong class="kv io">线性复杂度</strong>或者更糟，一个不同的复杂度<strong class="kv io">既不是线性的也不是恒定的</strong>。所以，让我们找到另一个解决方案。</p><h2 id="d2ea" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">导出常数时间复杂度</strong></h2><p id="0026" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">对于恒定的时间复杂度，<strong class="kv io"> <em class="mn">输入的数量不影响算法花费的时间</em> </strong>。所以在我们的例子中，不管n的值是多少，也就是说，1，3，5，T31。函数中的表达式将总是执行相同的次数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/6d859dbf73377da10e39474f0683b15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/0*osm-DLuUKWSZkqYh"/></div></figure><h2 id="750d" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated"><strong class="ak">功能</strong></h2><p id="23be" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">看起来我们确实有一个不同的解决方案来解决上面的问题，它不使用循环。有一个<strong class="kv io">数学公式</strong>，我们可以应用它来得到所需的结果。数学公式是什么？</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="be55" class="lp lq in mp b gy mt mu l mv mw">For a given <strong class="mp io">n</strong>, <strong class="mp io">F = (n / 2) * (1 + n)</strong></span></pre><p id="12ce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们用n = 3来测试一下。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="e3a1" class="lp lq in mp b gy mt mu l mv mw">F = (3/2) * (1 + 3)<br/>  = (1.5) * (4)<br/>  = <strong class="mp io">6</strong></span></pre><p id="aaac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，是的，我们可以看到上面的公式在解决我们的问题。如果我们把它转换成JavaScript代码。它看起来会像这样。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="5fcd" class="lp lq in mp b gy mt mu l mv mw">function sum(n) {<br/>  <strong class="mp io">return (n/2) * (n+1);</strong><br/>}</span></pre><p id="a021" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们找出表达式执行的次数，以确定代码运行的频率。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/060b2fb591cddcafaa70e516538dc610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8VLgFGkZNSMstmIRwunhA.png"/></div></div></figure><p id="250e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它将运行一次，不管我们作为输入传递什么值，因为这里没有循环。因此，我们可以将函数方程写成:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="66d6" class="lp lq in mp b gy mt mu l mv mw"><strong class="mp io">T = 1 <br/>  = O(1)</strong></span></pre><p id="bebe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们的函数中没有运行<strong class="kv io"> (n) </strong>次的表达式，因此我们没有任何增长最快的术语。因此，我们得到了我们的<strong class="kv io">大O </strong>的函数为<strong class="kv io"> O(1) </strong>。那就是<strong class="kv io">恒定时间复杂度</strong>。这就是我们如何得到一个常数时间。类似地，使用<strong class="kv io">渐近分析</strong>的相同方法，我们可以导出任何算法的<strong class="kv io">时间复杂度。</strong></p><p id="47c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢您的阅读。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="d992" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mn">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mn">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mn">免费周报</em> </strong> </a> <em class="mn">。关注我们关于</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mn">推特</em> </strong> </a>，<a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mn">LinkedIn</em></strong></a><em class="mn">，</em><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mn">YouTube</em></strong></a><em class="mn">，以及</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mn">不和</em> </strong> </a> <em class="mn">。对增长黑客感兴趣？检查出</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mn">电路</em> </strong> </a> <em class="mn">。</em></strong></a></p></div></div>    
</body>
</html>