<html>
<head>
<title>Firebase 9: A Breath of Fresh Air for the AngularFire App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">fire base 9:angular fire应用程序的一股新鲜空气</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/firebase-9-a-breath-of-fresh-air-for-the-angularfire-app-c6d80c1260b2?source=collection_archive---------1-----------------------#2022-08-24">https://javascript.plainenglish.io/firebase-9-a-breath-of-fresh-air-for-the-angularfire-app-c6d80c1260b2?source=collection_archive---------1-----------------------#2022-08-24</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="a576" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">新的树抖动API的迁移指南。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/f2dd9206c049afde700dcbe0bb5e3595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-b2DAxiyn1f_NOw1GVpdg.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">AngularFire migration guide to Firebase 9 Modular API</figcaption></figure><blockquote class="kw kx ky"><p id="abda" class="kz la lb lc b ld le js lf lg lh jv li lj lk ll lm ln lo lp lq lr ls lt lu lv ik bi translated">💡我做这个指南是为了分享我把复杂的Firebase app从Firebase 8升级到Firebase 9模块化API后的个人经验。它将该应用在移动设备上的性能提高了35%，在桌面上的性能提高了10%。</p></blockquote><p id="def2" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">Firebase JS SDK的开发人员做了大量的工作，完全重写了在我们的web应用程序中集成和使用Firebase库的方式。现在它已经变得不可动摇，更小，并允许我们在需要时动态导入Firebase模块。</p><p id="5065" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">多亏了这些变化，我们的网络应用程序变得更加轻量级，运行速度也更快。由AngularFire支持的Angular应用程序也不例外。但是这一次，我们必须处理巨大的重构，以利用树摇摇模块的所有好处。</p><p id="ad24" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">在本教程中，我们将涵盖:</p><ul class=""><li id="4d33" class="lz ma ir lc b ld le lg lh lw mb lx mc ly md lv me mf mg mh bi translated">在兼容模式下从AngularFire 6迁移到Angular 7</li><li id="c63e" class="lz ma ir lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">从兼容模式到模块化的迁移策略</li><li id="de9c" class="lz ma ir lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">认证模块:匿名认证、账户链接、电子邮件和社交登录/注册</li><li id="e031" class="lz ma ir lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">实时数据库:对象、列表、高级查询、在线/离线状态</li><li id="0ea5" class="lz ma ir lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">云Firestore:文档、集合、高级查询</li></ul><p id="ccb0" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">从第一个角度来看，这似乎很难，但是在回顾了几个例子之后，你会发现它是多么的符合逻辑和简单明了。重构将会是一个没有陷阱的单调例行程序。</p><h2 id="c8bf" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">从AngularFire 6迁移到Angular 7</h2><p id="1dc3" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">首先，我们需要确保你使用最新的Firebase和AngularFire。检查<code class="fe nl nm nn no b">package.json</code>，如果包含AngularFire 6或以下，我们需要运行:<code class="fe nl nm nn no b">ng update @angular/fire</code>。还有，一定要用Angular 12+。</p><p id="6bb1" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">现在我们需要替换项目中从<code class="fe nl nm nn no b">@angular/fire/</code>到<code class="fe nl nm nn no b">@angular/fire/compat/</code>以及从<code class="fe nl nm nn no b">firebase/</code>到<code class="fe nl nm nn no b">firebase/compat/</code>的所有导入路径。</p><p id="0b25" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">另外，在<code class="fe nl nm nn no b">app.module.ts</code>中提供Firebase配置。</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="2e78" class="mn mo ir no b gz nt nu l nv nw">providers: [<br/>  {<br/>    provide: FIREBASE_OPTIONS,<br/>    useValue: environment.firebase<br/>  }<br/>]</span></pre><p id="0c2f" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">在这一步，我们的应用程序应该像以前一样工作。我们可以合并这些更改，甚至在这种模式下部署到prod，因为它允许我们在切换到Firebase 9模块化导入时，缓慢、部分、逐步地迁移，而不会破坏整个应用程序。</p><h1 id="a949" class="nx mo ir bd mp ny nz oa ms ob oc od mv jx oe jy my ka of kb nb kd og ke ne oh bi translated">模块导入</h1><p id="9f95" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">首先，我们要做的是导入AngularFire模块:</p><p id="a338" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它是怎样的:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="7851" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="aeab" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">这是一个最简单的例子。提供这种回调的好处并不明显。但是这是我们可以控制应该装载什么的地方。</p><p id="2cd8" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">例如，你还记得我之前提到的为移动设备加载的<code class="fe nl nm nn no b">iframe.js</code>吗？它符合移动社交认证的要求。但是我们可以控制何时加载这个解析器。所以我们可以将它从app.module.ts中移除，并在调用<code class="fe nl nm nn no b">signInWithPopup()</code>时将其作为参数传递。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk"><em class="ok">By the way, we can also do better ways to store authentication data later.</em></figcaption></figure><p id="f553" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">然后我们需要在调用社交登录时提供一个解析器。这里有一个例子:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><blockquote class="kw kx ky"><p id="dd30" class="kz la lb lc b ld le js lf lg lh jv li lj lk ll lm ln lo lp lq lr ls lt lu lv ik bi translated">注意，目前由于一些AngularFire问题，我们需要从firebase/auth导入signInWithPopup和browserPopupRedirectResolver，而不是<code class="fe nl nm nn no b">@angular/fire/auth</code>。</p></blockquote><h1 id="e8db" class="nx mo ir bd mp ny nz oa ms ob oc od mv jx oe jy my ka of kb nb kd og ke ne oh bi translated">证明</h1><p id="35f4" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">这是你需要改变的第一件事，因为在兼容模式下，<strong class="lc is"> Firebase会在应用加载期间在移动设备上加载</strong> <code class="fe nl nm nn no b">iframe.js</code>。这将大大降低你在PageSpeed Insights上的移动设备性能得分，甚至可能影响你在谷歌搜索结果中的位置。在移动设备上使用social auth需要这个iframe.js。</p><p id="721b" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">但是不要担心，在迁移到Firebase 9之后，性能会比以前更好，因为只有当用户单击登录按钮时，我们才能加载我们需要的所有内容。</p><p id="e453" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">现在我们需要重写使用AgnularFire auth方法的逻辑。</p><p id="c28f" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">情况如何:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="2505" class="mn mo ir no b gz nt nu l nv nw">import { AngularFireAuth } from '@angular/fire/compat/auth';</span><span id="3e9c" class="mn mo ir no b gz ol nu l nv nw">constructor(public afAuth: AngularFireAuth) {}</span></pre><p id="0f9c" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="3145" class="mn mo ir no b gz nt nu l nv nw">import {Auth} from '@angular/fire/auth';</span><span id="cca1" class="mn mo ir no b gz ol nu l nv nw">constructor(@Optional() private auth: Auth) {}</span></pre><p id="6fdf" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">但在更早的时候，它是AngularFire中所有Auth方法的类实例。现在，这是一个链接到Firebase应用程序的Auth模块实例。没有任何方法，它不会加载你不用的东西。</p><p id="8fb8" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">对于新的方法，我们需要单独导入所需的方法。</p><h2 id="d95b" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">用电子邮件登录</h2><p id="a182" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">情况如何:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="6c1a" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="d9db" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">这是主要的想法。我们导入我们需要的功能，仅此而已。</p><h2 id="9c74" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">登录社交网络</h2><p id="8532" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">情况如何:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="8197" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><blockquote class="kw kx ky"><p id="0469" class="kz la lb lc b ld le js lf lg lh jv li lj lk ll lm ln lo lp lq lr ls lt lu lv ik bi translated">我非常推荐在调用signInWithPopup时提供browserPopupRedirectResolver，而不是在主线程的app.module.ts中加载。</p></blockquote><h2 id="da2b" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">匿名登录</h2><p id="999f" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">就更简单了。它不需要任何重定向解析器。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><h2 id="02ee" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">将现有个人资料与社交网站链接</h2><p id="1bc0" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">由于重定向解析器的问题(我希望是暂时的)，我们需要从firebase而不是AngularFire导入它。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><blockquote class="kw kx ky"><p id="20da" class="kz la lb lc b ld le js lf lg lh jv li lj lk ll lm ln lo lp lq lr ls lt lu lv ik bi translated">提醒:如果在app.module.ts中简单提供了auth模块而没有定制<code class="fe nl nm nn no b">provideAuth(() =&gt; getAuth())</code>，则不需要提供browserPopupRedirectResolver。</p></blockquote><h2 id="0191" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">获取用户配置文件</h2><p id="a43e" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">情况如何:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="d34e" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="f6bf" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">在授权迁移之后，您可以发现显著的性能改进，尤其是对于移动设备。</p><h1 id="264c" class="nx mo ir bd mp ny nz oa ms ob oc od mv jx oe jy my ka of kb nb kd og ke ne oh bi translated">实时数据库</h1><p id="ba76" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">对于数据库，变化是相同的。之前，我们在数据库实例中有所有的方法。现在，我们应该导入我们需要在应用程序中使用的方法。</p><p id="ca9a" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">情况如何:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="4a20" class="mn mo ir no b gz nt nu l nv nw">import { AngularFireDatabase } from '@angular/fire/compat/database';</span><span id="818a" class="mn mo ir no b gz ol nu l nv nw">constructor(public db: AngularFireDatabase) {}</span></pre><p id="d80f" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="b956" class="mn mo ir no b gz nt nu l nv nw">import { Database } from '@angular/fire/database';</span><span id="30b4" class="mn mo ir no b gz ol nu l nv nw">constructor(public db: Database) {}</span></pre><p id="f1f9" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">和Auth实例一样，数据库实例不包含任何查询数据的方法。我们需要分别导入它们。</p><h2 id="9674" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">实时数据库获取对象</h2><p id="79f0" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">它是怎样的:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="5d18" class="mn mo ir no b gz nt nu l nv nw">this.db.object(`path/to/your/object`)<br/>    .valueChanges()<br/>    .subscribe((data) =&gt; {<br/>      // your code<br/>    });</span></pre><p id="b2c4" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="7424" class="mn mo ir no b gz nt nu l nv nw">import { Database, ref, objectVal } from '@angular/fire/database';</span><span id="171b" class="mn mo ir no b gz ol nu l nv nw">objectVal(ref(this.db, `path/to/your/object`))<br/>  .subscribe( data =&gt; {<br/>    // Your code<br/>  });</span></pre><p id="0c3e" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">如您所见，我们现在需要构建对我们想要获取或编辑的数据库对象的引用。更多的例子在下面。</p><h2 id="efd0" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">实时数据库获取列表</h2><p id="22a2" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">它是怎样的:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="8795" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">我用了<code class="fe nl nm nn no b">snapshotChanges</code>而不是<code class="fe nl nm nn no b">valueChanges</code>不是弄错了。早些时候，为了获得能够编辑每个项目的对象列表，我们必须使用<code class="fe nl nm nn no b">snapshotChages</code>来获得带有键的快照。然后，我们总是必须将快照映射到带有键的项目数组，就像当前的例子一样。</p><p id="a923" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">有了新的API，它变成了一个内置特性！</p><p id="ea4e" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><blockquote class="kw kx ky"><p id="8ac2" class="kz la lb lc b ld le js lf lg lh jv li lj lk ll lm ln lo lp lq lr ls lt lu lv ik bi translated">新的论点<code class="fe nl nm nn no b">{ keyField: ‘key’ }</code>成功了！您可以定义将包含对象键的属性。相同的配置可以用于<code class="fe nl nm nn no b">objectVal()</code>。</p></blockquote><h2 id="3c2f" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">实时数据库查询列表</h2><p id="baa3" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">如你所见，<code class="fe nl nm nn no b">objectVal</code>和<code class="fe nl nm nn no b">listVal</code>可以接受<code class="fe nl nm nn no b">ref(this.db, `path/to/your/list`)</code>作为第一个参数，但是如何对数据进行过滤或排序呢？</p><p id="1636" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">还有一个功能——查询。下面是我们如何使用它。</p><p id="6655" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">以前是什么样子:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="36cf" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="b7ab" class="mn mo ir no b gz nt nu l nv nw">const listRef = ref(this.db, `path/to/your/list`);<br/>const qry = query(listRef, orderByChild('date'));</span><span id="b746" class="mn mo ir no b gz ol nu l nv nw">listVal(qry, { keyField: 'key' }).subscribe((onlineList) =&gt; {});</span></pre><p id="af9d" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">query()可以接受多个参数，因此我们可以进行更高级的查询:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="97ff" class="mn mo ir no b gz nt nu l nv nw">const listRef = ref(this.db, `chats/${this.chatId}`);<br/>const qry = query(listRef, orderByChild('date'), limitToLast(30));</span><span id="1cf0" class="mn mo ir no b gz ol nu l nv nw">listVal&lt;IMessage&gt;(qry).subscribe((chatLog) =&gt; {<br/>  // Your code<br/>});</span></pre><h2 id="38d5" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">实时数据库在线/离线状态</h2><p id="8bdb" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">为了获得用户的在线状态，我们可以订阅一个. info/connected对象。</p><p id="0c62" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它是怎样的:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="fe7d" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="4778" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">但是当connected为false时，表示用户已经离线。所以我们不能改变用户的状态。为了处理这个问题，我们使用了<code class="fe nl nm nn no b">onDisconnect()</code>函数。</p><p id="d838" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它是怎样的:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="a8f5" class="mn mo ir no b gz nt nu l nv nw">const ref = this.db.object(`online/${newUser.key}`);<br/>ref.query.ref.onDisconnect().remove();</span></pre><p id="8a2d" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="b36d" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">我只是想说明我们之前使用的所有高级API都是可用的，但是应该单独导入。</p><h1 id="3e42" class="nx mo ir bd mp ny nz oa ms ob oc od mv jx oe jy my ka of kb nb kd og ke ne oh bi translated">Firebase Cloud Firestore</h1><p id="6a43" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">这里的变化与实时数据库相同。首先，这里是对app.module.ts的更改。</p><p id="842a" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">情况如何:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="1773" class="mn mo ir no b gz nt nu l nv nw">@NgModule({<br/>  imports: [<br/>    AngularFireModule.initializeApp(environment.firebase),<br/>    AngularFirestoreModule.enablePersistence(),<br/>  ]<br/>})</span></pre><p id="3d6a" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><pre class="kh ki kj kk gu np no nq nr aw ns bi"><span id="e580" class="mn mo ir no b gz nt nu l nv nw">@NgModule({<br/>    imports: [<br/>        ...<br/>      provideFirebaseApp(() =&gt; initializeApp(environment.firebase)),<br/>        provideFirestore(() =&gt; getFirestore()),<br/>    ],<br/>})</span></pre><p id="5d83" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">然后在组件中，我们对所有方法使用单个实例，现在类似于实时数据库，我们使用带有连接细节和单独导入功能的Firestore实例。</p><p id="f709" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">情况如何:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="fc31" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">它如何变成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="e8e1" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">要获得带有文档键和元数据的快照，有一个方法<code class="fe nl nm nn no b">onSnapshot</code>。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oi oj l"/></div></figure><p id="f025" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">动态加载Firestore模块是可能的，但在我的情况下，我在角度特征模块中加载它，对我来说，这是如何加载它的最有角度的方式。但是这里有一个如何实现的官方例子。</p></div><div class="ab cl on oo hv op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ik il im in io"><h2 id="52d6" class="mn mo ir bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">摘要</h2><p id="2ca0" class="pw-post-body-paragraph kz la ir lc b ld ng js lf lg nh jv li lw ni ll lm lx nj lp lq ly nk lt lu lv ik bi translated">您可以通过project <code class="fe nl nm nn no b">/compat/</code> word进行搜索，以检查迁移是否完全完成。不应该提及旧的进口货。</p><p id="a3f3" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">迁移之后，我的Angular项目开始获得比移动版高35%的PageSpeed insight分数。</p></div><div class="ab cl on oo hv op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ik il im in io"><p id="24cd" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated">嗨！非常感谢您阅读我的文章！如果你不是一个媒体成员，想要支持我，你可以通过<a class="ae om" href="https://golosay.medium.com/membership" rel="noopener">点击这个链接</a>来支持我。中型会员将允许你阅读我的帖子和其他人的帖子。再次感谢大家的支持！</p></div><div class="ab cl on oo hv op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ik il im in io"><p id="07ab" class="pw-post-body-paragraph kz la ir lc b ld le js lf lg lh jv li lw lk ll lm lx lo lp lq ly ls lt lu lv ik bi translated"><em class="lb">更多内容尽在</em> <a class="ae om" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc is"> <em class="lb">说白了. io </em> </strong> </a> <em class="lb">。报名参加我们的</em> <a class="ae om" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc is"> <em class="lb">免费周报</em> </strong> </a> <em class="lb">。关注我们关于</em> <a class="ae om" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lc is"> <em class="lb">推特</em> </strong> </a>，<a class="ae om" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lc is"><em class="lb">LinkedIn</em></strong></a><em class="lb">，</em><a class="ae om" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lc is"><em class="lb">YouTube</em></strong></a><em class="lb">，</em> <a class="ae om" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lc is"> <em class="lb">不和</em> </strong> </a> <em class="lb">。</em></p></div></div>    
</body>
</html>