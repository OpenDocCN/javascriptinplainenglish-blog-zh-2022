<html>
<head>
<title>What Will Happen If We Call React.useState 10,000 Times?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果我们调用React.useState一万次会发生什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-will-happen-if-we-call-react-usestate-10000-times-cfb82b6de179?source=collection_archive---------6-----------------------#2022-08-13">https://javascript.plainenglish.io/what-will-happen-if-we-call-react-usestate-10000-times-cfb82b6de179?source=collection_archive---------6-----------------------#2022-08-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d071ae1adc6d7530ebff4f2c4b9db4e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AL72kqWUYmrg_5-c"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3d72" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="b32f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">今天的文章就是为了回答这个问题:<strong class="la io"> <em class="lw">如果我们调用React.useState 10000次会发生什么？</em>T13】</strong></p><p id="10aa" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">简单来说，React是一个JavaScript库，可以帮助您创建SPA应用程序。但是有一个小问题，如果我们调用<code class="fe mc md me mf b">useState</code> 10000次或1次以上，React会重新呈现吗？</p><p id="e1ba" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">在本文中，我们还将学习React的两个最重要的深入概念。</p><h2 id="fe57" class="mg kb in bd kc mh mi dn kg mj mk dp kk lj ml mm ko ln mn mo ks lr mp mq kw mr bi translated">让我们测试一下行为</h2><p id="a827" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">为了测试这种行为，我创建了一个只有一个状态<code class="fe mc md me mf b">name</code>的小React应用程序，单击一个按钮，我将更新<code class="fe mc md me mf b">name</code>状态10000次。以下是App.js:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/7d889cddeb64140d178008e0fb3b0610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*R-3DpI5QSN2G8oM6KBMC7g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">App.js</figcaption></figure><p id="8c68" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">现在，让我们转到浏览器，看看它将如何运行:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/86ebcd4543fadfc85b7283aaad87bdae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F66l8GU77UErpLJ9Hxkc7Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">First-time load app</figcaption></figure><p id="bbaa" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">当应用程序第一次加载时，它将打印为空，因为默认状态没有变化，我们将默认状态保持为空字符串。接下来，让我们做一个点击动作，看看它会重新渲染组件多少次:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/c1de9ab97b8d7fa3d3ea9f33428e0847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akyul-YBMGj417MHOtZKuA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">after the click</figcaption></figure><p id="844d" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">很奇怪，对吧？如果我们让循环运行4次，为什么只有一次重新渲染？我们试一万次，确认一下。咔嚓一声之后:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/1df2041dfdfb3baa03ae0c546febaac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSoctrIWSCKIEEiFOPcncQ.png"/></div></div></figure><p id="771f" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">同样的输出。重新渲染只发生一次，但是为什么呢？所以有两个原因阻止了重新渲染。</p><h1 id="7aac" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">为什么禁止重新渲染？</h1><p id="76e3" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">阻止重新渲染有两个原因，它们都满足阻止的条件。</p><h2 id="9b0f" class="mg kb in bd kc mh mi dn kg mj mk dp kk lj ml mm ko ln mn mo ks lr mp mq kw mr bi translated">对象. is检查</h2><p id="3518" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们都知道React与虚拟DOM一起工作，每当React感觉到组件中有有效的更新，它就会触发重新渲染。但是那种感觉是什么？一种这样的“感觉”是<code class="fe mc md me mf b">Object.is()</code>检查。点击阅读更多关于<code class="fe mc md me mf b">Object.is()</code>的内容。但事情是这样的:</p><pre class="mt mu mv mw gt na mf nb nc aw nd bi"><span id="db65" class="mg kb in mf b gy ne nf l ng nh">Object.is(5, 5); // true       <br/>Object.is(5, 6); // false<br/>Object.is(null, null); // true<br/>Object.is([], []);  // false</span></pre><p id="e29a" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">对于所有原始数据类型，如果里面的数据有效，<code class="fe mc md me mf b">Object.is()</code>检查返回<code class="fe mc md me mf b">true</code>；而对于非原语数据类型，如果它们共享同一个内存位置，那么返回值为<code class="fe mc md me mf b">true</code>，否则为false。现在，React正在对每个导致重新渲染的变量使用这个<code class="fe mc md me mf b">Object.is()</code>检查。例如，如果我们多次使用同一个值，那么重新渲染也只会发生</p><pre class="mt mu mv mw gt na mf nb nc aw nd bi"><span id="36c7" class="mg kb in mf b gy ne nf l ng nh">if(Object.is(prevState, newState))// don't do anything<br/>else // re-render</span><span id="b4ea" class="mg kb in mf b gy ni nf l ng nh">setName('test')<br/>setName('test')<br/>setName('test')</span><span id="d8b8" class="mg kb in mf b gy ni nf l ng nh">// only runs for one time which is first</span></pre><p id="d04a" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">但是在我们之前的例子中，我们用索引更新了值，所以<code class="fe mc md me mf b">Object.is()</code>检查应该会失败，对吗？</p><p id="b826" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">是的，它会失败，但是还有一个检查阻止了重新渲染。</p><h2 id="5826" class="mg kb in bd kc mh mi dn kg mj mk dp kk lj ml mm ko ln mn mo ks lr mp mq kw mr bi translated">同时处理多条语句</h2><p id="d763" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">比方说，如果React是一个人，你要求那个人改变主工厂的一些东西，当他回来说他改变了它，然后你再次要求同样的东西再次改变。</p><p id="bb44" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">这太搞笑了，一个正常人会给你当头一棒。相反，你可以做一些调查，然后把最后的修改告诉那个人。对那个人来说，这也更容易理解。</p><p id="3e17" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">以同样的方式，React在实际触发重新呈现之前等待并查看下一条语句是否相同。举个例子，</p><pre class="mt mu mv mw gt na mf nb nc aw nd bi"><span id="d29a" class="mg kb in mf b gy ne nf l ng nh">setName('test')<br/>setName('test1')<br/>setName('test2')</span><span id="3dd0" class="mg kb in mf b gy ni nf l ng nh">// re-render only one time</span></pre><p id="a9eb" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">虽然有3个具有不同值的语句，但是它们被保存在相同的队列中以重新呈现，并且由于它们的顺序遵循相同的状态，所以它将只更新DOM一次。</p><h2 id="2121" class="mg kb in bd kc mh mi dn kg mj mk dp kk lj ml mm ko ln mn mo ks lr mp mq kw mr bi translated">结论</h2><p id="fb8a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在这篇文章中，我们学到了两个关于React如何防止重新渲染的新东西。这些是React采取的优化应用性能的对策。在我们上面的例子中，只有发送原因阻止了重新渲染，但是了解其他概念也是很好的。</p><p id="e66a" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">我希望你今天知道了一些有趣的事情。你可以在这里找到源代码<a class="ae jz" href="https://github.com/Piyush-Use-Personal/react-10000-times" rel="noopener ugc nofollow" target="_blank">。编码快乐！</a></p><p id="fd3b" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated"><em class="lw">更多内容看</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="lw">说白了。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="lw">免费周报</em> </strong> </a> <em class="lw">。关注我们关于</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="la io"> <em class="lw">推特</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="lw">LinkedIn</em></strong></a><em class="lw"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="lw">YouTube</em></strong></a><em class="lw"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="lw">不和</em> </strong> </a> <em class="lw">。</em></strong></a></p></div></div>    
</body>
</html>