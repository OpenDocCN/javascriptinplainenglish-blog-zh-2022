<html>
<head>
<title>TypeScript Practical Tips: Nominal Typing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿实用技巧:名义打字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-practical-tips-nominal-typing-f15ee9723851?source=collection_archive---------2-----------------------#2022-12-14">https://javascript.plainenglish.io/typescript-practical-tips-nominal-typing-f15ee9723851?source=collection_archive---------2-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2fab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">名义打字</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e016cd489a9c76e8e543a8c9aac09bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-EpZJ1JzfHPYkn7Ujxzrg.jpeg"/></div></div></figure><h2 id="e10a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是名义类型</h2><p id="dbca" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">名义类型化:将“名义”附加到类型上，以防止结构类型在某些情况下由于类型结构的相似性而被误用。假设以下代码可用:</p><pre class="kg kh ki kj gt mg mh mi bn mj mk bi"><span id="dec3" class="ml ks iq mh b be mm mn l mo mp">interface Vector2D { x: number, y: number };<br/>interface Vector3D { x: number, y: number, z: number };<br/>function calc(vector: Vector2D): void;<br/><br/>const vector: Vector3D = { x: 1, y: 1, z: 1}<br/><br/>calc(vector) // Does not throw errors</span></pre><p id="63f3" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">看起来<code class="fe mv mw mx mh b">calc()</code>函数应该只传入<code class="fe mv mw mx mh b">Vector2D </code>类型，但是它实际上也可以传入<code class="fe mv mw mx mh b">Vector3D </code>，因为<code class="fe mv mw mx mh b">Vector3D </code>本质上是<code class="fe mv mw mx mh b">Vector2D</code>的子集。对于<code class="fe mv mw mx mh b">calc()</code>函数，只要传入的向量变量同时具有x和y属性，就可以对其类型进行检查。</p><p id="85e8" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">这个特性在TS中被称为结构化类型，通常有助于编码过程，但在极端情况下，它可能不符合我们的期望。</p><p id="1f32" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">如果函数被严格限制为<code class="fe mv mw mx mh b">Vector2D </code>类型而不是<code class="fe mv mw mx mh b">Vector3D </code>类型，那么类型实现可以使用名义类型，通过给它们添加一个唯一的标识符来区分原始类型。</p><pre class="kg kh ki kj gt mg mh mi bn mj mk bi"><span id="7db4" class="ml ks iq mh b be mm mn l mo mp">interface Vector2D { x: number, y: number, __type: '2d' };<br/>interface Vector3D { x: number, y: number, z: number, __type: '3d' };<br/>function calc(vector: Vector2D): void;</span></pre><p id="82b8" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">对于接口，我们可以直接给它们添加标志属性，但是如何处理基本类型呢？答案是使用交叉类型，例如</p><pre class="kg kh ki kj gt mg mh mi bn mj mk bi"><span id="47c1" class="ml ks iq mh b be mm mn l mo mp">type Food = string &amp;amp; { _type: 'food' };<br/>type Money = number &amp;amp; { _type: 'money' }</span></pre><p id="a4a6" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">你可能对最终类型有所怀疑，但经过这种处理后，它们仍然是原始类型。因为事实上原语类型最终会被解析成它们的WrapperType对应物，比如string → String，number → Number，就像在JS中一样。这意味着您可以将它们作为基本类型使用，如下所示。</p><pre class="kg kh ki kj gt mg mh mi bn mj mk bi"><span id="0c77" class="ml ks iq mh b be mm mn l mo mp">const money = 100 as Money;<br/>const bill = money * 1; // bill is number type</span></pre><p id="407d" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">虽然这看起来不优雅，甚至很麻烦，但至少在某些情况下是类型安全的。如果您的类型系统中有许多基类型单元，这将非常有用。</p><h2 id="ac2f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">扩展的应用</h2><p id="97e0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">这种类型可以用作基元类型，但本质上不是纯粹的基元类型。我们可以利用这个特性来编写一些非常有趣和有用的类型。</p><p id="11c1" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">例如，在文字枚举的情况下，我们可以限制预定义的值，同时用基于基元类型的名义类型来保证它们，从而允许我们的类型有足够的自由，并且仍然享受TypeScript的类型提示，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/0c9fc26cf9225a1b38b01d9a772c6684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOyVitQFDxIWQMQey4BFXw.png"/></div></div></figure><p id="e9f2" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">正如您所看到的，CustomLiteral不仅享受Literal literals的类型提示，还可以在枚举的限制之外使用自定义字符串。如果我们直接跨越文字和原始类型字符串。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/7725c1810f3d6f1618e73e0b2844c974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxUxu0QLDi_6tptMJGqx9Q.png"/></div></div></figure><p id="f83f" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">联合类型的机制本质上是合并，合并得到的最终类型会是更一般的字符串，这反而让我们失去了文字类型的派生。要达到这个效果，我们需要给字符串类型一个“名字”，让它区别于常见的原语类型，不那么“通用”，这样在合并时就不会完全被字符串类型接管。附打字稿游乐场。</p><h2 id="8103" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Vue中的应用</h2><p id="b57b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">其实在Vue3源代码中有很多名词性类型化的例子，比如<code class="fe mv mw mx mh b">VNode</code>、<code class="fe mv mw mx mh b">Teleport</code>、<code class="fe mv mw mx mh b">KeepAlive</code>、<code class="fe mv mw mx mh b">Fragment</code>等。这些内置组件在它们的定义中有一个标志变量来区分它们。下图显示了<code class="fe mv mw mx mh b">KeepAlive </code>组件的声明，更多声明可以在官方知识库中找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/f95cb33a6ea386a9a3878cd029559c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ip0ukb_5p3O03GdwodbJg.png"/></div></div></figure><p id="45db" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">如果类型声明的位置在一个函数入口上，通常使用一个唯一的符号作为键来构造一个名义类型，以防止与用户定义的属性发生冲突</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/00ffb954a83b3beda54b683a56b1ff46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxeFcdt6LGwM4DC4muj8Kg.png"/></div></div></figure><p id="974d" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated">以上是TypeScript实用技巧名义打字的详细讲解。如果你对我的文章感兴趣，请跟我来。</p><p id="8f4d" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated"><em class="nc">更多内容看</em> <a class="ae nd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="nc">说白了就是io </em> </strong> </a> <em class="nc">。报名参加我们的</em> <a class="ae nd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。关注我们关于</em><a class="ae nd" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="nc">Twitter</em></strong></a>，<a class="ae nd" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="nc">LinkedIn</em></strong></a><em class="nc">，</em><a class="ae nd" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="nc">YouTube</em></strong></a><em class="nc">，以及</em> <a class="ae nd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="nc">不和</em> </strong> </a> <strong class="lp ir"> <em class="nc">。</em> </strong></p><p id="9766" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv la ms lx ly le mt ma mb li mu md me mf ij bi translated"><strong class="lp ir"> <em class="nc">对缩放您的软件启动感兴趣</em> </strong> <em class="nc">？检查出</em> <a class="ae nd" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="nc">电路</em> </strong> </a> <em class="nc">。</em></p></div></div>    
</body>
</html>