<html>
<head>
<title>28 JavaScript Skills a Qualified Intermediate Front-End Engineer Needs to Master</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一名合格的中级前端工程师需要掌握的28项JavaScript技能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/28-javascript-skills-a-qualified-intermediate-front-end-engineer-needs-to-master-ffed93de3f38?source=collection_archive---------0-----------------------#2022-02-25">https://javascript.plainenglish.io/28-javascript-skills-a-qualified-intermediate-front-end-engineer-needs-to-master-ffed93de3f38?source=collection_archive---------0-----------------------#2022-02-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e729a66fa85c08c1cb229d45ada906c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfTt8MO6ekgIXrean_AWgw.png"/></div></div></figure><p id="fbb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望这对你的工作和面试有所帮助。</p><h1 id="f9c4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">序</h1><p id="fbd2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">文中代码对应的详细注释和具体使用方法都放在我的GitHub上，源代码在底部可以找到。</p><h1 id="b0fc" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">1.确定对象的数据类型</h1><p id="863a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">使用Object.prototype.toString.call()配合闭包，通过传入不同的判断类型返回不同的判断函数。一行代码简洁、优雅、灵活(注意传入type参数时首字母大写)。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cc3378579126c1365ffe61a3b3498a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77a-glIxbdJB2IZJYx6r-A.png"/></div></div></figure><p id="e3ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">不建议使用该函数检测可能生成封装类型的基本数据类型，因为调用总是会对第一个参数进行装箱操作，导致基本类型和封装类型无法区分。</strong></p><h1 id="a62d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">2.循环来实现数组映射方法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/dd65d7d6920460efe0a0346f22a5e255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qWCPbKg7oVqKgD1WFJEVA.png"/></div></div></figure><p id="df84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用方法:将selfMap注入Array.prototype(下面数组的迭代方法也是如此)。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1c954a0c80e1ceb259ddd182d23eaffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-KdHy0IltllJAfVp1GOnA.png"/></div></div></figure><p id="e74e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">值得一提的是，map的第二个参数就是第一个参数回调中的这个点。如果第一个参数是一个箭头函数，那么设置第二个这将是无效的，因为箭头函数的词法绑定。</p><p id="1762" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个是稀疏阵列的处理。HasOwnProperty用于判断数组中是否存在当前下标的元素(感谢评论区的朋友)。</p><h1 id="d894" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">3.使用reduce实现数组映射方法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/54f3733aee5650f783968ed381bc62ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eY7Prjv2A9oZow1BuevxnA.png"/></div></div></figure><h1 id="2320" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.循环来实现数组筛选方法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d801b3962bc8da161edb50c597ed8de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HY6Tg9tbKqQAY5HEpFMiNg.png"/></div></div></figure><h1 id="68c5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">5.使用reduce实现数组筛选方法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/35fabd607546aa4b4511c6c82d02b67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8K-Y5dp8kcGUYhf7I5dacw.png"/></div></div></figure><h1 id="fbdd" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">6.循环来实现数组的一些方法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/25bfb21d5a9004a5011c6aa0426c2863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71zDp59mGUs90Iz8En1Liw.png"/></div></div></figure><p id="0592" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果执行某个方法的数组是空数组，那么它总是返回false，如果另一个数组的每个方法中的数组都是空数组，那么它总是返回true。</p><h1 id="202b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">7.循环来实现数组的reduce方法</h1><p id="4fcc" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">因为可能存在稀疏数组关系，所以reduce需要确保跳过稀疏元素，并遍历正确的元素和下标。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/22217ee5b7c9b1823027c2d1200fd62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JeR8OHOJ6g2nl5K_e8v0A.png"/></div></div></figure><h1 id="0abe" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">8.使用reduce实现数组的flat方法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e0bd2ead22cd9b1d6c8c683a560ca43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CrHS1OlEjIWRxmn3DkIbQ.png"/></div></div></figure><p id="6ab4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为selfFlat依赖于这个指向，所以在减少遍历的时候需要指定这个指向selfFlat，否则默认指向一个窗口，就会出错。</p><p id="ac0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原理是通过归约来遍历数组。当数组的一个元素还是数组时，通过ES6 spread运算符进行降维(ES5可以使用concat方法)，这个数组元素内部也可能有嵌套数组，所以需要递归调用selfFlat。</p><p id="bd21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同时，原生flat方法支持一个深度参数来表示降维的深度。默认值为1，将数组的维度减少一层。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3779881d416f07d82dedd6f5d24a92e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtSNPpcVBSy_SoTdOmJ87A.png"/></div></div></figure><p id="6d0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">传入Infinity将把传入的数组变成一维数组。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ee19379821cb9b0acb751d0ba3d1e6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-iDC_Av_mLtKQXfou27TQ.png"/></div></div></figure><p id="4b5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原则是每次递归深度参数减1。如果深度参数为0，则直接返回原始数组。</p><h1 id="4dfb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">9.实现ES6类语法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a6864600d2163f6fe10886cf4dbccf2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZ08BCO2lnp5UEm3aahOrw.png"/></div></div></figure><p id="fd43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ES6类基于寄生成分继承，是目前最理想的继承方式。通过Object.create()方法创建一个空对象，从Object.create()方法的参数中继承空对象，然后让子类(子类型)如果原型对象等于这个空对象，则可以实现子类实例的原型等于这个空对象，这个空对象的原型等于超类型原型对象(superType.prototype)的继承关系。</p><p id="b3bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Object.create()支持第二个参数，该参数用于为生成的空对象定义属性和属性描述符/访问器描述符。我们可以为这个空对象定义一个构造函数属性，更符合默认的继承行为，不可枚举。可枚举的内部属性(enumerable: false)。</p><p id="ff7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ES6类允许子类继承父类的静态方法和静态属性，而普通的寄生组合继承只能实现实例间的继承。对于类之间的继承，需要定义额外的方法。这里使用Object.setPrototypeOf()将超类型设置为子类型的原型，以便能够从父类继承静态方法和静态属性。</p><h1 id="a871" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">10.函数currying</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e2880a18bc70938a9a5c599a975d372c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iX6oYeIvfxCYOg3G1ZpmhQ.png"/></div></div></figure><p id="fab4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说明:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/08ba42514f466c2325edbf515a682caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJhLibmZ1Rm7278P7c4WJg.png"/></div></div></figure><p id="4bad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Currying是函数式编程中的一项重要技术，这项技术将一个接受多个参数的函数转换成一系列接受一个参数的函数。</p><p id="2fe3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数式编程的另一个重要函数compose可以组合函数，组合后的函数只接受一个参数，所以如果需要接受多个函数，需要使用compose进行函数组合，就需要使用currying对待组合的函数进行部分求值，使其始终只接受一个参数。</p><p id="4b9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看另一个例子:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d57d64c6d1b10a68e297d11b37021d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d69PpWo8q523RXUPcpqKsA.png"/></div></div></figure><h1 id="d03f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">11.函数currying(支持占位符)</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/4f2d99b9d0c9269b03489f7f798b0f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVBcOSouBphD5DXfvHQTVg.png"/></div></div></figure><p id="f2ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说明:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/09ad1ff2a14af14f207a2d6bac86f46c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OLP07chNCn1LCWrskXF2yg.png"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ce5e277807ec6c9dab0af658edd106b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59m1xTVZCm0GI1ba8BOn7Q.png"/></div></div></figure><p id="23b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用占位符可以使奉承更加灵活。这个想法是用每一轮的传入参数填充前一轮的占位符。如果当前轮次的参数包含占位符，它们将被放入内部存储的数组中。最终，当前回合的元素不会填充当前回合参数的占位符，只会填充之前传入的占位符。</p><h1 id="326d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">12.部分功能</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7d5f01c478bf17a4d6dd0d233be749c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGE51egyyurV9d0GRjdMlw.png"/></div></div></figure><p id="4301" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说明:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/572e8c2e23d33fa889f0c427d31f1dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoCh0pHvAerRoi2ti6iiJQ.png"/></div></div></figure><p id="635c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">部分函数和currying的概念是相似的。我个人认为两者的区别在于，partial function会固定你传入的几个参数，然后一次性接受剩下的参数，而function currying会根据你传入函数的参数不断返回，直到参数个数满足函数的参数个数才被curry。</p><p id="058b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Function.prototype.bind函数是部分函数的典型代表。它接受的第二个参数以预先添加到绑定函数的参数列表中的参数开始。与bind不同，上述函数还支持记账位字符。</p><h1 id="15cf" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">13.斐波那契数列及其优化</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/a09bff1223a0726597e02331225ab809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1MdjZSwkPI_J9R6fCQO4w.png"/></div></div></figure><p id="e22a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用函数内存保存以前操作的结果可以为经常依赖以前结果的计算节省大量时间，例如斐波那契数列。缺点是闭包中的obj对象会占用额外的内存。</p><p id="4f2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，使用动态规划比前者具有更低的空间复杂度，也是更值得推荐的解决方案。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/fcf9b51d049291a8b849ce08a06f81a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gw5gfdZFlwdFO5dl0uXqdA.png"/></div></div></figure><h1 id="e288" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">14.实现函数绑定方法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/024d9397d1b665728935969a0630d3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2PnAFi5EJx3IJL2n88bbpA.png"/></div></div></figure><p id="1194" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现该函数的bind方法的核心是使用调用来绑定该指针，同时考虑到其他一些情况，例如:</p><p id="a5b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当bind返回的函数被new调用为构造函数时，绑定值将失效，改为new指定的对象。</p><p id="89d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">定义绑定函数的长度属性和名称属性(不可枚举属性)。</p><p id="9f3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">绑定函数的原型需要指向原函数的原型(<em class="mg">真实情况下，绑定函数没有原型。而是在绑定函数中有一个内部属性[[TargetFunction]]，用来保存原函数。当final函数作为构造函数时，创建的实例的__proto__指向[[TargetFunction]]的原型，这里无法模拟内部属性，所以直接声明一个原型属性</em>。</p><h1 id="6ce3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">15.实现函数调用方法</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c8aeb05ebc1ccc1de444765f4adfeac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08Z7Y8w7u47hOgK8sA2EGQ.png"/></div></div></figure><p id="5f23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原理是将函数作为传入的上下文参数(context)的属性来执行。这里，ES6符号类型用于防止属性冲突。</p><h1 id="d704" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">16.简单公司</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8b1f7dc9b21818e2df368043724c5ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKP-W7vj4iwJH4l2EPo1bw.png"/></div></div></figure><p id="3c41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说明:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7c886eeedb12e9846021ca8a540109b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6W1U8M6UtMQbfw1JutoRg.png"/></div></div></figure><p id="8830" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">run函数接受一个生成器函数，并在run函数包装的生成器函数遇到yield关键字时停止</p><p id="0564" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当后续yield的承诺解析成功后，会自动调用next方法执行到下一个yield关键字，最终，每当一个承诺解析成功，就会解析下一个承诺。</p><p id="cae1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当所有解析成功时，打印所有解析的结果，并演变成现在最常用的async/await语法</p><h1 id="0a66" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">17.去抖</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d1d0d8139745a1a4c3455548a8557e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOjS8bQei27i4x8FtcuzwQ.png"/></div></div></figure><p id="6e2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主导是进入时是否执行一次。原理就是用定时器。如果事件在指定时间内再次被触发，则最后一个定时器将被清除，也就是说，该功能将不被执行，一个新的定时器将被重置，直到它超过指定时间。时间会自动触发计时器中的功能。</p><p id="9cc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同时，通过闭包暴露了一个cancel函数，这样外部可以直接清除内部计数器。</p><h1 id="7264" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">18.节流</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d2ccc741446b5af85ddc002454bef5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yVFw1NcYZQZjf3aTv0h7A.png"/></div></div></figure><p id="8fad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与防抖功能类似，不同的是额外使用内部时间戳作为判断，如果一段时间内没有触发事件，则允许触发下一个事件。同时增加了一个尾随选项，表示最后是否触发额外时间。</p><h1 id="2e5a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">19.图像延迟加载</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/23a42b2978952678d3934f8ba28ce86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cz_hpLZxAikjP-Bnh7SNaQ.png"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9bdc95d358938a59c785496c64ccc289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGUHcwgBp5gcoW9wyOLAxw.png"/></div></div></figure><p id="ca01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">getBoundClientRect的实现方法是监听scroll事件(建议在monitor事件中加入节流)，加载后图片会从img标签组成的DOM列表中删除，最后在monitor事件加载后所有图片都需要解除绑定。</p><p id="ad07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现一个intersectionObserver，实例化IntersectionObserver，让它观察所有img标签。</p><p id="172f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当img标签进入可见区时，执行实例化回调，向回调传递一个entries参数，该参数保存实例观察到的所有元素的一些状态，比如每个元素的边界信息，当前元素对应的DOM节点。，当前元素进入可见区域的速率。</p><p id="a77e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当一个元素进入可视区域时，将真实图像分配给当前的img标签并释放其观察</p><h1 id="c84c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">20.实施新的</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1f3988d50a71d43d1bb0d1b33a924317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzYno-SB-4wB_gOPI6rBRg.png"/></div></div></figure><h1 id="dd1b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">21.实现Object.assign</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e584ef68a7cf10182ee2fb288a1dde48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rrmWTIDl-aaQxDdtU62ig.png"/></div></div></figure><h1 id="5934" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">22.实现实例of</h1><p id="8943" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">原理是递归遍历右边参数的原型链，每次都与左边参数进行比较，当遍历到原型链末端时返回false，找到时返回true</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a12e2ff4641885abbf37963634fbcd7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kS3fWhQRi-GRUSm_Z8uzg.png"/></div></div></figure><h1 id="3a49" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">23.私有变量的实现</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a8d9e1eba70c649ea28cb0327ad06ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHi5PvEZ-EVSBT2FXGA1Ww.png"/></div></div></figure><p id="ae99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用Proxy代理所有以_开头的变量，这样就不能从外部访问它们</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d6a7f3f7571e78d7ae5251e88f8a242e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptITERayqpFyM4BncugE-w.png"/></div></div></figure><p id="dc73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以闭包的形式保存私有变量，缺点是类的所有实例都访问同一个私有变量</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3cf1e25a0a1f2669369a4c1b252eb281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15A1KPw8sP_eaCCiEVAUeg.png"/></div></div></figure><p id="86b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">闭包的另一个实现解决了上述闭包的缺点。每个实例都有自己的私有变量。缺点是放弃了类语法的简单性，放弃了所有特权方法(访问私有变量的方法)。存储在构造函数中</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a66960c26db569c7487e9d9ef7817d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fu8Zx7c8ET_YezOFerjcdg.png"/></div></div></figure><p id="3226" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过WeakMap和闭包，在每次实例化时保存由当前实例和所有私有变量组成的对象，闭包中的WeakMap无法从外部访问。使用WeakMap的好处是，当没有变量引用实例时，会自动释放。实例保存的私有变量，以减少内存溢出问题</p><h1 id="ffb5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">24.洗牌算法</h1><p id="e363" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">早期的chrome对少于10个元素的数组使用插入排序，这将导致数组乱序，而不是真正的乱序，即使最新版本的chrome使用就地算法使排序成为稳定的算法，乱序问题仍然没有解决</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/255380bf0434e35ec17f1bfa0c2bbd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1ZoC0K7oSM5QprxUBMK7w.png"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/96a7f1c9f24e8d388971ddeba3353a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9Qa02qj-LPOA3XEzZHgBg.png"/></div></div></figure><p id="9b9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">真正的无序可以通过洗牌算法实现。洗牌算法分为原地和非原地。图1是原位洗牌算法。不需要声明额外的数组来节省内存使用。原则是按顺序遍历。数组的元素，随机选择当前元素和所有后续元素中的一个，并交换它们</p><h1 id="b06a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">25.单一模式</h1><p id="cd2d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">ES6的代理拦截构造函数的执行方法实现的单例模式</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/579caff72de85c6d6e7edec0652cc7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOqucxCiFVhNvObcUUrMhQ.png"/></div></div></figure><h1 id="5ec7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">26.许诺</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2c25d6b815efa9c3c9c1a8bb11a3ff79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s498EKNFev6Ech56w7Wqtg.png"/></div></div></figure><p id="ae35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说明:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/22fcc16bc9238666f6266f870041effb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pk-5EzJLpKNtdqfVFPQSKA.png"/></div></div></figure><p id="d037" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">promisify函数是一个辅助函数，它将回调函数转换为承诺，适用于错误优先风格(nodejs)回调函数</p><p id="ebc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原理是不管错误优先风格回调成功还是失败，最后一个回调函数都会在执行后执行。我们需要做的就是让这个回调函数控制承诺的状态。</p><p id="d709" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里还使用Proxy来代理整个fs模块，截取get方法，这样就不需要手动用promisify函数包装fs模块的所有方法，更加灵活</p><h1 id="41cf" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">27.优雅地处理异步/等待</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/66a335ccae1b666547da20ec1d93f029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2unWeIudXdxxIltthtoSHA.png"/></div></div></figure><p id="9c0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说明:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/88b03e066efb82d4d3b138c28d4acd22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHy38AFe2m7PU7MC3EAtNA.png"/></div></div></figure><p id="c69b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不需要每次使用async/await都包装一层try/catch，这样更优雅。这是另一个想法。如果使用webpack，可以编写一个加载器，分析AST语法树，遇到await语法时自动注入try/catch。这样你甚至不需要使用帮助函数</p><h1 id="3e3d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">28.事件发射器</h1><p id="d2f1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">on方法用于注册事件，trigger方法触发事件以实现事件间的松散解耦，并增加了额外的once和off辅助函数来注册只触发一次的事件和注销事件。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7c8e74779cac7c00d4aa3c9f9fa89399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6s75Tv12sABhV4Fz7oVTrQ.png"/></div></div></figure><h1 id="557b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">29.实现JSON.stringify(附加)</h1><p id="dd40" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当使用JSON.stringify将对象转换为JSON字符串时，一些非法的数据类型会被扭曲，主要如下</p><p id="b6bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果对象包含toJSON方法，将调用toJSON</p><p id="293d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">阵列</p><ul class=""><li id="444f" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated">1.当存在未定义的/符号/函数数据类型时，将变为null</li><li id="34da" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">2.无穷大/NaN的存在也将变成零</li></ul><p id="0e0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对象</p><ul class=""><li id="d51a" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated">1.当属性值为未定义/符号/函数数据类型时，属性和值都不会转换为字符串</li><li id="8183" class="mh mi in jx b jy mq kc mr kg ms kk mt ko mu ks mm mn mo mp bi translated">2.如果属性值为Infinity/NaN，属性值将变为null</li></ul><p id="6971" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">日期数据类型值调用ISOString</p><p id="0bc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不是数组/对象/函数/日期的复杂数据类型成为空对象</p><p id="e029" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">循环引用抛出错误</p><p id="b716" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，JSON.stringify还可以传入第二个和第三个可选参数。感兴趣的朋友可以详细了解一下。</p><p id="b6cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现代码比较长，这里我直接粘贴对应的源代码地址<a class="ae mv" href="https://github.com/yeyan1996/JavaScript/blob/master/json.js" rel="noopener ugc nofollow" target="_blank"> JSON.stringify </a></p><h1 id="d54f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">源代码</h1><p id="bf89" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><a class="ae mv" href="https://github.com/yeyan1996/JavaScript" rel="noopener ugc nofollow" target="_blank">源码</a>，请不要吝啬你手中的明星，你的赞是对我最大的鼓励，谢谢</p><p id="aca1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mg">更多内容看</em> <a class="ae mv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mg">说白了就是</em> </strong> </a> <em class="mg">。报名参加我们的</em> <a class="ae mv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mg">免费周报</em> </strong> </a> <em class="mg">。关注我们关于</em><a class="ae mv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mg">Twitter</em></strong></a><em class="mg">和</em><a class="ae mv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mg">LinkedIn</em></strong></a><em class="mg">。加入我们的</em> <a class="ae mv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mg">社区</em> </strong> </a> <em class="mg">。</em></p></div></div>    
</body>
</html>