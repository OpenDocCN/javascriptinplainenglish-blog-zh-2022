<html>
<head>
<title>A Better Approach to Modals in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中情态动词的更好处理方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-better-approach-to-modals-in-react-236439955bab?source=collection_archive---------2-----------------------#2022-12-29">https://javascript.plainenglish.io/a-better-approach-to-modals-in-react-236439955bab?source=collection_archive---------2-----------------------#2022-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="53dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢React的一点是，它都围绕着一个基本概念:视图(用户看到的内容)是T2模型(与用户相关的所有数据)的一个功能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3d1e035003f73ac8036f30b552689906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nPQhDv2qQfF6Iz2j.png"/></div></div></figure><p id="3d7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在大多数情况下，这是一个构建ui的极好的概念模型。不过，有时候命令式方法更容易推理。</p><p id="31db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以情态动词为例。在React的世界中，与模态的完全交互(打开它、与之交互和/或关闭它)是移动部件管弦乐队的微妙结果，包括:</p><ol class=""><li id="32ca" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">指示模式是否应该显示的状态变量</li><li id="10f0" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">可能更多的状态包含了与模态相关的数据，比如显示什么样的文本或按钮</li><li id="26d5" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">每个按钮的事件处理程序</li></ol><p id="5d70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些数据都需要通过组件树向上、向下和横向传递。与它看起来应该有多简单相比，这是一个令人纠结的混乱:显示一个新屏幕，等待用户的按钮点击，并根据用户点击的按钮做一些事情。</p><p id="1b13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的上一个项目中，我面临着实现多个模态的恼人任务，我只需要用户的一个简单回答，比如一个OK/cancel，或者一个简短的文本响应。</p><p id="cb66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对钩子很着迷，所以我的第一个想法是:我能不能写一个钩子，把所有讨厌的状态和回调简化成一个简单的、命令式的API，我可以在我的应用程序的任何地方使用它？</p><p id="a127" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原来我可以，你也可以。在这个过程中，你会学到很多关于承诺和反应的知识。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ll"><img src="../Images/add73e05fb049b7ad7fa632aea67d012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sdh7vp-hBPIua-gsUN580g.jpeg"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Let’s have some fun.</figcaption></figure><h1 id="ecfd" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">API</h1><p id="6893" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">所有好的软件模块都是从接口开始的。这就像描述系统的目标——它应该能够做什么，使用什么命令？</p><p id="dc42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从概念上讲，提示就像返回承诺的函数一样简单。我们将模态需要的任何数据传递给函数，经过一段延迟(无论用户花多长时间想出答案)，它返回用户的响应。</p><p id="1743" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，让我们考虑一个OK/cancel模态。我们希望向modal发送一条自定义消息，并让它返回“OK”或“cancel”。这是这样一个函数的签名:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="2688" class="my lr iq mu b be mz na l nb nc">type OKCancelModalResponse = "OK" | "cancel";<br/><br/>function okCancelModal(message: string): Promise&lt;OKCancelModalResponse&gt;;</span></pre><p id="5f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们的目标是写一个钩子，用这个签名生成一个函数。以下是这种挂钩的模板:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="c911" class="my lr iq mu b be mz na l nb nc">export function useOKCancelModal() {<br/>  return useCallback((message: string) =&gt; {<br/>    // open the modal and do our stuff<br/>    const promise = new Promise&lt;OKCancelModalResponse&gt;();<br/>    return promise;<br/>  }, []);<br/>}</span></pre><h1 id="4a1b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">用数据思考</h1><p id="55d1" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">通用模型至少包含两个组件:</p><ol class=""><li id="c4ed" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">调用模态的组件(本质上是调用者)</li><li id="a65b" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">呈现模式的组件(本质上是被调用方)</li></ol><p id="6f71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据需要在这两个组件之间传递。具体来说，调用者需要告诉调用者消息是什么，而调用者需要用一个特定的响应(“OK”或“cancel”)来响应调用者。</p><p id="01db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以为此使用一个状态“片段”,因为我们永远不需要同时知道提示和响应。下面是一个简单的数据定义:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="c66b" class="my lr iq mu b be mz na l nb nc"><br/><br/>type OKCancelModalData = {<br/>  message: string;<br/>  response?: OKCancelModalResponse;<br/>}</span></pre><p id="c6ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nd">你到底想如何传输这些数据取决于你，但是我使用了一个简单的全局状态库，叫做<a class="ae ne" href="https://jotai.org/" rel="noopener ugc nofollow" target="_blank"> Jotai </a>。我首先初始化了一个<em class="nd">原子</em>，它只是全局状态的一部分:</em></p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="4d8e" class="my lr iq mu b be mz na l nb nc">export const okCancelModalData = atom&lt;OKCancelModalData | null&gt;(null);</span></pre><p id="65f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nf ng nh mu b">null</code>表示尚未打开任何模态，或者最后一个模态已关闭，其响应已读取。</p><p id="a614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以像这样将这个全局状态挂钩到我们的自定义挂钩中:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="7b98" class="my lr iq mu b be mz na l nb nc">export function useOKCancelModal() {<br/>  const [data, setData] = useAtom(okCancelModalData);<br/><br/>  return useCallback((message: string) =&gt; {<br/>    // open the modal and do our stuff<br/>    const promise = new Promise&lt;OKCancelModalResponse&gt;();<br/>    return promise;<br/>  }, []);<br/>}</span></pre><p id="f73f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当回调被调用时，第一步是打开模式并传入给定的消息:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="a25b" class="my lr iq mu b be mz na l nb nc">export function useOKCancelModal() {<br/>  const [data, setData] = useAtom(okCancelModalData);<br/><br/>  return useCallback((message: string) =&gt; {<br/>    setData({ message });<br/>    const promise = new Promise&lt;OKCancelModalResponse&gt;();<br/>    return promise;<br/>  }, []);<br/>}</span></pre><p id="b0f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是有趣的部分:承诺。</p><h1 id="d87a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">许下承诺很容易，但信守承诺却很难</h1><p id="3fd6" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">无论何时你迷失在承诺的土地上，只要记住Javascript承诺只不过是回调的标准化，带有一些花哨的语法。<code class="fe nf ng nh mu b">resolve</code>函数就是回调。</p><p id="2eab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们需要用用户的响应调用<code class="fe nf ng nh mu b">resolve</code>函数。当然，我们不会立即知道用户的响应——我们必须等待模态组件用响应更新<code class="fe nf ng nh mu b">data</code>。</p><p id="12cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将添加另一个状态，但这个状态不需要是全局的，因为它将只存储由promise构造函数生成的<code class="fe nf ng nh mu b">resolve</code>函数，如下所示:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="6eec" class="my lr iq mu b be mz na l nb nc">export function useOKCancelModal() {<br/>  const [data, setData] = useAtom(okCancelModalData);<br/>  const [resolve, setResolve] = useState&lt;<br/>    (response: ConfirmationModalResponse) =&gt; void<br/>  &gt;(() =&gt; {});<br/><br/>  return useCallback((message: string) =&gt; {<br/>    setData({ message });<br/>    const promise = new Promise&lt;OKCancelModalResponse&gt;(<br/>      (_resolve) =&gt; setResolve(_resolve)<br/>    );<br/>    return promise;<br/>  }, []);<br/>}</span></pre><p id="bb0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单。但是有一个问题，任何时候你试图用<code class="fe nf ng nh mu b">React.useState()</code>存储一个函数都会遇到这个问题。</p><p id="6ab9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正常情况下，当你调用<code class="fe nf ng nh mu b">setState</code>时，你只是传入新的状态。这就是我们在上面尝试的，它适用于除功能之外的一切<em class="nd">。</em></p><p id="330c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是<code class="fe nf ng nh mu b">setState</code>还允许你传入一个reducer函数，它根据前一个状态计算下一个状态。所以当你传入<code class="fe nf ng nh mu b">setState</code>的值本身就是一个函数的时候，React会调用这个函数并存储它返回的值。在这种情况下，这将尽早解决我们的承诺，使我们的钩子无用。</p><p id="a6f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这个问题很简单:我们创建一个更高级的函数！我们没有传入<code class="fe nf ng nh mu b">_resolve</code>，而是传入一个返回它的函数:<code class="fe nf ng nh mu b">() =&gt; _resolve</code>。像这样:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="1b28" class="my lr iq mu b be mz na l nb nc">export function useOKCancelModal() {<br/>  const [data, setData] = useAtom(okCancelModalData);<br/>  const [resolve, setResolve] = useState&lt;<br/>    (response: ConfirmationModalResponse) =&gt; void<br/>  &gt;(() =&gt; {});<br/><br/>  return useCallback((message: string) =&gt; {<br/>    setData({ message });<br/>    const promise = new Promise&lt;OKCancelModalResponse&gt;(<br/>      (_resolve) =&gt; setResolve(() =&gt; _resolve)<br/>    );<br/>    return promise;<br/>  }, []);<br/>}</span></pre><p id="f815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备调用<code class="fe nf ng nh mu b">resolve</code>。</p><h1 id="530c" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">你知道它，你讨厌它，<code class="fe nf ng nh mu b">useEffect</code></h1><p id="4a51" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated"><code class="fe nf ng nh mu b">useEffect</code>是我们如何将副作用(比如调用<code class="fe nf ng nh mu b">resolve</code>)与组件中的数据变化同步，比如全局状态变量<code class="fe nf ng nh mu b">data</code>。</p><p id="39bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们所要做的就是等待对<code class="fe nf ng nh mu b">data</code>的更改，如果存在响应，则使用该响应对<code class="fe nf ng nh mu b">resolve</code>进行更改，并重置模态数据。因此:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="04d9" class="my lr iq mu b be mz na l nb nc">export function useOKCancelModal() {<br/>  const [data, setData] = useAtom(okCancelModalData);<br/>  const [resolve, setResolve] = useState&lt;<br/>    (response: ConfirmationModalResponse) =&gt; void<br/>  &gt;(() =&gt; {});<br/><br/>  useEffect(() =&gt; {<br/>    if (data &amp;&amp; data.response) {<br/>      resolve(data.response);<br/>      setData(null);<br/>    }<br/>  }, [data, setData, resolve]);<br/><br/>  return useCallback((message: string) =&gt; {<br/>    setData({ message });<br/>    const promise = new Promise&lt;OKCancelModalResponse&gt;(<br/>      (_resolve) =&gt; setResolve(() =&gt; _resolve)<br/>    );<br/>    return promise;<br/>  }, []);<br/>}</span></pre><p id="7778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们的钩子。</p><h1 id="d9b5" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">把所有的放在一起</h1><p id="0fc8" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">首先，您需要一个组件来呈现您的模态。逻辑很简单:</p><ol class=""><li id="56ad" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">如果<code class="fe nf ng nh mu b">okCancelModalData</code>是<code class="fe nf ng nh mu b">null</code>，不要渲染任何东西</li><li id="da3e" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">否则，用<code class="fe nf ng nh mu b">okCancelModalData.message</code>作为文本，用两个按钮设置正确的<code class="fe nf ng nh mu b">modalData</code>状态来呈现一个模态</li></ol><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="4e4b" class="my lr iq mu b be mz na l nb nc">const OKCancelModal: React.FC = () =&gt; {<br/>  const [modalData, setModalData] = useAtom(okCancelModalData);<br/><br/>  const onCancel = () =&gt; {<br/>    setModalData({ ...modalData!, response: "cancel" });<br/>  };<br/><br/>  const onOK = () =&gt; {<br/>    setModalData({ ...modalData!, response: "confirm" });<br/>  };<br/><br/>  if (!modalData) {<br/>    return null;<br/>  }<br/>  return (<br/>    &lt;Modal onClose={onCancel}&gt;<br/>      &lt;p&gt;{modalData.message}&lt;/p&gt;<br/>      &lt;div&gt;<br/>        &lt;Button onClick={onCancel}&gt;<br/>          Cancel<br/>        &lt;/Button&gt;<br/>        &lt;Button onClick={onOK}&gt;OK&lt;/Button&gt;<br/>      &lt;div&gt;<br/>    &lt;/Modal&gt;<br/>  );<br/>};</span></pre><p id="5538" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以通过导入<code class="fe nf ng nh mu b">useOKCancelModal</code>钩子从任何组件的函数中调用它:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="1722" class="my lr iq mu b be mz na l nb nc">const ModalCaller: React.FC = () =&gt; {<br/>  const okCancelModal = useOKCancelModal();<br/>  <br/>  async function doSomethingWithPrompt() {<br/>    const response = await okCancelModal("Clap this Medium story?");<br/>    if (response === "OK") {<br/>      mediumStory.clap();<br/>    } else {<br/>      // do nothing<br/>    }<br/>  }<br/><br/>  return ...<br/>}</span></pre><h1 id="86af" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="eb25" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">事后看来，这个设计似乎很简单，几乎是显而易见的。但是所涉及的概念却不是，这些概念——承诺和React挂钩——对于任何有抱负的Javascript或React开发人员来说都是绝对必要的。</p><p id="a1d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你从看到这段代码中有所收获，并喜欢你的新模态钩子——只是不要过度使用它，它是坏UX。</p><h2 id="fbd3" class="ni lr iq bd ls nj nk dn lw nl nm dp ma jy nn no me kc np nq mi kg nr ns mm nt bi translated">更多内容请访问<a class="ae ne" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> PlainEnglish.io </a>。</h2><p id="3aa9" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated"><em class="nd">报名参加我们的</em> <a class="ae ne" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="nd">免费每周简讯</em> </strong> </a> <em class="nd">。关注我们关于</em> <a class="ae ne" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="nd">推特</em></strong></a><a class="ae ne" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nd">领英</em></strong></a><strong class="jp ir"><em class="nd"/></strong><a class="ae ne" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nd">YouTube</em></strong></a><strong class="jp ir"><em class="nd">和</em></strong><em class="nd"/><a class="ae ne" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nd">不和</em> </strong> </a>T56】</p><h2 id="a759" class="ni lr iq bd ls nj nk dn lw nl nm dp ma jy nn no me kc np nq mi kg nr ns mm nt bi translated">希望扩大你的科技创业公司的知名度和采用率吗？检查<a class="ae ne" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank">电路</a>。</h2></div></div>    
</body>
</html>