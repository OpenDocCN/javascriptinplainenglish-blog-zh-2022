<html>
<head>
<title>5 Ways to Download Front-end Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下载前端文件的5种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-ways-to-download-front-end-files-a321271e7f5d?source=collection_archive---------0-----------------------#2022-11-16">https://javascript.plainenglish.io/5-ways-to-download-front-end-files-a321271e7f5d?source=collection_archive---------0-----------------------#2022-11-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="baf9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">1.一个标签，2。window.open，请按3。location.href，4。位置。？其他属性，以及5。XMLHttpRequest。每种方法的优缺点是什么？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9e037722a5d801654d0014dcf4ef76f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGIr2DJXnTNR6FFpx7O9qg.png"/></div></div></figure><p id="ceac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">前端涉及的文件下载还有很多应用场景，那么前端文件下载有多少种方式呢？每种方法的优缺点是什么？下面就一个一个介绍吧。</p><h1 id="f1ea" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">1.一个标签</h1><p id="b44f" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">文件下载是通过a标签的下载属性实现的。这种方法是最简单也是最常用的方法。让我们先来看看示例代码:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="7779" class="mm ll in mi b gy mn mo l mp mq">&lt;a href="<a class="ae mr" href="http://www.baidu.com" rel="noopener ugc nofollow" target="_blank">http://www.</a>google.com" download="google.html"&gt;download&lt;/a&gt;</span></pre><p id="79ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，我们点击了下载，发现跳转到了Google的首页，并没有实际下载文件。<br/>因为一个标签下载只能下载同一来源的文件，如果是跨域文件，包括图片、音视频等媒体文件，则是预览版，不能下载。<br/>上面的代码是通过写标签直接实现文件下载，我们也可以通过js来实现，代码如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="fb8c" class="mm ll in mi b gy mn mo l mp mq">const a = document.createElement('a')<br/>a.href = '<a class="ae mr" href="http://www.baidu.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a><br/>a.download = 'google.html'<br/>a.click()</span></pre><p id="6bf1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">效果和上面一样，不下载文件就跳转到百度首页。<br/>这里的重点是标签的下载属性，这是HTML5中新增的。<br/>其功能是指定下载的文件名。如果未指定，将根据请求内容的内容处理来确定下载的文件名。如果没有Content-Disposition，那么所请求的URL的最后一部分将被用作文件名。</p><h1 id="a4d0" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">2.窗口.打开</h1><p id="9660" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">上面使用标签的情况也可以通过window.open实现，效果是一样的，代码如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="97f2" class="mm ll in mi b gy mn mo l mp mq">window.open('<a class="ae mr" href="http://www.baidu.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a>, '_blank')</span></pre><p id="9212" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里的_blank是指定开口的方式。如果未指定，将在当前页面打开。在这里指定_blank意味着在新的页面上打开它。</p><p id="d672" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也可以使用标签的下载属性，代码如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="95e3" class="mm ll in mi b gy mn mo l mp mq">window.open('<a class="ae mr" href="http://www.baidu.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a>, '_blank', 'download=google.html')</span></pre><p id="ac98" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然这种方法也是有缺陷的。与标签相比，该方法不能下载。html，。htm，。xml，。xhtml等文件，因为这些文件会被当作html文件，所以它们会直接出现在当前页面上。打开。<br/>跨域下载文件也是不可能的。毕竟是window.open，不是window . download(window . download是虚构的)。</p><h1 id="dcdf" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">3.location.href</h1><p id="143c" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这个方法和window.open(url)一样，代码如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="f26a" class="mm ll in mi b gy mn mo l mp mq">location.href = '<a class="ae mr" href="http://www.baidu.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a></span></pre><p id="0158" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种方法有window.open的所有缺陷，不建议使用。这里只是作为一种理解，不做过多解释。</p><h1 id="0bbc" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">4.位置。？其他属性</h1><p id="ba45" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这里的其他是指可以跳转到页面的属性，比如location.assign、location.replace、location.reload等。这些属性可以实现文件下载，代码如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="b420" class="mm ll in mi b gy mn mo l mp mq">location.assign('<a class="ae mr" href="http://www.baidu.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a>)<br/>location.replace('<a class="ae mr" href="http://www.baidu.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a>)<br/>location.reload('<a class="ae mr" href="http://www.baidu.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a>)</span></pre><p id="4e34" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里的location.reload有点特殊，它的功能是重载当前页面，但是它也可以接受一个参数，这个参数就是要跳转的页面，所以它也可以实现文件下载。<br/>当然，和location.href一样，这些方法也有相同的缺点，也各有各的属性特点。这只是为了扩充知识面，不做过多解释。</p><h1 id="b200" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">5.XMLHttpRequest</h1><p id="e956" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这个方法就是我们常说的ajax下载，包括Axios，fetch等。都是一样的，代码如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="5f04" class="mm ll in mi b gy mn mo l mp mq">const xhr = new XMLHttpRequest()<br/>xhr.open('GET', '<a class="ae mr" href="http://www.baidu.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a>)<br/>xhr.send()</span><span id="d663" class="mm ll in mi b gy ms mo l mp mq">xhr.onload = function () {<br/>  const blob = new Blob([xhr.response], { type: 'text/html' })<br/>  const a = document.createElement('a')<br/>  a.href = URL.createObjectURL(blob)<br/>  a.download = 'google.html'<br/>  a.click()<br/>}</span></pre><p id="9f9a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里就不说XMLHttpRequest相关的知识了，只说文件下载相关的部分。<br/>这里的主要逻辑是，当我们的请求成功时，我们会得到响应体的响应，这个响应就是我们要下载的内容，然后我们将其转换成blob对象，再通过url.createObjectURL创建一个URL，然后通过a标签的download属性实现文件下载。<br/>这里有两个知识点，一个是blob对象，一个是URL.createObjectURL</p><h1 id="65e7" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">5.1斑点</h1><p id="5515" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">下面是blob对象的定义，来自<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="184b" class="mm ll in mi b gy mn mo l mp mq">The <!-- -->Blob<!-- --> object represents a blob, which is a file-like object of immutable, raw data; they can be read as text or binary data, or converted into a <a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" rel="noopener ugc nofollow" target="_blank">ReadableStream</a> so its methods can be used for processing the data.</span><span id="9d0a" class="mm ll in mi b gy ms mo l mp mq">Blobs can represent data that isn't necessarily in a JavaScript-native format. The <a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener ugc nofollow" target="_blank">File</a> interface is based on <!-- -->Blob<!-- -->, inheriting blob functionality and expanding it to support files on the user's system.</span></pre><p id="98c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">blob对象是html5中的一个新对象。它的功能是存储二进制数据，如图片、视频、音频等。其用法如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="46e6" class="mm ll in mi b gy mn mo l mp mq">/**<br/> * <a class="ae mr" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {Array}  array binary data<br/> * <a class="ae mr" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {Object} options configuration item<br/> *      <a class="ae mr" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {String} options.type The file type, which represents the MIME type of the array contents that will be put into the blob.<br/> *      <a class="ae mr" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {String} options.endings Used to specify how strings containing line terminators \n are written. Defaults to transparent, which means that line terminators will not be modified. It can also be specified as native, which means that \n will be converted to \r\n.<br/> */<br/>const blob = new Blob([], { type: '' })</span></pre><p id="fa05" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里主要关心的是类型属性。默认情况下，blob对象没有type属性，所以blob是一个非类型化的blob，文件不会被破坏，但是不能正常识别。</p><h1 id="e006" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">5.2 URL.createObjectURL</h1><p id="b457" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">以下来自<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="3416" class="mm ll in mi b gy mn mo l mp mq">The <!-- -->URL.createObjectURL()<!-- --> static method creates a string containing a URL representing the object given in the parameter.</span><span id="e96f" class="mm ll in mi b gy ms mo l mp mq">The URL lifetime is tied to the <a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/Document" rel="noopener ugc nofollow" target="_blank">document</a> in the window on which it was created. The new object URL represents the specified <a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener ugc nofollow" target="_blank">File</a> object or <a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank">Blob</a> object.</span></pre><p id="91a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此方法用于创建url。它的功能是将blob对象转换成url。此url可用于下载文件或预览文件。代码如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="a1c6" class="mm ll in mi b gy mn mo l mp mq">const url = URL.createObjectURL(blob)</span></pre><p id="4743" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里需要注意的是，这个url的生命周期是和创建它的窗口中的文档绑定在一起的，也就是说，当我们的文档被销毁时，这个url就会失效，所以我们需要在合适的时候销毁它，代码显示如下:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="430b" class="mm ll in mi b gy mn mo l mp mq">URL.revokeObjectURL(url)</span></pre><p id="e6d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回到我们刚刚下载的问题，我们通过blob对象解决了它，但是我们的type属性是硬编码的。如果文件类型确定了就没有问题，但是如果这个接口是下载文件的接口，文件可以是各种类型，我们该怎么处理呢？<br/>这里没有正确答案。首先是与接口提供商协商。谈判方案不确定。二是通过响应的头获取文件的类型，这也是我们要讲的:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="86f9" class="mm ll in mi b gy mn mo l mp mq">const type = response.headers['content-type']</span><span id="fd8e" class="mm ll in mi b gy ms mo l mp mq">const blob = new Blob([response.data], { type })</span></pre><p id="b190" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们通过响应的头获取类型，然后创建blob对象，这样文件就可以正确下载了。<br/>事实上，内容类型也可以是应用/八位流。这时，我们需要通过file-type获取文件的类型。<br/>下面的代码使用file-type来获取文件的类型:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="add8" class="mm ll in mi b gy mn mo l mp mq">import {fileTypeFromStream} from 'file-type';</span><span id="df11" class="mm ll in mi b gy ms mo l mp mq">const type = await fileTypeFromStream(response.body);<br/>const blob = new Blob([response.data], { type })</span></pre><p id="f7d7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">文件类型的使用可以参考这里的<a class="ae mr" href="https://github.com/sindresorhus/file-type" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f40c" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">总结</h1><p id="7df0" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">上面这么多解决方案，其实最后都落在一个标签上，所以不管是通过浏览器内置的行为下载，还是通过ajax下载，最后文件下载都是浏览器的行为。</p><p id="231a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mt">更多内容看</em> <a class="ae mr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mt">说白了就是</em> </strong> </a> <em class="mt">。报名参加我们的</em> <a class="ae mr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mt">免费周报</em> </strong> </a> <em class="mt">。关注我们关于</em> <a class="ae mr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mt">推特</em> </strong> </a>，<a class="ae mr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mt">领英</em> </strong> </a> <em class="mt">，</em><a class="ae mr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mt">YouTube</em></strong></a><em class="mt">，以及</em> <a class="ae mr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mt">不和</em> </strong> </a> <em class="mt">。对增长黑客感兴趣？检查</em> <a class="ae mr" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mt">电路</em> </strong> </a> <em class="mt">。</em></p></div></div>    
</body>
</html>