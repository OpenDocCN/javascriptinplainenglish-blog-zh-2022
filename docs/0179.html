<html>
<head>
<title>How to Choke JavaScript with a Simple Function?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用一个简单的函数噎死JavaScript？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-choke-the-javascript-with-a-simple-function-4dc0cae5fe03?source=collection_archive---------13-----------------------#2022-01-11">https://javascript.plainenglish.io/how-to-choke-the-javascript-with-a-simple-function-4dc0cae5fe03?source=collection_archive---------13-----------------------#2022-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6906ebfb9452a679f930e93bd167e290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MvTXWhpZrkoOc7Tr"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4f95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，我发现JavaScript函数可能会变慢和阻塞，这促使我探索这个问题。你说的函数扼流圈是什么意思？我是不是不小心写了一个无限循环的算法？不，我没有。我说的是一个基本的函数，但是我需要调用它很多次，比如10，000次以上。</p><p id="df2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">先说一个简单的函数？你听说过欧几里德算法吗，就是求两个数的最大公约数的那个？我打赌你有，这是JavaScript版本:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a29c" class="lh li in ld b gy lj lk l ll lm">function <strong class="ld io">gcd</strong>(a, b) {<br/>  return b == 0 ? a : <strong class="ld io">gcd</strong>(b, a % b)<br/>}</span></pre><h2 id="945f" class="lh li in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">用JavaScript运行百万次</h2><p id="c74a" class="pw-post-body-paragraph ka kb in kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">这个<code class="fe mj mk ml ld b">gcd</code>函数并不太疯狂，但这正是我想要的，一个基本函数，这样我就可以对它进行一些分析，看看它需要多长时间。我选择了两个大数<code class="fe mj mk ml ld b">461952</code>和<code class="fe mj mk ml ld b">116298</code>,这样递归层次就达到了7而不是3。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c19a" class="lh li in ld b gy lj lk l ll lm">const N = 4000000<br/>console.time('recursion')<br/>for (let i = 0; i &lt; N; i++) { <strong class="ld io">gcd</strong>(461952,116298) }<br/>console.timeEnd('recursion')</span></pre><p id="fac4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我只能运行这个代码不超过4，000，000次，然后我的电脑就会死机。实际上，这不是因为溢出，因为我只有7级递归。相反，我遇到了内存不足的问题——在这个简单的例子中，它使用了超过3GB的内存。这不是很奇怪吗？这么简单的函数怎么会消耗3GB的内存呢？我的电脑中病毒了吗？</p><p id="e929" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原来，最后我碰到了一个v14.17.0的node . js bug .<code class="fe mj mk ml ld b">gcd</code>恰好是一个全局函数。不管是什么原因，当一个函数在全局范围内定义时，它需要在调用时在内存中复制。所以实际上我做了400万个函数。为了避免这种情况，我们可以在函数内部定义递归函数，使其成为非全局函数:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5023" class="lh li in ld b gy lj lk l ll lm">function gcdWrapper(m, n) {<br/>  function <strong class="ld io">gcd</strong>(a, b) {<br/>    return (b == 0) ? a : <strong class="ld io">gcd</strong>(b, a % b)<br/>  } <br/>  return <strong class="ld io">gcd</strong>(m, n)<br/>}</span></pre><p id="db15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我调用<code class="fe mj mk ml ld b">gcdWrapper</code>400万次，它会在0.2秒内结束——太神奇了？如果我将Node.js切换回v12.22.1，bug就会消失。以下是修复后运行该算法的统计数据。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="88ce" class="lh li in ld b gy lj lk l ll lm">   1M    10M   100M     1G     10G<br/> 41ms  366ms   3.6s    36s   6029s  JavaScript</span></pre><p id="2ae3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">统计数据显示JavaScript在100万到10亿之间相当稳定，它随着运行次数的增加而线性增长。对于10亿次运行，只需要36秒，这还不算太糟糕。但当它达到100亿时，似乎开始变得不成比例的缓慢。</p><h2 id="93aa" class="lh li in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">在铁锈中运行百万次</h2><p id="427f" class="pw-post-body-paragraph ka kb in kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">我也用另一种语言看一下这个算法，做一个比较。我选了Rust，一种低级语言:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2ddf" class="lh li in ld b gy lj lk l ll lm">fn <strong class="ld io">gcd</strong>(a: u32, b: u32) -&gt; u32 {<br/>  match b {<br/>    0 =&gt; a,<br/>    _ =&gt; <strong class="ld io">gcd</strong>(b, a % b)<br/>  }<br/>}</span></pre><p id="033f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了类型检查和模式匹配编写，Rust版本与JavaScript版本没有太大区别。我编译它并用<code class="fe mj mk ml ld b">time</code>运行它，以知道它需要多长时间:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="41a2" class="lh li in ld b gy lj lk l ll lm">rustc -O gcd.rs<br/>time ./gcd</span></pre><p id="824e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是统计数据和之前的JavaScript数据:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a247" class="lh li in ld b gy lj lk l ll lm">   1M    10M   100M     1B     10B  100B<br/> 20ms  100ms  830ms   8.1s     80s  800s  Rust<br/> 41ms  366ms   3.6s    36s   6029s     -  JavaScript</span></pre><p id="14a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Rust版本也可以线性扩展，尤其是当运行次数超过1000万次时。与JavaScript版本相比，Rust版本在不到10亿时的运行速度也快了4倍。超过10亿次运行，Rust版本变得更快。</p><h1 id="115f" class="mm li in bd ln mn mo mp lq mq mr ms lt mt mu mv lw mw mx my lz mz na nb mc nc bi translated">结论</h1><p id="35fe" class="pw-post-body-paragraph ka kb in kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">Node.js在某些版本中可能会有问题，例如v14.17.0。当在全局范围内运行大量函数时，如果您使用不稳定版本的Node.js，它可能会阻塞引擎。在稳定的Node.js版本中，例如v12.22.1，它不会出现这个问题。测试用例显示，在10亿次运行的情况下，Node.js引擎可以非常稳定和线性。超过10亿次运行，JavaScript似乎会大幅减速。请记住，我们在实践中很少能达到这么多的函数调用。</p><p id="c1a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nd">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nd">plain English . io</em></strong></a><em class="nd">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nd">免费周报</em> </strong> </a> <em class="nd">。在我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nd">社区</em> </strong> </a> <em class="nd">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>