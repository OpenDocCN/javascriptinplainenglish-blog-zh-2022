# 反应没有魔力

> 原文：<https://javascript.plainenglish.io/theres-no-magic-in-react-52d8d91a92a3?source=collection_archive---------0----------------------->

![](img/cf3507632b1d78dc409103145c0ac7a1.png)

Photo by [Almos Bechtold](https://unsplash.com/es/@almosbech?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

## 每个 React 开发人员都应该知道的 JavaScript 基础，以揭示其背后的技巧！

这个标题听起来可能很明显，但是自从我开始教编码，我看到一些开发人员，当他们不明白发生了什么时，会认为有某种魔法在发生。

![](img/76027e435d7d3883ea6529cc17d13ac0.png)

这几行代码的目的是通过回顾“**普通 JavaScript** ”的一些基本概念，并了解这如何应用于 React 流，来理解每次我们更新状态时组件内部发生了什么。

## 议程

*   回顾一下 JavaScript 中的作用域和闭包。
*   这两个概念如何影响我们在 React(使用状态)中的流程。
*   用值更新状态和用 updater 函数更新状态的区别。
*   概述 JavaScript 中对象的引用。
*   如何处理 React 中的引用？

## 你还记得什么是范围吗？

作用域是一组**环境**。Kyle Simpson 将它们描述为桶的集合，我们可以在那里存储我们的声明和价值观。然后，在执行时，我们将能够从同一个桶中访问它们。

JavaScipt scope

上面的例子是这样工作的:JS 运行时引擎将从“全局范围”开始遍历我们的代码，这里我们只有一个声明，就是`count`。然后，当我们第一次调用 count 时，JS 引擎初始化一个新的作用域，我们可以称之为“count 的作用域”。对于 JavaScript，这是一个全新的维度。这里我们有**不同的变量和声明**，只能从作用域内部访问，不能从外部访问。一旦我们完成并且函数返回，这个环境将被废弃。这里我们声明`n`等于`0`，并对其求和`1`，最后记录其值。

如果我们再次调用 count 会发生什么？显然，又要打印`1`了，因为新的调用总是会设置一个新的范围并再次声明`let n = 0`。

坚持这个作用域的概念，如果我们尝试在最后一行记录`n`，我们会得到`undefined`，因为`n` **正好存在于【计数的作用域】**中，我们无法访问。

那么，我们如何得到一个每次调用函数都会更新的变量呢？

遵循这个概念:*“每个作用域可以访问它的外部作用域”*，我们可以上移一个作用域的`n`，这样当我们调用 count 时，我们将总是引用同一个声明，并且我们不断更新它的值，所以在最后一行，我们将打印`2`。

JavaScipt scope 2

但是污染了几个变量的全局范围就很不方便了，不是吗？

## 那么闭包呢？

闭包可以完美地解决这个问题。在这里，您可以找到闭包的定义:

> “一个闭包就是一个函数能够记住并访问它的词法范围，即使这个函数是在它的词法范围之外执行的。”

在下面的代码中，我们能够调用函数`counter`，该函数将返回另一个函数，我们将该函数赋值给`count`。每次我们调用`count`时，我们从外部作用域(第 2 行)访问`n`,并不断更新它的值，所有事情都将孤立地发生，不会污染全局作用域。

Example of Closure

## 状态在哪里更新？

往前走动动反应，但是要记住我们之前说的:*一个声明存在* ***只有*** *在其作用域*内。为什么我们惊讶地发现在这段代码中它仍然记录了`0`？

Pseudo code for useState Hook

在这个`useState`钩子的伪实现中，我们看到我们创建了`state`,我们将它和一个更新它的函数一起返回。这个概念和我们刚才看到的差不多。每当我们调用`setState`函数来更新状态时，我们实际上是在改变**使用范围 State** 内变量的值，这与组件的**范围完全不同。当我们在最后一行记录`state`时，我们仍然引用在`Component`内部分配的值，它仍然是`0`。**

我现在想问一个问题:*有钩子的主要区别是什么？*

以前，functions 组件被用来呈现表象，这些组件没有状态，但是使用它们的传入道具来呈现。所以他们是无国籍的，对吗？

在我看来，与 having 的主要区别在于:现在**，**我们可以**在函数调用**之间保持状态。正如我们在开始时所说的，每个函数调用都初始化一个新的作用域，并且只保存自己的值。在下面的代码中，我们可以看到我们将如何再次调用`Component`，它将从`useState`钩子接收最新的值，钩子总是访问相同的声明，这次将是`1`。

Multiple Component function calls

理解每个渲染都是一个新的函数调用是至关重要的，每个函数调用都用声明和值来设置它的新范围。

## 用值或更新程序更新状态

现在，你能告诉我这段代码会在屏幕上显示什么吗？

Counter component with setInterval

你的猜测是什么？*(前方剧透…)*

一旦你给出了你的答案，打开这个[沙盒](https://codesandbox.io/s/counter-with-interval-im0sxb?file=/src/App.js)看看你是否是正确的，并尝试为你的计数器实现一个解决方案。如果你需要提示，请继续阅读。

看一看这个**伪**版本的`useState`钩子(你可以在沙箱的`useState.js`文件中找到代码),记住我们到目前为止所说的关于闭包的内容，试着一行一行地跟随流程。

Pseudo useState implementation

所以让我来指导你扔这个。首先，它调用`useState`并将状态初始化为`0`，该状态以元组的形式返回，并带有更新它的函数。现在，在“使用范围状态”和“计数器范围”中，`_state`和`count`都是`0`。
然后我们调用`useEffect`一次，因为空数组的依赖关系。这将设置一个间隔，每秒将调用`setCount`通过`count`。这里是**重要的部分**。设置间隔我们在第一个“计数器范围”中声明一个新的匿名函数作为回调。每次我们调用这个回调函数时，它都会在同一个范围内寻找`count`的值，其中`count`总是`0`。调用`setCount`时，我们实际上在做以下事情:

```
setCount(0 + 1) // => 1
```

这就是为什么我们总是在屏幕上看到`1`，即使间隔正在运行。

怎么才能解决呢？我们应该能够访问 count 的最新值，即包含在 useState 范围内的值，以便不依赖于“counter 范围”中的值。幸运的是,`useState`钩子给了我们传递一个更新函数的可能性，该函数将最后一次计算的值作为参数。

```
setCount((count) => count + 1)
```

这保证了我们将把 1 加到最新的值上，并且我们的计数器现在将正常工作。

## 原语和引用

JS 开发人员的另一个困惑来源是**原语和对象**的概念以及由此衍生的所有后果。在 React 中，我们应该很好地理解这个主题，以确保我们不会陷入令人讨厌的错误，比如无限循环。我想每个人都能猜到我要说什么。

简单回顾一下。尽管 JS 不是严格类型化的，但它确实有不同的元素，允许我们进行特定的操作，这些是由它们的类型定义的。

我们有原语，它是除了对象、数组和函数之外的所有东西。这最后三个属于**“对象”**的名称。对象有一个特点，当我们初始化一个对象时，我们在内存中分配空间来保存值，并在当前范围内保存对该空间的引用。我们可以传递引用，但是我们总是在内存中引用同一个对象。

也就是说，当我们在对象之间进行比较时，我们会比较它们的引用，这意味着它们在内存中是完全相同的空间，而不是它们具有相同的属性和值。

下面是一些比较的例子:

Values comparison

## React 中的引用

说到 React，实际上，当我们有了，例如，一个返回函数或对象的自定义钩子时，我们需要小心，确保我们正确地使用它们，以避免无用的渲染，甚至无限循环。

看看下一个例子。在组件`SessionTime`中，我们利用`useCounter`钩子来获取从会话开始以来经过的时间，并使用函数来重置它。每秒钟我们都调用`useCounter`，并且每次都用新的引用重新声明`resrt`和`time`。这将导致`SessionTime`内部出现无限循环，因为`useEffect`在依赖数组中有`resert`。

> 重要提示:*依赖关系数组是 React 钩子用来理解它们何时需要再次运行的元素列表。在内部他们做一个燕子比较* `*deps[i] === deps[i]*` *，如果是假的就运行钩子。
> 如果我们回到上面的比较代码，我们可以看到，对于基元来说，这没问题，但是对于对象来说，我们需要小心，因为它们看起来相同是不够的，* ***它们需要相同*** *。*

useCounter hook returns always new references

这里的解决方案是使用记忆化，因此，除非我们需要更新它们，否则我们将始终保持相同的引用。在这种情况下，我们可以将`reset`包装到`useCallback`中，这样就可以解决问题了。

Keep the same references memoizing the values where possible

注意到`time`仍然在创建一个新的引用吗？当我们使用记忆时，我们需要一个一个地考虑。在这里，`time`使用每秒更新一次的`count`，因此将其封装到`useMemo`中不会改变实现，但只会占用更多的内存空间，而没有任何回报。假设在这种情况下这是意料之中的。

回到我们的闭包，请记住，在我们使用回调的地方使用这些类型的钩子，我们总是创建一个使用其作用域内的**值的闭包，所以我们需要确保传递正确的依赖关系。在任何情况下，React 都很好地指出了我们应该在什么时候向 linter 错误的依赖数组中添加什么。**

## 外卖食品

这篇文章的主要目标是理解在我们的组件和钩子内部发生的一切都只是 JavaScript，一旦我们理解了这一点，就不再有魔法了。

让我们回顾一下:

*   作用域是我们保存变量和声明的环境的集合，这些变量和声明只能由同一个作用域或内部作用域访问。
*   闭包是使这些作用域可访问的函数，并允许我们保存这些值的记忆。
*   在 React 中，**每个渲染都是一个新的函数调用**，每个函数调用都用新的变量和声明来设置它的新作用域。
*   当我们用`setState`更新状态时，我们实际上是在更新`useState`钩子内部的值，而不是组件内部的值。该组件将在下一次调用中接收新的更新值。
*   当我们调用`setState`时，如果我们想确保使用最新的值，我们可以使用更新器`setState(last => last + new)`
*   当我们比较对象、函数和数组时，我们比较的是它们的引用(内存中保存元素的地址)，而不是它们是否有相同的属性和值。
*   当我们将依赖项传递给钩子时，我们需要确保每次都不会通过记住它们的声明来传递新的引用。

*更多内容请看*[***plain English . io***](https://plainenglish.io/)*。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。关注我们关于*[***Twitter***](https://twitter.com/inPlainEngHQ)[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*[***YouTube***](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw)*[***不和***](https://discord.gg/GtDtUAvyhW) *。对增长黑客感兴趣？检查* [***电路***](https://circuit.ooo/) *。***