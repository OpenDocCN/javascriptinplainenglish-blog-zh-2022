<html>
<head>
<title>Build a GraphQL API Using Firebase Functions and Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Firebase函数和Apollo构建一个GraphQL API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-graphql-api-using-firebase-functions-and-apollo-9fd56649e556?source=collection_archive---------0-----------------------#2022-01-23">https://javascript.plainenglish.io/building-a-graphql-api-using-firebase-functions-and-apollo-9fd56649e556?source=collection_archive---------0-----------------------#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="852b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为了在我的web应用程序中构建灵活性，我想放弃使用Firebase SDK &amp;使用GraphQL，但是我如何在Firebase上运行Apollo呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4b83501016e3148f11fc33b60452dc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CTHLfY1_Bp2rpAJf"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@baciutudor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tudor Baciu</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f365" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在2021年10月推出<a class="ae kv" href="https://reciprocal.dev" rel="noopener ugc nofollow" target="_blank"> Reciprocal.dev </a> alpha之后，我开始研究我们整合的产品如何与我们着手解决的问题保持一致。</p><p id="c3e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我对完成的产品感到满意，但我脑海中有一种挥之不去的感觉——我们已经开发了一个允许用户构建交互式用户旅程地图的web应用程序，但当我们第一次定义对这样一个产品的需求时，我们正在Miro中构建我们的用户旅程地图。</p><p id="539f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">意识到这一点后，我做了一个概念验证，证明从我们的网络应用程序中引入<a class="ae kv" href="https://colinwren.medium.com/my-experiences-building-a-plugin-of-my-app-for-miro-8bbcf1ecd95c" rel="noopener">产品并将其翻译成Miro插件</a>是多么容易，尽管我们仍在评估其结果，但它凸显了一个可能被我们的技术实现所阻碍的潜在商业机会。</p><p id="96a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">alpha的数据模型非常专注于web应用程序所需的数据，我们广泛使用了Firebase SDK，这意味着支持该数据的多个前端是不可行的，因为每个系统的SDK在画布上定义实体的方式不同，并且对可用的库有所限制。</p><p id="3b1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在日常工作中一直在使用<a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>,觉得类型条件功能很适合我们的问题，因为它允许Miro插件请求对象的Miro表示，web应用程序可以请求web应用程序表示，同时保持其余数据的结构不变。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/66bb27c508a97a9e53cf752a0b1d7640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*nMLEOmaMDFy7pLxyTjvCJw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A pseudo-code query of how the type conditional and inline fragment functionality of GraphQL would allow for different data to be returned based on the representation needed by the front-end</figcaption></figure><p id="61f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用GraphQL(或任何API)还将允许根据接口构建前端，这意味着我们可以在不影响前端的情况下重构后端，前提是接口没有被破坏。</p><p id="b273" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前端，使用API的决定也应该消除后端调用对Firebase SDK的依赖，因为我一直使用<code class="fe lt lu lv lw b">functions.httpsCallable</code>来节省时间，因为这使得后端实现中的身份验证工作更容易。</p><p id="8625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前端不需要使用Firebase SDK来进行身份验证、加载/保存数据和处理存储，这意味着如果我们希望迁移到另一个技术堆栈，前端现在将更加易于移植。</p><p id="bdff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们同意投入时间来构建GraphQL API，我就开始构建一个运行在Firebase函数上的Apollo服务器来验证这种方法。</p><h1 id="fc9e" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">步骤1:构建模式</h1><p id="6ceb" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">不像REST API依赖于支持信息(Swagger、JSON schema等)。)为了定义从API返回的对象类型，GraphQL通过<a class="ae kv" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">将这些类型融入到API的定义中，该模式不仅定义了返回对象的类型，还定义了操作和这些操作的参数。</a></p><p id="2448" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您以前使用过JSON模式，那么您应该会发现使用GraphQL模式相对容易，尽管存在一些差异，例如GraphQL缺乏对<code class="fe lt lu lv lw b">Map</code> / <code class="fe lt lu lv lw b">Object</code> / <code class="fe lt lu lv lw b">Dict</code>对象的内置支持，并且需要单独的<code class="fe lt lu lv lw b">Input</code>类型作为参数，即使它们与模式中的另一种类型相同。</p><p id="b05d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraphQL服务器在运行时使用该模式来确定服务器将公开哪些查询和变化，并将使用该模式来验证对这些操作的调用，因此首先开始构建模式对我来说是有意义的。</p><p id="1dcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢<a class="ae kv" href="https://medium.com/geekculture/documenting-the-context-behind-your-code-with-architectural-decision-records-110a8db4d653" rel="noopener">在我的代码库中使用架构决策记录(ADR)</a>,因为这允许我捕捉我所做决策的相关信息，这样我就可以在以后不得不重构代码时查看笔记。因此，我创建了一个新的ADR来捕获更改现有数据模型的决策，这是通过为TypeScript中的每个实体构建一组类并使用这些对象构建GraphQL架构来实现的，使用代码生成工具来构建可在TypeScript中使用的类型。</p><p id="881c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为ADR的一部分，我捕获了将对步骤和连接实体进行的更改，以允许定义这些对象的多种表示，这样系统就可以支持多个前端。</p><p id="e027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用<a class="ae kv" href="https://mermaid-js.github.io/mermaid/#/" rel="noopener ugc nofollow" target="_blank"> Mermaid </a>来定义类图，这样就有了变化的可视化表示，因为这样更容易理解。</p><div class="kg kh ki kj gt ab cb"><figure class="mu kk mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/b5322729d20a509bc59dae65daf50190.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*1vt0uKo8SulMkAUSkIcrCg.jpeg"/></div></figure><figure class="mu kk na mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/9bb480e28bb24b9d007d99690cfd373b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*9HsW3WCt4hSy6yjPlBw3Zw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk nb di nc nd">The data model for Steps and Connections. On the left is the original which was heavily tied to one way of representing the object. On the right is the solution which allows for multiple representations of the same object</figcaption></figure></div><p id="682a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建模式时，我使用了<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.npmjs.com/package/graphql-schema-linter" rel="noopener ugc nofollow" target="_blank">graphql-schema-linter</a></code>工具来确保我的模式是有效的(尽管由于与我的连接实体的命名冲突，我不得不禁用与中继相关的规则),一旦模式构建完成，我就启动一个本地Apollo服务器来验证定义是否正确注册。</p><h1 id="dd43" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">步骤2:让Apollo服务器运行在Firebase函数上</h1><p id="2ccd" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">构建了模式并验证了它的正确性后，我继续研究如何在Firebase函数上运行GraphQL服务器。我选择了<a class="ae kv" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>来做这件事，因为它是我最有经验的GraphQL服务器。</p><p id="5044" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最初在Google上搜索如何做到这一点，返回了两种方法，一种是使用<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.npmjs.com/package/apollo-server-express" rel="noopener ugc nofollow" target="_blank">apollo-server-express</a></code>然后使用它，因为Firebase函数与Express兼容，另一种是使用<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.npmjs.com/package/apollo-server-cloud-functions" rel="noopener ugc nofollow" target="_blank">apollo-server-cloud-functions</a></code>，它提供了另一种方法的包装器，因此需要编写的代码更少。</p><p id="c92c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我遵循<a class="ne nf ep" href="https://medium.com/u/73ed71c0e436?source=post_page-----9fd56649e556--------------------------------" rel="noopener" target="_blank"> Fabio </a>的建议，采用了<code class="fe lt lu lv lw b">apollo-server-cloud-functions</code>的方法(<a class="ae kv" href="https://medium.com/@piuccio/running-apollo-server-on-firebase-cloud-functions-265849e9f5b8" rel="noopener">https://medium . com/@ piu ccio/running-Apollo-server-on-firebase-cloud-Functions-265849 e9 F5 b 8</a>)，但是因为我在Firebase函数代码库中使用了TypeScript，所以我在<code class="fe lt lu lv lw b">apollo-server-express</code>中遇到了一个问题，因为CORS的类型定义导致了编译错误。</p><p id="3264" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决<code class="fe lt lu lv lw b">apollo-server-express</code>中类型的问题，我必须将<code class="fe lt lu lv lw b">skipLibCheck: true</code>添加到我的<code class="fe lt lu lv lw b">tsconfig.json</code>中，这是我从这个Github问题中找到的:<a class="ae kv" href="https://github.com/apollographql/apollo-server/issues/927#issuecomment-445537360" rel="noopener ugc nofollow" target="_blank">https://Github . com/apollographql/Apollo-server/issues/927 # issue comment-445537360</a></p><p id="11f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我解决了类型问题，我就能够让Apollo服务器运行在Firebase模拟器上(可通过<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.npmjs.com/package/firebase-tools" rel="noopener ugc nofollow" target="_blank">firebase-tools</a></code>包安装),在复制了我的GraphQL模式并实现了一些虚拟解析器之后，我就能够使用一个<a class="ae kv" href="https://studio.apollographql.com/sandbox/explorer" rel="noopener ugc nofollow" target="_blank"> pollo Sandbox Explorer </a>来测试API。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A basic Apollo server on Firebase Functions, this would usually expose the GraphQL server on https://localhost:5001/[project name]/[deployment locale]/GraphQL which can be used in the Apollo Sandbox Explorer to interact with it</figcaption></figure><h1 id="a76f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">步骤3:让GraphQL模式更有用</h1><p id="169a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">虽然GraphQL服务器使用的模式对于允许API消费者知道发送什么和他们将接收什么非常有用，但是如果应用程序代码本身可以使用实体类型以便更快地捕捉错误，该模式将会更加有用。</p><p id="90fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，有一种方法可以做到这一点，那就是使用<a class="ae kv" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank">一个名为</a> <code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank">graphql-codegen</a></code> <a class="ae kv" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank">的工具，它获取GraphQL模式并将其转换成代码</a>。对于我的用例，我只需要生成一组可以在我的TypeScript代码中使用的类型，但是使用该工具可以有多种方式来使用该模式。</p><p id="b3d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了生成我需要的类型，我最终配置了<code class="fe lt lu lv lw b">graphql-codegen</code>来创建一个包含操作和解析器的<code class="fe lt lu lv lw b">types.d.ts</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The GraphQL codegen config used to generate the types files that could be used in downstream TypeScript projects to add type checks based on the GraphQL schema</figcaption></figure><p id="5be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我从模式中生成了类型，下一步就是发布模式和类型，这样它们就可以被下游服务使用，比如我的Firebase函数代码、web应用程序和Miro插件。</p><p id="0722" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，在将模式文件和生成的<code class="fe lt lu lv lw b">types.d.ts</code>添加到<code class="fe lt lu lv lw b">package.json</code>中的<code class="fe lt lu lv lw b">files</code>数组之前，我确保它们都在repo的根目录下(即不在目录下)。这意味着当运行<code class="fe lt lu lv lw b">npm publish</code>时，两个文件都将被打包，并可从库的根目录访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Example of package.json set up for publishing library with both schema and generated types</figcaption></figure><h1 id="96e6" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">步骤4:从库中加载GraphQL模式</h1><p id="63b5" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在将模式和类型发布为库以供下游使用之后，下一步是从GraphQL Firebase函数使用的Apollo服务器配置中的库中导入模式。</p><p id="78ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了从文件中加载模式，并将其用作Apollo配置的<code class="fe lt lu lv lw b">typeDefs</code>值，我需要从<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.npmjs.com/package/@graphql-tools/graphql-file-loader" rel="noopener ugc nofollow" target="_blank">@graphql-tools/graphql-file-loader</a></code>库导入<code class="fe lt lu lv lw b">GraphQLFileLoader</code>，并从<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.npmjs.com/package/@graphql-tools/load" rel="noopener ugc nofollow" target="_blank">@graphql-tools/load</a></code>库将此实例传递给<code class="fe lt lu lv lw b">loadTypedefsSync</code>的<code class="fe lt lu lv lw b">loaders</code>参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">By loading the schema from the library there’s a single source of truth for the schema and within that schema repo I’m free to use whatever tools I need to when building it before publishing the schema</figcaption></figure><h1 id="e12d" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">步骤5:认证用户</h1><p id="1a42" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">除了一两个例外，我正在构建的API将处理的大多数操作都要求对用户进行身份验证，以便后端可以处理他们有权访问的记录。</p><p id="e714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在后端alpha实现中，任何认证需求都是通过使用<code class="fe lt lu lv lw b"><a class="ae kv" href="https://firebase.google.com/docs/functions/callable" rel="noopener ugc nofollow" target="_blank">requests.onCall</a></code>函数来处理的，因为这些函数会处理认证并通过上下文对象向函数提供认证数据。</p><p id="a317" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前端alpha实现中，这些函数将使用Firebase SDK的一部分<code class="fe lt lu lv lw b"><a class="ae kv" href="https://firebase.google.com/docs/functions/callable" rel="noopener ugc nofollow" target="_blank">functions.httpsCallable</a></code>来调用。这将负责前端代码所需的任何身份验证。</p><p id="aec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">alpha实现对Firebase SDK的依赖意味着我没有在该SDK之外进行身份验证的现有实现。幸运的是，Firebase admin SDK提供了为用户创建jwt的方法，以及在使用这些令牌进行身份验证时验证它们的方法。</p><p id="d056" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Apollo服务器没有被定义为一个普通的Firebase函数，所以我不能只在函数实现的开头添加一个检查，相反，我需要使用Apollo服务器配置的<code class="fe lt lu lv lw b">context</code>属性来定义一个回调，该回调可以检查身份验证并向Apollo上下文添加任何相关的值，以便解析器稍后使用。</p><p id="fab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个Apollo上下文非常方便，不仅可以从JWT获取用户的ID，还可以让解析器访问在顶层功能模块中创建的Firestore实例，因为这样可以将代码分开，以便于维护。</p><h2 id="8bf6" class="ni ly iq bd lz nj nk dn md nl nm dp mh lf nn no mj lj np nq ml ln nr ns mn nt bi translated">创造一个JWT</h2><p id="9272" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Firebase admin SDK有一个<code class="fe lt lu lv lw b">admin.auth().createCustomToken</code>功能，可以创建一个可用于验证用户身份的JWT。可以向该函数传递一组用户数据来生成令牌，最低要求是提供用户的ID。</p><h2 id="bfb4" class="ni ly iq bd lz nj nk dn md nl nm dp mh lf nn no mj lj np nq ml ln nr ns mn nt bi translated">验证JWT</h2><p id="faec" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在GraphQL上下文回调中，可以从通过<code class="fe lt lu lv lw b">request.headers.authorization </code>路径传递给回调的请求对象中访问JWT。</p><p id="916d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">验证JWT的函数要求字符串只包含令牌，因此在读取<code class="fe lt lu lv lw b">authorization</code>头时，您需要去掉字符串的<code class="fe lt lu lv lw b">Bearer </code>部分。</p><p id="78b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Firebase admin SDK有一个<code class="fe lt lu lv lw b">admin.auth().verifyIdToken</code>函数，将JWT解码成一个对象，您可以从so中读取编码值。用户的ID可以在这个解码对象的<code class="fe lt lu lv lw b">uid</code>属性下找到。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Verifying the JWT within the GraphQL context and setting the userId and Firestore instance in the context so it’s available to the resolvers</figcaption></figure><h2 id="ec7d" class="ni ly iq bd lz nj nk dn md nl nm dp mh lf nn no mj lj np nq ml ln nr ns mn nt bi translated">仿真器陷阱</h2><p id="cd68" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">通过<code class="fe lt lu lv lw b">createCustomToken</code>创建的JWT无法被<code class="fe lt lu lv lw b">verifyIdToken</code>验证，因为<code class="fe lt lu lv lw b">aud</code>属性与<code class="fe lt lu lv lw b">verifyIdToken</code>预期的不同。为了创建具有正确<code class="fe lt lu lv lw b">aud</code>属性的令牌，需要进行一个额外的调用，该调用将产生一个可以验证的JWT。</p><p id="befb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您通过<code class="fe lt lu lv lw b">createCustomToken</code>生成了JWT，您需要将该令牌作为POST的一部分发送给可通过认证仿真器使用的<code class="fe lt lu lv lw b"> /www.googleapis.com/identitytoolkit/v3/relyingparty/verifyCustomToken</code>端点，当您将<code class="fe lt lu lv lw b">returnSecureToken</code>设置为true时，它将返回一个可以正常工作的JWT。下一步中的代码显示了如何做到这一点。</p><h1 id="6ded" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">第六步:测试一切正常</h1><p id="a831" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">现在，在Apollo中设置了身份验证，是时候尝试一个示例调用了，但是为了做到这一点，我们需要创建一个用户，创建一个JWT令牌来对他们进行身份验证，并创建一些要返回的测试数据。</p><p id="3a3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还没有启用认证或Firestore模拟器，那么您可以运行<code class="fe lt lu lv lw b">firebase init</code>并选择要安装的附加模拟器。</p><p id="de45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在身份验证模拟器下，您将看到一个带有“添加用户”按钮的用户列表，当按下该按钮时，将向您显示一个创建新用户的表单。您可以通过提供电子邮件地址和密码来创建新用户。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/3f9776d42fa7803238eefc0149c577a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0Kblygo12DvNW0IK0yVmg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The authentication emulator UI with created user</figcaption></figure><p id="3472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你创建了一个用户，你在系统中就有了一个用户，你可以创建一个使用<code class="fe lt lu lv lw b">createCustomToken</code>的JWT，但是你需要提供用户的UID给那个函数，并且创建的令牌需要通过<code class="fe lt lu lv lw b">verifyCustomToken</code>转换成仿真器接受的令牌。</p><p id="4215" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让事情变得简单，我将令牌管理和测试数据创建整合到一个端点中，我可以将用户ID发送到这个端点，这个端点将返回模拟器友好的JWT。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">This endpoint takes the ID of the generated user, creates the test data in Firestore for the resolvers to work with, and creates a JWT that can be used to authenticate the user</figcaption></figure><p id="5488" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我使用返回的JWT在Apollo Sandbox Explorer UI中设置授权头(在操作面板的底部有一个提供变量和头的方法)。</p><p id="76df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在提供了我希望运行的查询所需的一些变量之后，我能够针对运行在Firebase Functions模拟器上的Apollo服务器成功地执行一个经过身份验证的GraphQL调用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/b10554b3fcf737823a420088e94f8099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7ncEdskngzM-oIuZfod9uQ.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Creating a user in Firebase auth emulator, using the endpoint to create the test data and the JWT to authenticate with, and then executing a query in the Apollo Sandbox Explorer UI</figcaption></figure><h1 id="5e14" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">摘要</h1><p id="2967" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在Firebase上运行GraphQL相对来说比较简单，但是如果您希望通过Firebase模拟器在本地进行测试，那么身份验证需要做更多的工作。</p><p id="e739" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过从使用Firebase SDK与Firestore交互到实现API来实现这一点，我们现在在如何重构应用程序以及如何发展<a class="ae kv" href="https://reciprocal.dev" rel="noopener ugc nofollow" target="_blank"> Reciprocal.dev </a>方面有了更多的灵活性。</p><p id="7219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用<code class="fe lt lu lv lw b">graphql-codegen</code>工具，我能够通过GraphQL模式获得我的应用程序中实体的一个真实来源，然后生成代码来帮助下游使用这些实体，例如TypeScript的类型定义。</p><h2 id="a935" class="ni ly iq bd lz nj nk dn md nl nm dp mh lf nn no mj lj np nq ml ln nr ns mn nt bi translated">进一步阅读</h2><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/i-built-a-serverless-live-chat-app-with-next-js-fauna-and-wundergraph-for-graphql-live-queries-b671d9646f6"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">我用Next.js、Fauna和WunderGraph为GraphQL实时查询构建了一个无服务器的实时聊天应用程序</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">使用无服务器技术创建可扩展的实时聊天应用程序的分步指南，来自…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://plainenglish.io/blog/how-to-build-a-graphql-ecommerce-app-from-scratch" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">如何从头开始构建一个GraphQL电子商务应用程序</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">这就是你要建造的东西！埃森哲的一项调查(19个国家的20，000多名消费者)发现，47%的人…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">简明英语. io</p></div></div><div class="oi l"><div class="oo l ok ol om oi on kp nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://plainenglish.io/blog/how-to-compose-and-integrate-apis-together-as-if-you-were-using-npm-for-apis" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">如何将API组合和集成在一起，就像您正在使用API的NPM一样</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">将两个API整合到一个应用程序中，该应用程序显示了历史上最大的音乐会，按国家首都排列。与……</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">简明英语. io</p></div></div><div class="oi l"><div class="op l ok ol om oi on kp nz"/></div></div></a></div><p id="80c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oq">更多内容尽在</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oq">说白了. io </em> </strong> </a> <em class="oq">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oq">免费周报</em> </strong> </a> <em class="oq">。关注我们关于</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oq">推特</em> </strong> </a>，<a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oq">LinkedIn</em></strong></a><em class="oq">，</em><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oq">YouTube</em></strong></a><em class="oq">，</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oq">不和</em> </strong> </a> <em class="oq">。对增长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oq">电路</em> </strong> </a> <em class="oq">。</em></p></div></div>    
</body>
</html>