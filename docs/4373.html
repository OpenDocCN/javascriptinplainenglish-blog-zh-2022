<html>
<head>
<title>How to Keep Your Sanity While Working with Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在使用Git时保持理智</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-keep-your-sanity-while-working-with-git-2e1be74dfb01?source=collection_archive---------9-----------------------#2022-11-25">https://javascript.plainenglish.io/how-to-keep-your-sanity-while-working-with-git-2e1be74dfb01?source=collection_archive---------9-----------------------#2022-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a2af8596ccf96b334411ef1241d7f8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nlSk9kmujri4AWKg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Illustration by the author</figcaption></figure><p id="2f51" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Git很难。最重要的是，对于许多新开发人员来说，这是他们使用的第一个带有命令行界面(CLI)的工具。如果您同时学习以下所有内容，这可能有点太多了:</p><ul class=""><li id="ad6b" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">如何使用CLI</li><li id="1a1d" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">如何使用Git</li><li id="b92e" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">最后但同样重要的是:编程</li></ul><p id="9c35" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我将向您展示一些技巧，让您的Git体验不那么痛苦，更有趣！</p><h1 id="74c1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">检查您的状态</h1><p id="ab9d" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">Git足够慷慨，可以提供许多命令来检查您的存储库的状态，但也足够谨慎，不会用冗长来淹没初学者。简而言之——你应该让Git给你你需要的细节。您有以下命令:</p><h1 id="3a1b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">git状态</h1><p id="a295" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">这是一个关键命令，可以让您了解自己在Git中的位置。输出示例:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="2f46" class="na lp iq mw b be nb nc l nd ne">$ git status<br/>On branch main<br/>Your branch is up to date with 'origin/main'.<br/><br/>nothing to commit, working tree clean</span></pre><p id="d579" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当你在一个干净的树枝上时</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="6c58" class="na lp iq mw b be nb nc l nd ne">$ git status<br/>HEAD detached at abc01e7<br/>nothing to commit, working tree clean</span></pre><p id="d13f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当你处于<a class="ae nf" href="https://how-to.dev/the-detached-head-state-in-git-what-it-is-and-how-to-fix-it" rel="noopener ugc nofollow" target="_blank">分离头状态</a>时。</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="6469" class="na lp iq mw b be nb nc l nd ne">$ git status<br/>On branch main<br/>Your branch is up to date with 'origin/main'.<br/><br/>Untracked files:<br/>  (use "git add &lt;file&gt;..." to include in what will be committed)<br/>        lorem-ipsum.txt<br/><br/>nothing added to commit but untracked files present (use "git add" to track)</span></pre><p id="1555" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您的工作副本中有一些新文件时。</p><h1 id="8e0b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">git show</h1><p id="2006" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">这是一个允许您查看提交中发生的更改的命令。当不带参数运行时，它显示当前提交:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="8417" class="na lp iq mw b be nb nc l nd ne">$ git show<br/>commit abc01e761cb9cc14c4d5aecae2488810c834c0f9 (HEAD -&gt; main, origin/main, <br/>origin/HEAD)<br/>Author: Marcin Wosinek &lt;marcin.wosinek@gmail.com&gt;<br/>Date:   Wed Nov 2 11:57:33 2022 +0100<br/><br/>    Add lorem ipsum to readme<br/><br/>diff --git a/README.md b/README.md<br/>index 8ae0569..9dca8b4 100644<br/>--- a/README.md<br/>+++ b/README.md<br/>@@ -1 +1,2 @@<br/> # Test<br/>+Lorem ipsum</span></pre><p id="898e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以获得关于提交的所有细节:作者、时间、消息和每个被更改文件的差异。</p><p id="96cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以指定想要查看的任何提交:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="c138" class="na lp iq mw b be nb nc l nd ne">$ $ git show edd3504<br/>commit edd3504f6edc722482fa4383443fa1729acc9a87<br/>…rest of the output…</span></pre><p id="26ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意！该命令适用于<strong class="ke ir">提交</strong>。因此，如果您使用分支名称，它将显示来自该分支的最近提交:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="0e20" class="na lp iq mw b be nb nc l nd ne">$ git show main<br/>commit abc01e761cb9cc14c4d5aecae2488810c834c0f9 (HEAD -&gt; main, origin/main, origin/HEAD)<br/>Author: Marcin Wosinek &lt;marcin.wosinek@gmail.com&gt;</span></pre><h1 id="b30e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><code class="fe ng nh ni mw b">git tree — </code>一个我推荐给大家的自定义别名</h1><p id="2bed" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">为了查看所有分支的图形，我建议定义一个树别名——您可以在这篇文章<a class="ae nf" href="https://how-to.dev/how-to-display-git-branches-as-a-tree-in-cli" rel="noopener ugc nofollow" target="_blank">中了解更多。有了它，您可以运行:</a></p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="bd8e" class="na lp iq mw b be nb nc l nd ne">$ $ git tree<br/>* 11f7f3c (test) add test.txt file<br/>| * 2dbd30f (origin/test) add test.txt file<br/>| * e7be203 (test-2) add new file<br/>|/<br/>* abc01e7 (HEAD -&gt; main, origin/main, origin/HEAD) Add lorem ipsum to readme<br/>* edd3504 Add readme</span></pre><p id="c737" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并获得整个存储库的概览。</p><h1 id="3f63" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">检查您的默认编辑器是什么</h1><p id="f717" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">在某些情况下，Git希望您通过编辑它创建的临时文件向它提供输入。这个工作流程一开始可能会令人困惑，如果您不知道您的默认编辑器，情况会更糟。下面是如何通过列出Git的逻辑变量并过滤出包含<code class="fe ng nh ni mw b">EDITOR</code>的变量来检查它。在我的MacOS上，它是<code class="fe ng nh ni mw b">vi</code>:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="51d4" class="na lp iq mw b be nb nc l nd ne">$ git var -l | grep EDITOR<br/>GIT_EDITOR=vi</span></pre><p id="028d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样，在Ubuntu上:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="b9dc" class="na lp iq mw b be nb nc l nd ne">$ git var -l | grep EDITOR<br/>GIT_EDITOR=editor</span></pre><p id="db77" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Ubuntu上，<code class="fe ng nh ni mw b">editor</code>是一个启动默认文本编辑器的命令。在我能使用的一台机器上，它是<code class="fe ng nh ni mw b">nano</code>:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="dfb5" class="na lp iq mw b be nb nc l nd ne">$ update-alternatives --display editor<br/>editor - auto mode<br/>  link best version is /bin/nano<br/>  link currently points to /bin/nano<br/>…</span></pre><p id="0f2f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不管你的编辑是谁，确保你知道如何做以下事情:</p><ul class=""><li id="8b8a" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">编辑文件——由于界面的各种模式，这对于<code class="fe ng nh ni mw b">Vim</code>的初学者来说是一个挑战</li><li id="4429" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">保存更改</li><li id="ea8b" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">退出编辑器</li></ul><p id="ad53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，把编辑器换成你知道怎么用的。</p><h1 id="dc6c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">键入命令时使用tab键</h1><p id="c892" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">Git命令、所有属性和分支名称都很长；并且接口不接受任何错误。提高效率的关键是不要把它们全打出来。在大多数shell中，当您按tab键时，shell会:</p><ul class=""><li id="36e6" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">显示所有可用的命令自动完成</li><li id="c079" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">如果只有一个可用命令，则选择该命令</li></ul><p id="7f54" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，例如，对于我使用的<code class="fe ng nh ni mw b">zsh</code> shell，让我们在键入<code class="fe ng nh ni mw b">git co&lt;tab&gt;</code>后看到这些选项:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="78b4" class="na lp iq mw b be nb nc l nd ne">$ git co<br/>Completing main porcelain command<br/>commit        -- record changes to repository<br/>Completing ancillary manipulator command<br/>config        -- get and set repository or global options<br/>Completing ancillary interrogator command<br/>count-objects -- count unpacked objects and display their disk consumption<br/>Completing plumbing manipulator command<br/>commit-graph  -- write and verify Git commit-graph files<br/>commit-tree   -- create new commit object<br/>Completing plumbing internal helper command<br/>column        -- display data in columns</span></pre><p id="3f68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我输入<code class="fe ng nh ni mw b">git com&lt;tab&gt;</code>的时候完成这个单词:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="9181" class="na lp iq mw b be nb nc l nd ne">$ git commit</span></pre><p id="2c96" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样，它为参数、分支名称等提供了自动完成功能。打字的时候差别很大。</p><h1 id="93f8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用箭头</h1><p id="e935" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">看着某人重新输入他们刚才使用的整个命令是一种痛苦的经历。大多数shells允许您通过使用箭头键来重用最后一个命令。向上箭头键显示最近的命令，再次键入它将显示前一个命令，依此类推。找到您需要的后，您可以编辑它以匹配您正在执行的操作。</p><h1 id="572c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">随时获取远程更改</h1><p id="7582" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">我总是将我的本地存储库与远程存储库同步——甚至在我的私人存储库中，我知道我是一个人在工作。不注意别人在改变什么，很容易把事情搞砸。只需一个命令就能确保一切都是最新的:</p><pre class="mr ms mt mu gt mv mw mx bn my mz bi"><span id="d066" class="na lp iq mw b be nb nc l nd ne">$ git fetch</span></pre><p id="c51c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行之后，您知道您在本地看到的每一个<code class="fe ng nh ni mw b">origin/&lt;branch-name&gt;</code>引用都在与远程相同的位置。</p><p id="c710" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">解决冲突有时很痛苦，但没有什么比本可以轻松避免的冲突更令人痛苦。当人们引入不必要的冲突时，一个常见的场景是当他们在最近的提交之后开始一个新的分支。这可以通过以下方式轻松避免:</p><ul class=""><li id="8921" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">一直在捡东西</li><li id="3ce3" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">注意你在历史树中的位置</li></ul><h1 id="8605" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">短命的树枝</h1><p id="32ec" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">快速合并分支有几个好处:</p><ul class=""><li id="12bf" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">新特性会更快地集成到代码库中。如果它们没有完全准备好，它们总是可以被特征标志隐藏。</li><li id="97ae" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">主分支和另一个分支中较少的变化意味着冲突的风险较小，</li><li id="2395" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">更小的分支意味着需要审查的代码更少。</li></ul><p id="6138" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">短命的分支是通过小的交互来进步的一种方式——这是我在另一篇文章中推荐的。</p><h1 id="847e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">要避免的事情</h1><p id="1762" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">我经常看到初学者遇到我不需要处理的问题，因为我在Git中避免了以下事情:</p><h1 id="1c8e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">git拉</h1><p id="f806" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">在Git中，pull将两个操作合并为一个:</p><p id="55bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我总是想在进行合并或重置之前仔细检查我的远程状态<strong class="ke ir">。所以我的典型流程是:</strong></p><ul class=""><li id="b372" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><code class="fe ng nh ni mw b">git fetch</code>-从远程获取更新，</li><li id="9e3f" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe ng nh ni mw b">git tree</code>-我上面提到的别名，为了确保回购处于我期望的状态，</li><li id="2501" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe ng nh ni mw b">git rebase origin/&lt;branch-name&gt;</code>-当远程和本地发生变化时，或</li><li id="8b25" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">` git merge origin/-当远程上有更改而本地上没有时。也就是说，它可以作为快进合并来完成。</li></ul><h1 id="4da8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Git子模块</h1><p id="649b" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">最后，子模块是将一个或多个Git存储库嵌入另一个存储库的一种方式。内部存储库维护其单独的历史记录，而包含它的存储库只保存对内部repo应该在的源和当前提交的引用。</p><p id="993e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我对于Git子模块的主要问题是，它们使已经很困难的问题——版本控制——变得更加复杂，并且增加了更多的复杂性。</p><p id="cd61" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Git子模块为问题提供了另一种解决方案，可以通过以下方式更好地解决:</p><ul class=""><li id="53f7" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">使用一些包管理器(比如npm)来实现外部依赖</li><li id="5faa" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">将多个存储库合并为一个以实现内部依赖性</li></ul><h1 id="5100" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">下一步是什么</h1><p id="70f1" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">当您开始使用Git时，它有许多令人困惑的方面，但是一旦您理解了它，它就会变得简单得多。如果你有兴趣了解更多关于Git的知识，在这里注册<a class="ae nf" href="https://how-to-dev.ck.page/e92d2eb5d7" rel="noopener ugc nofollow" target="_blank">来获取我的Git相关内容的更新。</a></p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="f94c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nq">原发布于</em><a class="ae nf" href="https://how-to.dev/how-to-keep-your-sanity-while-working-with-git" rel="noopener ugc nofollow" target="_blank"><em class="nq">https://how-to . dev</em></a><em class="nq">。</em></p><p id="33b6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nq">更多内容看</em> <a class="ae nf" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nq">说白了。报名参加我们的</em> <a class="ae nf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nq">免费周报</em> </strong> </a> <em class="nq">。关注我们关于</em> <a class="ae nf" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nq">推特</em> </strong> </a>，<a class="ae nf" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="nq">LinkedIn</em></strong></a><em class="nq">，</em><a class="ae nf" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="nq">YouTube</em></strong></a><em class="nq">，以及</em> <a class="ae nf" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nq">不和</em> </strong> </a> <em class="nq">。对增长黑客感兴趣？检查</em> <a class="ae nf" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nq">电路</em> </strong> </a> <em class="nq">。</em></strong></a></p></div></div>    
</body>
</html>