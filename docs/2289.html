<html>
<head>
<title>Most Popular JavaScript Arrow Functions Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了最流行的JavaScript箭头函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/most-popular-javascript-arrow-functions-explained-39dee313c8d6?source=collection_archive---------5-----------------------#2022-05-27">https://javascript.plainenglish.io/most-popular-javascript-arrow-functions-explained-39dee313c8d6?source=collection_archive---------5-----------------------#2022-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5609" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数组map()，reduce()，filter()，forEach()，some()和every()函数讲解。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/c53f5d18771b19b92e8f199be6f1312f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YjvglJjLuvTwS2y0.png"/></div></figure><h1 id="3677" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">介绍</h1><p id="fa74" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">JavaScript引入了箭头函数表达式，它是可选的，语法比标准函数更紧凑。</p><p id="6507" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这些箭头函数因其简洁的风格和易用性而变得非常流行。</p><p id="44d8" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">让我们直接跳到一些例子。</p><h1 id="a59b" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">箭头功能</h1><p id="15bb" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">箭头函数的基本语法是，括号<code class="fe mg mh mi mj b">() </code>内有<code class="fe mg mh mi mj b">parameters</code>，后跟指向函数体的箭头<code class="fe mg mh mi mj b">=&gt;</code>。如果不需要<code class="fe mg mh mi mj b">param</code>，我们可以省略它，不要用括号<code class="fe mg mh mi mj b">()</code>:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="b4ce" class="mo ko iq mj b gy mp mq l mr ms">// No param required. body is one line return statement<br/>() =&gt; body</span><span id="ac55" class="mo ko iq mj b gy mt mq l mr ms">Example:</span><span id="858b" class="mo ko iq mj b gy mt mq l mr ms">() =&gt; 'foo' // This function once called returns 'foo' string. </span></pre><p id="d0ba" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们刚刚创建了第一个<em class="mu">匿名</em>箭头函数！然而，为了调用它，我们要么需要传递它，要么指定一个名称:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="039b" class="mo ko iq mj b gy mp mq l mr ms">const bar = () =&gt; 'foo'</span></pre><p id="a4e7" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">现在我们可以这样称呼它:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="ea81" class="mo ko iq mj b gy mp mq l mr ms">bar(); // Returns 'foo'</span></pre><p id="c940" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这相当于遵循传统语法:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="e2db" class="mo ko iq mj b gy mp mq l mr ms">function bar() {<br/>    return 'foo';<br/>}</span></pre><p id="befa" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">或者如果我们想保持匿名功能:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="2756" class="mo ko iq mj b gy mp mq l mr ms">function () {<br/>    return 'foo';<br/>}</span></pre><h1 id="6fcb" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">将函数转换为箭头函数</h1><p id="a136" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以看到，有一种简单的方法可以将现有函数转换为箭头函数:</p><ul class=""><li id="eb9b" class="mv mw iq lh b li mb ll mc lo mx ls my lw mz ma na nb nc nd bi translated">删除<code class="fe mg mh mi mj b">function</code>关键字</li><li id="2ac3" class="mv mw iq lh b li ne ll nf lo ng ls nh lw ni ma na nb nc nd bi translated">在<code class="fe mg mh mi mj b">()</code>和开口支架<code class="fe mg mh mi mj b">{</code>之间增加箭头<code class="fe mg mh mi mj b">=&gt;</code></li><li id="d53d" class="mv mw iq lh b li ne ll nf lo ng ls nh lw ni ma na nb nc nd bi translated">如果给定的函数可以简化为一行，我们可以另外删除函数的开括号和闭括号<code class="fe mg mh mi mj b">{ }</code>并删除<code class="fe mg mh mi mj b">return</code>关键字，因为return是隐含的。</li></ul><h1 id="9449" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">Array.map</h1><p id="b26f" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最常用和最流行的函数之一是<code class="fe mg mh mi mj b">Array.map</code>，它接受一个数组并根据给定的函数返回转换(映射)的值:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="1280" class="mo ko iq mj b gy mp mq l mr ms">const result = array.map(function)</span></pre><p id="c6de" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这里我们可以提供传统功能举例:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="397c" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="5e01" class="mo ko iq mj b gy mt mq l mr ms">function double (value) {<br/>    return value * 2;<br/>};</span><span id="14e5" class="mo ko iq mj b gy mt mq l mr ms">const result = array.map(double); // Returns: [2, 4, 6, 8, 10]<br/>console.log(array); // Array hasn't changed: [1, 2, 3, 4, 5]</span></pre><p id="6c7c" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">正如我们所看到的，我们在这里没有使用箭头函数。然而，我们必须声明一个命名的函数，然后将该函数作为参数传递给<code class="fe mg mh mi mj b">map</code>函数，该函数遍历数组中的所有项，将每个项作为输入参数传递并返回新数组。</p><p id="e9bb" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">显然，我们可以使用匿名函数，并将其直接传递给<code class="fe mg mh mi mj b">map</code>:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="841d" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="c8a1" class="mo ko iq mj b gy mt mq l mr ms">const result = array.map(function (value) {<br/>    return value * 2;<br/>}); // Returns: [2, 4, 6, 8, 10]</span></pre><p id="f5c5" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这很好。我们甚至可以通过使用箭头函数语法来进一步简化这一过程:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="49fe" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="ff03" class="mo ko iq mj b gy mt mq l mr ms">const result = array.map(value =&gt; value * 2);</span></pre><p id="f532" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这非常简洁，也非常容易理解:我们有一个arrow函数，它将<code class="fe mg mh mi mj b">value</code>作为输入参数(arrow函数的左侧)，并返回<code class="fe mg mh mi mj b">value</code>乘以<code class="fe mg mh mi mj b">2</code>(arrow函数的右侧)。</p><h1 id="b6b1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">Array.reduce</h1><p id="2b30" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一个流行的函数是<code class="fe mg mh mi mj b">reduce</code>，它接受一个数组并将<em class="mu">简化的</em>结果返回为单个值。例如，我们可以将数组中的所有元素相加。</p><p id="9c80" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">为了将数组缩减为单个值，reduce需要至少两个输入参数:<code class="fe mg mh mi mj b">previousValue</code>和<code class="fe mg mh mi mj b">currentValue</code>(称为<em class="mu">聚合器</em>)。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="6807" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5]; // Sum: 1 + 2 + 3 + 4 + 5 = 15</span><span id="b55a" class="mo ko iq mj b gy mt mq l mr ms">const total = array.reduce((val, curr) =&gt; curr += val); // 15</span></pre><p id="ab37" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">为了更好地理解这一点，我们可以添加<code class="fe mg mh mi mj b">console.log</code>输出和第三个参数<code class="fe mg mh mi mj b">index</code></p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="9757" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5]; // Sum: 1 + 2 + 3 + 4 + 5 = 15</span><span id="c918" class="mo ko iq mj b gy mt mq l mr ms">const total = array.reduce((val, curr, index) =&gt; {<br/>    console.log(`val: ${val} curr: ${curr} index: ${index}`);<br/>    return curr += val;<br/>}); // 15</span></pre><p id="d821" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们的<code class="fe mg mh mi mj b">console.log</code>会是什么样子:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="5c95" class="mo ko iq mj b gy mp mq l mr ms">"val: 1  curr: 2 index: 1"<br/>"val: 3  curr: 3 index: 2"<br/>"val: 6  curr: 4 index: 3"<br/>"val: 10 curr: 5 index: 4"</span></pre><p id="019b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们可以看到我们实际上是从index: <code class="fe mg mh mi mj b">1</code>和<code class="fe mg mh mi mj b">array[1] = 2</code>(这是当前值)开始的。先前的值是<code class="fe mg mh mi mj b">array[0] = 1</code>。值1和2相加，并作为<em class="mu">上一个</em>值传递给下一次迭代(索引:2)。在<code class="fe mg mh mi mj b">array[2]</code>处，我们有值<code class="fe mg mh mi mj b">3</code>——我们将它们加在一起，得到<code class="fe mg mh mi mj b">6</code>。接下来，在<code class="fe mg mh mi mj b">array[3]</code>处，我们有值4，其加在一起是用于下一次迭代的先前值，依此类推。最终我们得到了预期的<code class="fe mg mh mi mj b">15</code>。</p><p id="f029" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">让我们注意，我们可以用某个值初始化<code class="fe mg mh mi mj b">reduce</code>。为此，我们将初始值作为第二个参数传递。例如，如果我们使用<code class="fe mg mh mi mj b">10</code>，那么我们的总和将是:<code class="fe mg mh mi mj b">10 + 1 + 2 + 3 + 4 + 5 = 25</code>:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="b5e1" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="fb2c" class="mo ko iq mj b gy mt mq l mr ms">const total = array.reduce((val, curr) =&gt; curr += val, 10);</span></pre><p id="5a7c" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">值得注意的是，如果我们使用初始值，那么<code class="fe mg mh mi mj b">reduce</code>将从索引<code class="fe mg mh mi mj b">0</code>开始，因为先前值是我们用来初始化<code class="fe mg mh mi mj b">reduce</code>函数的值，而当前值在索引<code class="fe mg mh mi mj b">array[0]</code>处，否则，所有工作完全相同。</p><h1 id="df94" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">数组.过滤器</h1><p id="2d7b" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数组<code class="fe mg mh mi mj b">filter</code>应该是不言自明的，它接受一个数组并返回另一个包含通过给定条件的值的数组。</p><p id="2959" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">例如，让我们只返回偶数(数除以2得到零余数):</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="dc97" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="5b94" class="mo ko iq mj b gy mt mq l mr ms">const even = array.filter(i =&gt; i % 2 === 0); // Returns: [2, 4]</span></pre><h1 id="9c8a" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">Array.forEach</h1><p id="5131" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数组<code class="fe mg mh mi mj b">forEach</code>基本上是一个循环，它等价于<code class="fe mg mh mi mj b">for</code>语法:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="4b62" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="23e5" class="mo ko iq mj b gy mt mq l mr ms">for (let i = 0; i &lt; array.length; i++) {<br/>    console.log(`value: ${array[i]} index: ${i}`);<br/>    // some statements here<br/>}</span></pre><p id="1793" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们可以使用<code class="fe mg mh mi mj b">forEach</code>语法:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="e773" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="74ff" class="mo ko iq mj b gy mt mq l mr ms">array.forEach((item, index) =&gt; {<br/>    console.log(`value: ${item} index: ${index}`);<br/>    // some statements here<br/>});</span></pre><h1 id="bd45" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">数组. some</h1><p id="a585" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Array <code class="fe mg mh mi mj b">some</code>函数遍历给定的数组，并试图找到至少一个(一些)满足给定函数逻辑的元素。例如，让我们检查某个数组元素是否大于<code class="fe mg mh mi mj b">10</code>:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="2266" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="7afb" class="mo ko iq mj b gy mt mq l mr ms">array.some(i =&gt; i &gt; 10); // returns false</span></pre><p id="342b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们可以改变我们的搜索标准，检查是否有低于<code class="fe mg mh mi mj b">3</code>的数字—在我们的例子中是<code class="fe mg mh mi mj b">1</code>和<code class="fe mg mh mi mj b">2</code>:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="42ba" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="6e32" class="mo ko iq mj b gy mt mq l mr ms">array.some(i =&gt; i &lt; 3); // returns true</span></pre><p id="c9ee" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这次我们得到了<code class="fe mg mh mi mj b">true</code>,因为一些元素符合我们的逻辑。</p><h1 id="f3d8" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">Array.every</h1><p id="91e4" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数组<code class="fe mg mh mi mj b">every</code>与前一个<code class="fe mg mh mi mj b">some</code>非常相似——这次所有(每个)元素都必须匹配:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="365b" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="070b" class="mo ko iq mj b gy mt mq l mr ms">array.every(i =&gt; i &gt; 10); // returns false</span></pre><p id="9932" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">让我们看看是否能找到低于或等于<code class="fe mg mh mi mj b">5</code>的元素:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="cdf9" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5];</span><span id="52b0" class="mo ko iq mj b gy mt mq l mr ms">array.every(i =&gt; i &lt;= 5); // returns true</span></pre><p id="c8c8" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">数组中的所有元素都匹配，因此我们得到了<code class="fe mg mh mi mj b">true</code>。</p><p id="1d66" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">然而，如果我们添加另一个项目或改变我们的数组:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="81c0" class="mo ko iq mj b gy mp mq l mr ms">const array = [1, 2, 3, 4, 5, 6];</span><span id="532a" class="mo ko iq mj b gy mt mq l mr ms">array.every(i =&gt; i &lt;= 5); // returns false</span></pre><p id="13f5" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">不出所料，我们得到了<code class="fe mg mh mi mj b">false</code>,因为数组中的元素并不都匹配。</p><h1 id="097e" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">结论</h1><p id="7d5d" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">箭头函数是使代码更整洁、更简洁的好方法。如今，理解箭头函数语法是必须的。</p><p id="8025" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在这个快速教程中，我们通过例子介绍了一些最流行的函数。</p><p id="0df4" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">如果你有任何问题，请在下面留下评论。不然就鼓掌跟我来！</p><p id="10b6" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最后，你可以看看我的其他教程:</p><ul class=""><li id="9e99" class="mv mw iq lh b li mb ll mc lo mx ls my lw mz ma na nb nc nd bi translated"><a class="ae nj" href="https://medium.com/better-programming/fibonacci-algorithm-in-javascript-45743f3a0ff6" rel="noopener">用JavaScript计算斐波那契数列最快最有效的方法</a></li><li id="827b" class="mv mw iq lh b li ne ll nf lo ng ls nh lw ni ma na nb nc nd bi translated"><a class="ae nj" href="https://betterprogramming.pub/how-to-use-custom-authorizer-in-aws-api-gateway-with-serverless-4ddf42f32390" rel="noopener ugc nofollow" target="_blank">如何在无服务器的AWS API网关中使用自定义授权器</a></li><li id="f3a9" class="mv mw iq lh b li ne ll nf lo ng ls nh lw ni ma na nb nc nd bi translated"><a class="ae nj" href="https://levelup.gitconnected.com/secure-coding-standards-114be27e1253" rel="noopener ugc nofollow" target="_blank">安全编码标准</a></li><li id="0ced" class="mv mw iq lh b li ne ll nf lo ng ls nh lw ni ma na nb nc nd bi translated"><a class="ae nj" href="https://medium.com/geekculture/javascript-destructuring-1319c1808399" rel="noopener"> JavaScript析构</a></li><li id="b18e" class="mv mw iq lh b li ne ll nf lo ng ls nh lw ni ma na nb nc nd bi translated"><a class="ae nj" href="https://medium.com/swlh/node-js-and-singleton-pattern-7b08d11c726a" rel="noopener"> Node.js和单例模式</a></li></ul><p id="456e" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><em class="mu">更多内容请看</em><a class="ae nj" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir"><em class="mu">plain English . io</em></strong></a><em class="mu">。报名参加我们的</em> <a class="ae nj" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir"> <em class="mu">免费周报</em> </strong> </a> <em class="mu">。关注我们关于</em><a class="ae nj" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir"><em class="mu">Twitter</em></strong></a><em class="mu">和</em><a class="ae nj" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir"><em class="mu">LinkedIn</em></strong></a><em class="mu">。查看我们的</em> <a class="ae nj" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir"> <em class="mu">社区不和谐</em> </strong> </a> <em class="mu">加入我们的</em> <a class="ae nj" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir"> <em class="mu">人才集体</em> </strong> </a> <em class="mu">。</em></p></div></div>    
</body>
</html>