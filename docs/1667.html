<html>
<head>
<title>JavaScript Tips: How to Write Clean Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript技巧:如何编写干净的函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-tips-how-to-write-clean-functions-5de971694d38?source=collection_archive---------6-----------------------#2022-04-11">https://javascript.plainenglish.io/javascript-tips-how-to-write-clean-functions-5de971694d38?source=collection_archive---------6-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ada" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这些技巧将使你的代码更容易维护，更容易阅读和理解。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8839b72674c1e9ed4edc3eb8f6b48e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-16VodFXNJdenk1uO5E8mg.png"/></div></div></figure><p id="7de5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本帖中，我们将介绍用JavaScript编写干净函数的简单技巧。遵循这些提示将使您的代码更易于维护，更易于阅读和理解。</p><p id="8b3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们开始吧！</p><h1 id="bcee" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">小心隐藏的副作用</h1><p id="93de" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">“纯”函数是描述这一规则的另一种方式。给定相同的输入，纯函数总是返回相同的结果。它们也没有任何隐藏的副作用，这意味着它们不会在自己的功能范围之外修改输入或数据。任何应用程序的大部分通常都可以这样编写。</p><p id="341a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，我并不是说所有的副作用都是不好的，应该避免。你的程序<em class="mk">有</em>有副作用。否则有什么意义呢？</p><p id="a7ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的技巧是在应用程序代码中增加副作用。例如，如果您正在编写一个从API获取数据的函数，这是一个副作用，您希望使它更加明显，并避免将其隐藏在函数调用堆栈中。</p><p id="9d51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的函数<strong class="kt ir"> <em class="mk">让</em> </strong>对其输入进行更改会怎样？您仍然可以通过创建输入对象的新副本而不是就地修改它来保持它的纯净。让我们比较两个例子:</p><p id="af48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不好:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="ed09" class="mq lo iq mm b gy mr ms l mt mu">function addProperty(obj, key, value) {<br/>    obj[key] = value;<br/>    return obj;<br/>}</span></pre><p id="9562" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="45ed" class="mq lo iq mm b gy mr ms l mt mu">function addProperty(obj, key, value) {<br/>    const newObj = { ...obj }<br/>    newObj[key] = value;<br/>    return newObj;<br/>}</span></pre><p id="0af1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个函数违反了避免副作用的规则，因为它修改了输入对象。第二个函数保持输入对象不变，并返回添加了所需属性的新对象。</p><p id="fc1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二种方法是编写函数的更安全的方法。</p><h1 id="4c22" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">处理带有大量参数的函数</h1><p id="133d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可以做几件事来提高多参数函数的UX。一个简单的方法是用一个对象包装所有的参数。这里有一个例子</p><p id="5ad5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不好:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="1b44" class="mq lo iq mm b gy mr ms l mt mu">function addUser(firstName, lastName, age, city, state, zipCode) {<br/>    // ... do something with the user info<br/>}</span></pre><p id="f01d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="cdae" class="mq lo iq mm b gy mr ms l mt mu">function addUser({ firstName, lastName, age, city, state, zipCode }) {<br/>    // ... do something with the user info<br/>}</span></pre><p id="9f48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个函数将有更好的IDE支持。在不改变函数签名的情况下添加新参数也很容易。当然，您将不再需要担心参数的顺序。</p><h1 id="c713" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Currying</h1><p id="7d9e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Currying是函数式编程中的一项基本技术。它用于创建接受多个参数的函数，一次一个。</p><p id="7668" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用currying从现有的函数中创建参数更少的新函数。当您需要创建许多具有不同值的相似函数时，这很有用。</p><p id="f5f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不同的函数式编程库(例如<a class="ae mv" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda.js </a>)提供了一些实用程序来使用不同数量的参数来执行函数。也就是说，在许多情况下，您可以自己实现一个简单的curry函数。</p><p id="78e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单的currying方法的一个很好的例子是为React组件提供事件处理程序:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="97ae" class="mq lo iq mm b gy mr ms l mt mu">export default function SampleComponent({ onValueChange }) {<br/>  const handleChange = (key) =&gt; {<br/>    return (e) =&gt; onValueChange(key, e.target.value)<br/>  }</span><span id="6814" class="mq lo iq mm b gy mw ms l mt mu">return (<br/>    &lt;form&gt;<br/>      &lt;input onChange={handleChange('name')} /&gt;<br/>      &lt;input onChange={handleChange('email')} /&gt;<br/>      &lt;input onChange={handleChange('phone')} /&gt;<br/>    &lt;/form&gt;<br/>  )<br/>}</span></pre><p id="35f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，我们定义了一个<code class="fe mx my mz mm b">handleChange</code>函数，它接受一个键并返回一个事件处理函数。每当输入值改变时，调用<code class="fe mx my mz mm b">onValueChange</code>回调，由于closure，这个回调已经预先填充了键。</p><p id="5d5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们不必为每个输入创建单独的事件处理程序。我们可以用不同的键来处理<code class="fe mx my mz mm b">handleChange</code>函数，并多次重用它。</p><h1 id="7c23" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">做一件事</h1><p id="9705" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">有时我会看到这样的函数:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="fc63" class="mq lo iq mm b gy mr ms l mt mu">const createMeal = ({ type, addExtra }) =&gt; {<br/>    const request = type === "appetizer" ? createAppetizer : createMainCourse;</span><span id="a8b7" class="mq lo iq mm b gy mw ms l mt mu">return request((response) =&gt; {<br/>            if (addExtra) {<br/>                if (type === "appetizer") {<br/>                    response.dressing = "ceaser";<br/>                } else if (type === "main") {<br/>                    response.sides = "fries";<br/>                }<br/>                <br/>                return response;<br/>        }<br/>    });<br/>};</span><span id="d211" class="mq lo iq mm b gy mw ms l mt mu">createMeal({ type: "main", addExtra: true });<br/>createMeal({ type: "appetizer", addExtra: false });</span></pre><p id="aab5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个功能已经成熟，可以拆分了。没有理由它需要支持两种不同的用例。如果有两个更小、更专业的函数来代替就好得多了。</p><p id="2bef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，这些函数不会这样开始。它们从小而简单开始，然后随着新需求的出现，它们变得越来越复杂。因此，时不时地后退一步，问问自己某个功能是否做得太多了，这一点很重要。</p><p id="c1d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码最好改写成这样:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="b95b" class="mq lo iq mm b gy mr ms l mt mu">const createAppetizer = (addExtra) =&gt; {<br/>    return createAppetizerAPI().then((response) =&gt; {<br/>        if (addExtra) {<br/>            response.sides = "fries";<br/>        }<br/>    });<br/>};</span><span id="90bd" class="mq lo iq mm b gy mw ms l mt mu">const createMainCourse = (addExtra) =&gt; {<br/>    return createMainCourseAPI().then((response) =&gt; {<br/>        if (addExtra) {<br/>            response.dressing = "ceaser";<br/>        }<br/>    });<br/>};</span></pre><p id="eaca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在每个功能的意图都更加清晰了，它们也更容易重用。</p><p id="8b81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种拆分方法最适用于我们事先知道参数的函数。另一方面，具有动态参数的函数，比如用户输入，可能更难以这种方式进行拆分。</p><p id="4e80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">判断函数是否做得太多的一个好方法是问问自己为它编写测试有多容易。</p><p id="87f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一般来说，一个功能越容易测试越好。</p><h1 id="3284" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">调整你的应用决策树</h1><p id="a071" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">下面是我经常看到的另一种编写函数的方式:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="68ec" class="mq lo iq mm b gy mr ms l mt mu">const filterOutMeals = ({ meals, customerOrder }) =&gt; {<br/>    if (customerOrder.cancelled) return [];<br/>    return meals.filter((meal) =&gt; !meal.isCold);<br/>};</span></pre><p id="6d92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看起来不算太差，但是早期返回不需要在这个函数里。这又回到了将重要的决策和副作用放在调用堆栈中以使它们更加可见的想法。</p><p id="8744" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是我重写代码的方法:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="cc3d" class="mq lo iq mm b gy mr ms l mt mu">const filterOutMeals2 = ({ meals }) =&gt; {<br/>    return meals.filter((meal) =&gt; !meal.isCold);<br/>};</span><span id="97a9" class="mq lo iq mm b gy mw ms l mt mu">const meals = customerOrder.cancelled ? [] : filterOutMeals2({ meals });</span></pre><p id="2310" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，这段代码的意图就更清楚了，因为如果客户取消订单，避免过滤的决策在决策树中处于更高的位置。</p><h1 id="448d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="f267" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">编写干净的函数很重要，原因有几个。它使您的代码更具可读性、可重用性，并且更易于测试。</p><p id="e62d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我们介绍了用JavaScript编写干净函数的一些简单技巧。希望这些提示对你有所帮助！如果你感兴趣，不久前我写了一篇关于重构你的代码的适当策略的独立博文。</p><p id="2d1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑<a class="ae mv" href="https://twitter.com/IskanderSamatov" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我，</a>在那里我分享我学到的东西。<br/>快乐编码！</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="1798" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mk">原载于2022年4月11日</em><a class="ae mv" href="https://isamatov.com/javascript-clean-functions/" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://isamatov.com</em></a><em class="mk">。</em></p><p id="f1f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mk">更多内容请看</em><a class="ae mv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">plain English . io</em></strong></a><em class="mk">。报名参加我们的</em> <a class="ae mv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">免费周报</em> </strong> </a> <em class="mk">。关注我们关于</em><a class="ae mv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">Twitter</em></strong></a><em class="mk">和</em><a class="ae mv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mk">LinkedIn</em></strong></a><em class="mk">。加入我们的</em> <a class="ae mv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">社区不和谐</em> </strong> </a> <em class="mk">。</em></p></div></div>    
</body>
</html>