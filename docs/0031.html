<html>
<head>
<title>All About Rendering: Client and Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">渲染:客户端和服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/all-about-rendering-client-and-server-efc94b117460?source=collection_archive---------14-----------------------#2022-01-03">https://javascript.plainenglish.io/all-about-rendering-client-and-server-efc94b117460?source=collection_archive---------14-----------------------#2022-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="752b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">刚开始学习web开发，对客户端渲染和服务器端渲染感兴趣？不要再看了！我们甚至会看看静态渲染，并对它们进行比较😉</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a407fc9d2e2ac037f092f57fed6c1b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qK7vXWJYjACPWoLV"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@mike_van_den_bos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mike van den Bos</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="77a5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目录</h1><ol class=""><li id="0964" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><a class="ae kv" href="#7ba5" rel="noopener ugc nofollow">简介</a></li><li id="a356" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#fa5d" rel="noopener ugc nofollow">快速回顾</a> <br/> 2a。<a class="ae kv" href="#18a4" rel="noopener ugc nofollow">奖金！客户端，服务器，前端，后端，天啊！</a></li><li id="a50a" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#39f8" rel="noopener ugc nofollow">客户端渲染与服务器端渲染</a></li><li id="4300" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#59e1" rel="noopener ugc nofollow">奖金！静态渲染/生成器</a></li><li id="aac8" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#7cbe" rel="noopener ugc nofollow">结论&amp;要点</a></li><li id="d195" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#b599" rel="noopener ugc nofollow">想要更多？查看这些其他资源！</a></li></ol></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="7ba5" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated"><strong class="ak">简介</strong>📖</h1><p id="29e5" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">在训练营结束后的求职过程中，我继续学习，首先深入到我以前学过的东西。然而，当我为回去后能更深入地理解主题而兴奋时，我也想继续学习“新”的东西。最终，这让我学会了使用Next.js。</p><p id="a593" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">对于那些不知道Next.js是什么的人来说，它是一个基于React构建的JavaScript框架。因此，如果你知道React，学习Next.js的曲线不会太陡。这看起来已经是一个巨大的好处了，但是对许多人来说，Next.js的卖点是它支持服务器端渲染、客户端渲染和静态生成。</p><p id="31fc" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">如果我第一次读到它的时候，你和我一样，你可能会想“这是什么意思？”，更具体地说，“为什么这是一个好处？”😕</p><p id="7c60" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">自从我第一次有这些问题已经过去几个月了，在这段时间里我学到了很多。作为一个相信分享你所知道的东西的人，我决定为任何像我一样有问题的人写这篇文章，重点是客户端和服务器端的渲染。事不宜迟，我们开始吧！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="fa5d" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated"><strong class="ak">快速回顾</strong> ⚡</h1><p id="d34b" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">在我们理解客户端和服务器端渲染之前，首先我们需要理解什么是客户端、服务器和渲染。</p><ul class=""><li id="6351" class="lo lp iq lq b lr nk lt nl lv np lx nq lz nr mb ns md me mf bi translated"><strong class="lq ir"> <em class="nt">客户端</em> </strong>:根据<a class="ae kv" href="https://www.omnisci.com/technical-glossary/client-server" rel="noopener ugc nofollow" target="_blank"> Omnisci </a>，“客户端，也称为服务请求者，是请求服务器提供的资源和服务的计算机硬件或服务器软件”。换句话说，客户端访问服务器提供的服务。例如，无论何时打开浏览器，您的设备(电脑、平板电脑或手机)都是客户端。</li><li id="0241" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated"><strong class="lq ir"> <em class="nt">服务器</em> </strong>:另一方面，<a class="ae kv" href="https://www.omnisci.com/technical-glossary/client-server" rel="noopener ugc nofollow" target="_blank"> Omnisci </a>将服务器描述为，“为其他设备或程序提供功能的设备或计算机程序。任何可以被客户使用或调用来共享资源和分配工作的计算机化进程都是服务器”。这并不意味着服务器必须是物理的，也有虚拟服务器。因此，在高层次上，服务器的目的是运行其他计算机需要的服务。</li><li id="3508" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated"><strong class="lq ir"> <em class="nt">渲染</em> </strong>:当你的浏览器发出请求，服务器发出响应，为了让浏览器显示接收到的信息，需要对其进行渲染。也就是说，浏览器用HTML、CSS和JavaScript解释并组合这些信息，以创建DOM树。</li></ul><p id="7c50" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">简而言之，客户机和服务器之间的关系类似于消费者和企业；一种是客户端向服务器请求服务，服务器提供服务。因此，服务器可以同时支持多个客户端。另一方面，一个客户端可以请求多个服务器。这是有益的，因为它允许客户端和服务器相互独立；如果一台服务器出现故障，通常会有其他服务器来支持它们，如果用户(客户端)打开或关闭他们的设备，也不会影响其他用户的服务。连接这两者的是呈现，它完成了实际解释和显示服务的工作。</p><h2 id="18a4" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated"><strong class="ak">奖金！客户端，服务器，前端，后端，天啊！</strong>🙀</h2><p id="2f1f" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">现在你可能会想，“是什么让客户端和服务器不同于前端和后端”？简短的回答是，它们在很大程度上可以互换使用，因为它们几乎是同义词。也就是说，我喜欢SkillCrush从前端和后端区分客户端和服务器的方式；客户端和服务器描述了动作发生在哪里(计算机对服务器)，而前端和后端指的是什么样的动作(用户看到的和看不到的)正在发生。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="39f8" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated"><strong class="ak">客户端渲染对比服务器端渲染</strong>👩‍💻</h1><p id="ff9a" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">现在我们知道了客户端、服务器和渲染，我们可以深入了解什么是客户端和服务器端渲染了！如今，有许多方法可以向用户呈现内容，但主要的两种是客户端和服务器端。由于渲染对用户体验、性能、搜索引擎优化(SEO)等方面的影响，了解您采用的方法非常重要。</p><h2 id="1994" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated"><strong class="ak">服务器端渲染</strong>💻</h2><p id="0c55" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">过去，服务器端呈现(SSR)是标准，通常用于在浏览器中显示信息。使用SSR，我们能够获取数据并用该数据预先填充页面，因为服务器会编译数据并将完整的填充HTML页面交付给客户端。换句话说，每个页面甚至在加载到页面之前就知道它的全部内容。</p><p id="b8e0" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">SSR的好处是改善SEO，因为所有的内容在你得到之前就已经存在了。另一方面，如果用户决定访问网站上的不同页面，浏览器需要向服务器再次请求新数据/页面并刷新。因此，即使不同的页面具有相似的信息，也不是只有新信息更新已经呈现的内容，而是呈现整个(新)页面。这使得SSR非常适合网站，特别是如果SEO很重要，内容是动态但重复的，新页面加载不重要(例如一个电子商务网站)。</p><h2 id="930e" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated"><strong class="ak">客户端渲染</strong>💻</h2><p id="ec2b" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">结果，客户端渲染(CSR)的使用被广泛采用，特别是随着带有客户端JavaScript库的单页面应用程序(如React和Vue)的兴起。CSR所做的是通过使用JavaScript在浏览器中呈现来自服务器的内容。这允许服务器只负责加载HTML框架，因此当页面第一次加载时，它将是空白的；一旦JavaScript完成加载，其余的内容就会呈现在客户机上。</p><p id="bc5e" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">CSR的好处是解决了SSR的主要痛点；获取更多内容和/或更改页面并不意味着浏览器需要向服务器发出另一个请求，而是浏览器负责通过使用JavaScript加载新内容来呈现内容。这使得页面加载速度更快，因为您只需要加载页面中需要新内容的部分，从而避免了为一小部分内容加载整个页面。然而，由于在页面加载到浏览器上之前，内容是不会呈现的，所以SEO会受到很大的影响，并且在所有JavaScript都下载到浏览器之前，您的网站将无法加载，这使得初始加载时间很长，具体取决于互联网连接。因此，CSR更适合内容不断变化的web应用程序，快速响应/呈现非常重要，并且基于大量的用户交互。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="59e1" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated"><strong class="ak">奖金！静态渲染/生成</strong>😉</h1><p id="90f2" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">另一种类型的渲染是静态渲染，它是Next.js的一部分，在过去几年中变得越来越常用。在高层次上，它与SSR非常相似，都涉及为网站的每个页面/路径生成HTML。</p><p id="9d46" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">两者的主要区别在于渲染发生的时间；对于静态，它发生在构建时，而对于按需SSR，当客户端请求每个页面时。静态的好处是，因为不需要从服务器上生成或获取任何东西，所以网站会更快，即使服务器关闭也没关系，因为内容仍然存在。然而，这也意味着你需要提前考虑网站的所有响应(页面和内容),因为页面呈现时不需要生成任何东西。</p><p id="156c" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">因此，如果网站的内容是动态的、特定于用户的，或者如果你不一定关心SEO(即内容在登录之后)，这就不理想了，在这种情况下SSR会更好。您可能会使用静态呈现的一些示例是组合网站或博客，其中大部分内容保持不变，很少更改。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="7cbe" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated"><strong class="ak">结论&amp;要点</strong>📝</h1><p id="956d" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">无论您是否正在学习Next.js，理解客户端呈现、服务器端呈现以及它们之间的差异在您继续web开发之旅时都是非常重要的。这些知识将帮助您做出技术决策，并有意识地使用您的代码和技术堆栈。提醒一下，以下是最重要的几点:</p><ul class=""><li id="1f19" class="lo lp iq lq b lr nk lt nl lv np lx nq lz nr mb ns md me mf bi translated">客户端是您用来从服务器(如电脑、平板电脑和手机)访问服务的设备。</li><li id="7906" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">服务器运行其他计算机或客户端所需的服务，可以是虚拟的，也可以是物理的。</li><li id="1b2f" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">渲染基本上就是客户端的浏览器显示其内容，也就是作为响应从服务器接收到的带有HTML、CSS和JavaScript的数据。</li><li id="85ec" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">客户端和服务器从前端和后端的区别在于，客户端和服务器描述的是在哪里，而前端和后端描述的是发生什么样的动作。</li><li id="7974" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">服务器端呈现(SSR)使用客户端从服务器获取的数据预先填充页面，以便在加载页面之前就知道页面的内容。这使得它非常适合搜索引擎优化很重要、动态内容重复、页面刷新不重要的网站。</li><li id="1d87" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">客户端渲染(CSR)让服务器只负责加载HTML，并等待JavaScript在客户端完成加载，因此初始加载是一个空白页。因此，CSR更适合具有大量用户交互和动态用户特定内容的web应用程序。</li><li id="029d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">静态渲染发生在构建时，不依赖于服务器来获取或生成内容，因此速度非常快。静态渲染的最佳用例是作品集网站或博客，其中的内容不需要经常改变。</li></ul><p id="77ec" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated">这是一个总结，感谢阅读❤️如果你喜欢这篇文章，请检查我的其他工作，并关注我更多！一个好的起点是我的相关文章“<a class="ae kv" href="https://medium.com/swlh/fetch-requests-and-controller-actions-connecting-the-frontend-to-the-backend-733a87ffe757" rel="noopener">获取请求和控制器动作:将前端连接到后端</a>”或者我最受欢迎的关于React的文章“<a class="ae kv" href="https://medium.com/weekly-webtips/react-basics-whats-the-difference-between-javascript-and-jsx-604dd224b1cf" rel="noopener"> React基础知识:JavaScript和JSX有什么区别？</a>”。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="278e" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">用组件构建微前端</h1><p id="2d4d" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">微前端是加速和扩展应用程序开发的好方法，具有独立的部署、解耦的代码库和自治的团队。</p><p id="154a" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated"><a class="ae kv" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank"> Bit </a>为构建组件驱动的微前端提供了很好的开发者体验。构建组件、协作和组合可扩展的应用程序。我们的GitHub拥有超过14.5k颗恒星！</p><p id="8b43" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated"><a class="ae kv" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">试试Bit→</strong></a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/974fac3b1ac310e3d805735bbe3a102d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7OCJ5MkhAaNsAxCe.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An independently source-controlled and shared “card” component (on the right, its dependency graph, auto-generated by Bit)</figcaption></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="6e5f" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated">了解更多信息</h2><div class="oh oi gp gr oj ok"><a href="https://blog.bitsrc.io/building-a-react-component-library-d92a2da8eab9" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">构建React组件库——正确的方法</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">创建一个超级模块化的React组件库:可伸缩、可维护、安装速度极快。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">blog.bitsrc.io</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kp ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://blog.bitsrc.io/microservices-are-dead-long-live-miniservices-40e4ccf4741" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">微服务已死——微服务万岁</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">你真的在为你的应用使用微服务吗？再想想。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">blog.bitsrc.io</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy kp ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://blog.bitsrc.io/7-tools-for-faster-frontend-development-in-2022-43b6f663c607" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">2022年加快前端开发的7种工具</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">您应该知道的工具，可以更快地构建现代前端应用程序，并获得更多乐趣。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">blog.bitsrc.io</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy kp ok"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="b599" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated"><strong class="ak">想要更多？查看其他资源！💾</strong></h1><h2 id="1724" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated">Next.js功能</h2><p id="972c" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">📖<a class="ae kv" href="https://nextjs.org/docs/basic-features/pages" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/docs/basic-features/pages</a>T16】📖<a class="ae kv" href="https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/docs/basic-features/data-fetching</a></p><h2 id="2975" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated">翻译</h2><p id="eb73" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">📖<a class="ae kv" href="https://www.amsivedigital.com/insights/performance-creative/rendering-a-webpage-with-google-webmaster-tools/" rel="noopener ugc nofollow" target="_blank">https://www . amsi vedigital . com/insights/performance-creative/rendering-a-page-with-Google-web master-tools/</a></p><h2 id="de62" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated">客户端渲染与服务器端渲染</h2><p id="e2f1" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">📖<a class="ae kv" href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/web/updates/2019/02/rendering-on-the-web</a><br/>📖<a class="ae kv" href="https://www.freecodecamp.org/news/what-exactly-is-client-side-rendering-and-hows-it-different-from-server-side-rendering-bd5c786b340d/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/what-exact-is-client-side-rendering-and-hows-it-different-from-server-side-rendering-bd5c 786 b 340d/</a><br/>📖<a class="ae kv" href="https://www.toptal.com/front-end/client-side-vs-server-side-pre-rendering" rel="noopener ugc nofollow" target="_blank">https://www . toptal . com/front-end/client-side-vs-server-side-pre-rendering</a><br/>📖<a class="ae kv" href="https://www.toptal.com/front-end/client-side-vs-server-side-pre-rendering" rel="noopener ugc nofollow" target="_blank">https://www . toptal . com/front-end/client-side-vs-server-side-pre-rendering</a><br/>📖<a class="ae kv" href="https://www.solutelabs.com/blog/client-side-vs-server-side-rendering-what-to-choose-when" rel="noopener ugc nofollow" target="_blank">https://www . solute labs . com/blog/client-side-vs-server-side-rendering-what-to-choose-when</a></p><h2 id="8f32" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated">静态渲染/生成器</h2><p id="0eb7" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">📖<a class="ae kv" href="https://www.cosmicjs.com/blog/static-site-generators-explained-in-5-minutes" rel="noopener ugc nofollow" target="_blank">https://www . cosmicjs . com/blog/static-site-generators-explained-in-5-minutes</a><br/>📖<a class="ae kv" href="https://betterprogramming.pub/server-side-rendering-vs-static-site-generation-53a34872728c" rel="noopener ugc nofollow" target="_blank">https://better programming . pub/server-side-rendering-vs-static-site-generation-53a 34872728 c</a><br/>📖<a class="ae kv" href="https://frontarm.com/james-k-nelson/static-vs-server-rendering/" rel="noopener ugc nofollow" target="_blank">https://front arm . com/James-k-Nelson/static-vs-server-rendering/</a><br/>📖<a class="ae kv" href="https://www.section.io/engineering-education/client-side-rendering-vs-server-side-rendering-vs-static-site-generation/" rel="noopener ugc nofollow" target="_blank">https://www . section . io/engineering-education/client-side-rendering-vs-server-side-rendering-vs-static-site-generation/</a></p><p id="9318" class="pw-post-body-paragraph mx my iq lq b lr nk jr mz lt nl ju na lv nm nc nd lx nn nf ng lz no ni nj mb ij bi translated"><em class="nt">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nt">plain English . io</em></a><em class="nt">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nt">免费每周简讯</em> </a> <em class="nt">。在我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nt">社区</em> </a> <em class="nt">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>