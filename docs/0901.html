<html>
<head>
<title>How Pure Pipes Can Improve Your Angular Application’s Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纯管道如何提高Angular应用程序的性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-pure-pipes-can-improve-angular-applications-performance-c83106ac45e0?source=collection_archive---------3-----------------------#2022-02-20">https://javascript.plainenglish.io/how-pure-pipes-can-improve-angular-applications-performance-c83106ac45e0?source=collection_archive---------3-----------------------#2022-02-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ac23" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用纯管道提升Angular应用程序性能的指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9e7242ff639c8a821eb353830eb00845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4qpXnvzULDwW_c6G"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@pietromattia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pietro Mattia</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4424" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Angular中开发应用程序时，我们可能会遇到这样的情况:我们需要从HTML模板本身调用一个方法来获取一些将在UI中显示的数据。但是这个方法调用不依赖于任何事件。这种情况的典型例子如下—</p><p id="62c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例1 —</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="1604" class="lu lv in lq b gy lw lx l ly lz">&lt;div&gt; {{ <strong class="lq io">showData()</strong> }} &lt;/div&gt;</span></pre><p id="ef03" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例2 —</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="69c1" class="lu lv in lq b gy lw lx l ly lz">&lt;div&gt;      <br/>  &lt;img [src]="'assets/images/' + <strong class="lq io">getIconBasedOnMimeType(fileData)</strong>"&gt;    &lt;/div&gt;</span></pre><p id="5aeb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上述方法肯定会奏效。但是这种方法的问题是，每次角度变化检测运行时都会调用该方法。</p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><p id="fec8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们通过一个例子来理解这一点。请拉下面的GitHub库，切换到<strong class="kv io">非优化</strong>分支。</p><div class="mh mi gp gr mj mk"><a href="https://github.com/souvik-pl/ANGULAR_PIPE" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">GitHub - souvik-pl/ANGULAR_PIPE</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">此项目是使用Angular CLI版本12.0.0生成的。为开发服务器运行ng serve。导航到…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my km mk"/></div></div></a></div><p id="f36f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在那里，我们有app.component.ts的<strong class="kv io"><em class="mz"/></strong>和<strong class="kv io"><em class="mz">app . component . ts</em></strong>文件，如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a3e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当这个app组件初始化时，<strong class="kv io"> <em class="mz"> ngOnInit() </em> </strong>生命周期钩子被调用，它又调用<strong class="kv io"> <em class="mz"> getFiles() </em> </strong>方法。该方法将调用另一个同名的<strong class="kv io"><em class="mz">file system service</em></strong>方法来获取文件数据。</p><p id="2871" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面给出了<strong class="kv io"> <em class="mz">文件-system.service.ts </em> </strong>文件—</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3c91" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的<strong class="kv io"> <em class="mz"> getFile() </em> </strong>方法中，我们正在创建1秒的延迟，以获得实际API调用的感觉。</p><p id="8f06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里的<strong class="kv io"> <em class="mz"> FILE_DATA </em> </strong>只是在<strong class="kv io"> <em class="mz"> mock-data.ts </em> </strong>文件中定义的一个JavaScript对象。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="55fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，在<strong class="kv io"><em class="mz">app.component.html</em></strong>文件的第4行，我们调用<strong class="kv io"><em class="mz">getIconBasedOnMimeType()</em></strong>方法来根据文件的Mime类型获取SVG图标的名称。</p><p id="3121" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了检查这个方法被调用的次数，我们在这个方法中写了下面一行。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="393d" class="lu lv in lq b gy lw lx l ly lz">console.log('function called');</span></pre><p id="9698" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们将使用<strong class="kv io"> ng serve </strong>命令运行这个应用程序。我们将在浏览器中看到以下内容。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/4dea00a11e78a8007029944fab71339f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9Ot_sV7JV-6n-sSPaJSQQ.png"/></div></div></figure><p id="7c54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在控制台中，我们可以看到<code class="fe nd ne nf lq b">function called</code>已经打印了两次。因此，我们可以得出结论，在加载该页面时，更改检测运行了两次，并且方法<strong class="kv io"><em class="mz">getIconBasedOnMimeType()</em></strong>被调用了两次，即使参数没有被更改。</p><p id="2761" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们看看当我们在app组件中附加一个<strong class="kv io"> click </strong>事件监听器时会发生什么。我们将对app.component.ts的<strong class="kv io"><em class="mz"/></strong>和<strong class="kv io"><em class="mz">app . component . ts</em></strong>文件做一些小的修改，如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="241a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">应用程序重新加载后，我们将在屏幕上单击两次，这是我们在控制台中看到的内容—</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/76a8bf41f180357981c0fef23711cd13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVsmBh-T9LWgffZFXkZG3w.png"/></div></div></figure><p id="8a22" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，我们可以看到，在屏幕上单击两次后，更改检测运行了4次。结果<strong class="kv io"><em class="mz">getIconBasedOnMimeType()</em></strong>被调用了4次。</p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><p id="72dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，如果我们使用一个纯管道，而不是从模板中调用这个方法，那么只要参数保持不变，这个方法就不会在变化检测运行时被反复调用。</p><p id="dde1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们来了解一下纯管道和不纯管道的区别。<strong class="kv io">纯管道</strong>仅在angular检测到传递给管道的参数发生变化时调用。</p><p id="4440" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，每次变化检测运行时，都会调用一个<strong class="kv io">不纯管道</strong>。</p><p id="7fc4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们将创建一个新文件<strong class="kv io"> <em class="mz"> icon.pipe.ts </em> </strong>，如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b7eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当它被调用时，它将在控制台中记录<code class="fe nd ne nf lq b">Pipe called</code>。</p><p id="8dbe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们还要修改<strong class="kv io"><em class="mz">app.component.html</em></strong>文件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cefb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">应用程序重新加载后，我们将在屏幕上的任意位置单击2次，我们将能够看到以下内容—</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/4bf4d9f4590e7818883ee20177c1efb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7cCS1o3nAU3KLGdhvf3dYg.png"/></div></div></figure><p id="34e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们可以看到<code class="fe nd ne nf lq b">Pipe called</code>只打印了一次。</p><p id="ac3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以在存储库的主分支中获得用管道优化的代码，其链接如上所述。</p><p id="7d2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，通过这个小小的改变，我们可以提高应用程序的性能。</p><p id="7f95" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mz">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mz">plain English . io</em></strong></a><em class="mz">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mz">免费每周简讯</em> </strong> </a> <em class="mz">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mz">社区</em> </strong> </a> <em class="mz">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>