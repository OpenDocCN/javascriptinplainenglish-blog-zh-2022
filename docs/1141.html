<html>
<head>
<title>How to Build A Scalable Scrawler Service With Puppeteer?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用木偶师搭建一个可扩展的Scrawler服务？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-scaleable-scrawler-service-with-puppeteer-80f928f43950?source=collection_archive---------5-----------------------#2022-03-05">https://javascript.plainenglish.io/how-to-build-a-scaleable-scrawler-service-with-puppeteer-80f928f43950?source=collection_archive---------5-----------------------#2022-03-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5e74" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:用docker开发打字稿</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e7e94c50d0916e36fea0b6b42675a5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZG3yaLq8AGhwPjnEnz42AA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A simple crawler service</figcaption></figure><p id="17af" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">今天我要讲一个故事——如何用木偶师建立一个可扩展的涂鸦服务？该服务只有一个公共API，该API提供一个查询字符串，然后返回一个Google搜索结果链接列表。</p><p id="1d5c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在第1部分中，我们只是构建了一个简单的服务来完成基本需求。我们将使用Node.js作为运行时环境，使用Puppeteer chrome headless浏览器和TypeScript。我们还使用Docker和Docker compose来建立本地开发环境。</p><h1 id="d19d" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">用docker-compose开发一个打字稿项目</h1><p id="ed48" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">让我们用Express和TypeScript实现一个简单的HTTP服务。</p><p id="7e54" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">作为一个普通的Node.js项目，我们将从npm的初始命令开始:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="aa97" class="mq lp in mm b gy mr ms l mt mu">$ npm init</span></pre><p id="afca" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然后，安装TypeScript作为开发依赖和其他依赖:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="ba95" class="mq lp in mm b gy mr ms l mt mu">$ npm install typescript nodemon @types/express -D<br/>$ npm install express -S</span></pre><p id="1779" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">生成<code class="fe mv mw mx mm b">tsconfig.json</code>文件:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="56f6" class="mq lp in mm b gy mr ms l mt mu">$ npx tsc --init</span></pre><p id="f6d3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">并更新<code class="fe mv mw mx mm b">tsconfig.json</code>更改一些设置:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="16e7" class="mq lp in mm b gy mr ms l mt mu">...<br/>"target": es2018,<br/>"rootDir": "./src",<br/>"outDir": "./dist"<br/>...</span></pre><p id="7ed6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">TS文件将放在<code class="fe mv mw mx mm b">src</code>文件夹中，编译后的文件放在<code class="fe mv mw mx mm b">dist</code>文件夹中。</p><p id="e2c4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在<code class="fe mv mw mx mm b">src</code>我们创建<code class="fe mv mw mx mm b">index.ts</code>文件，这个文件是项目的切入点。让我们实现一个简单的express服务器:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="7c04" class="mq lp in mm b gy mr ms l mt mu"># index.ts<br/>import express from 'express';<br/>import environments from './utils/environments';</span><span id="133a" class="mq lp in mm b gy my ms l mt mu">const app = express();</span><span id="2aa9" class="mq lp in mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.json({ message: 'Hello World!' });<br/>});</span><span id="b4e3" class="mq lp in mm b gy my ms l mt mu">app.listen(environments.apiPort, () =&gt; {<br/>  console.log(`Server is running on: ${environments.apiPort}`);<br/>});</span></pre><p id="c17a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">带<code class="fe mv mw mx mm b">utils/environment.ts</code>:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="bef6" class="mq lp in mm b gy mr ms l mt mu">const apiPort = Number(process.env.API_PORT || 3000);</span><span id="6b53" class="mq lp in mm b gy my ms l mt mu">export default {<br/>  apiPort,<br/>};</span></pre><p id="b89d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们可以通过<code class="fe mv mw mx mm b">API_PORT</code>环境变量来控制服务器HTTP端口。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="e045" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我们将验证我们的设置和新服务器。首先，我们将类型脚本代码转换为JavaScript代码:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="cd7e" class="mq lp in mm b gy mr ms l mt mu">$ npx tsc</span></pre><p id="0695" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">终端中不应打印任何输出，并且将创建<code class="fe mv mw mx mm b">dist</code>文件夹。</p><p id="fe2e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">启动服务器:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="14ee" class="mq lp in mm b gy mr ms l mt mu">$ node dist/index.js<br/>&gt; Server is running on: 3000</span></pre><p id="e61f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当我们访问<code class="fe mv mw mx mm b">http://localhost:3000</code>时，会显示一条消息:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="f096" class="mq lp in mm b gy mr ms l mt mu">{<br/>    message: "Hello World!"<br/>}</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="50ac" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当我们更新一个ts文件时，我们必须重复这些步骤，以确保服务器运行的是最新的逻辑。让我们通过使用<code class="fe mv mw mx mm b">nodemon</code>的watch特性和Typescript编译器来试着让它变得简单一些。</p><p id="9e2f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">创建<code class="fe mv mw mx mm b">nodemon.json</code>来配置nodemon进程:只需监听<code class="fe mv mw mx mm b">dist</code>目录，只需观察js文件的变化。</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="d4b6" class="mq lp in mm b gy mr ms l mt mu">{<br/>    "watch": ["dist/"]",<br/>    "ext": "js",<br/>    "delay": 500<br/>}</span></pre><p id="d1c4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，在<code class="fe mv mw mx mm b">package.json</code>文件中创建2个npm脚本:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="d4de" class="mq lp in mm b gy mr ms l mt mu">...<br/>"scripts": {<br/>    "dev": "nodemon ./dist/index.js",<br/>    "build:watch": "rm -rf dist &amp;&amp; tsc --watch",<br/>  },<br/>...</span></pre><p id="e7e3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们仍然需要2个终端窗口，1个窗口transpile ts到JavaScript。</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="f144" class="mq lp in mm b gy mr ms l mt mu">$ npm run build:watch</span></pre><p id="16b9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">1窗口监视<code class="fe mv mw mx mm b">dist</code>目录的变化并重启服务器:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="de13" class="mq lp in mm b gy mr ms l mt mu">$ npm run dev</span></pre><p id="af81" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，当我们保存一个ts文件时，服务器将自动重启。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="5191" class="mq lp in bd lq ng nh dn lu ni nj dp ly lb nk nl ma lf nm nn mc lj no np me nq bi translated">Dockerzile开发环境</h2><p id="6964" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">直到现在，我们都不需要自定义docker映像，只需要使用节点映像。</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="e73f" class="mq lp in mm b gy mr ms l mt mu"># docker-compose.yml<br/>version: '3.9'<br/>services:<br/>  api:<br/>    build: node:latest<br/>    working_dir: /api<br/>    volumes:<br/>      - .:/api<br/>    command: npm run dev<br/>    ports:<br/>      - '${API_PORT}:${API_PORT}'<br/>    depends_on:<br/>      compile:<br/>        condition: service_healthy<br/>    environment:<br/>      - API_PORT=${API_PORT}<br/>  compile:<br/>    image: node:latest<br/>    working_dir: /source<br/>    volumes:<br/>      - .:/source<br/>    command: npm run build:watch<br/>    healthcheck:<br/>      test: bash -c "[ -f dist/index.js ]"<br/>      interval: 10s<br/>      timeout: 5s<br/>      retries: 5</span></pre><p id="41ea" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将所有项目文件挂载到容器中。<code class="fe mv mw mx mm b">compile</code>服务处理<code class="fe mv mw mx mm b">npm run build:watch</code>命令。而<code class="fe mv mw mx mm b">api</code>服务处理<code class="fe mv mw mx mm b">npm run dev</code>命令。只有当<code class="fe mv mw mx mm b">dist/index.js</code>文件存在时<code class="fe mv mw mx mm b">api</code>服务才会启动(这意味着<code class="fe mv mw mx mm b">compile</code>服务运行成功。</p><p id="bb3e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我们只需要一个终端窗口:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="e276" class="mq lp in mm b gy mr ms l mt mu">$ docker-compose up</span></pre><h1 id="01bd" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">爬虫谷歌搜索结果与木偶师</h1><p id="e0bf" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">木偶师需要一个chrome浏览器实例，然后我们将在<code class="fe mv mw mx mm b">api</code> docker容器上安装Chrome。为此，我们需要一个定制的docker图像。</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="e46e" class="mq lp in mm b gy mr ms l mt mu"># Dockerfile<br/>FROM node:latest</span><span id="f518" class="mq lp in mm b gy my ms l mt mu"># Install dependencies<br/>RUN apt-get update -qq \<br/>  &amp;&amp; apt-get install -qq --no-install-recommends \<br/>    ca-certificates \<br/>    apt-transport-https \<br/>  &amp;&amp; apt-get upgrade -qq</span><span id="2fe0" class="mq lp in mm b gy my ms l mt mu"># Install chrome<br/>RUN wget -q -O - <a class="ae nr" href="https://dl-ssl.google.com/linux/linux_signing_key.pub" rel="noopener ugc nofollow" target="_blank">https://dl-ssl.google.com/linux/linux_signing_key.pub</a> | apt-key add - \<br/>  &amp;&amp; echo "deb <a class="ae nr" href="https://dl.google.com/linux/chrome/deb/" rel="noopener ugc nofollow" target="_blank">https://dl.google.com/linux/chrome/deb/</a> stable main" &gt;&gt; /etc/apt/sources.list.d/google-chrome.list \<br/>  &amp;&amp; apt-get update -qq \<br/>  &amp;&amp; apt-get install -qq --no-install-recommends \<br/>    google-chrome-stable \<br/>  &amp;&amp; apt-get clean \<br/>  &amp;&amp; rm -rf /var/lib/apt/lists/*</span></pre><p id="6561" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">基于<code class="fe mv mw mx mm b">node</code>镜像创建新镜像，安装Chrome稳定版。chrome二进制文件路径是<code class="fe mv mw mx mm b">/usr/bin/google-chrome</code>，我们需要这个信息来配置木偶师。</p><p id="4e02" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">更新<code class="fe mv mw mx mm b">docker-compose.yml</code>以更改<code class="fe mv mw mx mm b">api</code>服务图像设置:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="c932" class="mq lp in mm b gy mr ms l mt mu">services:<br/>  api:<br/>    build: . # instead of image: node:latest</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="a09c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在我们可以实现搜索API: <code class="fe mv mw mx mm b">GET /search?query=</code>。</p><p id="94f9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">安装<code class="fe mv mw mx mm b">puppeteer-core</code>包，核心包不会安装chrome。我们已经在docker文件中自己安装了Chrome。</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="bdea" class="mq lp in mm b gy mr ms l mt mu">$ npm install puppeeter-core -S</span></pre><p id="debc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在<code class="fe mv mw mx mm b">index.ts</code>文件中，为express服务器注册一个新的请求句柄:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="3620" class="mq lp in mm b gy mr ms l mt mu">...<br/>import { ISearchResult } from './utils/interfaces';<br/>import { getLinksByQuery } from './utils/scraper';<br/>...</span><span id="10b3" class="mq lp in mm b gy my ms l mt mu">app.get('/search', async (req, res) =&gt; {<br/>  try {<br/>    const now = Date.now();</span><span id="0bb1" class="mq lp in mm b gy my ms l mt mu">    const { query = '' } = req.query as { query: string };<br/>    if (!query) {<br/>      return res.json({<br/>        query,<br/>        took: (Date.now() - now) / 1000,<br/>        links: [],<br/>      } as ISearchResult);<br/>    }</span><span id="1802" class="mq lp in mm b gy my ms l mt mu">    const links = await getLinksByQuery(query);</span><span id="06c7" class="mq lp in mm b gy my ms l mt mu">    return res.json({<br/>      query,<br/>      took: (Date.now() - now) / 1000,<br/>      links,<br/>    } as ISearchResult);<br/>  } catch (error) {<br/>    console.error(error);<br/>    return res.status(500).json({ message: (error as Error).message    });<br/>  }<br/>});</span></pre><p id="6410" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们从查询对象中获取一个<code class="fe mv mw mx mm b">query</code>字符串，如果查询是空的，我们用一个空列表来响应。否则，尝试通过<code class="fe mv mw mx mm b">getLinksByQuery</code>函数获取结果链接并返回给客户端。</p><p id="ff7a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接口定义<code class="fe mv mw mx mm b">./utils/interfaces</code>:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="f628" class="mq lp in mm b gy mr ms l mt mu">export interface ILink {<br/>  title: string;<br/>  link: string;<br/>}</span><span id="16f3" class="mq lp in mm b gy my ms l mt mu">export interface ISearchResult {<br/>  query: string;<br/>  took: number;<br/>  links: ILink[];<br/>}</span></pre><p id="04ff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mv mw mx mm b">getLinksByQuery</code>功能来自<code class="fe mv mw mx mm b">./utils/scraper</code>:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="6209" class="mq lp in mm b gy mr ms l mt mu">import withPage from './browser';<br/>import { ILink } from './interfaces';</span><span id="0415" class="mq lp in mm b gy my ms l mt mu">export function getLinksByQuery(query: string): Promise&lt;ILink[]&gt; {<br/>  return withPage(async (page) =&gt; {<br/>    await page.goto('<a class="ae nr" href="https://www.google.com/'" rel="noopener ugc nofollow" target="_blank">https://www.google.com/'</a>, {<br/>      timeout: 0,<br/>      waitUntil: 'networkidle2',<br/>    });<br/>    await page.type('input', query);<br/>    await page.keyboard.press('Enter');<br/>    await page.waitForSelector('div.yuRUbf &gt; a');</span><span id="9c5e" class="mq lp in mm b gy my ms l mt mu">    return page.evaluate(() =&gt; {<br/>      const data: ILink[] = [];<br/>      document.querySelectorAll('div.yuRUbf &gt; a').forEach((ele) =&gt; {<br/>        data.push({<br/>          title: ele.querySelector('h3')?.textContent as string,<br/>          link: (ele as HTMLAnchorElement).href,<br/>        });<br/>      });</span><span id="9b08" class="mq lp in mm b gy my ms l mt mu">      return data;<br/>    });<br/>  });<br/>}</span></pre><p id="cc7d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个函数调用<code class="fe mv mw mx mm b">withPage</code> helper来获得一个新的chrome页面实例，然后通过Google搜索查询。它在第一个搜索结果页面上返回所有结果链接。</p><p id="0d5c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最后，<code class="fe mv mw mx mm b">./utils/browser.ts</code>中的<code class="fe mv mw mx mm b">withPage</code>辅助函数:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="611e" class="mq lp in mm b gy mr ms l mt mu">import puppeteer, { Page } from 'puppeteer-core';</span><span id="26f3" class="mq lp in mm b gy my ms l mt mu">export default async function withPage&lt;T&gt;(func: (page: Page) =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {<br/>  const browser = await puppeteer.launch({<br/>    executablePath: '/usr/bin/google-chrome',<br/>    headless: true,<br/>    args: [<br/>      '--no-sandbox',<br/>      '--disable-background-networking',<br/>      '--disable-default-apps',<br/>      '--disable-extensions',<br/>      '--disable-sync',<br/>      '--disable-translate',<br/>      '--headless',<br/>      '--hide-scrollbars',<br/>      '--metrics-recording-only',<br/>      '--mute-audio',<br/>      '--no-first-run',<br/>      '--safebrowsing-disable-auto-update',<br/>      '--ignore-certificate-errors',<br/>      '--ignore-ssl-errors',<br/>      '--ignore-certificate-errors-spki-list',<br/>      '--user-data-dir=/tmp',<br/>    ],<br/>  });</span><span id="8726" class="mq lp in mm b gy my ms l mt mu">  const page = await browser.newPage();</span><span id="0ddb" class="mq lp in mm b gy my ms l mt mu">  try {<br/>    return await func(page);<br/>  } finally {<br/>    await page.close();<br/>    await browser.close();<br/>  }<br/>}</span></pre><p id="81c4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mv mw mx mm b">withPage</code>是一个通用函数，它接受一个参数——一个“动作”函数。我们通过puppeteer创建一个新的无头浏览器，并通过这个浏览器实例创建一个新的页面实例。将页面实例传递给“action”函数，返回action函数的结果。最后，关闭页面和浏览器即可。</p><p id="2d9b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mv mw mx mm b">await</code> <strong class="ku io"> <em class="ns">关键字在调用动作函数时非常重要，它确保页面和浏览器只有在动作函数完成时才关闭。</em> </strong></p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="5952" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我们可以通过浏览器或任何HTTP客户端来尝试新的API:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="17b7" class="mq lp in mm b gy mr ms l mt mu">$ curl '<a class="ae nr" href="http://localhost:3000/search?query=typescript%202022'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/search?query=typescript%202022'</a></span></pre><p id="8691" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">它将返回如下内容:</p><pre class="kd ke kf kg gt ml mm mn mo aw mp bi"><span id="ccb2" class="mq lp in mm b gy mr ms l mt mu">{<br/>  "query": "typescript 2022",<br/>  "took": 4.052,<br/>  "links": [<br/>    {<br/>      "title": "100万行の大規模なJavaScript製システムをTypeScriptに移行 ...",<br/>      "link": "<a class="ae nr" href="https://developers.cyberagent.co.jp/blog/archives/34364/" rel="noopener ugc nofollow" target="_blank">https://developers.cyberagent.co.jp/blog/archives/34364/</a>"<br/>    },<br/>    ...<br/>  ]<br/>}</span></pre><p id="485d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">01部分到此为止！</p><h1 id="6e14" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">结论</h1><p id="aabb" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">我希望你喜欢这篇文章，并从中获得一些有用的东西。这是我最喜欢的开始Node.js + TypeScript项目的方式。<br/>本文使用的源代码发表在<a class="ae nr" href="https://github.com/hoangsetup/scraper-service/tree/368ae525a4027364bf56611ac0b45615e46afeba" rel="noopener ugc nofollow" target="_blank"> Github </a>上。<br/>感谢阅读！</p><p id="65f1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="ns">更多内容看</em> <a class="ae nr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="ns">说白了就是</em> </strong> </a> <em class="ns">。报名参加我们的</em> <a class="ae nr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="ns">免费周报</em> </strong> </a> <em class="ns">。关注我们关于</em><a class="ae nr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ns">Twitter</em></strong></a><em class="ns">和</em><a class="ae nr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ns">LinkedIn</em></strong></a><em class="ns">。加入我们的</em> <a class="ae nr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="ns">社区</em> </strong> </a> <em class="ns">。</em></p></div></div>    
</body>
</html>