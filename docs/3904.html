<html>
<head>
<title>7 JavaScript Skills You Need for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React需要的7个JavaScript技能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-7-javascript-skills-you-need-for-react-9244169ca80a?source=collection_archive---------1-----------------------#2022-10-07">https://javascript.plainenglish.io/the-7-javascript-skills-you-need-for-react-9244169ca80a?source=collection_archive---------1-----------------------#2022-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a3f3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">它们是如何工作的，以及它们为什么重要</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dd66a5e1173b2810e79d09a25e30e0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H86RNnxLKQ5CETqfjDsWqw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image generated with MidJourney</figcaption></figure><p id="7279" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript的基础知识和你在React中理解编码所需要的东西之间存在差距。请注意，这不是一个巨大的黑洞，但足以让它值得探索。以下是你在React中需要掌握的7个JavaScript技巧。</p><p id="036d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将讨论它们如何出现在React中，以及它们如何对您有用。用于不变性、条件呈现、显示组件列表等等。</p><p id="9da3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使你对React不感兴趣，你仍然需要这些概念来编写好的JavaScript代码。</p><p id="67cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是首先…</p><h1 id="b5cd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.真实与虚假</h1><p id="a739" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">一个快速但基本的观点。JavaScript认为某些值是“假的”。虽然他们不是<code class="fe mp mq mr ms b">false</code>，但是他们仍然失败了一个<code class="fe mp mq mr ms b">if</code>语句。换句话说，JavaScript的行为就好像这些值是假的一样。</p><p id="f51f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript中的Falsy值包括(除其他外):</p><ul class=""><li id="b9d3" class="mt mu iq kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">不明确的</li><li id="bf22" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">空</li><li id="7df0" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">空字符串</li><li id="c24d" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">空数组</li><li id="fb67" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi">0</li><li id="d483" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">NaN(或者不是一个数字)</li></ul><p id="6758" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这有助于理解布尔运算符和三元运算符…</p><h1 id="254b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.布尔运算符</h1><p id="f668" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">毫无疑问，您熟悉在条件中使用布尔运算符<code class="fe mp mq mr ms b">&amp;&amp;</code>和<code class="fe mp mq mr ms b">||</code>。JavaScript允许你做的远不止这些。你看，这些操作符并不总是返回一个布尔值。</p><p id="a3ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我解释一下。</p><p id="48cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从布尔or运算符(<code class="fe mp mq mr ms b">||</code>)开始。这将计算表达式的第一个元素，并查看它是否为“falsy”。如果值为“真”，则运算符返回第一个词，即运算符左侧的词。如果不是，它返回第二个。</p><p id="ef32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们有一个变量(例如，<code class="fe mp mq mr ms b">name</code>)。我们不知道它是否被设置。如果<em class="lr">没有</em>设置，我们要设置一个默认值。or运算符允许我们执行以下操作:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="09f4" class="nl lt iq ms b gy nm nn l no np">let defaultedName = name || "defaultName";</span></pre><p id="66e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果<code class="fe mp mq mr ms b">name</code>为<code class="fe mp mq mr ms b">undefined</code>或<code class="fe mp mq mr ms b">null</code>或空字符串，运算符将返回第二项:<code class="fe mp mq mr ms b">"defaultName"</code>。如果<code class="fe mp mq mr ms b">name</code> <em class="lr">定义了</em>，则由操作员返回。这允许我们设置一个默认值。</p><p id="b551" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">&amp;&amp;布尔运算符的行为正好相反。如果第一项是“真”，则&amp;&amp;运算符返回第二项。让我们看看如何在React中使用它。假设我们有一个变量叫做<code class="fe mp mq mr ms b">errorMessage</code>。它可能包含也可能不包含错误消息。</p><p id="278e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在React的JSX部分，我们可以这样写:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="ef8d" class="nl lt iq ms b gy nm nn l no np">{errorMessage &amp;&amp; &lt;span&gt;{errorMessage}&lt;/span&gt;}</span></pre><p id="9efb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，如果errorMessage变量为true，则&amp;&amp;运算符仅返回span。如果有错误，我们只显示跨度。</p><h1 id="1494" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.三元运算符</h1><p id="5904" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">有一个精简的if / else语句叫做三元运算符。它是这样工作的，带有一个问号和一个冒号:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="5047" class="nl lt iq ms b gy nm nn l no np">variableTruthy ? itIsTrue : itIsFalse</span></pre><p id="b843" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">操作符所做的是检查变量是否“真”。如果是，运算符返回问号后的第一个词。如果不是，则返回冒号后的词。在我们的错误示例中，如果我们还想在没有错误时显示一条消息，我们可以在JSX代码中添加以下内容:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="8c83" class="nl lt iq ms b gy nm nn l no np">{ error ? &lt;span&gt;{error}&lt;/span&gt; : &lt;span&gt;"There is no error"&lt;/span&gt;}</span></pre><p id="181a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，在这种特殊情况下，我们可以在span中写得更简单:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="ef7c" class="nl lt iq ms b gy nm nn l no np">&lt;span&gt;{error ? error : "There is no error"}&lt;/span&gt;</span></pre><p id="6201" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">…但这只是因为我没有费心为这个错误添加任何样式。</p><h1 id="6b2f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.析构数组和对象</h1><p id="3468" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们来看一个简单的<code class="fe mp mq mr ms b">useState</code>钩子。</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="8cbc" class="nl lt iq ms b gy nm nn l no np">const [counter, setCounter] = useState(0);</span></pre><p id="24c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看<code class="fe mp mq mr ms b">counter</code>和<code class="fe mp mq mr ms b">setCounter</code>变量是如何定义的。它们是从数组中定义的。实际上，我们正在将变量映射到<code class="fe mp mq mr ms b">useState</code>的返回。钩子返回一个数组。此语法将数组的第一个值赋给第一个变量，第二个值赋给第二个变量。</p><p id="1197" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一种更简短(也更优雅)的书写方式:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="2882" class="nl lt iq ms b gy nm nn l no np">const temp = useState(0);<br/>const counter = temp[0];<br/>const setCounter = temp[1];</span></pre><p id="071f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，重组语法更加简洁，并且去掉了临时变量。对象的语法是相似的。它通常首先出现在import语句中。例如:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="e138" class="nl lt iq ms b gy nm nn l no np">import { useState } from 'react';</span></pre><p id="68d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它是如何工作的？假设我们有一个有年龄和名字的用户对象:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="48e2" class="nl lt iq ms b gy nm nn l no np">const user = {<br/>  name: "Bob", <br/>  age: 42<br/>}</span></pre><p id="0df0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用析构直接检索名称:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="41a1" class="nl lt iq ms b gy nm nn l no np">const {name} = user;</span></pre><p id="aa0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这相当于</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="60a0" class="nl lt iq ms b gy nm nn l no np">const name = user.name;</span></pre><h1 id="bad2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.箭头功能</h1><p id="bbdc" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">箭头函数是编写函数的一种更简洁的方式。在React中，简洁有助于编写可读的代码。箭头函数也是编写useEffect钩子的自然方式。</p><p id="2f5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简单回顾一下:编写函数的“正常”方式是使用<code class="fe mp mq mr ms b">function</code>关键字。例如:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="8aee" class="nl lt iq ms b gy nm nn l no np">function add(a,b) {<br/>  return a + b;<br/>}</span></pre><p id="4c82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以把它写成一个箭头函数，声明如下:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="23da" class="nl lt iq ms b gy nm nn l no np">const add = (a,b) =&gt; {<br/>  return a + b;<br/>}</span></pre><p id="43c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，由于这个函数中只有一个<code class="fe mp mq mr ms b">return</code>语句，我们可以去掉括号和<code class="fe mp mq mr ms b">return</code>语句本身:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="3795" class="nl lt iq ms b gy nm nn l no np">const add = (a,b) =&gt; a + b</span></pre><p id="2db9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这在使用数组函数时尤其有用。</p><h1 id="c2e5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.数组函数，特别是映射和过滤</h1><p id="7696" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">数组有一些有趣的函数可以对它们进行操作。我发现React中有两个特别有用的特性:<code class="fe mp mq mr ms b">map</code>和<code class="fe mp mq mr ms b">filter</code>。</p><p id="993d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两个函数都将一个函数作为参数，并返回一个新数组。</p><p id="5238" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Filter返回一个数组，该数组只包含函数作为参数传递的返回真值的项。</p><p id="c0a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们用返回模2的函数过滤一个数字数组，我们的新数组现在只包含奇数。这是因为当运行模运算时，偶数返回0，而0是假的:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="6436" class="nl lt iq ms b gy nm nn l no np">const odd = [1, 2, 4, 7, 9, 22].filter((a) =&gt; a % 2);<br/>// odd now only has odd numbers :  [1, 7, 9]</span></pre><p id="55f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，Map返回一个数组，其中每个新项都是函数的返回值。如果我们传递一个将其输入乘以2的函数，那么输出就是输入的双精度数组。</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="aa72" class="nl lt iq ms b gy nm nn l no np">const double = [1, 2, 4, 7, 9, 22].map((a) =&gt; a * 2);<br/>// double now has doubles:  [2, 4, 8, 14, 18, 44]</span></pre><p id="d6b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这在React中如何有用？假设我们正在构建一个待办事项列表应用程序。我们有一个想要显示的任务数组，存储在一个<code class="fe mp mq mr ms b">tasks</code>变量中。每个项目都有(例如) :</p><ul class=""><li id="6adc" class="mt mu iq kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">一个身份证，</li><li id="dce8" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">一个标题，</li><li id="ea1d" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">完成状态，可以是真或假。</li></ul><p id="2039" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们已经定义了一个任务组件。我们可以使用map函数创建一个列表，为每个项目返回一个任务组件:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="f5f7" class="nl lt iq ms b gy nm nn l no np">{ tasks.map((task) =&gt; &lt;Task key={task.id} task={task} /&gt; }</span></pre><p id="1c4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过使用<code class="fe mp mq mr ms b">filter</code>隐藏complete为真的项目，我们可以只显示不完整的项目:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="9f9d" class="nl lt iq ms b gy nm nn l no np">{ <br/>tasks.filter(task =&gt; !item.complete).map((task) =&gt; &lt;Task key={task.id} task={task} /&gt; <br/>}</span></pre><p id="1a8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">(小题外话:我们需要指定一个<code class="fe mp mq mr ms b">key</code>值来帮助React跟踪到底发生了什么变化。)</p><p id="c995" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有许多其他有用的数组函数值得一提。这个问题值得更深入的研究。但这两个是我觉得最有用的。</p><h1 id="1271" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.扩展运算符(和对象属性简写)</h1><p id="0251" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果在您的状态中使用对象，您需要开始使用spread操作符。spread操作符允许我们创建一个具有相同值的复制对象。</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="e49a" class="nl lt iq ms b gy nm nn l no np">const user = {<br/>  name: "Bob", <br/>  age: 42<br/>}<br/><br/>const user1 = user;<br/>const user2 = {...user};<br/><br/>console.log(user == user1); // true <br/>console.log(user == user2); // false</span></pre><p id="732d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这为什么有用？React跟踪更改，以了解何时重新渲染组件树的各个部分。在上面的例子中，<code class="fe mp mq mr ms b">user</code>和<code class="fe mp mq mr ms b">user1</code>是同一个对象。</p><p id="97e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果我们在<code class="fe mp mq mr ms b">user1</code>上将<code class="fe mp mq mr ms b">age</code>属性设置为43，<code class="fe mp mq mr ms b">user1</code>仍将等于<code class="fe mp mq mr ms b">user</code>。</p><p id="8efe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，想象React正在跟踪<code class="fe mp mq mr ms b">user</code>对象的状态。更改用户对象的一个属性值不会触发状态更改的检测。假设我们有一个用于更新用户状态的<code class="fe mp mq mr ms b">setUser</code>函数。如果我们这样做:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="10ef" class="nl lt iq ms b gy nm nn l no np">user.age = 43;<br/>setUser(user);</span></pre><p id="8f00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这不会触发更改检测。<code class="fe mp mq mr ms b">user</code>对象仍然是完全相同的对象。我们需要使用spread操作符创建一个新的对象，因此:</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="d707" class="nl lt iq ms b gy nm nn l no np">setUser({...user, age: 43});</span></pre><p id="0085" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里发生了什么？</p><p id="0735" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两个花括号意味着我们已经创建了一个新对象。“扩展”操作符的作用就像它拆分(或扩展)初始对象一样。</p><p id="75da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们要明确地写这里发生了什么……那将会特别冗长。我们需要首先创建一个空白的新对象。然后我们列出<code class="fe mp mq mr ms b">user</code>对象上的所有键。然后我们遍历键列表。这样做时，我们将新对象中的属性值设置为旧对象中的相应值。最后，我们设置新的更改值。</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="24c9" class="nl lt iq ms b gy nm nn l no np">const newUser = {}<br/>let keys = Object.keys(user); <br/><br/>for(let i = 0; i &lt; keys.length; i++) {<br/>	let key = keys[i];<br/>	newUser[key] = user[key];<br/>}<br/><br/>newUser.age = 43;</span></pre><p id="ec3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一点也不简洁。</p><p id="2a35" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">spread运算符将所有内容压缩成一行。一旦你理解了它的意思，产生的代码也是可读的(如果不是更可读的话)。</p><h1 id="bfe3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">采取下一步措施</h1><p id="71bc" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">记住:使用一门语言的高级特性永远不应该超过可读性。然而，如果使用正确，这些特性有助于使你的代码更具可读性，而不是更差。</p><p id="f1d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有什么要掌握的，要不断学习？</p><p id="3a0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，理解<a class="ae nq" rel="noopener ugc nofollow" target="_blank" href="/what-are-javascript-promises-how-to-use-them-84fdff5757b9">承诺和异步/等待是如何工作的</a>至关重要。这不是<em class="lr">反应堆的核心</em>部分。有些钩子为你隐藏了复杂性。但如果你想掌握JavaScript，这是不可避免的。</p><p id="aea7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你希望掌握React，你需要了解钩子如何工作，<a class="ae nq" href="https://medium.com/p/ed137b148f5a" rel="noopener">以及初学者应该避免的错误</a>。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="f9a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">更多内容看</em> <a class="ae nq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">说白了。报名参加我们的</em> <a class="ae nq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">免费周报</em> </strong> </a> <em class="lr">。关注我们关于</em> <a class="ae nq" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">推特</em> </strong> </a>，<a class="ae nq" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="lr">LinkedIn</em></strong></a><em class="lr">，</em><a class="ae nq" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="lr">YouTube</em></strong></a><em class="lr">，以及</em> <a class="ae nq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">不和</em> </strong> </a> <em class="lr">。对增长黑客感兴趣？检查</em> <a class="ae nq" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="lr">电路</em> </strong> </a> <em class="lr">。</em></strong></a></p></div></div>    
</body>
</html>