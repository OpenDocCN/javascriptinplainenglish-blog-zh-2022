<html>
<head>
<title>Performance Optimization Strategies Inside React You Don’t Know About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不知道的React内部的性能优化策略</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/performance-optimization-strategies-inside-react-you-dont-know-1d46714b483d?source=collection_archive---------0-----------------------#2022-07-03">https://javascript.plainenglish.io/performance-optimization-strategies-inside-react-you-dont-know-1d46714b483d?source=collection_archive---------0-----------------------#2022-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">成为反应冠军之路。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/adbb42a5f6c3e6c07fcdebbcf1c0e093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P4uEZJzhtXmtM-IE"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/es/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d175" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你知道React中有哪些性能优化策略吗？</p><p id="4378" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Vue.js有自己的模板语法，所以在编译阶段可以采用很多性能优化策略。尽管React是一个完整的运行时库，但它的性能优化策略集中在运行时阶段。</p><p id="89f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我打算与您讨论React中的一些性能优化策略，以帮助您更深入地了解React。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="17f1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题</h1><p id="11aa" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">请阅读以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您认为这样一个React组件将如何工作？或者说组件挂载后控制台会打印多少条信息？</p><p id="5a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的答案是什么？</p><p id="0318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="my">注意:如果您计划执行这段代码，请不要启用严格模式，因为这会干扰我们的实验。</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="32a2" class="ne ma iq na b gy nf ng l nh ni">// remove this code<br/>root.render(<br/>  &lt;StrictMode&gt;<br/>    &lt;App /&gt;<br/>  &lt;/StrictMode&gt;<br/>);</span><span id="e34a" class="ne ma iq na b gy nj ng l nh ni">// add this code<br/>root.render(&lt;App /&gt;);</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b9b5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">理论分析</h1><p id="24f5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果不考虑任何性能优化策略，我们只是进行纯理论分析，那么代码的运行逻辑应该是这样的:</p><p id="382e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(<em class="my">首先我们要知道，一般来说，父组件渲染完之后，子组件也会一起渲染。)</em></p><ol class=""><li id="af07" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">第一次渲染App组件时，控制台打印<code class="fe nt nu nv na b">App render 0</code>。</li><li id="6752" class="nk nl iq ky b kz nw lc nx lf ny lj nz ln oa lr np nq nr ns bi translated">然后子组件第一次渲染，控制台打印<code class="fe nt nu nv na b">child render</code>。</li><li id="acdc" class="nk nl iq ky b kz nw lc nx lf ny lj nz ln oa lr np nq nr ns bi translated">1000毫秒后，<code class="fe nt nu nv na b">setInterval</code>的回调函数被触发，执行<code class="fe nt nu nv na b">updateNum(1)</code>。</li><li id="14b9" class="nk nl iq ky b kz nw lc nx lf ny lj nz ln oa lr np nq nr ns bi translated">App组件再次渲染并打印<code class="fe nt nu nv na b">App render 1</code>。</li><li id="b61e" class="nk nl iq ky b kz nw lc nx lf ny lj nz ln oa lr np nq nr ns bi translated">子组件再次呈现，打印<code class="fe nt nu nv na b">child render</code>。</li><li id="f5d5" class="nk nl iq ky b kz nw lc nx lf ny lj nz ln oa lr np nq nr ns bi translated">每隔1000毫秒重复步骤3至5</li></ol><p id="0854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在图表中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/40eae5d003b46a24a3b60ed2ea53c862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmHc73MEXYYZ3VMbus7CPg.png"/></div></div></figure><p id="fed2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以控制台打印结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/82e0c012ebea8348c656689ac1e7b861.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*6xRUFked_WhtTeH9wGsIeA.png"/></div></figure><p id="0b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但注意，以上结果只是理论分析。由于React做了很多性能优化措施，实际输出可能和我们想的不一样。</p><p id="7748" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您开始一个真正的React项目，它应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/00b78b9a900a1e44582e22d441e5fdb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*If38p6X4qZSKNMYI0ThQxQ.png"/></div></figure><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="fc5c" class="ne ma iq na b gy nf ng l nh ni">App render 0</span><span id="b409" class="ne ma iq na b gy nj ng l nh ni">child render </span><span id="04d0" class="ne ma iq na b gy nj ng l nh ni">App render 1</span><span id="83db" class="ne ma iq na b gy nj ng l nh ni">child render </span><span id="f7e7" class="ne ma iq na b gy nj ng l nh ni">App render 1</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe mx l"/></div></figure><p id="8c91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们可以看到，理论分析的结果与实际操作的结果是不一致的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/0a450ae4c3d314ce74b02ad4ea39969b.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*nTyCBZnY1LPoKvGF-MVEjA.png"/></div></figure><p id="682f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么你知道发生了什么，为什么后续流程没有执行吗？在本文中，我们将一起讨论这个问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a955" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">优化策略1:救市</h1><p id="ae2e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们之前提到过，一般来说，父组件渲染完之后，子组件也会一起渲染。但是看之前的运行结果，最后一次App渲染之后，它的子组件就没有渲染了。为什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/53a3d9aaa6bf3e30a85431293d60da21.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*__2qTPAmtwy3ZryKA7T1NA.png"/></div></figure><p id="a191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是由于React内部采用了一种称为<strong class="ky ir">紧急救助</strong>的性能优化策略。具体来说:当<code class="fe nt nu nv na b">useState</code>更新的状态与当前状态相同时(使用<code class="fe nt nu nv na b">Object.is</code>进行比较)，React不会渲染组件的后代组件。</p><p id="49bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果前后状态相同，那么真的没有必要重新渲染子组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/0a6db19e51d6870e412e81ea28a93ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaAg7K3JlCdp5R2YX7BIDQ.png"/></div></div></figure><p id="3fe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但需要注意的是，救市策略只针对当前组件的子组件，当前组件本身仍可能呈现。这是因为在大多数情况下，只有当前组件渲染时，<code class="fe nt nu nv na b">useState</code>才会被执行，状态可以被计算出来，然后与当前状态进行比较。</p><p id="8762" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我们的演示而言，新的<code class="fe nt nu nv na b">num</code>只能在执行App render和<code class="fe nt nu nv na b">useState</code>之后才能计算。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bcf9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">优化策略2: <strong class="ak"> eagerState </strong></h1><p id="09e6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">但是救市策略只针对目标组件的后代组件，那么为什么对于目标组件App来说，<code class="fe nt nu nv na b">App render 1</code>执行两次后就不执行了呢？</p><p id="d350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是另一种优化策略发挥作用的地方。</p><p id="2c84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React的工作流程可以简单地概括为:</p><ul class=""><li id="0e7b" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr oi nq nr ns bi translated">交互(比如点击事件，<code class="fe nt nu nv na b">useEffect</code>)触发更新</li><li id="551f" class="nk nl iq ky b kz nw lc nx lf ny lj nz ln oa lr oi nq nr ns bi translated">组件树重新渲染</li></ul><p id="691c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">刚刚提到的<code class="fe nt nu nv na b">bailout</code>发生在步骤2:组件树开始渲染后，命中救市的组件的后代组件将不会被渲染。</p><p id="c141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其实还有一个更前端的优化策略:当第一步如果发现状态没有改变就触发更新时，第二步根本不会继续。</p><p id="7694" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个演示中，当执行<code class="fe nt nu nv na b">updateNum(1)</code>时，新的<code class="fe nt nu nv na b">num</code>会立即计算出来，然后与当前的num进行比较。如果相等，则不会渲染组件树。</p><p id="36f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种“提前计算状态的时机”的策略被称为<code class="fe nt nu nv na b">eagerState</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/5d04d7467d45444e19005bc3870a83bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQ8TIc2AL_oe8ixlTTxoHA.png"/></div></div></figure></div></div>    
</body>
</html>