<html>
<head>
<title>First Look at Standalone Components: Angular Beyond NgModules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">首先看一下独立组件:角度超过NgModules</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/first-look-at-standalone-components-angular-beyond-ngmodules-6360d30fca0d?source=collection_archive---------1-----------------------#2022-04-30">https://javascript.plainenglish.io/first-look-at-standalone-components-angular-beyond-ngmodules-6360d30fca0d?source=collection_archive---------1-----------------------#2022-04-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bbc9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Angular中独立元件的概述。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4802ab7e86a3bdf84c27837824648791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXA0S16KtjF_TbSQZevP8Q.png"/></div></div></figure><p id="b6e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">伟大的Angular团队已经发布了关于它的两个RFC，具体来说就是CLI 14.0.0-next.12和Core 14.0.0-next.15。</p><p id="82c5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当您使用以下方式生成新项目时:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="ef09" class="lq lr in lm b gy ls lt l lu lv">npx @angular/cli@next new ng14</span></pre><p id="1038" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感觉还是一样的，同样的交互问题，同样的项目结构用<code class="fe lw lx ly lm b">AppModule</code>创建。</p><p id="b3cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是那里有一个隐藏的复活节彩蛋，所以我一直在探索，看看它在未来会是什么样子。</p><h1 id="c491" class="lz lr in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">第一件事是删除AppModule</h1><p id="ba11" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">有史以来第一次，我没有使用<code class="fe lw lx ly lm b">AppModule</code>或任何<code class="fe lw lx ly lm b">NgModule</code>来制作我的棱角分明的作品，但几乎不需要什么改变。</p><p id="37ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一件事是在<code class="fe lw lx ly lm b">AppComponent</code>中添加一个独立的标志，然后更改<code class="fe lw lx ly lm b">main.ts</code>，仅用<code class="fe lw lx ly lm b">AppComponent</code>初始化应用程序。为此，您需要使用新功能<code class="fe lw lx ly lm b">bootstrapApplication</code>。它看起来会像这样:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="8b73" class="lq lr in lm b gy ls lt l lu lv">import { enableProdMode } from '<a class="ae lk" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { bootstrapApplication } from '<a class="ae lk" href="http://twitter.com/angular/platform-browser" rel="noopener ugc nofollow" target="_blank">@angular/platform-browser</a>';<br/>import { AppComponent } from './app/app.component';<br/>import { environment } from './environments/environment';</span><span id="c38e" class="lq lr in lm b gy mv lt l lu lv">if (environment.production) {<br/>  enableProdMode();<br/>}</span><span id="ec26" class="lq lr in lm b gy mv lt l lu lv">bootstrapApplication(AppComponent)<br/>  .catch(err =&gt; console.error(err));</span></pre><p id="2d58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是事情没有那么简单，因为现在它不知道什么是路由器出口，但是这是一个简单的解决方案，只需在<code class="fe lw lx ly lm b">AppComponent</code>中导入<code class="fe lw lx ly lm b">RouterModule</code>，是的，你现在就可以这样做。</p><p id="75bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是显示了一个更严重的错误，不是在您的终端中，而是在浏览器中(换句话说，运行时不是编译时错误):</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="60d2" class="lq lr in lm b gy ls lt l lu lv">ERROR NullInjectorError: R3InjectorError(Standalone[AppComponent])[ChildrenOutletContexts -&gt; ChildrenOutletContexts -&gt; ChildrenOutletContexts]: <br/>  NullInjectorError: No provider for ChildrenOutletContexts!</span></pre><p id="21ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">经过几次搜索，我发现这是因为我需要在我的应用程序中的某个地方调用<code class="fe lw lx ly lm b">RouterModule.forRoot()</code>来让router-outlet工作。对于独立组件的初始化，有一种新的方法可以使用新函数<code class="fe lw lx ly lm b">importProvidersFrom</code>来完成。下面是代码的样子:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="f212" class="lq lr in lm b gy ls lt l lu lv">import { enableProdMode, importProvidersFrom } from '<a class="ae lk" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { bootstrapApplication } from '<a class="ae lk" href="http://twitter.com/angular/platform-browser" rel="noopener ugc nofollow" target="_blank">@angular/platform-browser</a>';<br/>import { RouterModule, Routes } from '<a class="ae lk" href="http://twitter.com/angular/router" rel="noopener ugc nofollow" target="_blank">@angular/router</a>';<br/>import { AppComponent } from './app/app.component';<br/>import { environment } from './environments/environment';</span><span id="ddaf" class="lq lr in lm b gy mv lt l lu lv">const routes: Routes = [];</span><span id="569d" class="lq lr in lm b gy mv lt l lu lv">if (environment.production) {<br/>  enableProdMode();<br/>}</span><span id="dcee" class="lq lr in lm b gy mv lt l lu lv">bootstrapApplication(AppComponent, <strong class="lm io">{<br/>  providers: [<br/>    ...importProvidersFrom(RouterModule.forRoot(routes)),<br/>  ],<br/>}</strong>)<br/>  .catch(err =&gt; console.error(err));</span></pre><p id="765a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，它工作了，现在我们有了一个没有<code class="fe lw lx ly lm b">NgModule</code>的角度应用。</p><h1 id="e8cc" class="lz lr in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">然后，让我们有一个懒惰加载的组件</h1><p id="7b8c" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">在此之前，你只能延迟加载一个模块。要延迟加载一个组件，您必须为这个组件创建一个模块，然后延迟加载这个模块，但是现在简单多了。下面我们来看看怎么做。</p><p id="4c4b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们使用新标志<code class="fe lw lx ly lm b">--standalone</code>创建一个新的独立组件。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="af06" class="lq lr in lm b gy ls lt l lu lv">ng g c foo --standalone</span></pre><p id="3f6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了使用它，Routes中有一个名为loadComponent的新选项，它的工作方式与它处理模块的方式非常相似。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="b46e" class="lq lr in lm b gy ls lt l lu lv">const routes: Routes = [<br/>  {<br/>    path: 'foo',<br/>    loadComponent: () =&gt; import('./app/foo/foo.component').then(c =&gt; c.FooComponent),<br/>  },<br/>];</span></pre><p id="fc5a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在生产应用程序中，您应该从另一个文件中导出路由器，并将它们导入main.ts，但是我想让事情变得非常简单。</p><p id="0eaf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在如果你导航到<a class="ae lk" href="http://localhost:4200/foo" rel="noopener ugc nofollow" target="_blank">http://localhost:4200/Foo</a>你会看到<em class="mw"> Foo works </em>！如果你看一下devtool中的network选项卡，你会看到它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/ae997e560d5c4a83d966283811e6531b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HaVoExRpm8vHwqPxp4u1g.png"/></div></div></figure><p id="35aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了确保它确实是惰性加载的，您需要启动应用程序，然后导航到它，这是我们下一个也是最后一个部分的内容。</p><p id="5763" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">最后，创建一个可重用的独立组件</strong></p><p id="f6a1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我觉得对于旧的应用程序来说，这将是最有益的部分。现在，拥有一个可重用的组件从来都不容易，没有共享的<code class="fe lw lx ly lm b">NgModule</code>，你需要加载所有的组件来使用其中的一个，或者每个组件有一个模块，你必须创建许多不必要的文件。</p><p id="28f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将像以前一样开始，使用新的<code class="fe lw lx ly lm b">--standalone</code>标志创建它。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="03ba" class="lq lr in lm b gy ls lt l lu lv">ng g c header --standalone</span></pre><p id="4e4e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在HTML中，我们只需简单地输入:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="ac4f" class="lq lr in lm b gy ls lt l lu lv">&lt;a routerLink=""&gt;home&lt;/a&gt; | &lt;a routerLink="foo"&gt;foo&lt;/a&gt;</span></pre><p id="8520" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您会发现链接不起作用，这是因为您需要再次将<code class="fe lw lx ly lm b">RouterModule</code>导入到您的组件中，然后将<code class="fe lw lx ly lm b">HeaderComponent</code>导入到<code class="fe lw lx ly lm b">AppComponent</code>中，然后瞧，它起作用了！</p><p id="c8d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是它们的样子:</p><p id="6d72" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> AppComponent </strong></p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="ed71" class="lq lr in lm b gy ls lt l lu lv">import { Component } from '@angular/core';<br/>import { RouterModule } from '@angular/router';<br/>import { HeaderComponent } from './header/header.component';<br/><br/>@Component({<br/>  selector: 'app-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.scss'],<br/>  standalone: true,<br/>  imports: [RouterModule, HeaderComponent],<br/>})<br/>export class AppComponent {<br/>}</span></pre><p id="38a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">头部组件</strong></p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="c789" class="lq lr in lm b gy ls lt l lu lv">import { Component, OnInit } from '<a class="ae lk" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { RouterModule } from '<a class="ae lk" href="http://twitter.com/angular/router" rel="noopener ugc nofollow" target="_blank">@angular/router</a>';</span><span id="39a1" class="lq lr in lm b gy mv lt l lu lv"><a class="ae lk" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  selector: 'app-header',<br/>  standalone: true,<br/>  templateUrl: './header.component.html',<br/>  styleUrls: ['./header.component.scss'],<br/>  imports: [RouterModule],<br/>})<br/>export class HeaderComponent implements OnInit {</span><span id="6793" class="lq lr in lm b gy mv lt l lu lv">constructor() {<br/>  }</span><span id="74a2" class="lq lr in lm b gy mv lt l lu lv">ngOnInit(): void {<br/>  }</span><span id="963f" class="lq lr in lm b gy mv lt l lu lv">}</span></pre><p id="614f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在我的GitHub robertIsaac/ng14中看到完整的代码:</p><div class="my mz gp gr na nb"><a href="https://github.com/robertIsaac/ng14" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">GitHub - robertIsaac/ng14</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">此项目是使用Angular CLI版本14.0.0-next.12生成的。导航到…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np km nb"/></div></div></a></div><p id="3912" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mw">更多内容看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">说白了就是</em> </strong> </a> <em class="mw">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">免费每周简讯</em> </strong> </a> <em class="mw">。关注我们</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mw">Twitter</em></strong></a><em class="mw">和</em><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mw">LinkedIn</em></strong></a><em class="mw">。加入我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">社区不和谐</em> </strong> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>