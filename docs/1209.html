<html>
<head>
<title>An Introduction to JavaScript Prototype for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的JavaScript原型介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-introduction-to-javascript-prototype-for-beginners-e3e02b6fb168?source=collection_archive---------10-----------------------#2022-03-09">https://javascript.plainenglish.io/an-introduction-to-javascript-prototype-for-beginners-e3e02b6fb168?source=collection_archive---------10-----------------------#2022-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="110f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解什么是原型。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c4e3eb9bba8033b6519deb12853f3568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nX4znOtzdBp-AR-U8jve1g.png"/></div></div></figure><p id="b88d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于使用过基于类的语言(如C++或Java)的开发人员来说，JavaScript可能会让人感到困惑。尽管我们在JavaScript中有一个class关键字，但它仍然不是真正基于类的，因为这个关键字只是语法糖。它试图模仿其他语言的类功能，但最终仍然是基于原型的。但是到底什么是原型呢？</p><p id="8ba3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在这里观看这篇文章的视频版本。</p><h2 id="b199" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">什么是原型？</h2><p id="6347" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">在基于类的语言中，我们有一个包含所有属性和方法的类。创建该类的对象时，这个新创建的对象可以访问该类中定义的属性和方法。</p><p id="6b82" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">原型与类非常相似。它们充当我们在应用程序中创建的对象实例的<strong class="kq io">蓝图。这些对象实例除了自己的属性和方法之外，还可以访问原型的所有属性和方法。</strong></p><p id="916e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每当您在JavaScript中创建一个函数时，都会有一个<strong class="kq io">原型属性</strong>附加到该函数上(我说属性是因为，在JavaScript中，函数也是一个对象)。每当您使用“<strong class="kq io"> new </strong>”关键字调用该函数时，创建的对象实例将继承该函数原型的所有属性。</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="a3e1" class="ll lm in mk b gy mo mp l mq mr">const Engineer = function(name, type){<br/>   this.type = type;<br/>   this.name = name;<br/>}</span><span id="5e3c" class="ll lm in mk b gy ms mp l mq mr">Engineer.prototype.code = function(){<br/>   return "Typing..."<br/>}</span><span id="2779" class="ll lm in mk b gy ms mp l mq mr"><strong class="mk io">//frontEndEngineer can access the code method<br/>//present on Engineer.prototype</strong><br/>const frontEndEngineer = new Engineer("John Doe", "FE");</span></pre><p id="28e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Engineer.prototype是我们刚刚谈到的原型对象。对象实例是从这个原型派生的。在您的开发工具中，如果您尝试console.log您的对象实例，您会像往常一样找到您的对象属性，但是还会有<strong class="kq io"> [[Prototype]] </strong>属性。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/83131e2925c653b975b292fc11cffeea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*bBWZcZEpUA8TVephh_FhvA.png"/></div></figure><p id="3cb1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你仔细看，这就是这个函数的原型ie Engineer.prototype。所以这里的要点是:</p><p id="9589" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> Function.prototype =对象实例的原型</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/1c9b849df34749c4e51a7549b1de23b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p73hsV-wgDcMAnlOuKvwIA.png"/></div></div></figure><p id="c94f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以通过检查<code class="fe mv mw mx mk b">Engineer.prototype == Object.getPrototypeOf(frontEndEngineer)</code>来验证这一点。这将返回<strong class="kq io">真值</strong>。</p><p id="c46a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">(要访问实例的原型，可以在该实例上使用<strong class="kq io"> __proto__ </strong>，或者使用<strong class="kq io">object . getprototypeof(instance)</strong>。建议使用后者，因为__proto__已被弃用。它现在可能仍然有效，但浏览器标准可能随时改变，完全忽略关键字，所以请记住这一点。)</p><h2 id="1901" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">这解决了什么问题？</h2><p id="55af" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">现在，当您可以在函数(构造函数)本身内部添加属性时，为什么还要向原型添加属性呢？向构造函数添加方法和属性是一种非常有效的方法。但是当您的应用程序创建许多对象实例时，每次都会为每个实例创建一组新的属性。这可能会占用大量内存。</p><p id="3427" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相反，如果我们将这些属性添加到函数的原型中，它们将由解决上述问题的所有实例共享。这是否意味着我们永远不应该在构造函数中添加属性？不完全是。</p><p id="ee5f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一种常见的方法是两种情况的混合。构造函数形成了私有变量的<strong class="kq io">闭包，所以所有想要访问这些私有变量的属性都应该添加到构造函数中。其余的属性应该添加到原型中。</strong></p><h2 id="935d" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">本地对象及其原型</h2><p id="6a5d" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">像数组、字符串、日期这样的内置JavaScript对象也有各自的原型。例如，如果你看一下Array的原型，你会发现你每天都会用到的各种各样的方法和属性。任何时候创建任何原生JS对象的实例，都可以访问它的所有原型方法和属性。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/da746629f5649e82f0ee5cce4ea95676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s47M0VkgIan2eX6ocLxaFg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Different prototypes and their instances</figcaption></figure><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="8d2b" class="ll lm in mk b gy mo mp l mq mr">let arr = [1,2,3,4,5];<br/>console.log(Object.getPrototypeOf(arr))  //Array prototype</span><span id="27cc" class="ll lm in mk b gy ms mp l mq mr">let str = "Hello world!";<br/>console.log(Object.getPrototypeOf(str)) //String prototype</span><span id="c5fe" class="ll lm in mk b gy ms mp l mq mr">let date = new Date();<br/>console.log(Object.getPrototypeOf(date)) //Date prototype</span></pre><h2 id="7a14" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">原型链</h2><p id="03aa" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">现在我们知道了原型是如何工作的，让我们来看看原型链。</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="f154" class="ll lm in mk b gy mo mp l mq mr">let engineer = {<br/>   name : "John Doe",<br/>   type : "Front end engineer"<br/>}</span><span id="47e9" class="ll lm in mk b gy ms mp l mq mr">Object.prototype.typeCode = function(){<br/>   console.log("Typing...")<br/>}</span><span id="1e96" class="ll lm in mk b gy ms mp l mq mr">engineer.typeCode();</span><span id="d28b" class="ll lm in mk b gy ms mp l mq mr">let str = "Front end engineer";</span><span id="e812" class="ll lm in mk b gy ms mp l mq mr">str.typeCode();</span></pre><p id="e409" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这段代码在开始时可能看起来很奇怪，但是请记住。我们首先创建一个具有一些属性的对象(工程师)。既然这是一个对象，它就可以访问对象原型的方法和属性。因此，我们向Object.prototype添加了一个自定义方法(虽然这很方便地添加了一个方法，并使所有其他对象都可以访问它，但最好不要向原生JavaScript对象添加/更改方法)。现在，如果您在engineer对象实例上运行此方法，您将获得预期的输出。</p><p id="ea7a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但这正是开始变得有趣的地方。下面我们还有一个字符串对象。如果您尝试在string上调用相同的自定义方法，即使它从未被添加到String原型中，它也能很好地工作。刚刚发生了什么？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/4bbe9000ee5cfa5803c6cbb3863f0d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opVwiO6DDQyv1DOttbss4Q.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">The method works on both, object and string</figcaption></figure><p id="a872" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个工作的原因是因为<strong class="kq io">原型链接</strong>。如果您再次查看String.prototype，在最底部，您会看到另一个原型。你在最后看到的这个原型是对象原型。为什么我们在字符串原型中有一个对象原型？<strong class="kq io">因为String.prototype属性本身就是一个对象，JavaScript中的每个对象都是从Object prototype派生出来的。因此，您创建的任何数据元素最终都可以从对象原型继承。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a3d08b658bceeb67a98860462df19044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*bds7DtTV87WA9g0DTdRNfg.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">String.prototype is an object, so it will also have the Object.prototype</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/38796a24e6d36d4034a6180f9e490ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7QJy1EJL8B7tlqCTSb03A.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Object.prototype inside String prototype</figcaption></figure><p id="f14f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，JS引擎将总是试图<strong class="kq io">首先</strong>寻找本地存在于对象内部的属性。在我们的例子中，string对象试图寻找typeCode属性。由于字符串没有属性，它试图在<strong class="kq io">它的原型</strong>中寻找类型代码，即String.prototype。它仍然无法找到String.prototype中的属性，所以它移动到Object.prototype。最后，由于我们已经在Object.prototype中设置了属性，我们确实找到了它，并且它像预期的那样运行。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/5cc3f242c9eb69b00333c0b5958719eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dDew0I-Z951EwaWdFIbL6A.png"/></div></div></figure><p id="272b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所有其他原型也会发生这种情况，因为它们本质上都是对象。所以他们最终指向了对象原型。最后，如果JS引擎无法找到对象原型内部的属性，它会返回“<strong class="kq io">未定义的</strong>”，因为在对象原型之外没有任何东西可以遍历。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/25dce868100789b3a1c03d1f14eaf33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-p63zDPyzAtJOO9KLuK-oQ.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Prototype chain</figcaption></figure><h2 id="f0d0" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">关键要点</h2><ul class=""><li id="0ed7" class="ni nj in kq b kr me ku mf kx nk lb nl lf nm lj nn no np nq bi translated">原型是一个<strong class="kq io">对象实例</strong>的<strong class="kq io">蓝图</strong>。</li><li id="72ef" class="ni nj in kq b kr nr ku ns kx nt lb nu lf nv lj nn no np nq bi translated">每当您创建一个函数时，一个<strong class="kq io">原型属性</strong>会自动附加到它上面。(例如，<strong class="kq io"> Object.prototype </strong></li><li id="17cd" class="ni nj in kq b kr nr ku ns kx nt lb nu lf nv lj nn no np nq bi translated">从函数创建的对象实例将有一个[[Prototype]]属性，该属性本质上等于函数的原型。<br/> <strong class="kq io"> Object.prototype =对象实例的[[Prototype]] </strong></li><li id="cfd3" class="ni nj in kq b kr nr ku ns kx nt lb nu lf nv lj nn no np nq bi translated">对象实例<strong class="kq io">共享原型属性</strong>，这反过来节省了内存，而在构造函数中定义的属性是为每个实例重新创建的。</li><li id="51a1" class="ni nj in kq b kr nr ku ns kx nt lb nu lf nv lj nn no np nq bi translated">您可以在原型中定义自定义属性和方法，该原型的所有实例都可以访问这些属性和方法。理想情况下，你<strong class="kq io">不应该</strong>操纵<strong class="kq io">原生JavaScript对象</strong>的原型对象，因为这可能导致意想不到的行为。</li><li id="664a" class="ni nj in kq b kr nr ku ns kx nt lb nu lf nv lj nn no np nq bi translated">由于prototype属性也是一个对象，每个prototype属性最终都是从Object.prototype . So string . prototype或Array.prototype派生而来，因此也有object . prototype。</li><li id="3609" class="ni nj in kq b kr nr ku ns kx nt lb nu lf nv lj nn no np nq bi translated">每当您试图访问一个对象的属性时，JS engine都会在对象实例中查找它。如果没有找到，它会在对象的原型中查找。它会一直这样做，直到到达Object.prototype，之后就没有其他原型需要遍历了。这个原型网络就是<strong class="kq io">原型链</strong>。</li><li id="9711" class="ni nj in kq b kr nr ku ns kx nt lb nu lf nv lj nn no np nq bi translated">Object.prototype没有原型。</li></ul><h2 id="f0da" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">结论</h2><p id="c0fa" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">如果您是JavaScript新手，您可能会对所有这些是如何工作的感到困惑。你可能需要反复阅读才能理解这个话题。像往常一样，MDN有非常可靠的原型文档，所以请检查一下。</p><p id="5644" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://youtu.be/MErshtjCbH0" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">我也推荐大家看一下这个帖子的视频版，更好的理解。</strong>T3】</a></p><p id="3af5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何其他疑问或建议，你可以在评论中提出，或者通过我的社交网站与我联系。干杯！</p><p id="c8b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/><a class="ae lk" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae lk" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae lk" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">GitHub</a></p><p id="655e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nw">更多内容看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nw">说白了就是</em> </strong> </a> <em class="nw">。报名参加我们的</em><strong class="kq io"><em class="nw"/></strong><a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nw">免费每周简讯</em> </strong> </a> <em class="nw">。关注我们</em> <a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nw">推特</em> </strong> </a> <em class="nw">和</em><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nw">LinkedIn</em></strong></a><em class="nw">。加入我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nw">社区不和谐</em> </strong> </a> <em class="nw">。</em></p></div></div>    
</body>
</html>