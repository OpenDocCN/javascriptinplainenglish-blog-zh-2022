<html>
<head>
<title>GraphQL Data fetching with Apollo Client in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中使用Apollo客户端获取GraphQL数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-fetching-with-apollo-client-in-react-graphql-207aaaec2cfe?source=collection_archive---------4-----------------------#2022-10-22">https://javascript.plainenglish.io/data-fetching-with-apollo-client-in-react-graphql-207aaaec2cfe?source=collection_archive---------4-----------------------#2022-10-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5ae7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用带有GraphQL查询的Apollo客户端在React应用程序中检索数据</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4fe0c719618f5fd84a32d929357b9116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DY1qJa_o1q8JajNTSz3bww.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">有志者，事竟成 — Where there is a will ,there is a way</figcaption></figure><p id="dfaf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">学习东西总是需要时间的，不弄脏手很难把握技术的细微差别。GraphQL正在成为在现代web和移动应用程序中使用API的一种流行方式。</p><p id="29eb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我在2年前开始学过一次GraphQL，但是因为某些原因我没有机会继续下去。很快我将使用GraphQL开始一个新的公司项目，考虑到这一点，我创建了一个简单、有趣的React应用程序来更新我的知识。在本文中，我将与您分享如何使用带有GraphQL查询的Apollo客户端来检索数据。</p><p id="a90e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">什么是GraphQL？</strong></p><p id="4916" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">graph QL</em><strong class="ku io"><em class="lo"/></strong><em class="lo">是一种面向数据的API查询风格，它是由脸书开发的一种更高效获取数据的解决方案。</em></p><p id="70c7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">什么是阿波罗客户端？</strong></p><p id="dc18" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo"> Apollo Client是一个全面的JavaScript状态管理库，使我们能够使用GraphQL管理本地和远程数据。</em>👉🏼<em class="lo">简单解释:前端将GraphQL </em> <strong class="ku io"> <em class="lo">查询</em></strong><strong class="ku io"><em class="lo">阿波罗客户端</em> </strong> <em class="lo">处理查询并向GraphQL </em> <strong class="ku io"> <em class="lo">服务器、</em> </strong> <em class="lo">服务器请求数据，然后服务器将数据发送回</em> <strong class="ku io"> <em class="lo">阿波罗客户端</em> </strong> <em class="lo">哪个</em></p><p id="521f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">为什么要使用GraphQL？</strong></p><p id="8a33" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">传统的</em><a class="ae lp" href="https://restfulapi.net/" rel="noopener ugc nofollow" target="_blank"><em class="lo">REST API</em></a><em class="lo">存在过蚀刻或欠蚀刻的局限性。例如，如果端点持有关于用户的数据，我们可以点击</em> <code class="fe lq lr ls lt b"><em class="lo">/user</em></code> <em class="lo">端点，而不是</em> <strong class="ku io"> <em class="lo">仅</em> </strong> <em class="lo">获得我们感兴趣的</em> <code class="fe lq lr ls lt b"><em class="lo">name</em></code> <em class="lo">，我们可以获得端点必须提供的一切——包括</em><code class="fe lq lr ls lt b"><em class="lo">age</em></code><em class="lo"/><code class="fe lq lr ls lt b"><em class="lo">title</em></code><em class="lo"/><code class="fe lq lr ls lt b"><em class="lo">address</em></code><em class="lo">等。，所以很难设计出能够为客户提供准确数据需求的API。</em></p><p id="9772" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">使用GraphQL，我们能够准确地指定我们需要从服务器获得什么，并以可预测的方式接收数据。GraphQL还为API维护人员提供了在不影响现有查询的情况下添加或删除字段的灵活性，开发人员可以使用任何方法创建API。</em></p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="b63c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">够了，让我们开始动手吧。</p><p id="118e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">*如果你懒得用</em> <a class="ae lp" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> <em class="lo">创建React App </em> </a> <em class="lo">在本地创建一个新的React项目，直接跳到这个</em> <a class="ae lp" href="https://codesandbox.io/s/relaxed-fast-v1okx9?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"> <em class="lo">沙箱</em> </a> <em class="lo">里摆弄一下就行了。</em></p><p id="d2b4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个应用程序非常简单，我们将使用<a class="ae lp" href="https://rickandmortyapi.com/graphql" rel="noopener ugc nofollow" target="_blank"> Rick和Morty API </a>来获取和显示一些角色，我们也可以通过点击每张图片来显示个别角色。👇🏼</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mb"><img src="../Images/48c9aa80f9cbe37b2037f8daabbcef1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJPTRCafIyTyjJOzB7kYEg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">all Characters</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mc"><img src="../Images/f2c09de5f2f1446410922dcf32052d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWRkN07wfGEbcF9tLgPdDg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">display one Character by clicking on one image</figcaption></figure><p id="703f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">*因为这篇文章是关于数据获取的，所以没有使用很多CSS</em></p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="9711" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">设置:</strong></p><p id="3b55" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">第一步是安装以下软件包</p><p id="f905" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe lq lr ls lt b">npm install <strong class="ku io">@apollo/client</strong> <strong class="ku io">graphql</strong></code></p><ul class=""><li id="a45a" class="md me in ku b kv kw ky kz lb mf lf mg lj mh ln mi mj mk ml bi translated"><code class="fe lq lr ls lt b">@apollo/client</code>:包含设置Apollo客户端所需的几乎所有内容。它包括内存缓存、本地状态管理、错误处理和基于React的视图层。</li><li id="0248" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated"><code class="fe lq lr ls lt b">graphql</code>:提供解析GraphQL查询的逻辑。</li></ul><p id="a014" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然后，初始化<strong class="ku io"> ApolloClient </strong>，从<code class="fe lq lr ls lt b">@apollo/client</code>中导入我们需要的符号</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="375c" class="mv mw in lt b gy mx my l mz na">// index.js<br/>import { <strong class="lt io">ApolloClient, InMemoryCache, ApolloProvider</strong> <!-- -->} from “@apollo/client";</span></pre><p id="2c05" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接下来，我们将传递给它的构造函数一个带有<code class="fe lq lr ls lt b">uri</code>和<code class="fe lq lr ls lt b">cache</code>字段的配置对象</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="db44" class="mv mw in lt b gy mx my l mz na">const client = new <strong class="lt io">ApolloClient</strong>({<br/>    uri: “https://rickandmortyapi.com/graphql",<br/>    cache: new <strong class="lt io">InMemoryCache</strong>() <em class="lo"><br/></em>});</span></pre><ul class=""><li id="cdd7" class="md me in ku b kv kw ky kz lb mf lf mg lj mh ln mi mj mk ml bi translated"><code class="fe lq lr ls lt b">uri</code>指定我们的GraphQL服务器的URL。</li><li id="2182" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated"><code class="fe lq lr ls lt b">cache</code>是<code class="fe lq lr ls lt b">InMemoryCache</code>的一个实例，Apollo客户端用它来缓存获取后的查询结果。</li></ul><p id="cf7a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最后一步是用<strong class="ku io"> ApolloProvider </strong>将Apollo客户端连接到我们的React应用程序。ApolloProvider类似React的<code class="fe lq lr ls lt b"><a class="ae lp" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank">Context.Provider</a></code>。它包装了我们的React应用程序，并将客户端放在上下文中，这允许我们从组件树中的任何位置访问它。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="eddb" class="mv mw in lt b gy mx my l mz na">root.render(<br/>  &lt;StrictMode&gt;<br/>    &lt;<strong class="lt io">ApolloProvider</strong> <strong class="lt io">client</strong> = {client}&gt;<br/>       &lt;App /&gt;<br/>    &lt;/<strong class="lt io">ApolloProvider</strong>&gt;<br/>  &lt;/StrictMode&gt;</span></pre><p id="6818" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">完美！这就是设置，现在让我们创建组件并添加检索数据的功能！</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/05b92b0d3d8ba54930b5f7a003a33356.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*7tlqb6uppsMnoyzk-cBjag.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App structure</figcaption></figure><p id="7403" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们的组件应该看起来像下面这样👇🏼</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="68ce" class="mv mw in lt b gy mx my l mz na">// characters<br/>const Characters = () =&gt; {<br/>  ...// some data<br/>  return (<br/>    &lt;div&gt;<br/>       {data.map(({ ... }) =&gt; {<br/>          return ( <br/>            &lt;div key={id}&gt;<br/>               &lt;img src={...} alt={...} /&gt;<br/>               &lt;p&gt;{...}&lt;/p&gt;<br/>            &lt;/div&gt;<br/>       )})}<br/>    &lt;/div&gt;<br/>)}<br/>export default Characters;</span><span id="a74a" class="mv mw in lt b gy nc my l mz na">// single character<br/>const Character = () =&gt; {<br/>  ...// some single data<br/>  return (<br/>    &lt;div&gt;<br/>       &lt;h2&gt;{...}&lt;/h2&gt;<br/>       &lt;img src={...} alt={...} /&gt;<br/>       &lt;p&gt;Gender: {...}&lt;/p&gt;<br/>       &lt;p&gt;Status: {...}&lt;/p&gt;<br/>       &lt;p&gt;Species: {...} &lt;/p&gt;<br/>       &lt;p&gt;Location: {...}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>)};<br/>export default Character;</span></pre><p id="3ad3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了从服务器获取我们的字符，我们需要编写查询来请求我们想要的<strong class="ku io">精确字段</strong>，在我们的例子中，我们期望默认显示图像和名称。</p><p id="09da" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">* <em class="lo">你可以前往</em> <a class="ae lp" href="https://rickandmortyapi.com/graphql" rel="noopener ugc nofollow" target="_blank"> <em class="lo">瑞克和莫蒂API </em> </a> <em class="lo">试一试</em>👐</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/e163750f0b7e6908dbb09af300ea1cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70XwtImpGNIFb1JuWC4i1g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae lp" href="https://rickandmortyapi.com/graphql" rel="noopener ugc nofollow" target="_blank">Rick and Morty </a>GraphQL API</figcaption></figure><p id="ec8d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们创建一个fetch查询并执行它。通常在一些较大的项目中，为了在组件之间共享逻辑，我们想要创建一个<a class="ae lp" href="https://beta.reactjs.org/learn/reusing-logic-with-custom-hooks" rel="noopener ugc nofollow" target="_blank">自定义钩子</a>，所以我们也为我们的应用程序这样做，即使它很小，为什么不呢？🎈</p><p id="ae31" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在<em class="lo"> src: </em> <code class="fe lq lr ls lt b">src/hooks/useCharacters.js,</code>中添加一个<em class="lo"> hooks </em>文件夹和一个<em class="lo"> useCharacters </em>文件</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="d4a9" class="mv mw in lt b gy mx my l mz na">import { useQuery, gql } from "@apollo/client";</span><span id="f00e" class="mv mw in lt b gy nc my l mz na">const <strong class="lt io">GET_CHARACTERS </strong>= <strong class="lt io">gql</strong>`<br/>  query <strong class="lt io">GetCharacters</strong> {<br/>    characters {<br/>      results {<br/>        id<br/>        name<br/>        image<br/>      }<br/>    }<br/>  }<br/>`;</span><span id="cdae" class="mv mw in lt b gy nc my l mz na">// export custom hook <br/>// executing a query<br/>export const <strong class="lt io">useCharacters</strong> = () =&gt; {<br/>  const { loading, error, data } = <strong class="lt io">useQuery</strong>(GET_CHARACTERS);<br/>    return { error, data, loading };<br/>};</span></pre><p id="8cd9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上面的代码意味着:</p><ul class=""><li id="7a09" class="md me in ku b kv kw ky kz lb mf lf mg lj mh ln mi mj mk ml bi translated">我们创建一个名为<strong class="ku io"> GetCharacters </strong>的GraphQL查询，将其包装在<strong class="ku io"> gql </strong>函数中，并为它们分配一个变量<strong class="ku io"> GET_CHARACTERS </strong></li><li id="bfab" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated"><code class="fe lq lr ls lt b">useQuery</code>钩子是在Apollo应用程序中执行查询的主要API。要运行一个查询，调用<code class="fe lq lr ls lt b">useQuery</code>并向其传递一个GraphQL查询字符串(在我们的例子中:<strong class="ku io"> GET_CHARACTERS </strong>)。</li><li id="741e" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated">当我们的组件呈现时，<code class="fe lq lr ls lt b">useQuery</code>从Apollo客户端返回一个对象，该对象包含我们可以用来呈现UI的<code class="fe lq lr ls lt b">loading</code>、<code class="fe lq lr ls lt b">error</code>和<code class="fe lq lr ls lt b">data</code>属性。</li></ul><p id="6a22" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就这样，现在转到Characters.js，导入我们的自定义钩子并检索响应，让我们更新Characters组件:</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="9264" class="mv mw in lt b gy mx my l mz na">import { useCharacters } from "../hooks/useCharacters";<br/>const Characters = () =&gt; {<br/>  const { <strong class="lt io">loading</strong>, <strong class="lt io">error</strong>, <strong class="lt io">data</strong> } = <strong class="lt io">useCharacters</strong>(); </span><span id="ec11" class="mv mw in lt b gy nc my l mz na">  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;<br/>  if (error) return &lt;p&gt;Error :(&lt;/p&gt;;</span><span id="7157" class="mv mw in lt b gy nc my l mz na">  return (<br/>   &lt;&gt;<br/>     {<strong class="lt io">data</strong>?.characters.results.map(({ id, name, image }) =&gt; {<br/>       return (<br/>        &lt;div key={id}&gt;<br/>          &lt;img src={image} alt={name} /&gt;<br/>          &lt;p&gt;{name}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>      )})}<br/>   &lt;/&gt;<br/>)};<br/>export default Characters;</span></pre><p id="fa29" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当我们的查询执行并且<code class="fe lq lr ls lt b">loading</code>、<code class="fe lq lr ls lt b">error</code>和<code class="fe lq lr ls lt b">data</code>的值改变时，<code class="fe lq lr ls lt b">Characters</code>组件可以根据查询的状态智能地呈现不同的UI元素:</p><ul class=""><li id="2d79" class="md me in ku b kv kw ky kz lb mf lf mg lj mh ln mi mj mk ml bi translated">只要<code class="fe lq lr ls lt b">loading</code>为<code class="fe lq lr ls lt b">true</code>(例如查询仍在进行中)，组件就会显示<code class="fe lq lr ls lt b">Loading...</code>。</li><li id="be61" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated">当加载为<code class="fe lq lr ls lt b">false</code>且没有<code class="fe lq lr ls lt b">error</code>时，查询完成。</li><li id="f456" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated">该组件呈现服务器返回的字符。</li></ul><p id="5b00" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们可以用我们的单个字符组件做同样的逻辑，创建一个查询，得到我们需要的一切(* <em class="lo">)当然我们也可以使用上面相同的数据，并过滤出我们需要的单个字符的数据，但是让我们看看如何用查询参数</em>得到准确的数据:</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="e41c" class="mv mw in lt b gy mx my l mz na">// custom Hook useSingleCharacter<br/>import { useQuery, gql } from "@apollo/client";</span><span id="ac9e" class="mv mw in lt b gy nc my l mz na">const GET_CHARACTER = gql`<br/>  query <strong class="lt io">GetCharacter</strong>(<strong class="lt io">$characterId: ID!</strong>) {<br/>    character(<strong class="lt io">id: $characterId</strong>) {<br/>      name<br/>      image<br/>      gender<br/>      status<br/>      species<br/>      location {<br/>          name<br/>      }<br/>     }<br/>    }<br/>  `;</span><span id="ed99" class="mv mw in lt b gy nc my l mz na">export const useSingleCharacter = (<strong class="lt io">characterId</strong>) =&gt; {<br/>  const { loading, error, data } = useQuery(GET_CHARACTER, {<br/>    <strong class="lt io"> variables: { characterId },</strong><br/>  });<br/>  return { error, data, loading };<br/>};</span></pre><p id="66b9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">🍎上面的<code class="fe lq lr ls lt b">query</code>操作使用了带有一个参数的名称<code class="fe lq lr ls lt b">GetCharacter</code>。这个参数有一个<code class="fe lq lr ls lt b">$characterId</code>变量，一个<strong class="ku io">类型的</strong>的<code class="fe lq lr ls lt b">ID</code>。<code class="fe lq lr ls lt b">!</code>意味着这个操作是必需的，GraphQL不会执行这个操作，除非我们传递一个类型为<code class="fe lq lr ls lt b">ID</code>的<code class="fe lq lr ls lt b">characterId</code>变量。</p><blockquote class="ne nf ng"><p id="d144" class="ks kt lo ku b kv kw jo kx ky kz jr la nh lc ld le ni lg lh li nj lk ll lm ln ig bi translated">*GraphQL的默认标量<strong class="ku io">类型</strong>有:</p><p id="b9c0" class="ks kt lo ku b kv kw jo kx ky kz jr la nh lc ld le ni lg lh li nj lk ll lm ln ig bi translated"><code class="fe lq lr ls lt b">Int</code>:有符号32位整数</p><p id="c7b2" class="ks kt lo ku b kv kw jo kx ky kz jr la nh lc ld le ni lg lh li nj lk ll lm ln ig bi translated"><code class="fe lq lr ls lt b">Float</code>:有符号双精度浮点值</p><p id="8142" class="ks kt lo ku b kv kw jo kx ky kz jr la nh lc ld le ni lg lh li nj lk ll lm ln ig bi translated"><code class="fe lq lr ls lt b">String</code>:UTF‐8字符序列</p><p id="e912" class="ks kt lo ku b kv kw jo kx ky kz jr la nh lc ld le ni lg lh li nj lk ll lm ln ig bi translated"><code class="fe lq lr ls lt b">Boolean</code> : <code class="fe lq lr ls lt b">true</code>或<code class="fe lq lr ls lt b">false</code></p><p id="334c" class="ks kt lo ku b kv kw jo kx ky kz jr la nh lc ld le ni lg lh li nj lk ll lm ln ig bi translated"><code class="fe lq lr ls lt b">ID</code>(序列化为<code class="fe lq lr ls lt b">String</code>):一个惟一的标识符，通常用于重新提取对象或作为缓存的键。虽然它被序列化为<code class="fe lq lr ls lt b">String</code>，但是<code class="fe lq lr ls lt b">ID</code>并不适合人类阅读。</p></blockquote><p id="2c1b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">注意，这次我们为<code class="fe lq lr ls lt b">useQuery</code>钩子提供了一个配置选项(<code class="fe lq lr ls lt b">variables</code>👇</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="2017" class="mv mw in lt b gy mx my l mz na">variables: { characterId }</span></pre><p id="bcdc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个<code class="fe lq lr ls lt b">variables</code>选项是一个对象，它包含了我们想要传递给GraphQL查询的所有变量，在我们的例子中，我们想要传递当前选择的<strong class="ku io"> <em class="lo">字符化的</em> </strong>，这发生在带有钩子执行的单字符组件内部。</p><p id="00d7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，让我们更新我们的Character.js</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="0065" class="mv mw in lt b gy mx my l mz na">import { useSingleCharacter } from “../hooks/useSingleCharacter”;</span><span id="caf8" class="mv mw in lt b gy nc my l mz na">const Character = () =&gt; {<br/> <strong class="lt io"> const characterId = 1;</strong> // fake id<br/>  const { loading, error, data } = <strong class="lt io">useSingleCharacter</strong>(<strong class="lt io">characterId</strong>); <br/>  if (loading) return &lt;p&gt;Loading…&lt;/p&gt;;<br/>  if (error) return &lt;p&gt;Error :(&lt;/p&gt;;</span><span id="f466" class="mv mw in lt b gy nc my l mz na">  const {name, image, gender, status, location, species} =    data.character; // destructure data</span><span id="77ff" class="mv mw in lt b gy nc my l mz na">  return (<br/>    &lt;div&gt;<br/>      &lt;h2&gt;{name}&lt;/h2&gt;<br/>      &lt;img src={image} alt={name} /&gt;<br/>      &lt;p&gt;Gender: {gender}&lt;/p&gt;<br/>      &lt;p&gt;Status: {status}&lt;/p&gt;<br/>      &lt;p&gt;Species: {species} &lt;/p&gt;<br/>      &lt;p&gt;Location: {location.name}&lt;/p&gt;<br/>      &lt;Link to={“/”}&gt;<br/>         &lt;span role=”img” aria-label=”back”&gt;⏪&lt;/span&gt;<br/>      &lt;/Link&gt;<br/>    &lt;/div&gt;<br/>   )};<br/>export default Character;</span></pre><p id="deeb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">请注意，我们现在使用的是一个假的<strong class="ku io"> characterId = 1 </strong>，因为这个单个字符组件将通过单击image(在Characters.js中)来显示，我们将很快实现它。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="97b3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最后一步，让我们通过点击图片来实现两个组件的交互，我们将使用<a class="ae lp" href="https://reactrouter.com/en/main" rel="noopener ugc nofollow" target="_blank"> <em class="lo"> react-router </em> </a>，首先更新我们的index.js文件👇🏼</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="6f01" class="mv mw in lt b gy mx my l mz na">...// same<br/><strong class="lt io">import { BrowserRouter, Routes, Route } from “react-router-dom”;<br/></strong>import App from “./App”;<br/>import Character from “./components/Character”;</span><span id="fd46" class="mv mw in lt b gy nc my l mz na">const rootElement = ...;<br/>const root = ...;<br/>const client = new ApolloClient(...);</span><span id="5594" class="mv mw in lt b gy nc my l mz na">root.render(<br/>  &lt;StrictMode&gt;<br/>    &lt;ApolloProvider client={client}&gt;<br/>      &lt;<strong class="lt io">BrowserRouter</strong>&gt;<br/>        &lt;Routes&gt;<br/>          &lt;Route path=”/” element={&lt;App /&gt;} /&gt;<br/>          &lt;Route path=”<strong class="lt io">character/:characterId</strong>” <br/>                 element={&lt;<strong class="lt io">Character</strong> /&gt;} /&gt;<br/>          &lt;/Routes&gt;<br/>      &lt;/BrowserRouter&gt;<br/>    &lt;/ApolloProvider&gt;<br/>  &lt;/StrictMode&gt;<br/>);</span></pre><p id="b32c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">*如果我们导航到“…/character/1”我们应该会看到关于角色1的完整信息，数据来自我们的</em> <strong class="ku io"> <em class="lo">使用单个字符</em> </strong> <em class="lo">钩子</em>👐🏼</p><p id="0ac4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然后，让我们实现具有<em class="lo">真实特征</em>的可点击图像，我们只需要将图像包装在<a class="ae lp" href="https://reactrouter.com/en/main/components/link" rel="noopener ugc nofollow" target="_blank"> <em class="lo">链接</em></a><em class="lo">(</em><a class="ae lp" href="https://reactrouter.com/en/main" rel="noopener ugc nofollow" target="_blank"><em class="lo">react-router</em></a><em class="lo">)</em></p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="cc4b" class="mv mw in lt b gy mx my l mz na">// Characters.js<br/>// same ...<br/>&lt;Link to={`character/${<strong class="lt io">id</strong>}`}&gt;<br/>    &lt;img src={image} alt={name} /&gt;<br/>&lt;/Link&gt;</span></pre><p id="19f0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最后一步，更新Character.js，用<em class="lo">真实人物</em>代替之前的<em class="lo">假id </em></p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="0730" class="mv mw in lt b gy mx my l mz na">// use <a class="ae lp" href="https://reactrouter.com/en/main/hooks/use-params" rel="noopener ugc nofollow" target="_blank"><em class="lo">useParams</em></a> from <a class="ae lp" href="https://reactrouter.com/en/main" rel="noopener ugc nofollow" target="_blank"><em class="lo">react-router</em></a><em class="lo"> to</em> get <em class="lo">CharacterId<br/></em>import { useParams } from "react-router-dom";<br/>const { <strong class="lt io">characterId</strong> } = <strong class="lt io">useParams</strong>();<br/>const { loading, error, data } = useSingleCharacter(<strong class="lt io">characterId</strong>);</span></pre><p id="d181" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">总结</strong>以上步骤:</p><ul class=""><li id="6c1a" class="md me in ku b kv kw ky kz lb mf lf mg lj mh ln mi mj mk ml bi translated">创建组件</li><li id="5d54" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated">使用GraphQL API，并通过React自定义挂钩中的查询请求数据</li><li id="d393" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated">从组件执行钩子并获得数据响应，使用<em class="lo">假id </em>进行快速测试</li><li id="4b32" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated">用react-router定义客户端路由，实现两个组件的交互</li><li id="cba8" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated">使用react<em class="lo">-</em>router<em class="lo"/>和<em class="lo"> </em>中的useParams获得<em class="lo">表征</em></li><li id="55c9" class="md me in ku b kv mm ky mn lb mo lf mp lj mq ln mi mj mk ml bi translated">使用动态<em class="lo">特征化</em>和<em class="lo">T33】完成我们的应用程序</em></li></ul><p id="72be" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就是这样！🙌🏼</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="cef3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">还有更多的操作，如突变，订阅，重新提取，缓存，修改缓存数据，乐观的用户界面和分页等</p><p id="8090" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本文中，我只触及了查询的表面，掌握Apollo客户机和GraphQL需要不断的练习，在我的下一篇文章中(希望很快🤞🏻)，我们将了解变异、缓存、保持缓存同步和更新缓存。</p><p id="aafe" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">希望这是有趣的，对你有帮助，如果你也对我的其他文章感兴趣，这里有一些链接，谢谢你的时间🌹</p><div class="nk nl gp gr nm nn"><a href="https://xiaominzhu.medium.com/test-a-react-app-with-jest-and-react-testing-library-da9b59860051" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">用Jest和React- Testing-Library测试React应用程序</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在开发React应用程序时，有一部分我们有时没有认真对待:测试。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">xiaominzhu.medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/suspense-with-lazy-axios-react-471a43113e4b"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">反应:与懒惰和Axios的悬念</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">等等，悬疑不仅仅是代码分裂</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://xiaominzhu.medium.com/common-use-cases-of-react-hook-form-b7cf961a42f6" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">React-Hook-Form库|常见用例</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">因为绝对没有人喜欢创建和重建带有验证的复杂表单</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">xiaominzhu.medium.com</p></div></div><div class="nw l"><div class="od l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/a-shopping-list-with-react-hook-usereducer-310a3b6578"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">用React Hook useReducer创建购物清单</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">带有useReducer React挂钩的购物清单——一个让useReducer更容易理解的小练习。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nw l"><div class="oe l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/create-a-simple-react-custom-hook-fc733d7b977a"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">创建一个简单的React自定义挂钩</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">关于如何创建一个简单的React自定义钩子的教程</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nw l"><div class="of l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/create-a-simple-express-server-node-js-for-react-application-e2b2bd0c7e93"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">为React应用程序创建一个简单的Express服务器(Node.js)</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">关于如何创建一个简单的Express服务器(Node.js)、将其连接到React应用程序以及解决错误的教程…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nw l"><div class="og l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://xiaominzhu.medium.com/react-functional-components-using-refs-a5ad1d2817d4" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">使用引用对功能组件进行反应</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">forwardRef和useImperativeHandle的示例</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">xiaominzhu.medium.com</p></div></div><div class="nw l"><div class="oh l ny nz oa nw ob km nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://medium.com/geekculture/update-parent-state-from-child-component-with-react-context-api-a56cf3742428" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">用React上下文将状态从子节点更新到父节点</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">— React Context提供了一种通过组件树传递数据的方法，而不必在…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="oi l ny nz oa nw ob km nn"/></div></div></a></div><p id="9d3b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">更多内容请看</em><a class="ae lp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">plain English . io</em></strong></a><em class="lo">。报名参加我们的</em> <a class="ae lp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lo">免费周报</em> </strong> </a> <em class="lo">。关注我们上</em><a class="ae lp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">Twitter</em></strong></a><a class="ae lp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">LinkedIn</em></strong></a><strong class="ku io"><em class="lo"/></strong><a class="ae lp" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">YouTube</em></strong></a><strong class="ku io"><em class="lo"/></strong><em class="lo">和</em> <a class="ae lp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lo">不和</em> </strong> </a>  <em class="lo">对成长黑客感兴趣？检查</em> <a class="ae lp" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lo">电路</em> </strong> </a> <strong class="ku io"> <em class="lo">。</em> </strong></p></div></div>    
</body>
</html>