<html>
<head>
<title>How to leverage GitHub and semantic release to reduce vulnerabilities in your packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用GitHub和语义发布来减少包中的漏洞</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-leverage-github-and-semantic-release-to-reduce-vulnerabilities-in-your-packages-c517403e339c?source=collection_archive---------8-----------------------#2022-12-16">https://javascript.plainenglish.io/how-to-leverage-github-and-semantic-release-to-reduce-vulnerabilities-in-your-packages-c517403e339c?source=collection_archive---------8-----------------------#2022-12-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/97af07c88bee11ccf83e3ed9913b5f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTnYjwMydrCp0nedr5YQ8Q.png"/></div></div></figure><div class=""/><p id="87df" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你很可能从个人经验中知道，如今许多项目需要一堆依赖项来开发、编译或运行。</p><p id="4561" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您是否注意到，当您安装项目的依赖项时，npm还会报告这些依赖项中的已知漏洞？</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi kt"><img src="../Images/e3307522e4e31d23f874a808c000a918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yz1QRuo2RpiMHeRlbTkqsQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">`npm install` reporting vulnerabilities</figcaption></figure><p id="133d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使你的项目只使用了少量的直接依赖项，这些依赖项本身也有传递依赖项，等等…你明白我的意思了吧。</p><p id="b6aa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看<a class="ae lc" href="https://github.com/Th3S4mur41/demo-auto-security-release/network/dependencies" rel="noopener ugc nofollow" target="_blank">演示项目</a>的依赖关系树…</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ld"><img src="../Images/cb4cbe5bfe840338591ae3726ea91835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UutH7l2vwVX1fXhIuUPzEQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">List of dependencies and their vulnerabilities in both package.json and package-lock.json</figcaption></figure><p id="3326" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然项目本身“仅仅”有八(8)个直接依赖项在它的<a class="ae lc" href="https://github.com/Th3S4mur41/demo-auto-security-release/blob/main/package.json" rel="noopener ugc nofollow" target="_blank"> <em class="le"> package.json </em> </a>中被引用，但是整个依赖项树总共包含533个包。</p><p id="9c2d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">手动跟踪所有这些依赖项及其漏洞很快就变成了一项乏味的任务，如果不是不可能的话。</p><p id="a819" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是GitHub 可以帮忙的地方。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="3782" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="le">以下所有代码片段都可以从GitHub </em>  <em class="le">上的</em><a class="ae lc" href="https://github.com/Th3S4mur41/demo-auto-security-release" rel="noopener ugc nofollow" target="_blank"><em class="le">demo资源库中派生出来。</em></a></p><h1 id="08e9" class="lm ln iy bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">开源代码库</h1><p id="8cbc" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">Github最近发布了一份减少OWASP漏洞的最佳实践列表。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mp"><img src="../Images/4225337898a2e71a18be2f5bb2aa347e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fMrp413gu07gcZXYv38GAQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Explore how GitHub Advanced Security can help address several of the OWASP Top 10 vulnerabilities</figcaption></figure><p id="aa26" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其中一个技巧是利用<a class="ae lc" href="https://github.blog/2022-05-25-how-we-use-dependabot-to-secure-github/" rel="noopener ugc nofollow" target="_blank">dependent bot</a>来提醒开发者依赖关系中的已知漏洞，并潜在地将这些依赖关系更新到一个补丁版本。</p><p id="5b84" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是激活Dependabot警报和安全更新。这可以在<em class="le">代码安全和分析</em>下的存储库设置中轻松完成，正如你在下面的截图中看到的。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mq"><img src="../Images/1d1c8778b639e3aa26902b6ab0cf0abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2pahwtpfSCKa2qgkyttXQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Github’s “Code security and analysis” repository settings with Dependabot alerts &amp; Dependabot security updates enabled</figcaption></figure><h2 id="0413" class="mr ln iy bd lo ms mt dn ls mu mv dp lw kg mw mx ma kk my mz me ko na nb mi nc bi translated">依赖机器人警报</h2><p id="1932" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">第一个设置将在您使用的依赖关系中存在已知漏洞时提醒您，就像运行<code class="fe nd ne nf ng b">npm audit</code>一样，但它也将帮助您跟踪和管理这些漏洞。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nh"><img src="../Images/2684b6d6654839a5a99aa84ef54bf295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yuJLNnRGx3fUZSq4klfuAQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">The dependabot alerts page showing a single moderate vulnerability</figcaption></figure><h2 id="d8f0" class="mr ln iy bd lo ms mt dn ls mu mv dp lw kg mw mx ma kk my mz me ko na nb mi nc bi translated">依赖机器人安全更新</h2><p id="ff74" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">第二个设置将使dependabot能够尝试并自动修复漏洞。如果依赖项的一个固定版本可用并且与您的存储库兼容，Dependabot将打开一个pull请求来更新受影响的包。</p><h2 id="e360" class="mr ln iy bd lo ms mt dn ls mu mv dp lw kg mw mx ma kk my mz me ko na nb mi nc bi translated">Dependabot版本更新</h2><p id="4aab" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">但是为什么就此打住呢？第三个选项是<em class="le">dependent bot版本更新</em>，它将帮助您创建一个dependent bot配置来自动更新您的所有依赖项。</p><p id="3e37" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的代码是最基本的dependent bot配置，用于每周更新您的npm依赖项，并添加一个用户或团队作为dependent bot将创建的所有拉请求的审查者。</p><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="e395" class="nm ln iy ng b be nn no l np nq"># .github/dependabot.yml<br/>version: 2<br/>updates:<br/>  - package-ecosystem: "npm"<br/>    directory: "/" # Location of package manifests<br/>    schedule:<br/>      interval: "weekly"<br/>    reviewers:<br/>      - "&lt;user or team name&gt;"</span></pre><p id="b51e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae lc" href="https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file" rel="noopener ugc nofollow" target="_blank">官方依赖机器人文档</a>之后，版本更新可以以多种方式进一步定制。</p><h2 id="e110" class="mr ln iy bd lo ms mt dn ls mu mv dp lw kg mw mx ma kk my mz me ko na nb mi nc bi translated">[奖金]让您的CI保持最新</h2><p id="a54d" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">虽然这与您的依赖项没有直接关系，但也可能有助于保持您的CI安全。通过在dependent bot . yml中添加几行代码，您还可以对其进行配置，使您的Github操作保持最新。您只需添加第二个软件包生态系统，代码如下:</p><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="a3e5" class="nm ln iy ng b be nn no l np nq">- package-ecosystem: "github-actions"<br/>    directory: "/"<br/>    schedule:<br/>      interval: "daily"</span></pre></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="3d92" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lc" href="https://github.com/Th3S4mur41/demo-auto-security-release/blob/main/.github/dependabot.yml" rel="noopener ugc nofollow" target="_blank">演示库的dependabot配置</a>被设置为每天更新npm包和Github动作。</p><h2 id="fb4f" class="mr ln iy bd lo ms mt dn ls mu mv dp lw kg mw mx ma kk my mz me ko na nb mi nc bi translated">自动合并从属机器人PR</h2><p id="1370" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">在有很多依赖项的项目中，由Dependabot生成的pull请求的数量会很快成为审查和合并的负担。如果您有一个测试自动化来验证您的拉请求，这是您不再想要手动做的事情。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="8481" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">⚠️ <strong class="jx iz">在实施这一步骤之前，请确保设置分支保护和您可以信任的CI(构建、测试、部署),因为您将不再手动验证这些更改。</strong></p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/541524be51594e83071fe662ff0c4500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOgrG-oDEdAUzuOqMPJvLw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Make sure that PR need to be approved and your relevant CI workflows are successful before allowing pull requests to be merged</figcaption></figure></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="cd0a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过利用Github API创建一个工作流，可以自动合并Dependabot pull请求…</p><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="5cdb" class="nm ln iy ng b be nn no l np nq"># .github/workflows/dependabot-automation.yml<br/>name: Depandabot automation<br/>on: <br/> pull_request_target:    <br/>  types: [opened, synchronize, reopened]<br/>permissions:<br/>  pull-requests: write<br/>  contents: write<br/>jobs:<br/>  dependabot-auto:<br/>    name: '🤖 Dependabot Automation'<br/>    runs-on: ubuntu-latest<br/>    # Only run if PR was opened by dependabot<br/>    if: ${{ github.actor == 'dependabot[bot]' }}<br/>    steps:<br/>      - name: Dependabot metadata<br/>        id: metadata<br/>        uses: dependabot/fetch-metadata@v1<br/>          with:<br/>            github-token: '${{ secrets.GITHUB_TOKEN }}'<br/>      - name: Enable auto-merge for Dependabot PRs<br/>        continue-on-error: true<br/>        # Auto merge dependencies with patch or minor updates<br/>        # Major versions still must be merged manually<br/>        if: ${{(steps.metadata.outputs.update-type == 'version-update:semver-patch') || (steps.metadata.outputs.update-type == 'version-update:semver-minor')}}<br/>        run: gh pr merge --auto --squash "$PR_URL"<br/>        env:<br/>          PR_URL: ${{github.event.pull_request.html_url}}<br/>          # GH_TOKEN needed to trigger follow up worlflow: https://github.com/fastify/github-action-merge-dependabot/issues/134<br/>          GITHUB_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }} </span></pre><p id="27f1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您的分支被配置为在合并前需要批准，您还需要将以下步骤添加到前面的工作流中来处理这一问题。</p><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="8477" class="nm ln iy ng b be nn no l np nq">- name: Approve a PR<br/>    continue-on-error: true<br/>    run: gh pr review --approve "$PR_URL"<br/>    env:<br/>      PR_URL: ${{github.event.pull_request.html_url}}<br/>      # GH_TOKEN needed to approve PR as code owner on protected branches<br/>      GITHUB_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }} </span></pre><p id="660c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，你也可以依赖Github的动作，比如<a class="ae lc" href="https://github.com/marketplace/actions/dependabot-auto-merge" rel="noopener ugc nofollow" target="_blank">dependent bot Auto Merge</a>来简化工作流程，类似于<a class="ae lc" href="https://github.com/Th3S4mur41/demo-auto-security-release/blob/main/.github/workflows/on_dependabot.yml" rel="noopener ugc nofollow" target="_blank">在演示</a>中实现的解决方案。</p><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="8e14" class="nm ln iy ng b be nn no l np nq"><br/># This is the workflow to automatically approve and merge dependabot PRs<br/>#<br/>name: Dependabot automation<br/><br/>on:<br/>  pull_request_target:<br/>    types: [opened, synchronize, reopened]<br/><br/>  # Allows you to run this workflow manually from the Actions tab<br/>  workflow_dispatch:<br/><br/>jobs:<br/>  dependabot:<br/>    name: '🤖 Dependabot Automation'<br/>    runs-on: ubuntu-latest<br/>    if: ${{ github.actor == 'dependabot[bot]' }}<br/><br/>    steps:<br/>      - uses: actions/checkout@v3<br/>        with:<br/>          ref: ${{ github.event.pull_request.head.sha }}<br/><br/>      - uses: ahmadnassri/action-dependabot-auto-merge@v2<br/>        with:<br/>          target: minor<br/>          github-token: ${{ secrets.DEPENDABOT_TOKEN  }}<br/>          command: squash and merge</span></pre><h2 id="99b2" class="mr ln iy bd lo ms mt dn ls mu mv dp lw kg mw mx ma kk my mz me ko na nb mi nc bi translated">避免引入具有新依赖性的漏洞</h2><p id="4539" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">Github团队最近发布了一个名为<a class="ae lc" href="https://github.com/actions/dependency-review-action" rel="noopener ugc nofollow" target="_blank">dependency-review-action</a>的新操作，它可以通过扫描pull请求并在易受攻击的依赖项出现在代码中之前阻止它们的添加，来进一步帮助减少易受攻击的依赖项。</p><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="bf58" class="nm ln iy ng b be nn no l np nq">name: Check Dependencies<br/><br/>on:<br/>  pull_request:<br/>    types: [opened, synchronize, reopened]<br/><br/>permissions:<br/>  contents: read<br/><br/>jobs:<br/>  dependency-review:<br/>    name: '⛓️ Dependency Review'<br/>    runs-on: ubuntu-latest<br/><br/>    steps:<br/>      - name: '☁️ Checkout repository'<br/>        uses: actions/checkout@v3<br/><br/>      - name: '🛡️ Dependency Review'<br/>        uses: actions/dependency-review-action@v3</span></pre></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="d6fb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这些，您已经减少了代码中的漏洞。但是在你创建一个新的版本之前，你的包仍然会受到影响。</p><p id="3925" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这通常是遗留包或者没有被主动或定期维护的包的问题。一旦你进入下一个项目，这不是你想发生在你的包上的事情！</p><h1 id="de45" class="lm ln iy bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">语义释放</h1><p id="2a85" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated"><a class="ae lc" href="https://semantic-release.gitbook.io/semantic-release/" rel="noopener ugc nofollow" target="_blank"> semantic-release </a>是一个帮助你自动化你的包的发布过程的工具，包括更新版本号，生成发布说明和变更日志，将包发布到注册表。</p><h2 id="a039" class="mr ln iy bd lo ms mt dn ls mu mv dp lw kg mw mx ma kk my mz me ko na nb mi nc bi translated">提交格式</h2><p id="c185" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">为了让语义发布能够确定要碰撞语义版本的哪一部分，您的提交需要遵循提交约定。</p><p id="b77e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，我们使用带有默认设置的<a class="ae lc" href="https://github.com/Th3S4mur41/demo-auto-security-release/blob/main/commitlint.config.js" rel="noopener ugc nofollow" target="_blank">扩展的</a><a class="ae lc" href="https://commitlint.js.org/#/" rel="noopener ugc nofollow" target="_blank">提交列表</a>，以确保语义发布能够使用它们。</p><h2 id="0f60" class="mr ln iy bd lo ms mt dn ls mu mv dp lw kg mw mx ma kk my mz me ko na nb mi nc bi translated">自动发布安全修复程序</h2><p id="6d37" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">您还需要配置语义发布…</p><p id="8291" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，要选择哪个分支应该触发发布，您可能还需要添加一些插件来生成发布说明和changelog，发布您的包并生成GitHub标签。</p><p id="f8f3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下设置还将确保生成的changelog以及带有新版本的包配置被提交到您的存储库中。</p><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="1f18" class="nm ln iy ng b be nn no l np nq">{<br/> "branches": ["main"],<br/> "plugins": [<br/>  "@semantic-release/commit-analyzer",<br/>  "@semantic-release/release-notes-generator",<br/>  "@semantic-release/changelog",<br/>  "@semantic-release/npm",<br/>  [<br/>   "@semantic-release/git",<br/>   {<br/>    "assets": ["CHANGELOG.md", "package.json", "package-lock.json"]<br/>   }<br/>  ],<br/>  "@semantic-release/github"<br/> ]<br/>}</span></pre><p id="2ee7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这样？</p><p id="1a40" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不完全是。来自dependabot的默认提交消息不会触发新的发布，所以我们仍然需要做一些事情。</p><p id="3d67" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Matt Rathbun 写了一个<a class="ae lc" href="https://rathbun.dev/posts/semantic-release-dependabot/#approach-2---configure-semantic-release-to-understand-dependabot-commits" rel="noopener ugc nofollow" target="_blank">直截了当的指南</a>来更新你的语义发布配置，以自动触发依赖关系更新的新补丁发布。</p><p id="9401" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该配置包含两项更改:</p><ul class=""><li id="3f8d" class="ns nt iy jx b jy jz kc kd kg nu kk nv ko nw ks nx ny nz oa bi translated">更新提交分析器以发布用于“构建(deps)”提交的新补丁</li><li id="143c" class="ns nt iy jx b jy ob kc oc kg od kk oe ko of ks nx ny nz oa bi translated">更新发布说明生成器，在GitHub发布说明中包含这些提交的详细信息</li></ul><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="82d1" class="nm ln iy ng b be nn no l np nq">"release": <br/>  // ...<br/>  "plugins": [<br/>    [<br/>      "@semantic-release/commit-analyzer",<br/>      {<br/>        "preset": "conventionalcommits",<br/>        "releaseRules": [<br/>          {<br/>            "type": "build",<br/>            "scope": "deps",<br/>            "release": "patch"<br/>          }<br/>        ]<br/>      }<br/>    ],<br/>    [<br/>      "@semantic-release/release-notes-generator",<br/>      {<br/>        "preset": "conventionalcommits",<br/>        "presetConfig": {<br/>          "types": [<br/>            {<br/>              "type": "feat",<br/>              "section": "Features"<br/>            },<br/>            {<br/>              "type": "fix",<br/>              "section": "Bug Fixes"<br/>            },<br/>            {<br/>              "type": "build",<br/>              "section": "Dependencies and Other Build Updates",<br/>              "hidden": false<br/>            }<br/>          ]<br/>        }<br/>      }<br/>    ]<br/>    // ...<br/>  ]<br/>}{</span></pre><p id="e470" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">剩下要做的就是在主分支上的每一次推动都触发语义释放。</p><pre class="ku kv kw kx gt ni ng nj bn nk nl bi"><span id="809c" class="nm ln iy ng b be nn no l np nq">name: 'Semantic release'<br/><br/>on:<br/>  push:<br/>    branches: [main]<br/><br/>jobs:<br/>  # jobs to check your code come here<br/><br/>  release:<br/>    name: '🏷️ Release'<br/>    runs-on: ubuntu-latest<br/><br/>    environment:<br/>      name: production<br/>      url: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.release.outputs.version }}<br/><br/>    outputs:<br/>      version: ${{ steps.release.outputs.version }}<br/><br/>    steps:<br/>      - name: '☁️ Checkout repository'<br/>        uses: actions/checkout@v3<br/>        with:<br/>          fetch-depth: 0<br/>          persist-credentials: false<br/><br/>      - name: '⚙️ Use Node.js'<br/>        uses: actions/setup-node@v3<br/>        with:<br/>          check-latest: true<br/>          cache: 'npm'<br/><br/>      - name: '⛓️ Install dependencies'<br/>        run: npm ci --omit=optional --audit=false --prefer-offline --progress=false<br/><br/>      - name: '📦 Release'<br/>        id: release<br/>        env:<br/>          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}<br/>          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }} # Needed to push to GitHub<br/>        run: |<br/>          npx semantic-release<br/>          echo "::set-output name=version::$(npm run env | grep npm_package_version | cut -d '=' -f 2)"n::$(npm run env | grep npm_package_version | cut -d '=' -f 2)"</span></pre><p id="8d37" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，每次Dependabot修复您的依赖关系中的漏洞时，CI都会发布一个包含修复的软件包的新版本。</p><h1 id="459b" class="lm ln iy bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="4a33" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">通过结合这两个工具，您可以减少您的包中的漏洞的风险，而不用花费您的一分钟时间…我要说，这绝对值得花费最初的努力来做一点配置。</p><p id="0495" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你怎么想呢?</p><p id="266d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="le">更多内容请看</em><a class="ae lc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="le">plain English . io</em></strong></a><em class="le">。报名参加我们的</em> <a class="ae lc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> <em class="le">免费周报</em> </strong> </a> <em class="le">。关注我们关于</em><a class="ae lc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="le">Twitter</em></strong></a><a class="ae lc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="le">LinkedIn</em></strong></a><em class="le"/><a class="ae lc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="le">YouTube</em></strong></a><em class="le"/><a class="ae lc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="le">不和</em> </strong> </a> <strong class="jx iz"> <em class="le">。</em>T49】</strong></p><p id="d21e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="le">对缩放您的软件启动感兴趣</em> </strong> <em class="le">？检查</em> <a class="ae lc" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> <em class="le">电路</em> </strong> </a> <em class="le">。</em></p></div></div>    
</body>
</html>