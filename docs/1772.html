<html>
<head>
<title>Basic Authentication with AWS Cognito and Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Cognito和Next.js进行基本身份验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basic-authentication-with-aws-cognito-nextjs-69ef122096cf?source=collection_archive---------13-----------------------#2022-04-18">https://javascript.plainenglish.io/basic-authentication-with-aws-cognito-nextjs-69ef122096cf?source=collection_archive---------13-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9e52e0951ec4848eba5c886b64a70878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qeQuzbyeTc-8_uWB"/></div></div></figure><p id="9422" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我以前写过不少关于认证的文章。这是另一篇用户授权文章。</p><p id="d110" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，这一次，有点不一样了。以前的文章都是关于自己管理用户认证的。在本文中，我们将利用AWS Cognito及其用户池来实现相同的功能。</p><p id="8165" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在这里查看我以前的一些关于手动处理用户授权的文章:</p><ol class=""><li id="cda4" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><a class="ae lc" href="https://kelvinmwinuka.com/how-to-create-registration-authentication-with-express-passportjs/#more-918" rel="noopener ugc nofollow" target="_blank">如何用Express &amp; Passport.js </a>创建注册&amp;认证。</li><li id="0639" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated"><a class="ae lc" href="https://kelvinmwinuka.com/how-to-handle-password-reset-in-expressjs/" rel="noopener ugc nofollow" target="_blank">如何在快递中处理密码重置</a>。</li><li id="7493" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated"><a class="ae lc" href="https://kelvinmwinuka.com/how-to-verify-users-in-expressjs/" rel="noopener ugc nofollow" target="_blank">如何在快递中验证用户</a></li></ol><h1 id="27c0" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">设置</h1><p id="f6b8" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">本文假设您已经设置了一个AWS Cognito用户池，并且还设置了一些Next.js样板代码。我将写另一篇文章解释如何使用AWS控制台设置Cognito用户池。</p><p id="a5ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们来了解一下项目结构。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0a6a" class="mu lj in mq b gy mv mw l mx my">.<br/>├── components<br/>│   ├── layouts<br/>│   │   └── InputLayout.js<br/>│   ├── AuthLinkText.js<br/>│   ├── InputField.js<br/>│   ├── InputHelperText.js<br/>│   ├── Label.js<br/>│   └── SubmitButton.js<br/>├── hooks<br/>│   ├── useAuth.js<br/>│   ├── useRegister.js<br/>│   └── useValidationSchema.js<br/>├── pages<br/>│   ├── api<br/>│   │   ├── confirm<br/>│   │   │   ├── index.js<br/>│   │   │   └── send.js<br/>│   │   ├── password<br/>│   │   │   ├── reset.js<br/>│   │   │   └── reset_code.js<br/>│   │   ├── login.js<br/>│   │   └── register.js<br/>│   ├── password<br/>│   │   ├── reset.js<br/>│   │   └── reset_code.js<br/>│   ├── _app.js<br/>│   ├── confirm.js<br/>│   ├── index.js<br/>│   ├── login.js<br/>│   └── register.js<br/>├── public<br/>│   ├── favicon.ico<br/>│   └── vercel.svg<br/>├── styles<br/>│   ├── Home.module.css<br/>│   └── globals.css<br/>├── README.md<br/>├── next.config.js<br/>├── package-lock.json<br/>└── package.json</span></pre><p id="6072" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数都没什么特别的，因为它们是在设置Next.js项目时自动创建的。</p><p id="872b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“组件”文件夹包含所有可重用的定制组件，如表单输入字段和布局。</p><p id="9489" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我将重点介绍“钩子”和“页面”文件夹。如果你想看完整的代码，你可以在<a class="ae lc" href="https://github.com/kelvinmwinuka/cognito-next" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><p id="2c69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“hooks”文件夹有3个文件:</p><ol class=""><li id="5581" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">useAuth.js包含一个钩子来处理用户登录和密码重置。</li><li id="e381" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">js包含一个钩子来处理用户注册和验证。</li><li id="1857" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">useValidationSchema.js包含表单验证架构。我们不会在文章中涉及这一点。请随时查看回购的更多细节。</li></ol><p id="76a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我更喜欢使用钩子，因为它们允许我将组件中的业务逻辑和UI逻辑分开。</p><p id="2b36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“页面”文件夹有一个“API”子目录。这是所有后端代码所在的地方。</p><p id="4b1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Next.js使用基于文件系统的路由，因此文件结构决定了API端点。</p><p id="e420" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">API子目录之外的所有其他文件和子目录将被视为前端页面。</p><p id="9659" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确保安装了<a class="ae lc" href="https://www.npmjs.com/package/@aws-sdk/client-cognito-identity-provider" rel="noopener ugc nofollow" target="_blank">@ AWS-SDK/client-cognito-identity-provider</a>包。</p><p id="7438" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以参考完整的<a class="ae lc" href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-cognito-identity-provider/index.html#aws-sdkclient-cognito-identity-provider" rel="noopener ugc nofollow" target="_blank">CognitoIdentityServiceProvider SDK</a>来获得对本文所讨论内容的更深入的解释。</p><h1 id="9b48" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">签约雇用</h1><p id="d872" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">首先，让我们处理用户注册。导航到“pages/api/register.js”并添加以下代码:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="fa39" class="mu lj in mq b gy mv mw l mx my">import { CognitoIdentityProviderClient, SignUpCommand } from '<a class="ae lc" href="http://twitter.com/aws" rel="noopener ugc nofollow" target="_blank">@aws</a>-sdk/client-cognito-identity-provider'</span><span id="e751" class="mu lj in mq b gy mz mw l mx my">const { COGNITO_REGION, COGNITO_APP_CLIENT_ID } = process.env</span><span id="9395" class="mu lj in mq b gy mz mw l mx my">export default async function handler(req, res) {<br/>    if (req.method !== 'POST') return res.status(405).send()</span><span id="3347" class="mu lj in mq b gy mz mw l mx my">const params = {<br/>        ClientId: COGNITO_APP_CLIENT_ID,<br/>        Password: req.body.password,<br/>        Username: req.body.username,<br/>        UserAttributes: [<br/>            {<br/>                Name: 'email',<br/>                Value: req.body.email<br/>            }<br/>        ]<br/>    }</span><span id="fea8" class="mu lj in mq b gy mz mw l mx my">const cognitoClient = new CognitoIdentityProviderClient({<br/>        region: COGNITO\_REGION<br/>    })<br/>    const signUpCommand = new SignUpCommand(params)</span><span id="2b01" class="mu lj in mq b gy mz mw l mx my">try {<br/>        const response = await cognitoClient.send(signUpCommand)<br/>        return res.status(response['$metadata'].httpStatusCode).send()<br/>    } catch (err) {<br/>        console.log(err)<br/>        return res.status(err['$metadata'].httpStatusCode).json({ message: err.toString() })<br/>    }<br/>}</span></pre><p id="4d1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是“/api/register”端点的处理程序。包括一个guard子句，以确保只允许POST请求，对于任何其他类型的请求都返回405错误。</p><p id="8b8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在参数中，我们有以下内容:</p><ol class=""><li id="3a85" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">ClientId —您在AWS控制台中为此用户池创建的应用程序客户端Id。</li><li id="20d3" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">密码—用户选择的密码。</li><li id="7c45" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">用户名-用户选择的用户名。</li><li id="e506" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">UserAttributes —用户在注册时提供的任何附加属性。默认的属性列表包括地址、昵称、生日、电话号码、电子邮件、姓氏、首选用户名、性别、个人资料、名字、zoneinfo、地区、更新时间、中间名、网站和姓名。您也可以添加自定义属性(例如，如果您正在为一个组织创建一个身份验证系统，则为“部门”)。</li></ol><p id="476a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，如果您正在设置自定义用户属性，您需要遵循以下格式:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="61c1" class="mu lj in mq b gy mv mw l mx my">{<br/>    Name: 'custom:&lt;AttributeName&gt;',                <br/>    Value: '&lt;AttributeValue&gt;'<br/>}</span></pre><p id="d981" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在添加部门属性的情况下，它看起来像这样:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3ae9" class="mu lj in mq b gy mv mw l mx my">{<br/>    Name: 'custom:Department',                <br/>    Value: 'Engineering'<br/>}</span></pre><p id="894f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们发送注册命令来触发用户注册。如果一切顺利，返回status 200响应，否则，返回来自Cognito的错误代码和错误的字符串化版本。</p><p id="5ecd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Cognito通常会返回如下所示的错误:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="728c" class="mu lj in mq b gy mv mw l mx my">UsernameExistsException: User already exists<br/>...<br/>{<br/>  '$fault': 'client',<br/>  '$metadata': {<br/>    httpStatusCode: 400,<br/>    requestId: '9442223e-ef29-40c1-880e-6689638d8042',<br/>    extendedRequestId: undefined,<br/>    cfId: undefined,<br/>    attempts: 1,<br/>    totalRetryDelay: 0<br/>  },<br/>  __type: 'UsernameExistsException'<br/>}</span></pre><p id="caa6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">抓取状态码和消息，然后转发到前端。</p><p id="a3a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当请求成功时，Cognito将返回如下所示的响应:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d69a" class="mu lj in mq b gy mv mw l mx my">{<br/>  '$metadata': {<br/>    httpStatusCode: 200,<br/>    requestId: '67f6d99c-d13c-4677-ab46-957d88f62bb9',<br/>    extendedRequestId: undefined,<br/>    cfId: undefined,<br/>    attempts: 1,<br/>    totalRetryDelay: 0<br/>  },<br/>  AuthenticationResult: {<br/>    AccessToken: "...",<br/>    ExpiresIn: 3600,<br/>    NewDeviceMetadata: undefined,<br/>    RefreshToken: "...",<br/>    TokenType: "Bearer"<br/>  },<br/>  ChallengeName: undefined,<br/>  ChallengeParameters: {},<br/>  Session: undefined<br/>}</span></pre><p id="bbf2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这个应用程序，我们只对身份验证结果感兴趣，因为它包含访问和刷新令牌。</p><p id="239c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">充实useRegister挂钩，以便利用我们在上面创建的API端点。</p><p id="3cd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用以下逻辑创建一个名为“register”的方法:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ed05" class="mu lj in mq b gy mv mw l mx my">import { useRouter } from 'next/router'</span><span id="b187" class="mu lj in mq b gy mz mw l mx my">export default function useRegister() {</span><span id="b448" class="mu lj in mq b gy mz mw l mx my">const router = useRouter()</span><span id="ae15" class="mu lj in mq b gy mz mw l mx my">const register = (values, { setSubmitting }) =&gt; {<br/>        fetch('/api/register', {<br/>            method: 'POST',<br/>            headers: {<br/>                'Content-Type': 'application/json'<br/>            },<br/>            body: JSON.stringify(values)<br/>        }).then(res =&gt; {<br/>            if (!res.ok) throw res<br/>            router.push({<br/>                pathname: '/confirm',<br/>                query: { username: values?.username }<br/>            },<br/>                "/confirm")<br/>        }).catch(err =&gt; {<br/>            console.error(err)<br/>        }).finally(() =&gt; {<br/>            setSubmitting(false)<br/>        })<br/>    }</span><span id="e531" class="mu lj in mq b gy mz mw l mx my">const confirm = (values, { setSubmitting }) =&gt; {<br/>        // Confirm the user<br/>    }</span><span id="d12b" class="mu lj in mq b gy mz mw l mx my">return {<br/>        register,<br/>        confirm<br/>    }<br/>}</span></pre><p id="dd47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">register方法是我们注册表单的提交方法。“values”对象包含表单数据,“setSubmitting”允许我们在处理完请求后更新加载状态。</p><p id="c8db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将是这个项目中大多数钩子的共同主题。</p><p id="f02c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将Content-Type头设置为“application/json ”,以帮助Next.js解析请求体。</p><p id="ff99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个方法中，我们调用register端点并传递所有表单值(包括用户名、电子邮件和密码)。如果请求成功，我们将重定向到确认页面，并提示用户验证他们的电子邮件地址。在<a class="ae lc" href="https://kelvinmwinuka.com/basic-authentication-with-aws-cognito-and-nextjs#verification" rel="noopener ugc nofollow" target="_blank">验证</a>部分有更多相关信息。</p><p id="9d41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能会注意到我们这里有一个空的确认方法。该方法将处理验证用户的请求。我们也将在验证阶段讨论这一点。</p><p id="5243" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是注册表单的样子，注意我们导入了useRegister钩子，并将Register方法作为表单提交处理程序传递。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="cad0" class="mu lj in mq b gy mv mw l mx my">import { Formik } from "formik";<br/>import InputLayout from "../components/layouts/InputLayout";<br/>import Label from "../components/Label";<br/>import InputField from "../components/InputField";<br/>import InputHelperText from "../components/InputHelperText";<br/>import AuthLinkText from "../components/AuthLinkText";<br/>import SubmitButton from "../components/SubmitButton";<br/>import useValidationSchema from "../hooks/useValidationSchema";<br/>import useRegister from '../hooks/useRegister'<br/>import Link from "next/link";</span><span id="b98b" class="mu lj in mq b gy mz mw l mx my">export default function Register() {</span><span id="4f24" class="mu lj in mq b gy mz mw l mx my">const { registerSchema } = useValidationSchema()<br/>    const { register } = useRegister()</span><span id="bd0e" class="mu lj in mq b gy mz mw l mx my">return (<br/>        &lt;div style={{<br/>            padding: "10px"<br/>        }}&gt;<br/>            &lt;Formik<br/>                initialValues={{<br/>                    username: "",<br/>                    email: "",<br/>                    password: "",<br/>                    confirm_password: ""<br/>                }}<br/>                validationSchema={registerSchema}<br/>                onSubmit={register}<br/>                validateOnMount={false}<br/>                validateOnChange={false}<br/>                validateOnBlur={false}&gt;<br/>                {({<br/>                    isSubmitting,<br/>                    errors,<br/>                    values,<br/>                    handleSubmit,<br/>                    handleChange,<br/>                    handleBlur<br/>                }) =&gt; (<br/>                    &lt;form onSubmit={handleSubmit}&gt;<br/>                        &lt;InputLayout&gt;<br/>                            &lt;Label&gt;Username&lt;/Label&gt;<br/>                            &lt;InputField<br/>                                type="text"<br/>                                name="username"<br/>                                placeholder="Username"<br/>                                onChange={handleChange}<br/>                                onBlur={handleBlur}<br/>                                value={values?.username}<br/>                            /&gt;<br/>                            &lt;InputHelperText isError&gt;{errors?.username}&lt;/InputHelperText&gt;<br/>                        &lt;/InputLayout&gt;<br/>                        &lt;InputLayout&gt;<br/>                            &lt;Label&gt;Email&lt;/Label&gt;<br/>                            &lt;InputField<br/>                                type="email"<br/>                                name="email"<br/>                                placeholder="Email"<br/>                                onChange={handleChange}<br/>                                onBlur={handleBlur}<br/>                                value={values?.email}<br/>                            /&gt;<br/>                            &lt;InputHelperText isError&gt;{errors?.email}&lt;/InputHelperText&gt;<br/>                        &lt;/InputLayout&gt;<br/>                        &lt;InputLayout&gt;<br/>                            &lt;Label&gt;Password&lt;/Label&gt;<br/>                            &lt;InputField<br/>                                type="password"<br/>                                name="password"<br/>                                placeholder="Password"<br/>                                onChange={handleChange}<br/>                                onBlur={handleBlur}<br/>                                value={values?.password}<br/>                            /&gt;<br/>                            &lt;InputHelperText isError&gt;{errors?.password}&lt;/InputHelperText&gt;<br/>                        &lt;/InputLayout&gt;<br/>                        &lt;InputLayout&gt;<br/>                            &lt;Label&gt;Confirm password&lt;/Label&gt;<br/>                            &lt;InputField<br/>                                type="password"<br/>                                name="confirm_password"<br/>                                placeholder="Confirm password"<br/>                                onChange={handleChange}<br/>                                onBlur={handleBlur}<br/>                                value={values?.confirm_password}<br/>                            /&gt;<br/>                            &lt;InputHelperText isError&gt;{errors?.confirm_password}&lt;/InputHelperText&gt;<br/>                        &lt;/InputLayout&gt;<br/>                        &lt;InputLayout&gt;<br/>                            &lt;AuthLinkText href="/login"&gt;Already have an account? Log in&lt;/AuthLinkText&gt;<br/>                        &lt;/InputLayout&gt;<br/>                        &lt;SubmitButton isSubmitting={isSubmitting} /&gt;<br/>                    &lt;/form&gt;<br/>                )}<br/>            &lt;/Formik&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><h1 id="0bae" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">签到</h1><p id="6312" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">现在我们已经注册了我们的用户，是时候允许他们登录我们的应用程序了，方法是根据我们的Cognito用户池对他们进行身份验证。</p><p id="9ab9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将以下代码添加到“pages/api/login.js”文件中。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="99b9" class="mu lj in mq b gy mv mw l mx my">import { CognitoIdentityProviderClient, AdminInitiateAuthCommand } from "@aws-sdk/client-cognito-identity-provider"<br/><br/>const { COGNITO_REGION, COGNITO_APP_CLIENT_ID, COGNITO_USER_POOL_ID } = process.env<br/><br/>export default async function handler(req, res) {<br/>    if (req.method !== 'POST') return res.status(405).send()<br/><br/>    const params = {<br/>        AuthFlow: 'ADMIN_USER_PASSWORD_AUTH',<br/>        ClientId: COGNITO_APP_CLIENT_ID,<br/>        UserPoolId: COGNITO_USER_POOL_ID,<br/>        AuthParameters: {<br/>            USERNAME: req.body.username,<br/>            PASSWORD: req.body.password<br/>        }<br/>    }<br/><br/>    const cognitoClient = new CognitoIdentityProviderClient({<br/>        region: COGNITO_REGION<br/>    })<br/>    const adminInitiateAuthCommand = new AdminInitiateAuthCommand(params)<br/><br/>    try {<br/>        const response = await cognitoClient.send(adminInitiateAuthCommand)<br/>        console.log(response)<br/>        return res.status(response['$metadata'].httpStatusCode).json({<br/>            ...response.AuthenticationResult<br/>        })<br/>    } catch(err) {<br/>        console.log(err)<br/>        return res.status(err['$metadata'].httpStatusCode).json({ message: err.toString() })<br/>    }<br/>}</span></pre><p id="b63f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，我们只处理用户名/密码认证。为此，我们需要使用<code class="fe na nb nc mq b">ADMIN_USER_PASSWORD_AUTH</code>流程。此身份验证流程需要开发人员凭据。如果你在一个安全的服务器上认证用户，这是推荐的方法，优于使用<code class="fe na nb nc mq b">USER_PASSWORD_AUTH</code>的<code class="fe na nb nc mq b">InitiateAuthCommand</code>。</p><p id="e72b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一个参数是AuthParameters。它只包含提交表单时传递给端点的用户名和密码。这里要小心，确保auth参数都是大写的，否则，它们不会被识别。</p><p id="8c1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们把注意力转移到“useAuth”钩子上。将此代码添加到“hooks/useAuth.js”文件中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0f0e" class="mu lj in mq b gy mv mw l mx my">import { useRouter } from "next/router";</span><span id="79fe" class="mu lj in mq b gy mz mw l mx my">export default function useAuth(){</span><span id="df40" class="mu lj in mq b gy mz mw l mx my">const router = useRouter()</span><span id="350e" class="mu lj in mq b gy mz mw l mx my">const login = (values, { setSubmitting }) =&gt; {<br/>    fetch('/api/login', {<br/>      method: 'POST',<br/>      headers: {<br/>        'Content-Type': 'application/json'<br/>      },<br/>      body: JSON.stringify(values)<br/>    }).then(res =&gt; {<br/>      if (!res.ok) throw res<br/>    }).then(data =&gt; {<br/>      console.log(data)<br/>    }).catch(async err =&gt; {<br/>      const responseData = await err.json()<br/>      if (responseData?.message?.includes("UserNotConfirmedException:")) {<br/>        // Trigger confirmation code email<br/>        await fetch('/api/confirm/send', {<br/>          method: 'POST',<br/>          headers: {<br/>            'Content-Type': 'application/json'<br/>          },<br/>          body: JSON.stringify({ username: values.username })<br/>        })<br/>        await router.push(<br/>      {<br/>            pathname: "/confirm",<br/>            query: {username: values.username},<br/>          },<br/>          "/confirm")<br/>      }<br/>    }).finally(() =&gt; {<br/>      setSubmitting(false)<br/>    })<br/>  }</span><span id="4be3" class="mu lj in mq b gy mz mw l mx my">const resetPasswordRequest = (values, { setSubmitting }) =&gt; {<br/>    // Send the password reset code<br/>  }</span><span id="e6a1" class="mu lj in mq b gy mz mw l mx my">const resetPassword = (values, { setSubmitting }) =&gt; {<br/>    // Send request to reset password<br/>  }</span><span id="2eef" class="mu lj in mq b gy mz mw l mx my">return {<br/>    login,<br/>    resetPasswordRequest,<br/>    resetPassword<br/>  }<br/>}</span></pre><p id="a8c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有一个类似于上面创建的注册方法的登录方法。“值”对象表示我们的表单数据(用户名和密码)。</p><p id="3f9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意的是，如果用户还没有被验证/确认，Cognito将不允许用户被认证。因此尝试使用未经确认的用户登录将会返回一个错误。</p><p id="f06e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要处理这种情况，触发一个端点向用户发送确认电子邮件，然后将他们重定向到确认页面，以便他们可以被验证。在<a class="ae lc" href="https://kelvinmwinuka.com/basic-authentication-with-aws-cognito-and-nextjs#verification" rel="noopener ugc nofollow" target="_blank">验证</a>部分有更多关于这个端点的信息。</p><p id="5516" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的登录页面有以下代码:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="266a" class="mu lj in mq b gy mv mw l mx my">import { Formik } from "formik";<br/>import InputLayout from "../components/layouts/InputLayout";<br/>import Label from "../components/Label";<br/>import InputField from "../components/InputField";<br/>import InputHelperText from "../components/InputHelperText";<br/>import AuthLinkText from "../components/AuthLinkText";<br/>import SubmitButton from "../components/SubmitButton";<br/>import useAuth from "../hooks/useAuth";<br/>import useValidationSchema from "../hooks/useValidationSchema";<br/>import { useRouter } from "next/router";</span><span id="3408" class="mu lj in mq b gy mz mw l mx my">export default function Login() {</span><span id="0365" class="mu lj in mq b gy mz mw l mx my">const router = useRouter();<br/>  const { success } = router.query;</span><span id="912f" class="mu lj in mq b gy mz mw l mx my">const { loginSchema } = useValidationSchema();<br/>  const { login } = useAuth();</span><span id="6e36" class="mu lj in mq b gy mz mw l mx my">return (<br/>    &lt;div style={{<br/>      padding: "10px"<br/>    }}&gt;<br/>      {<br/>        success === "true" &amp;&amp;<br/>        &lt;div style={{<br/>          paddingTop: "10px",<br/>          paddingBottom: "10px",<br/>          color: "green"<br/>        }}&gt;<br/>          {'You\\'re signed up!'}<br/>        &lt;/div&gt;<br/>      }<br/>      &lt;Formik<br/>        initialValues={{<br/>          username: "",<br/>          password: ""<br/>        }}<br/>        validationSchema={loginSchema}<br/>        onSubmit={login}<br/>        validateOnMount={false}<br/>        validateOnChange={false}<br/>        validateOnBlur={false}&gt;<br/>        {({<br/>          isSubmitting,<br/>          errors,<br/>          values,<br/>          handleChange,<br/>          handleBlur,<br/>          handleSubmit<br/>        }) =&gt; (<br/>          &lt;form onSubmit={handleSubmit}&gt;<br/>            &lt;InputLayout&gt;<br/>              &lt;Label&gt;Username&lt;/Label&gt;<br/>              &lt;InputField<br/>                type="text"<br/>                name="username"<br/>                placeholder="Username or email"<br/>                onChange={handleChange}<br/>                onBlur={handleBlur}<br/>                value={values?.username}<br/>              /&gt;<br/>              &lt;InputHelperText isError&gt;{errors?.username}&lt;/InputHelperText&gt;<br/>            &lt;/InputLayout&gt;<br/>            &lt;InputLayout&gt;<br/>              &lt;Label&gt;Password&lt;/Label&gt;<br/>              &lt;InputField<br/>                type="password"<br/>                name="password"<br/>                placeholder="Password"<br/>                onChange={handleChange}<br/>                onBlur={handleBlur}<br/>                value={values?.password}<br/>              /&gt;<br/>              &lt;InputHelperText isError&gt;{errors?.password}&lt;/InputHelperText&gt;<br/>            &lt;/InputLayout&gt;<br/>            &lt;InputLayout&gt;<br/>              &lt;AuthLinkText href="/password/reset_code"&gt;{'Forgot password?'}&lt;/AuthLinkText&gt;<br/>            &lt;/InputLayout&gt;<br/>            &lt;InputLayout&gt;<br/>              &lt;AuthLinkText href="/register"&gt;{'Don\\'t have an account? Register.'}&lt;/AuthLinkText&gt;<br/>            &lt;/InputLayout&gt;<br/>            &lt;SubmitButton isSubmitting={isSubmitting} /&gt;<br/>          &lt;/form&gt;<br/>        )}<br/>      &lt;/Formik&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b04c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像前面一样，我们导入useAuth钩子，并利用它的login方法作为表单提交处理程序。</p><p id="e498" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将在<a class="ae lc" href="https://kelvinmwinuka.com/basic-authentication-with-aws-cognito-and-nextjs#passwordreset" rel="noopener ugc nofollow" target="_blank">密码重置</a>部分讨论useAuth挂钩中的两种密码重置方法。</p><h1 id="c79e" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">确认</h1><p id="e71d" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">所以我们已经注册了我们的用户，但是我们不能验证他们，因为他们没有被验证。让我们解决这个问题。</p><p id="f8a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们继续之前，需要注意一些事情:</p><ol class=""><li id="8aab" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我已经设置了我的用户池，使用电子邮件代码进行验证。AWS将在这里发送一封电子邮件，其中包含用户必须在您的应用程序上手动输入的代码。其他身份验证方法包括:可点击的验证链接和发送到他们电话号码的验证码。如果您使用任何其他验证方法(除了电话号码的验证码)，那么您可以跳过这一部分。</li><li id="c706" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">成功注册后，Cognito将自动触发所选的验证方法。验证也可以通过SDK触发。</li></ol><p id="06a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“pages/api/confirm/index.js”文件中，添加以下代码:</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/40be220c944be216b2349770248fbaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jj8JqQpjw_o6X-MgnT9Xg.png"/></div></div></figure><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a5a2" class="mu lj in mq b gy mv mw l mx my">import {<br/>    CognitoIdentityProviderClient,<br/>    ConfirmSignUpCommand<br/>} from "<a class="ae lc" href="http://twitter.com/aws" rel="noopener ugc nofollow" target="_blank">@aws</a>-sdk/client-cognito-identity-provider"</span><span id="b88a" class="mu lj in mq b gy mz mw l mx my">const { COGNITO_REGION, COGNITO_APP_CLIENT_ID } = process.env</span><span id="9ba5" class="mu lj in mq b gy mz mw l mx my">export default async function handler (req, res) {<br/>    if (req.method !== 'POST') return res.status(405).send()</span><span id="d163" class="mu lj in mq b gy mz mw l mx my">const params = {<br/>        ClientId: COGNITO_APP_CLIENT_ID,<br/>        ConfirmationCode: req.body.code,<br/>        Username: req.body.username<br/>    }</span><span id="645d" class="mu lj in mq b gy mz mw l mx my">const cognitoClient = new CognitoIdentityProviderClient({<br/>        region: COGNITO_REGION<br/>    })<br/>    const confirmSignUpCommand = new ConfirmSignUpCommand(params)</span><span id="d5f2" class="mu lj in mq b gy mz mw l mx my">try {<br/>        const response = await cognitoClient.send(confirmSignUpCommand)<br/>        console.log(response)<br/>        return res.status(response['$metadata'].httpStatusCode).send()<br/>    } catch (err) {<br/>        console.log(err)<br/>        return res.status(err['$metadata'].httpStatusCode).json({ message: err.toString() })<br/>    }<br/>}</span></pre><p id="1b89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里创建并发送带有以下参数的<code class="fe na nb nc mq b">confirmSignUpCommand</code>:</p><ol class=""><li id="fbe5" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">ClientId。</li><li id="3167" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">ConfirmationCode —由Cognito发送到用户电子邮件/电话的代码。</li><li id="a6f1" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">用户名—您要验证的用户的用户名。</li></ol><p id="c1d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，因为这是确认目录中的索引文件，所以我们在调用这个端点时不需要指定文件名。端点应该是“/api/confirm”</p><p id="bf99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在同一个确认目录中，我们有一个名为“send.js”的文件。该文件负责手动触发确认码电子邮件。</p><p id="7c86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将以下代码添加到该文件中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0772" class="mu lj in mq b gy mv mw l mx my">import {<br/>    CognitoIdentityProviderClient,<br/>    ResendConfirmationCodeCommand<br/>} from "<a class="ae lc" href="http://twitter.com/aws" rel="noopener ugc nofollow" target="_blank">@aws</a>-sdk/client-cognito-identity-provider"</span><span id="b744" class="mu lj in mq b gy mz mw l mx my">const { COGNITO_REGION, COGNITO_APP_CLIENT_ID } = process.env</span><span id="df2e" class="mu lj in mq b gy mz mw l mx my">export default async function handler (req, res) {<br/>    if (req.method !== 'POST') return res.status(405).send()</span><span id="9a59" class="mu lj in mq b gy mz mw l mx my">const params = {<br/>        ClientId: COGNITO_APP_CLIENT_ID,<br/>        Username: req.body.username<br/>    }</span><span id="4773" class="mu lj in mq b gy mz mw l mx my">const cognitoClient = new CognitoIdentityProviderClient({<br/>        region: COGNITO_REGION<br/>    })<br/>    const resendConfirmationCodeCommand = new ResendConfirmationCodeCommand(params)</span><span id="b57a" class="mu lj in mq b gy mz mw l mx my">try {<br/>        const response = await cognitoClient.send(resendConfirmationCodeCommand)<br/>        console.log(response)<br/>        return res.status(response['$metadata'].httpStatusCode).send()<br/>    } catch (err) {<br/>        console.log(err)<br/>        return res.stat(err['$metadata'].httpStatusCode).json({ message: err.toString() })<br/>    }<br/>}</span></pre><p id="e311" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，只需创建并发送带有params对象的<code class="fe na nb nc mq b">ResendConfirmationCodeCommand</code>，该对象包含您想要验证的用户的ClientId和用户名。</p><p id="4f1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Cognito将搜索具有指定用户名的用户，然后根据您的设置和/或提供的设置向他们的电子邮件/电话号码发送验证码。</p><p id="a296" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能想知道为什么这个命令叫做<code class="fe na nb nc mq b">ResendConfirmationCodeCommand</code>。</p><p id="f839" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Cognito会在注册时自动向用户发送一个验证码。</p><p id="3b15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您手动触发注册，那么您总是“重新发送”代码。</p><p id="b37d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还记得useRegister钩子中“confirm”方法吗？是充实它的时候了。</p><p id="4dd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在该方法中添加以下逻辑:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="dc54" class="mu lj in mq b gy mv mw l mx my">const confirm = (values, { setSubmitting }) =&gt; {<br/>        fetch('/api/confirm', {<br/>            method: 'POST',<br/>            headers: {<br/>                'Content-Type': 'application/json'<br/>            },<br/>            body: JSON.stringify(values)<br/>        }).then(res =&gt; {<br/>            if (!res.ok) throw res<br/>            router.push({<br/>                pathname: '/login',<br/>                query: { confirmed: true }<br/>            },<br/>                "/login")<br/>        }).catch(err =&gt; {<br/>            console.error(err)<br/>        }).finally(() =&gt; {<br/>            setSubmitting(false)<br/>        })<br/>    }</span></pre><p id="8956" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从此方法中，使用表单值调用“/api/confirm”端点。如果确认成功，将用户重定向到登录页面，以便他们可以登录。</p><p id="e71a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是“pages/confirm.js”文件中的确认页面:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4dd2" class="mu lj in mq b gy mv mw l mx my">import { Formik } from "formik";<br/>import InputLayout from "../components/layouts/InputLayout";<br/>import Label from "../components/Label";<br/>import InputField from "../components/InputField";<br/>import InputHelperText from "../components/InputHelperText";<br/>import SubmitButton from "../components/SubmitButton";<br/>import useValidationSchema from "../hooks/useValidationSchema";<br/>import useRegister from "../hooks/useRegister";<br/>import { useRouter } from "next/router";</span><span id="72d6" class="mu lj in mq b gy mz mw l mx my">export default function Confirm(){</span><span id="8cd1" class="mu lj in mq b gy mz mw l mx my">const router = useRouter();<br/>    const { username } = router.query;</span><span id="64c1" class="mu lj in mq b gy mz mw l mx my">const { confirm } = useRegister();<br/>    const { confirmSchema } = useValidationSchema();</span><span id="61b2" class="mu lj in mq b gy mz mw l mx my">return (<br/>        &lt;div style={{<br/>            padding: "10px"<br/>        }}&gt;<br/>            &lt;Formik<br/>                initialValues={{<br/>                    username: username,<br/>                    code: ""<br/>                }}<br/>                onSubmit={confirm}<br/>                validationSchema={confirmSchema}<br/>                validateOnMount={false}<br/>                validateOnChange={false}<br/>                validateOnBlur={false}&gt;<br/>                {<br/>                    ({<br/>                        isSubmitting,<br/>                        errors,<br/>                        values,<br/>                        handleSubmit,<br/>                        handleChange,<br/>                        handleBlur<br/>                     }) =&gt; (<br/>                        &lt;form onSubmit={handleSubmit}&gt;<br/>                            &lt;InputLayout&gt;<br/>                                &lt;Label&gt;Confirmation Code&lt;/Label&gt;<br/>                                &lt;InputField<br/>                                    type={"text"}<br/>                                    name={"code"}<br/>                                    placeholder={"Code"}<br/>                                    onChange={handleChange}<br/>                                    onBlur={handleBlur}<br/>                                    value={values?.code}<br/>                                /&gt;<br/>                                &lt;InputHelperText isError&gt;{errors?.code}&lt;/InputHelperText&gt;<br/>                            &lt;/InputLayout&gt;<br/>                            &lt;SubmitButton isSubmitting={isSubmitting} /&gt;<br/>                        &lt;/form&gt;<br/>                    )<br/>                }<br/>            &lt;/Formik&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><h1 id="1722" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">密码重置</h1><p id="46f4" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">任何授权系统中最重要的特性之一是重置密码的能力。</p><p id="b965" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">幸运的是，Cognito使密码重置变得非常简单。</p><p id="a176" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">密码重置流程类似于验证流程，但有一些额外的步骤:</p><ol class=""><li id="4c82" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">用户单击“忘记密码”链接，并被重定向到提示他们输入用户名的页面。</li><li id="cafe" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">向用户的电子邮件/号码发送确认码。</li><li id="36c7" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">如果代码发送成功，将用户重定向到一个重置页面，用户在该页面上输入代码和新密码。</li></ol><p id="c777" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，准备端点来触发包含代码的验证电子邮件。</p><p id="d5f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将以下代码添加到“pages/API/password/reset _ code . js”中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="022b" class="mu lj in mq b gy mv mw l mx my">import { CognitoIdentityProviderClient, ForgotPasswordCommand } from '<a class="ae lc" href="http://twitter.com/aws" rel="noopener ugc nofollow" target="_blank">@aws</a>-sdk/client-cognito-identity-provider'</span><span id="6367" class="mu lj in mq b gy mz mw l mx my">const { COGNITO_REGION, COGNITO_APP_CLIENT_ID } = process.env</span><span id="76a5" class="mu lj in mq b gy mz mw l mx my">export default async function handler (req, res) {<br/>    if (req.method !== 'POST') return res.status(405).send()</span><span id="f9b2" class="mu lj in mq b gy mz mw l mx my">const params = {<br/>        ClientId: COGNITO_APP_CLIENT_ID,<br/>        Username: req.body.username<br/>    }</span><span id="9f9d" class="mu lj in mq b gy mz mw l mx my">const cognitoClient = new CognitoIdentityProviderClient({<br/>        region: COGNITO_REGION<br/>    })<br/>    const forgotPasswordCommand = new ForgotPasswordCommand(params)</span><span id="cae0" class="mu lj in mq b gy mz mw l mx my">try {<br/>        const response = await cognitoClient.send(forgotPasswordCommand)<br/>        console.log(response)<br/>        return res.status(response['$metadata'].httpStatusCode).send()<br/>    } catch (err) {<br/>        console.log(err)<br/>        return res.status(err['$metadata'].httpStatusCode).json({ message: toString() })<br/>    }<br/>}</span></pre><p id="3ce0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们接受“ForgotPasswordCommand”命令的ClientId和username参数。Cognito将找到具有匹配用户名的用户，并使用配置的方法向他们发送验证码。</p><p id="3c89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“pages/api/password/reset.js”文件中，添加以下代码:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4870" class="mu lj in mq b gy mv mw l mx my">import {<br/>    CognitoIdentityProviderClient,<br/>    ConfirmForgotPasswordCommand<br/>} from "<a class="ae lc" href="http://twitter.com/aws" rel="noopener ugc nofollow" target="_blank">@aws</a>-sdk/client-cognito-identity-provider"</span><span id="39cb" class="mu lj in mq b gy mz mw l mx my">const { COGNITO_REGION, COGNITO_APP_CLIENT_ID } = process.env</span><span id="0b22" class="mu lj in mq b gy mz mw l mx my">export default async function handler(req, res) {<br/>    if (req.method !== 'POST') return res.status(405).send()</span><span id="a376" class="mu lj in mq b gy mz mw l mx my">const params = {<br/>        ClientId: COGNITO_APP_CLIENT_ID,<br/>        ConfirmationCode: req.body.code,<br/>        Password: req.body.password,<br/>        Username: req.body.username<br/>    }</span><span id="e87d" class="mu lj in mq b gy mz mw l mx my">const cognitoClient = new CognitoIdentityProviderClient({<br/>        region: COGNITO_REGION<br/>    })<br/>    const confirmForgotPasswordCommand = new ConfirmForgotPasswordCommand(params)</span><span id="8b30" class="mu lj in mq b gy mz mw l mx my">try {<br/>        const response = await cognitoClient.send(confirmForgotPasswordCommand)<br/>        console.log(response)<br/>        return res.status(response['$metadata'].httpStatusCode).send()<br/>    } catch (err) {<br/>        console.log(err)<br/>        return res.status(err['$metadata'].httpStatusCode).json({ message: err.toString() })<br/>    }<br/>}</span></pre><p id="9b1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们接受发送给用户的确认码、他们的新密码和用户名。</p><p id="50b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Cognito将负责所有的逻辑，确保所提供的代码是有效的，并且是发送给具有指定用户名的用户的代码。</p><p id="cf18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你会记得在useAuth钩子中，我们有两个空方法“resetPasswordRequest”和“resetPassword”。我们现在要把它们充实起来。</p><p id="b324" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将以下逻辑添加到这些方法中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8acb" class="mu lj in mq b gy mv mw l mx my">const resetPasswordRequest = (values, { setSubmitting }) =&gt; {<br/>    fetch('/api/password/reset\_code', {<br/>      method: 'POST',<br/>      headers: {<br/>        'Content-Type': 'application/json'<br/>      },<br/>      body: JSON.stringify(values)<br/>    }).then(res =&gt; {<br/>      if (!res.ok) throw res<br/>      router.push({<br/>        pathname: '/password/reset',<br/>        query: { username: values.username }<br/>      },<br/>        "/password/reset")<br/>    }).catch(err =&gt; {<br/>      console.error(err)<br/>    }).finally(() =&gt; {<br/>      setSubmitting(false)<br/>    })<br/>  }</span><span id="6335" class="mu lj in mq b gy mz mw l mx my">const resetPassword = (values, { setSubmitting }) =&gt; {<br/>    fetch('/api/password/reset', {<br/>      method: 'POST',<br/>      headers: {<br/>        'Content-Type': 'application/json'<br/>      },<br/>      body: JSON.stringify(values)<br/>    }).then(res =&gt; {<br/>      if (!res.ok) throw res<br/>      router.push({<br/>        pathname: '/login',<br/>        query: { reset: true }<br/>      },<br/>        "/login")<br/>    }).catch(err =&gt; {<br/>      console.error(err)<br/>    }).finally(() =&gt; {<br/>      setSubmitting(false)<br/>    })<br/>  }</span></pre><p id="7453" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe na nb nc mq b">resetPasswordRequest</code>方法触发“/api/password/reset_code”端点。</p><p id="82e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从用户的角度来看，他们被重定向到输入用户名的页面。提交表单后，他们会收到一封电子邮件，并被重定向到密码重置页面(如果电子邮件发送成功)。</p><p id="c0d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe na nb nc mq b">resetPassword</code>方法触发“/api/password/reset”端点来实际重置密码。</p><p id="8515" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是忘记密码表单的外观:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="92f5" class="mu lj in mq b gy mv mw l mx my">import { Formik } from "formik";<br/>import InputLayout from "../../components/layouts/InputLayout";<br/>import Label from "../../components/Label";<br/>import InputField from "../../components/InputField";<br/>import InputHelperText from "../../components/InputHelperText";<br/>import SubmitButton from "../../components/SubmitButton";<br/>import useValidationSchema from "../../hooks/useValidationSchema";<br/>import useAuth from '../../hooks/useAuth';</span><span id="7f59" class="mu lj in mq b gy mz mw l mx my">export default function ResetCode(){</span><span id="29a2" class="mu lj in mq b gy mz mw l mx my">const { resetPasswordRequestSchema } = useValidationSchema();<br/>    const { resetPasswordRequest } = useAuth();</span><span id="92cb" class="mu lj in mq b gy mz mw l mx my">return (<br/>        &lt;div style={{<br/>            padding: "10px"<br/>        }}&gt;<br/>            &lt;Formik<br/>                initialValues={{<br/>                    username: ""<br/>                }}<br/>                onSubmit={resetPasswordRequest}<br/>                validationSchema={resetPasswordRequestSchema}<br/>                validateOnMount={false}<br/>                validateOnChange={false}<br/>                validateOnBlur={false}<br/>                &gt;<br/>                {<br/>                    ({<br/>                        isSubmitting,<br/>                        errors,<br/>                        values,<br/>                        handleSubmit,<br/>                        handleChange,<br/>                        handleBlur<br/>                    }) =&gt; (<br/>                        &lt;form onSubmit={handleSubmit}&gt;<br/>                            &lt;InputLayout&gt;<br/>                                &lt;Label&gt;Username&lt;/Label&gt;<br/>                                &lt;InputField<br/>                                    type={"text"}<br/>                                    name={"username"}<br/>                                    placeholder={"Username"}<br/>                                    onChange={handleChange}<br/>                                    onBlur={handleBlur}<br/>                                    value={values?.username}<br/>                                /&gt;<br/>                                &lt;InputHelperText isError&gt;{errors?.username}&lt;/InputHelperText&gt;<br/>                            &lt;/InputLayout&gt;<br/>                            &lt;SubmitButton isSubmitting={isSubmitting} /&gt;<br/>                        &lt;/form&gt;<br/>                    )<br/>                }<br/>            &lt;/Formik&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="921b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是密码重置表单的外观:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="205a" class="mu lj in mq b gy mv mw l mx my">import { Formik } from "formik";<br/>import InputLayout from "../../components/layouts/InputLayout";<br/>import Label from "../../components/Label";<br/>import InputField from "../../components/InputField";<br/>import InputHelperText from "../../components/InputHelperText";<br/>import SubmitButton from "../../components/SubmitButton";<br/>import useValidationSchema from "../../hooks/useValidationSchema";<br/>import useAuth from '../../hooks/useAuth';<br/>import { useRouter } from "next/router";</span><span id="606e" class="mu lj in mq b gy mz mw l mx my">export default function Reset(){</span><span id="c715" class="mu lj in mq b gy mz mw l mx my">const router = useRouter()<br/>    const { username } = router.query</span><span id="7c26" class="mu lj in mq b gy mz mw l mx my">const { resetPasswordSchema } = useValidationSchema();<br/>    const { resetPassword } = useAuth()</span><span id="c41c" class="mu lj in mq b gy mz mw l mx my">return (<br/>        &lt;div style={{<br/>            padding: "10px"<br/>        }}&gt;<br/>            &lt;Formik<br/>                initialValues={{<br/>                    username: username,<br/>                    code: "",<br/>                    password: "",<br/>                    confirm\_password: ""<br/>                }}<br/>                validationSchema={resetPasswordSchema}<br/>                onSubmit={resetPassword}<br/>                validateOnMount={false}<br/>                validateOnChange={false}<br/>                validateOnBlur={false}<br/>            &gt;<br/>                {<br/>                    ({<br/>                        isSubmitting,<br/>                        errors,<br/>                        values,<br/>                        handleSubmit,<br/>                        handleBlur,<br/>                        handleChange<br/>                    }) =&gt; (<br/>                        &lt;form onSubmit={handleSubmit}&gt;<br/>                            &lt;InputLayout&gt;<br/>                                &lt;Label&gt;Reset code&lt;/Label&gt;<br/>                                &lt;InputField<br/>                                    type={"text"}<br/>                                    name={"code"}<br/>                                    placeholder={"Reset code"}<br/>                                    onChange={handleChange}<br/>                                    onBlur={handleBlur}<br/>                                    value={values?.code}<br/>                                /&gt;<br/>                                &lt;InputHelperText isError&gt;{errors?.code}&lt;/InputHelperText&gt;<br/>                            &lt;/InputLayout&gt;<br/>                            &lt;InputLayout&gt;<br/>                                &lt;Label&gt;New password&lt;/Label&gt;<br/>                                &lt;InputField<br/>                                    type={"password"}<br/>                                    name={"password"}<br/>                                    placeholder={"New password"}<br/>                                    onChange={handleChange}<br/>                                    onBlur={handleBlur}<br/>                                    value={values?.password}<br/>                                /&gt;<br/>                                &lt;InputHelperText isError&gt;{errors?.password}&lt;/InputHelperText&gt;<br/>                            &lt;/InputLayout&gt;<br/>                            &lt;InputLayout&gt;<br/>                                &lt;Label&gt;Confirm password&lt;/Label&gt;<br/>                                &lt;InputField<br/>                                    type={"password"}<br/>                                    name={"confirm_password"}<br/>                                    placeholder={"Confirm password"}<br/>                                    onChange={handleChange}<br/>                                    onBlur={handleBlur}<br/>                                    value={values?.confirm_password}<br/>                                /&gt;<br/>                                &lt;InputHelperText isError&gt;{errors?.confirm_password}&lt;/InputHelperText&gt;<br/>                            &lt;/InputLayout&gt;<br/>                            &lt;SubmitButton isSubmitting={isSubmitting} /&gt;<br/>                        &lt;/form&gt;<br/>                    )<br/>                }<br/>            &lt;/Formik&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><h1 id="8e3d" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">警告</h1><p id="d725" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们刚刚创建的实现的一个主要警告是，2个或更多的用户实际上可以用同一个电子邮件注册。</p><p id="2657" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不希望任何用户收到另一个用户的密码重置代码。</p><p id="667a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">出于这一原因以及许多其他原因，您可能希望为每个用户强制使用唯一的电子邮件。</p><p id="8e2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用Cognito触发器轻松实现这一点，cogn ITO触发器是运行定制lambda函数的事件触发器。这些允许我们定制我们的工作流程。</p><p id="d077" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在以下任何事件(以及更多事件)期间触发lambdas:</p><ol class=""><li id="e6b9" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">预注册—就在触发Cognito注册之前。</li><li id="4f35" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">预认证—就在用户被Cognito认证之前。</li><li id="efe5" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">自定义消息—就在发送验证/确认消息之前。我们可以在这里动态编辑消息。</li><li id="172f" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">身份验证后—用户成功通过身份验证后。如果身份验证失败，这将不会被触发。</li><li id="c8b3" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">确认后—用户通过验证/确认后。您可以使用它来发送欢迎电子邮件或启用某些只有已确认用户才能使用的权限。</li></ol><p id="1698" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些只是我们可用的触发器中的几个。你可以在这里找到关于这些触发器<a class="ae lc" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><p id="e8ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，我们最感兴趣的触发器是预注册触发器。我们可以检查是否有任何当前用户的电子邮件地址与我们刚刚收到的注册电子邮件地址相同。如果是这样，在Cognito注册之前抛出一个错误并失败。</p><p id="6caa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将发表一篇文章来演示如何实现这一点。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="62e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">【https://kelvinmwinuka.com】最初发表于<a class="ae lc" href="https://kelvinmwinuka.com/basic-authentication-with-aws-cognito-and-nextjs" rel="noopener ugc nofollow" target="_blank"><em class="nl"/></a><em class="nl">。</em></p><p id="36ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nl">更多内容请看</em><a class="ae lc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nl">plain English . io</em></strong></a><em class="nl">。报名参加我们的</em> <a class="ae lc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nl">免费周报</em> </strong> </a> <em class="nl">。关注我们关于</em><a class="ae lc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nl">Twitter</em></strong></a><em class="nl">和</em><a class="ae lc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nl">LinkedIn</em></strong></a><em class="nl">。加入我们的</em> <a class="ae lc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nl">社区不和谐</em> </strong> </a> <em class="nl">。</em></p></div></div>    
</body>
</html>