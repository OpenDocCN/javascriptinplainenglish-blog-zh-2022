<html>
<head>
<title>How Does Optional Chaining Work in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的可选链接是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-does-optional-chaining-work-in-javascript-7f57bb653191?source=collection_archive---------10-----------------------#2022-07-18">https://javascript.plainenglish.io/how-does-optional-chaining-work-in-javascript-7f57bb653191?source=collection_archive---------10-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e2dae6635086645689d90818e1d6ad7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLBdxRuTkSYkxOz-Og0uww.png"/></div></div></figure><p id="45e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可选链接是JavaScript中的一个特性，它允许我们访问对象的子属性，即使父对象不存在。当属性在一个对象上是可选的时候使用它，这样我们就不会返回一个错误，而是从Javascript得到一个结果。<strong class="ka ir">让我们看看它是如何工作的</strong>。</p><h1 id="a64d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">JavaScript可选性介绍</h1><p id="9809" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">任何使用过Javascript一段时间的人都可能会遇到一个非常常见的问题，即在我们做任何事情之前，访问可选的子属性需要很多额外的逻辑来测试它是否存在。</p><p id="1575" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个例子，想象一个构建文章的软件，其中对象<code class="fe lz ma mb mc b">article</code>可能有一个名为<code class="fe lz ma mb mc b">relatedArticle</code>的子属性，在这个子属性中，我们可能有一些相关文章的基本信息。让我们想象我们通过<code class="fe lz ma mb mc b">article.relatedArticle.url</code>访问一篇相关文章的URL然而，并不是每篇文章都有相关文章。传统上，在JavaScript中，假设定义了<code class="fe lz ma mb mc b">article</code>,我们可能会这样写:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="63e0" class="ml kx iq mc b gy mm mn l mo mp">let article = {};<br/>let url;<br/>if(article.relatedArticle !== undefined) {<br/>    url = article.relatedArticle.url;<br/>}</span></pre><p id="7296" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者我们可能会尝试这样的东西来代替:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="f772" class="ml kx iq mc b gy mm mn l mo mp">let article = {}<br/>let url = article.relatedArticle ? article.relatedArticle : undefined;</span></pre><p id="5191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<code class="fe lz ma mb mc b">relatedArticle</code>未定义，这最终会避免以下错误:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="a5fe" class="ml kx iq mc b gy mm mn l mo mp">Cannot read properties of undefined (reading 'url')</span></pre><p id="6ed6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果我们有多个子级别，我们可能会写一长串<code class="fe lz ma mb mc b">undefined</code>语句。对于非常大的对象来说，这可能会变得非常乏味并且失去控制。例如，下面当我们不确定这些对象是否会被定义时，我们尝试访问<code class="fe lz ma mb mc b">article.relatedArticle.url.rootDomain</code>:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="d0ea" class="ml kx iq mc b gy mm mn l mo mp">let article = {};<br/>let rootDomain;<br/>if(article.relatedArticle !== undefined &amp;&amp; article.relatedArticle.url !== undefined) {<br/>    rootDomain = article.relatedArticle.url.rootDomain;<br/>}</span></pre><p id="3180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可选性</strong>解决了过多<code class="fe lz ma mb mc b">undefined</code>检查的问题。如果某个东西被赋予了一个可选的<code class="fe lz ma mb mc b">?.</code>标签，那么如果它存在，这个值将被返回——否则它不会抛出一个错误。在上面的例子中，我们甚至不再需要一个<code class="fe lz ma mb mc b">if</code>语句:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1b1b" class="ml kx iq mc b gy mm mn l mo mp">let article = {};<br/>let rootDomain = article.relatedArticle?.url?.rootDomain;</span></pre><p id="92ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过添加<code class="fe lz ma mb mc b">?.</code>，如果<code class="fe lz ma mb mc b">relatedArticle</code>或<code class="fe lz ma mb mc b">url</code>未定义<strong class="ka ir">或<strong class="ka ir">为空</strong>，它将简单地传递到下一个属性，而不会抛出错误。我们甚至可以通过使用<a class="ae mq" href="https://fjolt.com/article/javascript-nullish-coalescing" rel="noopener ugc nofollow" target="_blank"> nullish合并</a>设置默认值来改进这一点。下面，如果发现<code class="fe lz ma mb mc b">rootDomain</code>属性未定义，它将返回<code class="fe lz ma mb mc b"><a class="ae mq" href="https://google.com/:" rel="noopener ugc nofollow" target="_blank">https://google.com/</a></code> <a class="ae mq" href="https://google.com/:" rel="noopener ugc nofollow" target="_blank"> : </a></strong></p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="343e" class="ml kx iq mc b gy mm mn l mo mp">let article = {};<br/>let rootDomain = article.relatedArticle?.url?.rootDomain ?? 'https://google.com/';</span></pre><h1 id="d2de" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何在JavaScript中使用可选链接</h1><p id="1562" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在大多数示例中，您可以使用如上所述的可选链接，以避免对象中真正可选的属性出错:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="4dfa" class="ml kx iq mc b gy mm mn l mo mp">let article = {};<br/>let rootDomain = article.relatedArticle?.url?.rootDomain;</span></pre><p id="fe1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对此需要注意的一点是，不能在对象的末尾添加问号。因此，下面的代码会抛出一个错误:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="09ad" class="ml kx iq mc b gy mm mn l mo mp">let article = {};<br/>let rootDomain = article.relatedArticle?.url?.rootDomain?;<br/>// Will throw an error like `Unexpected token ';'`</span></pre><p id="2fb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这是使用可选链接最常见的方式，但是在你的代码中还有其他方式实现它。让我们也来探究一下，看看如何在代码和项目中使用可选链接。</p><h1 id="6263" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">何时不使用可选链接</h1><p id="67bc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>你应该<strong class="ka ir">而不是</strong>使用可选链接来避免错误。如果您过度使用可选链接，您将隐藏错误，并使以后调试代码更加困难。相反，<strong class="ka ir">只对真正的可选属性使用可选链接</strong>！</p><h1 id="9884" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">可选的函数链接</h1><p id="8411" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您可以对预期可能返回对象的函数使用可选链接。它的工作原理与之前完全相同，只是我们在函数- <code class="fe lz ma mb mc b">myFunction(...arguments)?.x</code>后添加了<code class="fe lz ma mb mc b">?.</code>:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="f62b" class="ml kx iq mc b gy mm mn l mo mp">let myFunction = (x, y, z) =&gt; {<br/>    if(z !== undefined) {<br/>        return {<br/>            x: x,<br/>            y: y,<br/>            z: z<br/>        }<br/>    }<br/>}</span><span id="0ccc" class="ml kx iq mc b gy mr mn l mo mp">let arguments = [ 1, 2, 3 ];</span><span id="a1d9" class="ml kx iq mc b gy mr mn l mo mp">let getX = myFunction(...arguments)?.x;<br/>console.log(getX); // Returns 1;</span></pre><p id="4579" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个阶段，最好知道，默认情况下，如果一个函数没有<code class="fe lz ma mb mc b">return</code>，它将返回<code class="fe lz ma mb mc b">undefined</code>——所以这在您不确定函数是否会返回任何东西的情况下非常有用。</p><h1 id="4e1b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">可选的数组链接</h1><p id="d032" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">可选的链接也可以用于数组。例如，如果您不确定是否会定义一个属性，但它包含一个数组。下面，一个用户可以有一个有效地址的数组，我们想从他们的<strong class="ka ir">第一个</strong>地址得到他们地址的第一行。由于它可能不总是存在，我们可以在这里使用可选的链接来尝试和恢复它。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="0577" class="ml kx iq mc b gy mm mn l mo mp">let myUser = {<br/>    name: "John Doe",<br/>    age: 155<br/>}</span><span id="b6db" class="ml kx iq mc b gy mr mn l mo mp">let getAddress = myUser.addresses?.[0]?.first</span></pre><p id="389b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，<code class="fe lz ma mb mc b">addresses</code>没有在<code class="fe lz ma mb mc b">myUser</code>上定义，所以<code class="fe lz ma mb mc b">getAddress</code>将简单地返回<code class="fe lz ma mb mc b">undefined</code>。如果我们想检查一个应该是数组的属性，符号是<code class="fe lz ma mb mc b">obj.prop?.[index]</code>，而如果我们想检查一个可能不存在，但有子元素的数组索引，符号是<code class="fe lz ma mb mc b">obj[index]?.prop</code>。</p><h1 id="f16e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">具有可选功能的可选链接</h1><p id="40bc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有时，对象属性的返回可能是一个函数。在这些情况下，我们可能想要运行这个函数，但是因为它并不总是被定义，所以我们只希望它在那里的时候被触发。在这种情况下，我们可以使用符号<code class="fe lz ma mb mc b">?.()</code>来运行该函数，如果它存在的话。考虑下面的例子:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="330b" class="ml kx iq mc b gy mm mn l mo mp">let myObject = [<br/>    {<br/>        id: 15,<br/>        adder: (x) =&gt; {<br/>            return x + 10;<br/>        }<br/>    },<br/>    {<br/>        id: 145,<br/>    }<br/>]</span><span id="98d6" class="ml kx iq mc b gy mr mn l mo mp">myObject.forEach((item) =&gt; {<br/>    let runFunction = item.adder?.(10) || 10;<br/>    console.log(runFunction);<br/>});</span></pre><p id="d6a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在</strong>上面，我们有一个包含数组的对象，其中每个对象包含一个id — <code class="fe lz ma mb mc b">id</code>，也可能包含函数<code class="fe lz ma mb mc b">adder</code>。在这个例子中，我们想要运行这个<code class="fe lz ma mb mc b">adder</code>函数(如果它存在的话),或者如果这个函数没有定义的话，就把这个值默认为<code class="fe lz ma mb mc b">10</code>——所以我们运行这个函数:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1103" class="ml kx iq mc b gy mm mn l mo mp">let runFunction = item.adder?.(10) || 10;</span></pre><p id="46d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，如果定义了<code class="fe lz ma mb mc b">adder</code>，它就会运行，所以我们为数组的第一个元素获取<code class="fe lz ma mb mc b">x + 10</code>或<code class="fe lz ma mb mc b">20</code>，为第二个元素获取<code class="fe lz ma mb mc b">10</code>，因为<code class="fe lz ma mb mc b">adder</code>不存在。</p><h1 id="9645" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="59e6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">可选链接非常有用，并且得到了广泛的支持(不包括Internet Explorer)。根据返回类型，它可以与属性、数组或函数的任意组合一起使用。例如:</p><ul class=""><li id="203c" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><code class="fe lz ma mb mc b">obj?.property</code></li><li id="c3ee" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe lz ma mb mc b">obj?.[property]</code></li><li id="6925" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe lz ma mb mc b">obj[index]?.property</code></li><li id="c085" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe lz ma mb mc b">obj?.(args)</code></li><li id="6ca2" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe lz ma mb mc b">func(args)?.property</code></li></ul><p id="a34f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，可选链接是简化代码的一个很好的方法，它为对象中真正的可选属性提供了语法和意义。</p><p id="0d01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ng">更多内容请看</em><a class="ae mq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">plain English . io</em></strong></a><em class="ng">。报名参加我们的</em> <a class="ae mq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们关于</em><a class="ae mq" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">Twitter</em></strong></a><em class="ng">和</em><a class="ae mq" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">LinkedIn</em></strong></a><em class="ng">。查看我们的</em> <a class="ae mq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ng">社区不和谐</em> </strong> </a> <em class="ng">加入我们的</em> <a class="ae mq" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ng">人才集体</em> </strong> </a> <em class="ng">。</em></p></div></div>    
</body>
</html>