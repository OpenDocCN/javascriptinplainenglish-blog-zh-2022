<html>
<head>
<title>Demystifying ‘this’ in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开JavaScript中“this”的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-this-in-javascript-369a1dcb881?source=collection_archive---------17-----------------------#2022-03-15">https://javascript.plainenglish.io/demystifying-this-in-javascript-369a1dcb881?source=collection_archive---------17-----------------------#2022-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e593" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解“this”关键字在JavaScript中的实际工作方式。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/14f55cd64c0ca525d621b133c3ac7a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wji643Sk-3DdIcEqGVwd5Q.png"/></div></div></figure><p id="3e23" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它是JavaScript中经常使用的东西，但它所指的通常是一个谜。在JavaScript中，<code class="fe lk ll lm ln b">this</code>的工作方式与其他编程语言非常不同——它的工作方式取决于您是否使用了严格模式。</p><p id="a39c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你发现这很难，你并不孤单。让我们看看<code class="fe lk ll lm ln b">this</code>到底是如何工作的，并消除它在各种上下文中的含义。</p><h1 id="ddcb" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">JavaScript中的“this”是什么</h1><p id="1af9" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated"><code class="fe lk ll lm ln b">this</code>是JavaScript中的一个关键字，指的是某个上下文中的一个属性或一组属性。我们使用它的上下文改变了它的属性。在全局上下文中，这指的是全局对象——在浏览器中是一个窗口，但在Node.js和其他JavaScript实现中是<code class="fe lk ll lm ln b">globalThis</code>。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="a565" class="mp lp in ln b gy mq mr l ms mt">console.log(this); // The same as console.log(window);</span></pre><p id="a12d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在任何函数或代码之外，情况总是如此。然而，在不同的地方，这意味着不同的事情。</p><h1 id="1955" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">这是JavaScript中的函数</h1><p id="69fd" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">在函数中，这仍然是指全局对象。如果我们在函数中引用它，默认情况下，它会引用窗口或<code class="fe lk ll lm ln b">globalThis</code>对象:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="cffd" class="mp lp in ln b gy mq mr l ms mt">console.log(this); // The same as console.log(window);</span><span id="d20f" class="mp lp in ln b gy mu mr l ms mt">function myFunction() {<br/>    console.log(this); // The same as console.log(window);<br/>}</span><span id="2bbd" class="mp lp in ln b gy mu mr l ms mt">myFunction();</span></pre><p id="8557" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，在严格模式下，函数内部的<code class="fe lk ll lm ln b">this</code>是未定义的。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="e47f" class="mp lp in ln b gy mq mr l ms mt">"use strict"<br/>console.log(this); // The same as console.log(window);</span><span id="7b5e" class="mp lp in ln b gy mu mr l ms mt">function myFunction() {<br/>    console.log(this); // This is undefined!<br/>}</span><span id="a7c0" class="mp lp in ln b gy mu mr l ms mt">myFunction();</span></pre><h1 id="33f6" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">使用call()求解</h1><p id="f8fc" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">起初这有点令人困惑，但这样做的原因是因为我们需要在myFunction上添加一个<code class="fe lk ll lm ln b">this</code>对象——严格模式下的JavaScript不会将其默认为全局对象。为此，我们必须使用call()。在下面的例子中，我将myObject转换成了我们的<code class="fe lk ll lm ln b">this</code>变量:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="204a" class="mp lp in ln b gy mq mr l ms mt">"use strict"<br/>console.log(this); // The same as console.log(window);</span><span id="dd24" class="mp lp in ln b gy mu mr l ms mt">let myObject = {<br/>    firstName: "John",<br/>    lastName: "Doe",<br/>    age: 76<br/>}<br/>function myFunction() {<br/>    console.log(this.firstName);<br/>}</span><span id="16ad" class="mp lp in ln b gy mu mr l ms mt">myFunction.call(myObject); // this.firstName is defined as "John", so it will console log John<br/>myFunction(); // this.firstName will be undefined, and this will throw an error.</span></pre><p id="2d9c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">call()</code>运行<code class="fe lk ll lm ln b">myFunction</code>并将<code class="fe lk ll lm ln b">myObject</code>附加到<code class="fe lk ll lm ln b">this</code>关键字。如果我们不使用call，只是简单地运行<code class="fe lk ll lm ln b">myFunction()</code>，那么函数将返回一个错误，因为<code class="fe lk ll lm ln b">this.firstName</code>将是未定义的。您还可以使用空this调用函数，然后可以将数据追加到函数内部。</p><p id="0664" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这给了我们一个新的空间来定义我们的<code class="fe lk ll lm ln b">this</code>对象上的变量，而不是被来自全局This对象的数据所污染:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="d949" class="mp lp in ln b gy mq mr l ms mt">"use strict"<br/>console.log(this); // The same as console.log(window);</span><span id="a92e" class="mp lp in ln b gy mu mr l ms mt">function myFunction() {<br/>    this.firstName = 'John';<br/>    console.log(this.firstName); // This will be "John"<br/>}</span><span id="4846" class="mp lp in ln b gy mu mr l ms mt">myFunction.call({});</span></pre><h1 id="348b" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">严格模式下的不同行为</h1><p id="a778" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">正如您所看到的，根据我们是否使用严格模式，行为是非常不同的——所以在两种模式之间更改代码之前做一些测试是很重要的。</p><h1 id="1ffe" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">打电话申请</h1><p id="d9b9" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">你有时会看到<code class="fe lk ll lm ln b">call()</code>和一个叫做<code class="fe lk ll lm ln b">apply()</code>的函数互换使用。这两个函数非常相似，因为它们都使用指定的上下文来调用函数。唯一的区别是，<code class="fe lk ll lm ln b">apply()</code>在函数有参数时接受一个数组，而<code class="fe lk ll lm ln b">call()</code>逐个接受每个参数。</p><p id="1253" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="fbb7" class="mp lp in ln b gy mq mr l ms mt">"use strict"<br/>let otherNumbers = {<br/>    a: 10,<br/>    b: 4<br/>}<br/>function multiplyNumbers(x, y, z) {<br/>    return this.a * this.b * x * y * z<br/>}</span><span id="86e2" class="mp lp in ln b gy mu mr l ms mt">// Both will return the same result, the only difference<br/>// being that apply() uses an array for arguments.<br/>multiplyNumbers.call(otherNumbers, 1, 2, 3);<br/>multiplyNumbers.apply(otherNumbers, [ 1, 2, 3 ]);</span></pre><h1 id="1b11" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">使用bind()简化这个过程</h1><p id="db37" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">实现与<code class="fe lk ll lm ln b">call()</code>相似行为的另一种方法是使用<code class="fe lk ll lm ln b">bind()</code>。类似于<code class="fe lk ll lm ln b">call()</code>，<code class="fe lk ll lm ln b">bind()</code>，改变一个函数的this值，只是它是永久性的。这意味着你不必经常使用<code class="fe lk ll lm ln b">bind()</code>——你只需使用一次。</p><p id="ad84" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有一个例子，我们将对象永久地绑定到函数上，从而永久地更新它——我们只需要将它定义为一个新函数。在下面的例子中，我们定义了一个名为<code class="fe lk ll lm ln b">boundFunction</code>的新函数，它是我们的<code class="fe lk ll lm ln b">myFunction</code>和与之永久绑定的<code class="fe lk ll lm ln b">myObject</code>。</p><p id="a5ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，当我们调用控制台日志时，它将显示“John”。这与call不同，call需要在我们每次使用函数时使用。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="c85c" class="mp lp in ln b gy mq mr l ms mt">"use strict"<br/>console.log(this); // The same as console.log(window);</span><span id="48ea" class="mp lp in ln b gy mu mr l ms mt">let myObject = {<br/>    firstName: "John",<br/>    lastName: "Doe",<br/>    age: 76<br/>}<br/>function myFunction() {<br/>    console.log(this.firstName);<br/>}</span><span id="5ed4" class="mp lp in ln b gy mu mr l ms mt">let boundFunction = myFunction.bind(myObject); // this will bind this to myObject permanently.<br/>boundFunction(); // since we used bind, this will now be set to myObject, every time we call boundFunction() - so it will return John.</span></pre><h1 id="d986" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">箭头符号函数和这个</h1><p id="9fcf" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">JavaScript中箭头符号函数的一个关键特性是它们不包含<code class="fe lk ll lm ln b">this</code>上下文。这意味着他们从父母那里继承了<code class="fe lk ll lm ln b">this</code>。例如，假设我们处于严格模式，并且定义了一个箭头函数和一个“普通”样式的函数。对于箭头功能，<code class="fe lk ll lm ln b">this</code>将被继承，但对于其他功能，<code class="fe lk ll lm ln b">this</code>将保持未定义！</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="1fe1" class="mp lp in ln b gy mq mr l ms mt">"use strict"<br/>console.log(this); // The same as console.log(window);</span><span id="7226" class="mp lp in ln b gy mu mr l ms mt">function myFunction() {<br/>    console.log(this.name); // This will be "John"<br/>    let myArrowFunction = () =&gt; {<br/>        console.log(this.name); // This will be "John"<br/>    }</span><span id="ea88" class="mp lp in ln b gy mu mr l ms mt">    let myNormalFunction = function() {<br/>        console.log(this.name); // This will throw an error, since this is undefined!<br/>    }</span><span id="a729" class="mp lp in ln b gy mu mr l ms mt">    myArrowFunction();<br/>    myNormalFunction();<br/>}</span><span id="e447" class="mp lp in ln b gy mu mr l ms mt">myFunction.call({<br/>    name: "John"<br/>});</span></pre><h1 id="7417" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">构造函数和这个</h1><p id="8020" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">关于<code class="fe lk ll lm ln b">this</code>的另一个有趣的事情是，当在构造函数中使用时(这是一个使用new关键字的函数)，构造函数的返回基本上覆盖了它。例如，如果我们运行下面的代码，尽管我们将<code class="fe lk ll lm ln b">this.name</code>设置为John，但name的返回值是Jack:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="26dd" class="mp lp in ln b gy mq mr l ms mt">let functionA = function() {<br/>    this.name = "John";<br/>}</span><span id="abcf" class="mp lp in ln b gy mu mr l ms mt">let functionB = function() {<br/>    this.name = "John";<br/>    return {<br/>        name: "Jack"<br/>    }<br/>}</span><span id="dc41" class="mp lp in ln b gy mu mr l ms mt">let runFunctionA = new functionA();<br/>console.log(runFunctionA.name); // Returns "John";<br/>let runFunctionB = new functionB();<br/>console.log(runFunctionB.name); // Returns "Jack";</span></pre><h1 id="9e98" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">这在对象上下文中</h1><p id="1973" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">在对象上下文中，使用this是指对象。例如，假设我们在一个名为<code class="fe lk ll lm ln b">obj</code>的对象中运行一个函数，它引用了<code class="fe lk ll lm ln b">this.aProperty</code>——在本例中，它引用了<code class="fe lk ll lm ln b">obj</code>:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="0a86" class="mp lp in ln b gy mq mr l ms mt">let obj = {<br/>    aProperty: 15,<br/>    runFunction: function() {<br/>        console.log(this.aProperty); // Refers to 15<br/>    }<br/>}</span><span id="2beb" class="mp lp in ln b gy mu mr l ms mt">obj.runFunction(); // Will console log 15, since this refers to obj</span></pre><p id="a00a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果使用get()/set()符号，也是如此:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="8ac9" class="mp lp in ln b gy mq mr l ms mt">"use strict"<br/>let obj = {<br/>    aProperty: 15,<br/>    runFunction: function() {<br/>        console.log(this.aProperty); // Refers to 15<br/>    },<br/>    set updateProp(division) {<br/>        this.aProperty = this.aProperty / division; // this.aProperty refers to 15<br/>        console.log(this.aProperty); <br/>    }<br/>}</span><span id="a34b" class="mp lp in ln b gy mu mr l ms mt">obj.updateProp = 15; // Will divide aProperty by 15, and console log the result, i.e. 1</span></pre><h1 id="1060" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">将它与事件侦听器一起使用</h1><p id="cade" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">JavaScript的<code class="fe lk ll lm ln b">this</code>的另一个怪癖是，当使用事件监听器时，它指的是事件被添加到的HTML元素。在下面的例子中，我们向ID为“hello-world”的HTML标签添加了一个点击事件:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="4af8" class="mp lp in ln b gy mq mr l ms mt">document.getElementById('hello-world').addEventListener('click', function(e) {<br/>    console.log(this);<br/>});</span></pre><p id="a613" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们点击我们的<code class="fe lk ll lm ln b">#hello-world</code> HTML元素，我们将在控制台日志中看到:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="e25f" class="mp lp in ln b gy mq mr l ms mt">&lt;div id="hello-world"&gt;&lt;/div&gt;</span></pre><h1 id="4f24" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">将此用于类</h1><p id="65b2" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">在本节中值得注意的是，JavaScript中的类只是幕后的函数。这意味着我们在函数中看到的许多功能对类来说都是真实的。</p><p id="8982" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">默认情况下，类会将此设置为类实例本身。在下面的例子中，我们可以看到这一点——T2和T3都返回了约翰。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="d158" class="mp lp in ln b gy mq mr l ms mt">class myClass { <br/>    whatsMyName() {<br/>        return this.name;<br/>    }<br/>    get name() {<br/>        return "John";<br/>    }<br/>}</span><span id="278d" class="mp lp in ln b gy mu mr l ms mt">const runClass = new myClass();<br/>console.log(runClass.name);        // Returns "John"<br/>console.log(runClass.whatsMyName); // Returns "John"</span></pre><p id="a1a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">唯一的例外是静态项不会添加到此。所以如果我们定义一个函数，在它前面有关键字static，它就不会在<code class="fe lk ll lm ln b">this</code>上:</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="44f9" class="mp lp in ln b gy mq mr l ms mt">class myClass { <br/>    getMyAge() {<br/>        return this.whatsMyAge();<br/>    }<br/>    static whatsMyAge() {<br/>        return this.age; <br/>    }<br/>    get name() {<br/>        return "John";<br/>    }<br/>    get age() {<br/>        return 143<br/>    }<br/>}</span><span id="362e" class="mp lp in ln b gy mu mr l ms mt">const runClass = new myClass();<br/>console.log(runClass.whatsMyAge()); // Throws an error, since runClass.whatsMyAge() is undefined<br/>console.log(runClass.getMyAge()); // Throws an error, since this.whatsMyAge() is undefined</span></pre><p id="3c31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">值得注意的是，默认情况下，类总是处于严格模式——因此这将与类中默认的严格函数的行为方式相同。</p><h1 id="4e81" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">结论</h1><p id="da01" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">在JavaScript中，这可能意味着各种事情。在本文中，我们讨论了它在不同上下文中的含义——函数、类和对象。我们已经介绍了如何使用<code class="fe lk ll lm ln b">bind()</code>、<code class="fe lk ll lm ln b">call()</code>和<code class="fe lk ll lm ln b">apply()</code>向您的函数添加不同的<code class="fe lk ll lm ln b">this</code>上下文。</p><p id="c8b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还介绍了如何在严格模式和非严格模式下使用<code class="fe lk ll lm ln b">this</code>。在此之后，希望<code class="fe lk ll lm ln b">this</code>稍微去神秘化。</p><p id="72d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mv">更多内容看</em> <a class="ae mw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mv">说白了。报名参加我们的</em> <a class="ae mw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mv">免费周报</em> </strong> </a> <em class="mv">。关注我们关于</em><a class="ae mw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mv">Twitter</em></strong></a><em class="mv">和</em><a class="ae mw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mv">LinkedIn</em></strong></a><em class="mv">。加入我们的</em> <a class="ae mw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mv">社区</em> </strong> </a> <em class="mv">。</em></strong></a></p></div></div>    
</body>
</html>