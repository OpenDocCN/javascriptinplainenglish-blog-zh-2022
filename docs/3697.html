<html>
<head>
<title>Design Patterns: Adapter Pattern in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:TypeScript中的适配器模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/design-patterns-adapter-pattern-in-typescript-4b7ad3c1c234?source=collection_archive---------0-----------------------#2022-09-19">https://javascript.plainenglish.io/design-patterns-adapter-pattern-in-typescript-4b7ad3c1c234?source=collection_archive---------0-----------------------#2022-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="874c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用适配器模式轻松解决接口不兼容问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d553d4038c3d1930ae71637bda0e5d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YVKiEqxN2wcohBEz"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@callmefred?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Call Me Fred</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8903" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎来到TypeScript 系列的<strong class="ky ir">设计模式，这里介绍了一些使用TypeScript进行web开发时有用的设计模式。</strong></p><p id="be89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以前的文章如下:</p><ul class=""><li id="dccc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-strategy-pattern-in-typescript-54eda9b40f09">打字稿中的策略模式</a></li><li id="e4a5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-chain-of-responsibility-pattern-in-typescript-dba6bdffe456">打字稿中的责任链模式</a></li><li id="2644" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-observer-pattern-in-typescript-f6589f1ce4fc">打字稿中的观察者模式</a></li><li id="a1b2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-template-method-pattern-in-typescript-ce0c8b158985">TypeScript中的模板方法模式</a></li><li id="654d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-adapter-pattern-in-typescript-4b7ad3c1c234">类型脚本中的适配器模式</a></li><li id="cde0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-factory-method-pattern-in-typescript-c4c3047a6289">TypeScript中的工厂方法模式</a></li><li id="6456" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-abstract-factory-pattern-in-typescript-84cd7b002964">在TypeScript中抽象工厂模式</a></li></ul><p id="2041" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计模式对于web开发人员来说非常重要，通过掌握它们我们可以写出更好的代码。在本文中，我将使用<strong class="ky ir">类型脚本</strong>来介绍<strong class="ky ir">适配器模式。</strong></p><p id="3434" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在web系统中，邮件服务是一种非常常用的服务。在Node.js平台上，我们可以使用一个<a class="ae kv" href="https://github.com/nodemailer/nodemailer" rel="noopener ugc nofollow" target="_blank"> nodemailer </a>模块轻松实现发送邮件的功能。成功安装<a class="ae kv" href="https://github.com/nodemailer/nodemailer" rel="noopener ugc nofollow" target="_blank">节点邮件</a>模块后，您可以按照以下步骤发送邮件:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="c444" class="ml mm iq mh b gy mn mo l mp mq">let transporter = nodemailer.createTransport(transport[, defaults]);<br/>transporter.sendMail(data[, callback])</span></pre><p id="ea60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免将邮件服务绑定到特定的服务提供者，在开发邮件服务之前，我们首先定义与邮件提供者相关的接口:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="c92b" class="ml mm iq mh b gy mn mo l mp mq">interface EmailProvider {<br/>  sendMail(options: EmailOptions): Promise&lt;EmailResponse&gt;;<br/>}</span><span id="d546" class="ml mm iq mh b gy mr mo l mp mq">interface EmailOptions {<br/>  to: string | string[];<br/>  subject: string;<br/>  html: string;<br/>  from?: string;<br/>  text?: string;<br/>}</span><span id="a51e" class="ml mm iq mh b gy mr mo l mp mq">interface EmailResponse {}</span></pre><p id="1262" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些接口，我们可以轻松地创建邮件服务:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="478c" class="ml mm iq mh b gy mn mo l mp mq">class EmailService {<br/>  constructor(public emailProvider: EmailProvider) {}</span><span id="2a82" class="ml mm iq mh b gy mr mo l mp mq">  async sendMail(options: EmailOptions): Promise&lt;EmailResponse&gt; {<br/>    const result = await this.emailProvider.sendMail(options);<br/>    return result;<br/>  }<br/>}</span></pre><p id="5220" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前这个方案问题不大，但是如果有一天我们需要使用第三方邮箱云服务提供商。如<strong class="ky ir">发送栅格</strong>或<strong class="ky ir">发送器</strong>等。你会发现SDK用来发送邮件的方法的名字是<code class="fe ms mt mu mh b">send</code>。所以我们继续定义一个<code class="fe ms mt mu mh b">CloudEmailProvider</code>接口:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="f555" class="ml mm iq mh b gy mn mo l mp mq">interface CloudEmailProvider {<br/>  send(options: EmailOptions): Promise&lt;EmailResponse&gt;;<br/>}</span></pre><p id="9c07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对比之前定义的<code class="fe ms mt mu mh b">EmailProvider</code>界面，你会发现以下问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/ed4f14af2827b1be82c8dad6772ace4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xkO-DmEneSV1piNDcNwNkw.png"/></div></div></figure><p id="a109" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以不能直接使用<code class="fe ms mt mu mh b">EmailService</code>访问第三方邮箱云服务。要解决这个问题，有很多方法。让我们来介绍一下如何使用适配器模式来解决上述问题。</p><p id="bcdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">适配器模式的目的是允许两个由于接口不匹配而无法一起工作的对象一起工作。它就像胶水一样，将不同的东西转化，使它们能够一起工作。</p><p id="9dc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">适配器模式包含以下角色:</p><ul class=""><li id="9715" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">客户端(EmailService) </strong>:需要使用目标接口的对象；</li><li id="0c96" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">目标(EmailProvider) </strong>:定义客户端期望的接口；</li><li id="0a3f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">Adapter(CloudEmailAdapter)</strong>:将Adaptee接口适配到目标接口；</li><li id="d079" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">Adaptee(CloudEmailProvider)</strong>:定义需要适配的接口。</li></ul><p id="6883" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在了解了适配器模式之后，让我们创建<code class="fe ms mt mu mh b">CloudEmailAdapter</code>类:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="d1ce" class="ml mm iq mh b gy mn mo l mp mq">class CloudEmailAdapter implements EmailProvider {<br/>  constructor(public emailProvider: CloudEmailProvider) {}</span><span id="e37e" class="ml mm iq mh b gy mr mo l mp mq">  async sendMail(options: EmailOptions): Promise&lt;EmailResponse&gt; {<br/>    const result = this.emailProvider.send(options);<br/>    return result;<br/>  }<br/>}</span></pre><p id="81be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，因为<code class="fe ms mt mu mh b">EmailProvider</code>和<code class="fe ms mt mu mh b">CloudEmailProvider</code>两个接口不匹配，所以我们引入了<code class="fe ms mt mu mh b">CloudEmailAdapter</code>类来解决兼容性问题。</p><p id="b3ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们以sendgrid为例实现一个<code class="fe ms mt mu mh b">SendgridEmailProvider</code>:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="bce4" class="ml mm iq mh b gy mn mo l mp mq">import { MailService } from "<a class="ae kv" href="http://twitter.com/sendgrid/mail" rel="noopener ugc nofollow" target="_blank">@sendgrid/mail</a>";</span><span id="3edf" class="ml mm iq mh b gy mr mo l mp mq">class SendgridEmailProvider implements CloudEmailProvider {<br/>  private sendgridMail: MailService;</span><span id="20b6" class="ml mm iq mh b gy mr mo l mp mq">  constructor(<br/>    private config: {<br/>      apiKey: string;<br/>      from: string;<br/>    }<br/>  ) {<br/>    this.sendgridMail = new MailService();<br/>    this.sendgridMail.setApiKey(this.config.apiKey);<br/>  }</span><span id="ef4c" class="ml mm iq mh b gy mr mo l mp mq">  async send(options: EmailOptions): Promise&lt;EmailResponse&gt; {<br/>    const result = await this.sendgridMail.send(options);<br/>    return result;<br/>  }<br/>}</span></pre><p id="3966" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">提示:以上代码仅供演示，在实际项目中使用时需要做相应调整。</em></p><p id="67f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然已经定义了<code class="fe ms mt mu mh b">SendgridEmailProvider</code>和<code class="fe ms mt mu mh b">CloudEmailAdapter</code>类，让我们看看如何使用它们:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="45ab" class="ml mm iq mh b gy mn mo l mp mq">const sendgridMail = new SendgridEmailProvider({<br/>  apiKey: "******",<br/>  from: "<a class="ae kv" href="mailto:bytefer@gmail.com" rel="noopener ugc nofollow" target="_blank">bytefer@gmail.com</a>",<br/>});</span><span id="c403" class="ml mm iq mh b gy mr mo l mp mq">const cloudEmailAdapter = new CloudEmailAdapter(sendgridMail);<br/>const emailService = new EmailService(cloudEmailAdapter);</span><span id="935d" class="ml mm iq mh b gy mr mo l mp mq">emailService.sendMail({<br/>  to: "******",<br/>  subject: "Adapter Design Pattern",<br/>  html: "&lt;h3&gt;Adapter Design Pattern&lt;/h3&gt;",<br/>  from: "<a class="ae kv" href="mailto:bytefer@gmail.com" rel="noopener ugc nofollow" target="_blank">bytefer@gmail.com</a>",<br/>});</span></pre><p id="a6a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们总结一下适配器模式的使用场景:</p><ul class=""><li id="29e2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">系统需要使用一个已有的类，而这个类的接口不符合系统的需要，即接口不兼容；</li><li id="2032" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用第三方提供的服务，但是服务接口定义和自己需要的接口定义不一样。</li></ul><p id="c601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有任何问题，请随时给我留言。稍后我会继续介绍其他模式，如果你有兴趣，可以在<a class="ae kv" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或<a class="ae kv" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="bbec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想学习打字稿，那么就不要错过<strong class="ky ir">掌握打字稿</strong>系列。</p><ul class=""><li id="1df0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener"><strong class="ky ir">TypeScript泛型中的K、T、V是什么？</strong> </a></li><li id="257c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-mapped-types-like-a-pro-be10aef5511a"> <strong class="ky ir">使用TypeScript像临一样映射类型</strong> </a></li><li id="3b5a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-conditional-types-like-a-pro-7baea0ad05c5"> <strong class="ky ir">使用TypeScript条件类型像亲</strong> </a></li><li id="5fd2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7"> <strong class="ky ir">使用TypeScript交集类型像亲</strong> </a></li><li id="5d29" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://levelup.gitconnected.com/using-typescript-infer-like-a-pro-f30ab8ab41c7" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">使用打字稿像专家一样推断</strong> </a></li><li id="d056" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac" rel="noopener"> <strong class="ky ir">使用TypeScript模板字面类型像亲</strong> </a></li><li id="f23a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/15-utility-types-that-every-typescript-developer-should-know-6cf121d4047c"> <strong class="ky ir">打字稿可视化:15种最常用的实用类型</strong> </a></li><li id="847f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://levelup.gitconnected.com/10-things-you-need-to-know-about-typescript-classes-f58c57869266" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">关于打字稿类你需要知道的10件事</strong> </a></li><li id="54ed" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/purpose-of-declare-keyword-in-typescript-8431d9db2b10"><strong class="ky ir">TypeScript中‘declare’关键字的用途</strong> </a></li><li id="d2cc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/no-more-confusion-about-typescripts-any-and-unknown-98c4b53f8924"> <strong class="ky ir">不再混淆打字稿的“任何”和“未知”</strong> </a></li></ul><div class="ne nf gp gr ng"><div role="button" tabindex="0" class="ab bv gv cb fp nh ni bn nj kp ex"><div class="nk l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw nl nm fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l nl nm fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----4b7ad3c1c234--------------------------------" rel="noopener follow" target="_top"> Bytefer </a></p></div></div><div class="np nq gw l"><h2 class="bd ir td ls fp te fr fs tf fu fw ip bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tg au th ti tj pj tk an eh ei tl tm tn el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----4b7ad3c1c234--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="to l fo"><span class="bd b dl z dk">47 stories</span></div></div></div><div class="oc dh od fp ab oe fo di"><div class="di nu bv nv nw"><div class="dh l"><img alt="" class="dh" src="../Images/8fba4cad7ae795f6abed5234e33e0356.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*l87u8lL_MzD5n4z_"/></div></div><div class="di nu bv nx ny nz"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di bv oa ob nz"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div></div></div></div></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="aeb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">plain English . io</em></strong></a><em class="mw">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">LinkedIn</em></strong></a><em class="mw"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">YouTube</em></strong></a><em class="mw"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">不和</em> </strong> </a> <em class="mw">。对增长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mw">电路</em> </strong> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>