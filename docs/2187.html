<html>
<head>
<title>How To Filter Nullable Values From An Array Using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TypeScript从数组中筛选可为空的值</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-filter-nullable-values-from-an-array-using-typescript-30575cb25e3f?source=collection_archive---------21-----------------------#2022-05-19">https://javascript.plainenglish.io/how-to-filter-nullable-values-from-an-array-using-typescript-30575cb25e3f?source=collection_archive---------21-----------------------#2022-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8d58cbf1f3bebdb5311639ed70c06102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kC3hg0Rzv8DHLQSzIkHpZg.png"/></div></div></figure><p id="c5ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您在JavaScript开发中处理过任何类型的复杂数据，几乎可以保证您使用过函数数组方法。这些方法比传统实现更短，功能更强，通常使用for循环和有条件地填充数组来解决问题。</p><p id="676c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在正确的环境中使用这些方法可以显著提高代码的质量和可读性。当它们与TypeScript结合使用时尤其如此。但是尽管TypeScript出色地支持了Array <code class="fe kw kx ky kz b">map</code>函数，但对于Array <code class="fe kw kx ky kz b">filter</code>函数却不能这么说。</p><p id="ab45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">特别是，我们将从这样的数组中过滤出可空值。从开发人员的角度来看，当使用<code class="fe kw kx ky kz b">filter</code>函数过滤掉可空值时，TypeScript并不总是正确地选择类型。即使使用像<code class="fe kw kx ky kz b">!!</code>或<code class="fe kw kx ky kz b">Boolean</code>构造函数这样的操作符保证我们不再有可为空的值，TypeScript仍然假设不是这样。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4282" class="li lj iq kz b gy lk ll l lm ln">interface Array&lt;T&gt; {<br/>  // ...<br/>  filter&lt;S extends T&gt;(predicate: (value: T, index: number, array: T[]) =&gt; value is S, thisArg?: any): S[];<br/>}</span></pre><p id="a78f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解为什么会发生这种情况，我们必须看一下<code class="fe kw kx ky kz b">filter</code>函数的TypeScript类型定义。要注意的主要事情是谓词函数，它是您定义为第一个函数参数的回调函数，负责确定结果数组中值的类型。这意味着，如果谓词中的操作没有具体产生新的类型，那么<code class="fe kw kx ky kz b">filter</code>函数将假设函数调用前后的对象数组保持不变。</p><p id="b5f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是大多数问题出现的地方。开发人员通常内联定义谓词函数，这意味着他们将这一切都交给TypeScript来派生适当的类型。除此之外，JavaScript还有一些非常规的方法来检查可空值。想想我们之前提到的<code class="fe kw kx ky kz b">!!</code>操作符或<code class="fe kw kx ky kz b">Boolean</code>构造函数方法。虽然我们作为开发人员知道这些方法是可行的，但是它们对于TypeScript来说并不明确。这导致打字不匹配。</p><p id="17ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文将介绍在使用TypeScript从数组中过滤可空值时整理类型的不同方法。这些功能包括内联类型保护、类型转换和一个通用的实用函数。使用这些知识，您将能够使您的<code class="fe kw kx ky kz b">filter</code>函数调用正确地与TypeScript同步，并享受您应得的类型派生。</p><h1 id="bad1" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">直列式防护</h1><p id="aeb3" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在TypeScript中，存在类型保护的概念。基本上，在函数定义级别，您将函数的返回值作为类型谓词而不是具体类型键入。这向TypeScript表明，每当函数计算为true值时，对象的类型与类型谓词的结果相同。</p><p id="8dcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，除了在函数定义级别上这样做，您还可以在回调中内联这样做。通过利用这种机制，您可以使用所需类型的类型谓词来键入<code class="fe kw kx ky kz b">filter</code>函数回调的返回值。然后，您可以使用您喜欢的方式检查可空值，TypeScript将在调用<code class="fe kw kx ky kz b">filter</code>后自动推断不可空的类型。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c6b4" class="li lj iq kz b gy lk ll l lm ln">type SomeObject = { /* */ };</span><span id="16ae" class="li lj iq kz b gy mq ll l lm ln">const arrayWithNullableValues: Array&lt;SomeObject | null | undefined&gt; = [/* */];</span><span id="971a" class="li lj iq kz b gy mq ll l lm ln">const arrayNonNullable = arrayWithNullableValues.filter((value): value is SomeObject =&gt; !!value);</span></pre><h1 id="e600" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">铅字铸造</h1><p id="4bf3" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">将适当的类型放入可空过滤数组的另一种方法是利用类型转换。类型转换不是一个特定于TypeScript的概念，而是存在于几乎所有的类型系统或类型化编程语言中。这是一种机制，开发人员可以强制告诉类型系统将某个值视为某种类型。虽然不推荐，但是在有些情况下，当开发人员完全确定结果时，它们会很有用。</p><p id="64bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe kw kx ky kz b">filter</code>函数只接受谓词函数，所以不可能通过在回调中执行类型转换来影响结果数组的类型。相反，在应用<code class="fe kw kx ky kz b">filter</code>功能后，必须在变量级别上执行。如前所述，对于<code class="fe kw kx ky kz b">as Array&lt;T&gt;</code>,我们告诉TypeScript抛开他们所知道的关于数组的一切，把它看作是一个<code class="fe kw kx ky kz b">T</code>类型的数组。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="b30e" class="li lj iq kz b gy lk ll l lm ln">type SomeObject = { /* */ };</span><span id="299a" class="li lj iq kz b gy mq ll l lm ln">const arrayWithNullableValues: Array&lt;SomeObject | null | undefined&gt; = [/* */];</span><span id="6927" class="li lj iq kz b gy mq ll l lm ln">const arrayNonNullable = arrayWithNullableValues.filter(value =&gt; !!value) as Array&lt;SomeObject&gt;;</span></pre><h1 id="c25b" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">一般效用函数</h1><p id="859b" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">最后，还可以创建一个实用函数来进行过滤，并确保输入正确无误。与第一种方法类似，这种方法使用了类型保护。然而，不同之处在于类型是用一个独立的函数定义的，而不是内嵌在<code class="fe kw kx ky kz b">filter</code>函数回调中。</p><p id="7a17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">键入本身与我们研究的第一种方法没有什么不同。基本上，我们将函数的返回类型定义为类型谓词，向TypeScript表明传递的值是返回真值的实用函数的不可空值。</p><p id="0001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您甚至可以使这个实用函数成为一个通用函数，可以重用它来过滤任何对象或值的不可为null的值。为此，您必须更改函数的类型定义，以使用泛型类型。除此之外，一切都是一样的，现在您有了一个通用的实用函数，它将在TypeScript中正确地过滤不可为空的值。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4d09" class="li lj iq kz b gy lk ll l lm ln">function isNonNullable&lt;TValue&gt;(value: TValue | undefined | null): value is TValue {<br/>	return value !== null &amp;&amp; value !== undefined; // Can also be `!!value`.<br/>}</span><span id="ab92" class="li lj iq kz b gy mq ll l lm ln">type SomeObject = { /* */ };</span><span id="03b9" class="li lj iq kz b gy mq ll l lm ln">const arrayWithNullableValues: Array&lt;SomeObject | null | undefined&gt; = [/* */];</span><span id="cd15" class="li lj iq kz b gy mq ll l lm ln">const arrayNonNullable = arrayWithNullableValues.filter(isNonNullable);</span></pre><h1 id="ce74" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">最后的想法</h1><p id="1749" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">无论您使用React、Node还是其他形式的JavaScript库，您可能经常使用的一个函数是Array <code class="fe kw kx ky kz b">filter</code>函数。一个常见的用例，尤其是在JavaScript开发领域，是从数组中过滤出可空值。但是，如果将它与TypeScript结合使用，键入的结果并不总是如预期的那样。</p><p id="e650" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，本文介绍了在使用TypeScript从数组中过滤出可空值时整理类型的3种方法。这包括在<code class="fe kw kx ky kz b">filter</code>函数谓词上应用内联类型保护，对结果数组进行类型转换，以及使用类型保护的通用实用函数。使用这些方法，您将能够从数组中过滤可空值，并获得适当的类型。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4d41" class="li lj iq kz b gy lk ll l lm ln"><strong class="kz ir">Want to Connect?</strong></span><span id="aa4e" class="li lj iq kz b gy mq ll l lm ln">If you liked this article, consider checking out the other entries in the <a class="ae my" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">Uncommon React</a> newsletter and my <a class="ae my" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank">Twitter</a> for future updates.</span></pre><p id="155c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz">更多内容看</em> <a class="ae my" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mz">说白了。报名参加我们的</em> <a class="ae my" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mz">免费周报</em> </strong> </a> <em class="mz">。关注我们关于</em><a class="ae my" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mz">Twitter</em></strong></a><em class="mz">和</em><a class="ae my" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mz">LinkedIn</em></strong></a><em class="mz">。查看我们的</em> <a class="ae my" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mz">社区不和谐</em> </strong> </a> <em class="mz">，加入我们的</em> <a class="ae my" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mz">人才集体</em> </strong> </a> <em class="mz">。</em></strong></a></p></div></div>    
</body>
</html>