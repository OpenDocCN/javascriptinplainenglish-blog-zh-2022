<html>
<head>
<title>Getting Started with JavaScript Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法入门</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basics-of-javascript-algorithms-bbc0ddb785c2?source=collection_archive---------10-----------------------#2022-09-09">https://javascript.plainenglish.io/basics-of-javascript-algorithms-bbc0ddb785c2?source=collection_archive---------10-----------------------#2022-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="73c4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript算法基础第1部分:什么是算法？<em class="kc">一个</em> <strong class="ak"> <em class="kc">解决一个</em> <strong class="ak"> <em class="kc">特定问题</em> </strong> <em class="kc">时必须遵循的一套规则</em> </strong> <em class="kc">。</em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/36000d13013ca53bd58427bda056389d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oZFQCwi8K-tKBmH6"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1b0b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是理解<strong class="kw io"> JavaScript </strong>中<strong class="kw io">算法</strong>的系列作文的入门文章。以下是迄今为止发表的关于这一主题的文章的综合列表，每当有新的帖子发表时，该列表就会更新。我建议，按顺序读这个。</p><p id="97bd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">第1部分</strong>:JavaScript算法入门</p><p id="602c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">第二部分</strong> : <a class="ae kt" href="https://medium.com/p/a1b5a3ffcb71" rel="noopener">推导算法的时间复杂度/大O</a></p><p id="83dd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">第三部分</strong> : <a class="ae kt" href="https://medium.com/p/e786df20fc7b" rel="noopener">利用渐近分析导出常数时间复杂度O(1)</a></p><p id="eeae" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">第四部分</strong> : <a class="ae kt" href="https://medium.com/p/713856ad4e2" rel="noopener">递归算法及其时间复杂度O(n) vs O(2^n) </a></p><p id="5a8e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">第5部分</strong> : <a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/dynamic-programming-using-memoization-e1fd31bc9a55">使用记忆技术的动态搜索</a></p><p id="14e0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">第六部分</strong> : <a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/binary-search-and-its-time-complexity-in-javascript-d3f6e79fe84e">二分搜索法及其时间复杂度</a></p><p id="02d1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">第七部分</strong> : <a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/use-master-theorem-to-derive-big-o-of-a-recursive-binary-search-algorithm-7f32249f3f03">利用主定理导出递归二分搜索法的大O</a></p><p id="c431" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">此外，<strong class="kw io">建议</strong>浏览<strong class="kw io">这篇介绍性文章</strong>，因为它讲述了<strong class="kw io">非常基础的算法</strong>，这是<strong class="kw io">在继续之前了解</strong>的必要条件。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="a6d0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">所以，让我们从一个关于算法的最基本的问题开始。</p><h1 id="e94f" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated"><strong class="ak">什么是算法？</strong></h1><p id="cddd" class="pw-post-body-paragraph ku kv in kw b kx mp jo kz la mq jr lc ld mr lf lg lh ms lj lk ll mt ln lo lp ig bi translated"><em class="mu">一套</em> <strong class="kw io"> <em class="mu">解决一个</em> <strong class="kw io"> <em class="mu">特定问题</em> </strong> <em class="mu">时必须遵循的规则</em> </strong> <em class="mu">。</em></p><p id="b2ba" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是你在谷歌上搜索“<strong class="kw io">算法</strong>就会看到的基本定义。我们来理解一下，这里的“<strong class="kw io">规则集</strong>指的是解决一个<strong class="kw io">特定问题</strong>所必须遵循的<strong class="kw io">系列指令</strong>。这意味着，如果我们对一个问题遵循同样的规则和同样的输入，那么它将总是导致同样的解决方案。这是算法背后的核心思想。</p><p id="65b0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">作为一名程序员，我们编写的任何程序都被认为是一个<strong class="kw io">算法</strong>，因为它遵循上面提到的同样的<strong class="kw io">基本规则</strong>。例如，如果我们创建一个函数，将一个数与另一个数相加，我们也有一个算法。作为一名程序员，我们的目标是找到解决问题的最有效的方法。这意味着我们将总是寻找<strong class="kw io">最佳可用解决方案</strong>来解决特定问题，因为有多种方法来解决它。我们现在面临的问题是，我们如何找到最佳解决方案？</p><h2 id="81f2" class="mv ly in bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak">如何找到可能的最佳算法？</strong></h2><p id="3cd4" class="pw-post-body-paragraph ku kv in kw b kx mp jo kz la mq jr lc ld mr lf lg lh ms lj lk ll mt ln lo lp ig bi translated">当我们谈论找到给定问题的最佳解决方案时，我们可以考虑以下事情:</p><ul class=""><li id="cb5a" class="nh ni in kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated"><strong class="kw io"> <em class="mu">是消耗内存最少的算法吗？</em> </strong></li><li id="d1d7" class="nh ni in kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><strong class="kw io"> <em class="mu">是代码量最少的算法吗？</em>T25】</strong></li><li id="7a2e" class="nh ni in kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><strong class="kw io"> <em class="mu">是耗时最少的算法吗？</em>T29】</strong></li></ul><p id="ae2c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">最佳解决方案很可能取决于我们工作的条件。<strong class="kw io">但通常它是执行</strong>所需时间最少的一个。因此，我们应该寻找执行时间最少的算法。但是，我们如何测量一个算法的时间呢？</p><h2 id="8550" class="mv ly in bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak">测量算法的时间复杂度(使用时间差)</strong></h2><p id="f392" class="pw-post-body-paragraph ku kv in kw b kx mp jo kz la mq jr lc ld mr lf lg lh ms lj lk ll mt ln lo lp ig bi translated">让我们用一个例子来看看我们如何测量一个算法的时间复杂度。</p><h2 id="2014" class="mv ly in bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak">例题</strong></h2><p id="a10e" class="pw-post-body-paragraph ku kv in kw b kx mp jo kz la mq jr lc ld mr lf lg lh ms lj lk ll mt ln lo lp ig bi translated">编写一个函数，将数字作为输入，然后返回所有数字的总和。</p><p id="1de0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">函数:</strong>这个函数可以用JavaScript实现如下。</p><pre class="ke kf kg kh gt nv nw nx ny aw nz bi"><span id="ee89" class="mv ly in nw b gy oa ob l oc od">const n = [1, 2, 3, 4, 5];    // Input</span><span id="c386" class="mv ly in nw b gy oe ob l oc od"><strong class="nw io">function sum(n) {<br/>  let total = 0;<br/>  for (let index = 0; index &lt; n.length; index++) {<br/>    total += n[index];<br/>  }<br/>  return total;<br/>}</strong></span><span id="fcba" class="mv ly in nw b gy oe ob l oc od">console.log(sum(n));         // 15 </span></pre><p id="206f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上面的函数以一个数字数组作为参数，用0初始化总数，然后在for循环中我们遍历数组中的所有数字，加到总数中，最后返回总数。</p><p id="28cd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">例如，如果我们用数组[1，2，3，4，5]调用函数，那么我们得到的结果是15 ( <em class="mu"> i </em>)。e 1 + 2 + 3 + 4 + 5)。所以这是我们解决上述问题的第一个算法。</p><p id="673f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> <em class="mu">现在，让我们来看看如何测量它所花费的时间。</em> </strong></p><p id="6837" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为此，<strong class="kw io">一个简单的方法是通过计算函数</strong>开始和结束时间的差值来测量时间。这可以通过JavaScript实现，如下所示。</p><pre class="ke kf kg kh gt nv nw nx ny aw nz bi"><span id="5faa" class="mv ly in nw b gy oa ob l oc od">let startTime = 0;<br/>let endTime = 0;<br/>let timeToExecute = 0;</span><span id="528f" class="mv ly in nw b gy oe ob l oc od"><strong class="nw io">startTime = performance.now();</strong><br/>sum([1, 2, 3, 4, 5]);<br/><strong class="nw io">endTime = performance.now();</strong><br/><strong class="nw io">timeToExecute = endTime - startTime;</strong></span></pre><p id="4dfd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe of og oh nw b"><strong class="kw io">timeToExecute</strong></code> <strong class="kw io"> </strong>会给我们函数的<strong class="kw io">执行时间</strong>。让我们试着找出几个<strong class="kw io">不同参数</strong>的函数所用的时间。我们将在两个独立的设备上执行此操作，一个在较慢的设备上执行，另一个在较快的设备上执行。</p><p id="20b2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">在较慢的设备上执行上述功能:</strong></p><pre class="ke kf kg kh gt nv nw nx ny aw nz bi"><span id="1aec" class="mv ly in nw b gy oa ob l oc od">sum([1,2,3,4,5,6,7,8,9,10]);<br/><strong class="nw io">// 0.19999980926513672 -&gt; Time</strong></span><span id="856f" class="mv ly in nw b gy oe ob l oc od">sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]);<br/><strong class="nw io">// 0.2999999523162842  -&gt; Time</strong></span><span id="3f83" class="mv ly in nw b gy oe ob l oc od">sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]);    <br/><strong class="nw io">// 0.40000009536743164  -&gt; Time</strong></span></pre><p id="509c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">在更快的设备上执行上述功能:</strong></p><pre class="ke kf kg kh gt nv nw nx ny aw nz bi"><span id="172d" class="mv ly in nw b gy oa ob l oc od">sum([1,2,3,4,5,6,7,8,9,10]);  <br/><strong class="nw io">// 0  -&gt; Time</strong></span><span id="2537" class="mv ly in nw b gy oe ob l oc od">sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]);<br/><strong class="nw io">// 0  -&gt; Time</strong></span><span id="8ce3" class="mv ly in nw b gy oe ob l oc od">sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]);<br/><strong class="nw io">// 0  -&gt; Time</strong></span></pre><p id="232d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在，如果我们在速度较慢的设备和速度较快的设备上查看结果输出，您会发现时间并不总是相同。<strong class="kw io">在慢速设备上，它随着数组大小的增加而逐渐增加</strong>。但是，在更快的设备上，它是常数。</p><p id="9431" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">同样，如果我们对同一问题有另一种解决方案，我们认为这种解决方案比上面的实现更快，但在同样的时间内，即在更快的设备上<strong class="kw io"> 0 </strong>，那么我们就很难在这两种解决方案中找出最佳解决方案。<strong class="kw io">所以，根据这些具体的数字来测量时间并不是正确的方法。因为它有很多与我们算法无关的<strong class="kw io">影响因素</strong>。比如我们正在运行的<strong class="kw io">设备硬件</strong>上的事项。</strong></p><p id="cce8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在旧设备上，正如我们上面看到的，我们看到不同的数字。可能还有其他影响因素，如后台运行的进程数量、可用内存量减少等。那么，我们应该如何测量功能时间呢？</p><h2 id="ae33" class="mv ly in bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated">衡量算法的时间复杂度(使用模式)</h2><p id="53aa" class="pw-post-body-paragraph ku kv in kw b kx mp jo kz la mq jr lc ld mr lf lg lh ms lj lk ll mt ln lo lp ig bi translated">答案在于我们在不同输入下看到的模式，我们将在这里参考来自<strong class="kw io">较慢设备</strong>的结果，这里<strong class="kw io">倾向于花费更长的时间用于数组</strong>中传递的更多数字。</p><p id="8d77" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">一般来说，我们可以说，数组中的数字越多，花费的时间就越长。此外，该模式中有一点似乎很常见，那就是随着数组大小的增加<strong class="kw io">时间也会增加</strong>。事实上，我们应该这样看待它。</p><p id="e9cb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们不应该太在意具体的数字，因为这些数字取决于如上所述的环境中的许多因素。但是我们应该一直寻找这种和类似的<strong class="kw io">一般</strong>T37】模式。对于这个函数，如果你想画一个图，大概是这样的。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/7e4ff42fd712f94373965b07d62b54f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*_vESp8-0pjQubM45"/></div></figure><p id="dec7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是一个<strong class="kw io">线性图</strong>，因为我们在上面的函数中看到的<strong class="kw io">模式</strong>是线性的。我们看到，函数所花费的时间随着数组大小的增加而增加。并且，这个<strong class="kw io">时间的增加与数组大小的增加</strong>成比例。所以我们可以说增长是线性的，因此这里有一个线性增长函数。</p><p id="4e74" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="mu">我们增加输入的因子，在我们的例子中是</em><strong class="kw io"><em class="mu">【n】</em></strong><em class="mu">(即数组中的数字)，是时间函数增加的因子。</em></p><p id="bdcc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">当我们谈论算法时，这就是我们如何判断一个性能的。我们着眼于时间的功能，即<strong class="kw io">我们看到的</strong>模式，而不是实际时间，以便能够通过算法对输入的反应时间来评估算法的性能。并且，我们也称这种<strong class="kw io">为时间复杂度</strong>。在这种情况下，我们可以说<code class="fe of og oh nw b"><strong class="kw io">sum</strong></code> <strong class="kw io"> </strong>函数和算法具有<strong class="kw io">线性时间复杂度</strong>。</p><p id="f2f3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">上述问题的另一种解决方案(线性vs恒定时间)</strong></p><p id="6ee6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在JavaScript中，并不是所有的算法都需要线性时间。有时候我们有算法需要<strong class="kw io">常数时间</strong>。在这种情况下，<strong class="kw io">的输入数量</strong>不会影响该算法所花费的时间。我们可以通过如下所示修改前面的示例来看到这一点，以接受数字作为不同的参数，而不是一个数组。</p><pre class="ke kf kg kh gt nv nw nx ny aw nz bi"><span id="746b" class="mv ly in nw b gy oa ob l oc od"><strong class="nw io">function sum(n1, n2, n3, n4, n5) {<br/>  return n1 + n2 + n3 +n4 +n5;<br/>}</strong></span><span id="7900" class="mv ly in nw b gy oe ob l oc od">sum(1, 2, 3, 4, 5)   // 15</span></pre><p id="59ff" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在这种情况下，该函数接受五个参数，并返回所有参数的总和。这也是解决上述问题的另一种方法，我同意这不是最优的解决方案，因为参数的数量是固定的，如果我们需要更多的数字来传递参数，那么我们将不得不为它建立另一个函数。</p><p id="1fcf" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是，它仍然解决了问题，即计算所有通过的数字的总和。但是，当我们比较这两种功能时，这里有一个重要的区别需要注意。<strong class="kw io">修改后的函数没有循环，而是有一个单独的数学公式</strong>。</p><p id="b241" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在，如果我们尝试通过使用与我们应用于前一个循环函数相同的参数执行上述函数来<strong class="kw io">测量时间</strong>，您将会看到这里的结果是<strong class="kw io">常数</strong>。</p><pre class="ke kf kg kh gt nv nw nx ny aw nz bi"><span id="91b4" class="mv ly in nw b gy oa ob l oc od">sum(1,2,3,4,5,6,7,8,9,10);<br/><strong class="nw io">// 0  -&gt; Time</strong></span><span id="e45b" class="mv ly in nw b gy oe ob l oc od">sum(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30);<br/><strong class="nw io">// 0  -&gt; Time</strong></span><span id="07eb" class="mv ly in nw b gy oe ob l oc od">sum(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40);<br/><strong class="nw io">// 0  -&gt; Time</strong></span></pre><p id="e50b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">而且，不管我们给它传递多少参数，它都保持不变。我们在这里也没有任何模式，因为我们以前有不同的阵列大小。我们可以将此视为恒定时间的<strong class="kw io">例子。时间复杂度不变的图看起来像这样。</strong></p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/eef3d09acf22a6164c8b9f1d499a31cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/0*Q8fxF5DiK3RB19Mv"/></div></figure><p id="8b0b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">因此，通过比较上述两种算法的时间复杂度，即带有循环的<strong class="kw io">函数</strong> ( <strong class="kw io"> <em class="mu">参考较慢设备</em> </strong>的结果)和带有数学公式的<strong class="kw io">函数，我们可以说一个具有<strong class="kw io">线性</strong>时间复杂度，另一个具有<strong class="kw io">常数</strong>时间复杂度。</strong></p><h2 id="b7e7" class="mv ly in bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated">模式方法可靠吗？</h2><p id="be1e" class="pw-post-body-paragraph ku kv in kw b kx mp jo kz la mq jr lc ld mr lf lg lh ms lj lk ll mt ln lo lp ig bi translated">然而，这里有一个问题，<strong class="kw io">如果我们在一个非常快速的设备上执行这两个函数，从而产生恒定的时间值，会怎么样？我们在这里做什么？因为我们刚刚遵循的模式方法不能被应用，因为那里没有模式，因为结果是恒定的。</strong></p><p id="e94d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在这种情况下，我们可能会做出<strong class="kw io">不正确的判断</strong>，并将两个函数的<strong class="kw io">时间复杂度</strong>视为<strong class="kw io">常数</strong>，这与我们刚刚看到的较慢设备示例不同。因此，<strong class="kw io">即使这种通过识别基于时间的模式来识别函数的时间复杂度的技术也是不可靠的，因为它受到许多因素的影响</strong>。但是，我们确实有一个可靠的方法来评估算法，我们将在以后的帖子中关注它。</p><p id="b4ae" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><a class="ae kt" href="https://medium.com/@code.ceeker/basics-of-javascript-algorithms-part-2-a1b5a3ffcb71" rel="noopener"> <strong class="kw io">下一步- &gt;推导一个算法的时间复杂度/大O(渐近分析)</strong> </a></p><p id="931b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">感谢您的阅读。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="fa2a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="mu">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="mu">plain English . io</em></strong></a><em class="mu">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="mu">免费周报</em> </strong> </a> <em class="mu">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="mu">Twitter</em></strong></a><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="mu">LinkedIn</em></strong></a><em class="mu"/><a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="mu">YouTube</em></strong></a><em class="mu"/><a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="mu">不和</em> </strong> </a> <em class="mu">。对增长黑客感兴趣？检查</em> <a class="ae kt" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="mu">电路</em> </strong> </a> <em class="mu">。</em></p></div></div>    
</body>
</html>