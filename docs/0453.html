<html>
<head>
<title>Promise.all() v. Promise.allSettled() for Multiple Asynchronous Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多个异步操作的promise . all()v . promise . all settled()</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/promise-all-v-promise-allsettled-for-multiple-asynchronous-operations-239944c12ec7?source=collection_archive---------5-----------------------#2022-01-26">https://javascript.plainenglish.io/promise-all-v-promise-allsettled-for-multiple-asynchronous-operations-239944c12ec7?source=collection_archive---------5-----------------------#2022-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb22" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解决多个异步操作的两种不同方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d5fe5f5dd393010911e5c18988800269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CXKgYZ7Z1lfRXgJv"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@maritafox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marita Kavelashvili</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="221a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="55c9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe mk ml mm mn b">Promise.allSettled</code>是一个相对较新的特性，目前大多数主流浏览器都支持它。该功能改善了<code class="fe mk ml mm mn b">Promise.all</code>(ECMA 2015中推出)的短路特性。当需要立即执行异步任务时，<code class="fe mk ml mm mn b">Promise.all</code>是一个有用的操作员，但众所周知，当出现任何故障时，他会变得不耐烦(短路)。例如，<strong class="lq ir"> <em class="mo">例1 </em> </strong>即将失败，转到<code class="fe mk ml mm mn b">.catch</code>子句，不等待其他异步任务。这就需要一种叫做<code class="fe mk ml mm mn b">Promise.allSettled</code>的新方法，它会一直等到所有给定的承诺要么实现，要么被拒绝</p><p id="57ae" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><strong class="lq ir">例1 </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/1b234d67d73acaff91a38200e9c1f3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VmPo_6-FbUrp-JtHE0nNg.png"/></div></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="7fbe" class="kw kx iq bd ky kz nc lb lc ld nd lf lg jw ne jx li jz nf ka lk kc ng kd lm ln bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="99c6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您将前一个示例<strong class="lq ir">中的<code class="fe mk ml mm mn b">Promise.all</code>示例1 </strong>更改为<code class="fe mk ml mm mn b">Promise.allSettled</code>，则会转到<code class="fe mk ml mm mn b">.then</code>子句，成功执行所有异步任务。换句话说，<code class="fe mk ml mm mn b">Promise.allSettled</code>等待，直到所有承诺都被结算，而不管每个承诺是失败还是成功。</p><h2 id="c445" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">Promise.all &amp; Promise.allSettled的共同特征</h2><ol class=""><li id="f4bd" class="nt nu iq lq b lr ls lu lv lx nv mb nw mf nx mj ny nz oa ob bi translated">当有多个相关的异步任务时，这两种方法都很有用</li><li id="74b0" class="nt nu iq lq b lr oc lu od lx oe mb of mf og mj ny nz oa ob bi translated">两种方法都支持并发承诺，并发承诺的性能更好</li></ol><h2 id="5112" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">使用的好处。一切都解决了。全部</h2><ol class=""><li id="7dde" class="nt nu iq lq b lr ls lu lv lx nv mb nw mf nx mj ny nz oa ob bi translated">显式名称；allSettled是指没有悬而未决的承诺</li><li id="e528" class="nt nu iq lq b lr oc lu od lx oe mb of mf og mj ny nz oa ob bi translated">更好的错误处理</li><li id="e2ae" class="nt nu iq lq b lr oc lu od lx oe mb of mf og mj ny nz oa ob bi translated">一些助手功能是可访问的</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/34445c4acb26f74e471a3cbb136f755b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SDPOZBtEvFAxzZSlpPaJQ.png"/></div></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="9f8a" class="kw kx iq bd ky kz nc lb lc ld nd lf lg jw ne jx li jz nf ka lk kc ng kd lm ln bi translated">诺言的共同特征<em class="oi">。所有</em> &amp;承诺</h1><p id="998c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><strong class="lq ir"> 1。当有多个相关的异步任务时，这两种方法都很有用</strong></p><p id="2776" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">这两种方法都接受一个承诺列表，当有多个相关的异步任务，而整个代码依赖于这些任务才能成功工作时，这两种方法都很有用。例如，如果<code class="fe mk ml mm mn b">p1</code> &amp; <code class="fe mk ml mm mn b">p2</code>是相关的异步任务，都需要执行，我们可以用<code class="fe mk ml mm mn b">Promise.all</code>或<code class="fe mk ml mm mn b">Promise.allSettled</code>代替<code class="fe mk ml mm mn b">[await p1, await p2]</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7227" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><strong class="lq ir"> 2。两种方法都支持并发承诺，并发承诺的性能更好</strong></p><p id="b883" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">它们都支持并发承诺，并且非常有用，除非承诺A和B相互依赖。例如，如果您作为前端开发人员制作一个用户列表下拉UI，而后端开发人员说他为用户维护两个独立的数据库(一个用于存档(旧)用户，一个用于活动用户)。如果查询存档数据库和活动数据库分别需要5秒和3秒，那么像<code class="fe mk ml mm mn b">Promise.all</code>和<code class="fe mk ml mm mn b">Promise.allSettled</code>这样的并发承诺可以帮助我们在5秒内(无论哪个更慢)使用这两个结果，而不是8秒(5 + 3)。让我们看看代码，比较顺序异步函数和并发异步函数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="ba71" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><strong class="lq ir">输出:</strong></p><pre class="kg kh ki kj gt ol mn om on aw oo bi"><span id="2b1a" class="nh kx iq mn b gy op oq l or os">Q3Seconds execution: 3.009s<br/>Q3Seconds execution: 3.004s<br/>[ 'Archived user database', 'Active user database' ]<br/>concurrentPromise execution: 5.013s<br/>Q5Seconds execution: 5.010s<br/>sequentialStart execution: 8.014s</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="d66f" class="kw kx iq bd ky kz nc lb lc ld nd lf lg jw ne jx li jz nf ka lk kc ng kd lm ln bi translated">使用的好处。一切都解决了。全部</h1><p id="45d9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><strong class="lq ir"> 1。显式名称；allSettled是指没有待定的承诺</strong></p><p id="fa5e" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><a class="ae kv" href="https://github.com/tc39/proposal-promise-allSettled#promiseallsettled" rel="noopener ugc nofollow" target="_blank"> ECMA技术委员会</a>展示了引进<code class="fe mk ml mm mn b">allSettled</code>这种新方法的一些想法和动机。它说<code class="fe mk ml mm mn b">allSettled</code>之所以如此命名，是因为我们在谈论一个<em class="mo">已经确定的</em>而不是悬而未决的承诺。此外，许多图书馆已经采用了<code class="fe mk ml mm mn b">allSettled</code>这个名字，而且它已经被一些著名的图书馆普遍使用，如</p><p id="66ef" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><a class="ae kv" href="https://www.npmjs.com/package/promise.allsettled" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a><em class="mo">|</em><a class="ae kv" href="https://www.npmjs.com/package/q" rel="noopener ugc nofollow" target="_blank"><em class="mo">问</em> </a></p><p id="671c" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><strong class="lq ir"> 2。更好的错误处理</strong></p><p id="b894" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><code class="fe mk ml mm mn b">Promise.allSettled</code>更擅长错误处理。正如我们在前面的例子<strong class="lq ir">例1 </strong>中所讨论的，当承诺中存在错误情况时，<code class="fe mk ml mm mn b">Promise.all</code>的短路性质是不可选择的。如果有5个对服务器的请求，其中一个请求失败了，那么每个请求都会被抛出到一个<code class="fe mk ml mm mn b">catch</code>子句。通常，我们希望确保每个请求都得到执行和解决，不管是否有失败的请求。通过这种方式，我们可以发现哪些请求特别失败，并且可能只重试失败的请求来获取正确的数据。</p><p id="483d" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">当使用<code class="fe mk ml mm mn b">async / await</code>函数时，<code class="fe mk ml mm mn b">Promise.allSettled</code>更好地处理错误情况变得更加突出。当我们对<code class="fe mk ml mm mn b">Promise.all</code>使用<code class="fe mk ml mm mn b">async / await</code>时，我们需要用<code class="fe mk ml mm mn b">try ... catch</code>包装方法，担心错误情况会破坏代码流。</p><p id="4528" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">下面的例子显示了处理错误情况的<code class="fe mk ml mm mn b">try ... catch</code>语句</p><pre class="kg kh ki kj gt ol mn om on aw oo bi"><span id="80ca" class="nh kx iq mn b gy op oq l or os">(async () =&gt; {<br/>  try {</span><span id="30a2" class="nh kx iq mn b gy ot oq l or os">    const promises = await Promise.all([p1, p2]);<br/>  }<br/>  catch (e) {</span><span id="377e" class="nh kx iq mn b gy ot oq l or os">   console.log(e) // ERROR goes here<br/>  }<br/>})();</span></pre><p id="48db" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">然而，<code class="fe mk ml mm mn b">allSettled</code>的使用消除了用<code class="fe mk ml mm mn b">try … catch</code>语句包装承诺的需要</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/2aad03d5d990069146bb5afb2969d369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOkkS9LLfLpTLFkd6CncuA.png"/></div></div></figure><p id="8f4a" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><strong class="lq ir"> 3。一些辅助功能是可访问的</strong></p><p id="a317" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">使用<code class="fe mk ml mm mn b">allSettled</code>，失败的承诺返回状态<code class="fe mk ml mm mn b">rejected</code>和失败原因<code class="fe mk ml mm mn b">reason</code>，而成功的承诺返回状态<code class="fe mk ml mm mn b">fulfilled</code>和<code class="fe mk ml mm mn b">value</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/29c40cf08003008f90bbc881acc0f607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*bjWbp5lCcgf5YMExpHA72g.png"/></div></figure><p id="bc87" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">利用这个特点，我做了一些辅助函数。请随意制作你自己的并在评论中分享</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="50ad" class="kw kx iq bd ky kz nc lb lc ld nd lf lg jw ne jx li jz nf ka lk kc ng kd lm ln bi translated">摘要</h1><p id="9b0a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe mk ml mm mn b">Promise.allSettled()</code>方法的工作方式与<code class="fe mk ml mm mn b">Promise.all()</code>相似，但是它有一些改进，使得我们的编码工作更加容易。我建议您使用<code class="fe mk ml mm mn b">Promise.allSettled()</code>，并随时向我提供反馈。我们随时欢迎您的反馈。谢谢大家！</p><p id="a244" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><em class="mo">更多内容看</em> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mo">说白了。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mo">免费每周简讯</em> </strong> </a> <em class="mo">。在我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mo">社区不和谐</em> </strong> </a> <em class="mo">获得独家获得写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>