<html>
<head>
<title>How to Implement Daily Active Users Metric using Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Redis实现每日活跃用户指标</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-daily-active-users-metric-using-redis-4a7d7c4aca8f?source=collection_archive---------3-----------------------#2022-07-06">https://javascript.plainenglish.io/how-to-implement-daily-active-users-metric-using-redis-4a7d7c4aca8f?source=collection_archive---------3-----------------------#2022-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ff4e2bb196093622da704373cfbf674d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtJeCka-IbI3z1HfoX8scg.jpeg"/></div></div></figure><p id="f3e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用Redis可以做很多事情，但是何时何地使用它对一些人来说可能有点困惑。远程词典服务器(是的，没错，这就是Redis这个词的意思😉)将会令人难以置信地提高你的应用程序的性能，通过每秒数百万次的操作，将你的应用程序的读写操作的延迟减少到不到一毫秒——是的，这不是一个打字错误。</p><p id="1046" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Redis有大量您熟悉的数据结构来满足您的应用程序需求。它允许你将应用程序的数据存储为字符串、列表、散列、集合、JSON…等等。你猜怎么着？Redis超级好用。使用Redis，您可以编写更少的代码来在应用程序中存储、访问和使用数据。此外，您可以使用Redis API，而不必担心管理单独的缓存、数据库或底层基础设施。</p><p id="e752" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是嘿！Redis如何使我的应用程序受益已经说得够多了。我已经恋爱了。请告诉我，Redis到底是什么？放松…😉</p><p id="1667" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据官方文档，Redis是一个开源的、内存中的[键-值]数据结构存储，用作数据库、缓存、消息代理和流引擎。您可以使用大多数编程语言的Redis，如JavaScript、Java、Python、C++、C#、Swift、PHP等。</p><blockquote class="kt ku kv"><p id="82d9" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><em class="in"> Psst:这只是Redis的一个高级概述。欲了解更多，请访问</em> <a class="ae la" href="https://redis.io/docs/" rel="noopener ugc nofollow" target="_blank"> <em class="in">官方网站</em> </a> <em class="in">。</em></p></blockquote><p id="0eed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，现在请告诉我，我能为雷迪斯·🥺.做些什么当然，没问题！✌️Redis用例如下:</p><ul class=""><li id="4f71" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated">缓存可以减少数据访问延迟，增加吞吐量，减轻关系或NoSQL数据库和应用程序的负担。</li><li id="8d93" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">聊天、消息传递和队列，利用各种数据结构，如列表、排序集和散列。</li><li id="3e17" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">会话存储用于管理会话数据，如用户配置文件、凭据、会话状态和特定于用户的个性化设置。</li><li id="4aba" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">通过利用Redis排序集数据结构的游戏排行榜。</li><li id="98bd" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">使用GEOADD、GEODIST、GEORADIUS和GEORADIUSBYMEMBER等命令管理实时地理空间数据，以实时存储、处理和分析地理空间数据。</li><li id="9c64" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">快速内存数据存储支持实时流媒体。</li><li id="c3ca" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">快速内存数据存储，用于快速构建、训练和部署机器学习模型。</li><li id="b040" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">社交媒体分析、广告定位、个性化和物联网等实时分析用例。</li></ul><p id="dc99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有更多！</p><h1 id="0a7d" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">如何利用Redis缓存特性的强大功能，从Prometheus指标中获取每日活跃用户</h1><p id="b5ff" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">现在，让我向您展示如何最大化Redis缓存特性，以解决从现实应用程序中实时获取唯一活跃用户的业务问题。这可能就是你在这里的原因，不是吗？</p><h1 id="a7b7" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">问题是</h1><p id="4a4e" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">让我们再次强调这个问题。您需要从集成到Node.js应用程序中的Prometheus客户端获取一个指标。这个指标是每日活跃用户的计数，即每天至少浏览您的网站一次的每个用户。所以，无论用户一天打开你的网站100万次还是100万次，他在网站上的活动当天都记录为1。</p><h1 id="b2a6" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">这个计划</h1><p id="e27d" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">我们将创造一个普罗米修斯计数器。如果唯一用户打开网站并使用受保护的路由，计数器将累计1。该增量将保持不变，并且在那天结束之前不会因同一用户而改变。这种机制将适用于当天打开网站的每个唯一用户。因此，计数器在一天中为每个不同的用户不断增加。然后，在第二天，对于每个相同的唯一用户，计数器将增加1，并一直保持到当天结束。简而言之，用户访问网站的每一天，计数器将为每个独立用户增加1。</p><h1 id="236e" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">阻挡者</h1><p id="0a8f" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">为了识别用户已经在一天中至少打开过一次站点，并且因此不会在他在同一天迟早打开另一个受保护的路由时增加计数器，我们必须存储用户的信息，下次我们的应用程序接收到另一个对受保护的路由的请求时，我们可以使用这些信息来验证。我们不想将这些信息存储在我们的数据库中。不会吧！🙅‍♂️:我们需要的是一个缓存系统。👍</p><h1 id="0f40" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Redis来救援了！</h1><p id="6c12" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">Redis是完美的解决方案。使用Redis缓存，我们将在受保护的路由上执行以下操作:</p><ul class=""><li id="b250" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated">使用用户的ID作为密钥。</li><li id="1905" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">检查是否有基于键的缓存数据。</li><li id="641d" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">如果没有数据，那一定是用户当天第一次打开网站。因此，将用户的ID与…的结果一起存储</li><li id="4d21" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">以秒为单位计算从他打开站点到一天结束还剩多少时间，并将其用作Redis的到期时间。</li><li id="9209" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">然后，将每日活跃用户计数器增加1</li></ul><h1 id="12cd" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">先决条件</h1><ul class=""><li id="2bed" class="lb lc in jx b jy mn kc mo kg ms kk mt ko mu ks lg lh li lj bi translated">普罗米修斯:因为这是关于雷迪斯的，我假设你至少已经知道了普罗米修斯的基本知识。如果你没有，我建议你先参加一个速成班。</li><li id="2ff8" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">Grafana:对Grafana略知一二是理想的。但是如果你不知道Grafana，看看他们的<a class="ae la" href="https://grafana.com/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>。这很简单。</li><li id="c1bc" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">Redis:你应该知道Redis的一些基本概念。但这不是问题——我已经在一开始就向你介绍了其中的一些。此外，我将用<a class="ae la" href="https://redis.io/docs/manual/cli/" rel="noopener ugc nofollow" target="_blank"> redis-cli </a>带您完成安装和一些基本的Redis命令。</li><li id="2947" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">现有Node.js项目:在本文中，我将只分享Redis、Prometheus和Grafana实现的代码片段和截图，以实现主题目标，即获取日常活跃用户。</li></ul><p id="c2fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，我们开始吧！✌️</p><h1 id="8d70" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">安装Redis</h1><p id="3cf8" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">如何安装Redis取决于您的操作系统。点击此处查看最符合您需求的指南<a class="ae la" href="https://redis.io/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="dd9a" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">让我们用CLI来探索Redis</h1><p id="5a51" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">成功安装Redis后，打开您的终端并执行以下命令来启动Redis服务器。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c309" class="ne lq in na b gy nf ng l nh ni">❯ redis-server</span></pre><p id="3526" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这应该会产生如下所示的输出:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/1aff0ea508eb224c5c16837488319567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3MnpLzESq6osZX-bqmR-A.png"/></div></div></figure><p id="3191" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您得到一个错误，那么您可能没有安装Redis，或者对于Windows用户，您不是在WSL终端上。确保按照此处的安装指南<a class="ae la" href="https://redis.io/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">安装Redis。如果您使用的是Windows，请确保打开WSL终端。然后，再次尝试该命令。</a></p><p id="2838" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，您的终端上打印的部分信息表明Redis正在您的本地机器上的端口6379上运行。这是Redis服务器的默认端口号。</p><p id="af5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当Redis服务器正在运行时，打开一个新的终端并执行以下命令来启动CLI并访问Redis。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="4427" class="ne lq in na b gy nf ng l nh ni">❯ redis-cli</span></pre><p id="8215" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将打开一个指向<code class="fe nk nl nm na b">127.0.0.1:6379</code>的命令提示符。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/57fdac93e6a601f175a6aa7a522b533b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1MD__enRir70DOe2_F2mw.png"/></div></div></figure><p id="641c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们使用一些Redis命令。键入并执行以下命令，获取与某个模式匹配的所有键。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e880" class="ne lq in na b gy nf ng l nh ni">127.0.0.1:6379 ❯ KEYS *</span></pre><p id="5888" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Redis在存储点将数据映射到您指定的键。将键视为数据的id。要检索存储的数据，必须通过一个<code class="fe nk nl nm na b">key</code>。在上面的命令中，如果在<code class="fe nk nl nm na b">KEYS</code>关键字后指定的模式匹配一个键，如果模式是<code class="fe nk nl nm na b">*</code>，表示“所有键”，则返回一个或多个键。</p><p id="7853" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的命令应该会返回一条<code class="fe nk nl nm na b">empty list or set</code>消息…除非你已经存储了一些过去的数据。所以，让我们创建一个新的。执行以下命令:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bfd1" class="ne lq in na b gy nf ng l nh ni">127.0.0.1:6379 ❯ SET name Kenneth</span></pre><p id="8e56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nk nl nm na b">SET</code>是设置新数据的关键字。它需要一个键<code class="fe nk nl nm na b">name</code>和值<code class="fe nk nl nm na b">Kenneth</code>。注意，像这样存储的数据是作为字符串存储的。现在检查您的密钥<code class="fe nk nl nm na b">name</code>是否存在。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="aff6" class="ne lq in na b gy nf ng l nh ni">127.0.0.1:6379 ❯ KEYS name</span></pre><p id="c6e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该会看到包括您的新密钥<code class="fe nk nl nm na b">name</code>在内的密钥列表。但是，如果我对<code class="fe nk nl nm na b">value</code>感兴趣呢？我想看看用键存储的值。对此的命令是:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2de2" class="ne lq in na b gy nf ng l nh ni">127.0.0.1:6379 ❯ GET name</span></pre><p id="6db7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nk nl nm na b">GET</code>是获取数据的关键字。它需要一个键，在本例中是<code class="fe nk nl nm na b">name</code>。这将输出该键存储的值。所以，你应该看看<code class="fe nk nl nm na b">Kenneth</code>。</p><p id="0d36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的密钥(和值)将被永久存储，因为我们在创建时没有指定过期时间。但是，我们可以使用以下命令删除它:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3638" class="ne lq in na b gy nf ng l nh ni">127.0.0.1:6379 ❯ DEL name</span></pre><p id="795d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将返回<code class="fe nk nl nm na b">(integer) 1</code>,表示它被成功删除。但是，如果我们想在创建时为新数据设置一个到期时间呢？其语法是:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="de3a" class="ne lq in na b gy nf ng l nh ni">127.0.0.1:6379 ❯ SETEX name 15 Kenneth</span></pre><p id="42fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nk nl nm na b">SETEX</code>设置一个新的密钥和值，并在该值之前使用过期时间作为参数。到期时间必须以秒为单位。因此，上面的命令将设置一个名为<code class="fe nk nl nm na b">name</code>的新键，并为其分配一个名为<code class="fe nk nl nm na b">Kenneth</code>的值，并启动一个15秒的计时器。要获得关于还剩多少时间过期的信息，语法是:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7747" class="ne lq in na b gy nf ng l nh ni">127.0.0.1:6379 ❯ TTL name</span></pre><p id="0c2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nk nl nm na b">TTL</code>代表“生存时间”。它需要密钥的名称，它应该确定它的生存时间。反复执行上面的代码将会产生不同的输出，因为键(名称)的生存时间正在倒计时。一旦到了-2，就说明钥匙没了。</p><p id="e7ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">#普罗米修斯</p><p id="910b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前所述，我将只关注Prometheus代码中实现度量逻辑的部分。在实现Prometheus时，我通常会创建一个<code class="fe nk nl nm na b">metrics.js</code>文件来定义我的度量。将以下代码片段复制并粘贴到您的指标文件中:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="97d9" class="ne lq in na b gy nf ng l nh ni">import client from 'prom-client';</span><span id="3145" class="ne lq in na b gy no ng l nh ni"> export const dailyActiveUsersGauge = new client.Gauge({<br/>  name: 'my_daily_active_users',<br/>  help: 'Active users metrics on a daily basis.',<br/>  labelNames: ['user_id', 'year', 'month', 'day'],<br/> });</span></pre><p id="59e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，您会有一个验证请求<code class="fe nk nl nm na b">jwt</code>令牌的中间件。为此，我将创建一个<code class="fe nk nl nm na b">protect.js</code>中间件文件。它将包含我的<code class="fe nk nl nm na b">jwt</code>验证逻辑。如果验证通过，我将从解码的令牌中获得用户的<code class="fe nk nl nm na b">id</code>(它将被用作发布<code class="fe nk nl nm na b">jwt</code>令牌时所需的id)。然后，我会找到其<code class="fe nk nl nm na b">id</code>与解码的令牌<code class="fe nk nl nm na b">id</code>匹配的用户，并将用户的详细信息附加到请求对象上名为<code class="fe nk nl nm na b">user</code>的新属性中(因此，<code class="fe nk nl nm na b">req.user</code>)。最后调用栈中的<code class="fe nk nl nm na b">next()</code>中间件。</p><p id="4bee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，这只是我的看法。但是，无论您如何设计您的身份验证逻辑，只要您可以从请求对象中获得用户的<code class="fe nk nl nm na b">id</code>,就可以挂载下面的代码片段:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7376" class="ne lq in na b gy nf ng l nh ni">import { dailyActiveUsersGauge } from 'path/to/metrics.js';<br/> <br/> dailyActiveUsersGauge.inc(<br/>    {<br/>       user_id: currentUser.uid,<br/>       year,<br/>       month,<br/>       day,<br/>    },<br/>    1,<br/> );</span></pre><p id="51e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将创建一个名为<code class="fe nk nl nm na b">my_daily_active_users</code>和一些标签(<code class="fe nk nl nm na b">year</code>、<code class="fe nk nl nm na b">month</code>和<code class="fe nk nl nm na b">day</code>)的新度量指标，累积样本值为1。</p><p id="250e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">##Redis</p><p id="cbd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果没有Redis的帮助，我们不能依赖于我们当前的实现，因为每次相同的用户使用受保护的路由和调用<code class="fe nk nl nm na b">dailyActiveUsersGauge</code>度量时，样本值都会不断增加。这将在一天结束时产生不准确的结果。所以，我们用Redis来缓存用户的<code class="fe nk nl nm na b">id</code>。</p><p id="eb34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们安装<code class="fe nk nl nm na b">redis npm</code>包</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1a32" class="ne lq in na b gy nf ng l nh ni">❯ npm i redis</span></pre><p id="cf6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在项目文件夹中创建一个文件(我称之为redisCacheHandler.js ),并将以下代码粘贴到其中:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6b4a" class="ne lq in na b gy nf ng l nh ni">import { createClient } from 'redis';<br/> <br/> let client;<br/> <br/> if (process.env.NODE_ENV === 'production') {<br/>  client = createClient({<br/>    url: `redis://${process.env.REDIS_USER}:${process.env.REDIS_PASSWORD}@${process.env.REDIS_HOSTNAME}:${process.env.REDIS_PORT}`,<br/>   });<br/> } else {<br/>  // You should install redis and run the service command ----&gt; redis-server<br/>   client = createClient();<br/> }<br/> <br/> client.on('error', (err) =&gt; console.log('Redis Client Error', err));<br/> <br/> async function connectRedis() {<br/>   await client.connect();<br/> }<br/> <br/> connectRedis();<br/> <br/> const defaultExpirationTime = 60 * 10; // 60 seconds times 10 -&gt; 10 minutes<br/> <br/> const getOrSetCache = (cb) =&gt; cb();<br/> <br/> export const getCache = (key) =&gt;<br/>   new Promise((resolve, reject) =&gt; {<br/>     try {<br/>       getOrSetCache(async () =&gt; {<br/>        const data = await client.get(key);<br/>        if (data) {<br/>          console.log('SENDING CACHE...🍫');<br/>        }<br/>        resolve(JSON.parse(data));<br/>      });<br/>    } catch (error) {<br/>      reject(error);<br/>    }<br/> });<br/> <br/> export const setCache = (key, data, expTime) =&gt; {<br/>  if (typeof expTime === 'undefined') {<br/>    expTime = defaultExpirationTime;<br/> }<br/> <br/>  return new Promise((resolve, reject) =&gt; {<br/>    try {<br/>      getOrSetCache(async () =&gt; {<br/>        const isOk = await client.set(key, JSON.stringify(data), {<br/>          EX: expTime,<br/>        });<br/>        if (isOk) {<br/>          console.log('CACHED! ✅');<br/>        }<br/>        resolve();<br/>      });<br/>    } catch (error) {<br/>      reject(error);<br/>    }<br/>  });<br/> };</span></pre><p id="6cb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简要解释代码:</p><ul class=""><li id="7f74" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated">导入redis库。</li><li id="a4d6" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">检查应用程序运行的环境。如果在开发中，使用本地redis服务器(确保它正在运行)。如果在生产中，连接到<a class="ae la" href="https://redis.info/3NBGJRT" rel="noopener ugc nofollow" target="_blank"> Redis云</a>。</li><li id="1993" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">导出两个函数:</li><li id="7588" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><code class="fe nk nl nm na b">getCache</code>:通过给定的键检查存储的数据。返回数据的承诺(可能未定义)。</li><li id="620f" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><code class="fe nk nl nm na b">setCache</code>:设置新的键值数据，返回承诺。需要密钥、数据和以秒为单位的过期时间参数。如果未提供到期时间，则使用默认的到期时间10分钟。</li></ul><p id="e1c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，回到我们实现<code class="fe nk nl nm na b">dailyActiveUsersGauge</code>函数的地方，修改您的代码如下:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="4e91" class="ne lq in na b gy nf ng l nh ni">import { dailyActiveUsersGauge } from 'path/to/metrics.js';<br/>import { getCache, setCache } from 'path/to/redisCacheHandler.js';<br/> <br/>// .. ..<br/>  const cacheKey = currentUser.uid;<br/>    const date = new Date();<br/> <br/>    const year = date.getFullYear();<br/>    const month = date.getMonth();<br/>    const day = date.getDate();<br/> <br/>    const now = Date.now();<br/>    const endOfDay = date.setUTCHours(23, 59, 59, 999);<br/> <br/>    const secondsLeftTillEndOfDay = Math.floor((endOfDay - now) / 1000);<br/> <br/>    const cachedData = await getCache(cacheKey);<br/> <br/>    if (!cachedData) {<br/>      dailyActiveUsersGauge.inc(<br/>        {<br/>          user_id: currentUser.uid,<br/>          year,<br/>          month,<br/>          day,<br/>        },<br/>        1,<br/>      );<br/> <br/>      // cache<br/>      await setCache(cacheKey, '_', secondsLeftTillEndOfDay);<br/>   }<br/> <br/>// .. ..</span></pre><p id="023f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简要解释代码:</p><ul class=""><li id="d578" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated">导入我们的自定义redis模块。获取日、月和年，并将它们传递给dailyActiveUsersGauge函数。我们将需要这些信息，尤其是“日期”,以便与Prometheus一起对我们的指标进行分组。这正是我们最终想要获得每日计数的方式。</li><li id="34c8" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">使用用户的ID作为密钥</li><li id="9781" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">检查是否有基于键的缓存数据</li><li id="e21a" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">如果没有数据，那一定是用户当天第一次打开网站。因此，将用户的ID与…的结果一起存储</li><li id="9596" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">以秒为单位计算从他打开站点的时间到一天结束还剩多少时间作为到期时间</li><li id="67d6" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">然后，将每日活跃用户量增加1</li></ul><p id="c4fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述实现将确保我们有一个准确的每日用户计数，因为只有在Redis下有新用户或新密钥时，计数器才会增加。</p><h1 id="0727" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">格拉夫纳</h1><p id="41c5" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">在Grafana仪表板上，创建一个新面板，并按如下方式构建Prometheus metrics浏览器:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6129a65361525efee3b559eeac00d6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*Z-AVzz0L9BgIo-DVcOIvtA.png"/></div></figure><h1 id="3db8" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="61f2" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">Redis是一个强大的工具，几乎可以在web应用程序的任何地方使用。希望这篇文章是有帮助的，更重要的是对Redis的力量大开眼界。</p><p id="5f2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章是与Redis合作的。</p><p id="1091" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要了解更多信息，请浏览以下参考链接:</p><ul class=""><li id="eda4" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated"><a class="ae la" href="https://redis.info/3NBGJRT" rel="noopener ugc nofollow" target="_blank">免费试用Redis云</a></li><li id="83e6" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="https://redis.info/3Ga9YII" rel="noopener ugc nofollow" target="_blank">观看此视频，了解Redis云相对于其他Redis提供商的优势</a></li><li id="d1da" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="https://redis.info/3LC4GqB" rel="noopener ugc nofollow" target="_blank"> Redis开发者中心—工具</a></li><li id="f87d" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="https://redis.info/3wMR7PR" rel="noopener ugc nofollow" target="_blank"> RedisInsight桌面GUI </a></li></ul><p id="b43b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">更多内容看</em> <a class="ae la" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kw">说白了。报名参加我们的</em> <a class="ae la" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kw">免费周报</em> </strong> </a> <em class="kw">。关注我们关于</em><a class="ae la" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kw">Twitter</em></strong></a><em class="kw">和</em><a class="ae la" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kw">LinkedIn</em></strong></a><em class="kw">。查看我们的</em> <a class="ae la" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kw">社区不和谐</em> </strong> </a> <em class="kw">加入我们的</em> <a class="ae la" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kw">人才集体</em> </strong> </a> <em class="kw">。</em></strong></a></p></div></div>    
</body>
</html>