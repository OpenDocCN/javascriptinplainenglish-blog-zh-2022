<html>
<head>
<title>Mastering JavaScript Object Inheritance is Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript对象继承很容易</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/as-you-can-see-mastering-js-object-inheritance-is-so-easy-d39113fe8ec3?source=collection_archive---------10-----------------------#2022-07-21">https://javascript.plainenglish.io/as-you-can-see-mastering-js-object-inheritance-is-so-easy-d39113fe8ec3?source=collection_archive---------10-----------------------#2022-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8e35e6e074cd7bd9d4e8a984c295a161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qQtT4I4obfDBD8zS"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b9f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">原型链传承</strong></p><p id="1688" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">继承是通过将子类的原型指向父类的实例来实现的。<em class="ky">如果一个父类有一个引用类型的私有属性，那么这个属性在被继承为公共属性时，就被所有子类共享，任何子类对当前属性的任何改变都会影响到所有其他继承的子类。</em></p><p id="5c0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点</strong></p><ul class=""><li id="ec2a" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">子类可以访问父类添加的原型方法和属性。</li><li id="3f08" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">简单易用。</li></ul><p id="7ab0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点</strong></p><ul class=""><li id="0ba4" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">子类只能从一个父类继承，不可能有多个继承。</li><li id="dbf4" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">原型对象的属性由所有实例共享。</li><li id="2b61" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">子类实例不能动态地将参数传递给父类的构造函数。</li><li id="159a" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">子类的新方法必须放在原型替换之后。</li></ul><p id="4aba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">实例</strong></p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="f1ee" class="lw lx in ls b gy ly lz l ma mb">function Person(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>    this.children = [1, 2];<br/>    this.setName = function() {};<br/>}</span><span id="3b95" class="lw lx in ls b gy mc lz l ma mb">Person.prototype.addChild = function() {};</span><span id="1cbd" class="lw lx in ls b gy mc lz l ma mb">function Student(score) {<br/>    this.score = score;<br/>    this.setScore = function() {};<br/>}</span><span id="2f56" class="lw lx in ls b gy mc lz l ma mb">// The prototype of the child class is used as an instance object of the parent class to achieve the inheritance relationship<br/>Student.prototype = new Person();<br/>// The prototype will be overridden and the newly defined methods need to be placed after the prototype replacement.<br/>Student.prototype.sayName = function() {};</span><span id="3903" class="lw lx in ls b gy mc lz l ma mb">var student1 = new Student(1000);<br/>var student2 = new Student(2500);</span><span id="cdbd" class="lw lx in ls b gy mc lz l ma mb">student1.children.push(3);</span><span id="6e6a" class="lw lx in ls b gy mc lz l ma mb">console.log(student1);<br/>console.log(student2);<br/>console.log(student1.children); // [1, 2, 3]<br/>console.log(student2.children); // [1, 2, 3]<br/>console.log(student1.__proto__ === student2.__proto__); // true point to Student<br/>console.log(student1.__proto__. __proto__ === student2.__proto__. __proto__); // true points to Person</span></pre><p id="2261" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">构造函数继承</strong></p><p id="f3f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">父构造函数通过<code class="fe md me mf ls b">call()</code>从子类型构造函数中调用。</p><p id="4882" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点</strong></p><ul class=""><li id="64d0" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">解决了原型链继承中子类实例共享父引用属性的问题。</li><li id="579b" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">允许单个子类从多个父类继承。</li><li id="f758" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">子类实例可以动态地传递参数给父类。</li></ul><p id="f3a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点</strong></p><ul class=""><li id="39a8" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">函数复用性差，每个子类都创建父实例函数的副本，影响性能。</li><li id="3789" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">实例只是子类的实例，而不是父类的实例。</li><li id="65be" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">子类只能继承父类的实例属性和方法，不能继承原型上的属性和方法。</li></ul><p id="6958" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">示例</strong></p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="bbc0" class="lw lx in ls b gy ly lz l ma mb">function Person(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>    this.children = [1, 2];<br/>    this.setName = function() {};<br/>}</span><span id="fa2d" class="lw lx in ls b gy mc lz l ma mb">Person.prototype.addChild = function() {};</span><span id="875c" class="lw lx in ls b gy mc lz l ma mb">function Student(name, age, score) {<br/>    Person.call(this, name, age);<br/>    this.score = score;<br/>    this.setScore = function() {};<br/>}</span><span id="c881" class="lw lx in ls b gy mc lz l ma mb">var student1 = new Student('Jhon', 26, 1000);<br/>console.log(student1);<br/>console.log(student1.addChild); // undefined<br/>console.log(student1.__proto__); // Student<br/>console.log(student1.__proto__. __proto__); // Object</span><span id="1289" class="lw lx in ls b gy mc lz l ma mb">function Student(name, age, score) {<br/>    Person.call(this, name, age);<br/>    this.score = score;<br/>    this.setScore = function() {};<br/>}</span><span id="c298" class="lw lx in ls b gy mc lz l ma mb">var student1 = new Student('Jhon', 26, 1000);<br/>console.log(student1);<br/>console.log(student1.addChild); // undefined<br/>console.log(student1.__proto__); // Student<br/>console.log(student1.__proto__. __proto__); // Object</span></pre><p id="9f6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">组合遗传(原型链+构造函数组合遗传)</strong></p><p id="f138" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">组合继承是使用原型链继承原型属性和方法，使用构造函数继承实例属性。</p><p id="0dfb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点</strong></p><ul class=""><li id="d5f8" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">子类型不能动态地将参数传递给超类型。</li><li id="9f64" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">超类型构造函数将被调用两次。</li></ul><p id="0ede" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例子</strong></p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="de84" class="lw lx in ls b gy ly lz l ma mb">function Parent(username, password) {<br/>    this.password = password<br/>    this.username = username<br/>}</span><span id="5b09" class="lw lx in ls b gy mc lz l ma mb">Parent.prototype = {<br/>    login() {<br/>        console.log(`login as , ${this.username}, password is ${this.password}. `)<br/>    }<br/>}</span><span id="12c2" class="lw lx in ls b gy mc lz l ma mb">function Child(username, password) {<br/>    Parent.call(this, username, password) // second call<br/>    this.articles = 30<br/>}<br/>Child.prototype = new Parent() // first call<br/>// Child.prototype = Object.create(Parent.prototype) // This approach avoids the problems with the current inheritance approach</span><span id="feae" class="lw lx in ls b gy mc lz l ma mb">const user = new Child('jweboy', 'jl0630')<br/>// user.login()<br/>// console.log(user.articles)</span></pre><p id="6a15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">原型继承</strong></p><p id="542a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原型继承意味着创建一个临时构造函数，然后使用传入对象作为该构造函数的原型，最后返回临时类型的新实例。<code class="fe md me mf ls b">ECMAScript5</code>增加了<code class="fe md me mf ls b">Object.create</code>方法来标准化原型类型继承。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="fd87" class="lw lx in ls b gy ly lz l ma mb">// The following method is also a concrete implementation of Object.create<br/>function object(obj) {<br/>    function F() {}<br/>    F.prototype = obj;<br/>    return new F();<br/>}</span></pre><p id="7a7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">寄生遗传</strong></p><p id="325c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">寄生继承是创建一个只用于封装继承过程的函数，它以某种方式在内部增强对象并最终返回该对象。</p><p id="96ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点</strong></p><ul class=""><li id="7752" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">类似于构造函数，函数很难重用。</li></ul><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="78a9" class="lw lx in ls b gy ly lz l ma mb">function createObject(obj) {<br/>    const clone = Object.create(obj); // create a new object<br/>    clone.run = function() { // some way to enhance the object<br/>        return this.name;<br/>    };<br/>    return clone; // return the object<br/>}<br/>const obj = createObject({ name: 'tao' });<br/>// obj.run(); // 'tao'<br/>// console.dir(obj);</span></pre><p id="0f13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">寄生组合遗传</strong></p><p id="b7d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">寄生组合继承是通过构造函数继承属性，通过原型链继承方法。</p><p id="8cd2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优势</strong></p><ul class=""><li id="264f" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">子类型可以动态地将参数传递给超类型。</li><li id="4947" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">超类型的构造函数只执行一次。</li><li id="ca39" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">子类型属性是在它们自己的原型链中创建的，子类型之间不共享属性。</li></ul><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="7e6a" class="lw lx in ls b gy ly lz l ma mb">function inheritPrototype(child, parent) {<br/>    // Create a copy of the supertype prototype<br/>    const prototype = Object.create(parent.prototype)<br/>    // Override the missing constructor property for the created copy<br/>    prototype.constructor = child<br/>    // the created copy is assigned to the prototype of the subtype<br/>    child.prototype = prototype<br/>child.prototype = prototype }</span><span id="442c" class="lw lx in ls b gy mc lz l ma mb">function Parent(username, password) {<br/>    this.password = password<br/>    this.username = username<br/>}</span><span id="d296" class="lw lx in ls b gy mc lz l ma mb">Parent.prototype.login = function() {<br/>    console.log(`login as , ${this.username}, password is ${this.password}. `)<br/>}</span><span id="f784" class="lw lx in ls b gy mc lz l ma mb">function Child(username, password) {<br/>    Parent.call(this, username, password) // property inheritance<br/>    this.articles = 30<br/>}</span><span id="ea45" class="lw lx in ls b gy mc lz l ma mb">// Inheritance<br/>inheritPrototype(Child, Parent)</span><span id="6027" class="lw lx in ls b gy mc lz l ma mb">Child.prototype.read = function() {<br/>    console.log('read article at', this.articles)<br/>}</span><span id="d888" class="lw lx in ls b gy mc lz l ma mb">const user = new Child('jweboy', 'jl0630')<br/>// console.dir(user)</span></pre><p id="515b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">参考资源</strong></p><ul class=""><li id="c47a" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated"><a class="ae jz" href="https://juejin.im/post/5a96d78ef265da4e9311b4d8?utm_medium=fe&amp;utm_source=weixinqun#heading-7" rel="noopener ugc nofollow" target="_blank"> <em class="ky">深入探讨JavaScript继承的原理</em> </a></li><li id="8df8" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated"><a class="ae jz" href="https://segmentfault.com/a/1190000002440502#articleHeader10" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> JavaScript继承方法讲解</em> </a></li></ul><p id="eed8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">说白了就是</em> </strong> </a> <em class="ky">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">免费每周简讯</em> </strong> </a> <em class="ky">。关注我们</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">Twitter</em></strong></a><em class="ky">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">LinkedIn</em></strong></a><em class="ky">。查看我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">社区不和谐</em> </strong> </a> <em class="ky">加入我们的</em> <a class="ae jz" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">人才集体</em> </strong> </a> <em class="ky">。</em></p></div></div>    
</body>
</html>