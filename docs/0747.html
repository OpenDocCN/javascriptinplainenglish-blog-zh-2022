<html>
<head>
<title>Populating Next Right Pointers in Binary Tree with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript填充二叉树中的右下指针</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/populating-next-right-pointers-in-binary-tree-e22538ce9939?source=collection_archive---------17-----------------------#2022-02-10">https://javascript.plainenglish.io/populating-next-right-pointers-in-binary-tree-e22538ce9939?source=collection_archive---------17-----------------------#2022-02-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="237b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Leetcode问题的简单解法。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e87dbf6479ce958c83387f566eab774b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9AQVCHy7rbS27fumCniWg.jpeg"/></div></div></figure><p id="c852" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就在最近，我终于转到真正享受Leetcode问题。当然，我仍在不断完善我的技能，我想分享一个最近的解决方案。</p><p id="2c37" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个中级的<a class="ae lk" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" rel="noopener ugc nofollow" target="_blank">问题</a>,要求完美二叉树的每个节点上的“下一个”属性指向右边的节点，如果右边没有节点，该属性保持为空。</p><p id="f7dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">坦白地说，这是一个幼稚的解决方案，而且绝不是高性能的，但是对我来说，在进入更复杂的重构和方法之前看到这样的解决方案通常会有所帮助。</p><p id="79fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们开始使用的构造函数:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="f198" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">思考方法:</p><p id="7501" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">考虑如何在树中移动，以便轻松访问同一层的下一个节点，这让人想起了使用队列的广度优先遍历。这样，当我们在队列中移动时，如果手边的节点符合我们的标准，那么它的“下一个”指针可以很容易地指向队列中的下一个节点。</p><p id="7ca5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是这些标准是什么呢？为了决定是否应该指向队列中的下一个值，我们真正需要知道什么？…</p><p id="a4a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">……当前节点<em class="ln">是当前级别的最后一个节点吗？</em></p><p id="2a47" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果是，那么指针(默认情况下)将保持为空，我们可以继续。在所有其他情况下，我们可以将“next”分配给队列中的下一个。</p><p id="8605" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，通过在我们访问过的每个节点上增加一个计数器，我们可以评估它，并确定我们当前是否在一个级别的末尾。每个级别的开始(就我们的计数器而言)将是2的幂。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="8aa5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">给定我们当前的计数，这个助手会给我们2的下一次幂，或者更确切地说是下一关开始的计数。所以，为了确定我们现在的节点是否在一层的末端-</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="0789" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，对于每个被访问的节点，我们可以很容易地确定它的下一个指针是保持为空，还是指向队列中的下一个。</p><p id="ea7b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是主要功能:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="2580" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样，虽然Leetcode接受了这一点，但它还远远没有优化。但是作为第一个想到的方法，它是有效和简单的。</p><p id="87e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ln">更多内容请看</em><a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ln">plain English . io</em></strong></a><em class="ln">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ln">免费周报</em> </strong> </a> <em class="ln">。关注我们关于</em><a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ln">Twitter</em></strong></a><em class="ln">和</em><a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ln">LinkedIn</em></strong></a><em class="ln">。加入我们的</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ln">社区不和谐</em> </strong> </a> <em class="ln">。</em></p></div></div>    
</body>
</html>