<html>
<head>
<title>A Better Way to Build APIs with NextJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NextJS构建API的更好方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-better-way-to-build-apis-with-nextjs-f50f6e4bd084?source=collection_archive---------6-----------------------#2022-12-27">https://javascript.plainenglish.io/a-better-way-to-build-apis-with-nextjs-f50f6e4bd084?source=collection_archive---------6-----------------------#2022-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/13c6b91b23b0c84a5ebf631d4c133ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l7Gc578fnjaZjV4i"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">luis gomes</figcaption></figure><p id="4824" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上个月，我受命为一家新闻出版物开发一款全栈应用，我决定利用这个机会学习NextJS。我不得不说——它真的很棒。这很容易上手，我对最终的结果非常满意。</p><p id="e118" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">也就是说，在开发过程中，我不得不做出相当多困难的设计决策。NextJS在如何组织服务器端代码方面提供了很大的灵活性。灵活性带来自由，但自由也带来责任。</p><p id="a556" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为我的应用程序设计一个可伸缩的后端需要在各种需求之间进行折衷:</p><ol class=""><li id="9a6c" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><strong class="kb io">无服务器</strong>。与我过去构建的大多数后端不同，我不能只保持一个数据库连接。相反，无服务器函数需要为每个请求打开一个新的连接，无论是对API的请求还是对页面的请求。</li><li id="b0d8" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><strong class="kb io">认证</strong>。我想使用JWT对每个请求的用户进行身份验证，如果用户未经授权，根据页面返回401。</li><li id="63ad" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><strong class="kb io">简单明了的错误处理</strong>。为用户可能犯的每个错误手动调用<code class="fe ll lm ln lo b">res.status(4xx).json({ error: "etc" })</code>是很烦人的。我能找到一个允许我写类似于<code class="fe ll lm ln lo b">throw new UnauthorizedError()</code> ( <a class="ae lp" href="https://medium.com/better-programming/stop-using-express-js-to-make-web-servers-faed1942eaf3" rel="noopener">有点像NestJS </a>)的解决方案吗？</li><li id="36c2" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><strong class="kb io">干码</strong>。代码重复告诉我，我没有用正确的方式看待问题。在客户机和服务器之间共享代码的能力是选择NextJS的一个主要因素。作为TypeScript的忠实信徒，共享类型定义也是如此。</li></ol><p id="f06a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">经过大量的重构和修补，我找到了一个优雅的解决方案，成功地解决了所有这些需求。</p><h1 id="3ddc" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">连接到数据库</h1><p id="c897" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">我首先编写了一个简单的函数，它连接到我的数据库，初始化模型，并返回连接供以后使用。</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="651b" class="nb lr in lo b be nc nd l ne nf">async function connectToDB() {<br/>  const conn = await mongoose.createConnection(DATABASE_URL as string);<br/>  conn.model("Article", ArticleSchema);<br/>  conn.model("Sub", SubSchema);<br/>  conn.model("User", UserSchema);<br/>  return conn;<br/>}</span></pre><p id="9a4c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简单到目前为止。不幸的是，我在这里定义的模型立即失去了它们的类型。也就是说，如果我尝试使用其中一个模型，像这样:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="2b85" class="nb lr in lo b be nc nd l ne nf">conn.models.Article.findOneById(id);</span></pre><p id="b04e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">返回类型将是<code class="fe ll lm ln lo b">any</code>。对类型安全没有好处。</p><p id="3d29" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了解决这个问题，我为我的数据库创建了一个类型:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="d9cb" class="nb lr in lo b be nc nd l ne nf">export type MyDB = mongoose.Connection &amp; {<br/>  models: {<br/>    User: Model&lt;IUser&gt;;<br/>    Article: Model&lt;IArticle&gt;;<br/>    Sub: Model&lt;ISub&gt;;<br/>  };<br/>};</span></pre><p id="1c9b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">并返回<code class="fe ll lm ln lo b">conn</code>作为<code class="fe ll lm ln lo b">MyDB</code>:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="e266" class="nb lr in lo b be nc nd l ne nf">async function connectToDB() {<br/>  const conn = await mongoose.createConnection(DATABASE_URL as string);<br/>  conn.model("Article", ArticleSchema);<br/>  conn.model("Sub", SubSchema);<br/>  conn.model("User", UserSchema);<br/>  return conn as MyDB;<br/>}</span></pre><p id="a1c1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们现在可以打开到数据库的连接。但是有一个问题——如上所述，在无服务器应用程序中打开和重用单个数据库连接是不可行的，因为代码只是一个大型函数，一旦函数调用完成，它就会丢失任何状态。</p><p id="49a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">相反，每次我们想要查询数据库时，我们都需要打开一个新的连接，并在完成后关闭它。为此，我编写了一个包装函数，它接受一个回调函数，数据库<code class="fe ll lm ln lo b">conn</code>被传递给这个函数，如下所示:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="7c3c" class="nb lr in lo b be nc nd l ne nf">export async function withDB&lt;K&gt;(<br/>  callback: (conn: MyDB) =&gt; Promise&lt;K&gt;;<br/>): Promise&lt;K&gt; {<br/>  const conn = await connectToDB();<br/>  const result = await callback(conn);<br/>  conn.close();<br/>  return result as K;<br/>}</span></pre><p id="da7e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我现在已经完全隐藏了连接和断开数据库的逻辑。我只要打电话给<code class="fe ll lm ln lo b">withDB()</code>。</p><h1 id="14ba" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">请求处理程序</h1><p id="1fc2" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">让我们假设一个用户向<code class="fe ll lm ln lo b">/users</code>发出帖子请求注册。我们需要一些代码来处理这个请求，称为<strong class="kb io">处理程序</strong>。NextJS为我们提供了一个创建处理程序的基本API，但是在摆弄了几分钟之后，我意识到我可以设计出更加健壮的东西。</p><h2 id="a193" class="ng lr in bd ls nh ni dn lw nj nk dp ma kk nl nm me ko nn no mi ks np nq mm nr bi translated">什么是真正的处理程序？</h2><p id="b4ea" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">开箱即用，NextJS让您负责根据请求的HTTP方法选择要调用的服务器代码。我的第一个目标是将这种无趣和重复的行为抽象掉。</p><p id="9c3e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，我们将改变处理程序的概念。让我们把处理特定路径请求的函数想象成处理特定HTTP方法对特定路径的请求<strong class="kb io">的函数。这样，我们可以定义完全独立的函数来处理对<code class="fe ll lm ln lo b">/users</code>的POST请求，并将请求发送到相同的路径。</strong></p><p id="963c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，处理程序接受一些参数——<code class="fe ll lm ln lo b">req</code>对象读取查询参数或请求体；<code class="fe ll lm ln lo b">res</code>对象，比如说，需要写头；<code class="fe ll lm ln lo b">conn</code>对象，以便处理程序可以轻松地访问数据库；以及发出请求的用户的<code class="fe ll lm ln lo b">userId</code>，以防处理程序需要知道是谁发出的请求。</p><p id="eb63" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，处理程序不应该负责实际上<em class="ns">发送</em>一个响应，而只是确定<em class="ns">响应应该是什么</em>。无论函数返回什么值，最终都会在响应中以JSON的形式发送回来。</p><p id="e90b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这为方法处理程序产生了以下类型定义:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="c7c0" class="nb lr in lo b be nc nd l ne nf">export type MethodHandler&lt;BODY, RESPONSE&gt; = (params: {<br/>  req: Omit&lt;NextApiRequest, "body"&gt; &amp; { body: BODY };<br/>  res: NextApiResponse;<br/>  conn: MyDB;<br/>  userId: string | undefined;<br/>}) =&gt; Promise&lt;RESPONSE&gt;;</span></pre><h2 id="1e97" class="ng lr in bd ls nh ni dn lw nj nk dp ma kk nl nm me ko nn no mi ks np nq mm nr bi translated">处理各种方法</h2><p id="9ce6" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">记住一个<code class="fe ll lm ln lo b">MethodHandler</code>是针对一个特定的HTTP方法的，但是下一个API routes希望您导出一个函数，这个函数可以处理该路径上的每一个 HTTP方法。</p><p id="ffcf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们创建一个函数，它将HTTP方法映射到它们各自的方法处理程序，并返回另一个函数，该函数接受对特定路径的请求，并根据请求的方法调用相应的处理程序。</p><p id="8fb8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，我们将为这样的地图定义一种类型:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="a0d2" class="nb lr in lo b be nc nd l ne nf">export type Methods = "get" | "post" | "put" | "patch" | "delete";<br/><br/>export type MethodHandlers = {<br/>  [key in Methods]?: MethodHandler&lt;any, any&gt;;<br/>};</span></pre><p id="45cc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们创建一个函数，该函数选择适当的方法处理程序，通过数据库连接执行它，并用处理程序返回的任何对象进行响应:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="d5e6" class="nb lr in lo b be nc nd l ne nf">export default function createHandler(methodHandlers: MethodHandlers) {<br/>  return async (req: NextApiRequest, res: NextApiResponse&lt;any&gt;) =&gt; {<br/>    const response = await withDB((conn) =&gt; {<br/>      const handler =<br/>        methodHandlers[(req.method?.toLowerCase() as Methods) ?? "get"];<br/>      if (handler) {<br/>        const userId = getUserIdFromReq(req);<br/>        return handler({ req, res, conn, userId });<br/>      }<br/>    });<br/>    const statusCode = req.method === "GET" ? 200 : 201;<br/>    res.status(statusCode);<br/>    res.json(response);<br/>  };<br/>}</span></pre><h2 id="aa70" class="ng lr in bd ls nh ni dn lw nj nk dp ma kk nl nm me ko nn no mi ks np nq mm nr bi translated">处理错误</h2><p id="f1cf" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">对于每个API请求，都有各种错误的无数可能性。我没有去记忆状态代码、错误响应格式，也没有去创建一个早期返回的复杂网络，我决定一个更好的设计是简单地扩展Javascript的<code class="fe ll lm ln lo b">Error</code>类。</p><p id="b98f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，我定义了一些常见的错误类型:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="fff5" class="nb lr in lo b be nc nd l ne nf">export class NotFoundError extends Error {<br/>  constructor(message?: string) {<br/>    super(message);<br/>    this.name = "NotFoundError";<br/>  }<br/>}<br/><br/>export class UnauthorizedError extends Error {<br/>  ...<br/>}</span></pre><p id="be7f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，我创建了一个从错误类别到状态代码的映射:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="9e42" class="nb lr in lo b be nc nd l ne nf">const errorStatusCodes = {<br/>  ValidationError: 400,<br/>  NotFoundError: 404,<br/>  UnauthorizedError: 401,<br/>  MethodNotAllowedError: 405,<br/>  ConflictError: 409,<br/>};</span></pre><p id="9ddc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我定义了一个助手函数，它接受一个<code class="fe ll lm ln lo b">res</code>对象和任何错误，并适当地处理它:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="3fe7" class="nb lr in lo b be nc nd l ne nf">export function handleError(error: Error, res: NextApiResponse) {<br/>  if (Object.hasOwn(errorStatusCodes, error.name)) {<br/>    res<br/>      .status(errorStatusCodes[error.name as keyof typeof errorStatusCodes])<br/>      .json({ name: error.name, message: error.message });<br/>  } else {<br/>    console.error(error);<br/>    res<br/>      .status(500)<br/>      .json({ name: "ServerError", message: "Internal server error" });<br/>  }<br/>}</span></pre><p id="c7e8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，我在上面定义的<code class="fe ll lm ln lo b">createHandler()</code>函数中使用了一个<code class="fe ll lm ln lo b">try/catch</code>,将它们组合在一起:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="39ea" class="nb lr in lo b be nc nd l ne nf">export default function createHandler(methodHandlers: MethodHandlers) {<br/>  return async (req: NextApiRequest, res: NextApiResponse&lt;any&gt;) =&gt; {<br/>    try {<br/>      const response = await withDB((conn) =&gt; {<br/>        const handler =<br/>          methodHandlers[(req.method?.toLowerCase() as Methods) ?? "get"];<br/>        if (handler) {<br/>          const userId = getUserIdFromReq(req);<br/>          return handler({ req, res, conn, userId });<br/>        } else {<br/>          throw new MethodNotAllowedError("Method not allowed");<br/>        }<br/>      });<br/>      const statusCode = req.method === "GET" ? 200 : 201;<br/>      res.status(statusCode);<br/>      res.json(response ?? {});<br/>    } catch (e) {<br/>      handleError(e as Error, res);<br/>    }<br/>  };<br/>}</span></pre><h1 id="ff5e" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">创建我们的第一个处理程序</h1><p id="ff11" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">完成这些抽象之后，就该为创建用户定义一个处理程序了:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="a199" class="nb lr in lo b be nc nd l ne nf">type CreateUserRequest = {<br/>  name: string;<br/>  email: string;<br/>  password: string;<br/>};<br/>type CreateUserResponse = IUser;<br/><br/>const createUserHandler: MethodHandler&lt;<br/>  CreateUserRequest,<br/>  CreateUserResponse<br/>&gt; = async ({ req, conn, userId }) =&gt; {<br/>  const { name, email, password } = req.body;<br/>  const hashedPassword = await hashPassword(password);<br/>  try {<br/>    const newUser = await conn.models.User.create({<br/>      name: name,<br/>      email: email,<br/>      password: hashedPassword,<br/>    });<br/>    return newUser;<br/>  } catch (e) {<br/>    throw new ConflictError("Name or email already in use");<br/>  }<br/>};</span></pre><p id="cc00" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了实际定义一个NextJS可以用来处理API请求的函数，我们必须将这个处理程序传递到<code class="fe ll lm ln lo b">createHandler()</code>中，并从<code class="fe ll lm ln lo b">pages/api</code>中的一个文件中导出它，如下所示:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="4a0a" class="nb lr in lo b be nc nd l ne nf">export default createHandler({<br/>  post: createUserHandler,<br/>});</span></pre><h1 id="065a" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">发出API请求</h1><p id="a610" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">我们已经有了一个抽象，它将NextJS的默认API打得落花流水。但是不要忘记最后的要求:在客户机和服务器之间共享逻辑和类型。</p><p id="c78b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请注意，<code class="fe ll lm ln lo b">MethodHandlers</code>对象也拥有我们创建一个能够<em class="ns">发送</em>请求的函数所需的几乎所有信息。它唯一缺少的是处理程序的路径；NextJS从文件在项目中的位置知道这一点，但是这个路径只能作为字符串提供。</p><p id="ea25" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们从定义一个可以发出请求的函数的类型开始:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="d7f9" class="nb lr in lo b be nc nd l ne nf">export type RequestMaker&lt;BODY, RESPONSE&gt; = (body: BODY) =&gt; Promise&lt;RESPONSE&gt;;</span></pre><p id="08df" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的目标是编写一个函数，它可以接受一个<code class="fe ll lm ln lo b">MethodHandlers</code>对象——与提供给<code class="fe ll lm ln lo b">createHandler()</code>的对象相同——并使用它来返回函数，然后这些函数可以用于<em class="ns">发出</em>请求。</p><p id="4bca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这要求我们<em class="ns">重新映射</em>对象<code class="fe ll lm ln lo b">MethodHandlers</code>。我们将接收一个从HTTP方法到它们的处理程序的映射，并返回一个从HTTP方法到它们对应的<code class="fe ll lm ln lo b">RequestMaker</code>函数的映射。我们可以用以下类型来表示这种重新映射:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="e26a" class="nb lr in lo b be nc nd l ne nf">export type RequestMakerReturn&lt;K extends MethodHandlers&gt; = {<br/>  [key in keyof K]: K[key] extends MethodHandler&lt;infer B, infer R&gt;<br/>    ? RequestMaker&lt;B, R&gt;<br/>    : never;<br/>};</span></pre><p id="3074" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你害怕这种类型，不要害怕！查看我在难度增加指南中的<a class="ae lp" href="https://medium.com/javascript-in-plain-english/the-fundamentals-of-typescript-in-increasing-levels-of-difficulty-c54bab69fbb9" rel="noopener">打字稿，了解这是如何工作的。</a></p><h2 id="64be" class="ng lr in bd ls nh ni dn lw nj nk dp ma kk nl nm me ko nn no mi ks np nq mm nr bi translated">编写函数</h2><p id="a538" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">我们终于准备好好玩的部分了。我们需要一个接受两件事的函数:</p><ol class=""><li id="9c76" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">请求者发出请求的路径</li><li id="4284" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">返回类型(<code class="fe ll lm ln lo b">RequestMakerReturn</code>)所基于的<code class="fe ll lm ln lo b">MethodHandlers</code>对象</li></ol><p id="339b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">并返回重新映射的类型(<code class="fe ll lm ln lo b">RequestMakerReturn</code>)。</p><p id="ecc6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于任何复杂的函数，从签名开始都是最简单的:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="2b87" class="nb lr in lo b be nc nd l ne nf">export default function createRequestMakers&lt;K extends MethodHandlers&gt;(<br/>  path: string,<br/>  requestMakerData: K<br/>): RequestMakerReturn&lt;K&gt; {<br/>  ...<br/>}</span></pre><p id="9cb5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了重新映射一个对象，我们将它分解成一个条目数组(键/值对)，映射<em class="ns">到</em>数组，并从新的条目重新构建它。这是此类操作的模板:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="6f8b" class="nb lr in lo b be nc nd l ne nf">export default function createRequestMakers&lt;K extends MethodHandlers&gt;(<br/>  path: string,<br/>  requestMakerData: K<br/>): RequestMakerReturn&lt;K&gt; {<br/>  return Object.fromEntries(<br/>    Object.entries(requestMakerData).map(([method]) =&gt; {<br/>      const requestMaker = ...<br/>      return [method, requestMaker];<br/>    })<br/>  ) as RequestMakerReturn&lt;K&gt;; <br/>}</span></pre><p id="e220" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，我们需要做的就是定义一个请求生成器函数，根据请求的方法和路径发送请求，就像这样:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="5c67" class="nb lr in lo b be nc nd l ne nf">export default function createRequestMakers&lt;K extends MethodHandlers&gt;(<br/>  path: string,<br/>  requestMakerData: K<br/>) {<br/>  return Object.fromEntries(<br/>    Object.entries(requestMakerData).map(([method]) =&gt; {<br/>      const requestMaker = async (body: any) =&gt; {<br/>        const res = await axios(path, {<br/>          method,<br/>          headers: {<br/>            "Content-Type": "application/json",<br/>          },<br/>          data: {<br/>            ...body,<br/>          },<br/>        });<br/>        return res.data;<br/>      };<br/>      return [method, requestMaker];<br/>    })<br/>  ) as RequestMakerReturn&lt;K&gt;;<br/>}</span></pre><h2 id="3b24" class="ng lr in bd ls nh ni dn lw nj nk dp ma kk nl nm me ko nn no mi ks np nq mm nr bi translated">错误处理</h2><p id="da1f" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">剩下唯一要做的就是在客户端添加错误处理。我们可以重用为服务器定义的自定义错误类。</p><p id="2aa6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">任何非OK ( <code class="fe ll lm ln lo b">&gt;200</code>)响应都会导致Axios抛出一个<code class="fe ll lm ln lo b">AxiosError</code>。我们的服务器端错误处理程序将类名和消息作为响应中的数据发送，我们可以提取这些数据并在客户端使用它们来重新抛出相同的错误对象:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="0e88" class="nb lr in lo b be nc nd l ne nf">export function propagateError(status: number, responseData: any) {<br/>  switch (status) {<br/>    case 400:<br/>      throw new ValidationError(responseData.message);<br/>    case 401:<br/>      throw new UnauthorizedError(responseData.message);<br/>    case 404:<br/>      throw new NotFoundError(responseData.message);<br/>    case 405:<br/>      throw new MethodNotAllowedError(responseData.message);<br/>    case 409:<br/>      throw new ConflictError(responseData.message);<br/>    default:<br/>      throw new Error(responseData.message);<br/>  }<br/>}</span></pre><p id="a951" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，将这个整合到<code class="fe ll lm ln lo b">createRequestMakers</code>中就像<code class="fe ll lm ln lo b">try/catch</code>一样简单:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="17ce" class="nb lr in lo b be nc nd l ne nf">export default function createRequestMakers&lt;K extends MethodHandlers&gt;(<br/>  path: string,<br/>  requestMakerData: K<br/>) {<br/>  return Object.fromEntries(<br/>    Object.entries(requestMakerData).map(([method]) =&gt; {<br/>      const requestMaker = async (body: any) =&gt; {<br/>        try {<br/>          const res = await axios(path, {<br/>            method,<br/>            headers: {<br/>              "Content-Type": "application/json",<br/>            },<br/>            data: {<br/>              ...body,<br/>            },<br/>          });<br/>          return res.data;<br/>        } catch (e) {<br/>          if (e instanceof AxiosError) {<br/>            propagateError(e.status ?? 500, e.response?.data);<br/>          }<br/>        }<br/>      };<br/>      return [method, requestMaker];<br/>    })<br/>  ) as RequestMakerReturn&lt;K&gt;;<br/>}</span></pre><h1 id="805b" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">把所有的放在一起</h1><p id="3e0f" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">让我们回到我们在<code class="fe ll lm ln lo b">/pages/api</code>中的文件，在这里我们定义了我们的<code class="fe ll lm ln lo b">MethodHandlers</code>对象并导出了NextJS的请求处理程序。</p><p id="0ded" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们现在可以将同一个对象传递给<code class="fe ll lm ln lo b">createRequestMakers()</code>来获得发送请求的函数:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="142e" class="nb lr in lo b be nc nd l ne nf">const methodHandlers = {<br/>  post: createUserHandler,<br/>};<br/><br/>export default createHandler(methodHandlers);<br/><br/>export const { post } = createRequestMakers(<br/>  "/users",<br/>  methodHandlers<br/>);</span></pre><p id="163d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可能希望用更具描述性的名称导出您的请求生成器函数，而不仅仅是“post”。我是这样做的:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="b2cb" class="nb lr in lo b be nc nd l ne nf">export const { post: makeCreateUserRequest } = createRequestMakers(<br/>  "/users/createUser",<br/>  methodHandlers<br/>);</span></pre><p id="dd9b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，从任何React组件，您都可以像这样创建一个用户:</p><pre class="mt mu mv mw gt mx lo my bn mz na bi"><span id="6f44" class="nb lr in lo b be nc nd l ne nf">const user = await makeCreateUserRequest({<br/>  name: "test-username",<br/>  email: "test@email.com",<br/>  password: "testpassword",<br/>});</span></pre><p id="7d27" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">清晰的界面，优雅一致的错误处理，以及客户机和服务器之间共享的类型定义。使用这种设计，很难编写有错误的代码，所有平凡的、重复的逻辑都被抽象掉了。软件开发人员还想要什么？</p><h2 id="30da" class="ng lr in bd ls nh ni dn lw nj nk dp ma kk nl nm me ko nn no mi ks np nq mm nr bi translated">更多内容请访问<a class="ae lp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> PlainEnglish.io </a>。</h2><p id="3aa9" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated"><em class="ns">报名参加我们的</em> <a class="ae lp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ns">免费周报</em> </strong> </a> <em class="ns">。关注我们上</em> <a class="ae lp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ns">推特</em> </strong> </a>，<a class="ae lp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ns">领英</em> </strong> </a> <strong class="kb io"> <em class="ns">，</em></strong><a class="ae lp" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ns">YouTube</em></strong></a><strong class="kb io"><em class="ns">，以及</em></strong><em class="ns"/><a class="ae lp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ns">不和</em> </strong> </a>T47】</p><h2 id="a759" class="ng lr in bd ls nh ni dn lw nj nk dp ma kk nl nm me ko nn no mi ks np nq mm nr bi translated">希望扩大你的科技创业公司的知名度和采用率吗？检查<a class="ae lp" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank">电路</a>。</h2></div></div>    
</body>
</html>