<html>
<head>
<title>How to Use Async/Await in the React useEffect() Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React useEffect()挂钩中使用Async/Await</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-useeffect-async-await-478d0ca81330?source=collection_archive---------3-----------------------#2022-08-23">https://javascript.plainenglish.io/react-useeffect-async-await-478d0ca81330?source=collection_archive---------3-----------------------#2022-08-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7c77" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解如何在React useEffect()钩子中的异步函数上轻松使用await操作符。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ad382bdeef0f9ca53e9b18153d54ac9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*heyxQOTB430wP7HJiaboPw.png"/></div></div></figure><p id="b5e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于React <code class="fe lk ll lm ln b">useEffect()</code>钩子中的<code class="fe lk ll lm ln b">await</code>函数，将<code class="fe lk ll lm ln b">async</code>函数包装在一个立即调用的函数表达式(IIFE)中。</p><p id="1a97" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="7ac9" class="ls lt in ln b gy lu lv l lw lx">const [books, setBooks] = useState([]);</span><span id="acf6" class="ls lt in ln b gy ly lv l lw lx">useEffect(() =&gt; {<br/>  (async () =&gt; {<br/>    try {<br/>      // await async "fetchBooks()" function<br/>      const books = await fetchBooks();<br/>      setBooks(books);<br/>    } catch (err) {<br/>      console.log('Error occured when fetching books');<br/>    }<br/>  })();<br/>}, []);</span></pre><p id="9dcc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们将看看在<code class="fe lk ll lm ln b">useEffect()</code>钩子中调用<code class="fe lk ll lm ln b">async</code>函数的不同方法，以及在使用<code class="fe lk ll lm ln b">async</code> / <code class="fe lk ll lm ln b">await</code>时要避免的陷阱。</p><h1 id="aa8a" class="lz lt in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">使用useEffect()中的then/catch调用异步函数</h1><p id="b5bf" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated"><code class="fe lk ll lm ln b">async</code>函数在JavaScript中执行异步操作。为了在React useEffect()钩子中等待<code class="fe lk ll lm ln b">Promise</code><code class="fe lk ll lm ln b">async</code>函数返回被解决(完成或拒绝),我们可以使用它的<code class="fe lk ll lm ln b">then()</code>和<code class="fe lk ll lm ln b">catch()</code>方法:</p><p id="99e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的例子中，我们调用了<code class="fe lk ll lm ln b">fetchBooks()</code>异步方法来获取和显示样本阅读应用中存储的书籍:</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="9696" class="ls lt in ln b gy lu lv l lw lx">export default function App() {<br/>  const [books, setBooks] = useState([]);</span><span id="9d0e" class="ls lt in ln b gy ly lv l lw lx">  useEffect(() =&gt; {<br/>    // await async "fetchBooks()" function<br/>    fetchBooks()<br/>      .then((books) =&gt; {<br/>        setBooks(books);<br/>      })<br/>      .catch(() =&gt; {<br/>        console.log('Error occured when fetching books');<br/>      });<br/>  }, []);</span><span id="d517" class="ls lt in ln b gy ly lv l lw lx">  return (<br/>    &lt;div&gt;<br/>      {books.map((book) =&gt; (<br/>        &lt;div&gt;<br/>          &lt;h2&gt;{book.title}&lt;/h2&gt;<br/>        &lt;/div&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="d65b" class="lz lt in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">异步/等待问题:异步回调无法传递给useEffect()</h1><p id="9067" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">也许您更喜欢使用<code class="fe lk ll lm ln b">async/await</code>语法来代替<code class="fe lk ll lm ln b">then/catch</code>。您可以通过将回调传递给<code class="fe lk ll lm ln b">useEffect()</code> <code class="fe lk ll lm ln b">async</code>来尝试这样做。</p><p id="f99a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不是一个好主意，如果你使用的是棉绒，它会马上通知你。</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="b67b" class="ls lt in ln b gy lu lv l lw lx">// ❌ Your linter: don't do this!<br/>useEffect(async () =&gt; {<br/>  try {<br/>    const books = await fetchBooks();<br/>    setBooks(books);<br/>  } catch {<br/>    console.log('Error occured when fetching books');<br/>  }<br/>}, []);</span></pre><p id="6f8f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你的linter抱怨是因为<code class="fe lk ll lm ln b">useEffect()</code>的第一个参数应该是一个函数，要么不返回任何东西，要么返回一个函数来清除副作用。但是<code class="fe lk ll lm ln b">async</code>函数总是返回一个<code class="fe lk ll lm ln b">Promise</code>(隐式或显式)，并且<code class="fe lk ll lm ln b">Promise</code>对象不能作为函数调用。这可能会导致React应用程序出现真正的问题，比如内存泄漏。</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="c0a8" class="ls lt in ln b gy lu lv l lw lx">useEffect(async () =&gt; {<br/>  const observer = () =&gt; {<br/>    // do stuff<br/>  };</span><span id="5fc0" class="ls lt in ln b gy ly lv l lw lx">  await fetchData();</span><span id="48c9" class="ls lt in ln b gy ly lv l lw lx">  observable.subscribe(observer);</span><span id="4840" class="ls lt in ln b gy ly lv l lw lx">  // Memory leak!<br/>  return () =&gt; {<br/>    observable.unsubscribe(observer);<br/>  };<br/>}, []);</span></pre><p id="77ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个例子中，因为回调函数是<code class="fe lk ll lm ln b">async</code>，它实际上并不返回定义的清理函数，而是返回一个用清理函数解析的<code class="fe lk ll lm ln b">Promise</code>对象。因此，这个清除函数永远不会被调用，观察者永远不会从可观察对象中退订，从而导致内存泄漏。</p><p id="b959" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么我们该如何解决这个问题呢？如何在<code class="fe lk ll lm ln b">useEffect()</code>钩子中使用带有<code class="fe lk ll lm ln b">async</code>功能的<code class="fe lk ll lm ln b">await</code>操作符？</p><h1 id="8cae" class="lz lt in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">async/await解决方案1:在IIFE中调用异步函数</h1><p id="3c41" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">解决这个问题的一个直接方法是将<code class="fe lk ll lm ln b">async</code>函数中的<code class="fe lk ll lm ln b">await</code>函数<a class="ae mv" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">立即调用函数表达式</a>(life):</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="910f" class="ls lt in ln b gy lu lv l lw lx">const [books, setBooks] = useState([]);</span><span id="01e3" class="ls lt in ln b gy ly lv l lw lx">useEffect(() =&gt; {<br/>  (async () =&gt; {<br/>    try {<br/>      const books = await fetchBooks();<br/>      setBooks(books);<br/>    } catch (err) {<br/>      console.log('Error occured when fetching books');<br/>    }<br/>  })();<br/>}, []);</span></pre><p id="43e6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">顾名思义，生命是一个一旦被定义就运行的函数。它们用于避免污染全局命名空间，以及在尝试一个<code class="fe lk ll lm ln b">await</code>调用可能导致包含生命的作用域出现问题的场景中(例如在<code class="fe lk ll lm ln b">useEffect()</code>钩子中)。</p><h1 id="4149" class="lz lt in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">异步/等待解决方案2:在命名函数中调用异步函数</h1><p id="e363" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">或者，您可以在一个命名函数中<code class="fe lk ll lm ln b">await</code>这个<code class="fe lk ll lm ln b">async</code>函数:</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="0a1b" class="ls lt in ln b gy lu lv l lw lx">useEffect(() =&gt; {</span><span id="308c" class="ls lt in ln b gy ly lv l lw lx">  // Named function "getBooks"<br/>  async function getBooks() {<br/>    try {<br/>      const books = await fetchBooks();<br/>      setBooks(books);<br/>    } catch (err) {<br/>      console.log('Error occured when fetching books');<br/>    }<br/>  }</span><span id="a653" class="ls lt in ln b gy ly lv l lw lx">  // Call named function<br/>  getBooks();<br/>}, []);</span></pre><p id="993e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还记得使用可观察模式的例子吗？下面是我们如何使用一个命名的<code class="fe lk ll lm ln b">async</code>函数来防止发生的内存泄漏:</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="b7ee" class="ls lt in ln b gy lu lv l lw lx">// ✅ callback is not async<br/>useEffect(() =&gt; {<br/>  const observer = () =&gt; {<br/>    // do stuff<br/>  };</span><span id="00eb" class="ls lt in ln b gy ly lv l lw lx">  // Named function "fetchDataAndSubscribe"<br/>  async function fetchDataAndSubscribe() {<br/>    await fetchData();<br/>    observable.subscribe(observer);<br/>  }</span><span id="8969" class="ls lt in ln b gy ly lv l lw lx">  fetchDataAndSubscribe();</span><span id="befa" class="ls lt in ln b gy ly lv l lw lx">  // ✅ No memory leak<br/>  return () =&gt; {<br/>    observable.unsubscribe(observer);<br/>  };<br/>}, []);</span></pre><h1 id="385d" class="lz lt in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">异步/等待解决方案3:创建自定义挂钩</h1><p id="ed10" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">我们还可以创建一个自定义钩子，它的行为类似于<code class="fe lk ll lm ln b">useEffect()</code>，并且可以接受<code class="fe lk ll lm ln b">async</code>回调而不会导致任何问题。</p><p id="0ba4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">自定义挂钩可以这样定义:</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="309d" class="ls lt in ln b gy lu lv l lw lx">export function useEffectAsync(effect, inputs) {<br/>  useEffect(() =&gt; {<br/>    return effect();<br/>  }, inputs);<br/>}</span></pre><p id="e9aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以从代码中的多个地方调用它，就像这样:</p><pre class="kd ke kf kg gt lo ln lp lq aw lr bi"><span id="9768" class="ls lt in ln b gy lu lv l lw lx">const [books, setBooks] = useState([]);</span><span id="632b" class="ls lt in ln b gy ly lv l lw lx">useEffectAsync(async () =&gt; {<br/>  try {<br/>    const books = await fetchBooks();<br/>    setBooks(books);<br/>  } catch (err) {<br/>    console.log('Error occured when fetching books');<br/>  }<br/>});</span></pre><p id="9d93" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了这三种方法，我们现在可以很容易地在<code class="fe lk ll lm ln b">useEffect()</code>钩子中使用带有<code class="fe lk ll lm ln b">async</code>函数的<code class="fe lk ll lm ln b">await</code>操作符。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="a7d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nd">最初发表于</em><a class="ae mv" href="https://cbdev.link/9c5c72" rel="noopener ugc nofollow" target="_blank"><em class="nd">codingbeautydev.com</em></a></p><h1 id="d24a" class="lz lt in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">ES13中11个惊人的新JavaScript特性</h1><p id="bfde" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">本指南将带您快速了解ECMAScript 13中添加的所有最新功能。这些强大的新特性将会用更短、更富于表现力的代码来更新您的JavaScript。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/75a56482761ab63cfc081ad691d70d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*WqVjQY7sKZh3wld5WzkfTw.png"/></div></figure><p id="b288" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">报名参加，马上就能得到一份免费的。</p></div></div>    
</body>
</html>