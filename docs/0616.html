<html>
<head>
<title>Express API with Secure JWT Access and Refresh Token</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有安全JWT访问和刷新令牌的Express API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/expressjs-api-with-secure-jwt-access-and-refresh-token-64c5478be2c0?source=collection_archive---------1-----------------------#2022-02-03">https://javascript.plainenglish.io/expressjs-api-with-secure-jwt-access-and-refresh-token-64c5478be2c0?source=collection_archive---------1-----------------------#2022-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="df4b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Express构建一个API，用JSON Web Token授权保护它。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9a908008c748204570a6500bad296e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyqMCIMc6_pcABs_xyVqtw.jpeg"/></div></div></figure><p id="e884" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>被认为是构建后端和API服务的最佳框架之一，在本教程中，我们将使用它来构建一个最小但完全工作的REST API服务，并通过JWT授权进行保护。</p><h2 id="ab53" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">先决条件</h2><p id="580e" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">要跟进，您至少需要:</p><ul class=""><li id="86ff" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">HTTP请求工程的基本知识</li><li id="85b2" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">JavaScript的基础知识</li><li id="5a65" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">认证和授权流程的基本知识</li><li id="6a7c" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">Node.js和节点包管理器的基础知识</li></ul><p id="0d0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你还需要安装的<a class="ae ln" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js和NPM，以及一个进行HTTP请求的工具:你可以使用cURL，你可以使用Visual Studio代码的REST客户端扩展(</a><a class="ae ln" href="https://github.com/Huachao/vscode-restclient" rel="noopener ugc nofollow" target="_blank">https://github.com/Huachao/vscode-restclient</a>)或者像<a class="ae ln" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>这样的在线工具。<br/>您还可以在以下位置克隆我们的存储库和整个项目:</p><div class="na nb gp gr nc nd"><a href="https://github.com/popeating/express-api" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">GitHub - popeating/express-api:带JWT教程的Express API</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kp nd"/></div></div></a></div><h2 id="58ac" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">我们将编码什么</h2><p id="0dd6" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们将构建一个REST API服务，允许客户端应用程序向它请求数据(在我们的例子中是一个图书列表)；我们将使用JWT保护端点，我们将编写一个API登录服务来获取令牌，我们还将实现一个刷新令牌工作流。</p><p id="3e5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">我们不会关注</strong>客户端开发(因为我们正在构建一个‘非个人化’的服务)，但是我们会提供我们服务的规范，这样任何人都可以为它构建一个客户端。</p><h2 id="ebc3" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">设置项目</h2><p id="7282" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">一旦你在你的系统上安装了Node.js和NPM，我们开始构建项目，创建一个文件夹:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="6947" class="lo lp iq nt b gy nx ny l nz oa">mkdir express-api</span></pre><p id="a8a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">进入文件夹并初始化项目:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="0424" class="lo lp iq nt b gy nx ny l nz oa">npm init -y</span></pre><p id="1a3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将创建一个<code class="fe ob oc od nt b">package.json</code>文件，我们将在几分钟后编辑该文件，但在我们安装所有需要的依赖项之前:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="0035" class="lo lp iq nt b gy nx ny l nz oa">npm -i express dotenv bcrypt jsonwebtoken<br/>npm -i nodemon --save-dev</span></pre><p id="b23d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在创建一个<code class="fe ob oc od nt b">.env</code>文件来存储稍后将用于生成令牌的密钥。请记住，这些密钥应该保密，应该非常随机/难以猜测，你可以使用64位十六进制字符串(你可以在这里创建它们<a class="ae ln" href="https://www.browserling.com/tools/random-hex" rel="noopener ugc nofollow" target="_blank">https://www.browserling.com/tools/random-hex</a>)，不要使用我提供的那个！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0cde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以修改<code class="fe ob oc od nt b">package.json</code>来编辑正在运行的脚本，我们将使用<code class="fe ob oc od nt b">node</code> <strong class="kt ir"> </strong>进行生产，使用<code class="fe ob oc od nt b">nodemom</code> <strong class="kt ir"> </strong>进行开发(它的作用类似于热重装，修改代码时不需要重启服务器)；按如下方式更改脚本部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="59d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这种方式，我们在开始脚本中指明我们的服务入口点是<code class="fe ob oc od nt b">server.js</code>，我们现在将用最少的功能创建它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="09cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用<code class="fe ob oc od nt b">npm test</code>启动开发服务器，它应该登录到控制台“监听端口3000”并等待请求:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/2013a2b41ab42a2bc3841943a522d36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrkk4BftF8iUu_CCUBoqwA.png"/></div></div></figure><p id="cf1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用您喜欢的工具请求<a class="ae ln" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>(在这种情况下，您也可以使用浏览器，因为我们正在执行一个简单的GET请求):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/d9770db90c6af418ed8441dad004fe31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXiyaQUq-0RCLCjV9ZQ2Uw.png"/></div></div></figure><h2 id="a17c" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">数据</h2><p id="3ee4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">因为我们保持最小化，所以我们不会为我们的数据使用任何数据库或对象存储，我们将简单地将数据保存在一个文件中，概念是相同的，即使您使用本地MongoDB或远程Firebase或动物群实例。我们从某个地方获取数据(在我们的例子中是一个文件),并根据请求以JSON格式呈现给用户。</p><p id="92f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在您的项目文件夹中创建一个<code class="fe ob oc od nt b">data</code>文件夹，并在其中保存两个文件<code class="fe ob oc od nt b">book.js</code>，我们在其中保存图书数据库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="ee2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以及<code class="fe ob oc od nt b">users.js</code>我们注册用户的存储位置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8e71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">密码是用<code class="fe ob oc od nt b"><strong class="kt ir">bcrypt</strong></code>加密的(简单来说就是<em class="oi">密码</em>)，通常，需要访问API的用户通过网站注册(或者在网站上获取他们的凭证)，所以我们不提供注册的端点(但是我提供了一个<em class="oi"> generatepassword </em>端点，这样你可以很容易地生成加密的密码)。</p><h2 id="ece8" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">授权工作流程</h2><p id="b9fb" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">如前所述，我们的一些端点不是公共的，因此我们需要一种方法来验证和授权用户。对于身份验证，我们提供一个登录端点；对于授权，受保护的端点需要一个需要验证的授权头，并随请求一起发送。工作流程的详细工作方式如下:</p><ul class=""><li id="8dcb" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">用户请求登录端点，发布用户名和密码</li><li id="06bd" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">服务器尝试对用户进行身份验证，如果用户有效，服务器会发回一个JWT (JSON Web令牌)和一个刷新令牌，刷新令牌也存储在服务器上的某个地方(在我们的例子中是一个变量，存储在Redis或生产环境中的某个其他存储上)</li><li id="3fd7" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">客户端取回令牌并存储它们(如何/在哪里存储它们是客户端的责任)</li><li id="156a" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">客户端请求一个受保护的端点，在报头中发送JWT</li><li id="ea1d" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">服务器接收JWT，对其进行验证，如果验证通过，则发回客户端请求的数据</li><li id="d1b1" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">一旦JWT过期或即将过期，客户端可以通过向特定端点发送刷新令牌来请求新的JWT，而无需重新登录。</li><li id="f185" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">服务器接收刷新令牌，对其进行验证，如果验证是肯定的，则发布新的JWT和刷新令牌，并将它们发送回客户端。</li></ul><p id="a937" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JWT和刷新令牌采用相同的格式，获得几乎相同的信息，但使用两个不同的密钥(我们在<code class="fe ob oc od nt b">.env</code> <strong class="kt ir"> </strong>中设置的)，并获得两个不同的过期时间:JWT的一个短过期时间(因为它是会话期间使用最多的令牌，我们让它很快过期，以防它被拦截)和刷新令牌的一个长过期时间。两者的持续时间取决于你需要停留的安全程度；通常，JWT在不到一个小时内到期，而刷新令牌可以持续一个月。如果两个令牌都过期，用户需要再次登录。</p><h2 id="7b36" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">端点</h2><p id="0b49" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们的服务将提供以下端点:</p><p id="75db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">POST v1/auth/generate password<br/></strong>一个从普通密码生成加密密码的实用程序，我只是为了简化用户的手动创建而包含的，很可能它不会存在于现实服务中，它接受一个<code class="fe ob oc od nt b"><strong class="kt ir">password</strong></code> <strong class="kt ir"> </strong> post参数，它返回加密密码。</p><p id="1d53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">POST/v1/auth/sign in</strong><br/>它登录用户，需要将用户名和密码作为JSON对象<code class="fe ob oc od nt b">{“user":”username", “password": “password"}</code>传递，它返回一个JSON对象，其中包含用户信息一个JWT，以及一个刷新令牌。</p><p id="1c4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> GET /v1/books/ </strong> <br/>以JSON对象的形式返回图书列表，它需要一个有效的JWT，在头中以此格式传入<br/> <em class="oi">授权:Bearer eyjhbbgcioijuzi 1 niisinr5 CCI 6 ikpxvcj 9 . eyj 1c 2 vyijoidxnlcm 5 hbwuilcjlbwfpbci 6 im 1 lqghvbwub 3 jniiwibg v2 zwwioiiwiawf 0 ij xnjqzodc 2 mj 3 lcjlehaioi</em></p><p id="8f3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">GET/v1/books/GET/$ID<br/></strong>返回ID为$ ID的图书，这本书是可公开访问的(我们将它公开，以便我们可以测试登录和匿名访问)</p><p id="eaba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">POST/v1/auth/Refresh</strong><br/>生成并返回一个新的JWT，刷新令牌应该作为<code class="fe ob oc od nt b">refreshToken</code> <strong class="kt ir"> </strong>参数传递。</p><h2 id="13b8" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">编码路线</h2><p id="339b" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">一旦我们确定了我们需要的端点，我们使用快速路由器路由它们，为了保持整洁，我们在外部文件中组织路由:<br/>创建一个<code class="fe ob oc od nt b">routes</code> <strong class="kt ir"> </strong>文件夹，并添加<code class="fe ob oc od nt b">book.js</code>文件(它将处理与书籍相关的路由和端点)和<code class="fe ob oc od nt b">auth.js</code>文件(它将处理登录和所有与用户相关的操作)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="bef6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将这些路线添加到服务器(在<code class="fe ob oc od nt b">server.js</code>文件中):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4579" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一切正常，服务器应该会刷新，您现在可以在没有授权的情况下访问两个books端点。在保护书的路线之前，我们需要一种方法来验证用户；如下编辑<code class="fe ob oc od nt b">auth.js</code>路线文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="64aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并将路由添加到服务器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c5b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您在<code class="fe ob oc od nt b">auth.js</code>中看到的那样，<code class="fe ob oc od nt b">/signin</code>请求有一个中间件功能<code class="fe ob oc od nt b">userLogin</code>，在获得主路由器功能之前，会执行一个中间件功能。我们将<code class="fe ob oc od nt b">userLogin</code> <strong class="kt ir"> </strong>函数放在<code class="fe ob oc od nt b">middleware</code>文件夹内的文件<code class="fe ob oc od nt b">auth.js</code>中，以保持有序，因为我们将继续添加更多的中间件函数。userLogin函数将验证用户，将生成令牌，如果一切正常，将转到下一个中间件函数(在我们的例子中，将返回到主函数，因为我们只有一个中间件。<br/>我们来码<code class="fe ob oc od nt b">userLogin</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9789" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">登录过程很简单(在上线之前可能需要更多的强制措施)，它主要检查被传递的用户<code class="fe ob oc od nt b">req.body.user</code>是否存在，以及提供的密码<code class="fe ob oc od nt b">req.body.password</code>对用户是否有效。</p><p id="0b09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一切正常，它会生成两个令牌(存储在用户、电子邮件和用户级别，过期1小时和30天)，它还会将令牌保存在<code class="fe ob oc od nt b"><strong class="kt ir">refreshList</strong></code>对象中，稍后将用于令牌刷新，请记住，refreshList是不稳定的，如果您重新启动或刷新服务器，它将被重置，在生产环境中，您可能希望将此列表保存在更稳定的地方。a .最后，使用<code class="fe ob oc od nt b">next()</code>将所有内容发送回主函数。</p><p id="042a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此时，您应该能够发布到登录端点，提供用户名和密码，并获得一个JWT，我们将在下一步中使用它来授权用户:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/8eb14310702fa74b7f6638ab4b63d2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JzFhIb95nSFw_D5pVH0EQ.png"/></div></div></figure><p id="dea7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于用户授权，我们将使用另一个中间件<code class="fe ob oc od nt b">verifyToken</code> <strong class="kt ir"> </strong>，它将被添加到books端点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7f1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代码将在我们的中间件文件中</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3fc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ob oc od nt b">verifyToken</code> <strong class="kt ir"> </strong>中间件期待一个<code class="fe ob oc od nt b">authorization</code> <strong class="kt ir"> </strong>头，如果它存在并被验证(用<code class="fe ob oc od nt b">jwt.verify(token, process.env.SECRET_TOKEN</code>)我们可以返回到主函数(并显示账簿)，否则，生成并显示错误消息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/f5b6d58d795d33c2be792bcd2c52f696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_9nAITZwKXXPmWpnQtCXg.png"/></div></div></figure><p id="e7e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一部分是令牌刷新程序，让我们添加一个带有<code class="fe ob oc od nt b">tokenRefresh</code> <strong class="kt ir"> </strong>中间件的<code class="fe ob oc od nt b">refresh</code>端点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="61ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并将<code class="fe ob oc od nt b">tokenRefresh</code> <strong class="kt ir"> </strong>函数添加到<code class="fe ob oc od nt b">auth.js</code>中间件文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="24d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ob oc od nt b">tokenRefresh</code> <strong class="kt ir"> </strong>只是验证作为POST参数传递的令牌是否在<code class="fe ob oc od nt b">refreshList</code>中，并且是有效的，如果验证通过，它将生成一个新的JWT，刷新令牌，并将它们发送回用户(它还将这个新令牌存储在refreshList中):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/eb6562ee4d7e93ae06eb748cfeabd056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxbaMeyLuc2bhHEHanoLJw.png"/></div></div></figure><h2 id="bbc3" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">后续步骤</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/eb6562ee4d7e93ae06eb748cfeabd056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxbaMeyLuc2bhHEHanoLJw.png"/></div></div></figure><h2 id="8db8" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak">客户视角</strong></h2><p id="4f4b" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">正如我们之前所说，我们只关注服务器部分，这是一个API的主要范围，它应该是抽象的，它不是一个网站。客户端请求数据的方式(编程语言、库等等)是客户端开发者的选择，我们提供一个端点列表，我们的端点期望什么，我们的端点返回给客户端什么。所有的数据处理、刷新延迟等等都是客户端策略。</p><h2 id="a972" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">下一步是什么</h2><p id="c684" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">这只是一个受保护API的工作流程的基本示例。从现在开始，它只能得到改进，尝试从本地数据库或远程服务获取数据，提高在另一台服务器上存储用户数据的登录安全性，检查并验证用户发送的数据，添加更多端点，以GraphQL格式返回数据，为您的API构建客户端，限制每小时最大调用次数，使用级别限制访问…扩展和改进是无止境的！</p><p id="0106" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读。</p><p id="3db3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="oi">更多内容请看</em> <a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oi">说白了就是</em> </strong> </a> <em class="oi">。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oi">免费每周简讯</em> </strong> </a> <em class="oi">。在我们的</em> <a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="oi">社区不和谐</em> </strong> </a> <em class="oi">获取独家写作机会和建议。</em></p></div></div>    
</body>
</html>