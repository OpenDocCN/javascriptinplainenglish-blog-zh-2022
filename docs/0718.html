<html>
<head>
<title>Advanced JavaScript Memoization with Lodash.memoize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lodash.memoize实现高级JavaScript记忆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-memoization-for-javascript-functions-with-lodash-memoize-12677b07e9bc?source=collection_archive---------4-----------------------#2022-02-09">https://javascript.plainenglish.io/advanced-memoization-for-javascript-functions-with-lodash-memoize-12677b07e9bc?source=collection_archive---------4-----------------------#2022-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/facac2b6edf1ee8e2a518de466ce4b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WENJUSsGm-mGM7o_"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Copyright JS Foundation and other contributors</figcaption></figure><p id="4562" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在计算中，记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序—关于记忆的维基百科</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="0b8f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae lf" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>是一个现代的JavaScript实用程序库，提供模块化和额外的性能。它是一个无处不在的库，你的项目可能会用到它，即使你没有意识到。Lodash包含一个以<a class="ae lf" href="https://lodash.com/docs/4.17.15#memoize" rel="noopener ugc nofollow" target="_blank"> memoize </a>函数形式的内存化实现。</p><p id="bc72" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">默认情况下，memoize函数只使用提供给memoized函数的第一个参数作为缓存键。这是记忆化最简单的例子:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="3d21" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> { memoize } <strong class="ll io">=</strong> require('lodash');<br/><br/><strong class="ll io">const</strong> func <strong class="ll io">=</strong> (arg1) <strong class="ll io">=&gt;</strong> `My name is ${arg1}`<br/><strong class="ll io">const</strong> funcM <strong class="ll io">=</strong> memoize(func);<br/><br/>console.dir(funcM('John')); <em class="kx">// =&gt; 'My name is John'</em><br/>console.dir(funcM('John')); <em class="kx">// =&gt; 'My name is John' (cache hit)</em><br/>console.dir(funcM.cache.size); <em class="kx">// =&gt; 1</em></span></pre><p id="846f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">重要的是要认识到内存化函数的缓存键是使用<a class="ae lf" href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero" rel="noopener ugc nofollow" target="_blank"> SameValueZero </a>比较来确定的:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="ec90" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> { memoize } <strong class="ll io">=</strong> require('lodash');<br/><br/><strong class="ll io">const</strong> func <strong class="ll io">=</strong> (arg1) <strong class="ll io">=&gt;</strong> JSON.stringify(arg1)<br/><strong class="ll io">const</strong> funcM <strong class="ll io">=</strong> memoize(func);<br/><br/>console.dir(funcM({a: 1})); <em class="kx">// =&gt; '{"a":1}'</em><br/>console.dir(funcM({a: 1})); <em class="kx">// =&gt; '{"a":1}'</em><br/>console.dir(funcM.cache.size); <em class="kx">// =&gt; 2</em></span></pre><p id="62cb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，如果我们在函数中引入更多的参数呢？</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="abcc" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> { memoize } <strong class="ll io">=</strong> require('lodash');<br/><br/><strong class="ll io">const</strong> func <strong class="ll io">=</strong> (arg1, arg2) <strong class="ll io">=&gt;</strong> `${arg1} ${arg2}`;<br/><strong class="ll io">const</strong> funcM <strong class="ll io">=</strong> memoize(func);<br/><br/>console.dir(funcM('John', 'Doe')); <em class="kx">// =&gt; "John Doe"</em><br/>console.dir(funcM('John', 'FooBar')); <em class="kx">// =&gt; "John Doe" (cache hit)</em><br/>console.dir(funcM.cache.size); <em class="kx">// =&gt; 2</em></span></pre><p id="a9d8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以看到有一个明显的问题。如上所述，lodash只使用第一个参数作为缓存键。要解决这个问题，我们必须使用解析函数:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="c05f" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> { memoize } <strong class="ll io">=</strong> require('lodash');<br/><br/><strong class="ll io">const</strong> func <strong class="ll io">=</strong> (arg1, arg2) <strong class="ll io">=&gt;</strong> `${arg1} ${arg2}`;<br/><strong class="ll io">const</strong> resolver <strong class="ll io">=</strong> (arg1, arg2) <strong class="ll io">=&gt;</strong> JSON.stringify([arg1, arg2]);<br/><strong class="ll io">const</strong> funcM <strong class="ll io">=</strong> memoize(func, resolver);<br/><br/>console.dir(funcM('John', 'Doe')); <em class="kx">// =&gt; "John Doe"</em><br/>console.dir(funcM('John', 'FooBar')); <em class="kx">// =&gt; "John FooBar"</em><br/>console.dir(funcM.cache.size); <em class="kx">// =&gt; 2</em></span></pre><p id="52e3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这种解析器解决方案显然无法扩展。如果我们的func需要消耗复杂对象作为参数怎么办？这很好，除非对象参数很大或者包含循环引用。</p><p id="a269" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当参数是巨大的对象时，我们将花费太多的CPU时间将这些对象序列化成JSON字符串来确定缓存键。我们将比较巨大的字符串，而不是对象的SameValueZero比较。当对象参数包含循环引用时，我们将无法将它们序列化为JSON字符串并确定缓存键。</p><p id="efb4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Lodash还有一招可以克服这两个问题——能够影响缓存键的维护方式。为了实现我们的目标，我们必须创建lodash.memoize的专门化；名为memoizeN的函数:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="1e58" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> { memoize } <strong class="ll io">from</strong> "lodash";<br/><br/><strong class="ll io">const</strong> sameValueZero <strong class="ll io">=</strong> (x, y) <strong class="ll io">=&gt;</strong> x <strong class="ll io">===</strong> y <strong class="ll io">||</strong> (Number.isNaN(x) <strong class="ll io">&amp;&amp;</strong> Number.isNaN(y));<br/><strong class="ll io">const</strong> shallowArrayEquals <strong class="ll io">=</strong> (a) <strong class="ll io">=&gt;</strong> (b) <strong class="ll io">=&gt;</strong> {<br/>  <strong class="ll io">return</strong> Array.isArray(a) <strong class="ll io">&amp;&amp;</strong> Array.isArray(b)<br/>    <strong class="ll io">&amp;&amp;</strong> a.length <strong class="ll io">===</strong> b.length<br/>    <strong class="ll io">&amp;&amp;</strong> a.every((val, index) <strong class="ll io">=&gt;</strong> sameValueZero(val, b[index]));<br/>};<br/><strong class="ll io">const</strong> list <strong class="ll io">=</strong> (...args) <strong class="ll io">=&gt;</strong> args;<br/><br/><strong class="ll io">class</strong> Cache <strong class="ll io">extends</strong> Map {<br/>  <strong class="ll io">delete</strong>(key) {<br/>    <strong class="ll io">const</strong> keys <strong class="ll io">=</strong> Array.<strong class="ll io">from</strong>(<strong class="ll io">this</strong>.keys());<br/>    <strong class="ll io">const</strong> foundKey <strong class="ll io">=</strong> keys.find(shallowArrayEquals(key));<br/>    <strong class="ll io">return</strong> <strong class="ll io">super</strong>.<strong class="ll io">delete</strong>(foundKey);<br/>  }<br/>  <strong class="ll io">get</strong>(key) {<br/>    <strong class="ll io">const</strong> keys <strong class="ll io">=</strong> Array.<strong class="ll io">from</strong>(<strong class="ll io">this</strong>.keys());<br/>    <strong class="ll io">const</strong> foundKey <strong class="ll io">=</strong> keys.find(shallowArrayEquals(key));<br/>    <strong class="ll io">return</strong> <strong class="ll io">super</strong>.<strong class="ll io">get</strong>(foundKey);<br/>  }<br/>  has(key) {<br/>    <strong class="ll io">const</strong> keys <strong class="ll io">=</strong> Array.<strong class="ll io">from</strong>(<strong class="ll io">this</strong>.keys());<br/>    <strong class="ll io">return</strong> keys.findIndex(shallowArrayEquals(key)) <strong class="ll io">!==</strong> <strong class="ll io">-</strong>1;<br/>  }<br/>}<br/><br/><strong class="ll io">const</strong> memoizeN <strong class="ll io">=</strong> (fn, { resolver <strong class="ll io">=</strong> list } <strong class="ll io">=</strong> {}) <strong class="ll io">=&gt;</strong> {<br/>  <strong class="ll io">const</strong> { Cache: OriginalCache } <strong class="ll io">=</strong> memoize;<br/>  memoize.Cache <strong class="ll io">=</strong> Cache;<br/>  <strong class="ll io">const</strong> memoized <strong class="ll io">=</strong> memoize(fn, resolver);<br/>  memoize.Cache <strong class="ll io">=</strong> OriginalCache;<br/>  <strong class="ll io">return</strong> memoized;<br/>};</span></pre><p id="8190" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里真正的技巧是，记忆化的函数参数被转换成一个列表，这个列表形成一个缓存键。我们在特定的基础上覆盖lodash.memoize.Cache类，我们的实现能够为我们的列表缓存键进行缓存键查找。</p><p id="adf0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">观察下面的例子:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="789f" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> complexObj <strong class="ll io">=</strong> {a: 1};<br/><strong class="ll io">const</strong> simpleObj <strong class="ll io">=</strong> {b: 2};<br/><br/><strong class="ll io">const</strong> func <strong class="ll io">=</strong> (arg1, arg2) <strong class="ll io">=&gt;</strong> arg2;<br/><strong class="ll io">const</strong> resolver <strong class="ll io">=</strong> (arg1, arg2) <strong class="ll io">=&gt;</strong> [arg1, JSON.stringify(arg2)];<br/><strong class="ll io">const</strong> funcM <strong class="ll io">=</strong> memoizeN(func, { resolver });<br/><br/>console.dir(funcM(complexObj, simpleObj)); <em class="kx">// =&gt; {b: 2}</em><br/>console.dir(funcM(complexObj, {b: 2})); <em class="kx">// =&gt; {b: 2} (cache hit)</em><br/>console.dir(funcM({a: 1}, {b: 2})); <em class="kx">// =&gt; {b: 2}</em><br/>console.dir(funcM.cache.size); <em class="kx">// =&gt; 2</em></span></pre><p id="e7c1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们打算使用这两个参数来构成缓存键，以此来记忆func。对于第一个参数，对原始值使用SameValueZero比较。对于第二种情况，对JSON字符串化值使用SameValueZero比较。</p><p id="ca99" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以进一步专门化，让memoizeN使用应用于适当参数的比较器函数列表，而不是滥用解析器来序列化一些参数。</p><p id="7337" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">实现将如下所示:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="5898" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> memoize <strong class="ll io">=</strong> require('lodash/memoize');<br/><strong class="ll io">const</strong> isEqual <strong class="ll io">=</strong> require('lodash/isEqual');<br/><br/><strong class="ll io">const</strong> sameValueZero <strong class="ll io">=</strong> (x, y) <strong class="ll io">=&gt;</strong> x <strong class="ll io">===</strong> y <strong class="ll io">||</strong> (Number.isNaN(x) <strong class="ll io">&amp;&amp;</strong> Number.isNaN(y));<br/><strong class="ll io">const</strong> makeShallowArrayEquals <strong class="ll io">=</strong> (comparators) <strong class="ll io">=&gt;</strong> (a) <strong class="ll io">=&gt;</strong> (b) <strong class="ll io">=&gt;</strong> {<br/>  <strong class="ll io">return</strong> Array.isArray(a) <strong class="ll io">&amp;&amp;</strong> Array.isArray(b)<br/>    <strong class="ll io">&amp;&amp;</strong> a.length <strong class="ll io">===</strong> b.length<br/>    <strong class="ll io">&amp;&amp;</strong> a.every((val, index) <strong class="ll io">=&gt;</strong> {<br/>      <strong class="ll io">const</strong> comparator <strong class="ll io">=</strong> <strong class="ll io">typeof</strong> comparators <strong class="ll io">===</strong> 'function' ? comparators : comparators[index] <strong class="ll io">||</strong> sameValueZero;<br/>      <strong class="ll io">return</strong> comparator(val, b[index]);<br/>    });<br/>};<br/><strong class="ll io">const</strong> list <strong class="ll io">=</strong> (...args) <strong class="ll io">=&gt;</strong> args;<br/><br/><strong class="ll io">class</strong> Cache <strong class="ll io">extends</strong> Map {<br/>  shallowArrayEquals <strong class="ll io">=</strong> makeShallowArrayEquals(sameValueZero);<br/><br/>  <strong class="ll io">delete</strong>(key) {<br/>    <strong class="ll io">const</strong> keys <strong class="ll io">=</strong> Array.<strong class="ll io">from</strong>(<strong class="ll io">this</strong>.keys());<br/>    <strong class="ll io">const</strong> foundKey <strong class="ll io">=</strong> keys.find(<strong class="ll io">this</strong>.shallowArrayEquals(key));<br/>    <strong class="ll io">return</strong> <strong class="ll io">super</strong>.<strong class="ll io">delete</strong>(foundKey);<br/>  }<br/>  <strong class="ll io">get</strong>(key) {<br/>    <strong class="ll io">const</strong> keys <strong class="ll io">=</strong> Array.<strong class="ll io">from</strong>(<strong class="ll io">this</strong>.keys());<br/>    <strong class="ll io">const</strong> foundKey <strong class="ll io">=</strong> keys.find(<strong class="ll io">this</strong>.shallowArrayEquals(key));<br/>    <strong class="ll io">return</strong> <strong class="ll io">super</strong>.<strong class="ll io">get</strong>(foundKey);<br/>  }<br/>  has(key) {<br/>    <strong class="ll io">const</strong> keys <strong class="ll io">=</strong> Array.<strong class="ll io">from</strong>(<strong class="ll io">this</strong>.keys());<br/>    <strong class="ll io">return</strong> keys.findIndex(<strong class="ll io">this</strong>.shallowArrayEquals(key)) <strong class="ll io">!==</strong> <strong class="ll io">-</strong>1;<br/>  }<br/>}<br/><br/><strong class="ll io">const</strong> memoizeN <strong class="ll io">=</strong> (fn, { resolver <strong class="ll io">=</strong> list, comparators <strong class="ll io">=</strong> sameValueZero }) <strong class="ll io">=&gt;</strong> {<br/>  <strong class="ll io">const</strong> { Cache: OriginalCache } <strong class="ll io">=</strong> memoize;<br/>  memoize.Cache <strong class="ll io">=</strong> Cache;<br/>  <strong class="ll io">const</strong> memoized <strong class="ll io">=</strong> memoize(fn, resolver <strong class="ll io">||</strong> list);<br/>  memoized.cache.shallowArrayEquals <strong class="ll io">=</strong> makeShallowArrayEquals(comparators);<br/>  memoize.Cache <strong class="ll io">=</strong> OriginalCache;<br/>  <strong class="ll io">return</strong> memoized;<br/>};<br/><br/>module.exports <strong class="ll io">=</strong> memoizeN;</span></pre><p id="df18" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个版本的memoizeN为每个参数应用特定的比较器算法:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="9915" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> obj1 <strong class="ll io">=</strong> {a: 1};<br/><strong class="ll io">const</strong> obj2 <strong class="ll io">=</strong> {b: 2};<br/><strong class="ll io">const</strong> obj3 <strong class="ll io">=</strong> {c: 3};<br/><br/><strong class="ll io">const</strong> func <strong class="ll io">=</strong> (arg1, arg2, arg3) <strong class="ll io">=&gt;</strong> arg3;<br/><strong class="ll io">const</strong> strictEquality <strong class="ll io">=</strong> (x, y) <strong class="ll io">=&gt;</strong> x <strong class="ll io">===</strong> y;<br/><strong class="ll io">const</strong> sameValueZero <strong class="ll io">=</strong> (x, y) <strong class="ll io">=&gt;</strong> x <strong class="ll io">===</strong> y <strong class="ll io">||</strong> (Number.isNaN(x) <strong class="ll io">&amp;&amp;</strong> Number.isNaN(y));<br/><strong class="ll io">const</strong> deepEquality <strong class="ll io">=</strong> lodash.isEqual;<br/><strong class="ll io">const</strong> comparators <strong class="ll io">=</strong> [strictEquality, sameValueZero, deepEquality];<br/><strong class="ll io">const</strong> funcM <strong class="ll io">=</strong> memoizeN(func, { comparators });<br/><br/>console.dir(funcM(obj1, obj2, obj3)); <em class="kx">// =&gt; {c: 3}</em><br/>console.dir(funcM(obj1, obj2, {c: 3})); <em class="kx">// =&gt; {c: 3} (cache hit)</em><br/>console.dir(funcM(obj1, {b: 2}, obj3); <em class="kx">// =&gt; {c: 3}</em><br/>console.dir(funcM.cache.size); <em class="kx">// =&gt; 2</em></span></pre><p id="bacc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果我们将comparators选项定义为一个函数，那么memoized函数将使用它来比较每个参数。当没有提供比较器时，SameValueZero比较用于所有参数。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="6d2e" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">const</strong> obj1 <strong class="ll io">=</strong> {a: 1};<br/><strong class="ll io">const</strong> obj2 <strong class="ll io">=</strong> {b: 2};<br/><strong class="ll io">const</strong> obj3 <strong class="ll io">=</strong> {c: 3};<br/><br/><strong class="ll io">const</strong> func <strong class="ll io">=</strong> (arg1, arg2, arg3) <strong class="ll io">=&gt;</strong> arg3;<br/><strong class="ll io">const</strong> sameValueZero <strong class="ll io">=</strong> (x, y) <strong class="ll io">=&gt;</strong> x <strong class="ll io">===</strong> y <strong class="ll io">||</strong> (Number.isNaN(x) <strong class="ll io">&amp;&amp;</strong> Number.isNaN(y));<br/><strong class="ll io">const</strong> funcM <strong class="ll io">=</strong> memoizeN(func, { comparators: sameValueZero }); <em class="kx">// equivalen with memoizeN(func)</em><br/><br/>console.dir(funcM(obj1, obj2, obj3)); <em class="kx">// =&gt; {c: 3}</em><br/>console.dir(funcM(obj1, obj2, obj3)); <em class="kx">// =&gt; {c: 3} // cache hit</em><br/>console.dir(funcM.cache.size); <em class="kx">// =&gt; 1</em></span></pre><p id="d3f2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我已经将memoizeN提取到可通过npm安装的<a class="ae lf" href="https://gist.github.com/char0n/2e6c77d38cf00faacceaf37e46b76a32" rel="noopener ugc nofollow" target="_blank"> GitHub Gist </a>中。如果您更喜欢使用memoizeN作为npm包，以下是实现方法:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="7de3" class="lp lq in ll b gy lr ls l lt lu">$ npm install gist:2e6c77d38cf00faacceaf37e46b76a32 --save</span></pre><p id="a819" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此命令将在您的依赖项中创建以下条目:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="514e" class="lp lq in ll b gy lr ls l lt lu">"dependencies": {<br/>  "@char0n/memoizeN": "gist:2e6c77d38cf00faacceaf37e46b76a32" <br/>}</span></pre><p id="d1d7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后通过CommonJS或ESM使用它:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="df2c" class="lp lq in ll b gy lr ls l lt lu">const memoizeN = require('@char0n/memoizeN');<br/>// or<br/>import memoizeN from '@char0n/memoizeN';</span></pre><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">memoizeN</figcaption></figure><p id="d367" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你需要更高级的功能，比如LRU缓存、TTL、引用计数等等，我建议你看看<a class="ae lf" href="https://github.com/medikoo/memoizee" rel="noopener ugc nofollow" target="_blank"> memoizee </a>。memizee可能是JavaScript中功能最丰富的memoization实现。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="ac8d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">原载于</em><a class="ae lf" href="https://vladimirgorej.com/blog/advanced-memoization-for-javascript-functions-with-lodash-memoize/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="kx">https://vladimirgorej.com</em></strong></a><em class="kx">2022年2月5日</em></p><p id="ed33" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">更多内容看</em> <a class="ae lf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="kx">说白了就是</em> </strong> </a> <em class="kx">。报名参加我们的</em> <a class="ae lf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="kx">免费周报</em> </strong> </a> <em class="kx">。在我们的</em> <a class="ae lf" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="kx">社区不和谐</em> </strong> </a> <em class="kx">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>