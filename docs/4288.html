<html>
<head>
<title>Const vs. Function For React Functional Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应功能组分的常数与函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/const-vs-function-for-react-functional-components-23e70fd0d4e0?source=collection_archive---------2-----------------------#2022-11-17">https://javascript.plainenglish.io/const-vs-function-for-react-functional-components-23e70fd0d4e0?source=collection_archive---------2-----------------------#2022-11-17</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="ff73" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">好奇的React开发者的一点研究</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/7ff37c10f5019287963141365931b8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-UL9ZiAQ94eFkCvVbdcaig.png"/></div></div></figure><p id="27e1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">一段时间以来，我一直想知道在声明功能组件时使用<code class="fe lo lp lq lr b">function</code>而不是<code class="fe lo lp lq lr b">const</code>是否有好处，反之亦然。所以，我决定做一点研究，我会在这篇文章中为你总结。</p></div><div class="ab cl ls lt hv lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ik il im in io"><h2 id="4dc3" class="lz ma ir bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">TLDR</h2><p id="38dd" class="pw-post-body-paragraph ks kt ir ku b kv ms js kx ky mt jv la lb mu ld le lf mv lh li lj mw ll lm ln ik bi translated">无论你使用哪一个都没有关系。最重要的<em class="mx">技术</em>区别在于使用<code class="fe lo lp lq lr b">function</code>定义的功能部件被<strong class="ku is">提升</strong>而使用<code class="fe lo lp lq lr b">const</code>的功能部件则没有。然而，只要您在单独的文件中定义组件，并在需要它们的地方将它们导入到文件的顶部，这并没有什么实际的后果。这很可能是你组织文件的方式，这也是为什么它没有真正的区别</p><p id="7cd4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">我发现使用<code class="fe lo lp lq lr b">function</code>语法的最大好处是当使用Visual Studio代码作为编辑器时。这是因为VSC让您可以选择将<code class="fe lo lp lq lr b">function</code>重构为一个新文件，但是如果您使用了<code class="fe lo lp lq lr b">const</code>语法，则该选项不可用。</strong></p><p id="49b5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">此外，有些人因为可读性而偏爱其中之一。然而，这是主观的，你可以自己决定你喜欢什么。</p><p id="ea95" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">最后，在React中声明功能组件时，正是由于与VSC在实用性上的不同，我更喜欢使用<code class="fe lo lp lq lr b">function</code>而不是<code class="fe lo lp lq lr b">const</code>。除此之外，我没有发现两者之间有任何实际的区别。</p><p id="322a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">出于好奇，你可以在下面找到更多的细节。</p></div><div class="ab cl ls lt hv lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ik il im in io"><h2 id="0ba9" class="lz ma ir bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">技术差异——吊装</h2><p id="d246" class="pw-post-body-paragraph ks kt ir ku b kv ms js kx ky mt jv la lb mu ld le lf mv lh li lj mw ll lm ln ik bi translated">JavaScript有一个叫做提升的概念，它允许在使用变量和函数的行下面的行上声明变量和函数。这有点复杂，需要更多的解释才能完全理解，我不想在这里介绍。因此，我将向您展示它对我们的组件意味着什么。</p><p id="d1db" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">下面的代码要点包含两个修改过的<code class="fe lo lp lq lr b">index.tsx</code>文件，它们通常是React应用程序的入口点。<strong class="ku is">第一个是</strong> <strong class="ku is">无效</strong>会出错，而<strong class="ku is">第二个是</strong> <strong class="ku is">有效</strong>。它们之间唯一的区别是<code class="fe lo lp lq lr b">Header</code>组件在哪里初始化。在第一个文件中，它在第9行下面的第14行被初始化。在第二个文件中，它在第7行被初始化，在第13行被使用之前。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="my mz l"/></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">Gist with example files of an invalid const usage and a valid const usage</figcaption></figure><p id="ab8b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这个<a class="ae ne" href="https://codesandbox.io/s/constvsfunction-323l95?file=/src/index.tsx" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>的截图显示了当<code class="fe lo lp lq lr b">const</code>函数在初始化之前被使用时将会发生的错误。<em class="mx">(不要介意第二行的红色曲线)</em></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/71bde24503bb2a0cdcd5273cdf6062e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*j9lbp2Egy9-AqpwSA26TSw.png"/></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">Code sandbox showing an invalid use of the const keyword</figcaption></figure><p id="b714" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在让我们看一下相同的代码，只是使用了<code class="fe lo lp lq lr b">Header</code>组件的<code class="fe lo lp lq lr b">function</code>关键字。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/8fcdd2091c56d5600c1a2c6034e5735d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*RJ5S0CllYTf2YBZQv9LS7w.png"/></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">Code sandbox showing a valid use of the keyword function</figcaption></figure><p id="57ba" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">上面的<a class="ae ne" href="https://codesandbox.io/s/constvsfunctionworking-sm6yj5?file=/src/index.tsx" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>显示了使用<code class="fe lo lp lq lr b">function</code>语法时代码运行正确。<em class="mx">(第11行出现弯弯曲曲的红线是因为当前的林挺规则不允许在定义函数之前使用它，然而这只是林挺的情况。)</em></p><p id="8442" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这表明使用<code class="fe lo lp lq lr b">function</code>代替<code class="fe lo lp lq lr b">const</code>可能有潜在的技术优势。</p><p id="6ab6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is"> <em class="mx">但是这在现实世界的项目中真的重要吗……</em></strong></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nh"><img src="../Images/c10361496df4d6be2dc8d83bad9a55d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xdvZFZqg0jsWnSh5"/></div></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">Photo by <a class="ae ne" href="https://unsplash.com/@earbiscuits?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Juan Rumimpunu</a> on <a class="ae ne" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e667" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我认为没有。</p><p id="e9b5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这是因为我几乎总是在单独的文件中定义我的组件，然后将它们导入到我想要呈现它们的文件中。我的导入语句总是在文件的顶部。正因为如此，我的<code class="fe lo lp lq lr b">const</code>组件总是被定义在实际运行它们的代码行之上。</p><p id="1bbc" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这意味着即使在以下情况下，它也不会成为问题。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/e8108837b6061c055c22c350c5ca6664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*u0p64HYHFGL-VJZ95RcPPw.png"/></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">Code sandbox showing that defining components with const, is not really a problem even though they are not hoisted</figcaption></figure><p id="1565" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但是等一下，上面的例子是如何工作的？为什么在<code class="fe lo lp lq lr b">App</code>内部使用<code class="fe lo lp lq lr b">InnerComponent</code>没有问题？即使在<code class="fe lo lp lq lr b">App</code>下面定义。</p><p id="1105" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我的理论是，决定因素是运行时代码的顺序，而不是编译/解释时的顺序。运行时呈现应用程序的入口点是对第8行的<code class="fe lo lp lq lr b">root.render(&lt;App /&gt;);</code>的调用，这发生在<code class="fe lo lp lq lr b">index.tsx</code>中第3行的import语句之后。同样地，<code class="fe lo lp lq lr b">InnerComponent</code>的初始化在<code class="fe lo lp lq lr b">root.render(&lt;App /&gt;);</code>之上，因此一旦<code class="fe lo lp lq lr b">App</code>组件需要它，它就已经被初始化。</p><p id="5c7d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们来看一个纯JavaScript的小玩具示例，以便更容易理解。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nj"><img src="../Images/d1f5efec7dfde70bb92a978e2a3fde0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*2De7MhUvy-XjLTTCY1P6Fw.png"/></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">Working example with call to later defined function after its definition</figcaption></figure><p id="8a4c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在<a class="ae ne" href="https://codesandbox.io/s/constvsfunctionworking-sm6yj5?file=/src/index.tsx" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>的截图中，上面的<code class="fe lo lp lq lr b">InnerComponent</code>定义在函数表达式<code class="fe lo lp lq lr b">AppEntry</code>的定义下面。然而，对<code class="fe lo lp lq lr b">AppEntry</code>的调用发生在<code class="fe lo lp lq lr b">InnerComponent</code>被初始化之后，因此在运行时没有问题，尽管它是使用<code class="fe lo lp lq lr b">const</code>创建的函数。(这类似于React中的大多数用例)</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/8fd130964fd38fee4aa4d5daa6e75268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*VwpJQD_hPqpDCMO7vDSmXA.png"/></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">Example showing how InnerComponent cannot be used before its initialization at runtime</figcaption></figure><p id="b18b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">相反，如果我们将<code class="fe lo lp lq lr b">AppEntry</code>调用移到<code class="fe lo lp lq lr b">InnerComponent</code>之前，那么我们会看到问题的发生，因为<code class="fe lo lp lq lr b">const</code>函数表达式没有被提升。(但我认为这永远不会发生在你身上，因为你的应用程序的入口点最有可能在<code class="fe lo lp lq lr b">index.tsx</code>中，所有其他组件将在初始渲染函数之上导入)</p><p id="5b8d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">最后，如果我们使用<code class="fe lo lp lq lr b">function</code>关键字来声明<code class="fe lo lp lq lr b">InnerComponent</code>，那么提升就开始了，它的工作如下面的截图所示。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nl"><img src="../Images/597da6c23fea163f91177d8e52a97a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*c85jjjP0ymnwWi7N6PjNZw.png"/></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">Example showing that the function keyword causes the function to be hoisted</figcaption></figure></div><div class="ab cl ls lt hv lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ik il im in io"><h2 id="f082" class="lz ma ir bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">Visual Studio代码差异</h2><p id="71d7" class="pw-post-body-paragraph ks kt ir ku b kv ms js kx ky mt jv la lb mu ld le lf mv lh li lj mw ll lm ln ik bi translated">现在我们已经解决了技术上的差异，我认为这几乎是不存在的，让我们来看看我在使用VSC时注意到的效用差异。</p><p id="b146" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果你已经使用<code class="fe lo lp lq lr b">function</code>声明了功能组件，VSC允许你将它们重构到新的单独的文件中，但是如果你已经使用<code class="fe lo lp lq lr b">const</code>则不允许。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nm"><img src="../Images/ddfbbc4dfce54013e6e6ff9033c9f573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*e3e_ekOoJ3Sc3i6tfXlUCg.gif"/></div></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">gif showing refactoring options of function in VSC</figcaption></figure><p id="d3e7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">刚刚使用<code class="fe lo lp lq lr b">const</code>声明的相同功能。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nm"><img src="../Images/dea69fe42e80add599d1dc07113ecea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FXjJfu3RDb1Otqa1SW7MDQ.gif"/></div></div><figcaption class="na nb gk gi gj nc nd bd b be z dk">gif showing refactoring options of const in VSC</figcaption></figure><p id="9f90" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">对我来说，这其实是用<code class="fe lo lp lq lr b">function</code>代替<code class="fe lo lp lq lr b">const</code>最重要的好处。因为它消除了创建新文件和编写样板代码的繁琐步骤。</p><p id="23e9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">尽管如此，重构选项(如第二个gif所示)允许您将<code class="fe lo lp lq lr b">const</code>函数表达式转换为命名函数，因此您可以快速进行切换，尤其是在使用键盘快捷键的情况下。</p></div><div class="ab cl ls lt hv lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ik il im in io"><h2 id="0fdd" class="lz ma ir bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">主观利益(可读性)</h2><p id="02d7" class="pw-post-body-paragraph ks kt ir ku b kv ms js kx ky mt jv la lb mu ld le lf mv lh li lj mw ll lm ln ik bi translated">最后要考虑的是语法的可读性。这当然是一个主观的问题，一些人更喜欢<code class="fe lo lp lq lr b">function</code>语法，而另一些人更喜欢<code class="fe lo lp lq lr b">const</code>语法。</p><p id="3c1d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我喜欢的一个论点是，函数语法最类似于其他编程语言的函数声明，因此与粗箭头语法相比，非JavaScript开发人员更容易理解该语法。</p></div><div class="ab cl ls lt hv lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ik il im in io"><h2 id="f2bc" class="lz ma ir bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">最后的话</h2><p id="0ee5" class="pw-post-body-paragraph ks kt ir ku b kv ms js kx ky mt jv la lb mu ld le lf mv lh li lj mw ll lm ln ik bi translated">我对这个问题的结论是，使用哪种语法并不重要。就用你喜欢的那个吧。也许和我一样，VSC的不同可能是你的决定性因素。也许是可读性帮你做到了？</p><p id="734f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果你对此有任何补充或知识(也许我错过了一些重要的东西)，请在评论中分享。</p><p id="2466" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">感谢您的阅读，祝您愉快！</p><p id="02f7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><em class="mx">更多内容看</em> <a class="ae ne" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku is"> <em class="mx">说白了。报名参加我们的</em> <a class="ae ne" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku is"> <em class="mx">免费周报</em> </strong> </a> <em class="mx">。关注我们关于</em> <a class="ae ne" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ku is"> <em class="mx">推特</em></strong></a><a class="ae ne" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku is"><em class="mx">LinkedIn</em></strong></a><em class="mx"/><a class="ae ne" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ku is"><em class="mx">YouTube</em></strong></a><em class="mx"/><a class="ae ne" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ku is"><em class="mx">不和</em> </strong> </a> <em class="mx">。对增长黑客感兴趣？检查</em> <a class="ae ne" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku is"> <em class="mx">电路</em> </strong> </a> <em class="mx">。</em></strong></a></p></div></div>    
</body>
</html>