<html>
<head>
<title>JavaScript Object References and Its Copy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript对象引用及其副本</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-object-references-and-its-copy-92d3d76ef92?source=collection_archive---------4-----------------------#2022-08-27">https://javascript.plainenglish.io/javascript-object-references-and-its-copy-92d3d76ef92?source=collection_archive---------4-----------------------#2022-08-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8f8f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过引用传递和通过值传递及其在JavaScript中的修改</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5fe18bf8006aa41c83beaffd9ea9183f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0cLf4tZ50mlA6-SW"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sigmund</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d29b" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">JavaScript对象引用及其副本</h1><p id="61fa" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在处理JavaScript时，你将会面临这样的困惑:JavaScript如何处理它的基本变量和非基本变量，以及它们何时被用作值或引用。使用这些值时，每种方法的工作方式都不同。</p><p id="1c8d" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">今天，我们将讨论JavaScript如何定义其引用和对象，以及如何在不同的场合处理它们。</p><h2 id="0d3a" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">类型</h2><p id="d3c7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">让我们从基础开始，有两种类型的JavaScript对象，即原语和非原语。原语类型有<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">字符串、数字、空、布尔、BigInt、符号(新引入的)，以及未定义的</a>。</p><p id="5215" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">另一方面，非基元类型是存储中的引用，因为它们没有已定义的存储。非原始类型在存储中会变得很大，这就是JS将它最好地用于引用(也称为对象)的原因。每个对象都是从G <a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">全局对象类</a>派生出来的。</p><p id="8387" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">每个对象都分配了一个<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Glossary/Identifier" rel="noopener ugc nofollow" target="_blank">标识符</a>，它保存了它们引用的值，就像常规变量一样，标识符也有它们的作用域和Unicode。</p><h2 id="9a8d" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">更新基本类型</h2><p id="9c92" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">让我们从基本类型开始，更新它们。我们将首先创建一个字符串变量并将其赋给另一个变量，然后更新新变量并比较输出。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1573097de5e84299ff376a4c8c48d26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*NznJUAJOJOBIrLChGDM2hQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Primitive Type Example</figcaption></figure><p id="6be6" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">以下程序的输出将是唯一的，并声明每个原始值将保存在另一个内存地址中:</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="325c" class="mm ku in na b gy ne nf l ng nh">Output - test another test</span></pre><h2 id="aec5" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">更新非原始类型</h2><p id="a2ba" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">当我们使用非原始类型时，期望是不同的。我们要做和上面一样的事情，但是我们不更新值，而是更新里面的属性。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3fa7ebea21e6d30fb42069796fc68014.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*gp5Vt9T5uzMrHMJvDtoeqg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Non-primitive type example</figcaption></figure><p id="98b9" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在这种情况下，输出将更新原始对象，因为它们指向相同的位置:</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="5ba9" class="mm ku in na b gy ne nf l ng nh">Output - { name: 'another test' }</span></pre><p id="c836" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们可以通过使用<code class="fe nj nk nl na b">Object.assign</code>来克隆对象，值将会不同。举个例子，</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/617c113c1b7ef8077ec9ae41b7b71014.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*NVpwsxGq17IKMjM3RijkDQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using Object.assign</figcaption></figure><p id="b7c4" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在这种情况下，输出将是不同的，结果将打印原始对象，因为它们指向不同的内存地址:</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="9be0" class="mm ku in na b gy ne nf l ng nh">Output - { name: 'test' }</span></pre><h2 id="ea1b" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">如果我们有嵌套的非原始属性呢？</h2><p id="0ed1" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们正在尝试的例子是指向作为基本类型的属性，但是如果任何一个属性是非基本的呢？</p><p id="eac9" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">让我们看看预期的场景，我们将在我们的对象中创建一个非原始的属性，并尝试更新最新的对象，并将其与现有的对象进行比较:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0b2233dd25aaf9e3b97b4265ef614371.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*QgXDYDX4UE8sA7AuP_GY6Q.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Using Object.assign with nested objects</figcaption></figure><p id="17a1" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">程序的输出将是:</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="5171" class="mm ku in na b gy ne nf l ng nh">Output - { name: 'test', properties: { location: 'location two' } }</span></pre><p id="8ae5" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">现在，这是一件有趣的事情，<code class="fe nj nk nl na b">name</code>属性是原语，因此有不同的位置，但<code class="fe nj nk nl na b">properties</code>是非原语，与<code class="fe nj nk nl na b">obj.properties</code>共享相同的地址，当更新它时，也更新嵌套的对象。这是因为<code class="fe nj nk nl na b">Object.assign</code>只在顶层创建一个属性，不做嵌套克隆。</p><p id="3d72" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="no">对于嵌套克隆，有</em> <code class="fe nj nk nl na b"><em class="no">structuredClone(node v17), recursive methods, JSON.parse(JSON.stringify(obj))and third party library</em></code> <em class="no">等方法。</em></p><h1 id="0a9d" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">将变量传递给函数</h1><p id="d9ed" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">当我们处理函数和传递值时，有两种方式传递变量:传值和传引用。首先，让我们了解当一个变量被传递给一个函数时，JavaScript将如何定义该做什么。</p><h2 id="ca1c" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">按值传递与按引用传递</h2><p id="3584" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在JavaScript中，它从不明确地比较类型是值还是引用，但是当我们调用一个只有很少参数的方法时，会发生一个简单的机制。JavaScript将创建输入的副本。</p><p id="bd9f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">由于我们创建的每个函数都是<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype" rel="noopener ugc nofollow" target="_blank">函数</a>类的衍生物，因此每个函数都有一个名为<code class="fe nj nk nl na b">arguments</code>的属性，它是一个数组并被分配给方法。点击阅读更多关于<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">参数的信息。</a></p><p id="97af" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因为参数是非原始类型。JavaScript使用<code class="fe nj nk nl na b">Object.assign(arguments, [...rest])</code>，其中rest是作为数组传递的参数，当函数中的任何变量被更新时，它是一个被更新的arguments关键字。</p><p id="cf22" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因为我们创建了一个新的参数实例，如果值是原语，它将创建一个新的地址，另一方面，对于非原语，它将指向同一个实例变量。</p><h2 id="2dac" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">传递原始类型</h2><p id="e730" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">现在，我们知道函数将创建一个新的变量，所以传递一个原始类型似乎没有任何问题，变量将保持其原始状态。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/3169cba9aa09dbabe3978c518d676af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*YNXb9oopePQQFsR8YWk5tg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Example of primitive passed value to a method</figcaption></figure><p id="90b0" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">以下程序的输出将是未经修改的原始状态:</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="ff4e" class="mm ku in na b gy ne nf l ng nh">Output - test</span></pre><h2 id="da13" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">传递非基元类型并更新其引用</h2><p id="8a2f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">当传递非原始类型时，它也创建一个副本，并且该值将被引用。但是当更新引用时，它将指向另一个变量，因为我们传递给它的是一个副本，而不是一个实际的对象。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/35d51c96ee4655b4daeae0ddb069f7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*7M7fmLHw1Ps_hh5PGtBKSQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Example of non-primitive passed value to a method</figcaption></figure><p id="9464" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">由于我们更新了引用本身，以下程序的输出仍将保持其原始状态，没有任何修改:</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="74cb" class="mm ku in na b gy ne nf l ng nh">Output - { name: 'test' }</span></pre><h2 id="96e9" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">传递非原始类型并更新其属性</h2><p id="afb1" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">按照上面的例子，如果我们更新引用，那么它将指向一个新的内存地址，但是如果我们更新属性，那么它将更新值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e28829fbb8327862bc1d3615ff0372fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*ISEj3NiUT2Pkmb8C0LLGjw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Example of non-primitive passed value to a method and updating properties</figcaption></figure><p id="84e1" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">以下程序的输出将不会处于其原始状态，name属性将被赋予一个新值，因为引用不会用相同的标识符进行修改和更新。</p><pre class="kd ke kf kg gt mz na nb nc aw nd bi"><span id="2088" class="mm ku in na b gy ne nf l ng nh">Output - { name: 'another test' }</span></pre><h2 id="0fc5" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">结论</h2><p id="4bd7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">JavaScript是一种令人惊讶的语言，当在深层使用时，它的所有实现都有其独特之处。最复杂的情况是当我们处理一个嵌套对象时，每个对象都有自己唯一的共享标识符。因此，建议使用您想要的引用，并始终创建一个带有<code class="fe nj nk nl na b">Object.assign</code>属性的嵌套对象，以避免冲突。</p><p id="a410" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">希望你今天学到好东西，开心编码！</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="8688" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="no">更多内容尽在</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="no">说白了. io </em> </strong> </a> <em class="no">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="no">免费周报</em> </strong> </a> <em class="no">。关注我们关于</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="no">推特</em> </strong> </a>，<a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="no">LinkedIn</em></strong></a><em class="no">，</em><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="no">YouTube</em></strong></a><em class="no">，</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="no">不和</em> </strong> </a> <em class="no">。</em></p></div></div>    
</body>
</html>