<html>
<head>
<title>TypeScript Decorator for Logging Analytics Event in Angular Using Monad Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Monad设计模式在Angular中记录分析事件的TypeScript装饰器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-decorator-for-logging-analytics-event-in-angular-using-monad-design-pattern-3241246b0c5d?source=collection_archive---------0-----------------------#2022-07-16">https://javascript.plainenglish.io/typescript-decorator-for-logging-analytics-event-in-angular-using-monad-design-pattern-3241246b0c5d?source=collection_archive---------0-----------------------#2022-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="dc93" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Logging Decorator使用Monad设计模式、解耦应用程序代码和日志逻辑来跟踪Angular中的分析事件。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/97aa9ff941f495a649078bc4b75c07c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3Sl4byqig1xVKTucQqReg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Monads, Monads Everywhere</figcaption></figure></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="2d31" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在每个web/移动应用程序中，当它扩展时，会有一个点需要记录API、用户行为跟踪、事件、分析、错误等。</p><p id="12ec" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">日志记录是在问题影响您的用户或组织之前进行故障排除和解决问题的最佳实践。</p><p id="617d" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">要做到这一点，对于每一个事件动作，你需要将事件分派到分析平台，比如Google analytics。</p><p id="1833" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">假设您有一个函数<code class="fe lv lw lx ly b">logEvent</code>,它将分析事件发送到如下服务:</p><pre class="kd ke kf kg gt lz ly ma mb aw mc bi"><span id="74ac" class="md me in ly b gy mf mg l mh mi">interface IEvent = {<br/>  eventName: string;<br/>  eventData: {<br/>    args: any;<br/>   };<br/>}</span><span id="17fa" class="md me in ly b gy mj mg l mh mi">const logEvent = (event: IEvent) =&gt; {<br/>  thirdPartyAnalyticsService.send(event)<br/>}</span><span id="ce91" class="md me in ly b gy mj mg l mh mi">const getUser = (userId) =&gt; {<br/> logEvent({eventName: 'submit'; eventData: { args: userId }});</span><span id="8d57" class="md me in ly b gy mj mg l mh mi"> result = getUserFromAPI() // .... do some operations<br/> return result;<br/>}</span></pre><p id="d5fe" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">如果你看上面的代码，你会很快注意到代码库将充满方法<code class="fe lv lw lx ly b">logEvent</code>混乱和重复无处不在，因为需求不断变化，很快就会有很多条件和混乱。</p><p id="a867" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这开始真的真的伤害你的眼睛，你开始在你的梦里看到<code class="fe lv lw lx ly b">logEvent</code>。😴哦，噩梦。😱</p><p id="264b" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">很长一段时间，当我偶然发现<code class="fe lv lw lx ly b">Monads</code>时，我正在寻找一种解决方案来干燥这段代码，这就是点开始连接的时候。👀</p><p id="c633" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这里有一个视频很好地解释了单子是什么:<a class="ae mk" href="https://www.youtube.com/watch?v=C2w45qRc3aU" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=C2w45qRc3aU</a></p><blockquote class="ml"><p id="8a1e" class="mm mn in bd mo mp mq mr ms mt mu lu dk translated">基本上，单子是一种设计模式，允许用户链接操作，同时单子在幕后管理秘密工作。</p></blockquote><p id="5a5a" class="pw-post-body-paragraph kz la in lb b lc mv jo le lf mw jr lh li mx lk ll lm my lo lp lq mz ls lt lu ig bi translated">这正是我们想要的，在幕后秘密地进行记录。🤐</p><h2 id="e965" class="md me in bd na nb nc dn nd ne nf dp ng li nh ni nj lm nk nl nm lq nn no np nq bi translated">单子有三个部分:</h2><ol class=""><li id="2854" class="nr ns in lb b lc nt lf nu li nv lm nw lq nx lu ny nz oa ob bi translated">包装类型</li><li id="fe1d" class="nr ns in lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">包裹功能:允许进入单子生态系统</li><li id="3bcc" class="nr ns in lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">运行函数:对一元值运行转换</li></ol><p id="70df" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">但这和我们的问题有关系吗？让我们看看如何使用包装函数来解决这个问题。</p><p id="115b" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这是一个高阶函数，稍微做了一点调整，我们也跟踪原始函数的结果。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="c619" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">如果你仔细观察<code class="fe lv lw lx ly b">logWrapper</code>功能，铃声开始响起，叮，丁丁，叮，叮…🔔</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7a83437c0d35887294178b1d1555d6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Xud0Qxo_z0v6YtbBVbreWw.gif"/></div></figure><blockquote class="ml"><p id="bfa6" class="mm mn in bd mo mp ok ol om on oo lu dk translated">瞧，装饰者们…</p></blockquote><p id="7188" class="pw-post-body-paragraph kz la in lb b lc mv jo le lf mw jr lh li mx lk ll lm my lo lp lq mz ls lt lu ig bi translated">这个函数看起来更像装饰者…🔮</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi op"><img src="../Images/6f80beab6988c6b26cc1421d5da03f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*3OrNhrZ5IEZw3DITwvPtoQ.jpeg"/></div></figure><p id="8009" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">所以你可能想知道装饰者和单子是不是一样的，简而言之它们不是。但这是以后的话题。🗣</p><p id="0706" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">回到我们的问题，模式看起来有点类似，我们可以创建一个<code class="fe lv lw lx ly b">logEvent</code>自定义的typescript方法装饰器，它完全满足相同的目的。代码将类似于下面这样。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="408f" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">通过上述方法，我们隔离了应用程序和分析代码。</p><p id="029b" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">虽然上面的代码看起来很完整，解决方案也运行良好，但是它有一些限制。考虑以下场景:</p><pre class="kd ke kf kg gt lz ly ma mb aw mc bi"><span id="b515" class="md me in ly b gy mf mg l mh mi">@Logger()<br/>getUser(userId) {<br/>  // say some extra data is required to perform api request and we <br/>  // also need to track that extra data.<br/>  const randomExtraData = Math.random();</span><span id="8bfa" class="md me in ly b gy mj mg l mh mi">  const result = getUserFromAPI(userId, randomExtraData);<br/>  return result;<br/>}</span></pre><p id="339c" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在上面的例子中，我们的<code class="fe lv lw lx ly b">Logger</code>装饰者可以访问<code class="fe lv lw lx ly b">userId</code>和<code class="fe lv lw lx ly b">result</code>，但是不能访问<code class="fe lv lw lx ly b">randomExtraData</code>。</p><p id="9681" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">使用我们现有的实现，我们将无法捕获<code class="fe lv lw lx ly b">randomExtraData</code>的值，并将其包含在传递给<code class="fe lv lw lx ly b">logEvent</code>的分析事件中。</p><p id="f603" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">换句话说，在应用程序代码函数体中构造的数据对<code class="fe lv lw lx ly b">logEvent</code>函数不可用，也不能包含在跟踪事件中。</p><p id="7114" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这个随机数据可以是任何东西，另一个函数调用的结果、网络请求、修改的数据等等。</p><p id="e097" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">为了实现这一点，我们需要做一些改变。</p><p id="931d" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">因为<code class="fe lv lw lx ly b">Logger</code>可以访问它所调用的函数的返回值，所以我们可以通过将返回类型从数字改为对象，在返回值中传递一些内部数据(在本例中为<code class="fe lv lw lx ly b">randomExtraData</code>)。</p><p id="33a1" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><em class="oq">接下来是我们创建“WrapperType”的部分。</em></p><pre class="kd ke kf kg gt lz ly ma mb aw mc bi"><span id="4e0d" class="md me in ly b gy mf mg l mh mi"><a class="ae mk" href="http://twitter.com/Logger" rel="noopener ugc nofollow" target="_blank">@Logger</a>()<br/>getUser(userId) {<br/>  const randomExtraData = Math.random();</span><span id="0292" class="md me in ly b gy mj mg l mh mi">  const result = getUserFromAPI(userId, randomExtraData);<br/>  return {<br/>     result: result,<br/>     __loggingInfo: {<br/>        eventName: 'getUserEvent',<br/>        eventData: {<br/>          args: userId,<br/>          result: result,<br/>          extraData: randomExtraData,<br/>        },<br/>     } as IEvent<br/>  }<br/>}</span></pre><p id="8de6" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">很好，解决了一个问题，但是有时我想在记录之前向现有的事件数据中添加额外的数据，或者对event data进行一些更改，但有时我不想这样做。</p><p id="e76e" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这个数据修改过程是特定于日志记录的，我不希望我的组件了解它，甚至不希望处理它。</p><p id="afc3" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">为了解决这个问题，我们可以在我们的<code class="fe lv lw lx ly b">Logger</code>装饰器中引入一个参数，它可以接受一个<em class="oq">构造函数</em>，该函数构造一个定制的分析事件有效负载，可能会添加一些额外的数据。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="968d" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">让我们看看这个的最终结果。</p><p id="cba3" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="lb io"> <em class="oq">记录器装饰器实现:</em> </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="4992" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="lb io"> <em class="oq">应用组件利用记录器装饰器:</em> </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="641f" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">此外，这里是展示上述记录器装饰器的<strong class="lb io"> Stackblitz示例</strong>，请继续查看。💻</p><div class="or os gp gr ot ou"><a href="https://stackblitz.com/edit/angular-ivy-2gym2w?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd io gy z fp oz fr fs pa fu fw im bi translated">萨达斯</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">基于@angular/animations、@angular/compiler、@angular/core、@angular/common的angular-cli项目…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">stackblitz.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi km ou"/></div></div></a></div><p id="9ac8" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">最后，我们简要讨论了Logger decorator的实现，该实现用于使用TypeScript decorator在Angular中跟踪分析数据。</p><p id="cc01" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">请在下面留下评论，让我知道其他各种方法，如果有的话，或者如果有任何即兴创作。我很乐意回答这些问题。</p><p id="f34f" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><strong class="lb io">参考文献:</strong></p><ol class=""><li id="246c" class="nr ns in lb b lc ld lf lg li pj lm pk lq pl lu ny nz oa ob bi translated"><a class="ae mk" href="https://sambernheim.com/blog/building-a-monad" rel="noopener ugc nofollow" target="_blank">建造单子</a>🗒<a class="ae mk" href="https://mobile.twitter.com/sambernheim" rel="noopener ugc nofollow" target="_blank">塞缪尔·伯恩海姆</a></li><li id="c577" class="nr ns in lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><a class="ae mk" href="https://youtu.be/C2w45qRc3aU" rel="noopener ugc nofollow" target="_blank">【Youtube】软件工程师对单子的最佳介绍</a>📹</li></ol></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="1e76" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><em class="oq">更多内容看</em> <a class="ae mk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="oq">说白了。报名参加我们的</em> <a class="ae mk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="oq">免费周报</em> </strong> </a> <em class="oq">。关注我们关于</em> <a class="ae mk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="oq">推特</em></strong></a><strong class="lb io"><em class="oq"/></strong><em class="oq">和</em><a class="ae mk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="oq">LinkedIn</em></strong></a><em class="oq">。查看我们的</em> <a class="ae mk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="oq">社区不和谐</em> </strong> </a> <em class="oq">加入我们的</em> <a class="ae mk" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="oq">人才集体</em> </strong> </a> <em class="oq">。</em></strong></a></p></div></div>    
</body>
</html>