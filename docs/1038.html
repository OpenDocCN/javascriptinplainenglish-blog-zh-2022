<html>
<head>
<title>Implement Hybrid Decorator Functions in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中实现混合装饰函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0?source=collection_archive---------17-----------------------#2022-02-28">https://javascript.plainenglish.io/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0?source=collection_archive---------17-----------------------#2022-02-28</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="880e" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如果小心处理，装饰者可以附加到许多对象类型</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/c7784b4dd7ee863be48c43771aa3fff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mPjqjirn2Oo6AbA9.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Image by Author using logos from corresponding projects</figcaption></figure><p id="84bc" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">关于TypeScript装饰器的文档描述了每种装饰器类型的函数签名。这意味着每个装饰器必须为特定的目标对象类型实现。但是，通过仔细定义的方法签名，我们可以构造装饰器来处理任何对象类型的装饰。</p><p id="4083" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在本文中，我们将讨论在TypeScript装饰函数中使用的各种函数签名。通过仔细检查参数，我们可以推断出装饰器附加到了哪种对象上。这是因为，如果我们查看装饰函数签名的完整列表，我们会注意到有一个模式。然后我们可以定义类型保护函数来检测哪个模式被使用，并且可靠地知道装饰器被附加到哪个对象类型。</p><p id="f49d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">使用函数来测试用于调用装饰函数的函数签名，我们可以确定它附加到哪种对象。这将允许装饰器用于任何对象类型。本文的目标是一个可以在所有五种上下文中使用的装饰器:类、属性、访问器、参数和方法</p><p id="90be" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这些功能在<a class="ae ls" href="https://www.npmjs.com/package/decorator-inspectors" rel="noopener ugc nofollow" target="_blank">装饰检查员</a>包中可用。</p><p id="864c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">本文是系列文章的一部分:</p><ul class=""><li id="07aa" class="lt lu ir ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">装修工入门</a></li><li id="a474" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae ls" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装修工</a></li><li id="c9ac" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">物业装修工</a></li><li id="03dd" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">访问器装饰器</a></li><li id="e059" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-parameter-decorators-in-typescript-b0042b5474ed">参数装饰器</a></li><li id="d141" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6">方法装饰者</a></li><li id="49b1" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky is">混合装修工</strong> <em class="mh">本条</em></li><li id="af61" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7">用装饰器使用反射和反射API</a></li><li id="079a" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5">使用装饰器进行运行时数据验证</a></li></ul><p id="6888" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">要使用decorator，必须在TypeScript中启用两个特性，所以请务必<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">阅读本系列的decorator介绍文章</a>。</p><h1 id="e872" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">TypeScript装饰函数的方法签名概述</h1><p id="24cc" class="pw-post-body-paragraph kw kx ir ky b kz na js lb lc nb jv le lf nc lh li lj nd ll lm ln ne lp lq lr ik bi translated">回顾一下本系列其他文章中使用的装饰函数签名，我们可以得到这些签名:</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="13c2" class="nk mj ir ng b gz nl nm l nn no">const accessorfunc = (target: Object,<br/>                         propertyKey: string,<br/>                         descriptor: PropertyDescriptor) =&gt; {};<br/>const constructorfunc = (constructor: Function) =&gt; {};  <br/>const methodsfunc = (target: Object, propertyKey: string,<br/>                     descriptor: PropertyDescriptor) =&gt; {};  <br/>const parametersfunc = (target: Object,<br/>                         propertyKey: string | symbol,<br/>                         parameterIndex: number) =&gt; {};  <br/>const propertiesfunc = (target: Object, member: string)  =&gt; {};</span></pre><p id="983c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">例如，类装饰器只接受一个参数，可以命名为<code class="fe np nq nr ng b">target</code>。属性装饰器只接受两个参数。其他三个装饰者有三个论点，他们之间有区别。parameters decorator在第三个参数中使用了一个<code class="fe np nq nr ng b">number</code>。访问器和方法装饰器都将一个<code class="fe np nq nr ng b">PropertyDescriptor</code>作为第三个参数，但是对象的构造方式有所不同。</p><p id="93bf" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">附属于访问器的装饰器接收一组参数，而附属于类的装饰器接收其他参数。每种装饰器类型的装饰器函数必须能够处理任何一组参数，并且能够区分不同的使用。</p><p id="9f87" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这意味着我们需要一个通用的函数签名来匹配每种装饰类型。</p><p id="30d5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">经过考虑和测试，我们决定采用这种方法来处理每种情况:</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="6fe6" class="nk mj ir ng b gz nl nm l nn no">(target: Object, propertyKey?: string | symbol, <br/>  descriptor?: number | PropertyDescriptor)</span></pre><p id="cbee" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe np nq nr ng b">target</code>参数是通用的，而另外两个是可选的。然后，对于另外两个，要适应的值有变化。此签名处理所有变体。</p><p id="e457" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这将是装饰函数的函数签名，可用于五种装饰类型中的任何一种。接下来需要的是类似于类型保护的函数来测试参数。</p><p id="51bb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">请记住，在TypeScript中，类型保护函数接受一个参数，并测试该参数以确保它属于某种类型。</p><h1 id="8088" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">混合装饰函数概念的测试用例</h1><p id="1460" class="pw-post-body-paragraph kw kx ir ky b kz na js lb lc nb jv le lf nc lh li lj nd ll lm ln ne lp lq lr ik bi translated">创建这个类定义是为了测试混合装饰函数是否可行。</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="1050" class="nk mj ir ng b gz nl nm l nn no">@Decorator class HybridDecorated {<br/>     @Decorator<br/>     prop1: number;</span><span id="1ec0" class="nk mj ir ng b gz ns nm l nn no">     @Decorator<br/>     prop2: string;</span><span id="a8d1" class="nk mj ir ng b gz ns nm l nn no">     @Decorator<br/>     method(<br/>         @Decorator param1: string,<br/>         @Decorator param2: string<br/>     ) {<br/>         console.log(`inside method function`);<br/>         return { param1, param2 };<br/>     }</span><span id="a28a" class="nk mj ir ng b gz ns nm l nn no">     #meaning: number = 42;<br/>     @Decorator<br/>     get meaning() { return this.#meaning; }<br/>     set meaning(nm: number) { this.#meaning = nm; } <br/>}</span></pre><p id="b647" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这需要一个函数<code class="fe np nq nr ng b">Decorator</code>，它成功地检测出它在哪个上下文中，或者换句话说，装饰函数附加到了哪种对象上。</p><h1 id="7459" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">原型化decorator来处理decorator使用的所有TypeScript</h1><p id="e6a3" class="pw-post-body-paragraph kw kx ir ky b kz na js lb lc nb jv le lf nc lh li lj nd ll lm ln ne lp lq lr ik bi translated">给定前面显示的通用函数签名，<code class="fe np nq nr ng b">Decorator</code>函数必须这样定义:</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="0a7b" class="nk mj ir ng b gz nl nm l nn no">function Decorator(target: Object,<br/>      propertyKey?: string | symbol,<br/>      descriptor?: number | PropertyDescriptor) {</span><span id="c565" class="nk mj ir ng b gz ns nm l nn no">     console.log(`Decorator target`, target);<br/>     console.log(`Decorator propertyKey`, propertyKey);<br/>     console.log(`Decorator descriptor`, descriptor);<br/>}</span></pre><p id="f71a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">实际上，如果您构建了一个包含上述类定义和这个<code class="fe np nq nr ng b">Decorator</code>实现的文件(例如<code class="fe np nq nr ng b">first.ts</code>，您将得到以下输出:</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="d688" class="nk mj ir ng b gz nl nm l nn no">$ npx ts-node lib/hybrid/first.ts <br/>Decorator target {} <br/>Decorator propertyKey prop1 <br/>Decorator descriptor undefined <br/>Decorator target {} <br/>Decorator propertyKey prop2 <br/>Decorator descriptor undefined <br/>Decorator target {} <br/>Decorator propertyKey method <br/>Decorator descriptor 1 <br/>Decorator target {} <br/>Decorator propertyKey method <br/>Decorator descriptor 0 <br/>Decorator target {} <br/>Decorator propertyKey method <br/>Decorator descriptor {<br/>   value: [Function: method],<br/>   writable: true,<br/>   enumerable: false,<br/>   configurable: true <br/>} <br/>Decorator target {} <br/>Decorator propertyKey meaning <br/>Decorator descriptor {<br/>   get: [Function: get meaning],<br/>   set: [Function: set meaning],<br/>   enumerable: false,<br/>   configurable: true <br/>} <br/>Decorator target [class HybridDecorated] <br/>Decorator propertyKey undefined <br/>Decorator descriptor undefined</span></pre><p id="18bd" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这证明了这个概念是可行的，TypeScript装饰函数可以成功地附加到所有五种可装饰的对象类型上。</p><h1 id="009b" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">测试混合装饰器所附着的对象类型</h1><p id="dfec" class="pw-post-body-paragraph kw kx ir ky b kz na js lb lc nb jv le lf nc lh li lj nd ll lm ln ne lp lq lr ik bi translated">以下功能来自<a class="ae ls" href="https://www.npmjs.com/package/decorator-inspectors" rel="noopener ugc nofollow" target="_blank">装饰检查员</a>包。</p><p id="8f34" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了使这些功能简单一点，我们从这个开始:</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="05bd" class="nk mj ir ng b gz nl nm l nn no">const isset = (val) =&gt; {<br/>     return typeof val !== 'undefined' &amp;&amp; val !== null; <br/>}; <br/>const notset = (val) =&gt; {<br/>     return (typeof val === 'undefined') || (val === null); <br/>};</span></pre><p id="27f4" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这些用于确保参数实际上有一个值。如果它不是<code class="fe np nq nr ng b">undefined</code>也不是<code class="fe np nq nr ng b">null</code>，那么它就有一个值。</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="8751" class="nk mj ir ng b gz nl nm l nn no">export const isClassDecorator = (target: Object,<br/>     propertyKey?: string | symbol,<br/>     descriptor?: number | PropertyDescriptor) =&gt; {</span><span id="b51d" class="nk mj ir ng b gz ns nm l nn no">    return (isset(target)<br/>          &amp;&amp; notset(propertyKey)<br/>          &amp;&amp; notset(descriptor)); <br/>};</span></pre><p id="1784" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">类装饰器只在第一个参数中有一个值。</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="dd5f" class="nk mj ir ng b gz nl nm l nn no">export const isPropertyDecorator = (target: Object,<br/>     propertyKey?: string | symbol,<br/>     descriptor?: number | PropertyDescriptor) =&gt; {</span><span id="7f62" class="nk mj ir ng b gz ns nm l nn no">      return (isset(target)<br/>          &amp;&amp; isset(propertyKey)<br/>          &amp;&amp; notset(descriptor)); <br/>};</span></pre><p id="284f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">属性装饰器只在前两个参数中有值。</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="a25f" class="nk mj ir ng b gz nl nm l nn no">export const isParameterDecorator = (target: Object,<br/>     propertyKey?: string | symbol,<br/>     descriptor?: number | PropertyDescriptor) =&gt; {</span><span id="35ee" class="nk mj ir ng b gz ns nm l nn no">      return (isset(target)<br/>          &amp;&amp; isset(propertyKey)<br/>          &amp;&amp; isset(descriptor)<br/>          &amp;&amp; typeof descriptor === 'number'); <br/>};</span></pre><p id="814b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">参数装饰器在三个参数中都有值，第三个是一个数字。</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="aeae" class="nk mj ir ng b gz nl nm l nn no">export const isMethodDecorator = (target: Object,<br/>     propertyKey?: string | symbol,<br/>     descriptor?: number | PropertyDescriptor) =&gt; {</span><span id="2c5d" class="nk mj ir ng b gz ns nm l nn no">     if ((isset(target)<br/>      &amp;&amp; isset(propertyKey)<br/>      &amp;&amp; isset(descriptor)<br/>      &amp;&amp; typeof descriptor === 'object')) {<br/>         const propdesc = &lt;PropertyDescriptor&gt;descriptor;<br/>         return (typeof propdesc.value === 'function');<br/>     } else {<br/>         return false;<br/>     } <br/>}</span></pre><p id="168b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">方法装饰器在所有三个参数中都有值，第三个参数是一个对象，即PropertyDescriptor。该描述符在<code class="fe np nq nr ng b">value</code>字段中存储了一个函数。</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="88b9" class="nk mj ir ng b gz nl nm l nn no">export const isAccessorDecorator = (target: Object,<br/>     propertyKey?: string | symbol,<br/>     descriptor?: number | PropertyDescriptor) =&gt; {</span><span id="bff1" class="nk mj ir ng b gz ns nm l nn no">     if ((isset(target)<br/>      &amp;&amp; isset(propertyKey)<br/>      &amp;&amp; isset(descriptor)<br/>      &amp;&amp; typeof descriptor === 'object')) {<br/>         const propdesc = &lt;PropertyDescriptor&gt;descriptor;<br/>         return (typeof propdesc.value !== 'function')<br/>          &amp;&amp; (typeof propdesc.get === 'function'<br/>           || typeof propdesc.set === 'function');<br/>     } else {<br/>         return false;<br/>     } <br/>}</span></pre><p id="adb1" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">访问器装饰器类似于方法装饰器。不同之处在于<code class="fe np nq nr ng b">value</code>字段没有功能，而<code class="fe np nq nr ng b">get</code>和/或<code class="fe np nq nr ng b">set</code>字段有功能。</p><h1 id="b03d" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">在混合装饰函数中使用装饰类型保护</h1><p id="33fb" class="pw-post-body-paragraph kw kx ir ky b kz na js lb lc nb jv le lf nc lh li lj nd ll lm ln ne lp lq lr ik bi translated">让我们演示如何构建一个装饰函数，使用这些函数处理所有五种场景:</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="f331" class="nk mj ir ng b gz nl nm l nn no">import {<br/>     isClassDecorator, isPropertyDecorator, isParameterDecorator,<br/>     isMethodDecorator, isAccessorDecorator <br/>} from 'decorator-inspectors';</span><span id="c085" class="nk mj ir ng b gz ns nm l nn no">function Decorator(target: Object, propertyKey?: string | symbol,<br/>     descriptor?: number | PropertyDescriptor) {</span><span id="75b9" class="nk mj ir ng b gz ns nm l nn no">     if (isClassDecorator(target, propertyKey, descriptor)) {<br/>         console.log(`Decorator called on class`, target);<br/>     } else if (isPropertyDecorator(target,<br/>                           propertyKey, descriptor)) {<br/>         console.log(`Decorator called on property ${target} ${String(propertyKey)}`);<br/>     } else if (isParameterDecorator(target,<br/>                           propertyKey, descriptor)) {<br/>         console.log(`Decorator called on parameter ${target} ${String(propertyKey)} ${descriptor}`);<br/>     } else if (isMethodDecorator(target,<br/>                           propertyKey, descriptor)) {<br/>         console.log(`Decorator called on method ${target} ${String(propertyKey)}`, descriptor);<br/>     } else if (isAccessorDecorator(target,<br/>                           propertyKey, descriptor)) {<br/>         console.log(`Decorator called on accessor ${target} ${String(propertyKey)}`, descriptor);<br/>     }<br/>     else {<br/>         console.error(`Decorator called on unknown thing`, target);<br/>         console.error(`Decorator called on unknown thing`, propertyKey);<br/>         console.error(`Decorator called on unknown thing`, descriptor);<br/>     } <br/>}</span></pre><p id="34b6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这将从<code class="fe np nq nr ng b">decorator-inspectors</code>包中导入功能。函数<code class="fe np nq nr ng b">Decorator</code>使用通用装饰方法签名。然后，它使用这些函数来确定在哪个上下文中使用它，并输出适当的消息。如果使用不当，底部的消息将会打印出来。</p><p id="9a69" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如果我们在上面显示的示例类中使用这个装饰函数，我们会得到以下输出:</p><pre class="kh ki kj kk gu nf ng nh ni aw nj bi"><span id="966b" class="nk mj ir ng b gz nl nm l nn no">$ npx ts-node lib/hybrid/second.ts  <br/>Decorator called on property [object Object] prop1 <br/>Decorator called on property [object Object] prop2 <br/>Decorator called on parameter [object Object] method 1 <br/>Decorator called on parameter [object Object] method 0 <br/>Decorator called on method [object Object] method {<br/>   value: [Function: method],<br/>   writable: true,<br/>   enumerable: false,<br/>   configurable: true <br/>} <br/>Decorator called on accessor [object Object] meaning {<br/>   get: [Function: get meaning],<br/>   set: [Function: set meaning],<br/>   enumerable: false,<br/>   configurable: true <br/>} <br/>Decorator called on class [class HybridDecorated]</span></pre><p id="9244" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如您所见，一切都被正确识别。消息打印的顺序恰好与<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">使用和实现TypeScript装饰器的深度介绍</a>中讨论的求值顺序相匹配</p><h1 id="4c66" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">摘要</h1><p id="a1c9" class="pw-post-body-paragraph kw kx ir ky b kz na js lb lc nb jv le lf nc lh li lj nd ll lm ln ne lp lq lr ik bi translated">在查看不同的TypeScript decorators包时，可以看到在多个对象类型上经常使用相同的decorator名称。要做到这一点，装饰器必须检查它的参数，以确定它在哪个上下文中使用。</p><p id="8139" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这些函数将使您能够在装饰函数中做同样的事情。</p><h1 id="2abc" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">关于作者</h1><p id="0734" class="pw-post-body-paragraph kw kx ir ky b kz na js lb lc nb jv le lf nc lh li lj nd ll lm ln ne lp lq lr ik bi translated"><a class="ae ls" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mh">大卫·赫伦</em> </strong> </a> <em class="mh">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl nt nu hv nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ik il im in io"><p id="6d6b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="mh">最初发表于</em><a class="ae ls" href="https://techsparx.com/nodejs/typescript/decorators/hybrid-decorators.html" rel="noopener ugc nofollow" target="_blank"><em class="mh">https://techsparx.com</em></a><em class="mh">。</em></p><p id="4479" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><em class="mh">更多内容请看</em> <a class="ae ls" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mh">说白了就是</em> </strong> </a> <em class="mh">。报名参加我们的</em> <a class="ae ls" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mh">免费每周简讯</em> </strong> </a> <em class="mh">。关注我们</em> <a class="ae ls" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mh">推特</em> </strong> </a> <em class="mh">和</em><a class="ae ls" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky is"><em class="mh">LinkedIn</em></strong></a><em class="mh">。加入我们的</em> <a class="ae ls" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky is"> <em class="mh">社区不和谐</em> </strong> </a> <em class="mh">。</em></p></div></div>    
</body>
</html>