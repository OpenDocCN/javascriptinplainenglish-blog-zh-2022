<html>
<head>
<title>Introducing Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中引入承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introducing-promises-in-javascript-62b7558aebf2?source=collection_archive---------5-----------------------#2022-05-12">https://javascript.plainenglish.io/introducing-promises-in-javascript-62b7558aebf2?source=collection_archive---------5-----------------------#2022-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f311" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">新手承诺循序渐进指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1d9095d681c35c92fda89f483cb56c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPuZgD_374s7JWW1miAXvw.jpeg"/></div></div></figure><p id="1930" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想看这篇文章的视频，可以在下面找到。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h2 id="afa1" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">什么是异步？</h2><p id="6409" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">通常，当你在JavaScript中听到承诺时，你也会听到<strong class="kt ir">异步</strong>这个词。什么是异步？首先，我们有同步，这意味着一步一步地执行。当你走路时，你把一只脚放在另一只脚的前面，除非你在跳跃，否则你不会同时做这两只脚。另一个例子是等水壶烧开后再泡茶。另一方面，异步意味着您可以在后台做其他事情，而不必停下来等待。这有点像说你可能会在等水壶烧开的时候看电视，而不是站着盯着水壶等它。</p><p id="96c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript是我们所说的单线程语言，这意味着一次只能发生一件事。异步JavaScript是后台任务(比如对服务器的请求)可以发生的方式，不会因为等待单个任务完成而导致一切都停止。这意味着异步任务在程序的主流程之外运行。</p><h2 id="9bfa" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">介绍承诺</h2><p id="1e3c" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">在你的日常生活中，你经常会在实际行动之前向人们承诺一些事情。也许你说，“我保证我会洗碗，”或者，“我保证我会买些牛奶。”这就是JavaScript中承诺的基本工作方式。当你使用承诺时，你通常是在编写异步代码，你是在为将要完成的事情做出承诺或交易。</p><p id="a95c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦承诺完成，那么任务要么完成，要么失败。这就像你要么履行了买牛奶的承诺，要么你忘记了，所以你的承诺失败了。</p><p id="f945" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你在承诺中工作时，有两部分需要理解。创造承诺，然后如何使用承诺。</p><h2 id="6c92" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">创造承诺</h2><p id="9433" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">承诺是一个构造函数，所以你必须使用<em class="mn"> new </em>关键字，当你创建一个承诺时，它就变成了<em class="mn"> Promise </em>。promise将一个函数作为带有两个参数的实参:<em class="mn"> resolve </em>和<em class="mn"> reject </em>。</p><p id="2c2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Resolve和reject是可以调用的函数，因此需要用括号来执行它们。解决和拒绝用来决定当承诺运行时会发生什么。让我们看看创建承诺的基本语法。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="eef2" class="lp lq iq mp b gy mt mu l mv mw">const ourPromise = new Promise((resolve, reject) =&gt; {</span><span id="255c" class="lp lq iq mp b gy mx mu l mv mw">});</span><span id="4ce3" class="lp lq iq mp b gy mx mu l mv mw">console.log(ourPromise);</span></pre><p id="75bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们使用const并声明一个名为<em class="mn"> ourPromise </em>的变量。最初，这是未初始化的，但是我们使用关键字<em class="mn"> new </em>和<em class="mn"> Promise </em> (promise是一个构造函数)。我们传入<em class="mn">解决</em>和<em class="mn">拒绝</em>参数。下图显示了<em class="mn">我们的承诺</em>的控制台日志结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/d8e0ed7862fc7dfbb90834df14a3ff80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lB2pZzrYGqvlTak0VDHp-g.png"/></div></div></figure><h2 id="6d0b" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">承诺状态</h2><p id="d10d" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">承诺有三种状态。待定、已完成和已拒绝。我们创建的<em class="mn"> ourPromise </em>不解决或拒绝任何事情，因此它将无限期地保持在待定状态。有点像有人等着你出去买你的牛奶。</p><p id="002f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了完成一个承诺，我们使用解决或拒绝。解决意味着承诺成功，拒绝意味着失败。任何参数都可以被传递到resolve和reject中，但通常当我们处理承诺时，我们会发出数据请求，所以它是一个可以从中提取数据的对象。</p><h2 id="86c4" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">解决和拒绝</h2><p id="95a9" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">让我们更新我们的例子，以显示解决然后拒绝承诺的结果。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="0493" class="lp lq iq mp b gy mt mu l mv mw">const ourPromise = new Promise((resolve, reject) =&gt; {<br/>  resolve();<br/>});</span><span id="1915" class="lp lq iq mp b gy mx mu l mv mw">console.log(ourPromise);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/57a6421d46c3e3a6c12b824e4d265009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPCTFdl0NowAbVj-yr6gwA.png"/></div></div></figure><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="27f5" class="lp lq iq mp b gy mt mu l mv mw">const ourPromise = new Promise((resolve, reject) =&gt; {<br/>  reject();<br/>});</span><span id="7377" class="lp lq iq mp b gy mx mu l mv mw">console.log(ourPromise);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/77df10ccdc460d536f45fa695580a2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bz0tnBhtSmsLlHpshoCfqQ.png"/></div></div></figure><p id="1013" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们下定决心实现我们的承诺时，这个状态就实现了。当我们拒绝它时，这个状态就被拒绝了。现在，我们还将更新我们的示例，以便更好地表示请求。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="8417" class="lp lq iq mp b gy mt mu l mv mw">const ourPromise = new Promise((resolve, reject) =&gt; {<br/>  let didGetMilk = true;<br/>  <br/>  if(didGetMilk) {<br/>    resolve("We got the milk");<br/>  } else {<br/>    reject("Ooops we did not get the milk");<br/>  }<br/>});</span><span id="383c" class="lp lq iq mp b gy mx mu l mv mw">console.log(ourPromise);<br/>//Returns ---&gt; Promise {&lt;fulfilled&gt;: 'We got the milk'}</span></pre><p id="bdb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们创建了一个名为<em class="mn"> didGetMilk </em>的变量，它可以伪造来自服务器的响应。出于演示目的，我们将此设置为true。然后，我们使用一个if/else语句，该语句根据变量<em class="mn"> didGetMilk </em>的值来解析或拒绝承诺。</p><p id="c5d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们因为<em class="mn"> didGetMilk </em>为真而运行这个函数时，承诺会随着消息一起被解析。如果我们将<em class="mn"> didGetMilk </em>设置为false，承诺将被拒绝，如下例所示。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="2081" class="lp lq iq mp b gy mt mu l mv mw">const ourPromise = new Promise((resolve, reject) =&gt; {<br/>  let didGetMilk = false;<br/>  <br/>  if(didGetMilk) {<br/>    resolve("We got the milk");<br/>  } else {<br/>    reject("Ooops we did not get the milk");<br/>  }<br/>});</span><span id="1237" class="lp lq iq mp b gy mx mu l mv mw">console.log(ourPromise);<br/>//Returns ---&gt; Promise {&lt;rejected&gt;: 'Ooops we did not get the milk'}</span></pre><h2 id="6e7a" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">使用承诺和理解</h2><p id="b790" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">一旦承诺被解决，我们可以使用<em class="mn">然后</em>来运行代码。<em class="mn">那么</em>是一个在承诺完成后立即执行的方法。</p><p id="96df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以向<em class="mn">传递一个回调函数，然后向</em>传递一个回调函数，这个回调函数的代码将在承诺兑现后运行。让我们更新我们的例子来说明这一点。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="1280" class="lp lq iq mp b gy mt mu l mv mw">const ourPromise = new Promise((resolve, reject) =&gt; {<br/>  let didGetMilk = true;<br/>  <br/>  if(didGetMilk) {<br/>    resolve("We got the milk")<br/>  } else {<br/>    reject("Ooops we did not get the milk");<br/>  }<br/>});</span><span id="e65a" class="lp lq iq mp b gy mx mu l mv mw">ourPromise.then(res =&gt; {<br/>  console.log(res, "RES");<br/>});</span><span id="3802" class="lp lq iq mp b gy mx mu l mv mw">console.log(ourPromise);<br/>//Returns ---&gt; <br/>Promise {&lt;fulfilled&gt;: 'We got the milk'}<br/>We got the milk RES</span></pre><p id="b5d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们将<em class="mn"> didGetMilk </em>设置回true，这样承诺将被解析。我们继续使用<em class="mn">然后</em>的方法来实现我们的承诺。我们为结果设置了一个参数<em class="mn"> res </em>,并且我们控制台记录了这个结果。</p><p id="a768" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当promise运行时，我们得到已履行的状态，但我们也看到打印的<em class="mn"> res </em>参数。<em class="mn"> res </em>从我们给resolve方法的参数中传递。让我们改变我们给出的论点来巩固我们对此的理解。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="da08" class="lp lq iq mp b gy mt mu l mv mw">const ourPromise = new Promise((resolve, reject) =&gt; {<br/>  let didGetMilk = true;<br/>  <br/>  if(didGetMilk) {<br/>    resolve({message: "We got the milk"})<br/>  } else {<br/>    reject("Ooops we did not get the milk");<br/>  }<br/>});</span><span id="d814" class="lp lq iq mp b gy mx mu l mv mw">ourPromise.then(res =&gt; {<br/>  console.log(res.message, "RES");<br/>});</span><span id="449f" class="lp lq iq mp b gy mx mu l mv mw">console.log(ourPromise);<br/>//Returns ---&gt; <br/>Promise {&lt;fulfilled&gt;: 'We got the milk'}<br/>We got the milk RES</span></pre><p id="484a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们改变了传递的参数，以解析为一个对象。该对象有一个以字符串为值的<em class="mn">消息</em>键。我们更新<em class="mn">的控制台日志，然后</em>回调以打印来自对象的<em class="mn">消息</em>。</p><h2 id="3157" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">捕捉</h2><p id="3842" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">当承诺被拒绝时，我们通过使用<em class="mn"> catch </em>来处理。这与我们使用<em class="mn">然后使用</em>来解决承诺的方式类似。<em class="mn"> Catch </em>承诺被拒绝后会立即执行。让我们看一个例子。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="a5fa" class="lp lq iq mp b gy mt mu l mv mw">const ourPromise = new Promise((resolve, reject) =&gt; {<br/>  let didGetMilk = false;<br/>  <br/>  if(didGetMilk) {<br/>    resolve({message: "We got the milk"})<br/>  } else {<br/>    reject("Ooops we did not get the milk");<br/>  }<br/>});</span><span id="447d" class="lp lq iq mp b gy mx mu l mv mw">ourPromise<br/>.then(res =&gt; {<br/>  console.log(res.message, "RES");<br/>})<br/>.catch(error =&gt; {<br/>  console.log(error);<br/>})</span><span id="4625" class="lp lq iq mp b gy mx mu l mv mw">console.log(ourPromise);<br/>//Returns ---&gt; <br/>Promise {&lt;rejected&gt;: 'Ooops we did not get the milk'}<br/>Ooops we did not get the milk</span></pre><p id="6dc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这一次，当代码运行时，承诺被拒绝，因此catch中的代码得到运行，我们得到传递给调用reject的参数，并打印到控制台。</p><p id="2cd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢这篇文章，请随时发表任何意见，问题或反馈，并关注我的更多内容！</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="1cbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mn">更多内容请看</em><a class="ae ni" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mn">plain English . io</em></strong></a><em class="mn">。报名参加我们的</em> <a class="ae ni" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mn">免费周报</em> </strong> </a> <em class="mn">。关注我们关于</em><a class="ae ni" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mn">Twitter</em></strong></a><em class="mn">和</em><a class="ae ni" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mn">LinkedIn</em></strong></a><em class="mn">。查看我们的</em> <a class="ae ni" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mn">社区不和谐</em> </strong> </a> <em class="mn">加入我们的</em> <a class="ae ni" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mn">人才集体</em> </strong> </a> <em class="mn">。</em></p></div></div>    
</body>
</html>