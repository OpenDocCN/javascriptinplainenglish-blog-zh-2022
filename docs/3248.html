<html>
<head>
<title>JavaScript Algorithms: Sort an Array (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:对数组排序(LeetCode)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithms-sort-an-array-leetcode-9eb6126d465d?source=collection_archive---------5-----------------------#2022-08-12">https://javascript.plainenglish.io/javascript-algorithms-sort-an-array-leetcode-9eb6126d465d?source=collection_archive---------5-----------------------#2022-08-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/af123a3e8d40ca14649e4bf60674f404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qBsHS4RKAbsVyFkDM9oEGw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@utakaha?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Yukitaka Iha</a> on <a class="ae jz" href="https://unsplash.com/s/photos/sorting-array?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5ffc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">排序算法是一种排列列表元素的算法。最常用的顺序是数字顺序和字典顺序，以及升序或降序。</p><p id="5c85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我们将探索不同的排序算法，并考虑问题<a class="ae jz" href="https://leetcode.com/problems/sort-an-array/" rel="noopener ugc nofollow" target="_blank">排序来自Leetcode的数组</a></p><h2 id="23e6" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">描述</h2><p id="85ba" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">给定一个整数数组<code class="fe lw lx ly lz b">nums</code>，按升序对数组排序。</p><p id="3066" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例1: </strong></p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="bfcb" class="ky kz in lz b gy mi mj l mk ml"><strong class="lz io">Input:</strong> nums = [5,2,3,1]<br/><strong class="lz io">Output:</strong> [1,2,3,5]</span></pre><p id="96ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例二:</strong></p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="085e" class="ky kz in lz b gy mi mj l mk ml"><strong class="lz io">Input:</strong> nums = [5,1,1,2,0,0]<br/><strong class="lz io">Output:</strong> [0,0,1,1,2,5]</span></pre><p id="9d58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">约束:</strong></p><ul class=""><li id="ca0a" class="mm mn in kc b kd ke kh ki kl mo kp mp kt mq kx mr ms mt mu bi translated"><code class="fe lw lx ly lz b">1 &lt;= nums.length &lt;= 5 * 104</code></li><li id="496f" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated"><code class="fe lw lx ly lz b">-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li></ul><p id="05cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">解决方案</strong></p><p id="ba26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解决这个问题有几种选择:</p><h1 id="0b85" class="na kz in bd la nb nc nd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq bi translated">冒泡排序</h1><p id="c640" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">冒泡排序是最简单的排序算法，如果相邻元素的顺序不对，它会重复交换相邻元素。该算法不适合大数据集，因为它具有时间复杂度<em class="nr"> O(n)和空间复杂度</em>:<em class="nr">O(1)</em>。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fbd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们前面讨论过的没有优化的冒泡排序的实现。即使数组被排序，代码运行的复杂度也是O(n)。让我们看看如何实现一个优化的冒泡排序算法。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="9c77" class="na kz in bd la nb nc nd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq bi translated">快速排序</h1><p id="033a" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">快速排序是一种基于<a class="ae jz" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分治算法</a>原理的排序算法。</p><ul class=""><li id="68c0" class="mm mn in kc b kd ke kh ki kl mo kp mp kt mq kx mr ms mt mu bi translated">通过选择参考元素(从阵列中选择的元素)将阵列分成子阵列。分割数组时，必须定位锚点元素，使小于锚点的元素留在锚点的左侧(<strong class="kc io"> <em class="nr">小于</em> </strong>)，大于锚点的元素留在锚点的右侧(<strong class="kc io"> <em class="nr">大于</em> </strong>)。</li><li id="b79a" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">少于<strong class="kc io"><em class="nr"/></strong>和多于<strong class="kc io"><em class="nr"/></strong>的右侧也使用相同的方法分割。这个过程一直持续到每个子阵列包含一个元素。</li><li id="c37d" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">最后，这些元素被连接成一个有序的数组。</li></ul><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/02a0b2a048f6d79ec9e59f8421e93b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*pFKXbxyYKeDqGwnbAB4k9g.png"/></div></figure><p id="3adf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">时间复杂度<em class="nr"> O(n⋅log(n))和s </em>步速复杂度:<em class="nr"> O( </em> l <em class="nr"> og(n)) </em>。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="9875" class="na kz in bd la nb nc nd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq bi translated"><strong class="ak">合并排序</strong></h1><p id="4ccb" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">合并排序是最流行的排序算法之一，也是基于<a class="ae jz" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分治算法</a>的原理。</p><p id="a969" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，一个问题被分成多个子问题。每个子问题单独解决。最后将子问题组合起来形成最终解。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/427ad99dfffd0681445d0234cbf86499.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*Rc9W1A-OlaeS6ZQetvI8xA.png"/></div></figure><p id="3294" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">时间复杂度<em class="nr"> O(n⋅log(n))和s </em>步速复杂度:<em class="nr"> O(n) </em>。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f6ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有其他排序算法也可以解决这个问题，但今天我们考虑了最流行的方法。</p><p id="70cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望对你有用！</p><p id="753c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！回头见。😊</p><p id="6dba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nr">更多内容看</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nr">说白了就是</em> </strong> </a> <em class="nr">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nr">免费周报</em> </strong> </a> <em class="nr">。关注我们关于</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nr">推特</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nr">领英</em></strong></a><strong class="kc io"><em class="nr"/></strong><em class="nr">和</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nr">不和</em> </strong> </a> <strong class="kc io"> <em class="nr">。</em>T49】</strong></p></div></div>    
</body>
</html>