<html>
<head>
<title>NgRx ComponentStore Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NgRx组件存储示例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/ngrx-componentstore-example-2dd5abf225a9?source=collection_archive---------1-----------------------#2022-12-13">https://javascript.plainenglish.io/ngrx-componentstore-example-2dd5abf225a9?source=collection_archive---------1-----------------------#2022-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7bca" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">NgRx组件库介绍及实例</h2></div><p id="65ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ComponentStore是一个帮助管理组件状态的状态管理库。<a class="ae lb" href="https://ngrx.io/guide/component-store#ngrxcomponent-store" rel="noopener ugc nofollow" target="_blank"> ComponentStore </a>是NgRx的一部分，它将自己定位为“<em class="lc">基于被动推送的“主题服务”方法的替代方案。</em>”</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/c2e1aa6b7e7cfd55dcfbd177bf90618a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNOmt-bA43VL0X2T749JXA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">NGRX homepage</figcaption></figure><p id="f4cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">了解NgRx 、Redux或其他状态管理模式会有所帮助，但是这篇文章解释NGRX ComponentStore时假设没有NgRx知识。</p><h1 id="82ef" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">NGRX ComponentStore是什么？</h1><p id="21bf" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">ComponentStore是一个状态管理工具，允许开发人员在组件级别轻松管理状态(例如本地状态)，而不必在整个应用程序中全局管理它。</p><p id="de83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得推断单个组件的状态以及以可伸缩和可维护的方式实现复杂的状态管理场景变得更加容易。</p><h2 id="8d40" class="mq lu iq bd lv mr ms dn lz mt mu dp md ko mv mw mf ks mx my mh kw mz na mj nb bi translated">关键概念</h2><p id="a2c1" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated"><a class="ae lb" href="https://ngrx.io/guide/component-store" rel="noopener ugc nofollow" target="_blank">官方文档</a>出色地报告了NGRX ComponentStore的关键概念:</p><ul class=""><li id="b51d" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">本地状态必须被初始化，但是可以延迟完成。</li><li id="77dd" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">本地状态通常与特定组件的生命周期相关联，并在该组件被销毁时被清除。</li><li id="9b49" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">ComponentStore的用户可以通过<code class="fe nq nr ns nt b">setState</code>或<code class="fe nq nr ns nt b">updater</code>来更新状态，要么强制更新，要么通过提供一个可观察对象来更新。</li><li id="5c44" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">ComponentStore的用户可以通过<code class="fe nq nr ns nt b"><a class="ae lb" href="https://ngrx.io/api/store/select" rel="noopener ugc nofollow" target="_blank">select</a></code>或顶级<code class="fe nq nr ns nt b"><a class="ae lb" href="https://ngrx.io/api/component-store/ComponentStore#state$" rel="noopener ugc nofollow" target="_blank">state$</a></code>读取状态。选择器是非常高效的。</li><li id="c6d1" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">ComponentStore的用户可以用<code class="fe nq nr ns nt b"><a class="ae lb" href="https://ngrx.io/api/effects/EffectNotification#effect" rel="noopener ugc nofollow" target="_blank">effect</a></code>开始副作用，同步和异步都可以，并强制或被动地输入数据。</li></ul><h1 id="046c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">什么时候应该使用ComponentStore？</h1><p id="9a94" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">这取决于您的应用程序的复杂性。</p><p id="c3b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果场景是一个简单的父/子结构，我们可能会选择<code class="fe nq nr ns nt b">@<a class="ae lb" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">Input</a>()</code>和<code class="fe nq nr ns nt b">@<a class="ae lb" href="https://angular.io/api/core/Output" rel="noopener ugc nofollow" target="_blank">Output</a>()</code>装饰器。然而，这很快就会变得疯狂。尤其是当父组件和子组件之间有多个组件时。</p><p id="4fd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当应用变得复杂时，状态管理可能是更好的方法。在这种情况下，NgRx或者它的轻量级版本ComponentStore应该是维护单一事实来源和组件间通信的首选方式。</p><p id="a731" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<a class="ae lb" href="https://ngrx.io/guide/component-store/comparison" rel="noopener ugc nofollow" target="_blank"> Store和ComponentStore </a>的详细对比。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nu"><img src="../Images/80d1bb5e07f408dc8972b5dad8c767ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOyhB3yX9lYxfsmSCTpzKQ.png"/></div></div></figure><p id="599c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，如果您正在构建一个Angular应用程序，并且希望以一种可预测和可伸缩的方式管理状态，NGRX/ComponentStore可能是一个不错的选择。</p><p id="1020" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，需要注意的是，NGRX/ComponentStore只是Angular应用程序中管理状态的众多选项之一，在决定它是否适合您之前，您应该考虑您的特定需求和用例。</p><h1 id="17d4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">NgRx组件存储示例</h1><p id="1ad3" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们将创建一个应用程序来跟踪三个桶中的一些书的状态:愿望清单，阅读和历史。这三个桶代表</p><ul class=""><li id="aed2" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">你想读的书，</li><li id="a1e4" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">你正在读的那些，</li><li id="e642" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">还有你读过的那些。</li></ul><p id="02b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序有一个名为BooksComponent的组件，它包含三个子组件:</p><ul class=""><li id="e968" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">WishListComponent，</li><li id="a766" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">正在读取组件，</li><li id="e66f" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">历史组件。</li></ul><p id="45e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该商店位于一个名为books.store.ts的文件中，并且位于BooksComponent中。</p><p id="80b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个子组件都是相似的，但是我想让它们保持独立，以避免混淆。</p><p id="fac7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你当然可以重构应用程序来使用同一个组件的三个实例，但这不是本文的目的。</p><p id="4e10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是app结构。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nv"><img src="../Images/c5df8282202fb14e3d3da2e90103acf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0XoxLImE2UzXg82_WhyEQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">App structure</figcaption></figure><h2 id="6615" class="mq lu iq bd lv mr ms dn lz mt mu dp md ko mv mw mf ks mx my mh kw mz na mj nb bi translated">安装组件存储</h2><p id="8bf2" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">首先，在您的项目中安装ComponentStore。</p><p id="fbf4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用的是<code class="fe nq nr ns nt b">ng add</code>，但是如果你喜欢，你也可以<a class="ae lb" href="https://ngrx.io/guide/component-store/install#installing-with-npm" rel="noopener ugc nofollow" target="_blank">用npm或者yarn </a>。</p><pre class="le lf lg lh gt nw nt nx ny aw nz bi"><span id="2ce9" class="mq lu iq nt b gy oa ob l oc od">ng add <a class="ae lb" href="http://twitter.com/ngrx/component-store" rel="noopener ugc nofollow" target="_blank">@ngrx/component-store</a>@latest</span></pre><p id="cace" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会无意中发现以下警告</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi oe"><img src="../Images/e128bbea2178a86a9be7d2e429948454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wjy9-vlT7VfhKWUF5wSANA.png"/></div></div></figure><p id="dd2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的例子中，这产生了以下错误</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi of"><img src="../Images/9fe78460688a8bfb633e59e0a9d7f0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tByqXLVkZwLGOaH2gSrxxQ.png"/></div></div></figure><p id="4f08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用的是老版本的rxjs。</p><p id="10e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦您在package.json中将rxjs版本更新到<code class="fe nq nr ns nt b">^7.5.0</code>并运行<code class="fe nq nr ns nt b">npm install</code>，您就准备好安装ComponentStore了。</p><h2 id="2ded" class="mq lu iq bd lv mr ms dn lz mt mu dp md ko mv mw mf ks mx my mh kw mz na mj nb bi translated">初始化ComponentStore: BooksStore</h2><p id="58d2" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">根据文档，ComponentStore可以通过两种方式初始化:</p><ul class=""><li id="c0de" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated"><strong class="kh ir">通过构造函数</strong>—通过将初始状态传递给构造函数。这发生在ComponentStore内部</li><li id="4cfa" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><strong class="kh ir">使用惰性加载</strong> —通过调用<code class="fe nq nr ns nt b">setState</code>并传递一个匹配状态接口的对象。这发生在组件的类内部，而不是在ComponentStore中。</li></ul><p id="b425" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，我将从前者开始，商店的名称将是BooksStore。</p><p id="61cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以按照文档选择组件库的<a class="ae lb" href="https://ngrx.io/guide/component-store/initialization#lazy-initialization" rel="noopener ugc nofollow" target="_blank">惰性初始化。</a></p><p id="fafb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 1。创建ComponentStore文件:books.store.ts </strong></p><p id="9977" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从在我们创建的文件中创建ComponentStore开始，例如books.store.ts。该文件是books.component.ts的兄弟文件，将位于BooksComponent中。</p><p id="f75f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从现在开始，我将交替使用ComponentStore和BooksStore这两个术语，因为后者是ComponentStore的一种表示。</p><p id="ed7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 2。进口</strong></p><p id="73c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在BooksStore的开始，导入可注入的decorator和ComponentStore。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="9e96" class="oj lu iq nt b be ok ol l om od">import { Injectable } from '@angular/core';<br/>import { ComponentStore } from '@ngrx/component-store';</span></pre><p id="ac45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 3。初始化书店</strong></p><p id="9d52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以通过构造函数初始化BooksStore。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="c043" class="oj lu iq nt b be ok ol l om od">type BooksState {<br/>  wishList: string[];<br/>  reading: string[];<br/>  history: string[];<br/>}<br/><br/>const initialState = {<br/>  wishList: ['Oksi', 'The Pragmatic Programmer', 'Let My People Go Surfing'],<br/>  reading: ['4000 Weeks'],<br/>  history: ['Zero To One', 'Extreme Economies'],<br/>};<br/><br/>@Injectable()<br/>export class BooksStore extends ComponentStore&lt;BooksState&gt; {<br/>  constructor() {<br/>    super(initialState);<br/>  }<br/>}</span></pre><p id="721e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在初始化存储并传递一个名为<code class="fe nq nr ns nt b">initialState</code>的变量，该变量是一个包含三个键(愿望列表、阅读、历史)和一些表示与每个键相关的书名的字符串的对象。</p><p id="1ae4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">"<em class="lc">通过构造函数进行初始化使得ComponentStore使用者可以立即使用状态。</em></p><p id="6074" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，您可以将商店视为扩展ComponentStore的服务。然而，在这种情况下，我们并没有像服务中经常发生的那样，在“根”中提供它。</p><p id="b277" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，我们有了一个基本的store设置，可以将它注入BooksComponent，这样BooksComponent的所有子组件都可以使用相同的store实例。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="ea41" class="oj lu iq nt b be ok ol l om od">// books.component.ts<br/><br/>import { Component } from '@angular/core';<br/>import { BooksStore } from './books.store';<br/><br/>@Component({<br/>  selector: 'app-books',<br/>  templateUrl: './books.component.html',<br/>  styleUrls: ['./books.component.css'],<br/>  providers: [BooksStore],<br/>})<br/>export class BooksComponent {}</span></pre><p id="fe07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BooksComponent几乎是空的，但是我们需要它在providers数组中注入BooksStore，使BooksComponent的所有子组件都可以使用这个存储。</p><h2 id="b8e3" class="mq lu iq bd lv mr ms dn lz mt mu dp md ko mv mw mf ks mx my mh kw mz na mj nb bi translated">阅读状态</h2><p id="6242" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在我们想从子组件中读取存储中的状态。此外，我们希望每个组件只能读取状态的相关子集。</p><p id="fa02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">WishListComponent不需要知道HistoryComponent中有多少本书，其他组件也是如此。</p><p id="723c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我希望WishListComponent读取BooksStore中状态的子集。</p><p id="951a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 1。准备书店公开数据</strong></p><p id="e309" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe nq nr ns nt b">select</code>方法来<a class="ae lb" href="https://ngrx.io/guide/component-store/read#select-method" rel="noopener ugc nofollow" target="_blank">读取BooksStore中的状态</a>，并使wishList$属性在其他组件中可用。<code class="fe nq nr ns nt b">$</code>符号是一种约定，表示该属性是可观察的。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="ca23" class="oj lu iq nt b be ok ol l om od">@Injectable()<br/>export class BooksStore extends ComponentStore&lt;BooksState&gt; {<br/>  <br/>  readonly wishList$: Observable&lt;string[]&gt; = this.select(<br/>    (state) =&gt; state.wishList<br/>  );<br/>...</span></pre><p id="8b36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 2。读取WishListComponent中的状态数据</strong></p><p id="2672" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在WishListComponent中有三件事要做。</p><ul class=""><li id="ce78" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">导入组件中的存储、</li><li id="2285" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">在构造函数中声明存储，</li><li id="8016" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">使用商店获取我们需要的财产</li></ul><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="7a1c" class="oj lu iq nt b be ok ol l om od">import { Component } from '@angular/core';<br/>import { BooksStore } from '../books.store';<br/><br/>@Component({<br/>  selector: 'app-wish-list',<br/>  templateUrl: './wish-list.component.html',<br/>  styleUrls: ['./wish-list.component.css'],<br/>})<br/>export class WishListComponent {<br/>  wishList$ = this.booksStore.wishList$; // access data in store <br/><br/>  constructor(private readonly booksStore: BooksStore) {}<br/>}</span></pre><p id="2ed7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">wishList$属性是一个可观察对象，可以在模板中用来列出属于州的愿望列表部分的书籍。</p><p id="63ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于wishList$属性是可观察的，我们可以如下使用<a class="ae lb" href="https://betterprogramming.pub/go-reactive-with-angular-async-pipe-b290988f4000" rel="noopener ugc nofollow" target="_blank">异步管道</a>。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="9216" class="oj lu iq nt b be ok ol l om od">&lt;li *ngFor="let book of wishList$ | async"&gt;{{ book }}&lt;/li&gt;</span></pre><p id="e9d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于ReadingComponent和HistoryComponent，我们可以重复这两个步骤(公开存储中的数据和读取组件中的数据)。</p><p id="cd1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，我们应该得到类似下面这样的东西。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi on"><img src="../Images/aaa96a477191af2b40b9a1fdbb910c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgWEZ7enizSyjxi8Q4r26Q.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Child components read data from the state in BooksStore</figcaption></figure><h2 id="7660" class="mq lu iq bd lv mr ms dn lz mt mu dp md ko mv mw mf ks mx my mh kw mz na mj nb bi translated">更新状态</h2><p id="86d9" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">如文档中所述，有三种方法可以更新组件存储中的状态:</p><ul class=""><li id="7a33" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">在商店中创建一个<code class="fe nq nr ns nt b">updater</code>,并通过它传递输入</li><li id="b595" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">使用组件中的<code class="fe nq nr ns nt b">setState</code></li><li id="f5b4" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">从组件中使用<code class="fe nq nr ns nt b">patchState</code></li></ul><p id="5e70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，我们将探索更新ComponentStore中数据的第一种和第二种方法。</p><p id="78c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击愿望列表中的任何一本书，使用<code class="fe nq nr ns nt b">updater</code>将该书移至阅读列表。</p><p id="c205" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击阅读列表中的任何一本书，使用<code class="fe nq nr ns nt b">setState</code>将该书移至历史列表。</p><ol class=""><li id="6ef0" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la oo ni nj nk bi translated"><strong class="kh ir">更新器</strong></li></ol><p id="3024" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://ngrx.io/guide/component-store/write#updater-method" rel="noopener ugc nofollow" target="_blank">更新器</a> " <em class="lc">采用一个纯函数，以当前状态和值作为参数，应该返回新的状态，不变地更新。</em></p><p id="206a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在书店里，我们可以创建一个<code class="fe nq nr ns nt b">updater</code>，这样当它被触发时，就会把一本书从愿望清单移到阅读清单。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="30d4" class="oj lu iq nt b be ok ol l om od">// books.store.ts<br/><br/>...<br/>readonly moveToReading = this.updater((state, title: string) =&gt; ({<br/>    ...state,<br/>    wishList: [<br/>      ...state.wishList.filter((titleInList) =&gt; titleInList !== title),<br/>    ],<br/>    reading: [...state.reading, title],<br/>}));</span></pre><p id="7a2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">状态是不可变的，因此我们不能将新的属性直接赋给状态，否则变化检测器和选择器将检测不到变化。</p><p id="b3e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么我使用数组析构来“复制粘贴”旧的状态，然后修改它来创建新的数组，这些数组被分配给wishList和reading keys。</p><p id="1d3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新程序准备好了。我们可以在WishListComponent中创建一个方法来调用商店中的更新程序。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="e298" class="oj lu iq nt b be ok ol l om od">// wish-list.component.ts<br/><br/>handleClick(title: string) {<br/>    this.booksStore.moveToReading(title);<br/>}</span></pre><p id="bb7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用户点击书名时，模板调用<code class="fe nq nr ns nt b">handleClick</code>方法。</p><p id="6a40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nq nr ns nt b">handleClick</code>方法获取书名并将其传递给<code class="fe nq nr ns nt b">updater</code>。逻辑在组件之外。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="bab6" class="oj lu iq nt b be ok ol l om od">&lt;!-- wish-list.component.html --&gt;<br/>&lt;ul&gt;<br/>    &lt;li *ngFor="let book of wishList$ | async" (click)="handleClick(book)"&gt;<br/>      {{ book }}<br/>    &lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="709c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<strong class="kh ir">设置状态</strong></p><p id="671c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用另一个<code class="fe nq nr ns nt b">updater</code>将一本书从阅读列表移动到历史中，但是，我们将使用<code class="fe nq nr ns nt b">setState</code>。</p><p id="0a52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe nq nr ns nt b">updater</code>不同，<code class="fe nq nr ns nt b">setState</code>在组件中被调用，不需要存储中的任何方法。</p><p id="602d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以调用setState方法</p><ul class=""><li id="8c00" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">通过提供状态对象。此"<em class="lc">将整个状态重置为提供的值。这也是惰性初始化的执行方式。</em>”</li><li id="574d" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">作为回电。我们将使用这个选项。</li></ul><p id="60f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然HTML与wish-list.component.html中的完全相同，但是处理函数现在通过传递一个在必要时更新状态的回调函数来使用<code class="fe nq nr ns nt b">setState</code>。</p><pre class="le lf lg lh gt nw nt og bn oh oi bi"><span id="377e" class="oj lu iq nt b be ok ol l om od">// reading-component.ts<br/>handleClick(title: string) {<br/>    this.booksStore.setState((state) =&gt; ({<br/>      ...state,<br/>      reading: [<br/>        ...state.reading.filter((titleInList) =&gt; titleInList !== title),<br/>      ],<br/>      history: [...state.history, title],<br/>    }));<br/>}</span></pre><p id="5932" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，你应该能够点击一个标题，将它从愿望清单移到阅读清单，从阅读清单移到历史清单。</p><p id="2390" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nq nr ns nt b"><a class="ae lb" href="https://ngrx.io/guide/component-store/write#patchstate-method" rel="noopener ugc nofollow" target="_blank">patchState</a></code> <a class="ae lb" href="https://ngrx.io/guide/component-store/write#patchstate-method" rel="noopener ugc nofollow" target="_blank">方法</a>可以以非常相似的方式使用。</p><h1 id="4854" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="a971" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在这篇文章中，我们探索了NgRx ComponentStore的基础。</p><p id="98e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个存储，初始化了一个状态，创建了几个选择器来显示状态的一部分，并使用<code class="fe nq nr ns nt b">updater</code>和<code class="fe nq nr ns nt b">setState</code>来更新状态。</p><p id="3ffa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在BooksComponent里面的GitHub 上找到<a class="ae lb" href="https://github.com/lorenzojkrl/formication/tree/main/src/app/components/books" rel="noopener ugc nofollow" target="_blank">代码。</a></p><p id="dbc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一件事我们应该经历，效果。正如文档中所解释的，“<em class="lc">效果被设计成从组件中提取任何副作用(比如网络调用)并处理潜在的竞争情况。</em></p><p id="fa5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将撰写并链接另一篇关注这一部分的文章。</p><p id="c10b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">更多内容请看</em><a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">plain English . io</em></strong></a><em class="lc">。报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">免费周报</em> </strong> </a> <em class="lc">。关注我们关于</em><a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">Twitter</em></strong></a><a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">LinkedIn</em></strong></a><em class="lc"/><a class="ae lb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">YouTube</em></strong></a><em class="lc"/><a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc">不和</em> </strong> </a> <strong class="kh ir"> <em class="lc">。</em>T49】</strong></p><p id="cb1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lc">对缩放您的软件启动感兴趣</em> </strong> <em class="lc">？检查</em> <a class="ae lb" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">电路</em> </strong> </a> <em class="lc">。</em></p></div></div>    
</body>
</html>