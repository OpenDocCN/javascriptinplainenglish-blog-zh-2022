<html>
<head>
<title>Build a Solid and Secure Login Workflow in Next.js with Strapi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Strapi在Next.js中构建一个可靠且安全的登录工作流</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-solid-and-secure-login-workflow-in-next-js-with-strapi-part-2-register-and-login-4971cc7176f5?source=collection_archive---------4-----------------------#2022-03-04">https://javascript.plainenglish.io/build-a-solid-and-secure-login-workflow-in-next-js-with-strapi-part-2-register-and-login-4971cc7176f5?source=collection_archive---------4-----------------------#2022-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b45f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分:注册和登录——用NextJS和Strapi构建一个可靠、安全、可伸缩的登录系统</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fa59a1134aa8b486bb1f94f3e0e43ad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rAWPuprYBhiwjkEmrSz75w.png"/></div></div></figure><p id="f0d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在过去的3个月里，我们在NextJs中使用<a class="ln lo ep" href="https://medium.com/u/ace2e82e28e6?source=post_page-----4971cc7176f5--------------------------------" rel="noopener" target="_blank">Strapi</a>(<a class="ae lp" href="https://strapi.io/" rel="noopener ugc nofollow" target="_blank">https://strapi.io/</a>)作为后端，从零开始构建了一个完整的电子商务，在这个开发过程中，我们遇到了一些问题，我们需要大量的试验和错误来实现我们一直在寻找的行为，因为Strapi(尤其是v. 4)并不总是被很好地正确记录。无论如何，我们能够克服困难，我们记录了我们的发展道路。和我们的项目一样，我们从最烦人的任务开始:<strong class="kt ir">构建一个可靠、安全、可伸缩、可靠和可重用的登录工作流</strong></p><p id="86f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Strapi 提供了一个内置的用户管理和登录系统，可以通过社交登录进行扩展。不幸的是，本教程的大部分内容都是关于这个系统和外部库的使用(例如<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/passwordless-authentication-in-next-js-with-nextauth-js-and-mongodb-19760c79184"> next-auth </a>)，而且文档并不总是与v. 4保持同步，所以我们决定在本教程中分享我们的经验。</p><p id="6cd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于构建生产就绪的登录系统是一项漫长而复杂的任务，我们将本教程分为3个部分:</p><ul class=""><li id="d5ef" class="lq lr iq kt b ku kv kx ky la ls le lt li lu lm lv lw lx ly bi translated"><a class="ae lp" href="https://popeating.medium.com/build-a-solid-and-secure-login-workflow-in-next-js-with-strapi-part-1-concept-and-setup-5155ebe622bb" rel="noopener">第1部分:概念和设置</a></li><li id="9dce" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">第2部分:注册和登录</li><li id="ae12" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated"><a class="ae lp" href="https://popeating.medium.com/build-a-solid-and-secure-login-workflow-in-next-js-with-strapi-part-3-social-login-and-password-7409bfad28fb" rel="noopener">第3部分:社交登录和密码重置</a></li></ul><p id="b839" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还可以下载或克隆这个项目的存储库，以便跟进:</p><div class="me mf gp gr mg mh"><a href="https://github.com/popeating/fullcomm" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd ir gy z fp mm fr fs mn fu fw ip bi translated">GitHub — popeating/fullcomm</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">github.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv kp mh"/></div></div></a></div><h2 id="d2c6" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated">允许用户注册</h2><p id="561c" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">Strapi公开了一个api端点，允许用户通过使用以下参数向<code class="fe nu nv nw nx b">/api/auth/local/register</code>提交来注册:<em class="ny">用户名、密码、电子邮件</em>(您可以通过修改用户的内容类型向用户模式添加更多的字段，但我们会将其保持在最低限度)。所以在我们的项目中，我们需要:</p><ul class=""><li id="d08c" class="lq lr iq kt b ku kv kx ky la ls le lt li lu lm lv lw lx ly bi translated">一个允许用户输入注册数据的表单:这将是一个在<code class="fe nu nv nw nx b">pages/user/register.js</code>的注册页面，我们将在其中添加一个表单组件<code class="fe nu nv nw nx b">components/RegisterForm.js</code>。</li><li id="81f8" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">UserContext中的register ( <em class="ny"> doRegister() </em>)函数将获取所有的表单数据，并发送到NextJs API路由，然后等待响应。</li><li id="ad6e" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">Next.js API Route <code class="fe nu nv nw nx b">pages/api/auth/register.js</code>将接收到的数据发送到Strapi API，获得响应，并将其传递回函数。</li></ul><p id="6e8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从NextJs API路径开始，创建文件<code class="fe nu nv nw nx b">pages/api/auth/register.js</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b7b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个端点将把接收到的主体发送到注册的Strapi API端点，并返回一条消息和状态，所有这些都基于Strapi API响应。我们现在需要一个访问端点的函数，我们将通过向我们的上下文添加一个<em class="ny"> doRegister() </em>函数来将该函数添加到UserProvider上下文:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="bf25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ny"> doRegister() </em>将发送到我们的本地API(它将发送到Strapi)并获取一个数组。一旦一切就绪，我们就可以构建一个表单，并让它与注册交互。<br/>创建文件<code class="fe nu nv nw nx b">pages/register.js</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="fc0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它应该看起来像一个空白页面，显示我们将在<code class="fe nu nv nw nx b">/components/RegisterForm.js</code>中创建的<em class="ny"> RegisterForm </em>组件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1e5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个文件中，我们有效地构建了表单，在<em class="ny"> react-hook-form </em>的帮助下，我们还验证了它并处理了提交动作。<br/>我们准备了几个状态(<em class="ny">警报</em>和<em class="ny">正在提交</em>)，我们将使用它们来显示返回消息和启用/禁用提交按钮。我们声明doRegister函数，从上下文中获取它</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="acbb" class="mw mx iq nx b gy of og l oh oi">const { doRegister } = useContext(UserContext);</span></pre><p id="ba9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在表单提交时执行它:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="73a0" class="mw mx iq nx b gy of og l oh oi">const onSubmit = async (values) =&gt; {<br/>    //...<br/>    const ret = await doRegister(values);<br/>    //...<br/>}</span></pre><p id="ac82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们用返回值设置警告，如果返回值不是<em class="ny"> alert </em>我们也会重置表单。</p><p id="d05e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还应该创建一个文件<code class="fe nu nv nw nx b">/pages/users/index.js</code>，点击确认邮件后，您将被重定向到该页面:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="eaf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你去<code class="fe nu nv nw nx b">http://localhost:3000/user/register</code>，你应该会得到一个注册表单，你可以注册新用户(或者尝试已经注册的用户得到错误)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6134e4791f9f52900cedfde626fc5d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*44GfHYjw_Veg7zc0bhYJTA.png"/></div></figure><p id="ba91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您注册了一个新用户，并且一切正常，您将在您的Strapi面板中发现一个新用户，其中<strong class="kt ir">确认</strong>标志设置为false。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/45d06321ea0fe00f6d154785a0bc4a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73vg2vAX51TP8wbDOs3Qpw.png"/></div></div></figure><p id="1b71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还将收到一封带有链接的电子邮件，如果您单击它，您将被重定向到<code class="fe nu nv nw nx b">http://localhost:3000/user</code>(我们之前创建的空白页面)，并且<strong class="kt ir">确认</strong>标志将被设置为真，用户现在可以登录了。</p><h2 id="ec2c" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated">用户登录</h2><p id="ad56" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">用户登录比注册容易，它遵循相同的模式，所以我们需要:</p><ul class=""><li id="6162" class="lq lr iq kt b ku kv kx ky la ls le lt li lu lm lv lw lx ly bi translated">用户输入其用户名和密码的表单(和以前一样，是一个带有表单组件的页面)。</li><li id="5b80" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">UserContext中的login ( <em class="ny"> doLogin() </em>)函数将获取所有表单数据，并发送到NextJs API路由，然后等待响应。</li><li id="050f" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">Next.js API Route <code class="fe nu nv nw nx b">pages/api/auth/login.js</code>将接收到的数据发送到Strapi API，获得响应，并将其传递回函数。</li><li id="3f55" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">UserContext中的一个函数(<em class="ny"> checkLogin() </em>)，该函数将检查用户是否已经登录(通过调用NextJs API路由)，以便可以保护页面并根据用户更改内容。</li><li id="f63d" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">Next.js API Route <code class="fe nu nv nw nx b">pages/api/auth/user.js</code>将根据Strapi验证用户JWT，以检查用户是否登录。</li></ul><p id="cdcb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们之前所说的，我们将JWT存储在httpOnly cookie中，这样它就可以被服务器访问，并且在客户端也是非常安全的。<br/>首先，我们创建API路由来检查<code class="fe nu nv nw nx b">pages/api/auth/user.js</code>中的用户状态</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="770d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们从cookie中获取令牌，并用授权头向Strapi端点<code class="fe nu nv nw nx b">api/users/me</code>发出请求。如果用户是登录id(令牌被验证)，我们返回一些用户数据以及200响应，否则，我们返回403响应。</p><p id="a3fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些响应由<em class="ny"> checkLogin() </em>函数处理，我们将把它添加到我们的UserContext中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="62b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在在每个页面上(甚至在_app.js中)我们都可以访问<em class="ny"> checkLogin() </em>，如果该函数返回一个用户，就意味着该用户已经登录，我们可以据此采取行动。我们可以将该检查添加到我们的注册页面，这样登录的用户就不会看到注册表单，而是被重定向到:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="46ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<em class="ny"> useEffect </em>钩子的帮助下，我们调用<em class="ny"> checkLogin() </em>，如果它返回200状态，我们重定向到用户而不是显示注册表单。</p><p id="b8ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到登录，我们现在准备Next.js API路由，它将有效地登录用户<code class="fe nu nv nw nx b">pages/api/auth/login.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2546" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们根据<code class="fe nu nv nw nx b">api/auth/local</code> Strapi端点验证用户提交的数据(req.body ),如果用户通过了身份验证，我们将存储两个cookies，一个包含返回的JWT(用于请求期间的授权),另一个包含用户id(在许多情况下都很有用)。然后我们回到应用程序。<br/>我们使用doLogin()函数扩展用户上下文，该函数链接到我们用于用户授权的本地API:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="eb7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在任何需要登录用户的地方，我们只需调用<em class="ny"> doLogin() </em>，传递<em class="ny">标识符</em>和<em class="ny">密码</em>(在Strapi中，我们使用可以是用户名或电子邮件的标识符登录)</p><p id="3893" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们制作一个基本的登录表单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="495b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们检查用户是否已经登录，如果没有，我们显示位于<code class="fe nu nv nw nx b">components/LoginForm.js</code>中的LoginForm组件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a996" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">和前面一样，我们使用<em class="ny"> react-hook-form </em>来处理和验证表单，提交调用<em class="ny"> doLogin() </em>，如果登录成功，组件会将用户设置在一个状态，当页面检测到用户时，会重定向到<code class="fe nu nv nw nx b">/user</code></p><p id="b2cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您导航到<code class="fe nu nv nw nx b">http://localhost:3000/user/login</code>,您会看到一个登录表单，如果使用确认的用户登录，您将被重定向到<code class="fe nu nv nw nx b"><a class="ae lp" href="http://localhost:3000/user" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/user</a></code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/1b70d0ef3dff4a3d822515baa341fe3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*eFgt7UnEl4oMILx3mjVOxA.png"/></div></figure><p id="f994" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还可以修改<code class="fe nu nv nw nx b">pages/user/index.js</code>页面，为登录用户显示不同的内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="fbcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果用户已经登录(我们使用<em class="ny"> checkLogin() </em>函数)，我们将显示用户数据和一个注销按钮(我们接下来将准备这个按钮)，如果用户没有登录，我们将显示一个注册链接和一个登录链接。</p><h2 id="86ef" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated">注销</h2><p id="4f96" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">通过注销，您只需删除cookie并清理状态，不需要调用任何API，但为了保持一致性，我们坚持我们的设计模式(page-&gt;UserContext-&gt;NextJs API)，而且，由于cookie是httpOnly，只能由服务器头请求设置和修改。</p><p id="3343" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Next.js API路由简单删除cookie <code class="fe nu nv nw nx b">pages/api/out/logout.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0888" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注销的UserContext函数(通过向<code class="fe nu nv nw nx b">context/user.js</code>添加一个<em class="ny"> doLogout() </em>函数):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="74c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ny"> doLogout() </em>函数现在可以从我们的应用程序中访问，在我们的例子中，我们制作了一个可以添加到页面中的注销组件，它呈现一个注销按钮，单击该按钮后执行<em class="ny"> doLogout() </em> <code class="fe nu nv nw nx b">components/Logout.js</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="85ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一部分，我们将看到用户如何使用他们的社交账户登录。</p><p id="d0d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ny">更多内容请看</em><a class="ae lp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny">plain English . io</em></strong></a><em class="ny">。报名参加我们的</em> <a class="ae lp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em><a class="ae lp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny">Twitter</em></strong></a><em class="ny">和</em><strong class="kt ir"><em class="ny"/></strong><a class="ae lp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny">LinkedIn</em></strong></a><em class="ny">。加入我们的</em> <a class="ae lp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ny">社区</em> </strong> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>