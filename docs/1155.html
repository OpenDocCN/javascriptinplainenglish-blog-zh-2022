<html>
<head>
<title>Why You Should Not Put Any Logic in the RxJS Subscribe Callback in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不应该在Angular的RxJS订阅回调中放入任何逻辑</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-should-not-put-any-logic-in-the-rxjs-subscribe-callback-in-angular-df1ba4a12f13?source=collection_archive---------1-----------------------#2022-03-07">https://javascript.plainenglish.io/why-you-should-not-put-any-logic-in-the-rxjs-subscribe-callback-in-angular-df1ba4a12f13?source=collection_archive---------1-----------------------#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ad52" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">RxJS &amp; Angular最佳实践及示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/18626da1319c04845aa8e1601099f645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*814M_utK5uQVQuQzCqkmkQ.png"/></div></div></figure><p id="adf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一名自由开发人员，我倾向于从一个角度项目跳到另一个角度项目。我曾与不同规模和经验水平的团队一起工作过。</p><p id="9b8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我经常在一个<code class="fe ln lo lp lq b">subscribe</code>回调中遇到一大块命令性代码。我一直认为这是一种不好的做法。Angular拥抱RxJS和反应式编程范例。作为Angular开发者，我们真的应该做同样的事情。这篇文章会很固执己见，所以欢迎评论或提问。</p><h1 id="f894" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">Angular中的订阅回调是什么？</h1><p id="499a" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">Observable是RxJS库提供的主要工具，其Angular用途广泛。与常规的JavaScript承诺一样，Observable的目标是处理异步事件。</p><p id="572e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可观察到的和承诺的关键区别在于可观察到的是懒惰的。您可以声明一旦收到数据应该如何处理，但是您需要显式地<code class="fe ln lo lp lq b">subscribe</code>来触发异步调用。换句话说，发出调用和处理结果是分开的操作。而对于一个承诺，当你调用<code class="fe ln lo lp lq b">then</code>函数时，你实际上是在同时做这两个操作。它触发调用并处理结果。</p><p id="82af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到文章的主题，如果你在<code class="fe ln lo lp lq b">subscribe</code>回调中写了很多逻辑，你使用了一个可观察的，好像它是一个承诺。因此，您没有充分利用RxJS或角度特征。</p><h1 id="b469" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">命令式与反应式</h1><p id="de16" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">正如我通常对这些文章所做的那样，我使用两种不同的方法构建了一个基本的应用程序。这是一个简单的天气应用程序。你只需输入一个城市的名字，然后就可以得到该城市未来几天的天气情况。这是它的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f7bb68d484888cc2ae8ce208cf578986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/1*UowbHmLhF0QTU36Iq142nA.gif"/></div></figure><p id="223e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我使用了<a class="ae mp" href="https://www.weatherapi.com/" rel="noopener ugc nofollow" target="_blank">天气API </a>来获取天气数据。代码可以在我的GitHub上找到，有命令式和反应式分支，所以你可以比较一下。</p><h1 id="31ec" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">原因1:您没有尽可能多地使用RxJS操作符</h1><p id="63a4" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">为了说明第一个原因，让我们看看我在应用程序的两个版本中处理API调用的方式。</p><p id="4239" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于应用程序的命令式版本，我简单地订阅了两个端点，将数据处理并存储到组件属性中，然后显示在页面上。每当模板上的输入发生变化时，一切都会被触发。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="88a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于反应式版本，从一个可观察的方法开始这个过程比从一个回调方法开始要好。出于这个原因，我使用了<code class="fe ln lo lp lq b">ViewChild</code>装饰器从HTML元素中获取可观察对象。然后我做了和以前一样的处理，但是这一次，所有的东西都存储在可观察对象中，而不是一个对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="71f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我看来，在这里使用反应式方法而不是命令式方法有一些优势。</p><h2 id="f6a3" class="ms ls iq bd lt mt mu dn lx mv mw dp mb la mx my md le mz na mf li nb nc mh nd bi translated">它增加了<strong class="ak">可读性</strong>。</h2><p id="1767" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">一系列操作符非常容易阅读和理解(假设您知道最常见的RxJS操作符)。一组命令式代码总是要求你深入其中，试图理解该组代码的目标是什么。此外，您必须添加一些代码来将订阅推送到一个列表，以便以后取消订阅，这使得代码变得更重。嵌套订阅也增加了复杂性。看看这个，试着想象一下，如果有三个嵌套的订阅，每个订阅都有一个特定的错误管理块，会是什么样子。</p><h2 id="c269" class="ms ls iq bd lt mt mu dn lx mv mw dp mb la mx my md le mz na mf li nb nc mh nd bi translated">它使得<strong class="ak">测试</strong>和<strong class="ak">调试</strong>更加容易。</h2><p id="9d8c" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">对于命令式方法，您必须使用组件属性。在这个例子中，我只在函数中使用那些变量。但是有时，一旦创建了这个变量，您可能会想在组件的其他地方使用它。与反应式方法相比，从开发人员的角度来看，这非常方便。但这是有代价的。每当你在一个函数中使用组件属性时，这个函数就不再是纯粹的了，你正在产生一个副作用。副作用会导致更复杂的调试，因为您永远不知道更改发生在哪里。一般来说，纯函数更容易测试。</p><h2 id="c01c" class="ms ls iq bd lt mt mu dn lx mv mw dp mb la mx my md le mz na mf li nb nc mh nd bi translated">它具有内置的高级功能。</h2><p id="dd6d" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">去抖、<a class="ae mp" href="https://medium.com/@AurelienLeloup/cache-http-requests-with-rxjs-for-angular-eb9bee93824d" rel="noopener">缓存</a>等等。RxJS库中已经构建了很多。仅仅因为你决定不声明一个可观察的，就试图手工重新实现其中的一些特性，这实在是一种耻辱。</p><h1 id="e57d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">原因2:您不能使用异步管道</h1><p id="98fa" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">对于命令式方法，我们使用组件变量在模板上显示数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="18da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于反应式方法，我们直接使用模板上的<code class="fe ln lo lp lq b">async </code>管道来观察。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="db19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">async</code>管道是Angular提供的一个特性，用于处理Angular模板中的异步数据。与直接通过组件属性发送数据相比，它有两个主要优点。</p><h2 id="4d2d" class="ms ls iq bd lt mt mu dn lx mv mw dp mb la mx my md le mz na mf li nb nc mh nd bi translated">它将为您处理退订。</h2><p id="9e92" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">每当您订阅可观察网站时，您都需要取消订阅。你永远不应该忘记这样做。否则，您的代码会泄漏，导致意外行为。遵守这条规则并不困难。然而，这需要一些特定的代码来完成。</p><h2 id="3329" class="ms ls iq bd lt mt mu dn lx mv mw dp mb la mx my md le mz na mf li nb nc mh nd bi translated">它与OnPush变更检测一起工作得很好。</h2><p id="d0ce" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated"><code class="fe ln lo lp lq b">async</code>管道将在发出新值时触发变化检测，即使启用了OnPush策略。当您使用subscribe时，必须手动执行此操作。OnPush策略对于Angular应用程序的性能非常好。仅仅是它的使用就足以成为一个论点，永远要考虑<code class="fe ln lo lp lq b">async</code>导管的使用。</p><h1 id="0b48" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">关于错误管理</h1><p id="e010" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">评论中的一些人正确地指出了一个事实，如果我用这两种方法处理可能的错误，我的例子会更现实。</p><p id="cefd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是如果我的API密钥错误的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/cc25a0481e3d78e336271d869b8c5329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWAVTj7vRHWp8R_4t3laJw.png"/></div></div></figure><p id="3455" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是带有命令式方法的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8869" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于被动方法，代码变得更加复杂:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ece7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在对这两种方法进行评论和比较之前，让我们解释一下我是如何在这两种情况下实现错误管理的。</p><p id="9a74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于命令式方法，它非常简单。我们可以简单地在之前的<code class="fe ln lo lp lq b">next</code>回调之后使用<code class="fe ln lo lp lq b">error</code>回调。代码变得更密集了，但除此之外，没有什么太复杂的东西值得一提。</p><p id="1112" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于被动的方法，它更为棘手。首先，我们需要设置第三个观察值来显示错误。然后，我们使用<code class="fe ln lo lp lq b">catchError</code>来捕捉错误并允许我们处理它们。需要注意的是，该运算符就在HTTP请求之后链接。这使得主要的可观察物能够存活。因此，如果用户键入其他内容，错误就会消失，请求可以再次尝试。</p><p id="47a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">的确，用命令式方法处理错误的简单性对它有利。然而，让我们注意到，使用一个专用的“handleError”函数可以使被动方法的错误管理更加清晰。</p><h1 id="58a0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">最后评论</h1><p id="98aa" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">对于这类文章，重复两种方法都有效，这一点很重要。就我的例子而言，没有一种方法明显优于其他方法。虽然Angular确实包含了RxJS和反应范式，但该框架有一条陡峭的学习曲线。所以，如果您觉得使用subscribe编写您的第一个应用程序更舒服，因为这类似于使用诺言，那很好。在阅读了本文之后，也许您会认识到反应式编程的一些好处，并在某个时候尝试一下。</p><p id="3833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相关文章:</p><div class="nf ng gp gr nh ni"><a href="https://medium.com/angular-in-depth/angular-question-rxjs-subscribe-vs-async-pipe-in-component-templates-c956c8c0c794" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">非常常见的角度问题的最终答案:subscribe() vs | async Pipe</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">大多数流行的Angular状态管理库(如NgRx)以一系列的形式公开了应用程序状态…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kp ni"/></div></div></a></div><p id="380f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的GitHub上的完整项目:</p><div class="nf ng gp gr nh ni"><a href="https://github.com/aurelien-leloup/weather-app" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">GitHub-aurel ien-le loup/weather-app:一个简单的天气应用程序，用于演示命令与…</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">一个简单的天气应用程序，演示了命令式和反应式方法。使用分支导航…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw kp ni"/></div></div></a></div><p id="c035" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ny">更多内容请看</em><a class="ae mp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny">plain English . io</em></strong></a><em class="ny">。报名参加我们的</em> <a class="ae mp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em><a class="ae mp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny">Twitter</em></strong></a><em class="ny">和</em><a class="ae mp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ny">LinkedIn</em></strong></a><em class="ny">。加入我们的</em> <a class="ae mp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ny">社区不和谐</em> </strong> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>