<html>
<head>
<title>How to Implement JavaScript Array Methods By Yourself</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何自己实现JavaScript数组方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-javascript-array-methods-by-yourself-e06b976ca4c0?source=collection_archive---------12-----------------------#2022-11-01">https://javascript.plainenglish.io/how-to-implement-javascript-array-methods-by-yourself-e06b976ca4c0?source=collection_archive---------12-----------------------#2022-11-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="018c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">映射，归约，筛选，forEach，查找，每</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d3836ad6a16ae6acccec948603eb7e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQPHHEopBQ2x74eWKn-vFg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@nnonno?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Yifu Wu</a> on <a class="ae ks" href="https://unsplash.com/s/photos/array-methods?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="95fb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们都用类似<strong class="kv io"> <em class="lp">的数组方法。地图，。forEach，。过滤器，。减少</em> </strong>。作为参数，它们总是接受一个函数，该函数又接受不同数量的参数。我一直想知道它们是如何实现的，但是一直没有时间去弄清楚，直到有一天在一次面试中，我被要求写一个数组方法的实现。从理论上讲，这并不难，但在实践中，事实证明这有点难。因此，在本文中，我们将分析我们的主要数组方法的实现。</p><p id="0253" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">。</em> forEach </strong></p><p id="7e18" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此方法的语法如下:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="8ce3" class="lv lw in lr b gy lx ly l lz ma">arr.forEach(function(currentValue, index, array) {<br/>    //your iterator<br/>},thisArg);</span></pre><p id="2468" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，根据语法，我们的方法必须有两个参数，我们将传递数组元素的函数:<em class="lp"> index </em>，整个数组。第二个参数是一个值，当在函数内部调用时，该值将等于这个值，但是这对于arrow函数不起作用，因为它们没有自己的上下文。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mb mc l"/></div></figure><blockquote class="md me mf"><p id="d62c" class="kt ku lp kv b kw kx jo ky kz la jr lb mg ld le lf mh lh li lj mi ll lm ln lo ig bi translated">此外，我们不会显示对函数类型的检查，因为它对我们将要考虑的所有方法都是一样的。</p></blockquote><h2 id="904b" class="lv lw in bd mj mk ml dn mm mn mo dp mp lc mq mr ms lg mt mu mv lk mw mx my mz bi translated"><strong class="ak"> <em class="na">。</em>地图</strong></h2><p id="4e79" class="pw-post-body-paragraph kt ku in kv b kw nb jo ky kz nc jr lb lc nd le lf lg ne li lj lk nf lm ln lo ig bi translated">此方法的语法如下:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="a46c" class="lv lw in lr b gy lx ly l lz ma">const newArr = arr.map(function(currentValue, index, array){ <br/>   //your iterator<br/>}, thisArg)</span></pre><p id="ef0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，根据语法，我们的方法类似于前一个方法，但返回一个新的数组</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="6fc5" class="lv lw in bd mj mk ml dn mm mn mo dp mp lc mq mr ms lg mt mu mv lk mw mx my mz bi translated"><strong class="ak"> <em class="na">。过滤器</em> </strong></h2><p id="1715" class="pw-post-body-paragraph kt ku in kv b kw nb jo ky kz nc jr lb lc nd le lf lg ne li lj lk nf lm ln lo ig bi translated">此方法的语法如下:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="9aeb" class="lv lw in lr b gy lx ly l lz ma">const newArr = arr.map(function(currentValue, index, array){ <br/>   //your iterator<br/>}, thisArg)</span></pre><p id="6f36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，根据语法，我们的方法将那些不为空的元素写入新数组，并且函数调用返回真值</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="fcac" class="lv lw in bd mj mk ml dn mm mn mo dp mp lc mq mr ms lg mt mu mv lk mw mx my mz bi translated">。减少</h2><p id="842d" class="pw-post-body-paragraph kt ku in kv b kw nb jo ky kz nc jr lb lc nd le lf lg ne li lj lk nf lm ln lo ig bi translated">此方法的语法如下:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="ed4a" class="lv lw in lr b gy lx ly l lz ma">const result = arr.reduce(function(accumulator, element, index, array){<br/>    //your iterator<br/>}, initialAccumulator])</span></pre><p id="1cfb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，根据语法，我们的方法在迭代完数组中那些<strong class="kv io"> <em class="lp">不为空的</em> </strong>元素后，返回<strong class="kv io"> <em class="lp">累加的</em> </strong>值</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="4c3d" class="lv lw in bd mj mk ml dn mm mn mo dp mp lc mq mr ms lg mt mu mv lk mw mx my mz bi translated">。发现</h2><p id="c3fc" class="pw-post-body-paragraph kt ku in kv b kw nb jo ky kz nc jr lb lc nd le lf lg ne li lj lk nf lm ln lo ig bi translated">此方法的语法如下:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="8879" class="lv lw in lr b gy lx ly l lz ma">const result = arr.find(function(currentValue, index, array) {<br/>    //your iterator<br/>},thisArg);</span></pre><p id="ea5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，根据语法，我们的方法返回数组的<strong class="kv io"> <em class="lp">元素</em> </strong>如果调用的函数返回true否则返回<strong class="kv io"> <em class="lp">未定义的</em> </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="67ae" class="lv lw in bd mj mk ml dn mm mn mo dp mp lc mq mr ms lg mt mu mv lk mw mx my mz bi translated">。每个</h2><p id="e892" class="pw-post-body-paragraph kt ku in kv b kw nb jo ky kz nc jr lb lc nd le lf lg ne li lj lk nf lm ln lo ig bi translated">此方法的语法如下:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="2370" class="lv lw in lr b gy lx ly l lz ma">const boolean = arr.every(callback(currentValue, index, array){<br/>   //your iterator<br/>}, thisArg)</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9b23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，这个实现不会取代内置的方法，因为有很多检查，但是显示了构建您自己的方法的一般原则。</p><p id="38ac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望对你有用！</p><p id="803c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读！回头见。😊</p><p id="8225" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">plain English . io</em></strong></a><em class="lp">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">免费周报</em> </strong> </a> <em class="lp">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">LinkedIn</em></strong></a><strong class="kv io"><em class="lp"/></strong><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">YouTube</em></strong></a><strong class="kv io"><em class="lp">，以及</em></strong><em class="lp"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">不和</em> </strong> </a>  <em class="lp">对成长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">电路</em> </strong> </a> <strong class="kv io"> <em class="lp">。</em> </strong></p></div></div>    
</body>
</html>