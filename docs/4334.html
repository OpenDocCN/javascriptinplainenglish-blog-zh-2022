<html>
<head>
<title>How To Solve Hydration Error In Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决Next.js中的补水错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-solve-hydration-error-in-next-js-a50ec54bfc02?source=collection_archive---------0-----------------------#2022-11-22">https://javascript.plainenglish.io/how-to-solve-hydration-error-in-next-js-a50ec54bfc02?source=collection_archive---------0-----------------------#2022-11-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d6133a6e239b6656ad735c4b1cff3114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRNP5ORuO9JlxtmOYCGSfw.png"/></div></div></figure><p id="e765" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天我们来谈谈<code class="fe kt ku kv kw b">Next.js</code>中经常出现的<code class="fe kt ku kv kw b">hydration </code>错误。我们大多数用过<code class="fe kt ku kv kw b">Next.js</code>的人一定熟悉下面这个错误:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="c817" class="lf lg in kw b be lh li l lj lk"><strong class="kw io">Error</strong>: Hydration failed because the initial UI does not match what was rendered on the server.</span></pre><p id="891e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">错误原因已经在错误消息中明确说明:<strong class="jx io"/><code class="fe kt ku kv kw b"><strong class="jx io">hydration</strong></code><strong class="jx io">因水合后UI与服务器渲染的UI</strong>不一致而失败。尽管错误消息说水合失败，但是，它仍然显示可以认为渲染成功的正确UI。</p><h2 id="1a96" class="ll lg in bd lm ln lo dn lp lq lr dp ls kg lt lu lv kk lw lx ly ko lz ma mb mc bi translated">让我们来谈一个商业案例</h2><p id="e83e" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">我们在本地存储一些不重要或不同步的数据，并在客户端获取这些本地存储的数据。比如我们在<code class="fe kt ku kv kw b">localStorage</code>中存储了一些配置，页面会根据配置进行渲染。<br/>以<code class="fe kt ku kv kw b">sidebar</code>为例:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="65ff" class="lf lg in kw b be lh li l mi lk">export default function R() {<br/>    const [expand, setExpand] = React.useState(() =&gt; localStorage.getItem(EXPAND_STORAGE_KEY) === '1');<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;NavSidebar expand={expand} onExpand={setExpand} /&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="51b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有一个侧边栏，用户可以展开或折叠，我们经常在本地保存它的状态，以方便用户体验。</p><p id="d426" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于Next.js既有客户端渲染(<code class="fe kt ku kv kw b">CSR</code>)又有服务器渲染(<code class="fe kt ku kv kw b">SSR</code>)，代码将在客户端正确运行，但会导致服务器渲染(<code class="fe kt ku kv kw b">SSR</code>)出错，因为服务器端缺少<code class="fe kt ku kv kw b">localStorage</code> API。所以我们修改了代码:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="d5a4" class="lf lg in kw b be lh li l mi lk">export default function R() {<br/>    const [expand, setExpand] = React.useState(() =&gt;<br/>        typeof window === 'undefined' ? false : localStorage.getItem(EXPAND_STORAGE_KEY) === '1'<br/>    );<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;NavSidebar expand={expand} onExpand={setExpand} /&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="f68f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过<code class="fe kt ku kv kw b">window</code>关键字检查是服务器还是浏览器环境，然后根据它运行不同的代码，那么我们开头说的错误就消失了。</p><p id="0a13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码逻辑上看起来不错，但是在浏览器中运行就会出现上面的<code class="fe kt ku kv kw b">hydration</code>错误。</p><h2 id="c568" class="ll lg in bd lm ln lo dn lp lq lr dp ls kg lt lu lv kk lw lx ly ko lz ma mb mc bi translated">React做检查而不是Next.js</h2><p id="0c22" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">事实上，错误是由检查<code class="fe kt ku kv kw b">React</code>中的<code class="fe kt ku kv kw b">react-dom</code>而不是<code class="fe kt ku kv kw b">Next.js.</code>引起的，我们可以简单地查看<code class="fe kt ku kv kw b">react-dom</code>中的相关源代码:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="639d" class="lf lg in kw b be lh li l mi lk">if (!tryHydrate(fiber, nextInstance)) {<br/>    if (shouldClientRenderOnMismatch(fiber)) {<br/>        warnNonhydratedInstance(hydrationParentFiber, fiber);<br/>        throwOnHydrationMismatch();<br/>    }<br/>}<br/>function throwOnHydrationMismatch(fiber) {<br/>    throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');<br/>}<br/>function shouldClientRenderOnMismatch(fiber) {<br/>    return (fiber.mode &amp; ConcurrentMode) !== NoMode &amp;&amp; (fiber.flags &amp; DidCapture) === NoFlags;<br/>}</span></pre><p id="280f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">react-dom</code>中的代码将使用<code class="fe kt ku kv kw b">tryHydrate</code>尝试水合物操作，如果失败，将检查模式和标志并抛出<code class="fe kt ku kv kw b">hydration</code>错误。</p><p id="9aae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这个错误怎么解决？有3个解决方案适合你。</strong></p><h2 id="0761" class="ll lg in bd lm ln lo dn lp lq lr dp ls kg lt lu lv kk lw lx ly ko lz ma mb mc bi translated">解决方案1</h2><p id="9d09" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated"><code class="fe kt ku kv kw b">useEffect/componentDidMount</code></p><p id="dd5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要解决以上问题，官方推荐使用<code class="fe kt ku kv kw b">useEffect</code>:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="4b4f" class="lf lg in kw b be lh li l mi lk">const [expand, setExpand] = React.useState(true);<br/><br/>// to avoid ssr error<br/>useEffect(() =&gt; {<br/>    setExpand(localStorage.getItem(EXPAND_STORAGE_KEY) === '1');<br/>}, []);</span></pre><p id="1749" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不会抛出错误，因为效果不会在服务器上执行。当然也可以使用类组件，然后在<code class="fe kt ku kv kw b">componentDidMount</code>中获取<code class="fe kt ku kv kw b">localStorage</code>。然而，使用这种解决方案时会出现一些问题。比如有一个<code class="fe kt ku kv kw b">sideBar</code>展开和折叠的动画，用户在进入页面时会看到一个额外的动画，会很奇怪。解决方案是不默认呈现<code class="fe kt ku kv kw b">sidebar</code>。😂因此，<code class="fe kt ku kv kw b">SSR</code>的效果并没有想象中的那么好，这真的要看实际业务了。</p><h2 id="2c5a" class="ll lg in bd lm ln lo dn lp lq lr dp ls kg lt lu lv kk lw lx ly ko lz ma mb mc bi translated">解决方案2</h2><p id="5f96" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated"><code class="fe kt ku kv kw b">react-no-ssr</code></p><p id="d374" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种解决方案是使用一些开源库，比如<code class="fe kt ku kv kw b">react-no-ssr</code>。实际上，<code class="fe kt ku kv kw b">react-no-ssr </code>也是用<code class="fe kt ku kv kw b">solution 1</code>实现的。你可以看看源代码:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="6e42" class="lf lg in kw b be lh li l mi lk">import React from 'react';<br/><br/>const DefaultOnSSR = () =&gt; &lt;span&gt;&lt;/span&gt;;<br/><br/>class NoSSR extends React.Component {<br/>    constructor(...args) {<br/>        super(...args);<br/>        this.state = {<br/>            canRender: false<br/>        };<br/>    }<br/><br/>    componentDidMount() {<br/>        this.setState({ canRender: true });<br/>    }<br/><br/>    render() {<br/>        const { children, onSSR = &lt;DefaultOnSSR /&gt; } = this.props;<br/>        const { canRender } = this.state;<br/><br/>        return canRender ? children : onSSR;<br/>    }<br/>}<br/><br/>export default NoSSR;</span></pre><p id="c42c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以看到<code class="fe kt ku kv kw b">NoSSR</code>只会在<code class="fe kt ku kv kw b">componentDidMount</code>中设置<code class="fe kt ku kv kw b">canRender</code>，那么就会以正确的方式渲染。</p><h2 id="7b09" class="ll lg in bd lm ln lo dn lp lq lr dp ls kg lt lu lv kk lw lx ly ko lz ma mb mc bi translated">解决方案3</h2><p id="789e" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Turn Off SSR</code></p><p id="4fe6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以通过关闭组件的<code class="fe kt ku kv kw b">SSR</code>来解决问题。其实上面的<code class="fe kt ku kv kw b">react-no-ssr</code>就是其中之一，但是<code class="fe kt ku kv kw b">Next.js</code>还提供了一个内置的解决方案:<strong class="jx io">动态加载组件并关闭</strong> <code class="fe kt ku kv kw b"><strong class="jx io">SSR</strong></code>，以上面的<code class="fe kt ku kv kw b">sidebar</code>为例:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="7023" class="lf lg in kw b be lh li l mi lk">import dynamic from 'next/dynamic';<br/><br/>const DynamicSidebarWithNoSSR = dynamic(() =&gt; import('../components/Sidebar'), {<br/>    ssr: false<br/>});<br/><br/>export default function R() {<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;DynamicSidebarWithNoSSR /&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="f5eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们只需要提取组件，然后使用<code class="fe kt ku kv kw b">dynamic</code>加载组件并传入<code class="fe kt ku kv kw b">SSR</code>参数作为<code class="fe kt ku kv kw b">false</code>来关闭组件的服务器渲染。</p><p id="b706" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，为了方便我们可以做一些工作:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="cf1e" class="lf lg in kw b be lh li l mi lk">import dynamic from 'next/dynamic';<br/>import React from 'react';<br/><br/>const NoSSR = props =&gt; &lt;React.Fragment&gt;{props.children}&lt;/React.Fragment&gt;;<br/><br/>export default dynamic(() =&gt; Promise.resolve(NoSSR), {<br/>    ssr: false<br/>});</span></pre><p id="944c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们只需要直接调用<code class="fe kt ku kv kw b">NoSSR</code>来包装子组件:</p><pre class="kx ky kz la gt lb kw lc bn ld le bi"><span id="5bbb" class="lf lg in kw b be lh li l mi lk">import dynamic from 'next/dynamic';<br/>import Sidebar from '../components/Sidebar';<br/><br/>export default function R() {<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;NoSSR&gt;<br/>                &lt;Sidebar /&gt;<br/>            &lt;/NoSSR&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><h2 id="ef89" class="ll lg in bd lm ln lo dn lp lq lr dp ls kg lt lu lv kk lw lx ly ko lz ma mb mc bi translated">结论</h2><p id="4fa4" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated"><code class="fe kt ku kv kw b">CSR</code>仅限于在浏览器中运行，而<code class="fe kt ku kv kw b">SSR</code>需要能够在浏览器和服务器中运行，这遇到了一些在纯<code class="fe kt ku kv kw b">CSR</code>应用中没有出现的问题和挑战。在用户体验方面，<code class="fe kt ku kv kw b">SSR</code>确实会给我们的应用带来很大的提升。</p><p id="961d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读。期待<strong class="jx io"> </strong>期待您的关注和阅读更多高质量的文章。</p><div class="mj mk gp gr ml mm"><a href="https://levelup.gitconnected.com/the-story-of-clip-path-and-endangered-animals-in-css-8af987927fc6" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">CSS中剪辑路径和濒危动物的故事</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">使用CSS剪辑路径创建奇妙的动画</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jt mm"/></div></div></a></div><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/which-loop-traversal-is-the-fastest-in-javascript-c196311337d6"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">JavaScript中哪个循环遍历最快？</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">JavaScript数组遍历方法的比较</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mv l"><div class="nb l mx my mz mv na jt mm"/></div></div></a></div><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/identify-javascript-data-types-two-methods-are-enough-882e2c238e6b"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">识别JavaScript数据类型:两种方法就足够了</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">引入一个实用方法来识别所有数据类型</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mv l"><div class="nc l mx my mz mv na jt mm"/></div></div></a></div><p id="253d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nd">更多内容请看</em><a class="ae ne" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nd">plain English . io</em></strong></a><em class="nd">。报名参加我们的</em> <a class="ae ne" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nd">免费周报</em> </strong> </a> <em class="nd">。关注我们关于</em><a class="ae ne" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nd">Twitter</em></strong></a><em class="nd">和</em><a class="ae ne" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nd">LinkedIn</em></strong></a><em class="nd">。查看我们的</em> <a class="ae ne" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nd">社区不和谐</em> </strong> </a> <em class="nd">加入我们的</em> <a class="ae ne" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nd">人才集体</em> </strong> </a> <em class="nd">。</em></p></div></div>    
</body>
</html>