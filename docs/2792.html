<html>
<head>
<title>5 Clever Hacks for React-Query and SWR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-Query和SWR的5个妙招</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/five-clever-hacks-for-react-query-or-swr-27c2453f4e2d?source=collection_archive---------1-----------------------#2022-07-05">https://javascript.plainenglish.io/five-clever-hacks-for-react-query-or-swr-27c2453f4e2d?source=collection_archive---------1-----------------------#2022-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5aec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在React 18中处理双重渲染问题最终让你使用了像<a class="ae ki" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> react-query </a>或<a class="ae ki" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank"> SWR </a>这样的API处理库。厉害！但是，您知道吗，您可以从12Kb(或者SWR的4Kb)中获得比API抓取更多的东西？以下是这些令人敬畏的库的五种非常新颖的用法。</p><h1 id="a0c1" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">更喜欢视频？</h1><p id="0b25" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">如果你更喜欢看你的技术故事，那就去YouTube上看看。</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Five Clever Hacks for React-Query and SWR: The Video!</figcaption></figure><h1 id="6a61" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">简化的多次提取</h1><p id="dc5a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我们倾向于把一个<code class="fe lx ly lz ma b">useQuery</code>钩子看作是每次获取一个钩子。但是，假设您要进行两次提取。例如，您有一个登录系统，在该系统中，您首先获取进行登录，然后在获得用户ID后再次获取用户信息。</p><p id="258d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能会从以下内容开始:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="5599" class="mf kk in ma b gy mg mh l mi mj">import { useQuery } from "react-query";</span><span id="0d6d" class="mf kk in ma b gy mk mh l mi mj">const fetchLogin = () =&gt; fetch("/login.json").json();<br/>const fetchUser = (id) =&gt; fetch(`/${id}.json`).json();</span><span id="f402" class="mf kk in ma b gy mk mh l mi mj"><em class="ml">const MyComponent = () =&gt; {<br/>  const</em> { <em class="ml">data</em>: login } =<em class="ml"> useQuery</em>("login"<em class="ml">, </em>fetchLogin);<br/>  <em class="ml">const</em> { <em class="ml">data</em>: user } =<em class="ml"> useQuery</em>(<br/>    "user"<em class="ml">,</em> () =&gt; fetchUser(login.id),<br/>    { enabled: login?.id }<br/>  );</span><span id="c0fc" class="mf kk in ma b gy mk mh l mi mj">  return &lt;div&gt;{JSON.stringify(user)}&lt;/div&gt;<br/>}</span></pre><p id="8725" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个模型中，我们级联这两个<code class="fe lx ly lz ma b">useQuery</code>钩子。首先，我们获取登录名，然后一旦登录名返回非零的<code class="fe lx ly lz ma b">id</code>，我们就<code class="fe lx ly lz ma b">enable</code>进行第二次查询。现在，这是可行的。可是这样的痛苦！想象一下，如果有三个或更多的请求会更复杂。一定有更好的方法！</p><p id="8e99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们可以只做一个<code class="fe lx ly lz ma b">login</code>函数，就像这样:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="0c51" class="mf kk in ma b gy mg mh l mi mj">const login = async () =&gt; {<br/>  const resp = await fetch("/login.json");<br/>  const { id } = await resp.json();</span><span id="8498" class="mf kk in ma b gy mk mh l mi mj">  const userResp = await fetch(`/${id}.json`);<br/>  const user = await userResp.json();<br/>  return user;<br/>};</span></pre><p id="cb83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的组件中使用它。</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="b047" class="mf kk in ma b gy mg mh l mi mj"><em class="ml">const MyComponent = () =&gt; {<br/>  const</em> {data: user} =<em class="ml"> useQuery</em>("login"<em class="ml">, </em>login);<br/>  return &lt;div&gt;{JSON.stringify(user)}&lt;/div&gt;<br/>}</span></pre><p id="e167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你看，<code class="fe lx ly lz ma b">useQuery</code>监控任何函数，它可以是单个的<code class="fe lx ly lz ma b">fetch</code>，也可以是这样的函数，用逻辑等进行多次提取。或者它可能根本就不是一个提取(正如我们将很快看到的)。这里的要点是开始跳出<code class="fe lx ly lz ma b">fetch</code>的框框思考。</p><p id="40ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在我们结束关于<code class="fe lx ly lz ma b">fetch</code>的话题之前，让我们来看两个更方便的变体。</p><p id="b814" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果您要进行一系列的读取操作，您可以这样做:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="d10a" class="mf kk in ma b gy mg mh l mi mj">const getTextData = async () =&gt; {<br/>  const out = [];<br/>  for (const name of ["a", "b", "c"]) {<br/>    const resp = await fetch(`/data_${name}.json`);<br/>    out.push(await resp.json());<br/>  }<br/>  return out;<br/>};<br/>...<br/><em class="ml">const</em> {data: textData} =<em class="ml"> useQuery</em>("textData"<em class="ml">, </em>getTextData);</span></pre><p id="b36c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们使用一个<code class="fe lx ly lz ma b">for</code>循环来遍历一个值数组，然后在返回所有值之前请求每个值的JSON。顺便说一句，如果你喜欢这个例子，但不喜欢<code class="fe lx ly lz ma b">for</code>，你用<code class="fe lx ly lz ma b">forEach</code>替换它，它不会工作，那是因为<code class="fe lx ly lz ma b">forEach</code>与<code class="fe lx ly lz ma b">async/await</code>不兼容，但是嘿，你自己试试看，享受吧。</p><p id="3d5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您想并行执行此操作，可以尝试如下方式:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="42e5" class="mf kk in ma b gy mg mh l mi mj">const getTextData = async () =&gt; Promise.all(<br/>  ["a", "b", "c"].map(async (name) =&gt; {<br/>    const resp = await fetch(`/data_${name}.json`);<br/>    return await resp.json();<br/>  })<br/>);</span></pre><p id="1349" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也是可行的，但是我不认为结果的顺序是有保证的，这将取决于单个读取的解决速度。</p><p id="aa06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我听到你在尖叫:“够了，别玩了！给我看看新的！”好吧好吧。</p><h1 id="5624" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">记录时间</h1><p id="a321" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们用SWR做一个秒表。不，我没开玩笑！</p><p id="093a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将从创建一个函子(一个产生函数的函数)开始，这个函子将利用一个知道它被创建的时间的函数。当我们调用它时，它会返回开始时间和当前时间之间的差值，以秒为单位。</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="5e51" class="mf kk in ma b gy mg mh l mi mj">const createStopwatch = () =&gt; {<br/>  const startTime = Date.now();<br/>  return () =&gt; {<br/>    return Math.round((Date.now() - startTime) / 1000);<br/>  };<br/>};</span></pre><p id="9eb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，当我们调用<code class="fe lx ly lz ma b">createStopwatch</code>时，我们将得到一个知道其开始时间的函数，并给出从那时起经过的时间。我们可以在使用<code class="fe lx ly lz ma b">useSWR</code>钩子的组件中使用它，就像这样:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="742b" class="mf kk in ma b gy mg mh l mi mj"><em class="ml">import</em> useSWR <em class="ml">from</em> "swr";</span><span id="3774" class="mf kk in ma b gy mk mh l mi mj">const Stopwatch = () =&gt; {<br/>  const stopwatchRef = useRef(createStopwatch());<br/>  const { data } = useSWR("stopwatch", stopwatchRef.current, {<br/>    refreshInterval: 100,<br/>    dedupingInterval: 100,<br/>  });</span><span id="fb8c" class="mf kk in ma b gy mk mh l mi mj">  return &lt;div&gt;Time: {data}&lt;/div&gt;;<br/>};</span></pre><p id="e515" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先创建一个ref来保存这个函数，因为我们使用了<code class="fe lx ly lz ma b">useRef</code>，这个函数在挂载时只会被调用一次。然后我们在<code class="fe lx ly lz ma b">useSWR</code>钩子中使用那个函数(通过从<code class="fe lx ly lz ma b">stopwatchRef.current</code>中获取)，由于<code class="fe lx ly lz ma b">refreshInterval</code>，钩子每100毫秒调用一次那个函数。</p><p id="4d3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！嘣！秒表！我们使用SWR内置的刷新间隔来调用这个同步函数，而不是每100毫秒获取数据。</p><p id="af5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，这很酷，但并不实际，让我们尝试一些相关但更实际的东西。</p><h1 id="8f36" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">监控那些日志！</h1><p id="9d44" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">假设您想要UI的一部分来监视日志。日志每100毫秒就会更新一次<strong class="jm io"> lot </strong>。但是您不希望如此频繁地更新UI，因为，让我们面对现实吧，日志并不是那么重要。那么我们可以使用react-query(或SWR)来降低更新速度吗？我们当然可以！</p><p id="4dc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们模拟一个日志:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="525c" class="mf kk in ma b gy mg mh l mi mj">const subscribeToLog = () =&gt; {<br/>  let log = [];<br/>  let logIndex = 0;</span><span id="a13e" class="mf kk in ma b gy mk mh l mi mj">  setInterval(() =&gt; {<br/>    log.push(`${logIndex}: ${Date.now()}`);<br/>    log = log.slice(-3);<br/>    logIndex++;<br/>  }, 100);</span><span id="868c" class="mf kk in ma b gy mk mh l mi mj">  return () =&gt; log;<br/>};</span><span id="004c" class="mf kk in ma b gy mk mh l mi mj">const logListener = subscribeToLog();</span></pre><p id="7a2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了一个<code class="fe lx ly lz ma b">logListener</code>全局函数，它返回由interval函数不断构建的日志消息。每隔100毫秒，该间隔会添加一条新的日志消息，然后将日志缩减到最近的三个事件(只是为了保持较小的显示大小。)</p><p id="65a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们使用react-query来获取日志，但是每秒钟只能获取一次:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="46c1" class="mf kk in ma b gy mg mh l mi mj">import { useQuery } from "react-query";</span><span id="3598" class="mf kk in ma b gy mk mh l mi mj">const Logger = () =&gt; {<br/>  const { data } = useQuery("log", logListener, {<br/>    refetchInterval: 1000,<br/>  });</span><span id="1614" class="mf kk in ma b gy mk mh l mi mj">  return (<br/>    &lt;div&gt;<br/>      {data?.map((line, index) =&gt; (<br/>        &lt;div key={line}&gt;{line}&lt;/div&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="92f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，我们使用<code class="fe lx ly lz ma b">useQuery</code>钩子每1000毫秒(1秒)轮询一次<code class="fe lx ly lz ma b">logListener</code>(它返回日志中的最后三项)。这限制了显示，所以我们不会太频繁地更新它。</p><p id="1dbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，SWR电码是非常不同的。你得把<code class="fe lx ly lz ma b">refetchInterval</code>改成<code class="fe lx ly lz ma b">refreshInterval</code>再加上那个<code class="fe lx ly lz ma b">dedupingInterval</code>。这很疯狂，我知道，差别是惊人的。</p><p id="2be6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，这确实是react-query或SWR的不同用法，但是我还有什么呢？获取GPS坐标怎么样！</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/5a4ed6215e626bed58fb2319ae98f167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xh8aAO_qTOqDTMq4GmZAqQ.jpeg"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Five Clever Hacks for React-Query and SWR image</figcaption></figure><h1 id="13ec" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">带着GPS回家</h1><p id="855a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">任何你可以包装在承诺中的东西，你都可以用这些棒极了的库来监控。以获取GPS坐标为例。这里我们将浏览器的内置<code class="fe lx ly lz ma b">getCurrentPosition</code>包装在一个承诺中:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="451a" class="mf kk in ma b gy mg mh l mi mj">const getGPSCoordinates = async () =&gt;<br/>  new Promise((resolve, reject) =&gt; {<br/>    navigator.geolocation.getCurrentPosition(<br/>      (position) =&gt; {<br/>        resolve({<br/>          latitude: position.coords.latitude,<br/>          longitude: position.coords.longitude,<br/>        });<br/>      },<br/>      (error) =&gt; {<br/>        reject(error);<br/>      }<br/>    );<br/>  });</span></pre><p id="b4ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们可以称之为…让我选一个…这次是SWR:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="85d1" class="mf kk in ma b gy mg mh l mi mj">import useSWR from "swr";</span><span id="113d" class="mf kk in ma b gy mk mh l mi mj">const GPS = () =&gt; {<br/>  const { data } = useSWR("gps", getGPSCoordinates);<br/>  return &lt;div&gt;Location: {JSON.stringify(data)}&lt;/div&gt;;<br/>};</span></pre><p id="b0f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就这样，GPS坐标在你的组件里。</p><p id="f61a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的关键点是。任何可以转换成同步函数或基于承诺的异步函数的东西，都可以与这些库一起工作。<strong class="jm io">任何事情</strong>。一点也不。</p><h1 id="4005" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">与Web Workers并行</h1><p id="e038" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">这让我想到了<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank"> Web Workers </a>，它们是非常方便的代码，可以在页面上的不同线程中运行。举一个简单的例子:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="38ef" class="mf kk in ma b gy mg mh l mi mj">export const multiplyNumbers = (a, b) =&gt; {<br/>  postMessage({ type: "result", result: a * b });<br/>};</span></pre><p id="a680" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个小家伙能把两个数字相乘，然后传回结果。这么好的小功能！无论如何，我们可以使用react-query(或SWR)将它集成到我们的代码中，非常简单。我们首先需要加载它:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="4a3f" class="mf kk in ma b gy mg mh l mi mj">import worker from "workerize-loader!./worker";</span><span id="8554" class="mf kk in ma b gy mk mh l mi mj">const workerInstance = worker();</span></pre><p id="c223" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了一个使用<code class="fe lx ly lz ma b">workerize-loader</code> Webpack加载器加载的worker实例。然后，我们可以将它包装在一个基于承诺的函数中，该函数调用它，等待结果，然后用输出解析承诺。</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="bc97" class="mf kk in ma b gy mg mh l mi mj">const multiplyNumbers = async (args) =&gt;<br/>  new Promise((resolve) =&gt; {<br/>    workerInstance.addEventListener("message", (message) =&gt; {<br/>      if (message.data.type === "result") {<br/>        resolve(message.data.result);<br/>      }<br/>    });</span><span id="4433" class="mf kk in ma b gy mk mh l mi mj">    workerInstance.multiplyNumbers(args.a, args.b);<br/>  });</span></pre><p id="0845" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们所做的就是创建一个承诺，在实例上注册一个监听器，然后进行调用。一旦监听器触发，我们就有了结果。下面是使用这个函数的组件代码，这次使用的是react-query。</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="bb16" class="mf kk in ma b gy mg mh l mi mj">import { useMutation } from "react-query";</span><span id="f8ab" class="mf kk in ma b gy mk mh l mi mj">const WebWorker = () =&gt; {<br/>  const { data: result, mutate } = useMutation(<br/>    "multiply", multiplyNumbers);</span><span id="6b79" class="mf kk in ma b gy mk mh l mi mj">  const [valueA, setValueA] = useState("10");<br/>  const [valueB, setValueB] = useState("20");</span><span id="c3f2" class="mf kk in ma b gy mk mh l mi mj">  return (<br/>    &lt;div&gt;<br/>      &lt;input<br/>        value={valueA}<br/>        onChange={(evt) =&gt; setValueA(evt.target.value)}<br/>      /&gt;<br/>      &lt;input<br/>        value={valueB}<br/>        onChange={(evt) =&gt; setValueB(evt.target.value)}<br/>      /&gt;<br/>      &lt;button onClick={<br/>        () =&gt; mutate({ a: valueA, b: valueB })<br/>      }&gt;Multiply&lt;/button&gt;<br/>      &lt;div&gt;{result}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="bed2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我使用react-query中的<code class="fe lx ly lz ma b">useMutation</code>钩子，因为它在主动执行一些事情，这样更有意义。这很重要，因为你可能会用到这些模式。确保您的查询被建模为<code class="fe lx ly lz ma b">useQuery</code>，并且可能改变事情的操作使用了<code class="fe lx ly lz ma b">useMutation</code>钩子。</p><p id="78b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，这对SWR没有帮助，也没有突变挂钩，但对SWR也有办法做到这一点。</p><p id="ef8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们通过回答这个古老的问题，以盛大的方式结束这个话题；如果你有反应查询或SWR，你需要一个状态管理器吗？</p><h1 id="3e5e" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">内置状态管理器？！？</h1><p id="ecf3" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">SWR和react-query都管理缓存，对吗？它们都可以确保，如果您从两个不同的位置访问同一个查询键，您将获得相同的数据。</p><p id="acdd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着您可以使用该缓存来全局存储您想要的数据位，并且当您更新它们时，它们将在它们被“订阅”的任何地方更新。这就像是…一个州经理工作的80%?</p><p id="9c72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们可以创建一个名为<code class="fe lx ly lz ma b">useSWRGlobalState</code>的定制钩子来完成这个全局共享的任务，看看吧。</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="7d57" class="mf kk in ma b gy mg mh l mi mj">import useSWR from "swr";</span><span id="92b1" class="mf kk in ma b gy mk mh l mi mj">const useSWRGlobalState = (key, initialData) =&gt; {<br/>  const { data, mutate } = useSWR(key, () =&gt; initialData);<br/>  return [<br/>    data ?? initialData,<br/>    (value) =&gt;<br/>      mutate(value, {<br/>        revalidate: false,<br/>      }),<br/>  ];<br/>};</span></pre><p id="57ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您给这个钩子一个<code class="fe lx ly lz ma b">key</code>，这是我们一直在使用的查询键，以及您想要的任何初始数据。反过来，它使用<code class="fe lx ly lz ma b">useSWR</code>和<code class="fe lx ly lz ma b">mutate</code>函数来获取当前数据。</p><p id="a039" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后钩子返回一个数组，看起来像是从<code class="fe lx ly lz ma b">useState</code>返回的。这是一个数组，其中第一项是当前值，第二项是setter函数。</p><p id="196c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">setter函数是神奇的地方。我们调用我们得到的<code class="fe lx ly lz ma b">mutate</code>函数，并赋予它新的值<strong class="jm io">，但是</strong>我们告诉SWR <strong class="jm io">而不是</strong>重新获取该值。也就是说。设置缓存，但仅此而已。</p><p id="a4e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以用一些组件来包装它！</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="2b23" class="mf kk in ma b gy mg mh l mi mj">const StateEditor = () =&gt; {<br/>  const [value, setValue] = useSWRGlobalState("sharedText", "");</span><span id="1150" class="mf kk in ma b gy mk mh l mi mj">  return (<br/>    &lt;input value={value}<br/>       onChange={(evt) =&gt; setValue(evt.target.value)} /&gt;<br/>  );<br/>};</span><span id="e4d8" class="mf kk in ma b gy mk mh l mi mj">const StateViewer = () =&gt; {<br/>  const [value] = useSWRGlobalState("sharedText", "");</span><span id="9c6b" class="mf kk in ma b gy mk mh l mi mj">  return &lt;div&gt;{value}&lt;/div&gt;;<br/>};</span><span id="f81d" class="mf kk in ma b gy mk mh l mi mj">const GlobalStateDemo = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;StateEditor /&gt;<br/>      &lt;StateViewer /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="1599" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们有两个独立的组件，一个编辑状态，即<code class="fe lx ly lz ma b">StateEditor</code>组件，另一个查看共享状态，即<code class="fe lx ly lz ma b">StateViewer</code>。当您输入<code class="fe lx ly lz ma b">StateEditor</code>时，变化会立即显示在<code class="fe lx ly lz ma b">StateViewer</code>中。</p><p id="2136" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不开玩笑，真的。没有上下文。没有Redux。没有原子。只有一个小钩子，和你已经拥有的“获取库”。💥很疯狂，对吧？</p><p id="95a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我真的会用这个吗？在一个可能已经有状态管理器的大型应用程序中，肯定没有。但是如果我需要在我的组件层次结构中共享的只是单一的状态，比如用户ID和JWT，那么是的，我可能会这样做。</p><p id="c2bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顺便说一句，React-Query也可以做到这一点。</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="f811" class="mf kk in ma b gy mg mh l mi mj">const useRQGlobalState = (key, initialData) =&gt; [<br/>  useQuery(key, () =&gt; initialData, {<br/>    enabled: false,<br/>    initialData,<br/>  }).data ?? initialData,<br/>  (value) =&gt; client.setQueryData(key, value),<br/>];</span></pre><p id="eaad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个钩子返回一个数组，就像前面一样，其中数组中的第一项是我们用<code class="fe lx ly lz ma b">useQuery</code>得到的当前值，然后第二个值是一个setter函数，它直接在react-query客户机上为查询设置缓存数据。</p><h1 id="2cbb" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">包装它</h1><p id="12cd" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">我希望你已经找到了一个有趣的旅程，通过引入这些令人敬畏的库，你可以从你添加到你的应用程序代码中的千字节中挖掘出更多的价值。他们真的是React生态系统的无价之宝。</p><p id="fce8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ml">更多内容请看</em><a class="ae ki" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ml">plain English . io</em></strong></a><em class="ml">。报名参加我们的</em> <a class="ae ki" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ml">免费周报</em> </strong> </a> <em class="ml">。关注我们关于</em><a class="ae ki" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ml">Twitter</em></strong></a><em class="ml">和</em><a class="ae ki" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ml">LinkedIn</em></strong></a><em class="ml">。查看我们的</em> <a class="ae ki" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ml">社区不和谐</em> </strong> </a> <em class="ml">加入我们的</em> <a class="ae ki" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ml">人才集体</em> </strong> </a> <em class="ml">。</em></p></div></div>    
</body>
</html>