<html>
<head>
<title>11 Mistakes to Avoid When Using React in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在2022年使用React时要避免的11个错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/11-mistakes-to-avoid-when-using-react-in-2022-d93d26c46181?source=collection_archive---------0-----------------------#2022-08-15">https://javascript.plainenglish.io/11-mistakes-to-avoid-when-using-react-in-2022-d93d26c46181?source=collection_archive---------0-----------------------#2022-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c1ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React开发中应该避免的一些常见错误。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8e244458a9128c84e25f67db576b7fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JaBfPmXYosuPFLF_SUppg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Cover via freecoursesonline</figcaption></figure><p id="b8ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着React越来越流行，越来越多的React开发者在开发过程中遇到了各种各样的问题。</p><p id="f611" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将根据我的实际工作经验，总结React开发中的一些常见错误，以帮助您避免一些错误。</p><p id="e336" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你是刚开始使用React，建议你好好看看这篇文章。如果您已经使用React开发项目，也建议您检查并填补空白。</p><p id="a76b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">读完这篇文章，你将学会如何避免这11个反应错误:</p><ol class=""><li id="f6be" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">呈现列表时，不要使用键。</li><li id="c24e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">通过赋值直接修改状态值。</li><li id="fec4" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">将状态值直接绑定到输入的value属性。</li><li id="2c52" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">执行setState后直接使用state。</li><li id="63e4" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">使用useState + useEffect时无限循环。</li><li id="f335" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">忘记清理useEffect中的副作用。</li><li id="0a8f" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">布尔运算符的使用不正确。</li><li id="53c2" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">未定义组件参数类型。</li><li id="c3b4" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">将字符串作为值传递给组件。</li><li id="08b1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">没有以大写字母开头的组件名称。</li><li id="1545" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">元素的事件绑定不正确。</li></ol></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="1a87" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">1.呈现列表时，不要使用键</h1><h1 id="5d06" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="e21a" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">当我们第一次学习React时，我们会根据文档中描述的方法呈现一个列表，例如:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="eb7c" class="nt mn iq np b gy nu nv l nw nx">const numbers = [1, 2, 3, 4, 5];<br/>const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;);</span></pre><p id="8b33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">渲染后，控制台会提示一个警告⚠️ <code class="fe ny nz oa np b">a key should be provided for list items</code>。</p><h1 id="b000" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="55a4" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">您只需要按照提示为每个项目添加<code class="fe ny nz oa np b">key</code>属性:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="65d4" class="nt mn iq np b gy nu nv l nw nx">const numbers = [1, 2, 3, 4, 5];<br/>const listItems = numbers.map((number, index) =&gt; &lt;li key={index}&gt;{number}&lt;/li&gt;);</span></pre><p id="8809" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ny nz oa np b">key</code>帮助React识别哪些元素发生了变化，比如被添加或删除。所以我们需要为数组中的每个元素设置一个唯一的<code class="fe ny nz oa np b">key</code>值。</p><p id="c7e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于<code class="fe ny nz oa np b">key</code>的值，最好设置为唯一值。在上面的例子中，<code class="fe ny nz oa np b">index</code>被用作<code class="fe ny nz oa np b">key</code>的值。官方不建议。列表的顺序会变，没有唯一值，也没有最后一招。在这种情况下，性能会下降。</p><h1 id="cc3a" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">📚证明文件</h1><p id="535c" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><a class="ae ob" href="https://reactjs.org/docs/lists-and-keys.html#basic-list-component" rel="noopener ugc nofollow" target="_blank"> React —基本列表组件</a></p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="1bbe" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">2.通过赋值直接修改状态值</h1><h1 id="48e0" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="e305" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">在React中，状态不能直接赋值和修改，否则会导致难以修复的问题。示例:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="9219" class="nt mn iq np b gy nu nv l nw nx">updateState = () =&gt; {<br/>  this.state.name = "Chris1993";<br/>};</span></pre><p id="76c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，编辑会提示警告⚠️:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="22e5" class="nt mn iq np b gy nu nv l nw nx">Do not mutate state directly. Use setState().</span></pre><h1 id="2c75" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="ad5c" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">类组件可以用<code class="fe ny nz oa np b">setState()</code>方法修改，功能组件可以用<code class="fe ny nz oa np b">useState()</code>修改:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="ec82" class="nt mn iq np b gy nu nv l nw nx"><em class="oc">// ClassComponent：use setState()</em><br/>this.setState({ name: "Chris1993" });</span><span id="a0cd" class="nt mn iq np b gy od nv l nw nx"><em class="oc">// FunctionConponent：use useState()</em><br/>const [name, setName] = useState("");<br/>setName("Chris1993");</span></pre><h1 id="7f08" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">📚证明文件</h1><p id="5ff9" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><a class="ae ob" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">反应—状态和生命周期</a> <a class="ae ob" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">反应—使用状态挂钩</a></p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="8629" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">3.将状态值直接绑定到输入的值属性</h1><h1 id="2c6e" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="de07" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">当我们直接将<code class="fe ny nz oa np b">state</code>的值作为参数绑定到<code class="fe ny nz oa np b">input</code>标签的<code class="fe ny nz oa np b">value</code>属性时，会发现无论我们在输入框中输入什么，输入框的内容都不会改变。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="44a2" class="nt mn iq np b gy nu nv l nw nx">export default function App() {<br/>  const [count, setCount] = useState(0);<br/>  return &lt;input type="text" value={count} /&gt;;<br/>}</span></pre><p id="af93" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是因为我们使用state为默认值的状态变量赋给<code class="fe ny nz oa np b">&lt;input&gt;</code>的<code class="fe ny nz oa np b">value</code>，功能组件中的<code class="fe ny nz oa np b">state</code>只能被<code class="fe ny nz oa np b">useState</code>返回的<code class="fe ny nz oa np b">set</code>方法修改。所以解决方法也很简单，修改时使用<code class="fe ny nz oa np b">set</code>方法即可。</p><h1 id="0b21" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="298b" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">只需将一个<code class="fe ny nz oa np b">onChange</code>事件绑定到<code class="fe ny nz oa np b">&lt;input&gt;</code>，通过调用<code class="fe ny nz oa np b">setCount</code>对其进行修改:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="617c" class="nt mn iq np b gy nu nv l nw nx">export default function App() {<br/>  const [count, setCount] = useState(0);<br/>  const change = (val) =&gt; setCount(val.value);<br/>  return &lt;input type="text" value={count} onChange={change} /&gt;;<br/>}</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="1478" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">4.执行setState后直接使用state</h1><h1 id="0b07" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="7b45" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">当我们通过<code class="fe ny nz oa np b">setState()</code>修改数据并立即得到新数据时，会出现数据还是旧数据的情况:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="0095" class="nt mn iq np b gy nu nv l nw nx"><em class="oc">// init state data</em><br/>this.state = { name: "Chris1993" };</span><span id="4eeb" class="nt mn iq np b gy od nv l nw nx"><em class="oc">// update state data</em><br/>this.setState({ name: "Hello Chris1993!" });<br/>console.log(this.state.name); <em class="oc">// output: Chris1993</em></span></pre><p id="28db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可能会认为此时输入的<code class="fe ny nz oa np b">this.state.name</code>应该是<code class="fe ny nz oa np b">Hello Chris1993!</code>，结果却是<code class="fe ny nz oa np b">Chris1993</code>。</p><p id="2ec2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是因为<code class="fe ny nz oa np b">setState()</code>是异步的。执行<code class="fe ny nz oa np b">setState()</code>时，真正的更新操作会放在异步队列中执行，下一个要执行的代码(即<code class="fe ny nz oa np b">console.log</code>这一行)是同步执行的，所以打印出来的<code class="fe ny nz oa np b">state</code>不是最新值。</p><h1 id="1c62" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="c2d9" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">只需把后续要执行的操作封装成一个函数作为<code class="fe ny nz oa np b">setState()</code>的第二个参数，这个回调函数会在更新完成后执行。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="3998" class="nt mn iq np b gy nu nv l nw nx">this.setState({ name: "Hello Chris1993!" }, () =&gt; {<br/>  console.log(this.state.name); <em class="oc">// output: Hello Chris1993!</em><br/>});</span></pre><p id="6282" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在输出了正确的内容。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="260a" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">5.使用useState + useEffect时出现无限循环</h1><h1 id="9d99" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="3374" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">当我们在<code class="fe ny nz oa np b">useEffect()</code>中直接调用<code class="fe ny nz oa np b">useState()</code>返回的<code class="fe ny nz oa np b">set*()</code>方法，并且不设置<code class="fe ny nz oa np b">useEffect()</code>的第二个参数时，会发现一个死循环:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="0398" class="nt mn iq np b gy nu nv l nw nx">export default function App() {<br/>  const [count, setCount] = useState(0);<br/>  useEffect(() =&gt; {<br/>    setCount(count + 1);<br/>  });<br/>  return &lt;div className="App"&gt;{count}&lt;/div&gt;;<br/>}</span></pre><p id="dd33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这时可以看到页面上的数据一直在增加，<code class="fe ny nz oa np b">useEffect()</code>被无限调用，进入无限循环状态。</p><h1 id="1c95" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="17ea" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">这是一个错误使用<code class="fe ny nz oa np b">useEffect()</code>的常见问题。<code class="fe ny nz oa np b">useEffect()</code>可以看作是类组件中三个生命周期函数<code class="fe ny nz oa np b">componentDidMount</code>、<code class="fe ny nz oa np b">componentDidUpdate</code>和<code class="fe ny nz oa np b">componentWillUnmount</code>的组合。<code class="fe ny nz oa np b">useEffect(effect, deps)</code>接受两个参数:</p><ul class=""><li id="8d82" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated"><code class="fe ny nz oa np b">effect</code>副作用功能。</li><li id="36e0" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq oe lx ly lz bi translated"><code class="fe ny nz oa np b">deps</code>阵列的依赖性。</li></ul><p id="efa8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当<code class="fe ny nz oa np b">deps</code>阵列改变时，执行副作用功能<code class="fe ny nz oa np b">effect</code>。要修改方法，只需在<code class="fe ny nz oa np b">useEffect()</code>的第二个参数中传递<code class="fe ny nz oa np b">[]</code>:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="38e3" class="nt mn iq np b gy nu nv l nw nx">export default function App() {<br/>  const [count, setCount] = useState(0);<br/>  useEffect(() =&gt; {<br/>    setCount(count + 1);<br/>  }, []);<br/>  return &lt;div className="App"&gt;{count}&lt;/div&gt;;<br/>}</span></pre><p id="f030" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总结使用<code class="fe ny nz oa np b">useEffect</code>的四种情况:</p><ul class=""><li id="c35e" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated"><strong class="kx ir">不要设置第二个参数</strong>:当有状态更新时，会触发<code class="fe ny nz oa np b">useEffect</code>的副作用功能。</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="ba5b" class="nt mn iq np b gy nu nv l nw nx">useEffect(() =&gt; {<br/>  setCount(count + 1);<br/>});</span></pre><ul class=""><li id="90f0" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated"><strong class="kx ir">第二个参数是空数组</strong>:只有在挂载和卸载的时候才会触发<code class="fe ny nz oa np b">useEffect</code>的副作用函数。</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="c5d8" class="nt mn iq np b gy nu nv l nw nx">useEffect(() =&gt; {<br/>  setCount(count + 1);<br/>}, []);</span></pre><ul class=""><li id="0f3e" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated"><strong class="kx ir">第二个参数是一个单值数组</strong>:只有值发生变化时才会触发<code class="fe ny nz oa np b">useEffect</code>的副作用函数。</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="64ca" class="nt mn iq np b gy nu nv l nw nx">useEffect(() =&gt; {<br/>  setCount(count + 1);<br/>}, [name]);</span></pre><ul class=""><li id="3e4f" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated"><strong class="kx ir">第二个参数是一个多值数组</strong>:只有当传递的值发生变化时才会触发<code class="fe ny nz oa np b">useEffect</code>的副作用函数。</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="216a" class="nt mn iq np b gy nu nv l nw nx">useEffect(() =&gt; {<br/>  setCount(count + 1);<br/>}, [name, age]);</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="7786" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">6.忘记清理使用效果中的副作用</h1><h1 id="d6a4" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="695e" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">在类组件中，我们使用<code class="fe ny nz oa np b">componentWillUnmount()</code>生命周期方法来清理一些副作用，比如定时器、事件监听器等。</p><h1 id="49ca" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="c7be" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">可以为<code class="fe ny nz oa np b">useEffect()</code>的副作用函数设置返回函数，类似于<code class="fe ny nz oa np b">componentWillUnmount()</code>生命周期方法的作用:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="a3fc" class="nt mn iq np b gy nu nv l nw nx">useEffect(() =&gt; {<br/>  <em class="oc">// Other Code</em><br/>  return () =&gt; clearInterval(id);<br/>}, [name, age]);</span></pre><h1 id="b721" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">📚证明文件</h1><p id="b22e" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><a class="ae ob" href="https://reactjs.org/docs/hooks-effect.html#example-using-hooks-1" rel="noopener ugc nofollow" target="_blank"> React —使用钩子的例子</a></p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="a1f3" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">7.布尔运算符的使用不正确</h1><h1 id="8ea6" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="3b06" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">在JSX/TSX语法中，我们经常使用布尔值来控制呈现的元素，并且在许多情况下我们使用<code class="fe ny nz oa np b">&amp;&amp;</code>操作符来处理这个逻辑:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="3d90" class="nt mn iq np b gy nu nv l nw nx">const count = 0;<br/>const Comp = () =&gt; count &amp;&amp; &lt;h1&gt;Chris1993&lt;/h1&gt;;</span></pre><p id="bc7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们以为这个时候页面显示的是空的内容，实际上上面显示的是<code class="fe ny nz oa np b">0</code>的内容。</p><h1 id="82c5" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="02f0" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">原因是因为<a class="ae ob" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank"> falsy </a>表达式导致<code class="fe ny nz oa np b">&amp;&amp;</code>之后的元素被跳过，但返回falsy表达式的值。所以我们尽量把判断条件写得尽可能完整，不依赖于JavaScript的布尔值的真假来比较:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="11db" class="nt mn iq np b gy nu nv l nw nx">const count = 0;<br/>const Comp = () =&gt; count &gt; 0 &amp;&amp; &lt;h1&gt;Chris1993&lt;/h1&gt;;</span></pre><p id="a892" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">页面将显示空内容。</p><h1 id="4299" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">📚证明文件</h1><p id="4551" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><a class="ae ob" href="https://reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator" rel="noopener ugc nofollow" target="_blank">用逻辑&amp; &amp;运算符</a>反应—内嵌If</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="8b96" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">8.未定义组件参数类型</h1><h1 id="da84" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="f127" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">对于团队开发来说很常见。如果每个人开发的组件都没有定义好的参数类型，很容易让合作的同事不知道如何使用组件，非常麻烦，比如:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="7638" class="nt mn iq np b gy nu nv l nw nx">const UserInfo = (props) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      {props.name} : {props.age}<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><h1 id="f3c4" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="f98d" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">解决方案是</p><ul class=""><li id="1178" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated">使用TypeScript，定义组件的<code class="fe ny nz oa np b">props</code>类型；</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="7c2f" class="nt mn iq np b gy nu nv l nw nx"><em class="oc">// ClassComponent</em><br/>interface AppProps {<br/>  value: string;<br/>}<br/>interface AppState {<br/>  count: number;<br/>}</span><span id="81e0" class="nt mn iq np b gy od nv l nw nx">class App extends React.Component&lt;AppProps, AppStore&gt; {<br/>  <em class="oc">// ...</em><br/>}</span><span id="510a" class="nt mn iq np b gy od nv l nw nx"><em class="oc">// FunctionComponent</em><br/>interface AppProps {<br/>  value?: string;<br/>}<br/>const App: React.FC&lt;AppProps&gt; = ({ value = "", children }) =&gt; {<br/>  <em class="oc">//...</em><br/>};</span></pre><ul class=""><li id="90fa" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated">不使用TypeScript，可以使用<code class="fe ny nz oa np b">propTypes</code>定义<code class="fe ny nz oa np b">props</code>类型；</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="43b3" class="nt mn iq np b gy nu nv l nw nx">const UserInfo = (props) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      {props.name} : {props.age}<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="3b83" class="nt mn iq np b gy od nv l nw nx">UserInfo.propTypes = {<br/>  name: PropTypes.string.isRequired,<br/>  age: PropTypes.number.isRequired,<br/>};</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="fb28" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">9.将字符串作为值传递给组件</h1><h1 id="29cb" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="bee0" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">由于React也有一个模板语法，与HTML非常相似，所以经常会出现数字作为道具直接传递给组件的情况，从而导致意外的值判断:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="fd61" class="nt mn iq np b gy nu nv l nw nx">&lt;MyComp count="99"&gt;&lt;/MyComp&gt;</span></pre><p id="7844" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过<code class="fe ny nz oa np b">MyComp</code>组件中的<code class="fe ny nz oa np b">props.count === 99</code>将返回<code class="fe ny nz oa np b">false</code>。</p><h1 id="1648" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="2341" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">正确的方法应该是使用花括号来传递参数:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="d97d" class="nt mn iq np b gy nu nv l nw nx">&lt;MyComp count={99}&gt;&lt;/MyComp&gt;</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="f25f" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">10.没有以大写字母开头的组件名称</h1><h1 id="3a05" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><p id="83a0" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">刚刚起步的开发人员经常忘记以大写字母开始他们的组件名称。在JSX/TSX以小写字母开头的组件被编译成HTML元素，比如HTML标签的<code class="fe ny nz oa np b">&lt;div /&gt;</code>。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="0399" class="nt mn iq np b gy nu nv l nw nx">class myComponent extends React.component {}</span></pre><h1 id="cde7" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="c2b2" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">只需将第一个字母改为大写:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="d306" class="nt mn iq np b gy nu nv l nw nx">class MyComponent extends React.component {}</span></pre><h1 id="6566" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">📚证明文件</h1><p id="a6ce" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><a class="ae ob" href="https://reactjs.org/docs/components-and-props.html#rendering-a-component" rel="noopener ugc nofollow" target="_blank">反应——渲染一个组件</a></p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="6509" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">11.元素的事件绑定不正确</h1><h1 id="bfe0" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎀问题</h1><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="16c8" class="nt mn iq np b gy nu nv l nw nx">import { Component } from "react";</span><span id="f5e6" class="nt mn iq np b gy od nv l nw nx">export default class HelloComponent extends Component {<br/>  constructor() {<br/>    super();<br/>    this.state = {<br/>      name: "Chris1993",<br/>    };<br/>  }</span><span id="8107" class="nt mn iq np b gy od nv l nw nx">  update() {<br/>    this.setState({ name: "Hello Chris1993!" });<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button onClick={this.update}&gt;update&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="3d99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">点击<code class="fe ny nz oa np b">update</code>按钮时，控制台会报错:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="6f48" class="nt mn iq np b gy nu nv l nw nx">Cannot read properties of undefined (reading 'setState')</span></pre><h1 id="9bef" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">🎉解决方法</h1><p id="7caa" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">这是因为<code class="fe ny nz oa np b">this</code>指出了问题所在，有几种解决方案:</p><ul class=""><li id="8d9d" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated">在构造函数中绑定</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="c82b" class="nt mn iq np b gy nu nv l nw nx">constructor() {<br/>  super();<br/>  this.state = {<br/>    name: "Chris1993"<br/>  };<br/>  this.update = this.update.bind(this);<br/>}</span></pre><ul class=""><li id="d69b" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated">使用箭头功能</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="a63f" class="nt mn iq np b gy nu nv l nw nx">update = () =&gt; {<br/>  this.setState({ name: "Hello Chris1993!" });<br/>};</span></pre><ul class=""><li id="3021" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated">在渲染函数中绑定(不推荐，每次组件渲染时创建一个新函数，影响性能)</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="50da" class="nt mn iq np b gy nu nv l nw nx">&lt;button onClick={this.update.bind(this)}&gt;update&lt;/button&gt;</span></pre><ul class=""><li id="83be" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq oe lx ly lz bi translated">在渲染函数中使用箭头函数(不推荐，每次组件渲染时创建一个新函数，影响性能)</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="b61f" class="nt mn iq np b gy nu nv l nw nx">&lt;button onClick={() =&gt; this.update()}&gt;update&lt;/button&gt;</span></pre><h1 id="b2e2" class="mm mn iq bd mo mp ne mr ms mt nf mv mw jw ng jx my jz nh ka na kc ni kd nc nd bi translated">📚证明文件</h1><p id="cdcf" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">如何将一个事件处理器(比如onClick)传递给一个组件？</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="6b4d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你觉得这篇文章不错，请点赞、评论、关注，你的支持是我分享的最大动力。😺</p><div class="of og gp gr oh oi"><a href="https://medium.com/@Chris1993/15-useful-custom-react-hooks-for-your-next-web-app-c5902d868f4c" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">为你的下一个网络应用提供15个有用的自定义反应挂钩</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">本文与你分享15个非常有用的React Hooks函数。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kp oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/10-best-react-notification-libraries-in-2022-e06e8d338bb3"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">2022年10大最佳反应通知库</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在这篇文章中，我将向你介绍一些伟大的第三方反应通知库，以帮助你成为一个…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kp oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-develop-react-functional-components-with-typescript-12c2cfbb271d"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">如何用TypeScript开发React功能组件</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">用TypeScript定义React功能组件的4种方法:使用React。JSX足球俱乐部。元素，反应。有孩子的建议，&amp;…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="or l"><div class="oy l ot ou ov or ow kp oi"/></div></div></a></div></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="9828" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="oc">更多内容看</em> <a class="ae ob" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="oc">说白了。报名参加我们的</em> <a class="ae ob" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="oc">免费周报</em> </strong> </a> <em class="oc">。关注我们关于</em><a class="ae ob" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="oc">Twitter</em></strong></a><a class="ae ob" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="oc">LinkedIn</em></strong></a><em class="oc">，以及</em> <a class="ae ob" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="oc">不和</em> </strong> </a> <em class="oc">。</em></strong></a></p></div></div>    
</body>
</html>