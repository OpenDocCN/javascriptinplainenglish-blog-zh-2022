<html>
<head>
<title>Call and Apply in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript调用和应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/call-and-apply-in-javascript-f4974fc781aa?source=collection_archive---------11-----------------------#2022-10-06">https://javascript.plainenglish.io/call-and-apply-in-javascript-f4974fc781aa?source=collection_archive---------11-----------------------#2022-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2696" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的调用和应用简介</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de6bb3174ea6756508b36e943136f77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DiSzc3ZHNCiAb9ig1fQ3w.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="kr ks l"/></div></figure><h2 id="fa9b" class="kt ku iq bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">介绍</h2><p id="0d58" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx lc ly lz ma lg mb mc md lk me mf mg mh ij bi translated">当我们使用调用和应用时，我们通常是在处理对象。通过使用这些方法，我们可以从一个对象到另一个对象继承对象方法。例如，如果一个方法是在对象一上定义的，它可以被对象二调用。</p><p id="5e50" class="pw-post-body-paragraph lp lq iq lr b ls mi jr lu lv mj ju lx lc mk lz ma lg ml mc md lk mm mf mg mh ij bi translated">虽然call和apply背后的概念是相似的，但要注意的重要区别是，当您使用call时，您显式地传递参数，而使用apply时，您将第二个参数作为数组传递。让我们看一个例子来阐明这一点。我们将从查看调用方法开始。</p><h2 id="ba31" class="kt ku iq bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">打电话</h2><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="1de2" class="kt ku iq mo b gy ms mt l mu mv">const person = {<br/>  details: function() {<br/>    return `My name is ${this.name}`<br/>  }<br/>}</span><span id="4de2" class="kt ku iq mo b gy mw mt l mu mv">const bob = {<br/>  name: "Bob"<br/>}</span><span id="bfeb" class="kt ku iq mo b gy mw mt l mu mv">console.log(person.details.call(bob));<br/>//Returns ---&gt; My name is Bob</span></pre><p id="1ad7" class="pw-post-body-paragraph lp lq iq lr b ls mi jr lu lv mj ju lx lc mk lz ma lg ml mc md lk mm mf mg mh ij bi translated">在上面的例子中，我们创建了一个<em class="mx">人</em>对象。在对象内部，我们创建一个名为<em class="mx">细节</em>的方法。这个方法返回一个带有人名的模板文本。接下来，我们创建另一个名为<em class="mx">鲍勃</em>，<em class="mx">鲍勃</em>有一个<em class="mx">名称</em>属性和值集。最后，在控制台日志中，我们返回使用<em class="mx"> call() </em>方法调用<em class="mx"> details </em>方法的结果，并传入<em class="mx"> bob </em>作为参数。如果我们在这里不使用call方法，我们将得到下面的结果。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="7cca" class="kt ku iq mo b gy ms mt l mu mv">console.log(person.details)<br/>'My name is undefined'</span></pre><p id="0fd4" class="pw-post-body-paragraph lp lq iq lr b ls mi jr lu lv mj ju lx lc mk lz ma lg ml mc md lk mm mf mg mh ij bi translated">因此，通过使用call，我们可以使用在<em class="mx"> person </em>对象上定义的<em class="mx"> details </em>方法，但是在我们单独的bob对象上。这个指的是你作为参数传递给调用的内容。如果我们在控制台记录<em class="mx">细节</em>方法中<em class="mx">这个</em>的值，我们就可以确定这一点。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="e1e5" class="kt ku iq mo b gy ms mt l mu mv">const person = {<br/>  details: function() {<br/>    console.log(this)<br/>    //returns ---&gt; {name: 'Bob'}</span><span id="7ddd" class="kt ku iq mo b gy mw mt l mu mv">    return `My name is ${this.name}`<br/>  }<br/>}</span><span id="ff14" class="kt ku iq mo b gy mw mt l mu mv">const bob = {<br/>  name: "Bob"<br/>}</span><span id="d279" class="kt ku iq mo b gy mw mt l mu mv">console.log(person.details.call(bob));<br/>//Returns ---&gt; My name is Bob</span></pre><h2 id="982f" class="kt ku iq bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">应用</h2><p id="84ad" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx lc ly lz ma lg mb mc md lk me mf mg mh ij bi translated">Apply与call非常相似，只是我们必须传递一个数组作为第二个参数。让我们首先向使用call的初始示例添加一个参数。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="c8ee" class="kt ku iq mo b gy ms mt l mu mv">const person = {<br/>  details: function(age) {<br/>    return `My name is ${this.name} and I am ${age} years old.`<br/>  }<br/>}</span><span id="5f5b" class="kt ku iq mo b gy mw mt l mu mv">const bob = {<br/>  name: "Bob"<br/>}</span><span id="fa2f" class="kt ku iq mo b gy mw mt l mu mv">console.log(person.details.call(bob, 12));<br/>//Returns ---&gt; My name is Bob and I am 12 years old.</span></pre><p id="7ff6" class="pw-post-body-paragraph lp lq iq lr b ls mi jr lu lv mj ju lx lc mk lz ma lg ml mc md lk mm mf mg mh ij bi translated">在上面的例子中，我们现在在模板文字中使用的<em class="mx">细节</em>方法中为<em class="mx">年龄</em>设置一个参数。当我们使用call方法时，我们在传入<em class="mx"> bob </em>对象之后，再传入这个参数的值。如果我们使用apply，我们需要在这里使用一个数组。如下例所示。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="c204" class="kt ku iq mo b gy ms mt l mu mv">const person = {<br/>  details: function(age) {<br/>    return `My name is ${this.name} and I am ${age} years old.`<br/>  }<br/>}</span><span id="f22d" class="kt ku iq mo b gy mw mt l mu mv">const bob = {<br/>  name: "Bob"<br/>}</span><span id="b0b2" class="kt ku iq mo b gy mw mt l mu mv">console.log(person.details.apply(bob, [12]));<br/>//Returns ---&gt; My name is Bob and I am 12 years old.</span></pre><p id="c688" class="pw-post-body-paragraph lp lq iq lr b ls mi jr lu lv mj ju lx lc mk lz ma lg ml mc md lk mm mf mg mh ij bi translated">如果我们在使用apply时没有传入数组，我们会得到下面的错误。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="acdb" class="kt ku iq mo b gy ms mt l mu mv">Uncaught TypeError: CreateListFromArrayLike called on non-object<br/>    at &lt;anonymous&gt;:9:28</span></pre><p id="14ee" class="pw-post-body-paragraph lp lq iq lr b ls mi jr lu lv mj ju lx lc mk lz ma lg ml mc md lk mm mf mg mh ij bi translated">我希望你喜欢这篇文章。请随时发表任何评论、问题或反馈，并关注我以获取更多内容！</p><p id="e988" class="pw-post-body-paragraph lp lq iq lr b ls mi jr lu lv mj ju lx lc mk lz ma lg ml mc md lk mm mf mg mh ij bi translated"><em class="mx">更多内容请看</em><a class="ae my" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lr ir"><em class="mx">plain English . io</em></strong></a><em class="mx">。报名参加我们的</em> <a class="ae my" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lr ir"> <em class="mx">免费周报</em> </strong> </a> <em class="mx">。关注我们关于</em><a class="ae my" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lr ir"><em class="mx">Twitter</em></strong></a><a class="ae my" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lr ir"><em class="mx">LinkedIn</em></strong></a><strong class="lr ir"><em class="mx"/></strong><a class="ae my" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lr ir"><em class="mx">YouTube</em></strong></a><strong class="lr ir"><em class="mx">，以及</em></strong><em class="mx"/><a class="ae my" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lr ir"><em class="mx">不和</em> </strong> </a>  <em class="mx">对成长黑客感兴趣？检查</em> <a class="ae my" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lr ir"> <em class="mx">电路</em> </strong> </a> <strong class="lr ir"> <em class="mx">。</em> </strong></p></div></div>    
</body>
</html>