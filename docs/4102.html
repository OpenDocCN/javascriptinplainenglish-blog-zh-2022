<html>
<head>
<title>JavaScript Proxy: Using JavaScript Proxies like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript代理:像专业人士一样使用JavaScript代理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-proxy-using-javascript-proxies-like-a-pro-ed632342a3a2?source=collection_archive---------6-----------------------#2022-10-25">https://javascript.plainenglish.io/javascript-proxy-using-javascript-proxies-like-a-pro-ed632342a3a2?source=collection_archive---------6-----------------------#2022-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cd23f7a5b9d82d3be9b119bf5d3c1fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2b7PP4SAQOolObfvwuOKHA.png"/></div></div></figure><p id="daa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代理是JavaScript中的对象，它允许你制作一个对象的代理，同时也为标准的对象操作如<code class="fe kw kx ky kz b">get</code>、<code class="fe kw kx ky kz b">set</code>和<code class="fe kw kx ky kz b">has</code>定义自定义行为。这意味着，例如，如果有人试图从对象中获取属性值，您可以定义一组自定义行为。这将代理变成了一个非常强大的工具，所以让我们看看它们是如何工作的。</p><h1 id="b0e1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">JavaScript代理的基础知识</h1><p id="a50d" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">上面的内容听起来很复杂，所以首先让我们看一个没有任何方法的简单例子。可以使用<code class="fe kw kx ky kz b">new Proxy()</code>构造函数创建代理，它接受两个参数:</p><ul class=""><li id="afda" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">target</code>，也就是最初的对象。</li><li id="c0e7" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">handler</code>，这是我们将添加到我们的对象之上的一组方法或属性。</li></ul><p id="1f39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">handler</code>可以包含一个预定义方法的列表。例如，如果我们为<code class="fe kw kx ky kz b">get</code>定义一个方法，它将定制当我们试图从一个对象中<code class="fe kw kx ky kz b">get</code>一个项目时会发生什么。</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="e692" class="mz lb iq kz b gy na nb l nc nd">let target = {<br/>    firstName: "John",<br/>    lastName: "Doe",<br/>    age: 152<br/>}</span><span id="61e8" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>    get: (object, prop) =&gt; {<br/>        console.log(`Hi ${object.firstName} ${object.lastName}`)<br/>    }<br/>}</span><span id="00da" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);</span><span id="dd47" class="mz lb iq kz b gy ne nb l nc nd">proxyExample.age; // console logs "Hi John Doe"</span></pre><p id="3ea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们试图<code class="fe kw kx ky kz b">get</code>代理上的<code class="fe kw kx ky kz b">proxyExample.age</code>的值，自定义的<code class="fe kw kx ky kz b">get</code>处理程序触发了——所以我们控制台记录了<code class="fe kw kx ky kz b">Hi ${object.firstName} ${object.lastName}</code>。正如你所看到的，这可以成为一个非常强大的工具，因为当一个对象的标准操作被调用时，你可以做任何事情。</p><p id="2e5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，当我们将<code class="fe kw kx ky kz b">get</code>添加到上面的<code class="fe kw kx ky kz b">handler</code>时，我们有一些自定义参数。您可以添加到代理的每个处理程序都带有一组自定义参数。</p><p id="7a6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe kw kx ky kz b">get</code>，使用的功能是<code class="fe kw kx ky kz b">get(object, prop, receiver)</code>:</p><ul class=""><li id="28c8" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">object</code>——最初的对象。在上例中，这是包含<code class="fe kw kx ky kz b">firstName</code>、<code class="fe kw kx ky kz b">lastName</code>和<code class="fe kw kx ky kz b">age</code>的对象</li><li id="7868" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">prop</code>——有人企图<code class="fe kw kx ky kz b">get</code>的财产。上例中，<code class="fe kw kx ky kz b">age</code>。</li><li id="8fa6" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">reciever</code>——代理本身。</li></ul><p id="2cf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">!</p><h1 id="bc21" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">更新代理值</h1><p id="5fc4" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">代理仍然引用原始对象，因此对象值和代理值的引用是相同的。因此，如果您尝试更新代理的值，它也会更新原始对象的值。例如，下面我尝试更新代理，如您所见，原始对象和代理都被更新:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="c00f" class="mz lb iq kz b gy na nb l nc nd">let target = {<br/>    name: "John",<br/>    age: 152<br/>}</span><span id="3c60" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>}</span><span id="f3db" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);<br/>proxyExample.name = "Dave";</span><span id="d788" class="mz lb iq kz b gy ne nb l nc nd">console.log(proxyExample.name); // Console logs Dave<br/>console.log(target.name); // Console logs Dave</span></pre><p id="9bf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">知道这一点很有用——不要期望代理会完全创建一个单独的对象——这是<strong class="ka ir">而不是</strong>制作对象副本的一种方式。</p><h1 id="31a8" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">JavaScript代理中的自定义处理程序</h1><p id="47cc" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">代理有许多自定义处理程序，允许我们基本上“捕获”任何对象操作，并对它做一些有趣的事情。最常用的方法有:</p><ul class=""><li id="d4e6" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.apply(objects, thisObject, argList)</code> -一种捕获函数调用的方法。</li><li id="bff5" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.construct(object, argList, newTarget)</code> -当用<code class="fe kw kx ky kz b">new</code>构造函数关键字调用函数时进行陷阱的方法。</li><li id="793d" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.defineProperty(object, prop, descriptor)</code> -当一个新的属性被添加到一个使用<code class="fe kw kx ky kz b">Object.defineProperty</code>的对象时的一种陷印方法。</li><li id="f8f8" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.deleteProperty(object, prop)</code> -从对象中删除属性时的陷阱方法。</li><li id="38e5" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.get(object, prop, receiver)</code> -如前所述，当有人试图<code class="fe kw kx ky kz b">get</code>从一个对象获取属性时的一种陷阱方法。</li><li id="8d0b" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.set(object, prop, value, receiver)</code> -当属性被赋予一个值时进行陷阱的方法。</li><li id="1c5a" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.has(object, prop)</code> -一种捕获<code class="fe kw kx ky kz b">in</code>操作符的方法。</li></ul><p id="9f20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的方法足以完成你想用代理做的几乎所有事情。它们很好地涵盖了所有主要的对象操作，可以根据您的喜好进行修改和定制。</p><p id="e356" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一些，除了这些非常基本的对象操作，我们还可以访问:</p><ul class=""><li id="2707" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.getPrototypeOf(object)</code> -一个捕获<code class="fe kw kx ky kz b">Object.getPrototypeOf</code>方法的方法。</li><li id="f762" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.getOwnPropertyDescriptor(object, prop)</code>——一个捕获<code class="fe kw kx ky kz b">getOwnPropertyDescriptor</code>的方法，返回一个特定属性的描述符——例如，它是可枚举的吗，等等。</li><li id="faa4" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.isExtensible(object)</code> -触发<code class="fe kw kx ky kz b">Object.isExtensible()</code>时的一种陷阱方法。</li><li id="8a71" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.preventExtensions(object)</code> -触发<code class="fe kw kx ky kz b">Object.preventExtensions()</code>时的一种陷阱方法。</li><li id="0516" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.setPrototypeOf(object, prototype)</code> -触发<code class="fe kw kx ky kz b">Object.setPrototypeOf()</code>时的一种陷阱方法。</li><li id="eea6" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">proxy.ownKeys(object)</code> -当像<code class="fe kw kx ky kz b">Object.getOwnPropertyNames()</code>这样的方法被触发时的一种陷阱方法。</li></ul><p id="a825" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更详细地看看其中的一些，以理解代理是如何工作的。</p><h1 id="5f06" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">对代理使用in运算符</h1><p id="a5cc" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">我们已经讲过了<code class="fe kw kx ky kz b">proxy.get()</code>，所以让我们看看<code class="fe kw kx ky kz b">has()</code>。这主要在我们使用<code class="fe kw kx ky kz b">in</code>操作符时触发。例如，如果我们想在使用<code class="fe kw kx ky kz b">in</code>时控制台记录一个属性不存在的事实，我们可以这样做:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="0a88" class="mz lb iq kz b gy na nb l nc nd">let target = {<br/>    firstName: "John",<br/>    lastName: "Doe",<br/>    age: 152<br/>}</span><span id="4465" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>    has: (object, prop) =&gt; {<br/>        if(object[prop] === undefined) {<br/>            console.log('Property not found');<br/>        }<br/>        return object[prop]<br/>    }<br/>}</span><span id="5cc9" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);</span><span id="ebd5" class="mz lb iq kz b gy ne nb l nc nd">console.log('address' in proxyExample); <br/>// console logs <br/>// 'Property not found' <br/>// false</span></pre><p id="5511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe kw kx ky kz b">address</code>没有在<code class="fe kw kx ky kz b">target</code>中定义(因此也没有在<code class="fe kw kx ky kz b">proxyExample</code>中定义)，尝试控制台日志<code class="fe kw kx ky kz b">'address' in proxyExample</code>将返回false——但是它也将控制台日志<code class="fe kw kx ky kz b">'Property not found'</code>,正如我们在代理中定义的那样。</p><h1 id="baaf" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用代理设置值</h1><p id="6aa5" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">您可能想要修改的一个类似的有用方法是<code class="fe kw kx ky kz b">set()</code>。下面，我使用定制的<code class="fe kw kx ky kz b">set</code>处理程序来修改当我们试图改变用户年龄时会发生什么。对于每个set操作，如果属性是一个数字，那么当数字更新时，我们将控制台记录差异。</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="0230" class="mz lb iq kz b gy na nb l nc nd">let target = {<br/>    firstName: "John",<br/>    lastName: "Doe",<br/>    age: 152<br/>}</span><span id="e0e1" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>    set: (object, prop, value) =&gt; {<br/>        if(typeof object[prop] === "number" &amp;&amp; typeof value === "number") {<br/>            console.log(`Change in number was ${value - object[prop]}`);<br/>        }<br/>        return object[prop]<br/>    }<br/>}</span><span id="2f1b" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);</span><span id="d528" class="mz lb iq kz b gy ne nb l nc nd">proxyExample['age'] = 204;<br/>// Console logs <br/>// Change in number was 52</span></pre><p id="6bbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe kw kx ky kz b">proxyExample.age</code>和更新的值<code class="fe kw kx ky kz b">204</code>都是数字，我们不仅将我们的值更新为<code class="fe kw kx ky kz b">204</code>，而且我们还得到一个有用的控制台日志，告诉我们这两个数字之间的差异。很酷，对吧？</p><p id="68f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然<code class="fe kw kx ky kz b">set</code>将触发任何设置操作，包括向对象添加新项目，但是您也可以使用<code class="fe kw kx ky kz b">defineProperty</code>实现类似的行为。例如，这也是可行的:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="eafc" class="mz lb iq kz b gy na nb l nc nd">let target = {<br/>    firstName: "John",<br/>    lastName: "Doe",<br/>    age: 152<br/>}</span><span id="2772" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>    defineProperty: (object, prop, descriptor) =&gt; {<br/>        console.log(`A property was set - ${prop}`);<br/>    },<br/>}</span><span id="1544" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);</span><span id="a814" class="mz lb iq kz b gy ne nb l nc nd">proxyExample['age'] = "123 Fake Street";<br/>// Console logs<br/>// A property was set - address</span></pre><p id="2113" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是请注意，如果你添加了<code class="fe kw kx ky kz b">set</code>和<code class="fe kw kx ky kz b">defineProperty</code>作为句柄，在我们使用方括号<code class="fe kw kx ky kz b">[]</code>或<code class="fe kw kx ky kz b">.</code>符号设置属性的情况下，<code class="fe kw kx ky kz b">set</code>将覆盖<code class="fe kw kx ky kz b">defineProperty</code>。如果您显式使用<code class="fe kw kx ky kz b">Object.defineProperty</code>，那么<code class="fe kw kx ky kz b">defineProperty</code>仍然会触发，如下所示:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="7045" class="mz lb iq kz b gy na nb l nc nd">let target = {<br/>    firstName: "John",<br/>    lastName: "Doe",<br/>    age: 152<br/>}</span><span id="a2a6" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>    defineProperty: (object, prop, descriptor) =&gt; {<br/>        console.log(`A property was set with defineProperty - ${prop}`);<br/>        return true;<br/>    },<br/>    set: (object, prop, descriptor) =&gt; {<br/>        console.log(`A property was set - ${prop}`);<br/>        return true;<br/>    },<br/>}</span><span id="9c12" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);</span><span id="aa2b" class="mz lb iq kz b gy ne nb l nc nd">Object.defineProperty(proxyExample, 'socialMedia', {<br/>    value: 'twitter',<br/>    writable: false<br/>});<br/>proxyExample['age'] = "123 Fake Street";<br/>// Console logs<br/>// A property was set with defineProperty - socialMedia<br/>// A property was set - address</span></pre><h1 id="c23e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用代理删除值</h1><p id="35c2" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">除了这些有用的方法之外，我们还可以使用<code class="fe kw kx ky kz b">deleteProperty</code>来处理如果用户使用<code class="fe kw kx ky kz b">delete</code>关键字删除某些内容时会发生什么。例如，我们可以通过控制台日志让某人知道属性正在被删除:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="9379" class="mz lb iq kz b gy na nb l nc nd">let target = {<br/>    firstName: "John",<br/>    lastName: "Doe",<br/>    age: 152<br/>}</span><span id="6a41" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>    deleteProperty: (object, prop) =&gt; {<br/>        console.log(`Poof! The ${prop} property was deleted`);<br/>    },<br/>}</span><span id="58c2" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);</span><span id="cc0f" class="mz lb iq kz b gy ne nb l nc nd">delete proxyExample['age'];<br/>// Console logs<br/>// Poof! The age property was deleted</span></pre><h1 id="a7a4" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用代理定制函数调用</h1><p id="679d" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">当我们想调用一个函数时，代理还允许我们运行自定义代码。这是因为函数是对象的JavaScript怪癖。有两种方法可以做到这一点:</p><ul class=""><li id="08d6" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">使用<code class="fe kw kx ky kz b">apply()</code>处理程序，它捕获标准的函数调用。</li><li id="5124" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated">用<code class="fe kw kx ky kz b">construct()</code>处理程序，它捕获<code class="fe kw kx ky kz b">new</code>构造函数调用。</li></ul><p id="a021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个简单的例子，我们捕获一个函数调用，并通过在它的输出末尾添加一些东西来修改它。</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="b0ca" class="mz lb iq kz b gy na nb l nc nd">let target = (firstName, lastName) =&gt; {<br/>    return `Hello ${firstName} ${lastName}`<br/>}</span><span id="0fde" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>    apply: (object, thisObject, argsList) =&gt; {<br/>        let functionCall = object(...argsList);<br/>        return `${functionCall}. I hope you are having a nice day!`<br/>    },<br/>}</span><span id="f035" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);</span><span id="b5b7" class="mz lb iq kz b gy ne nb l nc nd">proxyExample("John", "Doe");<br/>// Returns<br/>// Hello John Doe. I hope you are having a nice day!</span></pre><p id="40aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">apply</code>接受三个参数:</p><ul class=""><li id="2a16" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">object</code> -原始对象。</li><li id="e648" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">thisObject</code> -函数/对象的<code class="fe kw kx ky kz b">this</code>值。</li><li id="37a5" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">argsList</code> -传递给函数的参数。</li></ul><p id="a54a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我们使用<code class="fe kw kx ky kz b">object</code>参数调用了我们的函数，它包含了最初的<code class="fe kw kx ky kz b">target</code>函数。然后我们在它的末尾添加了一些文本来改变函数的输出。又一次，很酷，对吧？</p><p id="c1f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以使用<code class="fe kw kx ky kz b">construct</code>做同样的事情，它也有三个参数:</p><ul class=""><li id="ad5b" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">object</code>——原始对象。</li><li id="214f" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">argsList</code> -函数/对象的参数。</li><li id="0627" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">newTarget</code> -最初被调用的构造函数-即代理。</li></ul><p id="88e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个函数返回一个对象的例子，我们使用代理上的<code class="fe kw kx ky kz b">construct</code>方法向它添加一些属性:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="5ceb" class="mz lb iq kz b gy na nb l nc nd">function target(a, b, c) {<br/>    return { <br/>        a: a,<br/>        b: b,<br/>        c: c<br/>    }<br/>}</span><span id="7e0f" class="mz lb iq kz b gy ne nb l nc nd">let handler = {<br/>    construct: (object, argsList, newTarget) =&gt; {<br/>        let functionCall = object(...argsList);<br/>        return { ...functionCall, d: 105, e: 45 }<br/>    },<br/>}</span><span id="072c" class="mz lb iq kz b gy ne nb l nc nd">let proxyExample = new Proxy(target, handler);</span><span id="777a" class="mz lb iq kz b gy ne nb l nc nd">new proxyExample(15, 24, 45);<br/>// Returns<br/>// {a: 15, b: 24, c: 45, d: 105, e: 45}</span></pre><h1 id="7ecf" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="f1b5" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">代理是JavaScript库中的一个神奇工具，它允许你修改对象的基本操作。这里有大量的方法可以使用，如果你正确使用它们，它们可以极大地简化你的代码。我希望你喜欢这篇文章——你可以在这里阅读更多我的JavaScript内容。</p><p id="7c2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ng">更多内容请看</em><a class="ae nf" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">plain English . io</em></strong></a><em class="ng">。报名参加我们的</em> <a class="ae nf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们关于</em><a class="ae nf" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">Twitter</em></strong></a><a class="ae nf" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">LinkedIn</em></strong></a><strong class="ka ir"><em class="ng"/></strong><a class="ae nf" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">YouTube</em></strong></a><strong class="ka ir"><em class="ng">，以及</em></strong><em class="ng"/><a class="ae nf" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">不和</em> </strong> </a>T55】</p></div></div>    
</body>
</html>