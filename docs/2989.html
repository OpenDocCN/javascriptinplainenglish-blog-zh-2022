<html>
<head>
<title>5 Tips for Using React with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React with TypeScript的5个技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-tips-for-using-react-with-typescript-a728e2905774?source=collection_archive---------6-----------------------#2022-07-20">https://javascript.plainenglish.io/5-tips-for-using-react-with-typescript-a728e2905774?source=collection_archive---------6-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ebcd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用React with TypeScript时需要掌握的五个有用的技巧。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/69f1fdb64c6cafceab2dcee587f65337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C1ihZS7eXbLSU6TR"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@sejadisruptivo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">DISRUPTIVO</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3252" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于我的许多同事来说，创建一个React应用程序是他们使用TypeScript的第一步。他们中的大多数人也从未上过TypeScript课程，因为他们包含了太多不相关的信息，这一点我同意。当在特定的库或框架中编写时(例如，在React中)，您很可能不会使用TypeScript的许多功能。特别是当你是一个初学者，只写简单的网站时，这里有五个很酷的东西，你可以在编写React应用程序时利用它们！</p><h2 id="99cc" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">1.通用组件和模糊性</h2><p id="5169" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">泛型类型很神奇；它们让我们能够为任何问题创造通用的解决方案。看看这个列表:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="5af6" class="lt lu iq ms b gy mw mx l my mz">interface TListProps&lt;T&gt; {<br/>  items: T[];<br/>  renderItem: (item: T) =&gt; JSX.Element;<br/>}</span><span id="5f3d" class="lt lu iq ms b gy na mx l my mz">const List = &lt;T,&gt;({ items, renderItem }: TListProps&lt;T&gt;) =&gt; {<br/>  return &lt;&gt;{items.map(renderItem)}&lt;/&gt;;<br/>};</span></pre><p id="8dc5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在TypeScript中，这是一种非常常见的模式。如果对你来说是新的，试着记住它。我们输入一组项目。我们记住每个元素的类型，并将其存储到t中。<code class="fe nb nc nd ms b">renderItem</code>函数独立于我们输入的列表，因此我们可以提供一个动态解决方案:想象我们输入一个字符串数组和一个对象数组——它们必须以不同的方式处理。以下是我们如何使用该组件的示例:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="2ca1" class="lt lu iq ms b gy mw mx l my mz">&lt;List<br/>  items={["one", "two"]}<br/>  renderItem={(item) =&gt; &lt;&gt;{item}&lt;/&gt;}<br/>/&gt;</span></pre><p id="809c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这种情况下，<code class="fe nb nc nd ms b">renderItem</code>中的<code class="fe nb nc nd ms b">item</code>将被自动输入为字符串。</p><p id="f8fe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当然，这实际上并没有什么作用。作为一个真正的列表，它缺少标记。我想保持这个例子简单，没有任何干扰。</p><p id="63c1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">除了通用组件的模式之外，这里还有一个值得注意的语法，我想让您知道。看看列表组件的定义:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="f924" class="lt lu iq ms b gy mw mx l my mz">const List =<strong class="ms ir"> &lt;T,&gt;</strong>(...) =&gt; {<br/>  return &lt;&gt;...&lt;/&gt;;<br/>};</span></pre><p id="30ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们写<code class="fe nb nc nd ms b">&lt;T,&gt;</code>。如果您来自另一种使用泛型的编程语言，这看起来会很尴尬。在未来的TypeScript版本或设置中，您甚至可以省略逗号。你可以先试着不用它；如果TypeScript抛出一个错误，那是因为TypeScript认为<code class="fe nb nc nd ms b">&lt;T&gt;</code>引用了一个JSX元素，并且正在寻找一个结束标记。为了消除歧义，我们加了一个逗号。通常，这表明我们需要两个泛型参数。如果我们从不添加第二个泛型参数，逗号将被忽略。这基本上是一个语法黑客。</p><h2 id="0bae" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">2.使用CSS / HTML属性</h2><p id="4c69" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">当定义一个自定义组件时，有时我们希望能够应用外部样式，就像本地JSX/HTML元素一样。我们可以通过从React类型导入<code class="fe nb nc nd ms b">CSSProperties</code>来实现这一点。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="bab9" class="lt lu iq ms b gy mw mx l my mz">import { CSSProperties} from "react";</span><span id="04ee" class="lt lu iq ms b gy na mx l my mz">interface TMyButtonProps {<br/>  style: CSSProperties;<br/>}</span><span id="bec4" class="lt lu iq ms b gy na mx l my mz">const MyButton = ({ style }: TMyButtonProps) =&gt; &lt;button style={style} /&gt;;</span></pre><p id="3765" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有了这个定义，我们可以在<code class="fe nb nc nd ms b">MyButton</code>上使用styles属性，就像它是一个普通的JSX/HTML元素一样。换句话说，我们得到了样式的自动完成和类型检查。</p><p id="f27e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是我们甚至可以更进一步。我经常看到人们在自定义按钮上重新定义HTML属性。我们可以提供本机HTML按钮元素的所有可用属性。为了实现这一点，我们引入了<code class="fe nb nc nd ms b">HTMLProps</code>类型。这是一个泛型，它希望我们传递想要从中获取属性的元素:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="77bd" class="lt lu iq ms b gy mw mx l my mz">import { HTMLProps } from "react";</span><span id="f9a5" class="lt lu iq ms b gy na mx l my mz">const MyButton = (props: HTMLProps&lt;HTMLButtonElement&gt;) =&gt; ...</span></pre><h2 id="08fa" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">3.键入事件</h2><p id="8a3b" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">类似于CSS和HTML属性，<code class="fe nb nc nd ms b">@types/react</code>也公开事件类型。举个例子，</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="6b85" class="lt lu iq ms b gy mw mx l my mz">React.MouseEvent&lt;HTMLButtonElement&gt;<br/>React.FormEvent&lt;HTMLInputElement&gt;<br/>React.KeyboardEvent&lt;HTMLInputElement&gt;</span></pre><p id="ad05" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用这些类型将允许您在没有内联的事件函数上获得自动完成(内联函数不需要显式类型化)。</p><h2 id="e051" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">4.键入使用状态</h2><p id="55ca" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">使用TypeScript时，useState挂钩是一个可以显式类型化的泛型函数。当无法推断出最终类型时，这很有用。例如，当你从一个空数组开始时。TypeScript无法知道它将保存哪种类型的对象。TypeScript会抱怨它:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="0aac" class="lt lu iq ms b gy mw mx l my mz">const [items, setItems] = useState([]);</span><span id="6f1b" class="lt lu iq ms b gy na mx l my mz">//<br/>setItems(["foo"]);<br/>//</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ne"><img src="../Images/e7c907894ee641079c5572dad08538ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_-7FQGRrUb2Pqr8Ue3bNA.png"/></div></div></figure><p id="671e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我有时会遇到这样的解决方案:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="4e7b" class="lt lu iq ms b gy mw mx l my mz">const [items, setItems] = useState([] as string[]);</span></pre><p id="9439" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然这样做可行，但最好使用通用参数:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="2fed" class="lt lu iq ms b gy mw mx l my mz">const [items, setItems] = useState&lt;string[]&gt;([]);</span></pre><p id="1bde" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">尽管这两种方法都有效，但这是一种更干净的管理类型的方式。</p><h2 id="61f7" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">5.导入非类型化模块</h2><p id="1b6f" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">并不是你要导入的每个模块都有类型。幸运的是，在过去的几年中，TypeScript的适应性有所增强，但是您可能仍然会不时地遇到不支持类型的模块。</p><p id="def3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以通过提供空声明来“关闭”类型检查:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="06dd" class="lt lu iq ms b gy mw mx l my mz">declare module "name-of-untyped-module";</span></pre><p id="3ca8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将最终把整个模块类型化为<code class="fe nb nc nd ms b">any</code>。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="4a56" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从我的经验来看，在管理了初始类型之后，对您的编码风格的大多数改进都可以通过掌握泛型来实现。如果您仍然对在代码库中使用泛型感到不舒服，那么有必要看一下整个主题。这个主题的第一步是研究常见的模式，就像我在本文第一部分提到的模式。</p><p id="e492" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就这些了，伙计们！<br/>感谢您的阅读！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="e262" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nm">更多内容请看</em><a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="nm">plain English . io</em></strong></a><em class="nm">。报名参加我们的</em> <a class="ae kw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="nm">免费周报</em> </strong> </a> <em class="nm">。关注我们关于</em><a class="ae kw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="nm">Twitter</em></strong></a><em class="nm">和</em><a class="ae kw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="nm">LinkedIn</em></strong></a><em class="nm">。查看我们的</em> <a class="ae kw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="nm">社区不和谐</em> </strong> </a> <em class="nm">加入我们的</em> <a class="ae kw" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="nm">人才集体</em> </strong> </a> <em class="nm">。</em></p></div></div>    
</body>
</html>