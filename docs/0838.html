<html>
<head>
<title>Type Coercion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的类型强制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/type-coercion-in-javascript-ef5e390d2318?source=collection_archive---------11-----------------------#2022-02-16">https://javascript.plainenglish.io/type-coercion-in-javascript-ef5e390d2318?source=collection_archive---------11-----------------------#2022-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/fa69ede00e9e3835abc5dc436d6a3c20.png" data-original-src="https://miro.medium.com/v2/0*sKveGxfoTDzpLfnE"/></div></figure><p id="c645" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然JavaScript被认为是初学者最简单的编程语言之一，但当开发人员希望JavaScript做一件事，而它却返回另一件事时，它也会变得令人沮丧。</p><p id="5f70" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我对数据类型不小心，我总是发现一些自动类型转换非常棘手。JavaScript中的类型强制是一个例子，说明当我们不知道它到底是如何工作的时候，这种语言会产生意想不到的结果。希望这篇文章能对这种神秘的行为有所启发。</p><figure class="kt ku kv kw gt jq gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/b0e50233bdf8cfeb6162f58550b725e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*9QCfn4GaimhDMabr.jpeg"/></div></figure><h1 id="42cf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JavaScript中的类型</h1><p id="80dd" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">JavaScript有七种基本类型:</p><ul class=""><li id="729b" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated"><code class="fe mj mk ml mm b">string</code></li><li id="d580" class="ma mb iq jw b jx mn kb mo kf mp kj mq kn mr kr mf mg mh mi bi translated"><code class="fe mj mk ml mm b">number</code></li><li id="7e69" class="ma mb iq jw b jx mn kb mo kf mp kj mq kn mr kr mf mg mh mi bi translated"><code class="fe mj mk ml mm b">Boolean</code></li><li id="b09b" class="ma mb iq jw b jx mn kb mo kf mp kj mq kn mr kr mf mg mh mi bi translated"><code class="fe mj mk ml mm b">undefined</code></li><li id="6021" class="ma mb iq jw b jx mn kb mo kf mp kj mq kn mr kr mf mg mh mi bi translated"><code class="fe mj mk ml mm b">null</code></li><li id="258f" class="ma mb iq jw b jx mn kb mo kf mp kj mq kn mr kr mf mg mh mi bi translated"><code class="fe mj mk ml mm b">Symbol</code></li><li id="db1b" class="ma mb iq jw b jx mn kb mo kf mp kj mq kn mr kr mf mg mh mi bi translated"><code class="fe mj mk ml mm b">BigInt</code></li></ul><p id="87c8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">JavaScript中的变量没有类型，然而，每当我们用一个值初始化一个变量时，它的类型就根据这个值来设置。</p><h1 id="00d3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">类型强制</h1><p id="759f" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">JavaScript中的类型强制只强制到<code class="fe mj mk ml mm b">string</code>、<code class="fe mj mk ml mm b">number</code>和<code class="fe mj mk ml mm b">Boolean</code>原始类型。JavaScript中没有办法将值类型强制为<code class="fe mj mk ml mm b">object</code>或<code class="fe mj mk ml mm b">function</code>。</p><p id="5515" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">JavaScript有两种典型的强制形式:<strong class="jw ir">隐式强制</strong>和<strong class="jw ir">显式强制</strong>。</p><p id="0c84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">隐式强制</strong>发生在JavaScript将值类型强制为幕后预期类型的时候。这种类型的强制在开发人员没有注意到的情况下发生。这些是我们需要小心的。</p><p id="ed69" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们想要将值类型强制为特定类型时，就会发生显式强制。大多数时候，JavaScript中的显式强制使用内置函数，如<code class="fe mj mk ml mm b">String()</code>、<code class="fe mj mk ml mm b">Number()</code>和<code class="fe mj mk ml mm b">Boolean()</code>。</p><blockquote class="ms mt mu"><p id="b264" class="ju jv mv jw b jx jy jz ka kb kc kd ke mw kg kh ki mx kk kl km my ko kp kq kr ij bi translated"><strong class="jw ir">编号</strong></p></blockquote><p id="485a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们看几个使用<code class="fe mj mk ml mm b">Number()</code>函数的<strong class="jw ir">显式强制</strong>的例子:</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="98df" class="nd ky iq mm b gy ne nf l ng nh">Number("42");           // 42<br/>Number("");             // 0<br/>Number(true);           // 1<br/>Number(false);          // 0<br/>Number(null);           // 0<br/>Number(undefined);      // NaN</span></pre><blockquote class="ms mt mu"><p id="6c2e" class="ju jv mv jw b jx jy jz ka kb kc kd ke mw kg kh ki mx kk kl km my ko kp kq kr ij bi translated"><strong class="jw ir">字符串</strong></p></blockquote><p id="0c23" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要在JavaScript中将一个值显式地强制为一个字符串，我们可以使用<code class="fe mj mk ml mm b">String()</code>函数。为了隐式地将一个值强制转换为一个字符串，我们可以对任何字符串操作数使用<code class="fe mj mk ml mm b">+</code>操作符。</p><p id="f774" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当<strong class="jw ir">显式地</strong>转换它们时，原始类型按预期转换成字符串:</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="d92d" class="nd ky iq mm b gy ne nf l ng nh">String("42");           // "42"<br/>String(true);           // "true"<br/>String(false);          // "false"<br/>String(null);           // "null"<br/>String(undefined);      // "undefined"</span></pre><p id="8df4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是当涉及到<strong class="jw ir">隐式</strong>转换时，事情就变得棘手了。！！</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="cdea" class="nd ky iq mm b gy ne nf l ng nh">10 + "10"         // "1010"<br/>20 + "200"        // "20200"<br/>0.212 + "1"       // "0.2121"<br/>null + ""         // "null"<br/>undefined + ""    // "undefined"<br/>NaN + ""          // "NaN"</span></pre><blockquote class="ms mt mu"><p id="5f19" class="ju jv mv jw b jx jy jz ka kb kc kd ke mw kg kh ki mx kk kl km my ko kp kq kr ij bi translated"><strong class="jw ir">布尔型</strong></p></blockquote><p id="f181" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">显式</strong>转换:</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="b162" class="nd ky iq mm b gy ne nf l ng nh">Boolean('')           // false<br/>Boolean(0)            // false     <br/>Boolean(-0)           // false<br/>Boolean(NaN)          // false<br/>Boolean(null)         // false<br/>Boolean(undefined)    // false<br/>Boolean(false)        // false</span></pre><p id="2f57" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">隐式</strong>转换:</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="a558" class="nd ky iq mm b gy ne nf l ng nh">true &amp;&amp; false      // false<br/>true &amp;&amp; true       // true<br/>true || false      // true<br/>true || !false     // true<br/>"name" || 0        // "name"<br/>"name" || []       // "name"<br/>"" || [1, 2, 3]    // [1, 2, 3]</span></pre></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="e427" class="kx ky iq bd kz la np lc ld le nq lg lh li nr lk ll lm ns lo lp lq nt ls lt lu bi translated">基于操作员的强制</h1><p id="5286" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">现在是棘手的时候了。你有很多操作符，它们也做很多隐式类型转换。让我们详细看看这些</p><figure class="kt ku kv kw gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/b616478f798b3572ba216ca08ce5810a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I1pz5pkS9dmWHGw5"/></div></div></figure><h1 id="75a0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">"+"运算符类型强制</h1><p id="38d2" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">对于不同的变量类型，这是一个非常棘手的操作。下面是几个例子，可能会告诉你，如果你不小心，事情会变得多么棘手。</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="bcb0" class="nd ky iq mm b gy ne nf l ng nh">true + false         // 1<br/>true + true          // 2<br/>false + false        // 0<br/>"1" + 1              // "11"<br/>{} + {}              // '[object Object][object Object]'<br/>{} + []              // 0<br/>[] + []              // ''<br/>[1] + []             // '1'<br/>[1,2]+[]             // '1,2'<br/>!([1]+[])            // false<br/>"foo" + + "bar"      // 'fooNaN'<br/>[] + null + 1        // 'null1'<br/>{}+[]+{}+[1]         // '0[object Object]1'<br/>!+[]+[]+![]          // 'truefalse'<br/>"number" + 15 + 3    // 'number153'<br/>15 + 3 + "number"    // '18number'<br/>null + ''            // 'null'<br/>null + undefined     // NaN</span></pre><p id="7299" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="mv">说明</em> </strong> —用+运算符将两个操作数相加时，如果两个值都是整数类型，JS引擎将尝试将它们相加。但是，如果任何一个值是字符串类型，JS将尝试自动将其他值转换为字符串，以便可以追加它们。</p><h1 id="12e4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">“/”运算符类型强制</h1><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="e615" class="nd ky iq mm b gy ne nf l ng nh">12 / 6             // 2<br/>12 / "6"           // 2<br/>"12" / "6"         // 2<br/>NaN / NaN          // NaN</span></pre><h1 id="a019" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">“-”运算符类型强制</h1><p id="1b2e" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">使用—运算符，JS引擎减去这些值，并尝试隐式地将这些值转换为整数。</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="1b90" class="nd ky iq mm b gy ne nf l ng nh">'10' - 10                // 0<br/>10 - '10'                // 0<br/>null - undefined         // NaN<br/>'2' - 1                  // 1</span></pre><h1 id="47f3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">" == "运算符类型强制</h1><p id="7eac" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在JS中，<strong class="jw ir"> == </strong>运算符是非常常见的比较值的方法。它根据值来比较这些值，而忽略它们的类型。</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="f73e" class="nd ky iq mm b gy ne nf l ng nh">'true' == true           // false<br/>false == 'false'         // false<br/>null == ''               // false<br/>!!"false" == !!"true"    // true<br/>['x'] == 'x'             // true<br/>NaN == NaN               // false <br/>undefined == undefined   // true<br/>null == null             // true<br/>null == undefined        // true<br/>10 == '10'               // true<br/>[10] == 10               // true<br/>[10] == '10'             // true</span></pre><h1 id="56f5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">" === "运算符类型强制</h1><p id="9b81" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在JS中，推荐使用<strong class="jw ir"> === </strong>运算符来比较值。它根据值和类型对值进行比较。</p><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="0782" class="nd ky iq mm b gy ne nf l ng nh">10 === '10'              // false<br/>[10] === 10              // false<br/>[10] === '10'            // false<br/>null == undefined        // false</span></pre><h1 id="e2a5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">"&gt;"运算符类型强制</h1><pre class="kt ku kv kw gt mz mm na nb aw nc bi"><span id="15c0" class="nd ky iq mm b gy ne nf l ng nh">6 &gt; '5'               // false<br/>'6' &gt; '45'            // true<br/>'6' &gt; '75'            // false</span></pre><h1 id="ba4d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><figure class="kt ku kv kw gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/ee4cd632bb4688000cdb9dd4d0e635bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UGfVapcRPRUhWDuq"/></div></div></figure><p id="daba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望这有助于您理解隐式转换可能非常棘手，当数据类型可以混合时应该尽可能避免。</p><h1 id="0832" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">阅读更多关于</h1><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/hoisting-in-javascript-a0320bb42921"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">深度提升JavaScript</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">深入探究JavaScript中的提升。</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="om l"><div class="on l oo op oq om or js od"/></div></div></a></div><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/let-vs-var-what-is-the-actual-difference-5acdb1f1c83"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">let' vs 'var ':实际区别是什么？</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">这里有一个关于JavaScript中let和var之间的区别的快速阅读，可能会派上用场。很高兴…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="om l"><div class="os l oo op oq om or js od"/></div></div></a></div><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/what-is-webpack-ed18b68bd5d3"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">JavaScript中的Webpack是什么？</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">我们大多数人在构建JavaScript应用程序时都听说过术语“Webpack”。这是什么？它是如何工作的…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="om l"><div class="ot l oo op oq om or js od"/></div></div></a></div><p id="94ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mv">更多内容看</em> <a class="ae ou" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="mv">说白了。报名参加我们的</em> <a class="ae ou" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="mv">免费周报</em> </strong> </a> <em class="mv">。在我们的</em> <a class="ae ou" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="mv">社区不和谐</em> </strong> </a> <em class="mv">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>