<html>
<head>
<title>A Neat Trick to Globally Preserve Query Params in Angular Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度路由器中全局保存查询参数的巧妙方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-neat-trick-to-globally-preserve-query-params-in-angular-router-87276c604942?source=collection_archive---------4-----------------------#2022-01-05">https://javascript.plainenglish.io/a-neat-trick-to-globally-preserve-query-params-in-angular-router-87276c604942?source=collection_archive---------4-----------------------#2022-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/52bbf4082f7a5c5a2df104642754b82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUNRgPv_98rvJmmrnDVjcw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo Credits: Author</figcaption></figure><p id="9ac2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">角路由器是软件工程的奇迹。它基于网络导航的简单原则。</p><ul class=""><li id="e674" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">URL只不过是一个序列化的树。这意味着您可以将URL反序列化为表示它的树。</li><li id="fb17" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">URL是web应用程序的唯一来源(嗯…应该是！)</li><li id="29da" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">路由是一种可能的路由器配置</li><li id="cd26" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">每个路由器配置都是一棵树，可以序列化为一个URL</li></ul><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/c28da773d5a30b6f560b15823194f775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxPAjaZb7gX0tm_hnJNyFw.png"/></div></div></figure><p id="5d8a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">目前，没有办法在所有路线导航中全局保留查询参数。例如，如果您正在检查URL中是否存在一个<code class="fe lr ls lt lu b">token</code>，以验证用户是否可以深度链接到一个URL。我们可以通过使用古老的策略模式和依赖注入来实现这一点。</p><h1 id="c740" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">扩展路由器的默认位置策略</h1><pre class="ln lo lp lq gt mt lu mu mv aw mw bi"><span id="c59a" class="mx lw in lu b gy my mz l na nb">import { PathLocationStrategy, APP_BASE_HREF, PlatformLocation } from '@angular/common';<br/>import { Optional, Inject, Injectable } from '@angular/core';<br/>import { UrlSerializer } from '@angular/router';</span><span id="5431" class="mx lw in lu b gy nc mz l na nb">@Injectable()<br/>export class PathPreserveQueryLocationStrategy extends PathLocationStrategy {<br/>  private get search(): string {<br/>    return this.platformLocation?.search ?? '';<br/>  }<br/>  constructor(<br/>    private platformLocation: PlatformLocation,<br/>    private urlSerializer: UrlSerializer,<br/>    @Optional() @Inject(APP_BASE_HREF) _baseHref?: string,<br/>  ) {<br/>    super(platformLocation, _baseHref);<br/>  }</span><span id="73df" class="mx lw in lu b gy nc mz l na nb">  prepareExternalUrl(internal: string): string {<br/>    const path = super.prepareExternalUrl(internal);<br/>    const existingURLSearchParams = new URLSearchParams(this.search);</span><span id="d455" class="mx lw in lu b gy nc mz l na nb">    const existingQueryParams = Object.fromEntries(existingURLSearchParams.entries());<br/>    const urlTree = this.urlSerializer.parse(path);<br/>    const nextQueryParams = urlTree.queryParams;</span><span id="6632" class="mx lw in lu b gy nc mz l na nb">    urlTree.queryParams = { ...existingQueryParams, ...nextQueryParams };</span><span id="2326" class="mx lw in lu b gy nc mz l na nb">    return urlTree.toString();<br/>  }<br/>}</span></pre><h1 id="879f" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">解释:</h1><ul class=""><li id="830b" class="kx ky in kb b kc nd kg ne kk nf ko ng ks nh kw lc ld le lf bi translated">我们扩展默认的<code class="fe lr ls lt lu b">PathLocationStrategy</code>类来实现我们的查询参数保存算法</li><li id="d617" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们覆盖了<code class="fe lr ls lt lu b">prepareExternalUrl</code>方法来处理URL中的查询参数</li><li id="b681" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们获取现有的URLSearch参数作为<code class="fe lr ls lt lu b">[URLSearchParams](&lt;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&gt;)</code>的实例</li><li id="8d35" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们从路径中创建一个<code class="fe lr ls lt lu b">[URLTree](&lt;https://angular.io/api/router/UrlTree&gt;)</code>，合并现有的和新的查询参数，并将其分配给新创建的URL树的<code class="fe lr ls lt lu b">queryParams</code></li><li id="d707" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们序列化新创建的URL树，并将其作为字符串返回</li></ul><h1 id="b51e" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">提供定制定位策略</h1><pre class="ln lo lp lq gt mt lu mu mv aw mw bi"><span id="dfed" class="mx lw in lu b gy my mz l na nb">// app.module.ts</span><span id="51b2" class="mx lw in lu b gy nc mz l na nb">import { LocationStrategy } from "@angular/common";<br/>import { PathPreserveQueryLocationStrategy } from "./preserve-query-params.ts";</span><span id="5f9d" class="mx lw in lu b gy nc mz l na nb">@NgModule({<br/>...<br/>providers: [<br/>    { provide: LocationStrategy, useClass: PathPreserveQueryLocationStrategy }<br/>  ],<br/>...<br/>})<br/>export class AppModule {}</span></pre><h1 id="d08f" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">更新Dom.iterable实用程序的TS配置</h1><p id="9c69" class="pw-post-body-paragraph jz ka in kb b kc nd ke kf kg ne ki kj kk ni km kn ko nj kq kr ks nk ku kv kw ig bi translated">将以下配置添加到项目根目录下的<code class="fe lr ls lt lu b">tsconfig.json</code>文件中。我们需要这个来使<code class="fe lr ls lt lu b">URLSearchParams</code>类和<code class="fe lr ls lt lu b">.entries()</code>方法在我们的项目中可用</p><pre class="ln lo lp lq gt mt lu mu mv aw mw bi"><span id="a409" class="mx lw in lu b gy my mz l na nb">// tsconfig.json<br/>{<br/>  "compilerOptions": {<br/>		...<br/>    "downlevelIteration": true,<br/>    "lib": [<br/>      "es2019",<br/>      "dom",<br/>      "dom.iterable",<br/>      "ESNext"<br/>    ]<br/>	...<br/>  }<br/>}</span></pre><h1 id="b8dd" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">警告</h1><ul class=""><li id="0906" class="kx ky in kb b kc nd kg ne kk nf ko ng ks nh kw lc ld le lf bi translated">由于所有查询参数都会保留，因此一旦将查询参数添加到路径中，所有后续导航都会携带该参数</li></ul><h1 id="1a56" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论</h1><p id="5777" class="pw-post-body-paragraph jz ka in kb b kc nd ke kf kg ne ki kj kk ni km kn ko nj kq kr ks nk ku kv kw ig bi translated">我们学习了如何在角度路由器中全局保存查询参数。我们看到Angular的依赖注入系统是多么强大，我们利用它来覆盖Angular的默认定位策略。</p><p id="99fb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是一个代码沙箱，其中有一个工作示例:</p><p id="c4da" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae ll" href="https://codesandbox.io/s/angular-preserve-query-params-up6cs?file=/src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank">角度保留查询参数</a></p><p id="3c3e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">感谢你的阅读，我希望这能帮助你，就像它帮助了我一样。</p><p id="51d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我很想在下面的评论中知道这是否有用！</p><p id="9f22" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你可以在<a class="ae ll" href="https://github.com/nivrith" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或者<a class="ae ll" href="https://twitter.com/_Nivrith_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我</p><p id="4da2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">快乐工程！</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="409a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ns">如果你想更新更多类似的文章</em> </strong> <a class="ae ll" href="https://resources.bytelimes.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ns">订阅我的简讯</em> </strong> </a></p><p id="98d5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="ns">更多内容请看</em><a class="ae ll" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ns">plain English . io</em></a><em class="ns">。报名参加我们的</em> <a class="ae ll" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ns">免费每周简讯</em> </a> <em class="ns">。在我们的</em> <a class="ae ll" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="ns">社区不和谐</em> </a> <em class="ns">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>