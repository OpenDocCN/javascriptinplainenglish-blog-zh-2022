<html>
<head>
<title>Everything You Should Know About Effects in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React中的效果，你应该知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-you-should-know-about-effects-in-react-6d824549f598?source=collection_archive---------3-----------------------#2022-08-01">https://javascript.plainenglish.io/everything-you-should-know-about-effects-in-react-6d824549f598?source=collection_archive---------3-----------------------#2022-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4304" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何应对React效应的思考？你可能没听说过的技巧和诀窍。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b8d4a4e3a7e57b07a398b57afd2f8702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rX1amQvTo8i7DrRmMrbH8w.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image by <a class="ae ks" href="https://unsplash.com/@jadhav24omkar" rel="noopener ugc nofollow" target="_blank">Omkar Jadhav</a> from <a class="ae ks" href="https://unsplash.com/photos/s5xNLPMxHZU" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ca26" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这不是一个关于反应效果如何在引擎盖下工作的教程。本文的主要目的是简明地描述最佳实践、技巧和诀窍。如果您需要React效果/挂钩如何工作的详细信息，您可能会发现以下链接很有用:</p><ul class=""><li id="f578" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><a class="ae ks" href="https://stackoverflow.com/questions/53729917/react-hooks-whats-happening-under-the-hood" rel="noopener ugc nofollow" target="_blank"> StackOverflow线程关于React钩子</a></li><li id="20ca" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://eliav2.github.io/how-react-hooks-work/" rel="noopener ugc nofollow" target="_blank">关于Eliav Louski的React hooks的精彩阅读</a></li><li id="125d" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://overreacted.io/how-does-setstate-know-what-to-do/" rel="noopener ugc nofollow" target="_blank">关于</a> <code class="fe md me mf mg b"><a class="ae ks" href="https://overreacted.io/how-does-setstate-know-what-to-do/" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae ks" href="https://overreacted.io/how-does-setstate-know-what-to-do/" rel="noopener ugc nofollow" target="_blank">的论文由丹·阿布拉莫夫</a></li></ul><h1 id="e136" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">关于一般反应效果</h1><p id="0e51" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">你可能已经看到了关于React是否遵循<a class="ae ks" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" rel="noopener ugc nofollow" target="_blank">反应式编程</a>原则的讨论。这里长话短说，我现在就来回答。<a class="ae ks" href="https://dev.to/this-is-learning/how-react-isn-t-reactive-and-why-you-shouldn-t-care-152m" rel="noopener ugc nofollow" target="_blank"> React不遵循</a>基本反应式编程原则。但同时，我们可以说<a class="ae ks" href="https://stackoverflow.com/questions/71855096/reactive-programming-in-react" rel="noopener ugc nofollow" target="_blank"> React是</a>的“反应性”。这里的要点是“反应式编程”和“反应式”是不一样的。更多详情可在<a class="ae ks" href="https://gist.github.com/sw-yx/9bf1fad03185613a4c19ef5352d90a09" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="26f2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我从反应性开始这一部分，因为理解反应的效果很重要。本质上，由于反应性，效果是可能的。</p><p id="1da9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们来看看下面这段简单的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 1</figcaption></figure><p id="9863" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们试着一行一行地理解这段代码做了什么。</p><ul class=""><li id="9bb2" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">1 —这是状态块定义。我们希望有一个动态的、可观察的<code class="fe md me mf mg b">counter</code>值。可通过<code class="fe md me mf mg b">setCounter</code>功能改变。但是如何观察它的变化呢？</li><li id="38d5" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">2-为了观察React中的可变值，我们可以使用<code class="fe md me mf mg b">useEffect</code>钩子。即，当<code class="fe md me mf mg b">counter</code>值改变时，回调被调用。这是React如何处理引擎盖下的这个。</li><li id="7a6a" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">这就是我们如何安排可观察实体的变化。同样，我们还需要一个<code class="fe md me mf mg b">useEffect</code>来设置它。为什么？这是因为React渲染的方式。正如你所看到的，依赖列表在这里是空的，这意味着这个动作只发生一次，后续的渲染不会再次触发它。当调用间隔回调时，<code class="fe md me mf mg b">counter</code>被更新，然后调用效果回调(2)，并重新开始。</li><li id="e9fa" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">4 —我们不想渲染任何内容。然后<code class="fe md me mf mg b">null</code>又回来了。</li></ul><p id="5417" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实际上，说<code class="fe md me mf mg b">counter</code>是一个可观测值是不正确的。根本看不到！我们可以看到它的变化，这要归功于React渲染内部机制(参见上面的参考资料)。那么，如何用简单的词语描述React效应项呢？让我们试试。</p><p id="0016" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ng"> React Effect是一种安排值的变化，然后观察这种变化并对其做出反应的机制。</em></p><p id="8a71" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再一次关于反应性。</p><p id="cd5c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ng"> React效果不遵循反应式编程的基本原则。主要区别在于实现细节。但是我们可以认为这种影响依赖于一种特殊类型的反应。</em></p><h1 id="f3f5" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">使用ESLint验证依赖性</h1><p id="d912" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">我鼓励你使用ESLint来验证你(和你的队友)的代码。你的ESLint配置质量的最好指标是你如何进行代码审查。如果您只需要检查业务逻辑和模式，这是一个高质量的ESLint配置。但是如果你总是被迫检查代码风格，这样的配置肯定应该改进…</p><p id="1d2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有一堆标准的ESLint规则你可以开箱即用。但最有可能的是，它们不足以满足快速增长的项目。然后<a class="ae ks" href="https://github.com/dustinspecker/awesome-eslint" rel="noopener ugc nofollow" target="_blank"> ESLint插件</a>登场。这个话题值得单独一篇文章来详细描述。现在我们只对<code class="fe md me mf mg b"><a class="ae ks" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react-hooks</a></code>插件感兴趣。它迫使你和你的团队遵循钩子的规则。</p><p id="b8b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有多种方法可以禁用ESLint规则。有很多情况下，开发人员认为他真的知道他的代码应该如何工作，而不想遵循钩子的规则。在这种情况下，开发人员很可能会做以下事情。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 2</figcaption></figure><p id="416c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">只要记住以下几点:</p><p id="becb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ng">如果你不想遵循钩子的规则，这并不意味着你更了解你的代码。这意味着你不明白反应效果如何工作，只是试图侵入系统！</em></p><p id="dd9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面我们将看看像<code class="fe md me mf mg b">useComponentDidMount</code>这样丑陋的钩子。在大多数情况下，他们使用这样的禁用语句。这也是为什么这些钩子只是黑客的另一个原因。</p><p id="9653" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面我们将看到我们如何有一个合法的变通办法，避免使用deps列表中的一些依赖项。</p><h1 id="6aa0" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">逮到你了</h1><p id="a717" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">React的反应系统基于这样一种方法，即开发者知道什么依赖关系应该触发一个效果。而且有些问题是<code class="fe md me mf mg b">eslint-plugin-react-hooks</code>无法检查的。</p><h2 id="64af" class="nh mi in bd mj ni nj dn mn nk nl dp mr lc nm nn mt lg no np mv lk nq nr mx ns bi translated">1.定制钩子中的记忆函数</h2><p id="c5db" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">让我们看看下面的例子。想象我们遵循了钩子的所有规则。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 3</figcaption></figure><p id="deb2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你看到这里的问题了吗？让我描述一下。问题出在<code class="fe md me mf mg b">incrementCounter</code>函数上。<code class="fe md me mf mg b">component</code>在<code class="fe md me mf mg b">useEffect</code>的deps列表中使用它。但是这个功能在<code class="fe md me mf mg b">useCounter</code>自定义挂钩中没有记忆。这意味着<code class="fe md me mf mg b">Component</code>的每一次渲染都会生成一个对<code class="fe md me mf mg b">incrementCounter</code>函数的新引用，并导致一个效果再次发生！</p><p id="1a1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实际上，这在这里不是一个大问题，因为我们关心的是事件，并在消除效果之前清除间隔。这是我希望你永远记住的一件重要的事情。</p><p id="5cbf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ng">始终清除</em> <code class="fe md me mf mg b"><em class="ng">useEffect</em></code> <em class="ng"> s中的事件。避免这一点会导致难以修复的问题。</em></p><p id="ce9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">解决这个问题的唯一合法选择是在<code class="fe md me mf mg b">useCounter</code>钩子中记忆<code class="fe md me mf mg b">incrementCounter</code>函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 4</figcaption></figure><h2 id="efec" class="nh mi in bd mj ni nj dn mn nk nl dp mr lc nm nn mt lg no np mv lk nq nr mx ns bi translated">2.小心输入函数</h2><p id="0af4" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">这种情况并不明显。我面临着一大堆与之相关的问题，这些问题很难抓住。让我们来看看吧。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 5</figcaption></figure><p id="95a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">存在与前一个例子相同的问题。当<code class="fe md me mf mg b">Component</code>呈现时，生成一个到内联函数(<code class="fe md me mf mg b">*</code>)的新链接。然后在<code class="fe md me mf mg b">useCounter</code>自定义钩子中造成意外效果。</p><p id="cfe6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有两种方法可以修复它。第一种方法是去掉内联函数并记忆它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 6</figcaption></figure><p id="649b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这很好。但是我不喜欢这种方法，因为这有点冗长。</p><ul class=""><li id="d557" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">你总是被迫去记忆输入函数。</li><li id="db40" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">你要确定每个人都会做这个记忆化，这是最大的问题。</li></ul><p id="a0de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我告诉你第二种方法。这是一个合法的变通办法，允许摆脱依赖，仍然符合钩子的规则。请小心使用这种方法，只有在没有其他方法解决问题时才使用它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 7</figcaption></figure><p id="6289" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们一行一行地研究这段代码。</p><ul class=""><li id="badb" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">1 —我们将输入函数保存为反应参考。这是访问该功能的合法方式，并且不会被强制在deps列表中指定。</li><li id="6d7f" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">2 —这是这种方法的重要组成部分。当输入函数改变时，我们应该更新对输入函数的引用。</li><li id="95ee" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">3 —然后，当我们想要使用输入函数(<code class="fe md me mf mg b">onChange</code>)时，我们使用对它的引用来代替(<code class="fe md me mf mg b">onChangeRef.current</code>)。</li><li id="da50" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">4 —现在，由于我们在幕后使用React Ref，输入函数的记忆是多余的，我们可以自由地内联它。</li></ul><p id="a6b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看起来不错。对吗？</p><p id="7e60" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可能会问这个地狱实际上是如何运作的。有一个简单的原则。JavaScript中的函数是对象。然后，当我们将内联函数作为参数传递时，我们实际上传递的是对函数的引用，而不是函数本身。当参考更新时，<code class="fe md me mf mg b">useEffect</code>只使用更新的输入功能。</p><p id="bfc0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你不知道这个概念，推荐你看看<a class="ae ks" href="https://javascript.info/object-copy" rel="noopener ugc nofollow" target="_blank">这一页</a>。如果你很着急，下图描述了这一点。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/38c0ac8fb0cdb07662d8e9417a80f163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3yAzLbdduapWTubv8fnBg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 1. Dynamic reference to the function</figcaption></figure><h1 id="a014" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">关于类组件生命周期方法的思考</h1><p id="1e08" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">我猜你有一些使用React类组件的经验。有一套<a class="ae ks" href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" rel="noopener ugc nofollow" target="_blank">生命周期方法</a>。(你可能会发现这张图也很有用。)有时候开发人员喜欢混合功能组件和类组件的生命周期原则。我指的是像<code class="fe md me mf mg b">useComponentDidMount</code>、<code class="fe md me mf mg b">useComponentWillUnmount</code>等定制挂钩。</p><p id="4314" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我对这种混合原则进行了很多讨论。此外，我想了很多，并试图为自己创造一个明确的理由，无论这是正确的还是错误的。甚至试图说服我这是好的，因为这样的代码在大多数情况下工作良好。</p><p id="1cb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Emm…在某些边缘情况下，这种混合可能是有用的。如果应用程序有规则认为这是一种可接受的建筑效果方法，这肯定会工作得很好。但是我仍然认为这样的代码是丑陋的，并且违反了React的反应原则！如果您不是一个熟练的React黑客，甚至会导致难以重现的问题。</p><p id="8102" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们试着理解出了什么问题。</p><p id="8fcd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，正如我们上面已经讨论过的，在大多数情况下，这样的解决方案不遵循钩子的规则。这意味着反应性被破坏了——它只能半正确地工作，并导致难以修复的错误。</p><p id="6cce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是你可能会说React Refs有一个合法的解决方法，我们可以用它来构建这些定制的钩子！你说得对。但这并不能改变很多事情。无论你使用合法或非合法的解决方案，这种反应仍然是被破坏的。</p><p id="01f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其次，这是一个巨大的误解，混淆了这两个不同的世界:基于类和基于函数的组件。当React团队在几年前设计类组件时，这是过去几天可以接受的解决方案。但是现在我们生活在一个完全不同的世界。前端正慢慢转向功能概念，因为它们允许构建更可靠的运行时和高性能的解决方案。由于这个原因，React团队被迫引入一种更现代的描述组件的方式——功能组件。</p><p id="a3ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">试着在你的脑海中构建这个画面。React为您提供了一个比旧的基于类的组件更加灵活和强大的现代API。你仍然不能重建你的思想，继续使用过时的概念。你明白我的意思吗？</p><p id="fb08" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不要再坚持围绕基于类的组件构建的旧的React概念。刷新您的思维，构建基于效果的React应用程序！并且没有强迫性的尝试去入侵系统和引入像<code class="fe md me mf mg b">useComponentDidMount</code>这样丑陋的自定义API。</p><h1 id="0608" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">为什么我们要析构函数</h1><p id="b783" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">我还想和你讨论一个话题。这和钩子的规则有关。如果你已经使用过<code class="fe md me mf mg b">eslint-plugin-react-hooks</code>，你可能会遇到钩子的规则不允许你直接使用“道具”的功能的情况(比如<code class="fe md me mf mg b">props.onChange</code>)。在将它添加到deps列表之前，您总是被迫析构它。在大多数情况下，开发人员只需使用ESLint disabling语句来禁用此警告。这是错误的。</p><p id="796a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这段代码违反了钩子的规则:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 8</figcaption></figure><p id="72a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个代码符合钩子的规则:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code Snippet 9</figcaption></figure><p id="e002" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们试着理解为什么钩子的规则强迫我们在将函数添加到deps列表之前，从“props”中析构函数。你可以在React问题讨论中找到<a class="ae ks" href="https://github.com/facebook/react/issues/16265#issuecomment-517518539" rel="noopener ugc nofollow" target="_blank">的最佳答案，其中</a><a class="nu nv ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----6d824549f598--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>详细描述了这个问题。</p><p id="84c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我强烈推荐阅读该讨论。但是如果你想快速浏览一下，我可以给你一个简短的回答。</p><p id="c3c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">问题在于纯度。React希望在deps列表中看到纯函数。不能认为<code class="fe md me mf mg b">props.onChange()</code>调用是纯调用，因为<code class="fe md me mf mg b">props</code>对象是<code class="fe md me mf mg b">onChange</code>的<code class="fe md me mf mg b">this</code>。</p><p id="5735" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是为什么重要呢？这是因为变化应该是可以观察到的。还记得我们上面关于反应性的讨论吗？</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="1576" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其实就是这样！关于反应效果有很多有趣的事情要说。但它们是下一篇论文的主题。希望你喜欢这次阅读。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="b103" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ng">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ng">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ng">免费周报</em> </strong> </a> <em class="ng">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ng">Twitter</em></strong></a><strong class="kv io"><em class="ng"/></strong><em class="ng">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ng">LinkedIn</em></strong></a><em class="ng">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ng">社区不和谐</em> </strong> </a> <em class="ng">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ng">人才集体</em> </strong> </a> <em class="ng">。</em></strong></a></p></div></div>    
</body>
</html>