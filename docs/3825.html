<html>
<head>
<title>What are JavaScript Promises &amp; How to Use Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是JavaScript承诺&amp;如何使用它们</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-javascript-promises-how-to-use-them-84fdff5757b9?source=collection_archive---------9-----------------------#2022-09-29">https://javascript.plainenglish.io/what-are-javascript-promises-how-to-use-them-84fdff5757b9?source=collection_archive---------9-----------------------#2022-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0da6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是承诺，为什么要使用承诺？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/68a5282e321580cf72b819546b7c9cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZggPmrl7_NF0FMBu8MwoQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@alisestorsul?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">alise storsul</a> on <a class="ae kv" href="https://unsplash.com/s/photos/pinkie-promise?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="747a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Javascript的问题</h1><p id="e703" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript有一个问题:它是单线程的。</p><p id="8645" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们这样说是什么意思？如果某件事需要时间，JS引擎在此期间不能做任何其他事情。</p><p id="3b33" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有时候，当编写“while”代码块时，我会忘记在结束条件中增加变量。这就产生了一个无限循环。当我这样做的时候…一切都冻结了。浏览器不再响应。我不得不强行关上窗户。这是一个极端的例子。但是让我们退后一点。电影以每秒24帧的速度运行，视频游戏以每秒60帧或更高的速度运行。每秒24帧意味着每40毫秒左右一帧。(1/24 = 0.0416秒)。</p><p id="d474" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于流畅的体验，JavaScript中的任何进程都必须在40毫秒或更短时间内完成任务。否则，用户会觉得应用程序落后了。</p><p id="b3a3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你想调用一个web服务器上的API，消息的往返肯定要比这个时间长。但是浏览器等不起。</p><p id="e64d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以我们需要找到方法告诉代码在等待的时候做其他的事情。</p><h1 id="5804" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">回调函数</h1><p id="62c6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">第一个解决方案是告诉浏览器:“运行这个过程(例如，调用这个API)，当它完成时，让我知道”。或者更准确地说:在完成时执行所提供的函数(作为函数调用中的一个参数)。我们希望代码回调的这个函数就是所谓的…回调。</p><p id="d2ea" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个回调函数允许我们添加更多的逻辑来响应服务器的响应。例如:当用户点击按钮时，首先通过调用登录API进行登录。当服务器响应时，检索身份验证数据并解释它。然后用登录数据调用web服务来更新玩家的信息。</p><p id="79fc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">仅在这个例子中，就有三个回调在起作用。第一个响应按钮的按下。第二个管理对登录API的调用和响应。最后一个从第二个web服务中检索响应。记住这个例子既不牵强也不复杂。</p><p id="9848" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是这种过程会在回调中产生回调。代码很快变得不可读，它产生“回调地狱”。</p><p id="5188" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这种操作还会带来另一个问题:错误处理。</p><p id="cd42" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设您在回调堆栈的每个阶段或深度都要执行特定的处理。现在想象一个错误发生了。如果它不是用try/catch管理的，则错误消息是无用的。“匿名函数的第5行出现错误”。</p><p id="edc9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这甚至还没有触及代码无声地失败的情况。</p><p id="345f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">唯一的解决方案是在每个深度、每个回调调用上添加try/catch管理。这很快变得很难操作。</p><h1 id="ea96" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是承诺？</h1><p id="d076" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了解决这些问题，发明了一种新的物体。它有三个基本属性:</p><ol class=""><li id="d4e8" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">它封装了异步处理</li><li id="2546" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">它可以被链接，不需要嵌套(回调)函数。</li><li id="ac5a" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">它处理错误</li></ol><p id="6485" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个对象就是承诺。</p><p id="5767" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一个承诺有两个可以调用的功能:“然后”和“抓住”。“then”函数将解析的结果作为参数，并返回一个新的承诺。“catch”函数将<em class="mp">误差</em>作为参数，并返回一个新的承诺。</p><p id="831b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些函数返回承诺的事实正是允许我们“链接”它们的原因，即:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c5be" class="nj kx iq nf b gy nk nl l nm nn">p.then(function1).then(function2)</span></pre><p id="714e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">其中<code class="fe no np nq nf b">p </code>是一个承诺。链接允许我们顺序读取代码，而不是越来越深地陷入嵌套的回调函数。</p><p id="c955" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">无论哪一步出错，承诺都会触发第一个“catch”。这允许集中(和理智！)错误管理。</p><h1 id="c6b5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">如何做出承诺</h1><p id="d2e1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们编写一个函数，创建一个等待指定时间的承诺。让我们称这个函数为sleep。</p><p id="aa7f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Promise的构造函数接受一个函数。</p><p id="dcf3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该函数将两个函数作为参数，通常称为“resolve”和“reject”。当过程结束时我们称之为。要么成功，在这种情况下我们称之为“解决”，要么失败，我们称之为“拒绝”。</p><p id="edc2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的睡眠功能看起来像这样:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="a919" class="nj kx iq nf b gy nk nl l nm nn">const sleep = (nb) =&gt; {<br/>  return new Promise ((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; resolve(), nb) ;<br/>  })<br/>};</span></pre><p id="58ff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里没有使用第二个参数reject。我们可以省略它，但为了完整起见，我们会保留它。如果我们这样做了:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="0039" class="nj kx iq nf b gy nk nl l nm nn">sleep(1000).then(() =&gt; console.log("done")); <!-- --> </span></pre><p id="090b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">睡眠产生一个承诺，在一定时间后触发一个功能。</p><h1 id="b99e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">承诺是好的，但我们可以做得更好！</h1><p id="537e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我有好消息。有一种更好的方式来称呼承诺。</p><p id="c08c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这可能感觉不同，因为“then”函数从未被显式调用。相反，这种语法依赖于async/await关键字。但它所做的只是让我们称之为承诺。它是如何工作的？</p><p id="341b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好吧，让我们用睡眠承诺来举一个基本承诺序列的例子:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="1338" class="nj kx iq nf b gy nk nl l nm nn">const wait = () =&gt; {<br/>  sleep(1000)<br/>    .then(() =&gt; sleep(1000))<br/>    .then(() =&gt; console.log(“2s later”);<br/>} ;</span></pre><p id="e7cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用async/await符号，我们可以写同样的东西:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="cdc5" class="nj kx iq nf b gy nk nl l nm nn">const wait = async () =&gt; {<br/>  await sleep(1000);<br/>  await sleep(1000);<br/>  console.log(“2s later”) ;<br/>} ;</span></pre><p id="05c3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">只有语法上的区别。正在调用相同的Promise对象。如果我们将两个await调用包装在try/catch中，它将像同步代码一样处理错误。</p><p id="8f86" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所有这些都改变了写承诺的方式。这非常类似于我们编写同步代码的方式。即使我们实际上在喊承诺。上面定义的等待函数也返回一个承诺。</p><h1 id="0a79" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">概括起来</h1><p id="d009" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript完全是关于与接口和API的交互。回调曾经是这样做的首选方式，但是它们有很多缺点。承诺是一个更好的解决方案。async/await语法使用Promises来描述异步行为，同时保持可读性。并让我们逃离“回调地狱”。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="d3cc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="mp">plain English . io</em></strong></a><em class="mp">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mp">免费周报</em> </strong> </a> <em class="mp">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="mp">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="mp">LinkedIn</em></strong></a><em class="mp"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="mp">YouTube</em></strong></a><em class="mp"/><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="mp">不和</em> </strong> </a> <em class="mp">。对增长黑客感兴趣？检查</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mp">电路</em> </strong> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>