<html>
<head>
<title>A Lesser-Known Trick with React Hook Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React钩子依赖的一个鲜为人知的技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-less-known-trick-with-react-hook-dependencies-8dafaca7a150?source=collection_archive---------3-----------------------#2022-08-08">https://javascript.plainenglish.io/a-less-known-trick-with-react-hook-dependencies-8dafaca7a150?source=collection_archive---------3-----------------------#2022-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f8bc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一个非正统的React钩子技巧，用于声明你的依赖数组。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3d24eb876808620a08fa85857e2d5c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BfwlKcEuT8BRDLcU"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@henmankk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Keagan Henman</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6257" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React是为开发人员设计的，让他们想出自己的编写方式。有一个非正统的反作用钩子技巧，我觉得用起来不对，但从技术上来说，它确实完成了任务。目的是向大家介绍它，而不是说服大家使用它。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="affa" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated"><strong class="ak">背景</strong></h1><p id="b845" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">作为React开发人员，我们被教导当我们在任何钩子中使用依赖数组作为参数时，要确保像对象和数组这样的非原始数据类型的<strong class="kv io">引用相等性</strong>。对这些数据类型的任何引用更改都会触发重新计算，因为React只进行浅层比较。</p><p id="4f1d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通常的做法是记住这些数据类型。另一种方法是结合使用<code class="fe mt mu mv mw b">ref</code>、记忆化和深度相等函数，像<a class="ae ks" href="https://github.com/kentcdodds/use-deep-compare-effect" rel="noopener ugc nofollow" target="_blank">use-deep-compare-effect</a>所做的那样，强制进行深度比较检查。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/05901cd27ade8e09f10f176415b69170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcw7gi_3_ecwlEUYobnl7A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Snippet of useDeepCompareEffect</figcaption></figure><p id="2125" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其思想是记忆依赖数组及其值。整个数组保存在一个<code class="fe mt mu mv mw b">ref</code>中，只有当传入的数组与前一个不完全相等时才会被更新。<code class="fe mt mu mv mw b">signalRef</code>用于通知<code class="fe mt mu mv mw b">useMemo</code>值已经改变，并返回新值给我们。</p><h1 id="9eba" class="lw lx in bd ly lz my mb mc md mz mf mg jt na ju mi jw nb jx mk jz nc ka mm mn bi translated">诀窍是</h1><p id="42e1" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">您知道字符串化对象和数组也可以获得几乎相同的结果吗？提出这个问题的不是别人，正是React的代言人丹·阿布拉莫夫本人。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ed0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">字符串化值将非原始数据类型转换为原始数据类型，我们可以安全地允许React进行比较。</p><h2 id="c02b" class="nf lx in bd ly ng nh dn mc ni nj dp mg lc nk nl mi lg nm nn mk lk no np mm nq bi translated"><strong class="ak">优点:</strong></h2><ul class=""><li id="21d4" class="nr ns in kv b kw mo kz mp lc nt lg nu lk nv lo nw nx ny nz bi translated"><strong class="kv io">更便宜<br/> </strong>一个<code class="fe mt mu mv mw b">JSON.stringify</code>只需要更少的开销。</li></ul><pre class="kd ke kf kg gt oa mw ob oc aw od bi"><span id="569c" class="nf lx in mw b gy oe of l og oh">const obj = { name: "Fabian", age: 99 }</span><span id="14fe" class="nf lx in mw b gy oi of l og oh">useDeepCompareEffect(() =&gt; doSomething(obj), [obj])<br/>// is the same as<br/>useEffect(() =&gt; doSomething(obj), [JSON.stringify(obj)])</span></pre><ul class=""><li id="fe86" class="nr ns in kv b kw kx kz la lc oj lg ok lk ol lo nw nx ny nz bi translated"><strong class="kv io">处理嵌套对象或派生值<br/> </strong>这些仅仅是概念性的例子。</li></ul><pre class="kd ke kf kg gt oa mw ob oc aw od bi"><span id="2c24" class="nf lx in mw b gy oe of l og oh">// Nested fields<br/>const obj = { address: { street: "", building: "" } }</span><span id="9afa" class="nf lx in mw b gy oi of l og oh">useEffect(() =&gt; doSomething(obj.address), [JSON.stringify(obj.address)])</span><span id="c9c5" class="nf lx in mw b gy oi of l og oh">// Derived values<br/>useEffect(() =&gt; doSomething(orders),<br/>[JSON.stringify(orders.map(o =&gt; o.id))])</span></pre><h2 id="b565" class="nf lx in bd ly ng nh dn mc ni nj dp mg lc nk nl mi lg nm nn mk lk no np mm nq bi translated">缺点:</h2><ul class=""><li id="2295" class="nr ns in kv b kw mo kz mp lc nt lg nu lk nv lo nw nx ny nz bi translated"><strong class="kv io">受限于JSON.stringify </strong> <br/>的能力，我们必须理解<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description" rel="noopener ugc nofollow" target="_blank">JSON . stringify对不同的数据类型做了什么</a>。Like函数不能被字符串化来检查它们的相等性。</li><li id="6d36" class="nr ns in kv b kw om kz on lc oo lg op lk oq lo nw nx ny nz bi translated"><strong class="kv io">要求对象字段和数组值的顺序相同<br/> </strong>我们只是检查两个字符串是否相同。<code class="fe mt mu mv mw b">objA</code>和<code class="fe mt mu mv mw b">objB</code>可以有相同的属性。但是如果一个属性在<code class="fe mt mu mv mw b">objA</code>中被列为第一个，在<code class="fe mt mu mv mw b">objB</code>中被列为最后一个，那么一旦被字符串化，它们就被认为是不同的。</li><li id="7a38" class="nr ns in kv b kw om kz on lc oo lg op lk oq lo nw nx ny nz bi translated"><strong class="kv io">抱怨表情复杂</strong> <br/>这种伎俩违背了<code class="fe mt mu mv mw b">react-hooks/exhaustive-deps</code> ESLint法则。可以忽略它，也可以通过声明一个变量来满足它。</li><li id="60b4" class="nr ns in kv b kw om kz on lc oo lg op lk oq lo nw nx ny nz bi translated"><strong class="kv io">促进依赖关系的模糊性</strong> <br/>我们需要仔细处理这个表达式，以理解我们到底依赖什么以及为什么依赖。这需要更多的精神资源，尤其是当涉及派生的价值时。</li><li id="df0e" class="nr ns in kv b kw om kz on lc oo lg op lk oq lo nw nx ny nz bi translated"><strong class="kv io">只适合浅层对象和数组</strong> <br/>任何复杂的数据结构像大型嵌套对象或者多维数组对于<code class="fe mt mu mv mw b">JSON.stringify</code>来说处理起来都比较慢。</li></ul><h1 id="17d5" class="lw lx in bd ly lz my mb mc md mz mf mg jt na ju mi jw nb jx mk jz nc ka mm mn bi translated">最后的话</h1><p id="a104" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">我们应该清楚我们想要达到的目标。我们希望获得正确的依赖关系的常见原因是确保副作用在需要时重新运行并优化性能。</p><p id="b62a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如肯特·c·多兹在他的文章中所说:</p><p id="bc6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="or">性能优化不是免费的。它们总是伴随着成本，但并不总是伴随着抵消成本的收益。</em></p><p id="c98e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不打破逻辑的额外重播不一定会痛。不会带来显著价值的优化可以跳过。我们应该谨慎使用这些技术，以避免产生比我们正在解决的问题更多的开销。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><div class="kd ke kf kg gt os"><a href="https://medium.com/@fabianlee/membership" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">通过我的推荐链接加入Medium—Fabian Lee</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg km os"/></div></div></a></div></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="8025" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="or">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="or">说白了就是</em> </strong> </a> <em class="or">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="or">免费每周简讯</em> </strong> </a> <em class="or">。关注我们关于</em> <a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="or">推特</em> </strong> </a>，<a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="or">领英</em> </strong> </a>，<strong class="kv io"> <em class="or"> </em> </strong> <em class="or">和</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="or">不和</em> </strong> </a> <em class="or">。</em></p></div></div>    
</body>
</html>