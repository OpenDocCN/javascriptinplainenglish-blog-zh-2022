<html>
<head>
<title>Transport Your Components Anywhere with React Portals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Portals将您的组件运送到任何地方</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/transporting-your-components-anywhere-with-react-portals-f7e3ed7a7a8c?source=collection_archive---------7-----------------------#2022-10-13">https://javascript.plainenglish.io/transporting-your-components-anywhere-with-react-portals-f7e3ed7a7a8c?source=collection_archive---------7-----------------------#2022-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="61ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中的门户为我们提供了一种在代码中的任何地方传输DOM元素的有用方法——这是一个关于React门户如何工作的教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/321930c9f975524979be56f0748be003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nW-1OhYUYsAbevWzqZADpg.png"/></div></div></figure><p id="1ea4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们在React中创建组件时，通常它们存在于组件树中。这基本上没问题，但是有时我们希望组件的某些部分出现在组件树之外，或者完全不同的地方。当我们创建模态弹出窗口时，这是一个常见的需求，它需要在所有其他组件之上。我们可能会在一个组件中创建它们，但最终我们会希望它们高于一切，将它们嵌套在许多组件中会导致问题，因为它们的<code class="fe ln lo lp lq b">z-index</code>会低于它们所在的位置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/4c95c3daede6e85d8d7230a0361b478d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cy98FdiTt3R8n_3f.png"/></div></div></figure><p id="b4d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们可以使用<code class="fe ln lo lp lq b">createPortal</code>将<strong class="kt ir">模态从它自己的组件中转移到模板的另一部分。这允许我们把组件放在任何我们想要的地方，比如HTML树的底部，在<code class="fe ln lo lp lq b">body</code>标签内，或者在另一个元素内。即使元素存在于组件树中，<code class="fe ln lo lp lq b">createPortal</code>也给了我们把它放在任何我们喜欢的地方的能力。</strong></p><h1 id="8992" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用React门户</h1><p id="3e76" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">为了向您展示门户是如何工作的，考虑在我们的<code class="fe ln lo lp lq b">App.js</code>文件中有以下基本的React代码。在这里，我们希望模态出现在所有东西的上面。因此，我们创建了一个名为<code class="fe ln lo lp lq b">#modal-container</code>的<code class="fe ln lo lp lq b">div</code>。这是我们希望所有模态最终进入的地方:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="1bf1" class="mt lt iq lq b gy mu mv l mw mx">import logo from './logo.svg';<br/>import './App.css';<br/>import { useState } from 'react'<br/>import Modal from './components/Modal.js';</span><span id="46e9" class="mt lt iq lq b gy my mv l mw mx">function App() {<br/>    const [isModalOpen, setIsModalOpen] = useState(false);<br/>    return (<br/>        &lt;div className="App"&gt;<br/>            &lt;header className="App-header"&gt;<br/>                &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>                &lt;p&gt;<br/>                Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br/>                &lt;/p&gt;</span><span id="f4fa" class="mt lt iq lq b gy my mv l mw mx">                &lt;button onClick={() =&gt; setIsModalOpen(!isModalOpen)}&gt;<br/>                    Click to Open Modal<br/>                &lt;/button&gt;<br/>                &lt;Modal modalState={isModalOpen} onClickEvent={() =&gt; setIsModalOpen(!isModalOpen)}&gt;<br/>                    This is Modal Content!<br/>                &lt;/Modal&gt;<br/>            &lt;/header&gt;<br/>            &lt;div id="modal-container"&gt;&lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span><span id="2e1f" class="mt lt iq lq b gy my mv l mw mx">export default App;</span></pre><p id="5c1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">App.js</code>内部，我导入了一个名为<code class="fe ln lo lp lq b">Modal</code>的组件。这是我们的模态组件，它会在用户点击按钮时弹出。只要使用<code class="fe ln lo lp lq b">setIsModalOpen()</code>将<code class="fe ln lo lp lq b">isModalOpen</code>设置为真，就会出现模态。否则，它会消失。</p><p id="5f79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还使用了一点CSS来确保我们的模态确实出现在所有其他事物之上:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="3df6" class="mt lt iq lq b gy mu mv l mw mx">#modal-container {<br/>    position: absolute;<br/>    top: 0;<br/>    left: 0;<br/>    width: 100%;<br/>    z-index: 9999;<br/>    height: 100%;<br/>    pointer-events: none;<br/>}</span><span id="bdfb" class="mt lt iq lq b gy my mv l mw mx">.modal {<br/>    position: absolute;<br/>    top: 200px;<br/>    background: white;<br/>    border-radius: 4px;<br/>    left: calc(50% - 100px);<br/>    width: 200px;<br/>}</span></pre><h1 id="ff86" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建我们的门户</h1><p id="65a8" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">创建一个potal非常简单——有一个函数，<code class="fe ln lo lp lq b">createPortal()</code>。我们没有在React中返回一些DOM，而是返回了<code class="fe ln lo lp lq b">Portal</code>。<code class="fe ln lo lp lq b">createPortal()</code>接受两个参数——我们想要返回的DOM元素——在本例中是模态的——和我们想要将DOM元素传送到的DOM元素。所以我们的第二个参数是<code class="fe ln lo lp lq b">document.getElementById('modal-container')</code>，因为我们想把所有的模态放入<code class="fe ln lo lp lq b">#modal-container</code>:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="a625" class="mt lt iq lq b gy mu mv l mw mx">import { createPortal } from 'react-dom';</span><span id="d103" class="mt lt iq lq b gy my mv l mw mx">function Modal({modalState, onClickEvent}) {</span><span id="db30" class="mt lt iq lq b gy my mv l mw mx">    if(!modalState) return null;</span><span id="6426" class="mt lt iq lq b gy my mv l mw mx">    return (<br/>        createPortal(<br/>            &lt;div className="modal"&gt;<br/>                &lt;button onClick={onClickEvent}&gt;Close Modal&lt;/button&gt;<br/>                &lt;div className="modal-content"&gt;Modal Content goes here&lt;/div&gt;<br/>            &lt;/div&gt;, <br/>            document.getElementById('modal-container')<br/>        )<br/>    );<br/>};</span><span id="6383" class="mt lt iq lq b gy my mv l mw mx">export default Modal;</span></pre><p id="24f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管我们将DOM元素传送到了<code class="fe ln lo lp lq b">modal-container</code>，但它的行为仍然像普通的React子元素一样。因为门户仍然存在于React树中，所以像元素所在的上下文这样的特性仍然起作用。</p><p id="e82e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还应该注意的是，虽然我们在同一个文件中有<code class="fe ln lo lp lq b">modal-container</code>和<code class="fe ln lo lp lq b">Modal</code>，但是你可以将DOM元素传送到React代码中的任意位置<strong class="kt ir">。因此，您可以将其传送到DOM中完全不同的子组件、元素或父组件。它非常强大和有用——所以要明智地使用它。</strong></p><p id="fc4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们回头看看我们的<code class="fe ln lo lp lq b">App.js</code> HTML:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="8bfa" class="mt lt iq lq b gy mu mv l mw mx">&lt;!-- .... --&gt;<br/>    &lt;button onClick={() =&gt; setIsModalOpen(!isModalOpen)}&gt;<br/>        Click to Open Modal<br/>    &lt;/button&gt;<br/>    &lt;Modal modalState={isModalOpen} onClickEvent={() =&gt; setIsModalOpen(!isModalOpen)}&gt;<br/>        This is Modal Content!<br/>    &lt;/Modal&gt;<br/>&lt;/header&gt;<br/>&lt;div id="modal-container"&gt;&lt;/div&gt;</span></pre><p id="68bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，即使<code class="fe ln lo lp lq b">Modal</code>位于我们的标题中，每当我们使用按钮打开模态时，它也会出现在<code class="fe ln lo lp lq b">#modal-container</code>中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/b520fcad7e7cd8bc395231a0fabdb597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YjP0D4aBVANvj3OW.png"/></div></div></figure><h1 id="94de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="21fc" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">门户是React中一个非常强大的工具。它们是解决基于组件的系统的主要问题的有效方法——在所有其他元素之上传输某些元素。因此，我希望您喜欢这个React门户指南。如果你正在学习React，我建议你先掌握JavaScript——这可以通过我的完整的<a class="ae mz" href="https://fjolt.com/series/learn-javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript手册</a>来实现。</p><p id="3e5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">祝你愉快。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="a1b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nh">更多内容看</em> <a class="ae mz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nh">说白了。报名参加我们的</em> <a class="ae mz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nh">免费周报</em> </strong> </a> <em class="nh">。关注我们关于</em> <a class="ae mz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nh">推特</em> </strong> </a>，<a class="ae mz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nh">LinkedIn</em></strong></a><em class="nh">，</em><a class="ae mz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nh">YouTube</em></strong></a><em class="nh">，以及</em> <a class="ae mz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nh">不和</em> </strong> </a> <em class="nh">。对增长黑客感兴趣？检查</em> <a class="ae mz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nh">电路</em> </strong> </a> <em class="nh">。</em></strong></a></p></div></div>    
</body>
</html>