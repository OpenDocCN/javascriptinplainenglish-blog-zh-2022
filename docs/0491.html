<html>
<head>
<title>The Importance of Knowing JavaScript Before Starting with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在开始使用React之前了解JavaScript的重要性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-importance-of-knowing-javascript-before-knowing-react-afd0df3274e1?source=collection_archive---------25-----------------------#2022-01-27">https://javascript.plainenglish.io/the-importance-of-knowing-javascript-before-knowing-react-afd0df3274e1?source=collection_archive---------25-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a4f6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基本概念如何让你成为更好的开发人员，并为你节省大量时间和头痛。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/242ff38aa7dfb43e3967fd069d580cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oyM51LuVTm3zRMYu"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@sickhews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Wes Hicks</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="631f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我一直在我工作的公司进行React面试，我注意到许多开发人员很难回答一些问题，因为他们不熟悉基本的JavaScript概念，或者他们不知道如何将它们转化为React。在本文中，我们将关注JavaScript如何处理等式以及在使用React时的重要性。</p><p id="eea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在采访中，当我们谈到优化部分时，我会提出以下问题:</p><h2 id="fa88" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">重新渲染一个组件需要做什么？</strong></h2><p id="07d2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="mq">当我们传递给组件的道具或其内部状态发生变化时</em> s ✅</p><p id="7889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单一点。好，那么下一个代码呢:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/5383d0fb94f0d8e7c40764cbd87daf79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOINkkCquXLzgTPW22L6nw.png"/></div></div></figure><p id="7010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么每次我点击<em class="mq">增加计数器按钮</em>时<code class="fe ms mt mu mv b"><em class="mq">MyComponent</em></code>都会被重新渲染，如果我传递给它的道具总是相同的，并且我没有任何内部状态？🤔</p><h2 id="b846" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">我如何知道它正在被重新渲染？</strong></h2><p id="ecfb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">很多人回答:<em class="mq">我可以在组件</em>里面放一个 <code class="fe ms mt mu mv b">console.log</code> <em class="mq">😬</em></p><p id="7af1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这是一种方法，但请不要！🛑</p><p id="fc3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我正在寻找的答案是:<em class="mq">因为我可以使用React Dev Tools Profiler来查找它。</em></p><p id="6cef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我采访过的大多数开发人员都不知道这个工具的存在，也不知道如何使用它。如果你还没有看过，请去看看🙏</p><div class="mw mx gp gr my mz"><a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">介绍React Profiler - React博客</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">React 16.5增加了对新的DevTools profiler插件的支持。这个插件使用React的实验分析器API来…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">reactjs.org</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kp mz"/></div></div></a></div><p id="48a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们知道它的存在，那就利用它吧。下面的图片是我点击按钮19次后分析器的样子，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/7630a824ab0051e9b558ae54aea009c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQJH_FUL8RBQ-sfiet87qw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">React Dev Tools Profiler</figcaption></figure><p id="c7a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里能看到什么？，那个<strong class="ky ir"> MyComponent </strong>被渲染了19次，同样的点击量。</p><p id="acf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在回到最初的问题。</p><h2 id="7a32" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">为什么每次我点击<em class="np">增加计数器按钮</em>时<em class="np">我的组件</em>都会被重新渲染，如果我传递给它的道具总是相同的，并且我没有任何内部状态？🤔</strong></h2><p id="fefd" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">TL；DR的回答是，每次我们点击按钮，我们改变来自<strong class="ky ir"> App </strong>组件的状态，因此，导致重新渲染，每次渲染都是新的；道具，状态，孩子。所以在每一次渲染中，<strong class="ky ir"> MyComponent </strong>都会被再次渲染，即使看起来那个组件正在接受相同的道具，并且正在破坏我们在开始给出的答案中所陈述的内容。React就是这么设计的，我们也无能为力。</p><p id="aaaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我们已经有点清楚了，让我们继续。</p><h2 id="fae2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">那我们怎么防止它被重新渲染呢？(假设这个组件很重，如果道具不变，我不想每次都被重新渲染)</strong></h2><p id="fed7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">嗯，有许多解决方案，但是让我们通过使用<a class="ae kv" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> React.memo </strong> </a>来采用<a class="ae kv" href="https://en.wikipedia.org/wiki/Memoization?oldformat=true" rel="noopener ugc nofollow" target="_blank">记忆化</a>的方式，这是一个<a class="ae kv" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">高阶组件</strong> </a>，它对先前的道具和当前的道具进行简单的(将这个词留到以后)比较，以确定该组件是否应该重新渲染。</p><p id="37ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要想在记忆之前找到其他解决方案，请查看这篇精彩的文章。</p><div class="mw mx gp gr my mz"><a href="https://overreacted.io/before-you-memo/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">备忘录之前()</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">有许多关于React性能优化的文章。一般来说，如果一些状态更新很慢，你…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">反应过度了</p></div></div><div class="ni l"><div class="nq l nk nl nm ni nn kp mz"/></div></div></a></div><p id="2fc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到使用<em class="mq"> React.memo </em>的问题，让我们在下一段代码中修改我们的组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/2be8f7f0c8037284cfc5607bbf19c8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WHZWkVfc8mpkTDMNGK4tyg.png"/></div></div></figure><p id="61f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们打开profiler并再次单击按钮，现在我们可以看到我们的组件只被渲染了一次！🎉</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/1124cba5544d3c177ab0a9d9493825b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1ZuLqmjVcGIoit7KJTIFg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Results using React.memo</figcaption></figure><p id="2875" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我修改<strong class="ky ir"> MyComponent </strong>来接收一个数组，而不是一个字符串，会发生什么，如下面的代码所示？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/be5d72a528f0790e7a51555aeb679927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZe2IV2LKN5cVdjHevH7wA.png"/></div></div></figure><p id="7d75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们再检查一下侧写器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/6b8eb15f9c509a86b5db74969b605ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nWrjZ47JJrbnAxK4ho_aQ.png"/></div></div></figure><p id="1310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哦不，它又在渲染了😱为什么？</p><p id="d879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记得我之前让你留着以后用的那个词吗？是的，浅薄。正如我所说的，<em class="mq"> React.memo </em>所做的是以前的道具和新道具之间的浅层比较，所以基本上它所做的是:</p><pre class="kg kh ki kj gt nu mv nv nw aw nx bi"><span id="1774" class="ls lt iq mv b gy ny nz l oa ob">prevProps === nextProps</span></pre><p id="81c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们知道JavaScript如何工作(我们应该知道)，我们知道下一个代码返回<code class="fe ms mt mu mv b">false</code></p><pre class="kg kh ki kj gt nu mv nv nw aw nx bi"><span id="059b" class="ls lt iq mv b gy ny nz l oa ob">[] === []</span></pre><p id="a7e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也是React认为道具不一样的原因。因为他们是，虽然他们有相同的价值。</p><p id="1eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，<em class="mq"> React.memo </em>允许我们传递自己的比较器函数作为第二个参数，这样我们可以实现一个更好的方法来比较先前的属性和当前的属性是否相同，以防止渲染。因为我们知道JavaScript是如何工作的(我们应该知道),所以我们知道数组不是导致这种行为的唯一类型的属性。</p><h2 id="382a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><p id="4a8c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在你知道了，知道JavaScript如何工作使我们成为更好的React开发者。这一次，我们探索了JavaScript处理等式的方式如何在优化之类的事情上发挥巨大的作用，但是对于其他React主题，有很多事情也是如此，比如高阶函数、闭包等等。</p><p id="38f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的建议是:在React之前学习JavaScript。</p><p id="5077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干杯！</p><p id="dac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">plain English . io</em></strong></a><em class="mq">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">免费周报</em> </strong> </a> <em class="mq">。在我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">社区</em> </strong> </a> <em class="mq">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>