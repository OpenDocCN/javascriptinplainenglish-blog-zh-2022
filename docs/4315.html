<html>
<head>
<title>How to Use SvelteKit + tRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用SvelteKit + tRPC</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-sveltekit-trpc-3b2e2271f082?source=collection_archive---------4-----------------------#2022-11-20">https://javascript.plainenglish.io/how-to-use-sveltekit-trpc-3b2e2271f082?source=collection_archive---------4-----------------------#2022-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/35f4619aaea6019c2a74eec18b2a197b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u5Yq2Mq4a5PXJk3H"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1b37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">tRPC是一个不可思议的库，它带来了类型安全的客户机/服务器函数调用，而没有代码生成的膨胀。虽然它没有SvelteKit的官方插件，但它很容易添加，今天我们将向您展示如何添加。</p><h1 id="ee49" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">设置</strong></h1><p id="0c5f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要跟进，导航到您现有的SvelteKit项目，或者按照下面的说明创建一个新的项目。确保在您的项目中启用了TypeScript，否则您将错过tRPC最重要的好处！</p><pre class="me mf mg mh gt mi mj mk bn ml mm bi"><span id="29c8" class="mn lc iq mj b be mo mp l mq mr">npm create svelte@latest my-app # be sure to select `Yes, using TypeScript syntax`<br/>cd my-app<br/>npm i</span></pre><h1 id="4088" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">安装tRPC和Zod？</strong></h1><p id="80fb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">tRPC本身并不在运行时对输入进行类型检查，而是允许您自带验证器。Zod是推荐的包，也是我们今天要用的包，但是它也支持像Yup和SuperStruct这样的东西。Zod将允许我们定义一个模式，然后tRPC继承它进行输入。然后，Zod将在运行时进行类型检查，如果请求不符合模式，就会相应地失败。</p><pre class="me mf mg mh gt mi mj mk bn ml mm bi"><span id="3015" class="mn lc iq mj b be mo mp l mq mr">npm i @trpc/server @trpc/client zod</span></pre><h1 id="e826" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">定义路由器</strong></h1><p id="61cc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">路由器保存了我们所有的程序。过程只是一个输入模式和一个返回响应的方法。这映射到一个API端点。我们将在<code class="fe ms mt mu mj b">src/lib/trpc/server.ts</code>中创建它。</p><p id="2f5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了定义我们的路由器，我们首先初始化tRPC。return名称空间用于定义我们所有的路由器和过程需求。调用<code class="fe ms mt mu mj b">t.router</code>创建一个路由器，作为唯一的参数，我们有一个对象，将名称映射到过程。我们将创建一个简单的<code class="fe ms mt mu mj b">hello</code>查询过程，它接受单个字符串作为输入。然后我们将返回前缀为<code class="fe ms mt mu mj b">Hello </code>的字符串。最后，我们将路由器的类型与路由器分开导出，以备后用。</p><pre class="me mf mg mh gt mi mj mk bn ml mm bi"><span id="a310" class="mn lc iq mj b be mo mp l mq mr">import { initTRPC } from '@trpc/server';<br/>import { z } from 'zod';<br/><br/>const t = initTRPC.create();<br/><br/>export const appRouter = t.router({<br/> hello: t.procedure.input(z.string()).query(async (opt) =&gt; {<br/>    return `Hello ${opt.input}`;<br/> }),<br/>});<br/><br/>export type AppRouter = typeof appRouter;</span></pre><h1 id="ebca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">使用钩子接受请求</strong></h1><p id="9533" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们有了一个路由器，我们需要将请求路由到该路由器，并返回响应。SvelteKit给了我们<code class="fe ms mt mu mj b">handle</code>钩子来做这件事。在<code class="fe ms mt mu mj b">src/hooks.server.ts</code>中创建钩子。handle钩子拦截所有对服务器的请求，在我们的例子中，可以完全覆盖某个API路由的行为(<code class="fe ms mt mu mj b">/api/trpc</code>)。当我们检测到对该路由的请求时，我们使用tRPC的处理程序进行获取，并将响应返回给客户端。</p><pre class="me mf mg mh gt mi mj mk bn ml mm bi"><span id="cdfd" class="mn lc iq mj b be mo mp l mq mr">import type { Handle } from '@sveltejs/kit';<br/>import { fetchRequestHandler } from '@trpc/server/adapters/fetch';<br/>import { appRouter } from '$lib/trpc/server';<br/><br/>const trpcPathBase = '/api/trpc';<br/><br/>export const handle: Handle = async ({ event, resolve }) =&gt; {<br/> if (event.url.pathname.startsWith(`${trpcPathBase}/`)) {<br/>  const response = await fetchRequestHandler({<br/>   endpoint: trpcPathBase,<br/>   req: event.request,<br/>   router: appRouter,<br/>   createContext() {<br/>    return {<br/>     req: event.request,<br/>    };<br/>   },<br/>  });<br/><br/>  return response;<br/> }<br/><br/> return await resolve(event);<br/>};</span></pre><h1 id="c030" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">使用客户端创建&amp;</strong></h1><p id="ed38" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们现在可以提出请求，但首先需要一个客户端。在<code class="fe ms mt mu mj b">src/lib/trpc/client.ts</code>中，创建一个代理客户机并传递url选项，这样客户机就知道向哪里发送请求。我们将使用localhost进行开发，使用我们的部署域进行生产。</p><pre class="me mf mg mh gt mi mj mk bn ml mm bi"><span id="26cb" class="mn lc iq mj b be mo mp l mq mr">import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';<br/>import type { AppRouter } from './server';<br/>import { dev } from '$app/environment';<br/><br/>export const trpc = createTRPCProxyClient&lt;AppRouter&gt;({<br/> links: [<br/>  httpBatchLink({<br/>      // url is dependent on the environment<br/>      // in dev, we use localhost<br/>      // in prod, we use the public domain<br/>   url: dev<br/>    ? 'http://localhost:5173/api/trpc'<br/>    : `https://example.com/api/trpc`,<br/>  }),<br/> ],<br/>});</span></pre><p id="651e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在<code class="fe ms mt mu mj b">src/routes/+page.svelte</code>中导入客户端，并观察神奇的类型推断在起作用。</p><pre class="me mf mg mh gt mi mj mk bn ml mm bi"><span id="a60a" class="mn lc iq mj b be mo mp l mq mr">&lt;script lang="ts"&gt;<br/>  import { trpc } from '$lib/trpc/client'<br/><br/>  async function hello(s: string) {<br/>    return await trpc.hello.query(s);<br/>  }<br/>&lt;/script&gt;</span></pre><h1 id="d3dd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">结论</strong></h1><p id="e92f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">tRPC给fullstack TypeScript项目带来了如此多的价值。在服务器上编写一次方法，然后从客户端调用该方法而不需要代码生成步骤的能力令人难以置信。虽然有一些警告，比如要求前端和后端都在同一个repo (monorepos)中，并且只支持TypeScript，但这是大多数项目所需要的。</p><h1 id="46fe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">资源</strong></h1><p id="9a9f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">-完成<a class="ae kc" href="https://github.com/TheOtterlord/sveltekit-trpc" rel="noopener ugc nofollow" target="_blank"> SvelteKit + tRPC </a>模板<br/> - <a class="ae kc" href="https://trpc.io/docs/" rel="noopener ugc nofollow" target="_blank"> tRPC文档</a><br/>-<a class="ae kc" href="https://zod.dev/" rel="noopener ugc nofollow" target="_blank">Zod</a><br/>-<a class="ae kc" href="https://kit.svelte.dev/docs/hooks" rel="noopener ugc nofollow" target="_blank">SvelteKit挂钩</a></p><p id="727b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">更多内容请看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mv">说白了。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mv">免费周报</em> </strong> </a> <em class="mv">。关注我们</em> <a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mv">推特</em> </strong> </a>，<a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mv">领英</em> </strong> </a> <strong class="kf ir"> <em class="mv">，</em></strong><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mv">YouTube</em></strong></a><strong class="kf ir"><em class="mv">，</em> </strong> <em class="mv">和</em><a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><strong class="kf ir"><em class="mv">不和</em> 【T63 </strong> <em class="mv">对成长黑客感兴趣？检查出</em> <a class="ae kc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mv">电路</em> </strong> </a> <strong class="kf ir"> <em class="mv">。</em> </strong></strong></a></strong></a></p></div></div>    
</body>
</html>