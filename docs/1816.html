<html>
<head>
<title>The Array Reduce Method Explained in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中解释的数组简化方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/array-reduce-method-explained-in-javascript-c74146e553d5?source=collection_archive---------13-----------------------#2022-04-21">https://javascript.plainenglish.io/array-reduce-method-explained-in-javascript-c74146e553d5?source=collection_archive---------13-----------------------#2022-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbc8b5858bfcf74633e319499752b192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J9aNncWkvG01JpCW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nathan Dumlao</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9243" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当面试软件工程候选人时，我寻找的一个小但重要的细节是他们是否在习惯性地<a class="ae kc" href="https://en.wikipedia.org/wiki/Programming_idiom" rel="noopener ugc nofollow" target="_blank">编程。程序员编写惯用代码的一种方法是使用语言内置的工具和约定，而不是从头开始显式编写。解释这一点的另一种方式是坚持这句话:“不要重新发明轮子。”同样，这是一个小细节，但它显示了经验和对手边语言的掌握。</a></p><p id="0c4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript有一段独特的、漫无边际的历史，现在仍在被书写。要理解reduce方法是如何工作的，首先必须理解JavaScript中的原型继承是如何工作的。</p><h1 id="cf44" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型方法</h1><p id="7105" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">实际上JavaScript中的一切都是对象。即使是字面实例化的原语(即不是从<code class="fe me mf mg mh b">class</code>构造的)，如字符串和数字，也有一些类似对象的行为。这些行为继承自实例的<code class="fe me mf mg mh b">prototype</code>。这种继承也可以被链接。例如，数组原型继承自对象原型。</p><p id="f673" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Array.prototype</code>有几个方法使得使用数组非常方便。数组的内容是有序的，所以自然地，当处理数组时，你经常需要遍历它们。<code class="fe me mf mg mh b">Array.prototype.reduce</code>是这些方法中的一种，它允许我们以声明的方式遍历数组，同时也允许将逻辑作为参数传入。</p><h1 id="56d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解释减少方法</h1><p id="0cb8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我第一次学习JavaScript时，我倾向于避免使用<code class="fe me mf mg mh b">Array.prototype.reduce</code>，部分原因是我对自己的理解没有信心。我应该花时间构建一个坚实的心智模型，而不是依赖不太习惯的方法来解决reduce方法最适合的问题。</p><h2 id="ba12" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">在后台</h2><p id="b186" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">理解正在发生的事情的最好方法之一是建立一个流程图。一旦这个方法被分解成它的原子组成部分，它就显得不那么可怕了。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/cad8dba6d9142a1f8728edd010a9d251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRg6yCN66DmSr9fTXzoRhg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A flowchart illustrating the logic of Array.prototype.reduce.</figcaption></figure><p id="79f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理解reduce方法的另一个好方法是通过从头重写方法的逻辑来强化你的心智模型。当我参加<a class="ae kc" href="https://www.hackreactor.com/" rel="noopener ugc nofollow" target="_blank"> Hack Reactor </a>时，这是我们被分配的许多介绍性任务之一。让我们来看看一些代码。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/c2759733e3f2d98470809030dd500b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYdd6_SBq3IR-lwho7LvGw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A custom implementation of Array.prototype.reduce.</figcaption></figure><p id="2745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我将<code class="fe me mf mg mh b">Array.prototype.reduce</code>重新分配给了我的新函数，这样我就可以像平常使用reduce方法一样使用它了。这意味着我们将使用数组上的属性访问来调用这个方法，因此，我们的<code class="fe me mf mg mh b">this</code>关键字将被赋给我们调用方法的数组。在这段代码中，你可以期望<code class="fe me mf mg mh b">this</code>是你试图减少的数组。让我们浏览一下代码。</p><p id="9672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我声明了一个<code class="fe me mf mg mh b">accumulator</code>变量，并将其初始化为传入的初始值或数组中的第一项。类似地，如果没有给我们初始值，我将一个<code class="fe me mf mg mh b">index</code>变量初始化为<code class="fe me mf mg mh b">1</code>，否则为<code class="fe me mf mg mh b">0</code>。从这里开始，我简单地遍历数组，在每次迭代中，我都将<code class="fe me mf mg mh b">accumulator</code>重新赋值为等于<code class="fe me mf mg mh b">reducer</code>函数的返回值。</p><h1 id="db24" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">逮到你了</h1><p id="bee3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">记住一个编程概念的最好方法是花几个小时调试由这个概念引起的问题。这些年来，我自己也有过一些这样的经历。</p><h2 id="3063" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">记得归还蓄电池</h2><p id="1bdd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">早些时候，当我在公司面试以获得我的第一份软件工程工作时，我发现自己在最后阶段的现场面试中，我决定在我的编码问题解决方案中使用<code class="fe me mf mg mh b">Array.prototype.reduce</code>。亲自编写代码的问题可能会带来压力，并可能导致您犯一些平时不会犯的错误。在这种情况下，我忘记从我的reducer函数返回一个值。那是在<a class="ae kc" href="https://en.wikipedia.org/wiki/ECMAScript#ES2015" rel="noopener ugc nofollow" target="_blank"> ES6 </a>的早期，我在用一个箭头函数。然而，通过使用代码块(即花括号)来定义我的函数体，我忘记了我将不再受益于不使用代码块的arrow函数中内置的隐式返回。像这样:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/7a9eef404201731eabb2a9177ccde63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gX6RvBq8XduTta3x3m17qw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">An example of not returning a value from the reducer function.</figcaption></figure><p id="53f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您没有从reducer函数返回值时，累加器被重新分配为<code class="fe me mf mg mh b">undefined</code>。发生这种情况是因为当你没有从一个函数显式返回值时，<code class="fe me mf mg mh b">undefined</code>被隐式返回。因此，随着数组的迭代，累加器只是重复地被重新分配为<code class="fe me mf mg mh b">undefined</code>。</p><p id="f868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我可以使用内联arrow函数的隐式return，或者添加一个return语句。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/a49f48bb13a4403566387fe2543c6719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toNbNFkNc7elVb0__U8dgw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Examples of properly returning a value from the reducer function.</figcaption></figure><h2 id="68ba" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请记住，累加器默认为第一项</h2><p id="3f6c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用reduce方法时出现的另一个常见错误是忘记传入初始值参数。如果没有用第二个参数调用reduce方法，累加器默认为数组中的第一项，循环从数组中的第二项开始迭代。</p><p id="66aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的求和例子中，这不是一个问题，因为我们得到了相同的和。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/4fe253acc9e8a655e7bda930046c7464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2mWLQ2I8PkRlvBuKM4Tlg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">An example of using the reduce method without a 2nd parameter.</figcaption></figure><p id="9eb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，当累加器具有不同的结构或者是完全不同的JavaScript类型时，不初始化您的累加器会引入一个bug。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/7580f7010411641af696185d3991e9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qw8q1oHfxT9e9pCAxZhdZA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Examples of using the reduce method with and without the 2nd parameter.</figcaption></figure><p id="a81c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们试图对存款进行求和。每个存款都是包含一个<code class="fe me mf mg mh b">amount</code>属性的对象。因为累加器应该是一个数字，而数组项是对象，所以当我们不初始化累加器时，就会引入一个错误。</p><p id="72d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当执行代码的第一部分时，JavaScript解释器被迫尝试添加一个带有数字的对象。结果是一个字符串，因为解释器会将对象和数字强制转换成字符串，并将它们连接在一起。当我们将累加器初始化为<code class="fe me mf mg mh b">0</code>时，我们得到了想要的结果。</p><h1 id="0da0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">何时使用Reduce</h1><p id="5bd8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了用惯用法编写代码，你需要对手头的语言有很强的理解。对于JavaScript数组，有几种原型方法可以用在各种情况下。对于reduce，我喜欢在一些关键场景中使用它。</p><h2 id="ea0f" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">将数组转换为另一种数据结构</h2><p id="293e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通常在处理数组时，您需要将条目列表转换成一个值。无论是处理需要求和的一组数字，还是筛选投资组合列表以使用特定策略计算它们的数量，使用reduce方法可能是最惯用的选择。</p><p id="4e95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他时候，您需要将数组转换为对象或地图。对对象和映射的属性访问具有恒定的时间复杂度(即<code class="fe me mf mg mh b">O(1)</code>，因此有时最好是遍历数组并映射那些项，以便稍后引用该映射。</p><h2 id="21f5" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">当将多个数组方法链接在一起的计算开销很大时</h2><p id="b2a6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我经常不得不处理有几十万行的数据集。根据运行时环境中可用的资源，遍历这么多行可能需要几秒钟甚至几分钟。这意味着涉及这些数据集的算法不能承受非线性时间复杂度，并且每次优化都很重要。</p><p id="8165" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，即使我只需要将<code class="fe me mf mg mh b">Array.prototype.filter</code>和<code class="fe me mf mg mh b">Array.prototype.map</code>链接在一起以过滤数组项，然后映射它们，遍历数据集两次也太多了，即使这在技术上是线性时间复杂度(即<code class="fe me mf mg mh b">O(n)</code>)。</p><p id="d4f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以减少数组并将两部分逻辑结合在一起，而不是将两个方法链接在一起。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/594fc8db338615073c7f3566c66013a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MX1DyJPiOw9Ei3sEQkok7g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A comparison of chaining two array methods versus using reduce.</figcaption></figure><p id="f119" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到我们得到了相同的答案，但是我们只需要使用reduce遍历数组一次。同样，当我们有硬件资源限制时，这种优化是最有益的。</p><h1 id="6fe2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="dd28" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">习惯性地写代码。为了做到这一点，你需要知道并在适当的时候使用原型方法。reduce方法在正确使用时非常有用，有时通过使用流程图和代码来构建您的心智模型会非常有帮助。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="7c4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh">最初发表于</em><a class="ae kc" href="https://codingbootcampguides.com/" rel="noopener ugc nofollow" target="_blank"><em class="nh">【https://codingbootcampguides.com】</em></a><em class="nh">。</em></p><p id="df0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nh">说白了。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nh">免费周报</em> </strong> </a> <em class="nh">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="nh">Twitter</em></strong></a><em class="nh">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="nh">LinkedIn</em></strong></a><em class="nh">。加入我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nh">社区</em> </strong> </a> <em class="nh">。</em></strong></a></p></div></div>    
</body>
</html>