# JavaScript 中的自制缓存和修剪

> 原文：<https://javascript.plainenglish.io/homemade-caching-and-pruning-6f4826b745a5?source=collection_archive---------13----------------------->

## JavaScript 中的缓存和修剪指南。

![](img/839231a5414fa1527097191f4a697ece.png)

我最近参与了一个后端项目，该项目有两个主要目标:

*   为读/写数据库操作构建一个 API
*   在 AWS 上部署和优化

在设置了服务器路由、数据库填充和 EC2 配置之后，我准备开始对 API 进行压力测试。

我受限于 t2.micros，所以纵向扩展并不是一个真正的选择。这就剩下了两种降低平均响应时间的方法…

水平缩放和缓存。今天的帖子讲的是后者。

**缓存选项**

有几种健壮的数据存储技术可用(Redis、Memcached ),但是因为缓存是一种非常强大的工具，所以我真的想深入了解并实现自己的技术。

幸运的是，总的原则是如此简单，把它放在一起既简单又有趣。

**实施**

为了在 O(1)时间内执行这些查找，我们需要一个具有键值对的基本对象(hash)。

因此，我将定义缓存和两个函数来处理我们需要经常进行的事务:

**快速提示:第 12 行的数字 1 是第 5 行也在递增的计数器。这个计数器在以后会有帮助，但是现在可以忽略。*

checkCache() 将查找先前的匹配响应，如果可用，则返回它。

createCache() 将在我们的缓存中创建新记录。

现在，我们只需要将这两个函数编织到所需的服务器路由中，这样，当请求在其他任何事情发生之前(在我的服务器将时间浪费在不必要的工作上之前)到来时，我们将检查缓存，如果可能的话，返回我们所拥有的。

如果我们没有它，我们将根据请求检索数据，然后创建一个记录供将来参考

你会注意到，为了尽可能简单，我省略了大部分上下文。您的键值对可能看起来非常不同。这是一个电子商务项目，所以我使用一个包含“产品”和产品 id 的字符串来创建一个唯一的键。

这个解决方案按原样工作。当缓存预热(存储了值)时，压力测试显示平均延迟显著降低，每秒请求数增加(我使用 Loader.io)。

**修剪**

虽然这对于测试来说可能足够了，但是对于持续运行的生产应用程序来说，这让我陷入了一个棘手的境地。当缓存增长超过可行的大小时会发生什么？

我如何(自动地)修剪这种过度生长，更重要的是，我如何使它成为一个智能的/战略性的过程？

**实施**

好吧，首先让我们说，我们要拿出一个以上的修剪模态。目前，我有两个想法——“测试”和“生产”。

对于测试，我的关注是单一的-我只是不想让它超载。通常，我的压力测试持续大约一分钟。我希望能够预热我的缓存(通常通过运行几个压力测试来模拟真实的日常使用量)，然后运行我的实际测试。

下面是初始清理功能的概要:

因此，我们将把当前的缓存和所需的修剪方法传递给它。如果这个方法是' test '，那么我们将简单地返回一个清空的缓存。

现在是生产形态

我在这里想要什么？在生产环境中，我的任务是创造最好的用户体验(很多时候，以 UX = *闪电般的速度*来说是“最好的”)。因此，我将使用搜索频率来确定要从缓存中删除哪些项目。现在，每个值数组中内置的计数器开始使用。

在上面代码的第 8 行，您可以看到我已经将阈值(任意地)设置为 10。所以现在，在最后一个清理间隔中查询次数少于 10 次的所有产品都将从缓存中删除。

然后，为了保持当前的频率计数，我将在每次修剪时重置剩余缓存项的计数器。换句话说，每个产品都必须证明其受欢迎程度，才能留在缓存中。

**园丁**

现在，我将创建一个园丁来应用修剪，在这种情况下，它将是一个 setInterval 方法。为了执行这个，我将使用下面的代码-

现在，prune 方法将每分钟应用于缓存，如果 pruneMethod = 'production '，我们知道缓存中将清除所有低于我们之前设置的搜索阈值的记录(10)。

但是，如果我想要更彻底的修剪，以便随着时间的推移进一步优化缓存，并将其保持在一定的大小范围内，该怎么办呢？

只是为了好玩，让我们给园丁#1 一个伙伴，园丁#2。

假设园丁#2 将会比园丁#1 多做 10 次修剪缓存的工作。

这里有一个稍微高级一点的修剪概念:

我将为这种修剪方法添加第三个参数“容量”。这里我们将为缓存传入一个指定的容量。如果方法仍然是“生产”，在第 5 行和第 6 行，我将计算我们的缓存超出容量多少(溢出)。

如果有溢出，我将在第 9 行调用一个助手来做进一步的操作。我对助手的要求是:

从最少搜索的记录开始，获取现有的缓存并削减指定的减少量(溢出+ 25%的容量-在每个周期将我们的缓存减少到 75%的容量) ***。***

通过这种方式，我们的缓存保持相关性，同时其容量也得到控制。

现在我们可以把高级西梅交给我们的第二个园丁了:

现在，我让 1 号园丁每小时运行一次(3，600，000 毫秒)，2 号园丁每 10 小时跟进一次。

下面是每个文件中的完整代码。

修剪的可能性是无限的，可以针对任何使用情形和流量级别进行定制。

显然，像 Redis 和 Memcached 这样的数据存储将包含更多的特性和改进，但是如果你像我一样喜欢应用实验，自己创建它将会是一次有益的经历。

*更多内容请看*[***plain English . io***](https://plainenglish.io/)*。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。关注我们关于*[***Twitter***](https://twitter.com/inPlainEngHQ)*和*[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*。加入我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *。*