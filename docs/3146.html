<html>
<head>
<title>How to Avoid CORS Issues in React/Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React/Next.js中如何避免CORS问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/avoiding-cors-issues-in-react-next-js-6a50c3f94653?source=collection_archive---------4-----------------------#2022-08-04">https://javascript.plainenglish.io/avoiding-cors-issues-in-react-next-js-6a50c3f94653?source=collection_archive---------4-----------------------#2022-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="44c7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果你编写过任何前端代码，你可能以前遇到过CORS错误。在这篇文章中，我们将看看如何修复它们。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/79b84f881fa7b590ad11bd4a1722444e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KzleSnAPbymFFXDW.png"/></div></div></figure><p id="b9ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您编写过任何前端代码，您可能以前遇到过CORS错误，就像这样:</p><p id="5893" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">访问_ </strong> <strong class="kq io">已被CORS政策封锁</strong></p><p id="5ae5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">跨源资源共享(CORS)是一种协议，它定义了当web请求跨越不同的URL时应该如何处理它们。</p><h1 id="4767" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">为什么跨来源请求是一个问题？</h1><p id="88d9" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">你的浏览器保存了你访问的每个网站的很多状态。假设您登录到mybank.com的<strong class="kq io"/>，并且您有一个设置有<strong class="kq io">mybank.com</strong>的cookie，表明您已经登录。</p><p id="28fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当您正在浏览时，您意外地访问了<strong class="kq io">恶意站点</strong>，它向<strong class="kq io">mybank.com</strong>发出了如下请求:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="951d" class="mm ll in mi b gy mn mo l mp mq">// Fetch request made from https://malicious.site<br/>fetch("https://api.mybank.com/account_details", {<br/>    method: "GET",<br/>    credentials: "include",<br/>})</span></pre><p id="22b2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果该请求被允许，并且您的cookie被包含在内，<strong class="kq io">恶意站点</strong>的所有者将能够代表您发出请求并读取您的帐户详细信息。</p><p id="bf50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用CORS，服务器可以指定接受或拒绝哪些跨源请求。它可以拒绝需要cookies的请求。它可以拒绝来自<strong class="kq io">untrusted.mybank.com</strong>的请求，但接受来自<strong class="kq io">app.mybank.com</strong>的请求。它可以拒绝所有POST请求，但允许get和put。</p><p id="7985" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">关于CORS需要注意的重要一点是，配置/设置是在<strong class="kq io">服务器</strong>上完成的，并且由服务器和你的浏览器强制执行。大多数服务器框架都有一个库来配置你的CORS头文件，但是如果你想看到底层头文件本身，<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">这里有一个很好的资源</a>。</p><h1 id="688f" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">实际例子</h1><p id="02c7" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">假设我们有一个带有快速后端的React应用程序。我们的前端运行在端口3000上——这是React常见的默认端口。</p><p id="2b87" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于我们的后端不能在本地端口3000上运行，我们将设置Express在端口4000上运行。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="c355" class="mm ll in mi b gy mn mo l mp mq">const express = require('express')<br/>const app = express()<br/>const port = 4000</span><span id="0b8b" class="mm ll in mi b gy ms mo l mp mq">app.get('/whoami', (req, res) =&gt; {<br/>    res.send('Who is anybody?')<br/>})</span><span id="af75" class="mm ll in mi b gy ms mo l mp mq">app.listen(port, () =&gt; {<br/>    console.log(`Example app listening on port ${port}`)<br/>})</span></pre><p id="bf19" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们的React应用程序像这样向我们的后端发出一个获取请求:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="c2ad" class="mm ll in mi b gy mn mo l mp mq">// Fetch request made from http://127.0.0.1:3000<br/>fetch("http://127.0.0.1:4000/whoami")</span></pre><p id="3acc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们应该预料到CORS误差。就像我们之前的例子一样，127.0.0.1: <strong class="kq io"> 3000 </strong>和127.0.0.1: <strong class="kq io"> 4000 </strong>被视为两个独立的域，因此您还不能跨它们发出请求。让我们来看看解决这个问题的几种方法。</p><h2 id="f27c" class="mm ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated">修复1:修复服务器</h2><p id="877e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">一种方法是修复我们的服务器。我们可以通过安装一个CORS库(<a class="ae mr" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/cors</a>)并告诉服务器期待来自127.0.0.1:3000的请求来做到这一点</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="9e98" class="mm ll in mi b gy mn mo l mp mq">app.use(cors({<br/>    origin: 'http://127.0.0.1:3000',<br/>}))</span></pre><p id="5db3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的请求将会成功。这种方法非常简单，通常也是很好的实践。如果我们的前端和后端托管在两个不同的子域上，我们可以在生产中使用同样的方法。</p><h1 id="3207" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">修复2:添加代理</h1><p id="785c" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">在生产中，在某些情况下，您将从同一来源托管您的前端和后端。在这些情况下，您通常希望编写如下所示的获取代码:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="6c1a" class="mm ll in mi b gy mn mo l mp mq">fetch("/whoami")</span></pre><p id="b27b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">而不是像这样:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="d072" class="mm ll in mi b gy mn mo l mp mq">const url;<br/>if (process.env.NODE_ENV === "production") {<br/>    url = "https://www.example.com/whoami"<br/>} else {<br/>    url = "http://127.0.0.1:4000/whoami"<br/>}<br/>fetch(url)</span></pre><p id="a20c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为此，<strong class="kq io"> create-react-app </strong>实际上自带了设置一个<a class="ae mr" href="https://create-react-app.dev/docs/proxying-api-requests-in-development/" rel="noopener ugc nofollow" target="_blank">简单代理</a>的能力。将以下内容添加到package.json中:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="e8e6" class="mm ll in mi b gy mn mo l mp mq">"proxy": "http://localhost:4000",</span></pre><p id="5d96" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，任何看起来像API请求的请求(例如，内容类型为application/json)将被自动转发到<a class="ae mr" href="http://localhost:4000." rel="noopener ugc nofollow" target="_blank"><strong class="kq io">http://localhost:4000</strong>。</a></p><p id="a31c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">绕过CORS问题的原因是，对于浏览器来说，请求<em class="ne">是</em>去往<a class="ae mr" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">http://localhost:3000</strong></a>，因此看起来不像是跨来源的请求。位于<a class="ae mr" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">http://localhost:3000</strong></a>的服务器会将请求转发给<a class="ae mr" href="http://localhost:4000," rel="noopener ugc nofollow" target="_blank"><strong class="kq io">http://localhost:4000</strong></a>，但浏览器不知道。‍</p><p id="b432" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您使用的是<strong class="kq io"> Next.js </strong>而不是<strong class="kq io"> create-react-app，</strong>您可以在<strong class="kq io"> next.config.js </strong>中设置一个重定向，它将转发所有匹配的流量:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="1a6b" class="mm ll in mi b gy mn mo l mp mq">module.exports = {<br/>  async rewrites() {<br/>    return [<br/>      {<br/>        source: '/api/:path*',<br/>        destination: 'http://localhost:4000/:path*'<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><h1 id="8774" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">摘要</h1><p id="cce3" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">修复React和Next.js中任何CORS问题的最简单方法实际上是不要在React或Next.js中做任何更改，而是修复您的服务器以允许来自它们的请求。</p><p id="445b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您不能更改服务器，React和Next.js都有办法让您将它们转换为代理，并代表您向后端发送代理请求。这通过使您的浏览器认为请求不再是跨来源请求而避免了任何CORS问题。</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="1c02" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ne">更多内容请看</em><a class="ae mr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ne">plain English . io</em></strong></a><em class="ne">。报名参加我们的</em> <a class="ae mr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">免费周报</em> </strong> </a> <em class="ne">。关注我们关于</em><a class="ae mr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ne">Twitter</em></strong></a><a class="ae mr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ne">LinkedIn</em></strong></a><em class="ne">，以及</em> <a class="ae mr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ne">不和</em> </strong> </a> <em class="ne">。</em></p></div></div>    
</body>
</html>