<html>
<head>
<title>Generator Functions: All You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发电机功能:您需要知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/generator-functions-all-you-need-to-know-3d5a2cb9ca2e?source=collection_archive---------2-----------------------#2022-10-01">https://javascript.plainenglish.io/generator-functions-all-you-need-to-know-3d5a2cb9ca2e?source=collection_archive---------2-----------------------#2022-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd57" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是生成器函数，它们与常规方法有什么不同，什么时候应该使用它们？</h2></div><p id="b7d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能听说过生成器方法，但可能对它们与常规方法有何不同以及何时应该使用它们感到困惑。希望这篇文章能对这些方面有所启发。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/9a1eb04d2ac4d2218114dc97243c4218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/0*qNRXEvXJMSpnBth5.jpeg"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae ln" href="https://miro.medium.com/max/640/1*RJXe3ij2rR4RNKFox-qgvw.jpeg" rel="noopener">link</a></figcaption></figure><blockquote class="lo lp lq"><p id="de6b" class="kf kg lr kh b ki kj jr kk kl km ju kn ls kp kq kr lt kt ku kv lu kx ky kz la ij bi translated"><strong class="kh ir">语法</strong></p></blockquote><pre class="lc ld le lf gt lv lw lx ly aw lz bi"><span id="e51e" class="ma mb iq lw b gy mc md l me mf">function* generator(i) {<br/>  yield i;<br/>  yield i + 1;<br/>}</span><span id="21e3" class="ma mb iq lw b gy mg md l me mf">const gen = generator(10);</span><span id="de83" class="ma mb iq lw b gy mg md l me mf">console.log(gen.next().value);<br/>// expected output: 10</span><span id="07fe" class="ma mb iq lw b gy mg md l me mf">console.log(gen.next().value);<br/>// expected output: 11</span></pre><p id="d47a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会看到一个生成器方法用*表示，这就是你如何快速判断这个方法是一个生成器函数还是一个常规函数。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><blockquote class="lo lp lq"><p id="6396" class="kf kg lr kh b ki kj jr kk kl km ju kn ls kp kq kr lt kt ku kv lu kx ky kz la ij bi translated"><strong class="kh ir">什么是生成器方法</strong></p></blockquote><p id="6304" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器是可以退出并稍后重新进入的函数，不像常规函数只能进入一次。它们的上下文(变量绑定)将在重入时被保存。</p><p id="153e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用生成器函数不会立即执行它的整个主体。相反，它返回一个迭代器对象，然后您可以调用next方法继续顺序执行。当迭代器的<code class="fe mo mp mq lw b">next()</code>方法被调用时，生成器函数的主体被执行，直到第一个<code class="fe mo mp mq lw b"><a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" rel="noopener ugc nofollow" target="_blank">yield</a></code>表达式。<code class="fe mo mp mq lw b">next()</code>方法返回一个对象，其<code class="fe mo mp mq lw b">value</code>属性包含生成的值，其<code class="fe mo mp mq lw b">done</code>布尔属性指示生成器是否生成了它的最后一个值。</p><pre class="lc ld le lf gt lv lw lx ly aw lz bi"><span id="4b0e" class="ma mb iq lw b gy mc md l me mf">function* mygenerator(i) {<br/>  yield i;<br/>  yield i + 1;<br/>}</span><span id="f13d" class="ma mb iq lw b gy mg md l me mf">const gen = mygenerator(10);</span><span id="5ce9" class="ma mb iq lw b gy mg md l me mf">console.log(gen.next().value);<br/>// expected output: 10</span><span id="1ffb" class="ma mb iq lw b gy mg md l me mf">console.log(gen.next().value);<br/>// expected output: 11</span></pre><p id="7d45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器中的<code class="fe mo mp mq lw b">return</code>语句在执行时，将使生成器结束(即由它返回的对象的<code class="fe mo mp mq lw b">done</code>属性将被设置为<code class="fe mo mp mq lw b">true</code>)。如果返回一个值，它将被设置为生成器返回的对象的<code class="fe mo mp mq lw b">value</code>属性。同样，如果出现异常，done属性也将被设置为true。</p><p id="4a51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以用<code class="fe mo mp mq lw b">yield*</code>替换<code class="fe mo mp mq lw b"><a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" rel="noopener ugc nofollow" target="_blank">yield</a></code>来从一个生成器中调用另一个生成器</p><pre class="lc ld le lf gt lv lw lx ly aw lz bi"><span id="49c9" class="ma mb iq lw b gy mc md l me mf">function* myGenerator2(i) {<br/>  yield i + 1;<br/>  yield i + 2;<br/>  yield i + 3;<br/>}<br/><br/>function* myGenerator1(i) {<br/>  yield i;<br/>  yield* myGenerator2(i);<br/>  yield i + 10;<br/>}<br/><br/>const gen = myGenerator1(10);<br/><br/>console.log(gen.next().value); // 10<br/>console.log(gen.next().value); // 11<br/>console.log(gen.next().value); // 12<br/>console.log(gen.next().value); // 13<br/>console.log(gen.next().value); // 20</span></pre><p id="a954" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在方法完成且done属性设置为true(通过完成整个方法的执行或通过return或error语句)后调用的任何数量的<code class="fe mo mp mq lw b">next()</code>语句，将使值返回为false，done设置为true。</p><pre class="lc ld le lf gt lv lw lx ly aw lz bi"><span id="4f10" class="ma mb iq lw b gy mc md l me mf">function* myGenerator() {<br/>  yield "A";<br/>  return "B";<br/>  yield "C";<br/>}<br/><br/>const gen = myGenerator();<br/>console.log(gen.next()); // { value: "A", done: false }<br/>console.log(gen.next()); // { value: "B", done: true }<br/>console.log(gen.next()); // { value: undefined, done: true }</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/4e1ba06956f1dcd77befb194c8d606f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/0*AxSJWR3vd8m3K--_.jpeg"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><blockquote class="lo lp lq"><p id="8570" class="kf kg lr kh b ki kj jr kk kl km ju kn ls kp kq kr lt kt ku kv lu kx ky kz la ij bi translated"><strong class="kh ir">用例——何时以及为何使用</strong></p></blockquote><p id="0856" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，一个价值百万美元的问题来了,“我什么时候以及为什么要使用生成器方法。</p><ul class=""><li id="e42a" class="ms mt iq kh b ki kj kl km ko mu ks mv kw mw la mx my mz na bi translated"><strong class="kh ir">惰性评估—仅在需要时运行</strong></li></ul><p id="d871" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设有一个无限的数据流，我们不能用一生的时间来评估这些数据。因此，我们可以在需要时使用生成器函数进行计算。</p><p id="1251" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是这种行为的一个非常常见的用例</p><blockquote class="nb"><p id="27c7" class="nc nd iq bd ne nf ng nh ni nj nk la dk translated"><em class="nl">创建连续id。您可以轻松地运行while(true)循环来获得一个新的亮片id，只有当您调用next()时，它才会计算下一个id。</em></p></blockquote><pre class="nm nn no np nq lv lw lx ly aw lz bi"><span id="672f" class="ma mb iq lw b gy mc md l me mf">function* idMaker() {<br/>  let index = 0;<br/>  while (true) {<br/>    yield index++;<br/>  }<br/>}<br/><br/>const gen = idMaker();<br/><br/>console.log(gen.next().value); // 0<br/>console.log(gen.next().value); // 1<br/>console.log(gen.next().value); // 2<br/>console.log(gen.next().value); // 3</span></pre><ul class=""><li id="63b7" class="ms mt iq kh b ki kj kl km ko mu ks mv kw mw la mx my mz na bi translated"><strong class="kh ir">记忆高效</strong></li></ul><p id="5d1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于它是惰性执行，因此它的内存效率更高，因为内存仅分配给数据，直到产生语句</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/fbef2a6d7f6f827472f2143e87bdd20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/0*I9CnJfZFd3ulyxO9"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><blockquote class="lo lp lq"><p id="9aaf" class="kf kg lr kh b ki kj jr kk kl km ju kn ls kp kq kr lt kt ku kv lu kx ky kz la ij bi translated"><strong class="kh ir">结论和需要记住的事情</strong></p></blockquote><ul class=""><li id="f87e" class="ms mt iq kh b ki kj kl km ko mu ks mv kw mw la mx my mz na bi translated">不能在生成器方法上调用构造函数</li></ul><pre class="lc ld le lf gt lv lw lx ly aw lz bi"><span id="162a" class="ma mb iq lw b gy mc md l me mf">function* = myGenerator() {}<br/>const obj = new myGenerator; <br/>// throws "TypeError: myGenerator is not a constructor</span></pre><ul class=""><li id="48a7" class="ms mt iq kh b ki kj kl km ko mu ks mv kw mw la mx my mz na bi translated"><code class="fe mo mp mq lw b">yield</code>是一条双行道:它不仅向外部返回结果，还可以通过在next()方法内部传递一个参数来传递生成器内部的值。</li></ul><pre class="lc ld le lf gt lv lw lx ly aw lz bi"><span id="eef1" class="ma mb iq lw b gy mc md l me mf">function *myGenerator() {<br/>        console.log('Hey ', yield)<br/>        console.log('is your last name ',yield)<br/>}<br/>let gen = myGenerator()<br/>gen.next()<br/>gen.next('sumeet') // Hey sumeet<br/>gen.next('bhalla') // is your last name bhalla</span></pre><p id="49ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章能帮助clera理解生成器方法的神秘本质。如果你使用Redux Saga，你将特别需要处理它们。</p><p id="b65f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这篇文章，并想了解更多关于redux Saga，请点击这里</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/redux-thunk-vs-redux-saga-all-you-need-to-know-ecb06eb7e34e"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">Redux Thunk vs Redux Saga:你需要知道的一切</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">您需要了解的关于Redux Thunk和Redux Saga的一切，以便为您的项目选择正确的React中间件。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oe l"><div class="of l og oh oi oe oj lh nv"/></div></div></a></div><p id="b00d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里还有一些Javascript文章，你可能也会感兴趣</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/must-know-javascript-features-in-2022-80c0655a6e98"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">2022年必知的JavaScript特性</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">使用这些功能，您可以减少代码并使其更具可读性。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj lh nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/all-about-importing-methods-in-javascript-d8d84fbd30d3"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">关于在JavaScript中导入方法的所有内容</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">知道在什么情况下使用什么语法。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj lh nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/type-coercion-in-javascript-ef5e390d2318"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">JavaScript中的类型强制</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">虽然JavaScript被认为是对初学者来说最简单的编程语言之一，但它也可能变得令人沮丧…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oe l"><div class="om l og oh oi oe oj lh nv"/></div></div></a></div></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="c4b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lr">更多内容请看</em><a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lr">plain English . io</em></strong></a><em class="lr">。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lr">免费周报</em> </strong> </a> <em class="lr">。关注我们关于</em><a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lr">Twitter</em></strong></a><a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lr">LinkedIn</em></strong></a><em class="lr"/><a class="ae ln" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lr">YouTube</em></strong></a><em class="lr"/><a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lr">不和</em> </strong> </a> <em class="lr">。对增长黑客感兴趣？检查</em> <a class="ae ln" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lr">电路</em> </strong> </a> <em class="lr">。</em></p></div></div>    
</body>
</html>