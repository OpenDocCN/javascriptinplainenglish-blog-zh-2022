<html>
<head>
<title>Build an Authenticated API Service with Next.js API Routes &amp; Upstash Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Next.js API Routes &amp; Upstash Redis构建一个经过认证的API服务</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-an-authenticated-api-service-with-next-js-api-routes-and-upstash-redis-a49fe6ad0311?source=collection_archive---------9-----------------------#2022-09-07">https://javascript.plainenglish.io/build-an-authenticated-api-service-with-next-js-api-routes-and-upstash-redis-a49fe6ad0311?source=collection_archive---------9-----------------------#2022-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8c6b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何利用next . js API Routes &amp;<a class="ae kc" href="https://upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank">upshredis</a>构建一个最小但功能完整的认证Rest API服务的教程。</h2></div><p id="9467" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在本文中，我们将构建一个最小但功能完整的认证Rest API服务，利用Next.js API路由和<a class="ae kc" href="https://upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank">upshredis</a>，我们将使用它作为超高速存储/缓存系统，用于数据、用户认证和JWT处理。请注意，这个项目不会有一个前端，但它将只公开可以用各种客户端查询的API。</p><h1 id="756c" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">先决条件</h1><p id="f84c" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">要跟随教程，您需要:</p><ul class=""><li id="67f8" class="lw lx in kf b kg kh kj kk km ly kq lz ku ma ky mb mc md me bi translated">一个新贵账户——<a class="ae kc" href="https://console.upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank">在这里注册一个免费账户</a></li><li id="11b6" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">Redis的基础知识</li><li id="ab56" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">Next.js API路线的基本知识</li><li id="4a8d" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">认证和授权工作流的基本知识</li><li id="ea1d" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">您可以选择一个工具来发出HTTP请求</li></ul><h2 id="4fc2" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">什么是Upstash Redis</h2><p id="0348" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated"><a class="ae kc" href="https://upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank"> Upstash </a>是<strong class="kf io">基于Redis的无服务器内存云数据库</strong>。我们将使用它来存储将由我们的API提供服务的数据，我们还将在<a class="ae kc" href="https://upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank">upshredis</a>中存储我们的用户群和用户令牌。</p><h2 id="5306" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">我们将建造什么</h2><p id="0535" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">我们将编写一个REST API服务，允许客户端应用程序向它请求数据(在这个特定的例子中是电影列表)；我们将使用JWT保护端点，我们将编写一个API登录服务来获取令牌，我们还将实现一个刷新令牌工作流。</p><p id="5b0a" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kf io">我们不会关注</strong>客户端开发(因为我们正在构建一个‘非个人化’的服务)，但是我们会提供我们服务的规范，这样任何人都可以为它构建一个客户端。</p><h2 id="fdce" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">存储库和演示</h2><p id="030e" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">为了跟进，您可能想要克隆项目存储库</p><div class="mw mx gp gr my mz"><a href="https://github.com/popeating/upstash-jwt" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">GitHub - popeating/upstash-jwt</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">这是一个用create-next-app引导的Next.js项目。首先，运行开发服务器:打开…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn no mz"/></div></div></a></div><p id="707b" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">您也可以在以下URL尝试演示:</p><p id="8688" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><a class="ae kc" href="https://upstash-dwov9jbiq-popland.vercel.app/api/auth/signin" rel="noopener ugc nofollow" target="_blank">https://upstash-dwo v9 jbiq-pop land . vercel . app/API/auth/sign in</a></p><p id="b01b" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">要连接到服务，发出一个POST HTTP请求，传递用户名(<em class="np">me@home.org</em>)和密码(<em class="np">密码</em>)，如下例所示(使用Postman):</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nq"><img src="../Images/496dcc830bc039445ac8e837fc1a8aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbHPJhbz5C7p0RhhcClsyQ.png"/></div></div></figure><h2 id="9472" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">建立Redis数据库</h2><p id="9050" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">首先，你需要注册<a class="ae kc" href="https://upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank">upshredis</a>(一个免费计划将用于测试目的)，一旦登录到控制台，你可以创建一个新的数据库:</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ob"><img src="../Images/c5ceb5873692fc6e0b62c546a0252403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVx2VOHSSoqx7u1_2rzLtQ.png"/></div></div></figure><p id="1665" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">继续点击“创建数据库”，将其命名为MovieManager，并将其设置为Global。<br/>我们现在使用<a class="ae kc" href="https://console.upstash.com/?utu_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank"> Upstash </a> CLI添加一些虚拟数据</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ob"><img src="../Images/e2bfde3aae5d7ba9876b9f628e49ca86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SQKoOTvBC4MVzme7MIl9w.png"/></div></div></figure><p id="e302" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们将使用HMSET命令添加一些电影作为Redis hash(它们基本上是对象):</p><pre class="nr ns nt nu gt oc od oe of aw og bi"><span id="3370" class="mk la in od b gy oh oi l oj ok">hmset movie:’Dr. Strangelove’ director ‘Stanley Kubrick’ year 1964<br/>hmset movie:’2001: A Space Odyssey’ director ‘Stanley Kubrick’ year 1968<br/>hmset movie:’Pulp Fiction’ director ‘Quentin Tarantino’ year 1994<br/>hmset movie:’Django Unchained’ director ‘Quentin Tarantino’ year 2012</span></pre><p id="436e" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们还将添加一个将被授权访问数据的用户，该用户也将是一个Redis散列:</p><pre class="nr ns nt nu gt oc od oe of aw og bi"><span id="c444" class="mk la in od b gy oh oi l oj ok">hmset user:’me@home.org’ password $2b$10$zctxUVDyy3jzvSp68oKpMOnkyra4R.NzOFVh9aii3Y43X7XtetoyK level 0</span></pre><blockquote class="ol om on"><p id="cc6b" class="kd ke np kf b kg kh jo ki kj kk jr kl oo kn ko kp op kr ks kt oq kv kw kx ky ig bi translated"><strong class="kf io">请注意</strong>:密码是用<code class="fe or os ot od b"><strong class="kf io">bcrypt</strong></code>加密的(简单来说就是<em class="in">密码</em>)，通常，需要访问API的用户通过网站注册(或者在网站上获取凭证)，在这个例子中我们不提供注册端点</p></blockquote><p id="340a" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在<a class="ae kc" href="https://console.upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank"> Upstash </a> CLI中输入的每个命令都应该给你一个OK回复，如果一切都正确，你就可以进入<em class="np">数据浏览器</em>并选择Hash，你就会得到你插入的数据列表</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ob"><img src="../Images/f1fb83d4bfc06f327613e66d5922e6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKgKG1BXbTER6_YQzjxq2Q.png"/></div></div></figure><h2 id="e383" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">授权工作流程</h2><p id="ba83" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">如前所述，我们的端点是不可公开访问的，因此我们需要一种方法来认证和授权用户。对于身份验证，我们提供一个登录端点；对于授权，受保护端点需要一个随请求一起发送的授权头。工作流程的详细工作方式如下:</p><ul class=""><li id="513f" class="lw lx in kf b kg kh kj kk km ly kq lz ku ma ky mb mc md me bi translated">用户请求登录端点，发布用户名和密码</li><li id="e7bf" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">服务器尝试对用户进行身份验证，如果用户有效，服务器创建并发回一个JWT (JSON Web令牌)和一个刷新令牌，刷新令牌也存储在我们的<a class="ae kc" href="https://upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank"> Upstash Redis </a>实例中</li><li id="7595" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">客户端取回令牌并将它们存储在某个地方(如何/在哪里存储它们是客户端的责任)</li><li id="c307" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">客户端请求一个受保护的端点，在报头中发送JWT</li><li id="c7ef" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">服务器接收JWT，对其进行验证，如果验证通过，则发回客户端请求的数据</li><li id="70b9" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">一旦JWT过期或即将过期，客户端可以通过向特定端点发送刷新令牌来请求新的JWT，而无需重新登录。</li><li id="597d" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">服务器接收刷新令牌，对其进行验证，如果验证是肯定的，则发布新的JWT和刷新令牌，将它们发送回客户端，并再次存储新的刷新令牌</li></ul><p id="cd14" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">JWT和刷新令牌采用相同的格式，获得几乎相同的信息，但使用两个不同的密钥(我们将在我们的<code class="fe or os ot od b">.<strong class="kf io">env</strong></code> <strong class="kf io"> </strong>文件中设置)并获得两个不同的到期时间:一个是JWT的短到期时间(因为它是会话期间使用最多的令牌，我们让它很快到期，以防它被拦截)，另一个是刷新令牌的长到期时间。两者的持续时间取决于你需要停留的安全程度；通常，JWT在不到一个小时内到期，而刷新令牌可以持续一个月。如果两个令牌都过期，用户需要再次登录。</p><h1 id="6e13" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">设置项目</h1><p id="9fd6" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">一旦我们完成了upshredis数据库，我们就可以开始初始化我们的项目；首先，我们创建一个新的Next.js项目:</p><pre class="nr ns nt nu gt oc od oe of aw og bi"><span id="bb69" class="mk la in od b gy oh oi l oj ok"><strong class="od io">npx create-next-app upstash-jwt</strong></span></pre><p id="17e6" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">然后，我们进入新创建的文件夹<code class="fe or os ot od b"><strong class="kf io">upstash-jwt</strong></code>，安装所需的模块:</p><pre class="nr ns nt nu gt oc od oe of aw og bi"><span id="d63c" class="mk la in od b gy oh oi l oj ok"><strong class="od io">npm i bcrypt jsonwebtoken @upstash/redis</strong></span></pre><p id="881f" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">创建一个<code class="fe or os ot od b"><strong class="kf io">.env.local</strong></code>文件来存储您的密钥并填入正确的数据</p><figure class="nr ns nt nu gt nv"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="7898" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">创建将用于生成JWT的SECRET_TOKEN和SECRET_RTOKEN，请记住这些密钥应该保密，并且应该非常随机/难以猜测，您可以使用64位十六进制字符串。<br/>从您的<a class="ae kc" href="https://console.upstash.com/?utm_source=Lorenzo1" rel="noopener ugc nofollow" target="_blank"> Upstash控制台</a>，详细信息选项卡，Rest API部分获取UPSTASH_REDIS_REST_URL和UPSTASH_REDIS_REST_TOKEN:</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ow"><img src="../Images/c3dbbf48238b325b9cfa103b69ff6a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROIjYoETrB2mgvsuH2kxtg.png"/></div></div></figure><p id="50d1" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们现在可以开始布置我们的端点了:</p><p id="6c5a" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kf io"> POST /auth/signin </strong></p><p id="8edb" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kf io"> GET /movies/ </strong> <br/>以JSON对象的形式返回电影列表，它需要一个有效的JWT，在头中以这样的格式传递:<br/> <em class="np">授权:无记名xxx </em></p><p id="e227" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kf io"> GET /movies/$ID <br/> </strong>返回ID为$ID的电影的细节</p><p id="8600" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kf io"> POST /auth/refresh </strong> <br/>生成并返回一个新的JWT，刷新令牌应该作为<code class="fe or os ot od b">refreshToken</code> <strong class="kf io"> </strong>参数传递。</p><h1 id="6475" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">API路线的代码</h1><p id="af7c" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">我们从登录端点开始，创建文件<code class="fe or os ot od b"><strong class="kf io">pages/api/auth/signin.js</strong></code>，如下所示:</p><figure class="nr ns nt nu gt nv"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="7af2" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们的登录端点将只接受带有两个参数的POST:<strong class="kf io">用户</strong>和<strong class="kf io">密码</strong>。首先，我们使用以下命令检查用户是否在Redis数据库中:</p><pre class="nr ns nt nu gt oc od oe of aw og bi"><span id="67ad" class="mk la in od b gy oh oi l oj ok">const user = await redis.hgetall(`user:${req.body.user}`);</span></pre><p id="5ad9" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">如果用户在场，我们将比较加密的密码:</p><pre class="nr ns nt nu gt oc od oe of aw og bi"><span id="5c7e" class="mk la in od b gy oh oi l oj ok">const validPassword = bcrypt.compare(req.body.password, user.password);</span></pre><p id="940f" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">此时，如果密码匹配，我们可以假设用户通过了身份验证，我们可以发送回一个JWT和一个刷新令牌，我们还将刷新令牌存储在Redis实例中。为了做到这一点，我们使用了一些名为<code class="fe or os ot od b"><strong class="kf io">utils.js</strong></code> <strong class="kf io">的外部文件中的函数。</strong></p><p id="1169" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">客户端负责存储返回的令牌，在需要时使用它们进行授权，并在过期时刷新它们。</p><p id="71df" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们有一个函数生成我们的令牌<code class="fe or os ot od b"><strong class="kf io">generateAccessToken</strong></code>，一个函数生成我们的刷新令牌<code class="fe or os ot od b"><strong class="kf io">generateRefreshToken</strong></code>，一个函数将刷新令牌存储在我们的Redis <code class="fe or os ot od b"><strong class="kf io">addToList</strong></code>中。这个<code class="fe or os ot od b"><strong class="kf io">utils.js</strong></code>文件也将用于保存所有其他的实用函数和引用(像Redis连接，令牌验证和刷新，等等):</p><figure class="nr ns nt nu gt nv"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="f5d6" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">现在，我们可以使用一个工具(比如Postman)来测试签名过程，通过向<code class="fe or os ot od b"><a class="ae kc" href="http://localhost:3000/api/auth/signin" rel="noopener ugc nofollow" target="_blank"><strong class="kf io">http://localhost:3000/api/auth/signin</strong></a></code>发送并传递用户名(<em class="np">me@home.org</em>)和密码(<em class="np">密码</em>)，您应该会得到一个包含用户详细信息的JSON对象以及一个JWT和一个刷新令牌:</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ox"><img src="../Images/87fd38834bedc34b601700c916079c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHWKPFY9DnJGnEEvfHDfWQ.png"/></div></div></figure><p id="f9d9" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">如果一切正常，在Redis数据库中，现在应该可以看到新创建的刷新令牌的新散列条目:</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oy"><img src="../Images/d077debc66405a3a40361f9cf9bb6096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-N92TbpOJ85B0u9MtbliCA.png"/></div></div></figure><p id="f3d6" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">接下来，我们通过编写令牌刷新路由<code class="fe or os ot od b"><strong class="kf io">refresh.js</strong></code>来完成认证过程</p><figure class="nr ns nt nu gt nv"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="0ef1" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">它使用来自<code class="fe or os ot od b"><strong class="kf io">utils.js</strong></code> <strong class="kf io"> </strong>的<em class="np"> tokenRefresh </em>函数，首先验证令牌是否有效并且可以被解码，然后在Redis上检查用户是否获得了刷新令牌(我们之前用<em class="np"> addToList </em>存储的那个)，如果一切都正确，它生成一个新的JWT、一个新的刷新令牌(并再次将其存储在Redis中)，并将所有内容发送回客户端。</p><p id="bec4" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们可以使用我们的工具测试这个端点，发送到<code class="fe or os ot od b"><a class="ae kc" href="http://localhost:3000/api/auth/signin" rel="noopener ugc nofollow" target="_blank"><strong class="kf io">http://localhost:3000/api/auth/r</strong></a><strong class="kf io">efresh</strong></code>并传递刷新令牌作为参数:</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ox"><img src="../Images/539975d688e113683e2360511d9c1725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSYHf4-Mx0TpNwAOmG_bjg.png"/></div></div></figure><p id="40ab" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">既然我们假设的客户机能够登录并刷新其令牌，那么让我们看看如何使用令牌来发出经过身份验证的请求。</p><p id="705c" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">创建一个新的API路由:<code class="fe or os ot od b"><strong class="kf io">api/movies/[[...id]].js</strong></code> <strong class="kf io"> </strong>，它将用于获取电影列表和电影细节:</p><figure class="nr ns nt nu gt nv"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="03dd" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">使用来自我们的<code class="fe or os ot od b"><strong class="kf io">utils.js</strong></code>的<em class="np"> verifyToken </em>函数，我们可以限制只有提供有效令牌的用户才能访问我们的API端点。我们做了几个示例查询，第一个得到电影列表。</p><pre class="nr ns nt nu gt oc od oe of aw og bi"><span id="ca57" class="mk la in od b gy oh oi l oj ok"><strong class="od io">const result = await redis.scan(0, { match: ‘movie:*’ });</strong></span></pre><p id="a671" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">第二个是根据URL请求中的id参数获取一部电影的详细信息:</p><pre class="nr ns nt nu gt oc od oe of aw og bi"><span id="c32b" class="mk la in od b gy oh oi l oj ok"><strong class="od io">const result = await redis.hgetall(id);</strong></span></pre><p id="0cab" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这两个请求都依赖于通过<em class="np"> verifyToken </em>检查的用户状态，但是您可以混合和匹配，例如，列表可以是公共的，细节可以受到保护。因为我们在用户(和令牌)中也存储了一个级别，所以我们可以有更多的授权级别。让我们试着得到一份电影列表:</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oz"><img src="../Images/0e7b9e5fceac03c1e4b82871a2ed05de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CASeN8-RDnlnUIWMlNbwbw.png"/></div></div></figure><p id="626d" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">还有一部电影的细节:</p><figure class="nr ns nt nu gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi pa"><img src="../Images/2e9a779e3dd38d9a200c1730d957f7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hw6UtSyXysLaup5myLe8QA.png"/></div></div></figure><h1 id="ba0b" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">客户视角</h1><p id="37a7" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">正如我们之前所说，我们只关注服务器部分，这是一个API的主要范围，它应该是抽象的，它不是一个网站。客户端请求数据的方式(编程语言、库等等)是客户端开发人员的选择，我们提供一个端点列表，我们的端点期望什么，以及我们的端点返回给客户端什么。所有的数据处理、刷新延迟等等都是客户端策略。</p><h1 id="ae1b" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">下一步是什么</h1><p id="9c66" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">这只是一个受保护API的工作流程的基本示例。从这里开始，它只能得到改进:优化数据在Redis上的存储方式，通过将用户数据存储在另一个Redis实例上来提高登录安全性，检查并验证用户发送的数据，添加更多的端点，以GraphQL格式返回数据，为您的API构建一个客户端，限制每小时的最大调用次数，使用级别来限制访问…扩展和改进是无止境的！</p></div><div class="ab cl pb pc hr pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ig ih ii ij ik"><p id="d29c" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="np">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf io"><em class="np">plain English . io</em></strong></a><em class="np">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io"> <em class="np">免费周报</em> </strong> </a> <em class="np">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf io"><em class="np">Twitter</em></strong></a><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf io"><em class="np">LinkedIn</em></strong></a><em class="np"/><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf io"><em class="np">YouTube</em></strong></a><em class="np"/><a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kf io"><em class="np">不和</em> </strong> </a> <em class="np">。对增长黑客感兴趣？检查</em> <a class="ae kc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io"> <em class="np">电路</em> </strong> </a> <em class="np">。</em></p></div></div>    
</body>
</html>