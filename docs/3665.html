<html>
<head>
<title>Getting Started with GraphQL API with Node.js Backend Support</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持Node.js后端的GraphQL API入门</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-graphql-api-with-node-js-backend-support-aab39c841861?source=collection_archive---------6-----------------------#2022-09-15">https://javascript.plainenglish.io/getting-started-with-graphql-api-with-node-js-backend-support-aab39c841861?source=collection_archive---------6-----------------------#2022-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="43b6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">GraphQL通过减少网络调用的数量，支持高效地从服务器获取数据</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/05b44a44923b8cc244f022b9457e59a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AseXoNeMN-IHiDqJicmupA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lxrcbsv?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Алекс Арцибашев</a> on <a class="ae ks" href="https://unsplash.com/s/photos/graph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3a21" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">GraphQL是脸书开发的API开源查询语言，于2015年开源。与传统的REST API相比，它专注于简化数据查询，并通过向客户提供他们所请求的内容来提高过程的效率。你会问，怎么会？</p><p id="a933" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通常，REST API需要多个端点来获取不同的数据组合，这意味着客户端需要发出不止一个请求来获取所需的数据。为了更好地理解，让我们考虑一个基本的例子，我们将在整篇文章中需要的地方使用它。</p><p id="789c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文假设您已经使用并理解了REST APIs，尽管这不是强制性的，但最好对它有所了解。</p><p id="bc0d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑以下数据:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="4bd0" class="lu lv in lq b gy lw lx l ly lz">const authors = [<br/> { id: 1, name: ‘J. K. Rowling’ },<br/> { id: 2, name: ‘J. R. R. Tolkien’ },<br/> { id: 3, name: ‘Brent Weeks’ }<br/>]</span><span id="4ae0" class="lu lv in lq b gy ma lx l ly lz">const books = [<br/> { id: 1, name: ‘Harry Potter and the Chamber of Secrets’, authorId: 1 },<br/> { id: 2, name: ‘Harry Potter and the Prisoner of Azkaban’, authorId: 1 },<br/> { id: 3, name: ‘Harry Potter and the Goblet of Fire’, authorId: 1 },<br/> { id: 4, name: ‘The Fellowship of the Ring’, authorId: 2 },<br/> { id: 5, name: ‘The Two Towers’, authorId: 2 },<br/> { id: 6, name: ‘The Return of the King’, authorId: 2 },<br/> { id: 7, name: ‘The Way of Shadows’, authorId: 3 },<br/> { id: 8, name: ‘Beyond the Shadows’, authorId: 3 }<br/>]</span><span id="1e29" class="lu lv in lq b gy ma lx l ly lz">module.exports = {<br/> authors,<br/> books<br/>}</span></pre><p id="6395" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设这是服务器/数据库上可用的数据，假设我们应该获取作者以及他们写的书。当使用REST API时，我们希望首先获取所有作者，然后使用作者id获取他们写的所有书籍。</p><p id="b33c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">端点看起来如下所示:</p><p id="a7d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">获取所有作者:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="070e" class="lu lv in lq b gy lw lx l ly lz">domain.com/api/books</span></pre><p id="503f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">按作者获取图书:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="e4c1" class="lu lv in lq b gy lw lx l ly lz">domain.com/api/:authorId/author</span></pre><p id="5406" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，需要为所有作者获取第二个端点，假设有100个不同的作者，这意味着要访问服务器100次才能获得所需的数据。更不用说从服务器返回后应该做的数据重排了。</p><p id="8ec0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">相比之下，<a class="ae ks" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>使用单个端点返回数据，而不是使用多个端点或查询参数。需要返回的数据由客户端发送的查询决定。可以根据需要灵活地编写查询。通过这种方式，网络调用的数量大大减少，从而提高了应用程序的性能。此外，还可以在一次调用中获得数据的目标组合，例如:上面例子中的书籍及其作者。</p><h1 id="a2b8" class="mb lv in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">理解GraphQL查询</h1><p id="bcb2" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">可以使用花括号{}组成查询。这组花括号进一步包含需要返回的字段，这些字段可以具有嵌套字段，以过滤必要的属性或获取与其他相关数据相关联的数据。</p><h2 id="0b26" class="lu lv in bd mc mx my dn mg mz na dp mk lc nb nc mm lg nd ne mo lk nf ng mq nh bi translated">#查询所有图书名称</h2><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="b309" class="lu lv in lq b gy lw lx l ly lz">query {<br/> books{<br/> name<br/> }<br/>}</span></pre><p id="3e4b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上述语句中的关键字“query”是可选的，可以省略。</p><h2 id="d572" class="lu lv in bd mc mx my dn mg mz na dp mk lc nb nc mm lg nd ne mo lk nf ng mq nh bi translated">#查询所有作者及其id</h2><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="9294" class="lu lv in lq b gy lw lx l ly lz">{<br/> authors{<br/> name,<br/> id<br/> }<br/>}</span></pre><p id="d513" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">需要在服务器中定义相应的模式，根据查询计算并返回数据。</p><p id="3f20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们创建数据模型，并使用<a class="ae ks" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>服务器启动GraphQL服务，我们将使用Amplication来完成这项工作。</p><h1 id="46c9" class="mb lv in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">使用Node.js创建GraphQL服务</h1><p id="0ca5" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">如上所述，我们必须创建数据模型，以便在查询时帮助检索数据，为此我们需要一个服务器，我们将使用Node.js服务器。</p><p id="9e1c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一步是安装GraphQL和其他所需的库。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="5822" class="lu lv in lq b gy lw lx l ly lz">npm install express graphql express-graphql</span></pre><p id="bf23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">安装完必要的依赖项后，创建一个指向任何端点的中间件('/graphql ')，处理所有发送的查询。</p><p id="14f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">中间件功能是一个express GraphQL，它接受包含所有数据模型的模式。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="1725" class="lu lv in lq b gy lw lx l ly lz">app.use(‘/graphql’, expressGraphQL({<br/> schema: schema,<br/> graphiql: true<br/>}))<br/>app.listen(3000, () =&gt; {<br/> console.log(‘Server started on port 3000’);<br/>} );</span></pre><p id="23df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">模式包含根查询，根查询进一步包含所有字段。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="9c1b" class="lu lv in lq b gy lw lx l ly lz">const RootQuery = new GraphQLObjectType({<br/> name: ‘RootQueryType’,<br/> fields: () =&gt; ({<br/> books : {<br/> type: new GraphQLList(BookType),<br/> resolve: () =&gt; books<br/> },<br/> authors: {<br/> type: new GraphQLList(AuthorType),<br/> resolve: () =&gt; authors<br/> }<br/> })<br/>})</span><span id="790e" class="lu lv in lq b gy ma lx l ly lz">const schema = new GraphQLSchema({<br/> query: RootQuery<br/>})</span></pre><p id="a0b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“字段”属性是一个返回所有可查询属性的函数。这些属性中的每一个都定义了它的类型和它所解析的内容。这个resolve函数接受一个指向其外部属性的参数，当嵌套在另一个属性中的数据之间存在关联时，可以利用这个参数。</p><p id="fe39" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的代码片段中，我们可以看到像<strong class="kv io"> GraphQLList、</strong>这样的包装器，这些是GraphQL提供的包装器，应该适当地使用它们来告诉GraphQL这是一个AuthorType类型的列表。AuthorType是作者数据结构的自定义类型定义。</p><h1 id="64fc" class="mb lv in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">使用Amplication创建Node.js应用程序</h1><p id="22ca" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">上面我们看到，将GraphQL集成到Node.js应用程序中、创建数据模型、建立关联等等是多么乏味。实现这一点的一个简单方法是使用扩增。</p><p id="9310" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于那些不知道的人来说，<a class="ae ks" href="https://amplication.com/" rel="noopener ugc nofollow" target="_blank">amplification</a>是一个用于创建Node.js应用程序的开源平台。它允许您创建数据模型，以及开箱即用的基于角色的访问控制。此外，您还可以立即下载生成的sour代码或将其推送到Github上的存储库中。它为创建数据模型和建立不同模型之间的关系提供了一个GUI，这使得开发过程直观而高效。</p><p id="082c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">去Amplication，然后<a class="ae ks" href="https://amplication.com/" rel="noopener ugc nofollow" target="_blank">用GitHub创建一个账户</a>。必须有一个GitHub帐户才能在Amplication中创建帐户。创建帐户后，你必须创建一个新项目。</p><p id="1653" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦创建了一个新项目，您就必须创建一个包含源代码、实体、角色等等的新服务。点击右上角的<strong class="kv io">“新服务”</strong>按钮，创建一个新服务，并根据自己的喜好命名服务。</p><p id="72f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">创建服务后，现在是时候构建数据模型并将它们与其他模型相关联了。</p><p id="8c1e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">点击“转到实体”。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/20a997dc6f32598ed3be33b56a083d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kNKbXRGPtUDUFwzE"/></div></div></figure><p id="ad16" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们必须添加所需的不同数据的实体，在我们的例子中，它是作者和书籍。</p><p id="0be2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">点击右上角的“添加实体”,添加实体“作者”和“书籍”</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/fc718b222c78b18263a2e2a67943f34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9BhMqwtgVQPbio7Q"/></div></div></figure><p id="6086" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦创建了一个实体，我们可以观察到像id、created_at、updated_at这样的属性是默认添加的，在我们的例子中最后两个属性是可选的，所以您可以保留它或者删除它。</p><p id="9f35" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们应该添加的唯一其他属性是“名称”。添加字段并相应地配置字段(单行文本，最大长度:1000)。</p><p id="6529" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">添加完实体和必填字段后，下一步是在它们之间创建一个关联。这相当简单，只需打开“图书”实体&gt;添加字段。</p><p id="beb6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将字段名设置为“作者”。</p><p id="5624" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于作者不是原始数据类型，因此将数据类型设置为“与实体的关系”，并将相关实体设置为“作者”。</p><p id="8b52" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关系是每本书可以有一个作者，所以选择“一本书可以与一个作者相关”。为清晰起见，请参考下图。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/1ab2aa1ce49d639e28bd63b36f54a107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gd7XJDo0t1OL10bD"/></div></div></figure><p id="3ca8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，如果你返回到作者实体，你可以看到“一个作者可以与许多本书相关”的关系是自动建立的，这不是很酷吗？</p><p id="e472" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这标志着数据模型的创建，您现在可以通过提交更改来构建应用程序，一旦构建完成。，您可以访问源代码或将其连接到GitHub存储库，并在每次构建后推送更改。</p><p id="6d0b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">源代码也可以下载到您的本地环境中，并根据需要进行微调。</p><p id="15e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">GraphQL不仅提供从服务器查询数据，还允许您修改数据，很像POST或PUT请求，但这是另一个故事的一部分。如果你有兴趣知道如何改变数据，我建议你进一步阅读<a class="ae ks" href="https://www.freecodecamp.org/news/a-beginners-guide-to-graphql-86f849ce1bec/" rel="noopener ugc nofollow" target="_blank">突变</a>。</p><h1 id="78fd" class="mb lv in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">结论</h1><p id="76c0" class="pw-post-body-paragraph kt ku in kv b kw ms jo ky kz mt jr lb lc mu le lf lg mv li lj lk mw lm ln lo ig bi translated">GraphQL能够通过减少网络调用的数量来有效地从服务器获取数据，并支持灵活的查询来准确地给出客户机想要的内容。像Amplication这样的工具有助于利用GUI直观地构建数据模型。这项技术相对较新，许多组织仍然使用不要使用GraphQL服务器，因此这种查询在REST APIs上是不可能的，但是重要的是根据正在解决的问题选择技术，而不是选择技术然后挑问题。</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="8391" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ns">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ns">plain English . io</em></strong></a><em class="ns">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ns">免费周报</em> </strong> </a> <em class="ns">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ns">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ns">LinkedIn</em></strong></a><em class="ns"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ns">YouTube</em></strong></a><em class="ns"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ns">不和</em> </strong> </a> <em class="ns">。对增长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ns">电路</em> </strong> </a> <em class="ns">。</em></p></div></div>    
</body>
</html>