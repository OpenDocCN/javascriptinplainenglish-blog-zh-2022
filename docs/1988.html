<html>
<head>
<title>How to Watch for Nested Changes in Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何观察Vue.js中的嵌套变化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-watch-for-nested-changes-in-vue-js-4a43148206e6?source=collection_archive---------17-----------------------#2022-05-04">https://javascript.plainenglish.io/how-to-watch-for-nested-changes-in-vue-js-4a43148206e6?source=collection_archive---------17-----------------------#2022-05-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9eb745e85d5ddbabebd937987d3e2604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*us5x8DqXTHTK_cD_d0yZSg.png"/></div></div></figure><p id="3c52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Vue.js是一种反应式语言，这意味着当数据发生变化时，我们可以自动在HTML中表现出来。为了帮助我们做到这一点，我们可以使用Vue 中的<a class="ae kt" href="https://fjolt.com/article/vue-how-to-watch-for-changes" rel="noopener ugc nofollow" target="_blank">观察器来观察数据的变化，然后对HTML做一些事情，或者向用户发送一条消息。</a></p><p id="badc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这对于简单的数据集来说很好，但是如果我们开始拥有比一个级别更深的数据，就很难正确地观察它的变化。</p><h1 id="0b73" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">观察Vue中嵌套的数据变化</h1><p id="b3fa" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了理解这个问题，我们需要了解观察器在Vue中是如何工作的。Vue仅观察<strong class="jx io">较浅的变化</strong>例如，在下面，我们观察<code class="fe lx ly lz ma b">count</code>的变化，而<code class="fe lx ly lz ma b">console.log</code>这些变化:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="743c" class="mj kv in ma b gy mk ml l mm mn">&lt;script&gt;<br/>export default {<br/>    data() {<br/>        return {<br/>            count: 1<br/>        }<br/>    },<br/>    watch: {<br/>        count(data) {<br/>            console.log(data);<br/>        }<br/>    }<br/>}<br/>&lt;/script&gt;</span><span id="2739" class="mj kv in ma b gy mo ml l mm mn">&lt;template&gt;<br/>    &lt;h1&gt;{{ count }}&lt;/h1&gt;<br/>    &lt;button @click="++this.count"&gt;<br/>        Click Me<br/>    &lt;/button&gt;<br/>&lt;/template&gt;</span></pre><p id="22ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次用户点击按钮，我们<code class="fe lx ly lz ma b">++this.count</code>，我们的观察者观察<code class="fe lx ly lz ma b">count</code>的任何变化。然后<code class="fe lx ly lz ma b">console</code>记录数据，所以我们可以看到新的计数值。这意味着<strong class="jx io">任何时候点击按钮，计数的值都会显示在控制台日志</strong>上。</p><p id="c933" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，<strong class="jx io">浅层变化</strong>意味着Vue只检查属性值的变化。如果我们的数据深度超过一个级别，Vue将不会检查更新。例如，更新下面的<code class="fe lx ly lz ma b">count.number</code>不会触发我们的<code class="fe lx ly lz ma b">count</code>观察器，因为Vue不会检查任何比<code class="fe lx ly lz ma b">count</code>更深的变化:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="ad62" class="mj kv in ma b gy mk ml l mm mn">data() {<br/>    return {<br/>        count: {<br/>            number: 1,<br/>            type: 'number'<br/>        }<br/>    },<br/>    watch: {<br/>        // This doesn't get triggered when count.number!<br/>        count(data) {<br/>            console.log(data);<br/>        }<br/>    }<br/>}</span></pre><p id="e561" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相反，我们需要特别提到哪个元素在变化。我们可以通过将我们的观察器改为观察<code class="fe lx ly lz ma b">count.number</code>来继续观察上面<code class="fe lx ly lz ma b">count.number</code>中的变化:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="6067" class="mj kv in ma b gy mk ml l mm mn">data() {<br/>    return {<br/>        count: {<br/>            number: 1,<br/>            type: 'number'<br/>        }<br/>    },<br/>    watch: {<br/>        // This gets triggered when count.number changes!<br/>        "count.number" : function(data) {<br/>            console.log(data);<br/>        }<br/>    }<br/>}</span></pre><p id="fecf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用上面的方法，我们可以很容易地检查属性中的属性变化，这样我们就可以触发适当的观察器，但是这可能会很麻烦。如果我们想简单地观察任何<code class="fe lx ly lz ma b">count</code>变化，我们需要使用<strong class="jx io">深度</strong>属性。</p><h1 id="d96d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用深层属性</h1><p id="0d80" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">deep属性可以添加到任何观察器中，它强制Vue观察特定数据属性中的任何变化。这意味着我们必须以稍微不同的方式编写我们的<code class="fe lx ly lz ma b">watcher</code>:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="1f42" class="mj kv in ma b gy mk ml l mm mn">data() {<br/>    return {<br/>        count: {<br/>            number: 1,<br/>            type: 'number'<br/>        }<br/>    },<br/>    watch: {<br/>        count: {<br/>            handler(data) {<br/>                console.log(data);<br/>            },<br/>            deep: true<br/>        }<br/>    }<br/>}</span></pre><p id="8ed9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，每当<code class="fe lx ly lz ma b">count</code>中的任何属性发生变化，<code class="fe lx ly lz ma b">count</code>观察器就会触发。当我们这次<code class="fe lx ly lz ma b">console.log(data)</code>时，整个<code class="fe lx ly lz ma b">count</code>对象将被控制台记录，即<code class="fe lx ly lz ma b">{ number: 1, type: 'number' }</code>。</p><p id="1992" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这比针对属性中的特定属性要容易得多，但是代价很高。由于Vue每次都必须遍历每个属性，对于非常大的对象，这会导致严重的性能问题。因此，只有当你有一个已知的小物体时才使用这个。对于其他情况，坚持以特定属性为目标，比如<code class="fe lx ly lz ma b">count.number</code>。</p><p id="0af5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mp">更多内容尽在</em> <a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mp">说白了. io </em> </strong> </a> <em class="mp">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mp">免费周报</em> </strong> </a> <em class="mp">。关注我们关于</em> <a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mp">推特</em> </strong> </a> <em class="mp">和</em><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mp">LinkedIn</em></strong></a><em class="mp">。加入我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mp">社区不和谐</em> </strong> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>