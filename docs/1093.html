<html>
<head>
<title>Let’s Build a Roguelike with the Random Walk Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用随机漫步算法建立一个Roguelike</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-dungeon-crawler-game-with-javascript-57189bdd9f08?source=collection_archive---------6-----------------------#2022-03-03">https://javascript.plainenglish.io/how-to-build-a-dungeon-crawler-game-with-javascript-57189bdd9f08?source=collection_archive---------6-----------------------#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7731ec937389e514ce91011d739e6bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEBEqpeRiw51QdHvI-WYgQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by <a class="ae kc" href="https://pixabay.com/users/skitterphoto-324082/" rel="noopener ugc nofollow" target="_blank">Skitterphoto</a> on <a class="ae kc" href="https://pixabay.com" rel="noopener ugc nofollow" target="_blank">Pixabay</a>.</figcaption></figure><p id="c09f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">学习编程最令人愉快的方式之一是构建游戏。在本教程中，我们将使用JavaScript和CSS构建一个地牢爬虫。这个游戏是一个类似Roguelike的游戏，关卡由算法生成，地图由瓷砖组成，玩家只有一次生命。</p><p id="1464" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">游戏文件可以在<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-1" rel="noopener ugc nofollow" target="_blank"> Github </a>上的<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-1/tree/main/games/game-1-drunkards-walk" rel="noopener ugc nofollow" target="_blank">目录</a>中找到，你也可以下载<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-1/archive/refs/heads/main.zip" rel="noopener ugc nofollow" target="_blank"> zip </a>并尝试<a class="ae kc" href="https://roguelike-tutorials.netlify.app/games/game-1-drunkards-walk/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>。下面是一个完整游戏的快速截图。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/92c9ac4322b8fdff732e5ab9673d498e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JT_ohqDisNN0bplt_8uDVQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A screenshot of the roguelike.</figcaption></figure><p id="4fce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能猜到灰色的瓷砖是墙。下面是其他图块所代表的内容。</p><ul class=""><li id="57ec" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la lm ln lo lp bi translated">你的玩家是蓝瓦。</li><li id="8a16" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">红色瓷砖是敌人。</li><li id="4d2c" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">黄色瓷砖是你可以拿起的武器。</li><li id="6c3a" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">绿色瓷砖是恢复健康的药剂。</li></ul><p id="4a32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像早期的Roguelikes一样，这在计算机上工作，需要键盘输入。但是，作为教程的后续步骤，您可以添加替代控件，如滑动、设备方向检测或软键。另外，<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-add-scrolling-to-a-javascript-roguelike-c9f835d10537">这个教程</a>可以帮你添加滚动。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="452c" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">游戏逻辑</h1><p id="5d8a" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">本教程中的代码是我用这个优秀的<a class="ae kc" href="https://codepen.io/ni-kun/pen/jWKWom" rel="noopener ugc nofollow" target="_blank"> CodePen </a>由<a class="ae kc" href="https://codepen.io/ni-kun" rel="noopener ugc nofollow" target="_blank"> Nicola </a>制作的叉子。虽然代码库有很大的不同，但它仍然拥有Nicola的核心游戏逻辑，包括以下内容:</p><h2 id="6f0a" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">电平生成</h2><ul class=""><li id="f602" class="lh li iq kf b kg na kk nb ko nr ks ns kw nt la lm ln lo lp bi translated">墙壁，以及敌人和物品的位置，都是程序生成的。</li><li id="d503" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">该算法生成每个敌人的生命值及其造成的伤害。</li></ul><h2 id="c168" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">控制</h2><ul class=""><li id="71de" class="lh li iq kf b kg na kk nb ko nr ks ns kw nt la lm ln lo lp bi translated">你用光标键移动你的播放器。</li><li id="224e" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">“切换阴影”按钮可以用来显示整个地图，或者将可见区域限制在玩家周围的7x7方块内。</li></ul><h2 id="8c08" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">物品和敌人</h2><ul class=""><li id="3e73" class="lh li iq kf b kg na kk nb ko nr ks ns kw nt la lm ln lo lp bi translated">你的玩家可以选择不同的武器，每种武器都造成一定的伤害。</li><li id="8c52" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">你不知道什么是武器，直到你拿起它。</li><li id="f8a0" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">可以拿药水恢复健康。</li><li id="03e5" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">当你拿起一个武器或药剂时，另一个会出现在另一个位置。</li><li id="c571" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">你可以通过击败敌人来积累经验和升级。</li></ul><h2 id="a340" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">结束游戏</h2><ul class=""><li id="cf2e" class="lh li iq kf b kg na kk nb ko nr ks ns kw nt la lm ln lo lp bi translated">如果你的健康达到零，你就输了。</li><li id="ef32" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">你通过击败地牢中的所有敌人来击败地牢。</li><li id="c041" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">击败地下城或输掉游戏后会创建一个新的地下城。</li></ul></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="a824" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">技术</h1><p id="3523" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在整个教程中，我们将使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" rel="noopener ugc nofollow" target="_blank"> DOM API </a>来设置界面，使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> Canvas API </a>来渲染地图并保持更新。我们还将为玩家、游戏和敌人使用JavaScript类。最后，我们将使用2D数组来存储地图数据和可见区域，以及用于按钮、字体和页面布局样式的CSS。</p><p id="fe3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是这些步骤的简要概述。</p><ol class=""><li id="2376" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la nu ln lo lp bi translated"><a class="ae kc" href="#0202" rel="noopener ugc nofollow">启动您的文件</a></li><li id="5ef7" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#b3c9" rel="noopener ugc nofollow">创建类别</a></li><li id="e13d" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#e2fd" rel="noopener ugc nofollow">添加游戏常数</a></li><li id="bc4b" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#de64" rel="noopener ugc nofollow">生成游戏标记</a></li><li id="a02b" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#cab7" rel="noopener ugc nofollow">运行您的第一个测试</a></li><li id="0491" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#c174" rel="noopener ugc nofollow">开始游戏</a></li><li id="9269" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#7501" rel="noopener ugc nofollow">生成地图</a></li><li id="aa95" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#83ef" rel="noopener ugc nofollow">渲染地图</a></li><li id="69ef" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#9823" rel="noopener ugc nofollow">生成游戏元素</a></li><li id="a71e" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#6aa1" rel="noopener ugc nofollow">玩家动作</a></li><li id="37a9" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#ce14" rel="noopener ugc nofollow">更新游戏统计数据</a></li><li id="5029" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#4856" rel="noopener ugc nofollow">敌人战斗</a></li><li id="03f3" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#57fd" rel="noopener ugc nofollow">处理战败的敌人</a></li><li id="fa16" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#7f1b" rel="noopener ugc nofollow">敌方碰撞检测</a></li><li id="edf0" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#56d7" rel="noopener ugc nofollow">收集药剂和武器</a></li><li id="48fe" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated"><a class="ae kc" href="#23e7" rel="noopener ugc nofollow">影子逻辑</a></li></ol><p id="b29d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始吧。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="0202" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">1.启动您的文件</h1><ul class=""><li id="2cc9" class="lh li iq kf b kg na kk nb ko nr ks ns kw nt la lm ln lo lp bi translated">首先创建您的<code class="fe nv nw nx ny b">style.css</code>和一个<code class="fe nv nw nx ny b">script.js</code>文件。</li><li id="06ac" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">创建一个<code class="fe nv nw nx ny b">index.html</code>文件来保存游戏结构，并拉入上面的文件。它应该有一个空的<code class="fe nv nw nx ny b">&lt;div&gt;</code>元素和一个<code class="fe nv nw nx ny b">container</code>的<code class="fe nv nw nx ny b">id</code>。</li></ul><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The HTML shell for your game.</figcaption></figure><p id="9d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的JavaScript中，如果您希望将代码与教程之后添加的非游戏代码隔离开，可以随意地将代码包装在一个立即调用的函数表达式(IIFE)中。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="c688" class="of md iq ny b be og oh l oi oj">(function() {<br/><br/>   // you can add your code here.<br/><br/>})();</span></pre><p id="8fd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你的<code class="fe nv nw nx ny b">script.js</code>文件被载入浏览器后，上面的生活将立即开始。</p><p id="3377" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了我们的结构，现在让我们用将要使用的类和常量填充JavaScript文件。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="b3c9" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">2.创建类</h1><p id="f011" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">首先，我们将创建三个JavaScript类:一个用于敌人，一个用于玩家，一个用于游戏。</p><p id="8e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是玩家类，包括等级、生命值、经验值、武器和坐标。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The player class.</figcaption></figure><p id="62ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是敌人职业，有生命值、伤害和坐标属性。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The enemy class.</figcaption></figure><p id="2dcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是带有两个2D数组的整体游戏类:<code class="fe nv nw nx ny b">map</code>和<code class="fe nv nw nx ny b">shadow</code>。还有一个用于阴影切换的布尔属性，一个敌人数组，以及用于画布API的<code class="fe nv nw nx ny b">canvas</code>和<code class="fe nv nw nx ny b">context</code>对象。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The game class.</figcaption></figure><p id="fe82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为游戏类创建一个快速方法，允许它在玩家击败地牢或“游戏结束”发生后重置。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The game’s reset method.</figcaption></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="e2fd" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">3.添加游戏常数</h1><p id="991b" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们添加游戏引擎将使用的全局常量。</p><h2 id="2738" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">经验值和等级</h2><p id="ec97" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">当你打败敌人时，你会累积经验点数(XP)。每次你赚到100 XP，你就会升级——所以让我们为此创建一个常数。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="37a7" class="of md iq ny b be og oh l oi oj">const POINTS_PER_LEVEL = 100;</span></pre><h2 id="5c94" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">地图尺寸</h2><p id="0510" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们编写两个快速常量来设置地图的尺寸。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="9b14" class="of md iq ny b be og oh l oi oj">const COLS = 80;<br/>const ROWS = 60;</span></pre><p id="7759" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们用一个叫做<code class="fe nv nw nx ny b">TILE_DIM</code>的常量来指定游戏区块的宽度和高度。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="a222" class="of md iq ny b be og oh l oi oj">const TILE_DIM = 10;</span></pre><h2 id="c4ee" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">瓷砖代码和颜色</h2><p id="4311" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">地图2D数组将存储整数地图代码。为了使我们的代码可读，让我们为每个地图元素代码添加一个常数。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="ef67" class="of md iq ny b be og oh l oi oj">const WALL_CODE = 0;<br/>const FLOOR_CODE = 1;<br/>const PLAYER_CODE = 2;<br/>const ENEMY_CODE = 3;<br/>const POTION_CODE = 4;<br/>const WEAPON_CODE = 5;</span></pre><p id="b7a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了以正确的颜色呈现一个图块，这些图块代码将被用于索引到一个<code class="fe nv nw nx ny b">TILE_COLORS</code>数组中，我们可以将它写成另一个常量。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The tile colors.</figcaption></figure><p id="7099" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于阴影2D数组，让我们为可见的瓷砖和黑暗中的瓷砖创建代码。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="01ab" class="of md iq ny b be og oh l oi oj">SHADOW_CODE = 0;<br/>VISIBLE_CODE = 1;</span></pre><h2 id="8bc4" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">游戏元素的数量</h2><p id="4779" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们设置一些常量来决定游戏开始时有多少敌人、药剂和武器会被添加到地图上。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="e2cf" class="of md iq ny b be og oh l oi oj">const TOTAL_ENEMIES = 10;<br/>const STARTING_POTIONS_AMOUNT = 4;<br/>const STARTING_WEAPONS_AMOUNT = 3;</span></pre><h2 id="7a07" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">敌人和药剂助手</h2><p id="9a97" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们添加一些随机选择敌人属性的辅助数组。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="1d5d" class="of md iq ny b be og oh l oi oj">// possible health that enemies can have<br/>const ENEMIES_HEALTH = [30, 30, 30, 30, 40, 40, 60, 80];<br/><br/>// possible damage that enemies can inflict<br/>const ENEMIES_DAMAGE = [30, 30, 30, 30, 40, 40, 60, 80];</span></pre><p id="5f8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，新药剂恢复的生命值将从这个数组中选择。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="6320" class="of md iq ny b be og oh l oi oj">const POTIONS = [10, 20, 30, 40, 50];</span></pre><h2 id="5be6" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">武器</h2><p id="a542" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在让我们添加一个保存武器的常数。每个武器都有标签和伤害等级。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The constant holding the weapons.</figcaption></figure><h2 id="1254" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated"><strong class="ak">能见度</strong></h2><p id="54d1" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">如果阴影被打开，玩家周围应该有一个正方形，这个正方形应该总是可见的。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/2075d25aae991d08360058c2e55dd2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*wTJTruH1sSvvOaMGAkZieQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The square of visibility.</figcaption></figure><p id="6f8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面显示的正方形是7x7瓷砖。让我们设置一个名为<code class="fe nv nw nx ny b">VISIBILITY </code>的常量，它指定每个方向上应该有多少个图块可见。在这种情况下，让我们用3来实现7x7的平方。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="7d41" class="nf md iq ny b gy oo op l oq oj">const VISIBILITY = 3;</span></pre><p id="d54e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">游戏常数到此为止。现在让我们把注意力转向构建游戏标记和样式。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="de64" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">4.生成游戏标记</h1><p id="e82f" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">这个游戏发生在一个包含几个元素的页面上:</p><ul class=""><li id="3481" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la lm ln lo lp bi translated">显示游戏统计数据的平视显示器(HUD)</li><li id="03a0" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">玩家四处移动的关卡地图</li><li id="3f0f" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">打开和关闭阴影的按钮</li></ul><p id="166c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从调用我们的容器的函数开始，这是我们的<code class="fe nv nw nx ny b">index.html</code>页面中唯一的元素。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="f626" class="nf md iq ny b gy oo op l oq oj">function createDOM() {</span><span id="b6a6" class="nf md iq ny b gy or op l oq oj">   let container = document.getElementById('container');</span><span id="c96b" class="nf md iq ny b gy or op l oq oj">}</span></pre><p id="46f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们为平视显示器(HUD)创建一个元素。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="2328" class="nf md iq ny b gy oo op l oq oj">function createDOM() {</span><span id="e91b" class="nf md iq ny b gy or op l oq oj">    let container = document.getElementById('container');</span><span id="7ec0" class="nf md iq ny b gy or op l oq oj"><strong class="ny ir">    let hud = document.createElement('ul');</strong></span><span id="a9ca" class="nf md iq ny b gy or op l oq oj"><strong class="ny ir">    hud.id = 'hud';</strong><br/>}</span></pre><h2 id="3045" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">填充HUD</h2><p id="5438" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">HUD将会有一些标签-数值对来显示玩家的健康，剩余敌人的数量，以及其他的统计数据。因此，在进入<code class="fe nv nw nx ny b">createDOM</code>之前，让我们编写一个函数来创建一个标签-值对，并将其添加到<code class="fe nv nw nx ny b">hud</code>元素中。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A function for adding a label-value pair to the HUD.</figcaption></figure><p id="aeb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们回到<code class="fe nv nw nx ny b">createDOM</code>，写一个我们想要显示的统计数据列表。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="e18a" class="nf md iq ny b gy oo op l oq oj">let labels = ['XP', <br/>              'Level',<br/>              'Health', <br/>              'Weapon', <br/>              'Damage',<br/>              'Enemies'];</span></pre><p id="dd35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以对它们中的每一个调用<code class="fe nv nw nx ny b">addStat</code>。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="68a7" class="nf md iq ny b gy oo op l oq oj">for (var label of labels) {<br/>      hud = addStat(label, hud);<br/>}</span></pre><p id="eaa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码会将每个stat的标签-值对添加到<code class="fe nv nw nx ny b">hud</code>元素中。</p><p id="39e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们将<code class="fe nv nw nx ny b">hud</code>元素添加到主游戏容器中。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="eca6" class="nf md iq ny b gy oo op l oq oj">container.appendChild(hud);</span></pre><h2 id="0fcd" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">添加游戏地图</h2><p id="e3fc" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在我们有了HUD逻辑，让我们添加游戏地图本身，这将是一个<code class="fe nv nw nx ny b">&lt;canvas&gt;</code>元素。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="3867" class="nf md iq ny b gy oo op l oq oj">let canvas = document.createElement('canvas');</span><span id="fdd6" class="nf md iq ny b gy or op l oq oj">canvas.id = 'grid';</span></pre><p id="9de9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe nv nw nx ny b">COLS</code>常数决定了地图的宽度，而<code class="fe nv nw nx ny b">ROWS</code>决定了地图的高度，所以我们可以用它们来创建画布尺寸的常数。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="c213" class="nf md iq ny b gy oo op l oq oj">const tileDim = 10;<br/>    <br/>canvas.height = ROWS * TILE_DIM;<br/>canvas.width = COLS * TILE_DIM;</span></pre><p id="e0f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们将画布添加到容器中。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="87bf" class="nf md iq ny b gy oo op l oq oj">container.appendChild(canvas);</span></pre><p id="1125" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们同样添加切换按钮。请注意，有一个按钮</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="489d" class="nf md iq ny b gy oo op l oq oj">let btn = document.createElement('button');<br/>btn.className = 'toggle';<br/>btn.textContent = 'Toggle Shadow';<br/>container.appendChild(btn);</span></pre><p id="f6de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该按钮需要切换阴影的打开和关闭，所以现在，让我们启动该功能并向按钮添加一个事件侦听器。</p><p id="7c37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先在<code class="fe nv nw nx ny b">createDOM</code>之外加上这个功能。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="bc3d" class="nf md iq ny b gy oo op l oq oj">function toggleShadow() {<br/>    game.isShadowToggled = !game.isShadowToggled;<br/>}</span></pre><p id="0b45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，返回到<code class="fe nv nw nx ny b">createDOM</code>并将监听器添加到按钮。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="27b1" class="nf md iq ny b gy oo op l oq oj">btn.addEventListener('click',toggleShadow);</span></pre><p id="fc35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是创建游戏标记的整个功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The function for creating the game markup.</figcaption></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="cab7" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">5.运行您的第一个测试</h1><p id="8018" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在这一点上，它可以是一个鼓舞士气，看看你到目前为止。所以让我们声明我们需要的两个全局变量，然后编写一个<code class="fe nv nw nx ny b">init</code>函数。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="ea4d" class="of md iq ny b be og oh l oi oj">var game = null;<br/>var player = null;<br/><br/>function init() {<br/>    createDOM();<br/>}<br/><br/>init();</span></pre><p id="3ea9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在浏览器中打开您的<code class="fe nv nw nx ny b">index.html</code>文件。在你的页面顶部，你应该有一个统计列表。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/dac0100b581f9439df1cce8ad6698dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*KflIC3uTtsdrTaHIZxgYcw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The list of stats without styling.</figcaption></figure><p id="4132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在页面的底部，你应该有你的切换按钮。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/9fbbd79dfd14db71a919323eb68dba8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*uMG7j_A7N_WE4UOo4O9VXQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The button without styling.</figcaption></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="3433" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">添加CSS</h1><p id="3b07" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">到目前为止，这个页面看起来像一个1995年的基本网站，这是因为我们还没有添加CSS。让我们现在做那件事。</p><p id="ccfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是整个页面的一般样式。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是HUD的样式。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="818d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，下面是按钮的样式。虽然它们驻留在我们的<code class="fe nv nw nx ny b">styles.css</code>文件中，但是它们是从引导库借来的。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The button colors, by Bootstrap.</figcaption></figure><p id="4408" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们刷新页面。您的统计面板应该如下图所示。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ou"><img src="../Images/a3fa68122c5c8185e5cf66ac707e6757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7cMaWHj6X3rXvrAJeHU3TQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The styled stats panel</figcaption></figure><p id="691a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在页面的底部，你的按钮应该是这样的:</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/c65e6b9dcdca937cda0e343593f48b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*zbCnFlSj43nwRddl6ys5Tg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The styled button panel</figcaption></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="c174" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">6.开始游戏</h1><p id="80a2" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在我们已经测试了我们的标记和样式，让我们来编写基本的游戏开始逻辑。</p><p id="1c46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回我们的<code class="fe nv nw nx ny b">init()</code>函数来初始化<code class="fe nv nw nx ny b">game</code>对象。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="eee7" class="of md iq ny b be og oh l oi oj">function init() {<br/>   createDOM();<br/>   game = new Game();<br/>}</span></pre><p id="5c95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，设置它的<code class="fe nv nw nx ny b">canvas</code>和<code class="fe nv nw nx ny b">context</code>属性，这样我们可以更容易地跟踪它。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="9a7a" class="of md iq ny b be og oh l oi oj">function init() {<br/><br/>   createDOM();<br/>   game = new Game();<br/>   <br/>   // new<br/>   game.canvas = document.getElementById("grid");<br/>   game.context = game.canvas.getContext("2d");<br/>}</span></pre><p id="1e73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置好<code class="fe nv nw nx ny b">game</code>对象后，让我们编写一个新的<code class="fe nv nw nx ny b">startGame</code>函数，它将在游戏开始时处理地图及其元素的生成。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="fa55" class="of md iq ny b be og oh l oi oj">function startGame() {<br/><br/>}</span></pre><p id="0243" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然已经启动了<code class="fe nv nw nx ny b">startGame</code>功能，让我们将其添加到<code class="fe nv nw nx ny b">init()</code>功能中。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="c6ee" class="of md iq ny b be og oh l oi oj">function init() {<br/>   createDOM();<br/>   game = new Game();<br/>   game.canvas = document.getElementById("grid");<br/>   game.context = game.canvas.getContext("2d");<br/><br/>   // new<br/>   startGame();<br/>}</span></pre><p id="2d98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然<code class="fe nv nw nx ny b">init</code>只会被调用一次，但<code class="fe nv nw nx ny b">startGame</code>会被放置在另一个位置，以便在游戏结束后再次调用。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="7501" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">7.生成地图</h1><p id="539f" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">制作地图的目标是获得存储在我们的2D阵列中的墙砖和地砖的排列，一旦渲染到<code class="fe nv nw nx ny b">&lt;canvas&gt;</code>元素上，就可以转换成可穿越的游戏关卡。</p><h2 id="976c" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">启动功能</h2><p id="950a" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我们先来启动一个名为<code class="fe nv nw nx ny b">generateMap</code>的函数，这个函数最终会添加到<code class="fe nv nw nx ny b">startGame</code>中。</p><p id="27b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数从一个嵌套循环开始，它遍历所有的瓷砖位置，在每个位置创建一个墙砖。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="64dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不能转化为一个很大的级别，所以我们需要添加逻辑来“挖掘”数组，用地砖替换一些墙砖。</p><h2 id="ebe8" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">该算法</h2><p id="c2a3" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">为了实现这一点，我们将编写一个<em class="lb">随机行走</em>算法的实现，其中创建每个地砖的点，或“挖掘者”，从中心开始，沿着向外的路径蹒跚前行。下面是一个挖掘机旅程的快速动画。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/b0b2b27b7e10d2a77b9804a756a25af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/1*a6m_ZqRlGrgOViUlJ357Zw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The random walk algorithm in action.</figcaption></figure><p id="f378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在地图的外部边缘附近，有挖掘者不能创造地砖的禁止区域。当它到达这些地方时，它会更加蹒跚，随机尝试其他方向，直到它要么找到一个合法的挖掘点，要么放弃——在这一点上，它要么回到中心，要么简单地退出，如果已经完成了足够的挖掘。</p><p id="6de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种随机绊倒的结果是一个给定的地牢通常会像一个石灰岩洞。也就是说，如果房间和走廊是你想要的，有其他算法你可以在以后交换。</p><p id="730a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是算法的具体步骤。</p><ol class=""><li id="9308" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la nu ln lo lp bi translated">从地图的中心开始。</li><li id="75ba" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated">开始一次挖掘尝试。随机选择x轴或y轴继续前进。</li><li id="150f" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated">随机选择正向或负向移动。</li><li id="3d4b" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated">如果太靠近顶部、左侧、右侧或底部边缘，会导致扣分。搜索离边缘更远的另一个图块位置。每一次失败的搜索都会增加惩罚次数。</li><li id="6427" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated">如果在达到最大惩罚后我们不能离开边缘，检查我们是否需要添加更多的地砖。如果是，返回中心；否则，完成。</li><li id="9a86" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated">如果我们离边缘足够远，而这个新位置又没有地板，就在这里加一块地砖。增加使用的瓷砖数量，并将惩罚重置为零。</li><li id="aef9" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la nu ln lo lp bi translated">如果我们已经做到了这一步，重复步骤2-6，除非我们已经达到了最大尝试次数。</li></ol><p id="73e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们看看如何用JavaScript实现这个算法。</p><h2 id="7589" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">将挖掘机放在中间</h2><p id="2a91" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">一开始，我们从游戏板的中心开始挖掘。所以在我们的<code class="fe nv nw nx ny b">generateMap</code>函数中，让我们用一个名为<code class="fe nv nw nx ny b">pos</code>的对象来初始化我们的挖掘机的位置，这个对象的<code class="fe nv nw nx ny b">x</code>和<code class="fe nv nw nx ny b">y</code>属性最初被设置为地图的中心。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="1807" class="of md iq ny b be og oh l oi oj">let pos = { <br/>      x:COLS/2,<br/>      y:ROWS/2<br/>};</span></pre><h2 id="8706" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">设置常数</h2><p id="c14b" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在，让我们设定一次挖掘的最大尝试次数。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="4ae0" class="nf md iq ny b gy oo op l oq oj">const ATTEMPTS = 30000;</span></pre><p id="d0da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们设置游戏板需要的最小地砖数量。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="5aa5" class="nf md iq ny b gy oo op l oq oj">const MINIMUM_TILE_COUNT = 1000;</span></pre><p id="4280" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，让我们设置挖掘尝试失败之前的最大外部限制惩罚数。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="7e03" class="nf md iq ny b gy oo op l oq oj">const MAX_PENALTIES_COUNT = 1000;</span></pre><p id="029a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们来设定外限。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="3f6b" class="nf md iq ny b gy oo op l oq oj">const OUTER_LIMIT = 3;</span></pre><p id="d1e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">外部限制为3时，在每个地砖和地图边缘之间应该至少有三个墙砖。</p><h2 id="fe90" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">准备循环</h2><p id="b107" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们写一个<code class="fe nv nw nx ny b">randomDirection</code>助手来设置挖掘者的方向。我们将使用这两次——一次是正常移动，另一次是当我们接近外部极限时，必须尝试另一个位置。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="2dba" class="nf md iq ny b gy oo op l oq oj">const randomDirection = () =&gt; Math.random() &lt;= 0.5 ? -1 : 1;</span></pre><p id="810a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们使用一个<code class="fe nv nw nx ny b">Math.random()</code>和一个三元运算符来选择正方向或负方向。</p><p id="3382" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，让我们将使用的瓦片数和惩罚数都初始化为零。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="b8e2" class="nf md iq ny b gy oo op l oq oj">let tiles = 0, penalties = 0;</span></pre><h2 id="ca95" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">天真的循环</h2><p id="26e5" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们首先编写不检查外部限制的dig循环。</p><p id="4575" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用一个<code class="fe nv nw nx ny b">for</code>循环继续挖掘，直到我们用尽所有的尝试。在循环开始时，我们选择是在<code class="fe nv nw nx ny b">x</code>轴还是<code class="fe nv nw nx ny b">y</code>轴上挖掘，以及是正向还是负向挖掘。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="48b8" class="of md iq ny b be og oh l oi oj">for (var i = 0; i &lt; ATTEMPTS; i++) {<br/><br/>   let axis = Math.random() &lt;= 0.5 ? 'x' : 'y';<br/><br/>   pos[axis] += randomDirection();<br/><br/>}</span></pre><p id="9cac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了方便起见，让我们从<code class="fe nv nw nx ny b">pos</code>中提取我们的<code class="fe nv nw nx ny b">x</code>和<code class="fe nv nw nx ny b">y</code>属性。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="7883" class="of md iq ny b be og oh l oi oj">for (var i = 0; i &lt; ATTEMPTS; i++) {<br/><br/>   let axis = Math.random() &lt;= 0.5 ? 'x' : 'y';<br/><br/>   pos[axis] += randomDirection();<br/><br/>   // new <br/>   let {x, y} = pos;<br/>}</span></pre><p id="c43e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们在新位置添加一个地板砖(如果不存在的话)。添加一个意味着我们使用我们的一个瓷砖。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="a1b7" class="of md iq ny b be og oh l oi oj">let {x, y} = pos;<br/><br/>// new<br/><br/>if (game.map[y][x] != FLOOR_CODE) {<br/>      game.map[y][x] = FLOOR_CODE;<br/><br/>      tiles++;<br/>}</span></pre><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="0f9a" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">添加外部限制检查</h2><p id="0fde" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">如果不检查我们在当前轴上相对于地图每条边的位置，我们可以很容易地越过地图——并且超出阵列。因此，让我们添加外部限制检查。</p><p id="9e0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们回到计算轴的地方。基于我们使用的轴，我们可以得到行或列的总数。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="1288" class="of md iq ny b be og oh l oi oj">let axis = Math.random() &lt;= 0.5 ? 'x' : 'y';<br/><br/>// new<br/>let numCells = axis == 'x' ? COLS : ROWS;<br/><br/>pos[axis] += randomDirection();</span></pre><p id="c31c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们开始一个<code class="fe nv nw nx ny b">while</code>循环，检查我们是否在地图的边缘和外部界限之间。</p><ul class=""><li id="3076" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la lm ln lo lp bi translated">如果我们在x轴上挖掘，我们检查右边和左边。</li><li id="4bfd" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">如果我们在y轴上挖掘，我们检查顶部和底部边缘。</li></ul><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="fc01" class="of md iq ny b be og oh l oi oj">while (pos[axis] &lt; OUTER_LIMIT || <br/>       pos[axis] &gt;= numCells - OUTER_LIMIT) {<br/><br/>    // search for a new tile here. <br/>    // if we cannot find one, quit or start from the center.<br/>}</span></pre><p id="8c43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顶部和左侧边缘将是<code class="fe nv nw nx ny b">0</code>，所以我们用第一个条件来处理它:</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="0625" class="of md iq ny b be og oh l oi oj">pos[axis] &lt; OUTER_LIMIT</span></pre><p id="a599" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">底部和右侧边缘将等于<code class="fe nv nw nx ny b">numCells</code>，我们将其设置为等于<code class="fe nv nw nx ny b">ROWS</code>(底部边缘)或<code class="fe nv nw nx ny b">COLS</code>(右侧边缘)。我们用第二个条件来处理:</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="866f" class="of md iq ny b be og oh l oi oj">pos[axis] &gt;= numCells - OUTER_LIMIT</span></pre><p id="754e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们实际上在一个被禁止的方块上，我们试图找到另一个方块并增加惩罚。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="667b" class="of md iq ny b be og oh l oi oj">while (pos[axis] &lt; OUTER_LIMIT || <br/>       pos[axis] &gt;= numCells - OUTER_LIMIT) {<br/><br/>     pos[axis] += randomDirection();<br/>     penalties++;<br/><br/>}</span></pre><p id="770b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们达到了惩罚极限，那么就不要再寻找安全的地砖了——让我们检查一下我们是否使用了最少数量的地砖。如果是这样，我们就可以完成地图和<code class="fe nv nw nx ny b">return</code>的构建了。如果没有，我们回到中心，开始挖一个新的隧道。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="dc74" class="of md iq ny b be og oh l oi oj">penalties++;<br/><br/>// new<br/>if (penalties &gt; MAX_PENALTIES_COUNT) {<br/>     if (tiles &gt;= MINIMUM_TILES_AMOUNT) {<br/>           return;<br/>     }<br/><br/>      pos.x = COLS / 2;<br/>      pos.y = ROWS / 2;<br/>}</span></pre><p id="593b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是整个<code class="fe nv nw nx ny b">while</code>循环的样子。第1行和第2行显示了它在函数中的位置。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The outer limits check.</figcaption></figure><p id="cff4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们添加了这个外部限制检查，我们必须意识到惩罚的数量——所以我们需要在添加一个图块后重置它们。</p><p id="53de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以事不宜迟，让我们回到函数的末尾，将惩罚数重置为零。这样，每一次新的尝试都从零惩罚开始。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="94a5" class="of md iq ny b be og oh l oi oj">if (game.map[y][x] != FLOOR_CODE) {<br/><br/>    game.map[y][x] = FLOOR_CODE;<br/>    tiles++;<br/>}<br/>penalties = 0;</span></pre><p id="a09f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是整个<code class="fe nv nw nx ny b">generateMap</code>函数，其中<code class="fe nv nw nx ny b">numCells</code>被初始化，<code class="fe nv nw nx ny b">while</code>循环，<code class="fe nv nw nx ny b">penalties</code>被复位。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2209" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">终于来了！我们的地图生成算法现在已经完成。现在让我们将它添加到我们的<code class="fe nv nw nx ny b">startGame()</code>函数中。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="abbd" class="nf md iq ny b gy oo op l oq oj">function startGame() {<br/>   generateMap();<br/>}</span></pre></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="83ef" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">8.渲染地图</h1><p id="fd4e" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在我们可以生成地图了，让我们继续编写渲染它的逻辑。我们将从编写一个在地图上绘制一个图块的函数开始。</p><h2 id="fb0d" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">绘制一个图块</h2><p id="3633" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated"><code class="fe nv nw nx ny b">drawObject</code>函数使用Canvas API在地图上绘制一个正方形。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8936" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里最复杂的一行是对<code class="fe nv nw nx ny b">rect</code>方法的调用。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="fa14" class="nf md iq ny b gy oo op l oq oj">game.context.rect(x * TILE_DIM, y * TILE_DIM, TILE_DIM, TILE_DIM);</span></pre><p id="de23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前两个参数是我们正在绘制的方块左上角的<code class="fe nv nw nx ny b">x</code>和<code class="fe nv nw nx ny b">y</code>坐标。接下来的两个参数都是<code class="fe nv nw nx ny b">TILE_DIM</code>，指定了平铺的高度和宽度。</p><h2 id="f442" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">画所有的瓷砖</h2><p id="c9a0" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们从为地图上的每个区块编写一个函数调用<code class="fe nv nw nx ny b">drawObject</code>开始。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="515e" class="nf md iq ny b gy oo op l oq oj">function drawMap(startX, startY, endX, endY) {<br/>}</span></pre><p id="f7ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们定义一个数组，为每种瓷砖类型提供一种颜色。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c313" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，数组中每种颜色的索引对应于图块代码。例如，地板颜色的索引<code class="fe nv nw nx ny b">1</code>对应于<code class="fe nv nw nx ny b">FLOOR_CODE</code>值。除了地板和墙壁，我们还没有使用瓷砖代码，但我们很快就会这样做。</p><p id="b803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们编写一个嵌套循环，允许我们遍历地图上的每一个图块并调用<code class="fe nv nw nx ny b">drawObject</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="9979" class="of md iq ny b be og oh l oi oj">for (var row = startY; row &lt; endY; row++) {<br/><br/>    for (var col = startX; col &lt; endX; col++) {<br/><br/>         let c_idx = game.map[row][col];<br/><br/>         let color = colors[c_idx];<br/><br/>         // new<br/>         drawObject(col, row, color);<br/>    }<br/>}</span></pre><p id="bc93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nv nw nx ny b">drawObject</code>调用中，<code class="fe nv nw nx ny b">col</code>和<code class="fe nv nw nx ny b">row</code>参数分别对应于给定图块的<code class="fe nv nw nx ny b">x</code>和<code class="fe nv nw nx ny b">y</code>坐标。</p><p id="1b00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是整个<code class="fe nv nw nx ny b">drawMap</code>函数的样子。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The map drawing function.</figcaption></figure><p id="aabb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们扩展我们的<code class="fe nv nw nx ny b">startGame</code>函数，并为其添加<code class="fe nv nw nx ny b">drawMap</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="68c7" class="of md iq ny b be og oh l oi oj">function startGame() {<br/><br/>  generateMap();<br/><br/>  setTimeout(gameSetUp, 1000);<br/><br/>  function gameSetUp() {<br/>      drawMap(0, 0, COLS, ROWS);<br/>  }<br/>}</span></pre><p id="f8d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我将<code class="fe nv nw nx ny b">drawMap</code>作为一个名为<code class="fe nv nw nx ny b">gameSetup</code>的新内部函数的一部分，它将随着时间的推移而扩展。</p><p id="01c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用<code class="fe nv nw nx ny b">setTimeout</code>来延迟<code class="fe nv nw nx ny b">gameSetup</code>一秒，这将有助于编排等级转换。</p><h2 id="59d2" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">测试您的地图</h2><p id="6622" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">如果你刷新你的浏览器，你的游戏地图应该会显示出来，看起来和下面的地图风格相似。地图本身永远是不一样的。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/b229f4453e2fa38e0e8d4036580caf21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-B3cg6Mjw-LRGS5FV5zpA.png"/></div></div></figure><h2 id="5fee" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">需要思考的问题</h2><ul class=""><li id="4f79" class="lh li iq kf b kg na kk nb ko nr ks ns kw nt la lm ln lo lp bi translated">在<code class="fe nv nw nx ny b">generateMap</code>功能中，您一次只能沿一个轴改变挖掘机的位置。为什么这很重要？如果你能同时改变x和y的值，会发生什么？</li><li id="5af9" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">算法如何保证每条路径都是由连续的瓦片组成的？</li><li id="f8f9" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">为什么地图上的所有地砖最终都能被玩家接触到？</li></ul></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="9823" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">9.生成游戏元素</h1><p id="7632" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在我们已经有了迷宫生成算法，是时候用游戏元素填充关卡了。其中包括以下内容:</p><ul class=""><li id="d7eb" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la lm ln lo lp bi translated">玩家</li><li id="a55e" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">敌人</li><li id="2db9" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">健康药水</li><li id="42a9" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">武器</li></ul><h2 id="209b" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">添加对象</h2><p id="56d4" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我们从一个简单的函数<code class="fe nv nw nx ny b">addObjToMap</code>开始，它基于<code class="fe nv nw nx ny b">coords</code>参数在特定位置添加一个新的图块，使用<code class="fe nv nw nx ny b">tileCode</code>设置图块的类型。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="83db" class="of md iq ny b be og oh l oi oj">function addObjToMap(coords, tileCode) {<br/><br/>   game.map[coords.y][coords.x] = tileCode<br/>}</span></pre><h2 id="0afa" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">寻找有效坐标</h2><p id="6c57" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">鉴于<code class="fe nv nw nx ny b">generateMap</code>的挑战在于创建可穿越的通道，这里的目标是选择既不是墙壁也不是游戏元素的坐标——所以让我们编写一个函数来随机生成一个代表未被占用的瓷砖的坐标。下面的函数，<code class="fe nv nw nx ny b">generateValidCoords,</code>就是这么做的。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="a2a6" class="of md iq ny b be og oh l oi oj">function generateValidCoords() {<br/><br/>  var x, y;<br/><br/>  do {<br/>      x = Math.floor(Math.random() * COLS);<br/>      y = Math.floor(Math.random() * ROWS);<br/>   }<br/>   while (game.map[y][x] != FLOOR_CODE);<br/> <br/>   return {<br/>      x: x,<br/>      y: y<br/>   };<br/>}</span></pre><p id="480b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的<code class="fe nv nw nx ny b">do...while</code>循环一直进行，直到在<code class="fe nv nw nx ny b">game.map</code>数组中找到一个等于<code class="fe nv nw nx ny b">FLOOR_CODE</code>的元素，它代表一个空闲的图块。</p><h2 id="2b3f" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">添加玩家</h2><p id="851d" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在我们可以在地图上添加东西了，让我们试着用一个叫做<code class="fe nv nw nx ny b">generatePlayer</code>的函数来添加我们的玩家对象。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="c6fe" class="of md iq ny b be og oh l oi oj">function generatePlayer() {<br/>}<br/></span></pre><p id="9e3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个函数中，我们首先获得一些有效的坐标。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="beb3" class="of md iq ny b be og oh l oi oj">function generatePlayer() {<br/><br/>   var coords = generateValidCoords();<br/><br/>}</span></pre><p id="fe33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们实例化一个新的玩家对象，传递必要的参数。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="34a8" class="of md iq ny b be og oh l oi oj">function generatePlayer() {<br/><br/>  var coords = generateValidCoords();<br/><br/>  // new, with these parameters: level, health, weapon, coords, xp<br/>  player = new Player(1, 100, WEAPONS[0], coords, 30);<br/>}</span></pre><p id="5bb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们使用<code class="fe nv nw nx ny b">player.coords</code>和玩家的磁贴代码将玩家对象添加到地图中。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="7338" class="of md iq ny b be og oh l oi oj">function generatePlayer() {<br/><br/>  var coords = generateValidCoords();<br/><br/>  // parameters: level, health, weapon, coords, xp<br/>  player = new Player(1, 100, WEAPONS[0], coords, 30);<br/><br/>  // new<br/>  addObjToMap(player.coords, PLAYER_CODE);<br/>}</span></pre><p id="0f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以从我们的<code class="fe nv nw nx ny b">gameSetup</code>函数中调用<code class="fe nv nw nx ny b">generatePlayer</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="eb7f" class="of md iq ny b be og oh l oi oj">function startGame() {<br/><br/>  generateMap();<br/><br/>  setTimeout(gameSetUp, 1000);<br/><br/>  function gameSetUp() {<br/><br/>      // new<br/>      generatePlayer();<br/><br/>      drawMap(0, 0, COLS, ROWS);<br/>  }<br/>}</span></pre><h2 id="b47e" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">测试播放器生成逻辑</h2><p id="296e" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">刷新浏览器并测试代码。现在，您应该会在屏幕上看到一个蓝色方块。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/43cc909b5e9ea52970eb391fabba1471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaJc8TXugYTwNmbtBsM52w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The player should appear as a blue tile.</figcaption></figure><h2 id="d978" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">树敌</h2><p id="9ec9" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在让我们制造一些敌人。</p><p id="d6f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始一个叫做<code class="fe nv nw nx ny b">generateEnemies</code>的函数。<code class="fe nv nw nx ny b">amount</code>是你想要产生的敌人数量。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="b8ed" class="nf md iq ny b gy oo op l oq oj">function generateEnemies(amount) {</span><span id="a589" class="nf md iq ny b gy or op l oq oj">   for (var i = 0; i &lt; amount; i++) {</span><span id="013e" class="nf md iq ny b gy or op l oq oj">   }<br/>}</span></pre><p id="1808" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将再次从获取可用图块的坐标开始。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="6f67" class="nf md iq ny b gy oo op l oq oj">for (var i = 0; i &lt; amount; i++) {</span><span id="2781" class="nf md iq ny b gy or op l oq oj">     let coords = generateValidCoords();<br/>}</span></pre><p id="1397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们随机挑选一些<code class="fe nv nw nx ny b">health</code>和<code class="fe nv nw nx ny b">damage</code>值。回想一下，这些是我们从中选择值的数组。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="f012" class="nf md iq ny b gy oo op l oq oj">const ENEMIES_HEALTH = [30, 30, 30, 30, 40, 40, 60, 80];</span><span id="426e" class="nf md iq ny b gy or op l oq oj">const ENEMIES_DAMAGE = [30, 30, 30, 30, 40, 40, 60, 80];</span></pre><p id="6df9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这需要从<code class="fe nv nw nx ny b">ENEMIES_HEALTH</code>和<code class="fe nv nw nx ny b">ENEMIES_DAMAGE</code>数组中选取随机值，所以让我们编写一个帮助函数来选取一个值。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="a9dc" class="nf md iq ny b gy oo op l oq oj">function pickRandom(arr) {</span><span id="afe5" class="nf md iq ny b gy or op l oq oj"> let idx = Math.floor(Math.random() * arr.length);</span><span id="ff95" class="nf md iq ny b gy or op l oq oj"> return arr[idx];<br/>}</span></pre><p id="21c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们调用辅助函数两次—一次用于<code class="fe nv nw nx ny b">health</code>，一次用于<code class="fe nv nw nx ny b">damage</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="d476" class="of md iq ny b be og oh l oi oj">function generateEnemies(amount) {<br/>   for (var i = 0; i &lt; amount; i++) {<br/><br/>      let coords = generateValidCoords();<br/><br/>      let health = pickRandom(ENEMIES_HEALTH);<br/><br/>      let damage = pickRandom(ENEMIES_DAMAGE);<br/>   }<br/>}</span></pre><p id="964c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们实例化我们的敌人，并将其添加到<code class="fe nv nw nx ny b">game</code>对象的<code class="fe nv nw nx ny b">enemies</code>数组中。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="b70c" class="nf md iq ny b gy oo op l oq oj">let enemy = new Enemy(health, coords, damage);</span><span id="e886" class="nf md iq ny b gy or op l oq oj">game.enemies.push(enemy);</span></pre><p id="21fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们把它添加到地图上。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="343d" class="nf md iq ny b gy oo op l oq oj">addObjToMap(coords, ENEMY_CODE);</span></pre><p id="1e8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是整个<code class="fe nv nw nx ny b">generateEnemies</code>功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="9acf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们将它添加到<code class="fe nv nw nx ny b">generatePlayer</code>之后的<code class="fe nv nw nx ny b">gameSetup</code>函数中。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="8638" class="of md iq ny b be og oh l oi oj">function gameSetUp() {<br/><br/>     generatePlayer();<br/><br/>     // new<br/>     generateEnemies(TOTAL_ENEMIES);<br/><br/>     drawMap(0, 0, COLS, ROWS);<br/>}</span></pre><h2 id="83a5" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">敌人的考验</h2><p id="f9ef" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">如果你刷新浏览器，你应该会在地牢里看到十个类似敌人的红色方块。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/99f342cfa7131cb2627204e24d329e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9axSiRkpTZK-X6owoW6fOg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The ten red tiles represent enemies.</figcaption></figure><p id="f7e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将它添加到init函数中。</p><h2 id="4604" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">生成药剂和武器</h2><p id="4568" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">对于一个任性的冒险者来说，没有一些物品几乎不可能在地牢中生存，所以让我们添加一个放置物品的功能。下面的函数既可以处理健康药水，也可以处理武器。</p><p id="7ae5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从一个有两个参数的循环开始:</p><ul class=""><li id="2f9d" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la lm ln lo lp bi translated"><code class="fe nv nw nx ny b">quantity</code>，即要创建的项目数</li><li id="6a2e" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated"><code class="fe nv nw nx ny b">tileCode</code>，对应于<code class="fe nv nw nx ny b">POTION_CODE</code>或<code class="fe nv nw nx ny b">WEAPON_CODE</code>常量，用于索引到<code class="fe nv nw nx ny b">TILE_COLORS</code>数组中。</li></ul><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="4cf1" class="of md iq ny b be og oh l oi oj">function generateItems(quantity, tileCode) {<br/>  <br/>}</span></pre><p id="9333" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从一个条件设置为<code class="fe nv nw nx ny b">quantity</code>的<code class="fe nv nw nx ny b">for</code>循环开始。在每一轮循环中，让我们生成一些有效的坐标，并将<code class="fe nv nw nx ny b">tileCode</code>添加到<code class="fe nv nw nx ny b">game.map</code> 2D数组中由坐标指定的索引处。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="84fc" class="of md iq ny b be og oh l oi oj">function generateItems(quantity, tileCode) {<br/>   <br/>   // new<br/>   for (var i = 0; i &lt; quantity; i++) {<br/><br/>      let coords = generateValidCoords();<br/><br/>      addObjToMap(coords, tileCode);<br/>   <br/>   }<br/>}</span></pre><p id="f8b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们接下来的步骤包括使用<code class="fe nv nw nx ny b">tileCode</code>获取正确的颜色，然后用<code class="fe nv nw nx ny b">drawObject</code>在地图上渲染。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="f4f9" class="of md iq ny b be og oh l oi oj">addObjToMap(coords, tileCode);<br/><br/>let color = TILE_COLORS[tileCode];<br/><br/>drawObject(coords.x, coords.y, color);</span></pre><p id="a765" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整功能如下。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2522" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与敌人生成不同，我们没有创建JavaScript对象并将它们添加到遭遇数组中。当玩家找到一种药剂或武器时，它的属性会在飞行中生成。</p><p id="7ab6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">写完这个函数，我们回过头来把它添加到<code class="fe nv nw nx ny b">gameSetup</code>函数中。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="2505" class="of md iq ny b be og oh l oi oj">function gameSetUp() {<br/><br/>      generatePlayer();<br/><br/>      // new<br/>      generateItems(STARTING_WEAPONS_AMOUNT, WEAPON_CODE);<br/><br/>      generateItems(STARTING_POTIONS_AMOUNT, POTION_CODE);<br/><br/>      generateEnemies(TOTAL_ENEMIES);<br/><br/>      drawMap(0, 0, COLS, ROWS);<br/>}</span></pre><h2 id="bffa" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">项目测试</h2><p id="6013" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">如果你刷新浏览器，你会看到四个橙色方块代表药剂，三个绿色方块代表武器。你所有的游戏元素现在都在地图上了！</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pa"><img src="../Images/f284778a6be44176648f0032fa75a337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6U485oYpn-MY6r9pN5TSTg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Here we have enemies in red, weapons in orange, potions in green, and our player in blue.</figcaption></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="6aa1" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">10.球员运动</h1><p id="e377" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">尽管我们取得了进步，但我们还不能控制球员。让我们通过添加一个位置更新函数和一个调用它的键盘监听器来解决这个问题。</p><p id="3771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们添加一个辅助对象，它从地图中删除一个对象，并用地砖来替换它。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="528f" class="of md iq ny b be og oh l oi oj">function removeObjFromMap(x, y) {<br/>  <br/>   game.map[y][x] = FLOOR_CODE;<br/><br/>};</span></pre><p id="38d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们在一个稍微大一点的更新玩家位置的函数中使用它。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b02e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们调用<code class="fe nv nw nx ny b">removeObjFromMap</code>从数组中清除玩家。然后，我们将<code class="fe nv nw nx ny b">PLAYER_CODE</code>设置为新单元的更新位置。最后，我们更新<code class="fe nv nw nx ny b">player.coords</code>，用于处理玩家移动。</p><p id="dc02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们开始我们的球员运动功能。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="cffb" class="of md iq ny b be og oh l oi oj">function addKeyboardListener() {<br/><br/>   document.addEventListener('keydown', function(e) {<br/><br/>     // we will add logic here<br/><br/>   });<br/>}</span></pre><p id="8b45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在侦听器中，让我们为播放器的当前坐标和新坐标设置变量。目前，这两对坐标是相同的。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="ddca" class="of md iq ny b be og oh l oi oj">function addKeyboardListener() {<br/><br/>    document.addEventListener('keydown', function(e) {<br/><br/>      var x = player.coords.x;<br/>      var y = player.coords.y;<br/>      var oldX = player.coords.x;<br/>      var oldY = player.coords.y;<br/>   });<br/>}</span></pre><p id="8c9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编写逻辑，通过调整<code class="fe nv nw nx ny b">x</code>或<code class="fe nv nw nx ny b">y</code>坐标来响应光标键的每次按下。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Switch / case statement.</figcaption></figure><p id="3aa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果玩家没有撞墙，我们使用新旧坐标调用<code class="fe nv nw nx ny b">updatePlayerPosition</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="55ea" class="of md iq ny b be og oh l oi oj">if (game.map[y][x] != WALL_CODE) {<br/><br/>   updatePlayerPosition(player.coords.x, player.coords.y, x, y);<br/>}</span></pre><p id="21e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们重新绘制玩家周围的地图部分。我发现，如果一个7x7的区域在任何时候都是可见的，并且随着玩家移动，那么重绘一个10x10的正方形效果很好。我们可以通过设置四个指定渲染边界的变量来实现这一点——分别是<code class="fe nv nw nx ny b">left</code>、<code class="fe nv nw nx ny b">top</code>、<code class="fe nv nw nx ny b">right</code>和<code class="fe nv nw nx ny b">bot</code>——然后调用<code class="fe nv nw nx ny b">drawMap</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="aca4" class="of md iq ny b be og oh l oi oj">if (game.map[y][x] != WALL_CODE) {<br/><br/>   updatePlayerPosition(player.coords.x, player.coords.y, x, y);<br/><br/>   let left = oldX - VISIBILITY - 1;<br/>   let top = oldY - VISIBILITY - 1;<br/>         <br/>   let right = x + VISIBILITY + 2;<br/>   let bot = y + VISIBILITY + 2 ;<br/><br/>   drawMap(left, top, right, bot);<br/>}</span></pre><p id="5a98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们调用<code class="fe nv nw nx ny b">preventDefault</code>来防止不想要的行为，比如滚动。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="1d8f" class="of md iq ny b be og oh l oi oj">e.preventDefault();</span></pre><p id="7280" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="85d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成<code class="fe nv nw nx ny b">addKeyboardListener</code>后，一定要在你下面的<code class="fe nv nw nx ny b">init()</code>函数中调用它。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="0470" class="of md iq ny b be og oh l oi oj">function init() {<br/>   createDOM();<br/>   game = new Game();<br/>   game.canvas = document.getElementById("grid");<br/>   game.context = game.canvas.getContext("2d");<br/>   startGame();<br/><br/>   // add here<br/>   addKeyboardListener();<br/><br/>}</span></pre><p id="aa1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，刷新你的浏览器，测试你是否可以移动你的播放器。</p><h2 id="35b3" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">一个需要思考的问题:</h2><p id="a283" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我们还没有添加碰撞检测——所以在这一点上，玩家可以简单地走到物品或敌人的瓷砖上，然后在玩家离开瓷砖后消失。为什么会这样？</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="ce14" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">11.更新游戏统计数据</h1><p id="9735" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我们即将让我们的玩家与敌人和物品互动，所以现在是一个写逻辑来更新HUD中的数据的好时机。提醒一下，下面是统计数据的样子。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/f27cd65cf6fd53c15f15421ce23730be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7quTR-Hbbl29Dmt7e9_DQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The game stats.</figcaption></figure><p id="73dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编写一个<code class="fe nv nw nx ny b">updateStats</code>函数，列出我们想要打印的三个播放器属性。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="b10a" class="of md iq ny b be og oh l oi oj">function updateStats() {<br/><br/>  let player_props = ['xp', 'level', 'health'];<br/><br/>}</span></pre><p id="a2a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们使用一个<code class="fe nv nw nx ny b">for...of</code>循环来遍历玩家的属性，并将每个属性打印到HUD。令人高兴的是，每个HUD元素的<code class="fe nv nw nx ny b">id</code>与对应的播放器属性相同。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="a562" class="of md iq ny b be og oh l oi oj">function updateStats() {<br/>  <br/>  let player_props = ['xp', 'level', 'health'];<br/><br/>  // new<br/>  for (var prop of player_props) {<br/>      let el = document.getElementById(prop);<br/>  }<br/>  el.textContent = player[prop];<br/>}</span></pre><p id="307e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要打印出当前武器的名称及其伤害等级。这里又是<code class="fe nv nw nx ny b">weapons</code>数组。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The constant holding the weapons.</figcaption></figure><p id="bffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">武器的DOM元素的ID是<code class="fe nv nw nx ny b">weapon</code>而不是<code class="fe nv nw nx ny b">name</code>，所以让我们编写一个映射对象，将HUD元素的ID匹配到武器的对象键<code class="fe nv nw nx ny b">name</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="d020" class="of md iq ny b be og oh l oi oj">let weapon_props = [{<br/>         domId: 'weapon',<br/>         key: 'name',<br/>      },<br/>      {<br/>         domId: 'damage',<br/>         key: 'damage'<br/>      }<br/> ];</span></pre><p id="18d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们准备迭代武器的两个属性并打印它们，通过<code class="fe nv nw nx ny b">domId</code>获取元素，通过<code class="fe nv nw nx ny b">key</code>获取属性。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="6af7" class="of md iq ny b be og oh l oi oj">for (var prop of weapon_props) {<br/><br/>  let {domId, key} = prop;<br/><br/>  let el = document.getElementById(domId);<br/><br/>  el.textContent = player.weapon[key];<br/>}</span></pre><p id="7744" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们来更新一下剩余敌人的数量，对应的是<code class="fe nv nw nx ny b">enemies</code>数组的长度。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="e124" class="of md iq ny b be og oh l oi oj">let enemyStats = document.querySelector("#enemies");<br/><br/>enemyStats.textContent = game.enemies.length;</span></pre><p id="6a31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的函数，我们可以在玩家移动和交互时调用它。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The complete updateStats function.</figcaption></figure><p id="3431" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为最后一步，让我们将<code class="fe nv nw nx ny b">updateStats</code>添加到我们的<code class="fe nv nw nx ny b">gameSetup</code>函数中，这样我们就可以在一开始就知道玩家的生命体征。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="0b42" class="of md iq ny b be og oh l oi oj">function gameSetUp() {<br/>      generatePlayer();<br/>      generateItems(STARTING_WEAPONS_AMOUNT, WEAPON_CODE);<br/>      generateItems(STARTING_POTIONS_AMOUNT, POTION_CODE);<br/>      generateEnemies(TOTAL_ENEMIES);<br/> <br/>      drawMap(0, 0, COLS, ROWS);<br/>      updateStats();<br/> }</span></pre><p id="6528" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了我们的<code class="fe nv nw nx ny b">updateStats</code>功能，我们现在可以编排战斗和收集物品的过程了。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="4856" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">12.敌军战斗</h1><p id="2fbe" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">当你的玩家试图移动到敌人的方格时，一场战斗将会发生。你根据敌人的伤害等级损失生命值，敌人的生命值根据你的武器等级下降。</p><p id="ed87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果敌人造成的伤害超过了玩家剩余的生命值，那么游戏就结束了，伙计！我们来写一个<code class="fe nv nw nx ny b">gameOver</code>函数，打印一条消息，调用<code class="fe nv nw nx ny b">game.reset()</code>方法，用新的关卡重启游戏。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="7ead" class="of md iq ny b be og oh l oi oj">function gameOver() {<br/><br/>   alert("GAME OVER");<br/>   game.reset();<br/>   startGame();<br/><br/>};</span></pre><p id="d485" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们开始一个在遭遇战中被调用的<code class="fe nv nw nx ny b">fightEnemy</code>函数。它会检查敌人造成的伤害是否会让玩家的生命值降到零度以下。如果是，我们称之为<code class="fe nv nw nx ny b">gameOver</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="234c" class="of md iq ny b be og oh l oi oj">function fightEnemy(enemy) {<br/><br/>   if (player.health - enemy.damage &lt;= 0) {<br/>      gameOver();<br/>      return;<br/>}</span></pre><p id="c56d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，如果你的玩家造成的伤害超过了敌人的生命值，敌人就会被击败。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="0c5b" class="of md iq ny b be og oh l oi oj">function fightEnemy(enemy) {<br/>   if (player.health - enemy.damage &lt;= 0) {<br/>      gameOver();<br/>      return;<br/>   }<br/><br/>   // new<br/>   if (enemy.health - player.weapon.damage &lt;= 0) {<br/>      enemyDefeated(enemy);<br/>   }<br/>}</span></pre><p id="1d48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你的敌人在这一轮战斗中幸存了下来，它只是失去了生命值。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="277a" class="of md iq ny b be og oh l oi oj">function fightEnemy(enemy) {<br/>   if (player.health - enemy.damage &lt;= 0) {<br/>      gameOver();<br/>      return;<br/>   }<br/>   if (enemy.health - player.weapon.damage &lt;= 0) {<br/>      enemyDefeated(enemy);<br/>   }<br/><br/>   // new<br/>   else {<br/>      enemy.health -= player.weapon.damage;<br/>   }<br/>}</span></pre><p id="1bbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果玩家在这一轮后还活着，生命值将会消失，游戏数据将会更新。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="dede" class="of md iq ny b be og oh l oi oj">function fightEnemy(enemy) {<br/>   if (player.health - enemy.damage &lt;= 0) {<br/>      gameOver();<br/>      return;<br/>   }<br/>   if (enemy.health - player.weapon.damage &lt;= 0) {<br/>      enemyDefeated(enemy);<br/>   }<br/>   else {<br/>      enemy.health -= player.weapon.damage;<br/>   }<br/><br/>   // new<br/>   player.health -= enemy.damage;<br/>   updateStats();<br/>}</span></pre></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="57fd" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">13.对付战败的敌人</h1><p id="b353" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们编写<code class="fe nv nw nx ny b">enemyDefeated</code>函数，它将一个<code class="fe nv nw nx ny b">enemy</code>对象作为参数。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="eb92" class="of md iq ny b be og oh l oi oj">function enemyDefeated (enemy) {<br/><br/>}</span></pre><p id="07ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个函数中，让我们首先从<code class="fe nv nw nx ny b">game.map</code> 2D数组中的位置删除敌人的牌码。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="ed4b" class="of md iq ny b be og oh l oi oj">removeObjFromMap(enemy.coords.x, enemy.coords.y);</span></pre><p id="af8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们更新游戏地图，使红色的敌人消失。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="8325" class="of md iq ny b be og oh l oi oj">let left = enemy.coords.x - 1;<br/>let top = enemy.coords.y - 1<br/>let right = enemy.coords.x + 1;<br/>let bot = enemy.coords.y + 1;<br/><br/>drawMap(left, top, right, bot);</span></pre><p id="ee39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们增加玩家的经验值，它等于敌人生命值和伤害等级的平均值。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="10a8" class="of md iq ny b be og oh l oi oj">player.xp += parseInt((enemy.damage + enemy.health)/2);</span></pre><p id="ce5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在必须弄清楚我们是否应该升级玩家。我们用积分来量化玩家的水平吧。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="aba5" class="of md iq ny b be og oh l oi oj">let level_in_points = POINTS_PER_LEVEL * (player.level - 1);</span></pre><p id="cf74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果玩家的经验值和当前等级的点数之差大于100(每个等级的点数)，这意味着玩家的等级应该提高。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="3665" class="of md iq ny b be og oh l oi oj">if (player.xp - level_in_points &gt;= POINTS_PER_LEVEL) {<br/><br/>   player.level++;<br/>}</span></pre><p id="621c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经调整了播放器，让我们从<code class="fe nv nw nx ny b">game.enemies</code>数组中移除<code class="fe nv nw nx ny b">enemy</code>对象并更新HUD。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="542c" class="of md iq ny b be og oh l oi oj">let e_idx = game.enemies.indexOf(enemy);<br/><br/>game.enemies.splice(e_idx, 1);<br/><br/>updateStats();</span></pre><p id="81b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们检查一个胜利，这将发生在没有敌人的情况下。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="4ed1" class="of md iq ny b be og oh l oi oj">if (game.enemies.length == 0) {<br/>      userWins();<br/>}</span></pre><p id="c1c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个快速的<code class="fe nv nw nx ny b">userWins</code>函数，打印一个胜利消息，重置游戏对象，开始一个新游戏。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="e9dd" class="of md iq ny b be og oh l oi oj">function userWins() {<br/><br/>   alert("YOU CONQUERED THE DUNGEON!");<br/><br/>   game.reset();<br/><br/>   startGame();<br/>};</span></pre><p id="1b03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe nv nw nx ny b">enemyDefeated</code>功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The enemyDefeated function.</figcaption></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="7f1b" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">14.敌人碰撞检测</h1><p id="0584" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">现在我们已经有了一套可能的战斗场景的函数，我们需要检测玩家何时接触到敌人。为了实现这一点，让我们回到处理玩家移动的<code class="fe nv nw nx ny b">addKeyboardListener</code>函数。</p><p id="482b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在该函数中，在检查墙壁的上方，让我们检查下一个图块是否在<code class="fe nv nw nx ny b">game.map</code>数组中有一个<code class="fe nv nw nx ny b">ENEMY_CODE</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="ac35" class="of md iq ny b be og oh l oi oj"><br/>// switch / case with keycodes above<br/><br/>if (game.map[y][x] == ENEMY_CODE) {<br/><br/>}<br/><br/><br/>// check for walls below</span></pre><p id="5010" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有，我们就用匹配的坐标找到敌人。下面我们使用数组方法<code class="fe nv nw nx ny b">find</code>和一个叫做<code class="fe nv nw nx ny b">matching_coords</code>的辅助函数。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="a437" class="of md iq ny b be og oh l oi oj">const matching_coords = (enemy) =&gt; {<br/>     return enemy.coords.x == x &amp;&amp; enemy.coords.y == y;<br/>}<br/>let enemy = game.enemies.find(matching_coords);</span></pre><p id="407e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了敌人的对象，让我们把它传到一个叫<code class="fe nv nw nx ny b">fightEnemy</code>的地方。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="449d" class="of md iq ny b be og oh l oi oj">if (game.map[y][x] == ENEMY_CODE) {<br/>       <br/>      const matching_coords = (enemy) =&gt; {<br/>          return enemy.coords.x == x &amp;&amp; enemy.coords.y == y;<br/>      }<br/>      let enemy = game.enemies.find(matching_coords);<br/><br/>      // new<br/>      fightEnemy(enemy);<br/> }</span></pre><p id="b31d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，对于它下面的<code class="fe nv nw nx ny b">WALL_CODE</code>检查，让我们用<code class="fe nv nw nx ny b">else if</code>代替<code class="fe nv nw nx ny b">if</code>，这样我们只有在<em class="lb">而不是</em>遇到敌人时才移动玩家。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/722bf2fbe540bd3c231f54f12af76a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7Df4k-2_0BZ2ZkD6HvBTw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Enemy collision detection logic</figcaption></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="56d7" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">15.收集药剂和武器</h1><p id="0d11" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们继续扩展我们的<code class="fe nv nw nx ny b">addKeyboardListener</code>功能来处理武器和药剂的遭遇。下面是我们的球员移动代码的详细介绍，并附有注释，说明我们将在哪里添加这个新的逻辑。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pd"><img src="../Images/0a338ff8b89d2338f64f3fbe0733fc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbGLKZNXN0hyoH9OVOgcuw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A snippet of player movemeent code.</figcaption></figure><p id="5787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从魔药的代码开始，然后你可以试着写武器的代码。记住药剂可以带来的生命值是在<code class="fe nv nw nx ny b">POTIONS</code>数组中指定的。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="52a9" class="of md iq ny b be og oh l oi oj">const POTIONS = [10, 20, 30, 40, 50];</span></pre><p id="399c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编写一个快速助手函数，从这个数组中随机选取一个值。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="4e4c" class="of md iq ny b be og oh l oi oj">function pickRandom(arr) {<br/><br/>   let idx = Math.floor(Math.random() * arr.length);<br/><br/>   return arr[idx];<br/>}</span></pre><p id="e722" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们在遭遇药剂的代码中使用它。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="4037" class="of md iq ny b be og oh l oi oj">if (game.map[y][x] == POTION_CODE) {<br/><br/>    player.health += pickRandom(POTIONS);<br/><br/>    removeObjFromMap(x, y);<br/>      <br/>    generateItems(1, POTION_CODE);      <br/>}</span></pre><p id="8406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nv nw nx ny b">if</code>条件下，会发生三件事:</p><ul class=""><li id="a09b" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la lm ln lo lp bi translated">我们通过从<code class="fe nv nw nx ny b">POTIONS</code>数组中抽取的数量来增加生命值。</li><li id="82e1" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">我们从地图上移除药剂物品。</li><li id="c417" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">我们调用<code class="fe nv nw nx ny b">generateItems</code>在别的地方创造新的药剂。</li></ul><p id="5866" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然你已经知道了如何为魔药编写碰撞检测，那就继续为武器编写一个吧。完成后，您可以将您的代码与下面的完整<code class="fe nv nw nx ny b">addKeyboardListener</code>函数进行比较。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The full addKeyboardListener function with collision detection.</figcaption></figure><p id="3c5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，武器和药剂逻辑与玩家移动逻辑在同一个代码块中。这意味着与敌人不同，玩家不会被药剂或武器阻挡，而是可以走过它们并捡起它们。</p><h2 id="2098" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">测试你的游戏</h2><p id="44bd" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在这一点上，除了“切换阴影”按钮之外，游戏中的所有东西都应该工作了。所以在这一点上，刷新你的浏览器，并测试游戏，以确保它按预期运行。</p><p id="3dd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在使用Git这样的版本控制系统，这是提交您的更改的好时机。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="23e7" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">16.影子逻辑</h1><p id="11d5" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">作为最后一步，让我们得到“切换阴影”按钮的工作。当我们打开它时，应该只能看到玩家周围的7x7方块。当玩家移动时，可见的方块应该随之移动。</p><h2 id="43f1" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">生成初始阴影</h2><p id="e9b6" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们从一个名为<code class="fe nv nw nx ny b">generateShadow</code>的函数开始，它在2D数组中存储可见方块的位置。我们将初始化两个对象，<code class="fe nv nw nx ny b">start</code>和<code class="fe nv nw nx ny b">end</code>，它们将分别存储正方形的左上和右下坐标。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="921b" class="of md iq ny b be og oh l oi oj">function generateShadow() {<br/>   let start = {}, end = {};<br/>  <br/>}</span></pre><p id="508e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，在我们文件的其他地方，我们有一个值<code class="fe nv nw nx ny b">VISIBILITY</code>，它决定了7x7可见正方形的大小。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="ddd4" class="of md iq ny b be og oh l oi oj">VISIBILITY = 3</span></pre><p id="2c58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以在这个函数内，让我们用<code class="fe nv nw nx ny b">VISIBILITY</code>结合玩家的位置来计算可见方块左边缘的位置。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="04b2" class="of md iq ny b be og oh l oi oj">let left_edge = player.coords.x - VISIBILITY;</span></pre><p id="223d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们通过比较左边缘和最低可能索引a行来计算起始的<code class="fe nv nw nx ny b">x</code>坐标:<code class="fe nv nw nx ny b">0</code>。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="07d3" class="of md iq ny b be og oh l oi oj">start.x = left_edge &lt; 0 ? 0 : left_edge;</span></pre><p id="53f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe nv nw nx ny b">OUTER_LIMIT</code>小于<code class="fe nv nw nx ny b">3</code>并且玩家非常靠近地图的左边缘，则<code class="fe nv nw nx ny b">left_edge</code>可能小于零。如果<code class="fe nv nw nx ny b">left_edge</code>为负，我们从<code class="fe nv nw nx ny b">0</code>开始可见方块的左上<code class="fe nv nw nx ny b">x</code>坐标。下面是它可能的样子。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/d6f27034db90d9499f7349b52b385da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*nTRAUHROikqyQqv9pSHWYg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">On the left edge, the visible rectangle is no longer 7x7.</figcaption></figure><p id="375a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们对顶部边缘和<code class="fe nv nw nx ny b">y</code>坐标做同样的操作。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="dbf5" class="of md iq ny b be og oh l oi oj">let top_edge = player.coords.y - VISIBILITY;<br/><br/>start.y = top_edge &lt; 0 ? 0 : top_edge;</span></pre><p id="3d7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将对<code class="fe nv nw nx ny b">right_edge</code>和<code class="fe nv nw nx ny b">bot_edge</code>进行同样的操作，以获得<code class="fe nv nw nx ny b">end</code>坐标。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="bf1e" class="of md iq ny b be og oh l oi oj">let right_edge = player.coords.x + VISIBILITY;<br/>let bot_edge = player.coords.y + VISIBILITY;<br/><br/>end.x = right_edge &gt;= COLS ? COLS - 1 : right_edge;<br/>end.y = bot_edge &gt;= ROWS ? ROWS - 1 : bot_edge;</span></pre><p id="9d80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回想一下，<code class="fe nv nw nx ny b">game</code>对象将有一个名为<code class="fe nv nw nx ny b">shadow</code>的2D数组。现在我们已经有了<code class="fe nv nw nx ny b">start</code>和<code class="fe nv nw nx ny b">end</code>坐标，让我们使用一个嵌套循环来基于可见矩形的新角填充这个数组。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/a456fca430a060f8523b1efd92bca4e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCTkuj9ADFeZiGtytojiCA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Here we populate the 2D shadow array with a nested loop.</figcaption></figure><p id="ca1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们让可见矩形内的图块的值为<code class="fe nv nw nx ny b">VISIBLE_CODE</code> ( <code class="fe nv nw nx ny b">1</code>)，而其他图块的值为<code class="fe nv nw nx ny b">SHADOW_CODE</code> ( <code class="fe nv nw nx ny b">0</code>)。</p><p id="ef28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是整个<code class="fe nv nw nx ny b">generateShadow</code>功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The generate shadow logic</figcaption></figure><h2 id="1321" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">完成游戏设置功能</h2><p id="530f" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我们现在可以通过在调用<code class="fe nv nw nx ny b">generateItems</code>之前调用<code class="fe nv nw nx ny b">generateShadow</code>来完成我们的<code class="fe nv nw nx ny b">gameSetup</code>函数。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="6ee9" class="of md iq ny b be og oh l oi oj">function gameSetUp() {<br/>      generatePlayer();<br/><br/>      // new <br/>      generateShadow();<br/><br/>      generateItems(STARTING_WEAPONS_AMOUNT, WEAPON_CODE);<br/>      generateItems(STARTING_POTIONS_AMOUNT, POTION_CODE);<br/>      generateEnemies(TOTAL_ENEMIES);<br/>   <br/>      drawMap(0, 0, COLS, ROWS);<br/>      updateStats();<br/>}</span></pre><h2 id="fafa" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">用阴影逻辑绘制地图</h2><p id="3c20" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我们需要修改四个函数来适应阴影和可见方块。让我们从<code class="fe nv nw nx ny b">drawMap</code>开始，当阴影打开时，它应该使大部分方块变黑。</p><p id="f282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是整合了影子逻辑的完整<code class="fe nv nw nx ny b">drawMap</code>功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The complete drawMap function</figcaption></figure><p id="cf14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑的关键位在下面。如果阴影是开着的，而玩家不在可见的矩形内，我们只需将那块瓷砖涂成黑色。否则，我们使用指定的瓷砖颜色。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="797b" class="of md iq ny b be og oh l oi oj">if (game.isShadowToggled &amp;&amp; game.shadow[row][col] == SHADOW_CODE) {<br/><br/>     // new - set color to black<br/>     color = '#000000';<br/>            <br/>} else {<br/>     let c_idx = game.map[row][col];<br/>     color = TILE_COLORS[c_idx];<br/>}</span></pre><h2 id="6cb0" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">完成阴影切换处理程序</h2><p id="0881" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">为了确保阴影可以被打开和关闭，现在让我们将<code class="fe nv nw nx ny b">drawMap</code>添加到我们的<code class="fe nv nw nx ny b">toggleShadow</code>函数中。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="4300" class="of md iq ny b be og oh l oi oj">function toggleShadow() {<br/>   game.isShadowToggled = !game.isShadowToggled;<br/><br/>   // new<br/>   drawMap(0, 0, COLS, ROWS);<br/>}</span></pre><p id="ab49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加这个调用到<code class="fe nv nw nx ny b">drawMap</code>将会在每次阴影切换时更新地图。</p><h2 id="0da5" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">使用影子逻辑生成项目</h2><p id="4a0d" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">当在地图上生成药剂和武器时，我们现在可以包括一个与阴影相关的检查。如果在游戏过程中添加了药剂或武器，只有当阴影关闭<em class="lb">或</em>且该物品在可见的矩形内时，才能抽取药剂或武器。</p><pre class="ld le lf lg gt ob ny oc bn od oe bi"><span id="e973" class="of md iq ny b be og oh l oi oj">if (!game.isShadowToggled || <br/>     game.shadow[coords.y][coords.x] == VISIBLE_CODE) {<br/><br/>         let color = TILE_COLORS[tileCode];<br/><br/>         drawObject(coords.x, coords.y, color);<br/>}</span></pre><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The item generation function.</figcaption></figure><h2 id="aff9" class="nf md iq bd me ng nh dn mi ni nj dp mm ko nk nl mq ks nm nn mu kw no np my nq bi translated">更新玩家位置</h2><p id="58a8" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在下面的函数中，我们需要添加玩家位置更新时重绘地图的逻辑。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/8e9547253749460385a6ef83b07cd874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPfbK-NUzMiGZ8sfqySdKA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The position update function before adding the shadow logic.</figcaption></figure><p id="ec6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们建立两个坐标，<code class="fe nv nw nx ny b">start</code>和<code class="fe nv nw nx ny b">end</code>，这两个坐标将建立将被重新渲染的地图区域。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="e24f" class="nf md iq ny b gy oo op l oq oj">let start = {}, end = {};</span></pre><p id="eec9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的默认情况是假设我们的玩家向右下方移动。</p><p id="23da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们找到旧广场的左上坐标，这将需要重新渲染。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="3561" class="nf md iq ny b gy oo op l oq oj">let old_left = oldX - VISIBILITY;  </span><span id="78e5" class="nf md iq ny b gy or op l oq oj">let old_top = oldY - VISIBILITY;</span></pre><p id="4a88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过检查渲染区域的左上边缘来计算它们，就像我们在生成阴影时所做的那样。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="ab5b" class="nf md iq ny b gy oo op l oq oj">start.x = old_left &lt; 0 ? 0 : old_left;</span><span id="ee01" class="nf md iq ny b gy or op l oq oj">start.y = old_top &lt; 0 ? 0 : old_top;</span></pre><p id="b960" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用类似的技术来寻找渲染区域的右下角。因为我们在向右移动，所以我们用<code class="fe nv nw nx ny b">newX</code>来找最右边的边。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="2ab8" class="nf md iq ny b gy oo op l oq oj">let new_right = newX + VISIBILITY;</span></pre><p id="a37a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且因为是向下移动，所以用<code class="fe nv nw nx ny b">newY</code>来找底边。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="ee18" class="nf md iq ny b gy oo op l oq oj">let new_bot = newY + VISIBILITY;</span></pre><p id="7d96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以找到正方形右下角的坐标。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="b994" class="nf md iq ny b gy oo op l oq oj">end.x = new_right &gt;= COLS ? COLS - 1 : new_right;</span><span id="cfdd" class="nf md iq ny b gy or op l oq oj">end.y = new_bot &gt;= ROWS ? ROWS - 1 : new_bot;</span></pre><p id="a8dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果玩家向左移动呢？在这种情况下，我们使用<code class="fe nv nw nx ny b">newX</code>来获得正方形的左边缘，因为我们必须确保重新渲染左边缘。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="a989" class="nf md iq ny b gy oo op l oq oj">if (oldX &gt; newX) {<br/>      start.x = newX - VISIBILITY;<br/>}</span></pre><p id="1221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe nv nw nx ny b">oldX</code>更靠右，所以让它成为渲染区域的最右边的界限。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="93c0" class="nf md iq ny b gy oo op l oq oj">if (oldX &gt; newX) {<br/>      start.x = newX - VISIBILITY;<br/>   <strong class="ny ir">   end.x = oldX + VISIBILITY;</strong><br/>}</span></pre><p id="41b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果玩家向上移动，让我们用<code class="fe nv nw nx ny b">newY</code>找到渲染区域的上边缘，用<code class="fe nv nw nx ny b">oldY</code>找到下边缘。这最大化了我们重新渲染的区域的高度。</p><pre class="ld le lf lg gt ob ny ol om aw on bi"><span id="d81f" class="nf md iq ny b gy oo op l oq oj">if (oldY &gt; newY) {<br/>      start.y = newY - VISIBILITY;<br/>      end.y = oldY + VISIBILITY;<br/>}</span></pre><p id="d8d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们遍历需要重新渲染的区域。我们将使用<code class="fe nv nw nx ny b">newX</code>、<code class="fe nv nw nx ny b">newY</code>和<code class="fe nv nw nx ny b">VISIBILITY</code>来确定哪些图块可见。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/a456fca430a060f8523b1efd92bca4e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCTkuj9ADFeZiGtytojiCA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The nested loop.</figcaption></figure><p id="b0ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe nv nw nx ny b">updatePlayerPosition</code>功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1ee5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经做到了这一步，祝贺你！你已经完成了完整的游戏。请随意测试您的工作，并与此代码笔进行比较。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="ph oa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The complete game.</figcaption></figure><p id="be20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，可以随意下载这个<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-1/archive/refs/heads/main.zip" rel="noopener ugc nofollow" target="_blank"> zip </a>，里面有完整的代码和其他类似roguelike的实验。与本教程相关的演示在<code class="fe nv nw nx ny b">games/game-1-drunkards-walk</code>目录中。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="a778" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">潜在的后续步骤</h1><p id="80c8" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">如果你想进一步开发你的游戏，下面是一些想法供你考虑。</p><ul class=""><li id="ea14" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la lm ln lo lp bi translated">给你能拥有的健康加上一个限制。</li><li id="164a" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">添加健康栏。</li><li id="a34e" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">增加滚动功能，这样游戏可以独立于屏幕宽度运行。</li><li id="9ca3" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">添加滑动控制、加速度控制或软键按压。</li><li id="0dc6" class="lh li iq kf b kg lq kk lr ko ls ks lt kw lu la lm ln lo lp bi translated">添加声音，音乐，图像，伤害效果和精灵。</li></ul><p id="a5c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次感谢<a class="ae kc" href="https://codepen.io/ni-kun" rel="noopener ugc nofollow" target="_blank">尼古拉</a>，他在开发最初游戏的整体架构方面做得非常好。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><div class="ld le lf lg gt pi"><a href="https://medium.com/codex/build-a-maze-game-with-vanilla-javascript-part-1-of-2-ddfd35e84e93" rel="noopener follow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd ir gy z fp pn fr fs po fu fw ip bi translated">用普通Javascript构建一个迷宫游戏，第1部分</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">开始这个由两部分组成的旅程，用HTML、CSS和普通JS创建一个迷宫游戏。</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">medium.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw jw pi"/></div></div></a></div><p id="94db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">说白了就是io </em> </strong> </a> <em class="lb">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">免费周报</em> </strong> </a> <em class="lb">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">Twitter</em></strong></a><em class="lb">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">LinkedIn</em></strong></a><em class="lb">。加入我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">社区不和谐</em> </strong> </a> <em class="lb">。</em></p><p id="8387" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">并考虑注册</em><a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"><strong class="kf ir"><em class="lb">Medium</em></strong></a><em class="lb">无限制访问我以及其他作家的所有文章。</em></p></div></div>    
</body>
</html>