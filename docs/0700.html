<html>
<head>
<title>React Query: Beyond the Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React查询:超越基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-query-beyond-basics-f43149c7a36a?source=collection_archive---------6-----------------------#2022-02-08">https://javascript.plainenglish.io/react-query-beyond-basics-f43149c7a36a?source=collection_archive---------6-----------------------#2022-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d6e956ca75aa8c78184a76d8c9cae219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouyHRR8FBxpdLFB1LR3qJw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@vorosbenisop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Benjamin Voros</a> on <a class="ae jz" href="https://unsplash.com/s/photos/mountain-night-sky?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b0d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">互联网上的各种文章已经讨论了使用react-query的好处。<code class="fe ky kz la lb b">useQuery</code> / <code class="fe ky kz la lb b">useMutation</code>的易用性，即基本上是一行代码，用来访问加载、获取或错误状态以及响应数据，已经被反复迭代了。但更高级、更小众的功能几乎没有讨论过。所以我在这里，深入研究了react-query世界的一些特性。</p><p id="d46a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将给你一个简单的待办事项列表应用程序的例子，其中显示了待办事项列表。当用户想要创建新的todo时，会打开一个模态表单。成功创建待办事项后，将重新提取待办事项列表。在待办事项列表中，如果用户点击一个待办事项，它将转到一个新的页面，该页面将显示与该待办事项对应的详细信息。</p><h1 id="526d" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> 1。onSucces &amp; onError </strong></h1><p id="73e6" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><code class="fe ky kz la lb b">useQuery</code>和<code class="fe ky kz la lb b">useMutation</code>都支持各种配置选项。其中两个是接受函数的<code class="fe ky kz la lb b">onSuccess</code>和<code class="fe ky kz la lb b">onError</code>参数。这两个选项很有帮助，尤其是当我们想要执行一些非数据呈现逻辑时。在todo列表的例子中，如果我们想抛出一个成功或错误的消息芯片，不一定是一个组件，use可以使用这些。(<em class="mf">如果需要渲染组件，我们最好用</em> <code class="fe ky kz la lb b"><em class="mf">isSuccess</em></code> <em class="mf">或者</em> <code class="fe ky kz la lb b"><em class="mf">isError</em></code>)。基本上，这可以像我们在api获取中使用的<code class="fe ky kz la lb b">.then</code>中的回调函数一样。更好的用例是分派一些redux状态。这也可以在这里完成，不需要到处摸索。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="2e49" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2.查询无效</h1><p id="3624" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在我们的待办事项列表示例中，正如我们已经讨论过的，我们希望在成功创建任务时重新获取所有待办事项的列表。所以查询失效的魔力来了。我们必须使用前面讨论过的<code class="fe ky kz la lb b">onSuccess</code>函数。在该函数中，我们可以使用queryClient invalidation来使无效，即要求react-query重新提取一个或多个查询。</p><p id="af8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的todo应用程序中，当我们的create todo成功时，我们将使获取所有todo列表的查询无效。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="0a89" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">3.查询重试次数</h1><p id="78d8" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">这可能很小，但在情况需要时可以派上用场。React query带有一些对应于每个配置选项的预配置默认值。例如，缓存时间为5分钟，过时时间为0。所以众多选项中的一个，就是<code class="fe ky kz la lb b">retry</code>选项。其默认值为3。也就是说，如果一个查询在第一次尝试中获取查询不成功，它将继续尝试3次，然后将<code class="fe ky kz la lb b">isError</code>声明为真。在某些情况下，你可能不希望这种行为。您可以随时将其更改为其他数字，表示您希望发生的重试次数。另一种方式是，retry也接受true和false作为值。那是什么意思？如果retry为true，那么react query将获取查询，直到成功；如果retry为false，那么在任何不成功的尝试之后都不会重试。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6466" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有这些选项都可以根据每个查询进行更改。但是您可能希望为所有查询声明自己的配置选项(除非您在某个特定查询中另外指定)。那么您应该考虑在查询客户机中这样做。</p><h1 id="ef09" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4.有条件地启用查询</h1><p id="24f4" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在某些情况下，您可能希望查询仅在满足某些条件时运行。<code class="fe ky kz la lb b">useQuery</code>react-query的所有其他优点都是钩子，不能直接用在if-else语句中，因为那会破坏react钩子的基本规则。对于这些类型的场景，react-query带有一个名为<code class="fe ky kz la lb b">enabled</code>的选项。我们总是可以将它们硬编码为真或假，但是真正精彩的地方是当一个变量被传递时。现在，根据变量值的变化，查询将被启用或禁用。多酷啊！</p><p id="87ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在我们的todo-list应用程序中，当用户转到单个todo时，<code class="fe ky kz la lb b">todo_id</code>作为url中的参数传递(使用react-router或其他路由库)。并按<code class="fe ky kz la lb b">todo_id</code>，取明细。现在，我们希望获取查询，前提是param不为空。我们可以这样做-</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="9bbd" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">5.查询的自定义挂钩</h1><p id="23d7" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">这更多的是个人观点，而不是react-query特有的特性。因此，如果您需要定制预配置选项之外的行为，或者需要访问<code class="fe ky kz la lb b">onSuccess</code>或<code class="fe ky kz la lb b">onError</code>选项，很快您可能会得到类似这样的结果。有些人可能更希望可以立即看到查询中发生了什么。但是，如果您需要跨多个组件访问同一个查询，您可能希望在整个react-query逻辑周围创建自己的定制钩子。我向你保证，这不是什么高端柔术。如果我们考虑前面的例子，它会是这样的:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><blockquote class="mm mn mo"><p id="2d0d" class="ka kb mf kc b kd ke kf kg kh ki kj kk mp km kn ko mq kq kr ks mr ku kv kw kx ig bi translated">一些专业建议</p></blockquote><ol class=""><li id="eafc" class="ms mt in kc b kd ke kh ki kl mu kp mv kt mw kx mx my mz na bi translated">如果你考虑编写自定义钩子，你也可以考虑声明一个变量，在这里我们只是保存数据，或者如果你出于某种原因需要状态代码，那么你也可以在这里把它抽象出来，作为单个值传递，并生成我们需要映射或执行其他操作的数据。定义良好的变量比一般数据更有意义。</li></ol><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="9efc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.如果将数据重命名为其他名称，也可以直接在react-query中完成。不仅仅是数据，你还可以将<code class="fe ky kz la lb b">isLoading</code>或<code class="fe ky kz la lb b">isError</code>重命名为其他名称。如果您需要在一个组件中访问两个或多个查询，这是非常必要的。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="2971" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.您可以使用api路由作为查询名称。如果将您的查询函数抽象到其他地方，这将非常有意义。如果您发现您需要访问您认为已经在某些组件中使用过的特定查询，这可能也会有所帮助。现在你想在其他组件中使用它。以这种方式命名，您将很容易避免查找特定查询的名称。毕竟，查询名称对于有效利用react-query的优势(例如，查询无效)是至关重要的。我在整篇文章中都遵循了这种风格。</p><p id="7376" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.如果使用定制钩子，你可以考虑根据它们的主要路径将它们保存在单独的文件中。并将它们都保存在服务文件夹本身中，这种结构可能已经在axios中使用了。</p><pre class="mg mh mi mj gt nb lb nc nd aw ne bi"><span id="f6bb" class="nf ld in lb b gy ng nh l ni nj">src<br/> — components<br/> — pages<br/> — services<br/>  — todo.js<br/>  — user.js</span></pre><p id="5f69" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它并不意味着详尽无遗。就几个，我每天都在用。</p><p id="6b47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后的一些部分是纯粹的个人黑客，你可能不同意，或者我可能真的做错了。请随时告诉我。</p><p id="36e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mf">更多内容看</em> <a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mf">说白了。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mf">免费周报</em> </strong> </a> <em class="mf">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mf">Twitter</em></strong></a><em class="mf">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mf">LinkedIn</em></strong></a><em class="mf">。加入我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mf">社区</em> </strong> </a> <em class="mf">。</em></strong></a></p></div></div>    
</body>
</html>