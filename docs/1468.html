<html>
<head>
<title>How to Get an Element’s Top Position Relative to the Browser’s Viewport?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何获取一个元素相对于浏览器视口的顶部位置？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-get-an-elements-top-position-relative-to-the-browser-s-viewport-df955547100f?source=collection_archive---------1-----------------------#2022-03-26">https://javascript.plainenglish.io/how-to-get-an-elements-top-position-relative-to-the-browser-s-viewport-df955547100f?source=collection_archive---------1-----------------------#2022-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1aee0d16d616cd957b5eda257584f64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*svnxcGvPxQnHQ7c9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pueblovista?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paul Gilmore</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d3e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，我们可能想要获得一个元素相对于浏览器视窗的顶部位置。</p><p id="1963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何获取元素相对于浏览器视窗的顶部位置。</p><h1 id="477b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用getBoundingClientRect方法</h1><p id="c0bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">getBoundingClientRect</code>方法获得一个元素相对于其视窗的位置。</p><p id="02f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0ade" class="mq lc iq mh b gy mr ms l mt mu">const div = document.querySelector('div')<br/>const {<br/>  top: t,<br/>  left: l<br/>} = div.getBoundingClientRect();<br/>console.log(t, l)</span></pre><p id="6c83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">querySelector</code>得到div。</p><p id="bb4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在它上面调用<code class="fe me mf mg mh b">getBoundingClientRect</code>来获得一个具有<code class="fe me mf mg mh b">top</code>和<code class="fe me mf mg mh b">left</code>属性的对象。</p><p id="98ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">top</code>有相对于视口顶部的位置。</p><p id="f300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">left</code>有相对于视口左侧的位置。</p><p id="463d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两者都以像素为单位。</p><p id="06c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想考虑滚动，那么我们把<code class="fe me mf mg mh b">scrollY</code>值加到<code class="fe me mf mg mh b">top </code>上，把<code class="fe me mf mg mh b">scrollX</code>值加到<code class="fe me mf mg mh b">left</code>上。</p><p id="0a64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0df8" class="mq lc iq mh b gy mr ms l mt mu">const div = document.querySelector('div')<br/>const {<br/>  top: t,<br/>  left: l<br/>} = div.getBoundingClientRect();<br/>const {<br/>  scrollX,<br/>  scrollY<br/>} = window<br/>const topPos = t + scrollX<br/>const leftPos = l + scrollY<br/>console.log(topPos, leftPos)</span></pre><p id="ad70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将滚动位置包含在元素的位置中。</p><h1 id="baab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="349a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">getBoundingClientRect</code>方法获得元素相对于视口的位置。</p></div></div>    
</body>
</html>