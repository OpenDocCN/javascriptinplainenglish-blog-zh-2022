<html>
<head>
<title>Regular Expressions—a Rite of Passage: From Theory to Practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式——通过仪式:从理论到实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/regular-expressions-a-rite-of-passage-from-theory-to-practice-f4f23bec6044?source=collection_archive---------3-----------------------#2022-05-22">https://javascript.plainenglish.io/regular-expressions-a-rite-of-passage-from-theory-to-practice-f4f23bec6044?source=collection_archive---------3-----------------------#2022-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ec2d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:应用该理论构建一个验证邮政编码的演示单页应用程序。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/76aadc13aa64be426b01fd5081bad05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwmAyNyj6DLOAFHmw5v2qw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Photo by </strong><a class="ae kt" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><strong class="bd ks">Kelly Sikkema</strong></a><strong class="bd ks"> on </strong><a class="ae kt" href="https://unsplash.com/s/photos/flow-chart?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><strong class="bd ks">Unsplash</strong></a></figcaption></figure><p id="e1dd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> <em class="lq">欢迎回来！</em>T3】</strong></p><p id="8342" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">对于那些已经阅读了本教程系列第一部分的人，感谢您坚持阅读这篇理论文章。随着我们从理论走向实践，它会有回报的。</p><p id="83b2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在第2部分中，我们应用了第1部分中所学的内容，<a class="ae kt" href="https://rhieger-98255.medium.com/regular-expressions-a-rite-of-passage-for-web-developers-b24181465096" rel="noopener"> <strong class="kw io"> <em class="lq">正则表达式Web开发人员的必经之路</em></strong></a><strong class="kw io"><em class="lq"/></strong>其中<strong class="kw io"> <em class="lq"> </em> </strong>快速介绍了<strong class="kw io">正则表达式</strong>的一些关键概念。</p><p id="079b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们将通过为网络建立一个演示<strong class="kw io">单页应用(SPA) </strong>来把理论转化为实践。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="dae1" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">入门指南</h1><p id="c479" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated">对于那些还没有看到我们的<strong class="kw io"> SPA </strong>的人来说，下面的<strong class="kw io">图1 </strong>显示了登录页面:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/02d3a04918ef94c8ce2108ac9fcd7b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szrHN_cYlWtVtdMJp42i5A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Fig. 1 Regex Demo Landing Page</strong></figcaption></figure><p id="2071" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上面的开始屏幕显示了以下组件:</p><ol class=""><li id="9286" class="mw mx in kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">主标题，说明了应用程序的功能——即匹配有效的邮政编码。</li><li id="0d90" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">紧接在它的下面，一个标注框更详细地解释了应用程序的目标。</li><li id="91f1" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">接下来是多行测试字符串的滚动列表，它将被传递给下面显示的<strong class="kw io">正则表达式</strong>。</li><li id="0b7c" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">在这下面，我们有一个<strong class="kw io">小部件</strong>，在左侧，有一组2个垂直堆叠的按钮。第一个是<strong class="kw io"> Validate Zip Codes </strong>，它触发一个匹配并从测试字符串中提取有效邮政编码的事件。单击时，其右侧的窗口会填充由<strong class="kw io">正则表达式返回的有效邮政编码。</strong></li><li id="0da9" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">第二个按钮— <strong class="kw io">重置— </strong>将文本框重置为默认状态，如图1<strong class="kw io">所示。</strong></li></ol><p id="e249" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> <em class="lq">我们要怎么做这一切？</em> </strong>让我们思考一下这个问题。</p><p id="786f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们为我们的应用程序提供了一些预制的测试数据(尽管如果用户上传一个包含测试数据的文件，原理仍然是一样的)。在这两种情况下，<strong class="kw io">正则表达式引擎</strong>都会显示测试数据，并被要求只返回有效邮政编码的匹配。</p><p id="6908" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这比听起来更复杂。指定给<strong class="kw io">正则表达式引擎</strong>的<strong class="kw io">正则表达式</strong>必须能够执行以下所有操作:</p><ul class=""><li id="9e39" class="mw mx in kw b kx ky la lb ld my lh mz ll na lp nk nc nd ne bi translated">确保用户输入仅由数字和可选的+4邮政编码连字符组成。(显然，在这个演示应用程序中，没有用户输入。但是这个项目的进一步开发可以使应用程序完全交互。)</li><li id="8898" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nk nc nd ne bi translated">除了+4邮政编码中需要的连字符之外，任何字母、标点或其他特殊符号都不能作为返回匹配的一部分。</li><li id="5b17" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nk nc nd ne bi translated">确保各种邮政编码(5位数字或+4)的前面或后面没有其他字符。</li><li id="31f8" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nk nc nd ne bi translated">在任何情况下，邮政编码都必须以5位数字开始。</li><li id="875e" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nk nc nd ne bi translated">可选地，<strong class="kw io">正则表达式引擎</strong>必须能够匹配以连字符开始并以4个数字结束的5字符序列。</li><li id="7ed2" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nk nc nd ne bi translated">最后，最后4位数字后不得出现任何字符。</li></ul><p id="b24e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">所有这些似乎都是一项艰巨的任务。但是正如我们在前面的教程中看到的，<strong class="kw io">正则表达式</strong>完全能够满足所有这些需求。</p><p id="be1d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> <em class="lq">这一刻终于到来了！</em> </strong></p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="e1d9" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">让我们建造它！</h1><p id="5a9b" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated">在所有这些理论之后，让我们将它付诸实践并构建这个应用程序。</p><p id="c175" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">要开始，请下载<a class="ae kt" href="https://github.com/RHieger/regex-zip-code-tutorial/raw/starter-code/regex-starter-code.zip" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">启动代码</strong> </a>。</p><h2 id="114e" class="nl lz in bd ma nm nn dn me no np dp mi ld nq nr mk lh ns nt mm ll nu nv mo nw bi translated">第一步。解压缩启动代码档案</h2><p id="bd7b" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated">这个档案被命名为<strong class="kw io"> regex-starter-code.zip </strong>。你可以根据自己的喜好给它重新命名，比如<strong class="kw io"> regex-demo-web-app.zip </strong>。<strong class="kw io"> </strong>一定要保管好<strong class="kw io">。zip扩展名，因为如果缺少扩展名，一些zip存档程序可能无法识别文件。</strong></p><p id="93f7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">出于本教程的目的，我使用<a class="ae kt" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">微软Visual Studio代码</a>，但是你也可以使用你最喜欢的文本编辑器。</p><p id="a79b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">一旦您解压了重命名的<strong class="kw io"> regex-demo-web-app.zip </strong>(或者您选择的任何名称)，您将拥有一个类似于图2<strong class="kw io">所示的文件结构。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/49edf19bd61cc3b4212093e2eded6c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0b54tbToGAxaVuBx1d5yZQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Fig. 2 Project File Structure</strong></figcaption></figure><h2 id="217f" class="nl lz in bd ma nm nn dn me no np dp mi ld nq nr mk lh ns nt mm ll nu nv mo nw bi translated">第二步。将项目片段放在一起</h2><p id="5757" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated">我们的项目由<strong class="kw io"> HTML </strong>内容、<strong class="kw io"> CSS </strong>样式和单个<strong class="kw io"> JavaScript </strong>文件— <strong class="kw io"> app.js </strong>组成。</p><p id="3828" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">虽然我已经为您提供了样式，以便我们可以主要关注于<strong class="kw io"> JavaScript，</strong>我们将从<strong class="kw io">index.html</strong>文件提供的基本结构开始。</p><p id="be7d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们首先在您最喜欢的网络浏览器中打开应用程序的<strong class="kw io">index.html</strong>文件。出于本教程的目的，我使用<a class="ae kt" href="https://www.google.com/chrome/downloads/" rel="noopener ugc nofollow" target="_blank"> Google Chrome </a>作为其卓越的开发工具。下面的图3显示了我们的准系统应用程序框架。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/733a3506956826b1a970df93fc1076b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58tcmwwrN2C_1eUCqpmX6w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Fig. 3 Bare Bones HTML</strong></figcaption></figure><p id="ea8d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">图3 </strong>展示了我们的应用程序所在文档的基本结构。不是那么容易理解。让我们解决这个问题。</p><p id="0d0b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">下面的代码清单1 </strong>显示了我们的<strong class="kw io">index.html</strong>文件中第<strong class="kw io">行<br/>23–39的一个片段。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/1b40e9e070c42087c4d698170ac54f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9qsPPjI-Oikhm7PoeKtsw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Code Listing 1. index.html showing relevant &lt;head&gt; content</strong></figcaption></figure><p id="a563" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">第24行和第28行</strong>是相关的代码行，我们现在将对它们进行修改，以将应用程序的三个组件结合在一起。</p><p id="2e85" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如您所知，为了让浏览器按照我们的意愿呈现应用程序登录页面，我们必须将我们的<strong class="kw io">级联样式表</strong>链接到<strong class="kw io"> HTML </strong>文件。</p><p id="814f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们还必须将我们的JavaScript代码链接到HTML文件。请遵循以下步骤:</p><ol class=""><li id="9cc4" class="mw mx in kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">将上面第24行的注释替换为下面的注释:<br/> <code class="fe nz oa ob oc b"><strong class="kw io">&lt;link rel=“stylesheet” href=“./css/zipcodes.css”&gt;</strong></code></li><li id="1504" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">现在我们集成项目的最后一个组件。参考上面的<strong class="kw io">代码清单1 </strong>，将<strong class="kw io">第28行</strong>替换为这个:<br/> <code class="fe nz oa ob oc b"><strong class="kw io">&lt;script src=“./js/app.js” defer&gt;&lt;/script&gt;</strong></code></li></ol><p id="06b7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe nz oa ob oc b"><strong class="kw io">&lt;script&gt;</strong></code>标签中的关键字<strong class="kw io"> defer </strong>保证了浏览器在脚本执行开始前加载<strong class="kw io">index.html</strong>文档的<strong class="kw io"> DOM </strong>。这可以防止<strong class="kw io"> JavaScript </strong>抛出错误，因为<strong class="kw io"> DOM </strong>对象引用了一个尚未定义的节点。</p><p id="5371" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">记得将这些更改保存到你的index.html文件中。</strong></p><p id="0cac" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">3.刷新您的浏览器。</p><p id="e916" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">太好了！如果一切按计划进行，您的网页应该完全如图1所示。但是，如果你点击<strong class="kw io"> <em class="lq">中的任何一个按钮，此时绝对不会发生任何事情。</em> </strong>显然，这是因为我们还没有编写任何为这些按钮提供功能的代码。</p><h2 id="08ac" class="nl lz in bd ma nm nn dn me no np dp mi ld nq nr mk lh ns nt mm ll nu nv mo nw bi translated">第三步。捕获必要的DOM节点</h2><p id="03c6" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated">首先打开起始代码档案中的<strong class="kw io"> app.js </strong>文件。它应该如下图<strong class="kw io">4</strong>所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi od"><img src="../Images/853fad6044742324a260a2335cacc1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYdR2vJXmjOs68ruzBPIOw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Fig. 4 app.js Starter Code</strong></figcaption></figure><p id="7021" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如您所见，整个文件现在只包含注释。<strong class="kw io">图4 </strong>将是我们完成应用程序的路线图。我们将在构建缺失代码时引用它。</p><p id="6533" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们从捕获必要的<strong class="kw io"> DOM节点开始。</strong>我们将使用<strong class="kw io">文档对象模型(DOM) </strong>来确定当用户与我们的应用程序交互时，需要改变的屏幕部分。</p><p id="bf4e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"><em class="lq">DOM对象中需要捕获哪些HTML元素？首先，我们可以推断，因为当我们单击应用程序中的任何一个按钮时都不会发生任何事情，所以我们需要访问这些节点。因此，我们需要2个<strong class="kw io"> DOM对象</strong>来捕获<strong class="kw io">验证邮政编码</strong>和<strong class="kw io">重置</strong>按钮。</em></strong></p><p id="89fe" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">接下来，我们需要做两件事。我们需要按钮右侧的默认消息，现在显示为<strong class="kw io"> NO MATCH </strong>消失，取而代之的是由<strong class="kw io"> regex引擎</strong>返回的滚动匹配列表。</p><p id="4afb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了做到这一点，我们需要能够捕获默认消息，以便可以删除它。我们还需要访问它的<strong class="kw io">父元素</strong>，一旦默认消息被移除，它将包含滚动列表。因此，我们需要2个DOM对象来捕获这些元素。</p><p id="e349" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">总之，我们必须声明4个<strong class="kw io"> DOM </strong> <strong class="kw io">对象</strong>来捕获引用我们需要访问的<strong class="kw io"> HTML </strong> <strong class="kw io">元素</strong>的<strong class="kw io">节点</strong>。</p><p id="aa72" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们创建它们，并测试它们在<strong class="kw io"> DOM中是否可见。</strong></p><p id="b266" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">下面的图5 </strong>显示了包含<strong class="kw io">元素</strong>的<strong class="kw io"> HTML </strong>的相关行，我们将在<strong class="kw io"> DOM对象中捕获这些元素:</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/6dbf80b8f7d17fe26d79ba396b087da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uGe7J33BSiLSh6KrWKaQQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Fig. 5 Elements to Be Captured in the DOM</strong></figcaption></figure><p id="1720" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">图5 </strong>中的关键标记是按钮、显示为“不匹配”的段落及其父元素——具有<strong class="kw io">结果的<strong class="kw io"> id </strong>属性的<code class="fe nz oa ob oc b"><strong class="kw io">&lt;div&gt;</strong></code>，第106–118行。</strong></p><p id="c684" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">每个<strong class="kw io">元素</strong>都设置了一个<strong class="kw io"> id </strong>属性，以便可以使用<code class="fe nz oa ob oc b"><strong class="kw io">document.getElementById()</strong></code> <strong class="kw io">方法捕获它。</strong>还有<em class="lq">和</em>其他可以采用的方法，比如<code class="fe nz oa ob oc b"><strong class="kw io">querySelector()</strong></code>和<code class="fe nz oa ob oc b"><strong class="kw io">querySelectorAll()</strong></code>方法。对于本教程，我选择使用<code class="fe nz oa ob oc b"><strong class="kw io">getElementById()</strong></code>是因为它的直接和简单。</p><p id="e3e4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">要创建必要的<strong class="kw io"> DOM对象，</strong>请参考上面的<strong class="kw io">图4 </strong>。用以下4行代码替换第18 行的注释:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="cd31" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const</strong> resultButton = <strong class="oc io">document.getElementById</strong>('validate');<br/><strong class="oc io">const</strong> resetButton = <strong class="oc io">document.getElementById</strong>('reset');<br/><strong class="oc io">const</strong> resultBox = <strong class="oc io">document.getElementById</strong>('results');<br/><strong class="oc io">const</strong> placeHolder = <strong class="oc io">document.getElementById</strong>('message');</span></pre><p id="d2a9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">尽管如此，如果你刷新浏览器并点击<strong class="kw io">验证邮政编码</strong>按钮，什么也不会发生。我们还没有提供这项功能。我们<em class="lq">现在将</em>做的是使用<strong class="kw io">谷歌Chrome开发者工具</strong>测试我们捕获的元素是否真的被捕获。</p><p id="c8f7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">验证节点对DOM <br/> </strong>可见为此，刷新浏览器并通过按下<strong class="kw io"> Ctrl+Shift+J </strong>打开<strong class="kw io"> JavaScript控制台</strong>对于Windows/Linux/Unix和<strong class="kw io"> Command+Option+J </strong>对于Mac。您应该会看到类似下面图6 的内容:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/3fb898652976306647d9491ff503789c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4O-7xPa_-tGgANqmkVXWg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Fig. 6 Google Chrome Showing JavaScript Console on Right</strong></figcaption></figure><p id="81a5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了验证我们的<strong class="kw io">节点对象，</strong>在<strong class="kw io"> JavaScript控制台</strong>中单击一个插入点，并键入以下命令，然后按<strong class="kw io"> Enter/Return </strong>键:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="c91a" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">resultButton</strong> &lt;Enter&gt;<br/><strong class="oc io">resetButton</strong> &lt;Enter&gt;<br/><strong class="oc io">resultBox</strong> &lt;Enter&gt;<br/><strong class="oc io">placeHolder</strong> &lt;Enter&gt;</span></pre><p id="4c92" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">确保通过点击折叠信息旁边的向右箭头展开<strong class="kw io">结果框</strong>的输出。</p><p id="7314" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您应该会看到类似下面图7<strong class="kw io">所示的结果:</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/4ab6ee13e78c04bf280bf99f2440d0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnB_jMuiShUH5btE8p2cFQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Fig 7. Browser with JavaScript console confirming access to desired nodes</strong></figcaption></figure><p id="9da6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">到目前为止，我们已经有了应用程序的入口点，因为我们可以访问需要操作的页面部分。接下来，我们需要声明我们的<strong class="kw io">测试字符串</strong>和我们的<strong class="kw io">正则表达式。</strong></p><h2 id="8b68" class="nl lz in bd ma nm nn dn me no np dp mi ld nq nr mk lh ns nt mm ll nu nv mo nw bi translated">第四步。声明测试字符串和正则表达式</h2><p id="02fc" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated">我们需要声明两个<strong class="kw io">常量</strong>——一个存储我们传递给<strong class="kw io">正则表达式</strong>的<strong class="kw io">测试字符串</strong>，另一个存储<strong class="kw io">正则表达式</strong> <strong class="kw io">对象</strong>，其中<strong class="kw io">测试字符串</strong>将被传递给该对象。</p><p id="6fe7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">回头参考<strong class="kw io">图4 </strong>，我们将关注<strong class="kw io">线22和26。</strong></p><p id="793d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">替换第22行</strong> <br/>用以下代码替换<strong class="kw io">第22行</strong>(修改后的代码中的第25行)的注释:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="b840" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const</strong> testString =<br/><strong class="oc io">`</strong>10003<br/>asdf10003<br/>10003asdf<br/>jklm10003^$@%<br/>10003-8924<br/>one zero zero zero three<br/>9101-94015<br/>94015-9101<br/>20012<br/>08735<br/>KbdsD$%^&amp;*<br/>sSd070031jkl;m<br/>70122<br/>\sKu2034<br/>98108<br/>75381<br/>asdfjkl;<br/>60661<br/>!9004!@#$5^&amp;*<br/>97218<br/>#,.$$&amp;&amp;%@<br/>10022-3337<br/>eNuhfF!.<strong class="oc io">`;</strong></span></pre><p id="7c40" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">替换第26行</strong> <br/>现在用以下代码替换第26行<strong class="kw io">的注释(修改后的代码中的第52行):</strong></p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="f707" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const regex</strong> = <strong class="oc io">/</strong>^[0-9]{5}(-[0-9]{4})?$<strong class="oc io">/gm;</strong></span></pre><p id="423f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们的演示应用程序已经准备就绪。我们已经捕获了<strong class="kw io"> DOM </strong> <strong class="kw io">节点</strong>，当用户点击<strong class="kw io"> Validate Zip Codes </strong>按钮时，这些节点是向页面注入动态数据所必需的。我们还提供了我们的<strong class="kw io"> testString </strong>常量和<strong class="kw io"> regex </strong>常量。</p><p id="aa00" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">接下来，我们必须继续构建功能，该功能将提供我们希望在页面上注入的有效邮政编码的匹配。</p><h2 id="0c38" class="nl lz in bd ma nm nn dn me no np dp mi ld nq nr mk lh ns nt mm ll nu nv mo nw bi translated">第五步。使用Regex返回有效的邮政编码匹配</h2><p id="89c2" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated">在我们实际向<strong class="kw io"> app.js </strong>添加必要的代码之前，让我们后退一步，清楚地了解匹配过程将如何工作。</p><p id="8a85" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们已经有了使用<strong class="kw io">对象文字符号</strong>声明的<strong class="kw io"> regex </strong>对象。这个<strong class="kw io">对象</strong>公开了执行不同种类<br/>搜索的<strong class="kw io">方法</strong>。</p><p id="3760" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">有几个<strong class="kw io">方法</strong>被<strong class="kw io"> regex </strong>对象公开。你可以在Mozilla开发者网<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#using_regular_expressions_in_javascript" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">正则表达式页面</strong></a>(<em class="lq">在JavaScript中使用正则表达式】</em>)。</p><p id="582e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">然而，与我们相关的是<code class="fe nz oa ob oc b"><strong class="kw io">match()</strong></code>方法。这个<strong class="kw io">方法</strong>的语法是:</p><p id="e737" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe nz oa ob oc b"><strong class="kw io">&lt;string object&gt;.match(&lt;regular expression object&gt;);</strong></code></p><p id="b689" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们的<strong class="kw io">字符串对象</strong>就是上面在<strong class="kw io">步骤4中声明的常量<strong class="kw io"> testString </strong>。</strong>我们将使用<strong class="kw io"> testString </strong>暴露的<code class="fe nz oa ob oc b"><strong class="kw io">match()</strong></code> <strong class="kw io">方法</strong>。<strong class="kw io"/><code class="fe nz oa ob oc b"><strong class="kw io">match()</strong></code><strong class="kw io">方法</strong>反过来需要一个<strong class="kw io"/>参数，那就是<strong class="kw io">正则表达式</strong>对象。</p><p id="d9a8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe nz oa ob oc b"><strong class="kw io">match()</strong></code>的返回值是一个由<strong class="kw io">正则表达式返回的每个匹配组成的<strong class="kw io">数组</strong>。</strong></p><p id="255c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">返回值<strong class="kw io">必须是</strong> <strong class="kw io">返回给某个</strong>才能被访问。在上面显示的语法中，由<code class="fe nz oa ob oc b"><strong class="kw io">match()</strong></code> <strong class="kw io">方法</strong>返回的<strong class="kw io">对象</strong>是不可寻址的，尽管已经为它保留了内存。</p><p id="ebc0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">一旦<strong class="kw io">方法</strong>被执行<strong class="kw io"> JavaScript </strong>将<strong class="kw io">垃圾收集</strong>存储在其中的<br/>值，只要它确定它们没有被<br/>使用或者不再被使用。如果你有兴趣了解更多关于<br/>这方面的知识，你可能想参考这篇关于<br/> <a class="ae kt" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">垃圾收集</strong> </a> ( <em class="lq">“垃圾收集】</em>)的简短但内容丰富的文章。</p><p id="a860" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们将使用的实际语法如下所示:</p><p id="4868" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe nz oa ob oc b"><strong class="kw io">const myConstant = &lt;string object&gt;.match(&lt;regular expression object&gt;);</strong></code></p><p id="8bde" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">替换第31行</strong> <br/>回过来参考<strong class="kw io">图4，</strong>用以下代码行替换<strong class="kw io">第31行</strong>(修改后的代码中的第57行)的注释:</p><p id="b94f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe nz oa ob oc b"><strong class="kw io">const </strong>matches = <strong class="kw io">testString.match</strong>(regex);</code></p><p id="9b4c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这一行代码完成了很多工作。将<strong class="kw io"> testString </strong>一次性传递给<strong class="kw io"> regex </strong>(我们的<strong class="kw io">正则表达式</strong> <strong class="kw io">对象</strong>)，执行模式匹配，提取有效的邮政编码，并将结果存储在一个<strong class="kw io">数组</strong>中，其中的标识符<strong class="kw io">与</strong>匹配。<strong class="kw io"> <em class="lq">非常强大的东西。</em> </strong></p><p id="d432" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在，让我们通过以下步骤对此进行测试:</p><ol class=""><li id="1ab2" class="mw mx in kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">刷新您的浏览器。如果您尚未打开<strong class="kw io"> JavaScript控制台，</strong>现在就打开。</li><li id="6da9" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">在<strong class="kw io"> JavaScript控制台</strong>中点击一个插入点，键入<strong class="kw io">匹配</strong>，然后按<strong class="kw io"> Enter/Return </strong>键。展开控制台中返回的内容后，您的显示应该如下面的<strong class="kw io">图8 </strong>所示:</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/b1c8c96f4f55cb1c5b13a3a5bf37ac62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUSkgtgLQKpoznibeIHRpA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd ks">Fig. 8 Browser with JavaScript Console confirming valid zip code matches</strong></figcaption></figure><p id="76c2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">由于<strong class="kw io">图8 </strong>确认了<strong class="kw io">正则表达式对象返回了11个有效的邮政编码匹配。</strong></p><p id="8553" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">显然，我们不能要求最终用户进入JavaScript控制台来获得验证过程的结果。</strong>为了使这成为一个真正的动态应用程序，我们必须为创建两个<strong class="kw io">事件监听器</strong>构建一些基础设施——一个监听<strong class="kw io">验证邮政编码</strong>按钮上的<strong class="kw io">点击</strong>，另一个监听<strong class="kw io">点击<strong class="kw io">重置</strong>按钮上的</strong>。</p><h2 id="3e91" class="nl lz in bd ma nm nn dn me no np dp mi ld nq nr mk lh ns nt mm ll nu nv mo nw bi translated">第六步。创建助手函数</h2><p id="12f7" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated"><strong class="kw io"> <em class="lq">该基础设施由什么组成？</em> </strong> <em class="lq"> </em>如果我们从最明显的假设开始，我们需要当最终用户点击其中一个按钮时发生一些事情。</p><p id="48a3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们的应用程序是事件驱动的。因此我们需要为按钮编写两个<strong class="kw io">事件监听器</strong>。正如我们将看到的，这些事件监听器由几个<strong class="kw io">助手函数</strong>提供支持。</p><p id="b3f1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在我们编写第一个<strong class="kw io">助手</strong>之前，我们需要声明一个空的<strong class="kw io">数组</strong>，它的代码将填充这个数组。</p><p id="61fc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">回头参考<strong class="kw io">图4 </strong>，用以下代码行替换<strong class="kw io">第43行</strong>(修改后的代码中的第69行)的注释:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="d370" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const</strong> paragraphText = [];</span></pre><p id="d464" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上面的空<strong class="kw io">数组</strong>将由我们的第一个<strong class="kw io">辅助函数填充。</strong></p><p id="e59c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"/><code class="fe nz oa ob oc b"><strong class="kw io">createParahgaphText()</strong></code><strong class="kw io">助手函数<br/> </strong>回过来参考<strong class="kw io">图4 </strong>，用以下代码替换<strong class="kw io">第47行</strong>(修改后的代码中的第73行)中的注释:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="23a6" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const</strong> createParagraphText = () =&gt; {<br/>  <strong class="oc io">matches.forEach</strong>( match =&gt; {<br/>    <strong class="oc io">let</strong> matchNumber = <strong class="oc io">matches.indexOf</strong>(match) + 1;<br/>    <strong class="oc io">paragraphText.push</strong>(<br/>      `Match #${<strong class="oc io">matchNumber</strong>}: ${<strong class="oc io">match</strong>}`<br/>    );<br/>  });<br/>};</span></pre><p id="f126" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> <em class="lq">这个辅助函数发生了什么？</em> </strong>我们来一行一行的分解一下。</p><p id="5f0d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe nz oa ob oc b"><strong class="kw io">createParagraphText()</strong></code> <strong class="kw io"> </strong>中的代码是由<strong class="kw io"/><strong class="kw io"/><code class="fe nz oa ob oc b"><strong class="kw io">forEach()</strong></code>循环组成的。<code class="fe nz oa ob oc b"><strong class="kw io">forEach()</strong></code>被<strong class="kw io">数组</strong>对象暴露。在上面的代码中，我们的<strong class="kw io">数组</strong>是<strong class="kw io">匹配</strong>常量。</p><p id="f68a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们称之为<strong class="kw io">比赛中的<code class="fe nz oa ob oc b"><strong class="kw io">forEach()</strong></code>方法。match，</strong>位于<strong class="kw io">方法</strong>的<strong class="kw io">参数</strong>部分，是对在<strong class="kw io"> matches数组</strong>中找到的每个<strong class="kw io">元素</strong>的引用。</p><p id="08cc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">还有一个<strong class="kw io">匿名回调函数</strong>作为第二个参数，从<code class="fe nz oa ob oc b"><strong class="kw io">match()</strong></code> <strong class="kw io">方法</strong>创建的<code class="fe nz oa ob oc b"><strong class="kw io">matches[]</strong></code> <strong class="kw io">数组</strong>中提取数据。在<strong class="kw io">回调函数的第一行中，</strong>我们声明了变量<strong class="kw io"> matchNumber，</strong>，它存储了<code class="fe nz oa ob oc b"><strong class="kw io">matches[]</strong></code> <strong class="kw io"> </strong>数组中<strong class="kw io"> index + 1 </strong>的值。</p><p id="8411" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们调用<strong class="kw io"> match </strong>上的<code class="fe nz oa ob oc b"><strong class="kw io">indexOf()</strong></code> <strong class="kw io"> </strong>来得到<strong class="kw io"> match </strong>的<strong class="kw io">数组索引</strong>循环的每次迭代。<strong class="kw io"> 1 </strong>被添加到<strong class="kw io">索引</strong>值，因为我们知道，数组是<strong class="kw io"> 0索引的，</strong>对于人类来说，引用匹配<strong class="kw io"> 1到11，</strong>比引用匹配<strong class="kw io"> 0到10更有意义。</strong></p><p id="6a7b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在我们函数的最后一行，我们使用由<strong class="kw io">数组对象公开的<code class="fe nz oa ob oc b"><strong class="kw io">push()</strong></code> <strong class="kw io">方法</strong>来填充<code class="fe nz oa ob oc b"><strong class="kw io">paragraphText[]</strong></code>数组。</strong></p><p id="8750" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们为每一项指定要推送到<strong class="kw io">数组</strong>的数据同时使用<strong class="kw io">模板文字符号</strong>和<strong class="kw io">字符串插值</strong>来创建一个<strong class="kw io">数组元素</strong>，如下所示:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="5304" class="nl lz in oc b gy oj ok l ol om">Match #1: 10003</span></pre><p id="3591" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你可能想知道为什么我没有在<br/>中一次性完成整个段落。构建完整的段落是我们的<br/> next <strong class="kw io"> helper函数的结果。</strong></p><p id="b361" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在我们构建那个<strong class="kw io">，</strong>之前，我们需要声明另一个空的<strong class="kw io">数组</strong>来包含完整的段落。</p><p id="a14f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">回头参考<strong class="kw io">图4 </strong>，用以下代码替换<strong class="kw io">第51行</strong>(修订代码中的第84行)的注释:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="f410" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const</strong> paragraphs = [];</span></pre><p id="1ac8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">用从<code class="fe nz oa ob oc b"><strong class="kw io">paragraphText[]</strong></code> <strong class="kw io">数组</strong>中提取的<strong class="kw io">子</strong> <strong class="kw io">文本节点</strong>填充<strong class="kw io">数组</strong>。</p><p id="f748" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe nz oa ob oc b"><strong class="kw io">createParagraphs()</strong></code>必须完成以下所有工作:</p><ol class=""><li id="f7f1" class="mw mx in kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">为每个<strong class="kw io">正则表达式</strong>匹配在<strong class="kw io"> DOM </strong>中创建一个<code class="fe nz oa ob oc b"><strong class="kw io">&lt;p&gt;</strong></code>元素。</li><li id="2754" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">将包含<strong class="kw io">匹配</strong>数据的<strong class="kw io">文本节点</strong>附加到添加到<strong class="kw io"> DOM的每个<code class="fe nz oa ob oc b"><strong class="kw io">&lt;p&gt;</strong></code> <strong class="kw io">元素</strong>。</strong></li><li id="2607" class="mw mx in kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">将每个完成的段落推送到<code class="fe nz oa ob oc b"><strong class="kw io">paragraphs[]</strong></code> <strong class="kw io">数组</strong>。</li></ol><p id="72d7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"/><code class="fe nz oa ob oc b"><strong class="kw io">createParagraphs()</strong></code><strong class="kw io">助手函数<br/> </strong>回过来参考<strong class="kw io">图4，</strong>用以下代码替换<strong class="kw io">第55行</strong>(修改后的代码中的第88行)中的注释:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="5297" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const</strong> createParagraphs = () =&gt; {<br/>  <strong class="oc io">paragraphText.forEach</strong>( <strong class="oc io">text</strong> =&gt; {<br/>    <strong class="oc io">const</strong> paragraph = <strong class="oc io">document.createElement</strong>('p');<br/>    <strong class="oc io">paragraph.textContent</strong> = text;<br/>    <strong class="oc io">paragraphs.push</strong>(paragraph);<br/>  });<br/>};</span></pre><p id="a80f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> <em class="lq">那么这段代码到底在做什么？</em></strong><em class="lq"/><code class="fe nz oa ob oc b"><strong class="kw io">createParagraphs()</strong></code>函数的整个逻辑可以在对<br/> <code class="fe nz oa ob oc b"><strong class="kw io">forEach()</strong></code> <strong class="kw io">方法的一次调用中找到。</strong></p><p id="d3bb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">循环中的第一行是:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="1370" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const </strong>paragraph<strong class="oc io"> = document.createElement</strong>('p');</span></pre><p id="017f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们思考一下这里发生了什么。</p><p id="6b0e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">每次通过循环，<strong class="kw io"> JavaScript </strong>都会找到一个<strong class="kw io">文本</strong> <strong class="kw io">节点</strong>，它是<code class="fe nz oa ob oc b"><strong class="kw io">paragraphText[]</strong></code> <strong class="kw io">数组</strong>的成员。这一行代码声明了一个<code class="fe nz oa ob oc b"><strong class="kw io">&lt;p&gt;</strong></code> <strong class="kw io">元素</strong>，其中的<strong class="kw io">文本</strong> <strong class="kw io">节点</strong>将作为<strong class="kw io">子节点追加到该元素中。</strong></p><p id="297b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">循环中的下一行是:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="b5f0" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">paragraph.textContent = </strong>text;</span></pre><p id="79e5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这一行将当前索引处的<strong class="kw io">文本节点</strong>追加到前一行创建的<code class="fe nz oa ob oc b"><strong class="kw io">&lt;p&gt;</strong></code> <strong class="kw io">元素</strong>中。循环中的最后一行代码是:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="7835" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">paragraphs.push</strong>(paragraph);</span></pre><p id="b8df" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这行代码将一个完整的段落推送到<code class="fe nz oa ob oc b"><strong class="kw io">paragraphs[]</strong></code> <strong class="kw io">数组</strong>。重复该序列，直到<code class="fe nz oa ob oc b"><strong class="kw io">paragraphText[]</strong></code> <strong class="kw io">数组</strong>中的最后一个<strong class="kw io">元素</strong>被读入循环。</p><p id="6b23" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">已完成段落的<strong class="kw io">数组</strong>现在等待被追加到<strong class="kw io"> resultBox对象。最后一个<strong class="kw io">助手函数</strong>将完成这项任务。</strong></p><p id="84bc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">append paragraphs()辅助函数<br/> </strong>让我们回顾一下<strong class="kw io">图1 </strong>。所示的两个按钮在它们的<strong class="kw io"> </strong>右侧有一个显示<strong class="kw io">不匹配的信息框。</strong></p><p id="593b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们现在要交换这个框的内容，用一个滚动窗口移除<strong class="kw io">不匹配</strong>占位符消息，该窗口将包含<code class="fe nz oa ob oc b"><strong class="kw io">paragraphs[]</strong></code> <strong class="kw io">数组</strong>中的所有段落作为其子项。</p><p id="2e6c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">回头参考图4中的<strong class="kw io">，</strong>用下面的代码替换<strong class="kw io">第59行</strong>(修改代码中的第98行)上的注释:</p><pre class="kd ke kf kg gt of oc og oh aw oi bi"><span id="2d56" class="nl lz in oc b gy oj ok l ol om"><strong class="oc io">const</strong> appendParagraphs = (<strong class="oc io">parent, children</strong>) =&gt; {<br/>  <strong class="oc io">children.forEach</strong>( (<strong class="oc io">child</strong>) =&gt; {<br/>    <strong class="oc io">parent.appendChild</strong>(child);<br/>  });<br/>};</span></pre><p id="b5ce" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在仅仅5行代码中，<code class="fe nz oa ob oc b"><strong class="kw io">appendParagraphs()</strong></code>完成了相当多的工作。该函数接受两个<strong class="kw io">参数</strong>、<strong class="kw io">父</strong>和<strong class="kw io">子</strong>。</p><p id="3489" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">调用该函数时，<strong class="kw io">父</strong>引用<strong class="kw io"> resultBox </strong>，即在我们的<strong class="kw io">index.html</strong>文件中捕获<code class="fe nz oa ob oc b"><strong class="kw io">&lt;div id="results"&gt;</strong></code> <strong class="kw io"> </strong>的<strong class="kw io">节点对象</strong>。<strong class="kw io">子</strong>指<code class="fe nz oa ob oc b"><strong class="kw io">paragraphs[]</strong></code> <strong class="kw io">数组。</strong></p><p id="6b10" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们最后的<strong class="kw io">辅助函数</strong>也使用了<code class="fe nz oa ob oc b"><strong class="kw io">forEach()</strong></code> <strong class="kw io">方法。</strong>这里<code class="fe nz oa ob oc b"><strong class="kw io">paragraphs[]</strong></code> <strong class="kw io">数组</strong>的所有元素都被追加到<strong class="kw io"> resultBox </strong>节点，重复这个过程直到所有11个匹配都被追加到<strong class="kw io"> resultBox。</strong></p><blockquote class="on oo op"><p id="41c9" class="ku kv lq kw b kx ky jo kz la lb jr lc oq le lf lg or li lj lk os lm ln lo lp ig bi translated"><strong class="kw io"> <em class="in">重要提示:</em> </strong>如果您尝试在浏览器中将这些节点记录到<strong class="kw io"><em class="in">JavaScript</em></strong><strong class="kw io"><em class="in">控制台</em> </strong>中，您会收到一条错误消息。这是因为我们到目前为止创建的每个<strong class="kw io"> <em class="in">助手函数</em> </strong>都是由<strong class="kw io"> <em class="in">回调函数</em> </strong>调用的<strong class="kw io"> <em class="in">事件监听器</em> </strong>我们还没有编码。</p></blockquote><p id="492b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们现在已经完成了由<strong class="kw io">数组</strong>和3个<strong class="kw io">辅助函数组成的基础设施。</strong></p><blockquote class="on oo op"><p id="8c91" class="ku kv lq kw b kx ky jo kz la lb jr lc oq le lf lg or li lj lk os lm ln lo lp ig bi translated"><strong class="kw io"> <em class="in">抛开一个重要的:</em> </strong> <em class="in"> </em>你会注意到，在<code class="fe nz oa ob oc b"><strong class="kw io">appendParagraphs()</strong></code> <strong class="kw io"> <em class="in">函数</em> </strong>中，我们有一个完全抽象的<strong class="kw io"> <em class="in">函数</em> </strong>即<strong class="kw io"> <em class="in">解耦</em> </strong>。</p><p id="e445" class="ku kv lq kw b kx ky jo kz la lb jr lc oq le lf lg or li lj lk os lm ln lo lp ig bi translated">虽然所有的<strong class="kw io"> <em class="in">助手函数</em> </strong> <em class="in">，</em>都可以这样做，但为了简洁起见，我还是举了这个例子。这种<strong class="kw io"> <em class="in">将函数</em> </strong>从它们所操作的数据中分离出来的技术使得代码更加可重用，并且应该在公共应用程序版本中作为一条规则来实践。</p></blockquote><h1 id="2bb9" class="ly lz in bd ma mb ot md me mf ou mh mi jt ov ju mk jw ow jx mm jz ox ka mo mp bi translated">下一步是什么？</h1><p id="7987" class="pw-post-body-paragraph ku kv in kw b kx mq jo kz la mr jr lc ld ms lf lg lh mt lj lk ll mu ln lo lp ig bi translated">当你成功完成上述所有步骤后，你可以继续我们教程的第三部分也是最后一部分— <a class="ae kt" href="https://rhieger-98255.medium.com/regular-expressions-a-rite-of-passage-completing-the-application-526589605075" rel="noopener"> <strong class="kw io"> <em class="lq">正则表达式—成年礼:完成应用</em> </strong> </a> <strong class="kw io"> <em class="lq">。</em> </strong></p><p id="e6e1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">更多内容请看</em><strong class="kw io"><em class="lq"/></strong><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lq">说白了。报名参加我们的</em><strong class="kw io"><em class="lq"/></strong><a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lq">免费每周简讯</em> </strong> </a> <em class="lq">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lq">Twitter</em></strong></a><em class="lq">和</em><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lq">LinkedIn</em></strong></a><em class="lq">。查看我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="lq">社区不和谐</em> </strong> </a> <em class="lq">加入我们的</em> <a class="ae kt" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="lq">人才集体</em> </strong> </a> <em class="lq">。</em></strong></a></p></div></div>    
</body>
</html>