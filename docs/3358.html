<html>
<head>
<title>Let’s Understand Chrome V8: Understanding Bytecode and How to Debug it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来理解Chrome V8:理解字节码以及如何调试它</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-understand-chrome-v8-understanding-bytecode-and-how-to-debug-it-2e470db67ba5?source=collection_archive---------11-----------------------#2022-08-22">https://javascript.plainenglish.io/lets-understand-chrome-v8-understanding-bytecode-and-how-to-debug-it-2e470db67ba5?source=collection_archive---------11-----------------------#2022-08-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7e94" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">先来了解一下Chrome V8(第18章):字节码的细节。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2229cb027639f57877eb360bf75cd927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCFNVeb4ds9hl7WF-NP-kw.png"/></div></div></figure><p id="35cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">欢迎阅读</em> <a class="ae ll" href="https://medium.com/@huidou" rel="noopener"> <em class="lk">其他章节让我们来了解一下Chrome V8 </em> </a></p><p id="9f88" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">字节码是用CodeStubAssembler (CSA)实现的，可以粗略地看作一个程序集。字节码在V8启动时以反序列化的方式加载，没有符号表。所以我想告诉你:CAS在静态分析中是晦涩难懂的。而且，我们在调试中无法得到字节码的源代码。本文将讨论如何在汇编级别调试字节码，并查看其执行细节。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lm"><img src="../Images/f90eb0c9c6dae8457e5c2bbfd1e5dadd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ooelvpSvkXKnrm1zxQRnfw.png"/></div></div></figure><p id="a40c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">图1显示了字节码的解释器。该图对于JavaScript开发人员来说已经足够详细了。但是对于V8学习者来说，图1缺少很多细节，例如:点火启动、加载字节码和分派。让我们调试字节码来深入了解这些细节。</p><h1 id="fe21" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated"><strong class="ak"> 1。准备工作</strong></h1><p id="2065" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated"><strong class="kq io">注:</strong>在调试之前，你最好了解一下栈帧，字节码和寄存器的编码，<a class="ae ll" href="https://medium.com/@huidou/lets-understand-chrome-v8-chapter-7-stack-frame-bb3fa3b7ad5" rel="noopener">看这里</a>。</p><p id="44da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是调试前的最后一个C++函数Invoke。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7fc8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第14到23行初始化将要执行的JSFunction，也就是您的JavaScript代码。以下是你应该记住的五个重要成员。这些成员可以帮助您在调试中定位您的位置。它们在一个调试上下文中是不变，但是在不同的调试中是不同的。</p><p id="ad5b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> (1) </strong>第7行，<em class="lk">代码</em>，是Builtin::JSEntry指针，现在值是1FA 0E06 ED30(在我的调试上下文中)。</p><p id="2e57" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> (2) </strong>第18行，<em class="lk"> stub_entry </em>，是点火的入口。下面是从Builtin::JSEntry获取stub_entry的函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c88a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">条目是1FA 1326 1840。</p><p id="cbdf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> (3) </strong> Line21，<em class="lk"> func </em>，它是JSFunction的地址，也就是你的JavaScript代码。值为16 2BD8 15A9。</p><p id="5723" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">(4)</strong>Builtin::InterpreterEntryTrampoline的地址是52 61C0 8A41。</p><p id="e8bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">(5)</strong>dispatch _ table为1FA 0E08 CFB0。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mm"><img src="../Images/9055ff4cc0779faa8e47e6b179c89169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANKcb9XgiAsUT6V9KqU_1Q.png"/></div></div></figure><p id="4073" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">图2是进入字节码的调用栈。</p><h1 id="af7f" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated"><strong class="ak"> 2。调试字节码</strong></h1><p id="cb95" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">让我们从进入stub_entry开始调试字节码。调用()。很抱歉，我不能一行一行地解释，因为汇编代码没有上下文。我认为最好的方法是给出点火执行过程中的重要状态。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/f3f7d78af561148d6e992a8d222d1ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jwy5i9JFF0LBciopDGSjPA.png"/></div></div></figure><p id="a244" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在图3中，寄存器RCX是1FA 1326 1840(stub_entry)。我提到过，stub_entry是点火的入口。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/1eb0fc806f20e3d65f7a6b7622e4e2ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fi0RC465voZI61NHqshKg.png"/></div></div></figure><p id="089c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在图4中，寄存器RBX是1FA0E068A00，这是stub_entry的第一个参数。调用()，即isolate-&gt; isolate _ data()-&gt; isolate _ root()。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/68f79dbbc8c4ae8d843d26ea04114023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUBI-Tf8z4AiiqfTuTk2rg.png"/></div></div></figure><p id="49d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">图5是移动R8和调用RSI。寄存器R8是func，RSI是stub_entry，下面是stub_entry指向的函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="15b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第12到37行中，我们可以看到它们与图6中的汇编代码相同。实际上，Generate_JSEntryVariant正在执行。Builtin:JSEntry负责按std::call标准组织参数。稍后，函数Builtin::InterpreterEntryTrampoline将使用这些参数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/0908f49f029cd06f593c1f3be2ce9442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*owEuacwDHF3KvfsMmJN34A.png"/></div></figure><p id="6afc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">builtin::InterpreterEntryTrampoline在dispatch_table中查找以找到目标字节码并调用它，如图7所示。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/c153b4170333dba851a1046144edd2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VoCqKc4z_AdGSOfH6qhQhA.png"/></div></div></figure><p id="8276" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们更深入地研究一下调度，参见图7。</p><ul class=""><li id="3efe" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj mx my mz na bi translated">标记1:机器寄存器R15是dispatch_table。</li><li id="d464" class="ms mt in kq b kr nb ku nc kx nd lb ne lf nf lj mx my mz na bi translated">mark 2:计算目标字节码地址，也就是dispatch_table +字节码的编码。</li><li id="d44b" class="ms mt in kq b kr nb ku nc kx nd lb ne lf nf lj mx my mz na bi translated">mark 3:调用目标字节码。</li></ul><p id="cdb3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我的例子中，目标字节码是LdaConstant。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="77e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当LdaConstant退出时，在dispatch_table中查找下一个字节码，如图8所示。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/6bc46a61294e42ef2739067a74cd0a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hyEdcyITfvZqU6W0dWjNg.png"/></div></div></figure><p id="d830" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在汇编级别，我们可以看到点火启动和字节码执行，这可以帮助我们更好地理解V8解释器。</p><p id="8fdf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，这部分就到此为止了。下次再见，保重！</p><p id="0204" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何问题，请联系我。<strong class="kq io">微信</strong> : qq9123013 <strong class="kq io">邮箱</strong>:<a class="ae ll" href="mailto:v8blink@outlook.com" rel="noopener ugc nofollow" target="_blank">v8blink@outlook.com</a></p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="ee48" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容看</em> <a class="ae ll" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">说白了。报名参加我们的</em> <a class="ae ll" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。关注我们关于</em> <a class="ae ll" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">推特</em> </strong> </a>，<a class="ae ll" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">，</em><a class="ae ll" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">YouTube</em></strong></a><em class="lk">，以及</em> <a class="ae ll" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">不和</em> </strong> </a> <em class="lk">。</em></strong></a></p></div></div>    
</body>
</html>