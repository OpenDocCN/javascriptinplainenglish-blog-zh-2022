<html>
<head>
<title>Improve Pagination Search with Node.js and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js和MongoDB改进分页搜索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improve-pagination-search-with-node-js-and-mongodb-ac38795d9ddd?source=collection_archive---------1-----------------------#2022-02-20">https://javascript.plainenglish.io/improve-pagination-search-with-node-js-and-mongodb-ac38795d9ddd?source=collection_archive---------1-----------------------#2022-02-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f7795ecde59e9c11ac53bf9a7373f690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PVy1td33SrzwuLkL"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@martinshreder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin Shreder</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4d25" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们列出数据时，一个好的实践是对来自服务器的结果进行分页，并为客户端创建一种请求新页面(更多元素)的方式。</p><p id="b246" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用Node.js和MongoDB时，有两种创建分页的常见模式:</p><ul class=""><li id="aec3" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">在查询数据时使用<code class="fe lh li lj lk b">.skip(X).limit(Y)</code>:基本上我们定义一个每页的大小(“限制”)并计算“跳过”值</li><li id="dda3" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">使用<code class="fe lh li lj lk b">{_id: {$lt: FIRST_MONGO_ID, $gt: LAST_MONGO_ID}}</code>和<code class="fe lh li lj lk b">.sort(_id: -1}</code>:这里我们保留了第一个和最后一个显示元素的引用，并且总是在这些值之间寻找元素</li></ul><p id="7f35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些文章谈到了这一点:</p><ul class=""><li id="b712" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><a class="ae jz" href="https://docs.mongodb.com/manual/reference/method/cursor.skip/#pagination-example" rel="noopener ugc nofollow" target="_blank">https://docs . MongoDB . com/manual/reference/method/cursor . skip/# pagination-example</a></li><li id="f5ec" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated"><a class="ae jz" href="https://medium.com/swlh/mongodb-pagination-fast-consistent-ece2a97070f3" rel="noopener">https://medium . com/swlh/MongoDB-pagination-fast-consistent-ece2a 97070 f 3</a></li><li id="88e1" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated"><a class="ae jz" href="https://www.codementor.io/@arpitbhayani/fast-and-efficient-pagination-in-mongodb-9095flbqr" rel="noopener ugc nofollow" target="_blank">https://www . code mentor . io/@ arpitbhayani/fast-and-efficient-pagination-in-MongoDB-9095 flbqr</a></li></ul><p id="798c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的问题是:来自两个不同mongo集合的分页元素列表，一个有大约400.000个元素，另一个有将近200万个元素。随着元素数量的增加，请求时间也会增加。让我们来看一些数字。</p><p id="cd43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于第一页:</p><ul class=""><li id="ce55" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">请求时间:16.37秒</li><li id="f4b1" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">回应:<code class="fe lh li lj lk b">{items: [...], page: 1, pageSize: 10, total: 14225}</code></li></ul><p id="6c4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一页:</p><ul class=""><li id="c4d4" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">请求时间:37.61秒</li><li id="0b99" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">回应:<code class="fe lh li lj lk b">{items: [...], page: 1426, pageSize: 10, total: 14255}</code></li></ul><p id="7d61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于实施的一些细节:</p><ul class=""><li id="c627" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><code class="fe lh li lj lk b">skip</code> + <code class="fe lh li lj lk b">limit</code>是这里使用的分页策略</li><li id="0132" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">我们计算与查询匹配的元素总数，即使我们只返回定义的页面大小*我们每次想要返回的页面数量</li></ul></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="b307" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">改进是基于功能和技术的变化。</p><p id="a1d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">的功能变化</strong>是基于如何处理一长串结果。就像当你在google中寻找一些过于普通的东西时，一开始你不会得到所有可用的页面(元素的总数)，但你会得到一定数量的页面，当你在列表中前进时，你会得到新的页面(其他数量的元素)。这完全有道理，因为你会为一些可能不需要的东西付出高昂的代价(计算所有可用元素的时间)。如果有太多的元素，您应该改进搜索条件，减少元素数量。</p><p id="3873" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">的技术变化</strong>与Mongo如何执行搜索以及我们如何处理数据有关。一些需要更改或验证的内容:</p><ul class=""><li id="061f" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">拥有正确的索引，并基于这些字段执行查询</li><li id="32c6" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">在查询中使用投影。不要从集合中获取所有元素。只获取列表需要的属性(当您需要其余的属性时，只需通过id执行一个简单的查询并获取它们)</li><li id="c835" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">每次我们寻找有限数量的元素来更新总数，在我的例子中是100个元素(这意味着10页10个元素)。代码类似于</li></ul><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/4b959ea854e3ea7058e104f7eb912bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8BSLEdrrhbN3ajdXAtewA.png"/></div></div></figure><p id="b540" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看请求时间的改进</p><p id="abfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于第一页:</p><ul class=""><li id="5ee1" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">请求时间:732毫秒</li><li id="9b49" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">回复:<code class="fe lh li lj lk b">{items: [...], page: 1, pageSize: 1, total: 100}</code></li></ul><p id="85e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于最后一个可见页面(加载时将出现此页面):</p><ul class=""><li id="05b0" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">请求时间:1.87秒</li><li id="937d" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">回复:<code class="fe lh li lj lk b">{items: [...], page: 20, pageSize: 10, total: 542}</code></li></ul><p id="f607" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很明显，改进非常大，对客户来说也是生产力。</p><p id="ee7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，正如我们在这里看到的，功能性的改变比技术性的改变更重要。每次，我们都需要评估我们将如何使用技术来为用户获得最佳解决方案。在这种情况下，减少显示数据的时间比告诉用户我们总共有多少个元素更重要(我们有太多元素，所以它没有正确的时序响应重要)。我们不需要每次都进行重大而复杂的技术变革，也许我们需要更多地“跳出框框思考”。</p><p id="14d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望这对某人有所帮助。</p><p id="3f2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mc">说白了就是io </em> </strong> </a> <em class="mc">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mc">免费周报</em> </strong> </a> <em class="mc">。在我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mc">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="mc">。</em></p></div></div>    
</body>
</html>