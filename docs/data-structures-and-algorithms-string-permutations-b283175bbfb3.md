# 数据结构和算法:字符串排列

> 原文：<https://javascript.plainenglish.io/data-structures-and-algorithms-string-permutations-b283175bbfb3?source=collection_archive---------5----------------------->

![](img/b21660ade6174263c8bcf4184973e89e.png)

Photo by [Arnold Francisca](https://unsplash.com/@clark_fransa?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

对面试进行编码可能会面临许多挑战。不管你喜不喜欢，数据结构和算法问题在软件开发的过程中仍然很常见。申请足够多的工作，你很可能会遇到这样的问题:

*给定一个字符串，返回该字符串的所有唯一排列*

起初看起来很简单，但很快就会明白，在表面之下隐藏着一些复杂性。让我们看看这个问题是什么，它带来的挑战以及它是如何解决的。

让我们从理解问题的要求开始:字符串的所有唯一排列。排列是事物顺序的变化。关于这个问题，排列是一个包含所有相同字符但顺序不同的新字符串。例如，给定字符串“abc”，排列将是:

“abc”、“acb”、“bac”、“bca”、“cab”、“cba”

期望的结果是给定字符串的所有不同字母组合。让我们分解这个问题并解决它。

查看“abc ”,对结果进行更仔细的检查显示，不同的组合是通过取一个字母，将其移动到前面，然后将其余字母的不同组合附加到上面来实现的。

以" a "作为前导字母，其余两个字母" bc "将有两种可能的组合，" bc "和" cb "，从而产生" abc "和" acb "。

移至" b "作为前导字母，其余字母" ac "可重新排列为" ac "或" ca "，从而产生" bac "和" bca "。

最后，前导字母" c "具有剩余的字母" ab "和" ba "，导致出现" cab "和" cba "。

这种方法可以分解为对给定字符串中的每个字母进行迭代，将其保存为前导字符，然后对剩余的字母进行迭代，得到它们的不同组合，并将这些组合附加到前导字符上。这需要大量的迭代。在 for 循环中编写 for 循环可能很难阅读，所以这是使用递归的好时机。递归是一个在满足中断条件之前调用自身的函数。

`countdown`函数用一个每次调用都减 1 的参数调用自己。这一直持续到数字小于 1，函数返回，递归结束。这是休息状态。

回到字符串排列问题，我们将迭代每一个字符串，取当前迭代值的字母(我们称之为`char`)，然后用递归得到剩余字母的所有组合，并将其附加到`char`。结果将被推入一个数组中。

因为我们使用了递归，所以这个函数从一个中断条件开始。递归调用都使用剩余的字母作为参数来获得它们的各种组合。如果只提供了一个字母(`if(str.length < 2)`)，那么只能有一个组合，因此递归被停止，返回单个字母。

接下来我们有一个数组(`permutations`)来存储结果。

现在迭代给定的字符串，将位于`str[i]`的字母赋给变量`char`。既然我们知道了`char`的索引，那么`slice()`就可以用来得到剩余的字母，并把它们赋给`remainingChars`。剩余的字母将用作递归函数调用中的参数。

再次使用“abc”，在调用`getPermutations("abc")`时，第一次迭代将产生`char = "a"`和`remainingChars = "bc"`。我们现在到达函数中的递归部分:

for…of 语句迭代递归函数调用的每个返回值，它们被追加到`char`中，此时为“a”并被推送到`permutations`数组中。`remainingChars`中的字母当前是“bc ”,因此第一次递归调用等同于`getPermutations("bc")`,它将迭代这些字母，将它们分开，并再次递归调用函数，直到满足中断条件，剩下“bc”和“cb”被附加到“a”并被推送到`permutations`数组。

对给定字符串中的每个字母重复这一过程，得到一个有六种排列的数组。

这个函数是有效的，但是还需要考虑一些其他的东西。在“abc”的例子中，字符串中的每个字母都是不同的。如果字符串有重复字符会怎么样？

记住问题状态，找出所有 ***唯一的*** 排列。让我们来解决这个问题。我们需要一种方法来检查`char`的当前值是否已经被使用。还有其他方法可以实现这一点，但我发现`indexOf()`方法在这里工作得很好，因为它检查给定值的第一个索引。

现在我们有一个条件来检查`char`的值之前是否已经被使用过。如果有，从`indexOf()`返回的索引将低于循环中的当前索引，我们使用`continue`跳到下一次迭代。

很好，现在每个排列只出现一次，我们已经满足了问题的要求。这是全部功能的排列组合。

这个问题在编码面试中经常出现。仅仅因为这个原因而学习是有好处的，但是理解如何解决这个问题也有其他好处。例如，这是学习递归以及何时使用递归的好方法。它还有助于编码人员注意和处理边缘情况。研究它，理解它，把你学到的东西带到下一次面试或项目中去！

*更多内容尽在* [***说白了. io***](https://plainenglish.io/) *。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。关注我们关于* [***推特***](https://twitter.com/inPlainEngHQ) *和*[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*。查看我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *加入我们的* [***人才集体***](https://inplainenglish.pallet.com/talent/welcome) *。*