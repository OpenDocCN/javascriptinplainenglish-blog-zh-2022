<html>
<head>
<title>Do zip compression/decompression on the front end</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对前端进行压缩/解压缩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/do-zip-compression-decompression-on-the-front-end-7b0ea0931c04?source=collection_archive---------6-----------------------#2022-12-15">https://javascript.plainenglish.io/do-zip-compression-decompression-on-the-front-end-7b0ea0931c04?source=collection_archive---------6-----------------------#2022-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aac98bc492cb778c9baf9f5d046df053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vb6uysv324n3MvQvTAbM7g.png"/></div></div></figure><p id="0613" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不久前，当我研究前端如何解析excel表单时，我了解了jszip库，它可以在前端直接压缩和解压缩zip包。让我们看看如何使用。</p><h2 id="cc2a" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">使用</h2><p id="3080" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">更不用说安装了，只需要npm直接安装jszip。</p><h2 id="b5c5" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">读取本地文件</h2><p id="a485" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">要读取本地zip文件，我们只需要使用loadAsync传入一个文件对象，首先创建一个用于选择文件的文件输入:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="3b07" class="md kx iq lz b be me mf l mg mh">&lt;input type="file" id="file" name="file" /&gt;</span></pre><p id="2fe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在文件选择之后，我们调用loadAsync来读取文件内容:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="fb3a" class="md kx iq lz b be me mf l mg mh">document.querySelector('#file').addEventListener('change', async e =&gt; {<br/>    const file = e.target.files[0];<br/>    if (!file) return;<br/>    const zip = await JSZip.loadAsync(file);<br/>});</span></pre><p id="2250" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">读取完成后，我们可以在返回的zip对象的files属性中看到压缩包中的所有文件:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="926b" class="md kx iq lz b be me mf l mg mh">const zip = {<br/>    files: {<br/>        'Hello.txt': ZipObject,<br/>        'images/': ZipObject,<br/>        'images/smile.gif': ZipObject<br/>    }<br/>};</span></pre><p id="0ed9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的文件和文件夹都会按照路径挂在文件中，zipport包含文件压缩信息，但是需要注意的是，文件的内容在这个时候仍然是压缩的，所以我们不能把它当作一个普通的文件。要使用这个文件，我们需要在使用它之前进行第二次转换。例如，如果我们想读取上面Hello.txt中的内容，我们可以首先将其转换为blob对象，然后使用文件阅读器读取它:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="6a7d" class="md kx iq lz b be me mf l mg mh">const txtBlob = await zip.files['Hello.txt'].async('blob');<br/>const fileReader = new FileReader();<br/>file.onload = r =&gt; console.log(r.target.result);<br/>reader.readAsText(f);<br/>// log: Hello World\n</span></pre><p id="8008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们也可以直接使用内置的方法直接转换成字符串:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="5551" class="md kx iq lz b be me mf l mg mh">const text = await zip.files['Hello.txt'].async('string');</span></pre><p id="a5d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器端，jszip支持以下数据类型:</p><ul class=""><li id="333d" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><code class="fe mr ms mt lz b">array</code></li><li id="00ec" class="mi mj iq ka b kb mu kf mv kj mw kn mx kr my kv mn mo mp mq bi translated"><code class="fe mr ms mt lz b">arraybuffer</code></li><li id="6c20" class="mi mj iq ka b kb mu kf mv kj mw kn mx kr my kv mn mo mp mq bi translated"><code class="fe mr ms mt lz b">base64</code></li><li id="001a" class="mi mj iq ka b kb mu kf mv kj mw kn mx kr my kv mn mo mp mq bi translated"><code class="fe mr ms mt lz b">blob</code></li><li id="6c6a" class="mi mj iq ka b kb mu kf mv kj mw kn mx kr my kv mn mo mp mq bi translated"><code class="fe mr ms mt lz b">string</code></li><li id="df2c" class="mi mj iq ka b kb mu kf mv kj mw kn mx kr my kv mn mo mp mq bi translated"><code class="fe mr ms mt lz b">uint8array</code></li></ul><p id="d238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在节点方面，jszip还支持nodebuffer和nodestream。</p><h2 id="77d8" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">读取远程文件</h2><p id="bb92" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">除了读取本地文件，jszip还支持读取远程zip文件:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="e073" class="md kx iq lz b be me mf l mg mh">new Promise(function (resolve, reject) {<br/>    JSZipUtils.getBinaryContent('/jszip/test/ref/text.zip', function (err, data) {<br/>        if (err) {<br/>            reject(err);<br/>        } else {<br/>            resolve(data);<br/>        }<br/>    });<br/>})<br/>    .then(JSZip.loadAsync)<br/>    .then(function (zip) {<br/>        return zip.file('Hello.txt').async('string');<br/>    });</span></pre><p id="deaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里使用zip.file方法读取文件，这与上面使用文件读取的方法相同。官方的JSZipUtils.getBinaryContent函数可以直接获取远程文件进行读取，而且这个包非常方便。</p><h2 id="0c8f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">压缩文件</h2><p id="83d7" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">除了上面提到的解压缩文件，jszip还支持在浏览器端直接压缩文件。首先，我们需要实例化一个zip对象:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="9e4a" class="md kx iq lz b be me mf l mg mh">const zip = new JSZip();<br/>zip.file('Hello.txt', 'Hello world\n');</span></pre><p id="324c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过文件向对象添加文件，然后通过generateAsync生成blob文件:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="c5d3" class="md kx iq lz b be me mf l mg mh">const blob = await zip.generateAsync({ type: 'blob' });</span></pre><p id="4b9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文件生成后，可通过文件的另存为直接下载文件保存:</p><pre class="lu lv lw lx gt ly lz ma bn mb mc bi"><span id="d34b" class="md kx iq lz b be me mf l mg mh">saveAs(blob, 'hello.zip');</span></pre><h2 id="05c8" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">压缩解压缩原理</h2><p id="ce4d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让我们谈谈压缩和解压缩的原理。由于我对压缩和解压缩算法没有太多的研究，我不打算在这里谈论太多深入的内容。我只是去了解相关内容。这里有一个简单的声明:压缩主要是通过合并连续的字符来完成的。压缩，可以简单地认为，例如，当遇到像44444999999这样的字符时，zip压缩会将其压缩为4，5，9，6的形式，从而达到压缩的目的。当然，实际的算法比这个复杂得多。</p><p id="01ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其实压缩和解压缩都没有web盲点，只是算法复杂，但是使用的能力比较基础，只能把文件数据取出来，然后再进行解析，所以前端确实是可以实现的。而且因为前端压缩解压场景太少，这也是为什么很少有人知道前端可以做压缩解压，根本没想过的原因。</p><h2 id="1f51" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">要使用的场景</h2><p id="7164" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在实际业务需求中，前端很少用于压缩或解压缩。个人能想到的实际使用场景如下:</p><ul class=""><li id="3a97" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">在线压缩和解压缩工具网站</li><li id="660d" class="mi mj iq ka b kb mu kf mv kj mw kn mx kr my kv mn mo mp mq bi translated">解析excel文件和其他依赖zip压缩的文件</li><li id="0dc5" class="mi mj iq ka b kb mu kf mv kj mw kn mx kr my kv mn mo mp mq bi translated">工具网站上传zip包资源解析及使用</li></ul><h2 id="ca1d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">总结</h2><p id="49b1" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">总的来说，jszip的API设计还是很不错的。很好用，没有那么多麻烦的事情。另外用Promise配合async/await真的很好。如果以后遇到需要的场景会是一个不错的选择。</p><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-parse-excel-files-with-javascript-114752b6aa1d"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">如何用JavaScript解析Excel文件</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">今天就来说说如何用JS解析excel文件。当然，用库没什么意思，比如…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nl l"><div class="nm l nn no np nl nq jw nc"/></div></div></a></div><p id="3f3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nr">更多内容请看</em><a class="ae ns" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nr">plain English . io</em></strong></a><em class="nr">。报名参加我们的</em> <a class="ae ns" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nr">免费周报</em> </strong> </a> <em class="nr">。关注我们关于</em><a class="ae ns" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nr">Twitter</em></strong></a><a class="ae ns" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nr">LinkedIn</em></strong></a><em class="nr"/><a class="ae ns" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nr">YouTube</em></strong></a><em class="nr"/><a class="ae ns" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nr">不和</em> </strong> </a> <strong class="ka ir"> <em class="nr">。</em>T49】</strong></p><p id="d004" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="nr">对缩放您的软件启动感兴趣</em> </strong> <em class="nr">？检查</em> <a class="ae ns" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nr">电路</em> </strong> </a> <em class="nr">。</em></p></div></div>    
</body>
</html>