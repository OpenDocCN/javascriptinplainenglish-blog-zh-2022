<html>
<head>
<title>Deep Cloning with structuredClone() in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript中的structuredClone()进行深度克隆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deep-cloning-with-structuredclone-in-javascript-f94a106914b1?source=collection_archive---------1-----------------------#2022-04-22">https://javascript.plainenglish.io/deep-cloning-with-structuredclone-in-javascript-f94a106914b1?source=collection_archive---------1-----------------------#2022-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/234ed3b693f06658d2d26c0d084348fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktOh-3QsYQvov66wOteXNw.jpeg"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="4164" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">普通JavaScript中的<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lb">深度克隆</em> </strong> </a>由来已久，在JavaScript中深度克隆对象的下一个最佳方法是使用<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lb">spread</em></strong></a><code class="fe lc ld le lf b">(...)</code>操作符。spread <code class="fe lc ld le lf b">(...)</code>操作符只会创建对象的深度副本，直到级别1。另一方面，嵌套对象遵循了<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lb">的概念，浅层复制了</em> </strong> </a> <strong class="ke io"> <em class="lb">。</em>T24】</strong></p><p id="6588" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">下图是使用扩展<code class="fe lc ld le lf b">(...)</code>操作符深度克隆一个对象的例子:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="db0c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在上面的例子中，<strong class="ke io"> <em class="lb">名字</em> </strong>和<strong class="ke io"> <em class="lb">姓氏</em> </strong>得到了对两个对象具有不同值的深层副本——<strong class="ke io"><em class="lb">虚构字符</em> </strong>和<strong class="ke io"> <em class="lb">克隆的虚构字符。</em> </strong></p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/905499487baa404587008f572d295943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErFlDm06n03iUydbzwSoiw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Deep copy with level 1 object keys</figcaption></figure><p id="fd50" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">然而，<strong class="ke io">地址</strong>对象中的<strong class="ke io"> <em class="lb">国家</em> </strong>键得到一个浅拷贝，这意味着只有引用被拷贝，但它指向内存中的相同位置。因此，两个对象中的<strong class="ke io"> <em class="lb">国家</em> </strong>都改为<strong class="ke io"> <em class="lb">美国</em> </strong>。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/d34ff9da9a2fb31cedb974db5b214be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yP_qB4OwEEihTsvW3aXZ7g.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Shallow Copy with nested objects</figcaption></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="f809" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">虽然我们有深度克隆方法，如第三方JS库提供的<a class="ae la" href="https://lodash.com/docs/#cloneDeep" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lb">cloneDeep</em></strong></a>，如<a class="ae la" href="https://lodash.com/docs/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lb">loadash</em></strong></a><strong class="ke io"><em class="lb"/></strong>或通过编写<code class="fe lc ld le lf b">JSON.parse(JSON.stringify(originalObject))</code>使用基于JSON的hack，它们支持嵌套对象的深度克隆，但这是有代价的， 现在，我们可以使用现成可用的<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lb">结构克隆</em> </strong> </a>作为JavaScript的一部分，而不必在任何JS应用程序中安装额外的依赖项，如<a class="ae la" href="https://lodash.com/docs" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lb">loadash</em></strong></a><strong class="ke io"><em class="lb"/></strong>。</p><p id="35f6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">根据<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lb">MDN</em></strong></a>网站上的定义，</p><blockquote class="lr ls lt"><p id="a0d4" class="kc kd lb ke b kf kg kh ki kj kk kl km lu ko kp kq lv ks kt ku lw kw kx ky kz ig bi translated">全局<code class="fe lc ld le lf b">structuredClone()</code>方法使用<strong class="ke io"><em class="in"/></strong><a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="in">结构化克隆算法</em> </strong> </a> <strong class="ke io"> <em class="in">创建给定值的<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="in">深度克隆</em> </strong> </a>】。它兼容所有的现代浏览器。</em></strong></p></blockquote><p id="54b7" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">下图是使用<code class="fe lc ld le lf b">structuredClone()</code>方法深度克隆一个对象的例子:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="f818" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">克隆的结果是:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/68f086f6b65b58334794f2e099a73fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i48eyqwIrvGHkNevI0pW0g.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Output using structuredClone</figcaption></figure><p id="daee" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io"><em class="lb">structured clone()</em></strong>方法也允许<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lb">可转移对象</em> </strong> </a>中的原始值被<em class="lb">转移</em>而不是克隆到新对象中。转移的对象从原始对象分离并附加到新对象；它们在原始对象中不再可用。</p><p id="f1c6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">使用<code class="fe lc ld le lf b">structuredClone()</code>可以复制大部分内置值。将这种方法用于一些原始类型(如RegExp)仍然有一些缺点。更多请参考本<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lb"> MDN链接</em> </strong> </a></p><p id="dc3a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">然而，在大多数情况下，就像上面举例说明的那样，它应该工作得很好。</p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h1 id="c620" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">结论</h1><p id="e879" class="pw-post-body-paragraph kc kd in ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ig bi translated">现在我们有了。我希望这篇文章对你有用。感谢您的阅读。请随时提供您的意见、建议和任何其他可能有帮助的反馈。</p><p id="8782" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><em class="lb">更多内容看</em> <a class="ae la" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lb">说白了。报名参加我们的</em> <a class="ae la" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lb">免费周报</em> </strong> </a> <em class="lb">。关注我们关于</em><a class="ae la" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lb">Twitter</em></strong></a><em class="lb">和</em><a class="ae la" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lb">LinkedIn</em></strong></a><em class="lb">。加入我们的</em> <a class="ae la" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="lb">社区</em> </strong> </a> <em class="lb">。</em></strong></a></p></div></div>    
</body>
</html>