<html>
<head>
<title>Arrow Functions Vs. Regular Functions in JavaScript — A Comprehensive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的箭头函数与常规函数——综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/arrow-functions-vs-regular-functions-in-js-fa1a1f235c86?source=collection_archive---------7-----------------------#2022-07-05">https://javascript.plainenglish.io/arrow-functions-vs-regular-functions-in-js-fa1a1f235c86?source=collection_archive---------7-----------------------#2022-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8451" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中箭头函数和普通函数的比较</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1297af07a28d95409fc9904a61802186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awCpF-akFw69OrK7pTA1gA.png"/></div></div></figure><p id="97c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">箭头函数是ECMAScript 6(ES6)中引入的一个奇妙特性。ES6发布于2015年。2017年开始了我的开发者生涯。所以当我写我的第一个JavaScript程序时，箭头函数就在其中。在我个人看来，我更喜欢尽可能地使用箭头函数。原因是，当我们与常规函数进行比较时，带有箭头函数的代码是清晰易读的，而且我对使用箭头函数感到很舒服。</p><p id="1268" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果箭头函数很容易实现，那么常规函数就不可能被箭头函数完全取代。有些情况下我们必须使用常规函数。所以阿罗函数并不是包治百病的良药。</p><p id="90ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">“箭头函数和普通函数有什么区别？”</em> </strong>是JavaScript面试中普遍存在的问题。所以如果你的目标是掌握JavaScript，不要错过这个内容。</p><p id="a808" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们从基本的事情开始，然后讨论这个话题的高级项目。</p><p id="6b08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们使用关键字<code class="fe ll lm ln lo b">function</code>定义的函数称为常规函数。我们可以用两种方式定义正则函数:</p><ol class=""><li id="2beb" class="lp lq in kq b kr ks ku kv kx lr lb ls lf lt lj lu lv lw lx bi translated">函数声明</li><li id="af1c" class="lp lq in kq b kr ly ku lz kx ma lb mb lf mc lj lu lv lw lx bi translated">函数表达式</li></ol><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="70e3" class="mh mi in lo b gy mj mk l ml mm"><em class="lk">// Function declaration<br/></em>function sayHello(name) {<br/>   return `Hello ${name}`<br/>}</span><span id="15c9" class="mh mi in lo b gy mn mk l ml mm"><em class="lk">// Function expression<br/></em>const sayHello = function(name) {<br/>   return `Hello ${name}`<br/>}</span></pre><p id="8758" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以将上述常规函数定义为箭头函数，如下所示:</p><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="1ba9" class="mh mi in lo b gy mj mk l ml mm">const sayHello = (name) =&gt; `Hello ${name}`;</span></pre><p id="0a40" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">定义箭头函数时要遵循的准则。</p><ul class=""><li id="56f0" class="lp lq in kq b kr ks ku kv kx lr lb ls lf lt lj mo lv lw lx bi translated">当一个函数只有一个参数时，<code class="fe ll lm ln lo b">=&gt;</code>符号前的括号不是必需的。但是这个函数不仅仅需要参数；括号是强制性的。</li><li id="e8c6" class="lp lq in kq b kr ly ku lz kx ma lb mb lf mc lj mo lv lw lx bi translated">如果函数体只有一行表达式，则不需要在<code class="fe ll lm ln lo b">=&gt;</code>符号后使用花括号。如果不是这样，花括号是强制性的。</li></ul><p id="e2eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请参考下面的代码来阐明上述准则。</p><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="d72c" class="mh mi in lo b gy mj mk l ml mm">const add = (a, b) =&gt; a + b;</span><span id="37c5" class="mh mi in lo b gy mn mk l ml mm">const sayHello = name =&gt; `Hello ${name}`;</span><span id="7e9d" class="mh mi in lo b gy mn mk l ml mm">const someFunction = (x, y, z) =&gt; {<br/>  <em class="lk">// do some stuff<br/>  </em>...<br/>  return z;<br/>}</span></pre><p id="5a50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">基本的事情都做完了。现在，让我们进入正题。</em> </strong></p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h2 id="38d7" class="mh mi in bd mw mx my dn mz na nb dp nc kx nd ne nf lb ng nh ni lf nj nk nl nm bi translated"><strong class="ak">使用“this”关键字的不同行为</strong></h2><p id="2898" class="pw-post-body-paragraph ko kp in kq b kr nn jo kt ku no jr kw kx np kz la lb nq ld le lf nr lh li lj ig bi translated"><strong class="kq io"> <em class="lk">在常规函数中</em></strong><em class="lk"/><code class="fe ll lm ln lo b">this</code>关键字是动态的，这取决于执行上下文。</p><p id="d0c7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">在箭头函数中，</em></strong><code class="fe ll lm ln lo b">this</code>的行为与常规函数的<code class="fe ll lm ln lo b">this</code>行为有很大不同。<code class="fe ll lm ln lo b">this</code>的值总是等于外部函数的<code class="fe ll lm ln lo b">this</code>值，而不是定义自己的执行上下文。换句话说，<code class="fe ll lm ln lo b">this</code>是按词法解析的，不管arrow函数是如何执行的，也不管它在哪里执行。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="bb04" class="mh mi in lo b gy mj mk l ml mm">function myFunction() {<br/>  console.log(this); // global object<br/>}<br/>myFunction();</span></pre><p id="366f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在一个<strong class="kq io"> <em class="lk">简单调用</em> </strong>的过程中，就像上面的代码片段一样，<code class="fe ll lm ln lo b">this</code>等于<code class="fe ll lm ln lo b">global</code>对象。如果我们把<code class="fe ll lm ln lo b">myFunction</code>转换成一个箭头函数，效果也是一样的。</p><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="4f43" class="mh mi in lo b gy mj mk l ml mm">const myFunction = () =&gt; {<br/>  console.log(this); <em class="lk">// global object<br/></em>}<br/>myFunction();</span></pre><p id="3bb0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们在常规函数中使用<code class="fe ll lm ln lo b">new myFunction()</code>、<br/>执行一个<strong class="kq io"> <em class="lk">构造函数调用</em>、<br/>，<code class="fe ll lm ln lo b">this</code>等于新创建的<code class="fe ll lm ln lo b">myFunction {}</code>实例，但是如果我们对一个箭头函数执行同样的操作，它会给出一个错误<code class="fe ll lm ln lo b">TypeError: myFunction is not a constructor</code>。</strong></p><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="2875" class="mh mi in lo b gy mj mk l ml mm">function myFunction() {<br/>  console.log(this);   <em class="lk">// </em>myFunction {}<em class="lk"><br/></em>}<br/>// constructor invocation<br/>new myFunction();</span><span id="2ec4" class="mh mi in lo b gy mn mk l ml mm">const myFunction = () =&gt; {<br/>  console.log(this);   <em class="lk">// </em>TypeError: myFunction is not a constructor<em class="lk"><br/></em>}<br/>// constructor invocation<br/>new myFunction();</span></pre><p id="9d85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">所以，普通的函数可以用来构造对象，但是箭头函数不支持这一点，因为箭头函数是按照词汇来解析</em> </strong> <code class="fe ll lm ln lo b">this</code> <strong class="kq io"> <em class="lk">的。</em>T41】</strong></p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="1f0b" class="mh mi in lo b gy mj mk l ml mm">const dog = {<br/>  name: 'Lassie',<br/>  bark: function () {<br/>    console.log(this);   // { name: 'Lassie', bark: ƒ }<br/>  }<br/>}<br/>// Normal function method invocation<br/>dog.bark();</span><span id="2f11" class="mh mi in lo b gy mn mk l ml mm">const dog = {<br/>  name: 'Lassie',<br/>  bark: () =&gt; {<br/>    console.log(this);  // global object<br/>  },<br/>}<br/>// Arrow function method invocation<br/>dog.bark();</span></pre><p id="830b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io"> <em class="lk">方法调用期间</em> </strong>与上面的代码片段一样，在常规函数中，<code class="fe ll lm ln lo b">this</code>等于其拥有的对象，但是在箭头函数中，<code class="fe ll lm ln lo b">this</code>指的是外部函数的词法范围。在上面的代码片段中，<code class="fe ll lm ln lo b">this</code>等于<code class="fe ll lm ln lo b">global</code>对象，因为<code class="fe ll lm ln lo b">dog</code>对象是在脚本的根级别中声明的。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="df3c" class="mh mi in lo b gy mj mk l ml mm">const dogObject = { name: 'Lassie' };</span><span id="2944" class="mh mi in lo b gy mn mk l ml mm">// Normal Function<br/>function createDog() {<br/>  console.log(this); // { name: 'Lassie' }<br/>}<br/>createDog.call(dogObject);<br/>createDog.apply(dogObject);</span><span id="c491" class="mh mi in lo b gy mn mk l ml mm">// Arrow Function<br/>const createDog = () =&gt; {<br/>console.log(this); // global object<br/>};<br/>createDog.call(dogObject);<br/>createDog.apply(dogObject);</span></pre><p id="7665" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io"> <em class="lk">使用<code class="fe ll lm ln lo b">function.call(context)</code>或<code class="fe ll lm ln lo b">function.apply(context)</code>间接调用</em> </strong>时，在常规函数中，<code class="fe ll lm ln lo b">this</code>等于第一个参数；在上面的代码片段中，是<code class="fe ll lm ln lo b">dogObject</code>。在arrow函数中，<code class="fe ll lm ln lo b">this</code>的值不变，并且<code class="fe ll lm ln lo b">this</code>仍然按词法解析。在上面的代码片段中，<code class="fe ll lm ln lo b">this</code>等于<code class="fe ll lm ln lo b">global</code>对象，因为<code class="fe ll lm ln lo b">createDog</code>函数是在脚本的根级别中声明的。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h2 id="19bf" class="mh mi in bd mw mx my dn mz na nb dp nc kx nd ne nf lb ng nh ni lf nj nk nl nm bi translated">参数绑定</h2><p id="6ce8" class="pw-post-body-paragraph ko kp in kq b kr nn jo kt ku no jr kw kx np kz la lb nq ld le lf nr lh li lj ig bi translated">常规函数有参数绑定。这就是为什么我们可以在函数体内使用<code class="fe ll lm ln lo b">arguments</code>关键字来访问它们。但是箭头函数没有参数绑定。如果我们试图使用关键字<code class="fe ll lm ln lo b">arguments</code>访问这些文件，它会给出错误:<code class="fe ll lm ln lo b">ReferenceError: arguments is not defined</code>。<br/>参见下面的例子。</p><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="99dc" class="mh mi in lo b gy mj mk l ml mm">function x() {<br/>  console.log(arguments);<br/>  // [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]<br/>}<br/>x(1, 2, 3);</span><span id="3831" class="mh mi in lo b gy mn mk l ml mm">const y = () =&gt; {<br/>  console.log(arguments); <br/>  // ReferenceError: arguments is not defined</span><span id="bb39" class="mh mi in lo b gy mn mk l ml mm">}<br/>y(1, 2, 3);</span></pre><p id="e78b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是我们可以使用spread运算符访问arrow函数中的参数，如下所示:</p><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="8879" class="mh mi in lo b gy mj mk l ml mm">const y = (...n) =&gt; {<br/>  console.log(n);<br/>}<br/>y(1, 2, 3);</span></pre></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="9873" class="ns mi in bd mw nt nu nv mz nw nx ny nc jt nz ju nf jw oa jx ni jz ob ka nl oc bi translated">不应该使用箭头函数的地方</h1><ul class=""><li id="da65" class="lp lq in kq b kr nn ku no kx od lb oe lf of lj mo lv lw lx bi translated"><strong class="kq io"> <em class="lk">定义对象内部的函数。</em> </strong></li></ul><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="a5e7" class="mh mi in lo b gy mj mk l ml mm">const person = {<br/>  age: 30,<br/>  sayAge: () =&gt; {<br/>    console.log(`I am ${this.age} years old.`);<br/>    // I am <strong class="lo io">undefined</strong> years old.<br/>  },<br/>}<br/>person.sayAge();</span></pre><p id="4ce3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在你应该知道打印年龄的原因是<code class="fe ll lm ln lo b">undefined</code>😎。</p><ul class=""><li id="77f2" class="lp lq in kq b kr ks ku kv kx lr lb ls lf lt lj mo lv lw lx bi translated"><strong class="kq io"> <em class="lk">担任建造师</em> </strong></li></ul><pre class="kd ke kf kg gt md lo me mf aw mg bi"><span id="39f5" class="mh mi in lo b gy mj mk l ml mm">const Employee = () =&gt; {};<br/>const employee = new Employee(); <br/><em class="lk">// TypeError: Employee is not a constructor</em></span></pre><p id="afb6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注:</strong> <em class="lk">理解箭头函数和常规函数的区别有助于为特定需求选择正确的语法。</em></p><p id="9e6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">你知道什么是封闭吗？<br/>没有？然后看我之前的文章</em> </strong> <a class="ae og" href="https://medium.com/@sudarshanadayananda/what-is-a-closure-in-js-eab2fcb68ccc" rel="noopener"> <strong class="kq io"> <em class="lk"> JS封</em> </strong> </a> <strong class="kq io"> <em class="lk">。<br/>是的？还在读。你肯定会学到新的东西。</em> </strong></p><p id="2b5f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读。😍</p><blockquote class="oh"><p id="0fd9" class="oi oj in bd ok ol om on oo op oq lj dk translated">希望你能从这篇文章中学到一些新的东西。请跟随我阅读这类文章。干杯！</p></blockquote><p id="e205" class="pw-post-body-paragraph ko kp in kq b kr or jo kt ku os jr kw kx ot kz la lb ou ld le lf ov lh li lj ig bi translated"><em class="lk">更多内容请看</em><a class="ae og" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a><em class="lk">。报名参加我们的</em> <a class="ae og" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">免费每周简讯</em> </strong> </a> <em class="lk">。关注我们</em> <a class="ae og" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">推特</em></strong></a><strong class="kq io"><em class="lk"/></strong><em class="lk">和</em><a class="ae og" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">LinkedIn</em></strong></a><em class="lk">。查看我们的</em> <a class="ae og" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">社区不和谐</em> </strong> </a> <em class="lk">加入我们的</em> <a class="ae og" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">人才集体</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>