<html>
<head>
<title>How to Build a GIF Converter in a Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在浏览器中构建GIF转换器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-gif-creator-in-browser-3235d274c27f?source=collection_archive---------8-----------------------#2022-05-16">https://javascript.plainenglish.io/how-to-build-a-gif-creator-in-browser-3235d274c27f?source=collection_archive---------8-----------------------#2022-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="df89" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用FFmpeg在浏览器中创建一个简单的MP4到高质量GIF的转换器？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/35cc51eb8119971422435cb5ff839e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Qe60suSfV_KDs5syR76B-A.gif"/></div></figure><h1 id="5259" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">为什么我们还在使用gif？</h1><p id="f53a" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">gif拖慢了互联网的速度，因为它们占用了大量的网站存储空间，并且因为将它们推送到客户端所需的总带宽:gif的重量可能是. mp4视频文件的10倍，并且它们的颜色质量仅限于256色调色板。</p><p id="00f2" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">尽管有这些缺点，Twitter、WhatsUp和脸书等社交媒体怪物应用程序默认情况下会循环运行gif，不像用户需要按下播放按钮的视频。这个功能对于内容创作者来说是无价的，可以在第一眼就抓住观众。</p><p id="82eb" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">如果你想知道Twitter和Telegram等大型应用程序是如何处理所有这些存储负载的，他们在幕后使用了一个简单而有效的技巧:这些应用程序将胖乎乎的GIF文件转换为纤细的MP4文件，同时在用户feed中显示该文件为未经处理的GIF文件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi md"><img src="../Images/54c82780bfed0bf8c3cb6f97508d2f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*-YCLia52AgzNc3nj.gif"/></div></figure><h1 id="a0d0" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">在线可用转换器</h1><p id="a112" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">Giphy是最受欢迎的GIF托管提供商，它有自己的GIF创建者。IOS移动应用程序非常好，除了帐户创建是必须的。</p><p id="a790" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated"><a class="ae me" href="https://filmora.wondershare.com/animated-gif/best-gif-maker-online.html" rel="noopener ugc nofollow" target="_blank">有许多GIF编辑器</a>运行服务器端<a class="ae me" href="https://ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> FFmpeg </a>引擎。服务器端方法是常见且可靠的，但有以下缺点:</p><ul class=""><li id="7cd6" class="mf mg in le b lf ly li lz ll mh lp mi lt mj lx mk ml mm mn bi translated">上传用于转换的视频文件可能需要一些时间，具体取决于带宽、视频分辨率和长度。</li><li id="130b" class="mf mg in le b lf mo li mp ll mq lp mr lt ms lx mk ml mm mn bi translated">在云上公开运行你的转换器有点昂贵:你需要在一个<a class="ae me" href="https://stackoverflow.com/questions/50053313/how-to-make-ffmpeg-available-inside-my-docker-container" rel="noopener ugc nofollow" target="_blank"> ubuntu容器</a>中为每个客户端运行FFmpeg进程，因此当你扩展时，可能会对你的预算有所影响。</li></ul><p id="0cdd" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">我们一直在寻找一种廉价的方式来创建gif并在浏览器中处理视频，以节省运行成本和上传费用。过了一会儿，我们发现了一些在浏览器中完成任务的方法:</p><ol class=""><li id="4bde" class="mf mg in le b lf ly li lz ll mh lp mi lt mj lx mt ml mm mn bi translated"><a class="ae me" href="https://ffmpegwasm.netlify.app/" rel="noopener ugc nofollow" target="_blank"><strong class="le io">FFmpeg . wasm</strong></a><strong class="le io">:</strong>是FFmpeg的纯WebAssembly / JavaScript端口。它使视频&amp;音频能够在浏览器中录制、转换和流式传输。核心加载速度快约2秒，以实现快速互联网带宽，并保持回购。缺点:FFmpeg.wasm使用SharedArrayBuffer，这要求站点被隔离。背后的<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" rel="noopener ugc nofollow" target="_blank">故事</a>颇耐人寻味。不幸的是，它在Safari iOS上不起作用。</li><li id="e30c" class="mf mg in le b lf mo li mp ll mq lp mr lt ms lx mt ml mm mn bi translated"><a class="ae me" href="https://yahoo.github.io/gifshot/" rel="noopener ugc nofollow" target="_blank"><strong class="le io">GIF shot</strong></a><strong class="le io">:</strong>是一种不同的方法，通过使用canvas分割视频流，从网络摄像头和存储的视频创建GIF。几年前由雅虎集团创建。不幸的是，它不能在移动Safari上工作。</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Gifshot Demo</figcaption></figure><ol class=""><li id="4415" class="mf mg in le b lf ly li lz ll mh lp mi lt mj lx mt ml mm mn bi translated"><a class="ae me" href="http://bgrins.github.io/videoconverter.js/" rel="noopener ugc nofollow" target="_blank"><strong class="le io">video converter . js</strong></a>:也是几年前创建的，使用消息与移植的FFmpeg模块通信，该库没有使用SharedArrayBuffer方法，因此可以在任何地方工作，包括移动Safari。它的主要缺点是加载速度:可能需要5秒钟来加载内核，并且一些FFmpeg过滤器不工作。这是我们基于这种方法构建的一个演示:</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">VideoConverter.js</figcaption></figure><h1 id="d1f4" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">我们的选择</h1><p id="24d7" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们选择了<a class="ae me" href="https://ffmpegwasm.netlify.app/" rel="noopener ugc nofollow" target="_blank"> FFmpeg.wasm </a>来使用普通的javascript创建<strong class="le io">高质量的GIF创建器演示</strong>。</p><p id="d3e9" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">从长远来看，VideoConverter是一个更好的选择，因为它可以跨平台使用，但它需要一些改造工作来跟上更新的功能。</p><h1 id="1d10" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">基于FFmpeg.wasm构建视频转GIF演示</h1><p id="13db" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="na">GitHub上有完整的代码，你可以把它分叉，按原样部署在</em><a class="ae me" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"><em class="na">Vercel</em></a><em class="na">上。</em></p><div class="nb nc gp gr nd ne"><a href="https://github.com/KostaMalsev/high-quality-gif.git" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">GitHub-KostaMalsev/high-quality-gif:浏览器转换器中的视频到Gif和Gif到视频</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ki ne"/></div></div></a></div><h1 id="26e2" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">循序渐进:</h1><h2 id="655d" class="nt kl in bd km nu nv dn kq nw nx dp ku ll ny nz kw lp oa ob ky lt oc od la oe bi translated"><strong class="ak">第一步:创建web应用程序的HTML部分</strong></h2><p id="1956" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">放置3个按钮、图像+视频元素和一个div“文件”,以便稍后附加处理的输出结果:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of mv l"/></div></figure><h2 id="d4f4" class="nt kl in bd km nu nv dn kq nw nx dp ku ll ny nz kw lp oa ob ky lt oc od la oe bi translated">步骤2:导入ffmpeg.wasm库代码:</h2><p id="8697" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">定义其全局:</p><pre class="kd ke kf kg gt og oh oi oj aw ok bi"><span id="3b5f" class="nt kl in oh b gy ol om l on oo">&lt;script src="ffmpeg.min.js"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>      //Define ffmpeg:<br/>      const { createFFmpeg } = FFmpeg;<br/>      let ffmpeg;<br/> &lt;/script&gt;</span></pre><p id="aa4a" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">您也可以从cdn加载更新的库:</p><pre class="kd ke kf kg gt og oh oi oj aw ok bi"><span id="89e8" class="nt kl in oh b gy ol om l on oo">&lt;script <strong class="oh io">src="https://unpkg.com/@ffmpeg/ffmpeg@0.10.0/dist/ffmpeg.min.js"&gt;</strong>&lt;/script&gt;<br/>&lt;script&gt;<br/>      //Define ffmpeg:<br/>      const { createFFmpeg } = FFmpeg;<br/>      let ffmpeg;<br/> &lt;/script&gt;</span></pre><h2 id="1fda" class="nt kl in bd km nu nv dn kq nw nx dp ku ll ny nz kw lp oa ob ky lt oc od la oe bi translated">步骤3:为图像/视频加载添加监听器</h2><p id="ccfc" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这里没有实际上传，媒体被格式化到Uint8Array缓冲区，使它们可以在<a class="ae me" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>环境中被ffmpeg使用。为此，我们使用<em class="na">检索图像/视频</em>功能。</p><p id="d4e6" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">在Dom中添加全局变量和对HTML元素的引用:</p><pre class="kd ke kf kg gt og oh oi oj aw ok bi"><span id="e160" class="nt kl in oh b gy ol om l on oo">var worker;<br/>var sampleImageData = null;<br/>var sampleVideoData = null;<br/>var outputElement;<br/>var filesElement;<br/>var running = false;<br/>var isWorkerLoaded = false;<br/>let fileName = '';</span><span id="b989" class="nt kl in oh b gy op om l on oo"><strong class="oh io">//Get the html elements:<br/></strong>const uploadButtons = document.querySelector('.upload-buttons');<br/>const imageUploadButton = document.querySelector('#image-upload');<br/>const videoTag = document.querySelector("#video-tag");<br/>const inputTag = document.querySelector("#input-tag");<br/>const log = document.querySelector('#log');<br/>const vFigure = document.querySelector('#videoContainer');<br/>const imgTag = document.querySelector('#img-tag');<br/>const button = document.querySelector(".convert-button");</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of mv l"/></div></figure><h2 id="ae13" class="nt kl in bd km nu nv dn kq nw nx dp ku ll ny nz kw lp oa ob ky lt oc od la oe bi translated">步骤4:调用转换ffmpeg.wasm引擎</h2><p id="814c" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">首先用异步函数<em class="na"> initWorker() </em>初始化引擎:</p><pre class="kd ke kf kg gt og oh oi oj aw ok bi"><span id="2828" class="nt kl in oh b gy ol om l on oo">//Init the ffmpeg worker<br/><strong class="oh io">async function initWorker() {</strong></span><span id="00d7" class="nt kl in oh b gy op om l on oo">   if (isWorkerLoaded) return;</span><span id="1c84" class="nt kl in oh b gy op om l on oo">   console.log('Start init worker');</span><span id="d250" class="nt kl in oh b gy op om l on oo">   ffmpeg = await createFFmpeg({log: true});</span><span id="d0bb" class="nt kl in oh b gy op om l on oo">   button.classList.remove("hidden");<br/>   button.classList.add("gray");<br/>   button.style.setProperty('--load', 0);<br/>   button.innerText = 'Loading engine...';</span><span id="a0d6" class="nt kl in oh b gy op om l on oo">   await ffmpeg.load();</span><span id="403b" class="nt kl in oh b gy op om l on oo">   filesElement = document.querySelector("#files");</span><span id="2762" class="nt kl in oh b gy op om l on oo">}</span></pre><p id="3ba3" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">使用<em class="na"> convertGifToMp4 </em>运行GIF到Mp4转换。</p><p id="7945" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated"><strong class="le io">该部分包括3个子步骤:</strong></p><ol class=""><li id="feb0" class="mf mg in le b lf ly li lz ll mh lp mi lt mj lx mt ml mm mn bi translated">通过调用<em class="na"> ffmpeg将带有视频数据的Uint8Array推送到w<a class="ae me" href="https://emscripten.org/docs/api_reference/Filesystem-API.html" rel="noopener ugc nofollow" target="_blank">ASM“file system”</a>。FS </em>以便我们的FFmpeg可以读取它。</li></ol><p id="67cb" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">2.运行<strong class="le io"> ffmpeg。使用常规ffmpeg指令运行</strong>。</p><pre class="kd ke kf kg gt og oh oi oj aw ok bi"><span id="1018" class="nt kl in oh b gy ol om l on oo"><strong class="oh io">ffmpeg.run('-i', 'input.mp4', '-vf', 'fps=10,scale=320:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse', 'output.gif')</strong></span></pre><p id="da40" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">这一行是用<a class="ae me" href="https://ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> ffmpeg标志语言</a>写的，可以大致翻译成如下:</p><p id="b838" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated"><em class="na">使用input.mp4文件并将其转换为带有以下标志的output . gif:</em></p><p id="b9d6" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated"><em class="na">设置fps为10(帧每秒)，</em></p><p id="ed5d" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated"><em class="na">将输出的高度设置为320px，宽度设置为原始宽度，使用lanczos算法缩放至所需尺寸，</em></p><p id="4f42" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated"><em class="na">使用其中一个输出流生成调色板，选择最佳的256种颜色来表示视频中的所有颜色，并在其孪生流上使用该调色板来估计输出GIF的颜色。(</em> <a class="ae me" href="https://www.alanwsmith.com/posts/20envmzo1zes--create-high-quality-gifs-with-ffmpeg" rel="noopener ugc nofollow" target="_blank"> <em class="na">链接供参考</em> </a> <em class="na"> ) </em></p><p id="262a" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">3.从“wasm文件系统”获取输出数据，并创建一个下载链接。</p><p id="3181" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">以下是完整的3个子步骤序列:</p><pre class="kd ke kf kg gt og oh oi oj aw ok bi"><span id="c5b4" class="nt kl in oh b gy ol om l on oo">//Convert mp4 264 video to gif:<br/><strong class="oh io">async function convertVideo2Gif() {</strong></span><span id="b839" class="nt kl in oh b gy op om l on oo">       await initWorker();</span><span id="48f8" class="nt kl in oh b gy op om l on oo">       const sourceBuffer = sampleVideoData;</span><span id="56de" class="nt kl in oh b gy op om l on oo">       ffmpeg.FS(<br/>          "writeFile",<br/>          "input.mp4",<br/>          new Uint8Array(sourceBuffer, 0, sourceBuffer.byteLength)<br/>        );</span><span id="8f8b" class="nt kl in oh b gy op om l on oo">        button.innerText = 'Processing...';<br/>        startRunning();</span><span id="3ad6" class="nt kl in oh b gy op om l on oo">        ffmpeg.setProgress(({ratio}) =&gt; {</span><span id="29ed" class="nt kl in oh b gy op om l on oo">               button.style.setProperty('--load', ratio);</span><span id="bf19" class="nt kl in oh b gy op om l on oo">                if (ratio !== 0) {<br/>                button.innerText = 'Converting...';<br/>          }</span><span id="e874" class="nt kl in oh b gy op om l on oo">         });</span><span id="b622" class="nt kl in oh b gy op om l on oo">      //Run the ffmpeg: <br/><strong class="oh io">        let res = await ffmpeg.run('-i', 'input.mp4', '-vf', 'fps=10,scale=320:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse', 'output.gif');</strong></span><span id="06fe" class="nt kl in oh b gy op om l on oo"><strong class="oh io">        //Retrieve the result:<br/></strong>        const output = ffmpeg.FS("readFile", "output.gif");</span><span id="c967" class="nt kl in oh b gy op om l on oo">        //Provide downloadable link to file:<br/>        let videoDownloadLink = getDownloadLink(output,       "output.gif");<br/>        if (videoDownloadLink)<br/>          filesElement.appendChild(videoDownloadLink);</span><span id="130a" class="nt kl in oh b gy op om l on oo">        videoDownloadLink.click();</span><span id="cdf4" class="nt kl in oh b gy op om l on oo">        stopRunning();</span><span id="841a" class="nt kl in oh b gy op om l on oo">        button.innerHTML = 'Convert';<br/>        button.classList.add('hidden');<br/>        button.classList.remove('gray');<br/>        button.style.setProperty('--load', 0);<br/>        uploadButtons.classList.remove('hidden');</span><span id="f510" class="nt kl in oh b gy op om l on oo">        imgTag.src = '';</span><span id="e86e" class="nt kl in oh b gy op om l on oo">        videoTag.src = '';<br/>        videoTag.classList.add('hidden');</span><span id="335b" class="nt kl in oh b gy op om l on oo">}</span></pre><p id="5bc9" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">以下是创建可下载链接的功能:</p><pre class="kd ke kf kg gt og oh oi oj aw ok bi"><span id="f6ed" class="nt kl in oh b gy ol om l on oo">//Generate downloadable link<br/><strong class="oh io">function getDownloadLink(fileData, fileName) {</strong></span><span id="c141" class="nt kl in oh b gy op om l on oo">  if (fileName.match(/\.jpeg|\.gif|\.jpg|\.png/)) {</span><span id="dbda" class="nt kl in oh b gy op om l on oo">     var blob = new Blob([fileData]);</span><span id="9b84" class="nt kl in oh b gy op om l on oo">      if (navigator.share) {<br/>            const fileToShare = new File([blob], fileName);</span><span id="e6bb" class="nt kl in oh b gy op om l on oo">            navigator.share({<br/>              files: fileToShare,<br/>              title: 'Converted GIF',<br/>              text: 'Converted GIF',<br/>            });<br/>          } else {</span><span id="56f5" class="nt kl in oh b gy op om l on oo">              var src = URL.createObjectURL(blob);<br/>              var a = document.createElement('a');<br/>              a.href = src;<br/>              a.download = fileName;</span><span id="bb0f" class="nt kl in oh b gy op om l on oo">          return a;</span><span id="063d" class="nt kl in oh b gy op om l on oo">        }</span><span id="104c" class="nt kl in oh b gy op om l on oo">      } else {</span><span id="f27d" class="nt kl in oh b gy op om l on oo">          var a = document.createElement('a');<br/>          a.classList.add('button');<br/>          a.download = fileName;<br/>          var blob = new Blob([fileData]);<br/>          var src = window.URL.createObjectURL(blob);<br/>          a.href = src;<br/>          a.textContent = 'Download result';<br/>          return a;<br/>        }<br/>    }</span></pre><h2 id="0d41" class="nt kl in bd km nu nv dn kq nw nx dp ku ll ny nz kw lp oa ob ky lt oc od la oe bi translated">第五步:添加一个别致的CSS:</h2><p id="b9af" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这里有一个不错的CSS技巧:加载程序接收<em class="na">比率</em>变量，并呈现加载栏CSS动画:</p><pre class="kd ke kf kg gt og oh oi oj aw ok bi"><span id="58d9" class="nt kl in oh b gy ol om l on oo">button.style.setProperty(' — load', ratio);// use in js script</span></pre><p id="d97b" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">以下是完整的CSS文件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="04e5" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">第6步:添加vercel.json</p><p id="d7e5" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">为了隔离文件，我们需要指示Vercel(在本例中)提交site isolated: vercel.json内容:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="4a86" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">就是这样！</h1><p id="6902" class="pw-post-body-paragraph lc ld in le b lf lg jo lh li lj jr lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这是在Vercel的一个独立站点上进行的演示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/cab01404a83f20c2e337d5d00ef9b71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YA1PkhijqVKXdDye.gif"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk"><a class="ae me" href="https://high-quality-gif.vercel.app/" rel="noopener ugc nofollow" target="_blank">https://high-quality-gif.vercel.app</a></figcaption></figure><p id="d5c6" class="pw-post-body-paragraph lc ld in le b lf ly jo lh li lz jr lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated"><em class="na">使用vercel.json文件配置隔离选项。</em></p></div></div>    
</body>
</html>