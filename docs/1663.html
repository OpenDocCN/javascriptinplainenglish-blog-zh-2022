<html>
<head>
<title>7 Functional Concepts to Master as a Web Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为一名Web开发人员需要掌握的7个功能概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-functional-concepts-to-master-as-web-developer-f51fdaf6e5c3?source=collection_archive---------2-----------------------#2022-04-11">https://javascript.plainenglish.io/7-functional-concepts-to-master-as-web-developer-f51fdaf6e5c3?source=collection_archive---------2-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">掌握这些关键概念，成为更好的web开发人员。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5a1a57e5ac733638cc9a3e79c7157c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Euxi1fnme8NlCNE"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@sammoqadam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sam Moqadam</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fe38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为web开发人员，我们乐于尝试各种不同的方法来构建web应用程序。使用函数是一件特别有趣的事情，但并不是每个人都充分利用各种函数概念来改进他们的代码，我将我在代码中经常使用的七个函数概念分离出来。</p><h2 id="d59c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">什么是功能概念？</h2><p id="e026" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">功能概念是一组特定规则的一般概念，这些规则根据功能的行为或结构对不同类型的功能进行分类。利用这些概念将确保你写作</p><ul class=""><li id="7706" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">更容易维护和测试代码；</li><li id="8179" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">可重用代码；</li><li id="2c67" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">功能更简单强大；</li><li id="4b03" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">仅使用函数表示数据和操作；</li><li id="6a27" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">等等；</li></ul><p id="f3f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数式编程可能会变得超级复杂和紧张。取决于你想深入到什么程度，你会很快意识到仅仅用函数就可以做几乎所有的事情。有了如此惊人的能力，我发现自己一遍又一遍地使用这些概念来确保最佳代码。</p><h2 id="4e3c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">纯函数</h2><p id="ef39" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一个函数被认为是"<em class="ne">纯</em>"如果:</p><ul class=""><li id="cba1" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">提供相同的输入，它复制相同的输出；</li><li id="280b" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">执行时无副作用；</li></ul><p id="5850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更简单地说，如果我用两个数字调用一个函数，例如3和8，并且这个函数每次都返回11，而没有改变我的输入或环境中的任何东西(本地的或非本地的)，那么这个函数被认为是纯的。</p><p id="cdfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">我们来看看几个不纯的函数:</strong></p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="0632" class="ls lt iq ng b gy nk nl l nm nn">const x = 10;</span><span id="e9f4" class="ls lt iq ng b gy no nl l nm nn">function <strong class="ng ir">getTen</strong>() {<br/>   return x;<br/>}</span></pre><p id="d064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数是不纯的，因为它直接访问一个作用域变量(不是赋予它的)，因此会产生不一致的结果。如果<code class="fe np nq nr ng b">x</code>改变，那么函数将改变它的返回。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="0163" class="ls lt iq ng b gy nk nl l nm nn">function <strong class="ng ir">getJrName</strong>(personObj) {<br/>  <strong class="ng ir">personObj.name = `${personObj.name} Jr.`;</strong></span><span id="0b1f" class="ls lt iq ng b gy no nl l nm nn">  return personObj.name;<br/>}</span></pre><p id="845b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">改变输入的函数不是纯函数。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="1dc7" class="ls lt iq ng b gy nk nl l nm nn">function printSum(n1, n2) {<br/>   <strong class="ng ir">console.log(n1, n2);</strong><br/>}</span></pre><p id="f727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述功能完全依赖于其环境。如果这个函数运行在<code class="fe np nq nr ng b">console.log</code>不存在或者行为不同的环境中，那么这个函数会产生不同的结果。</p><p id="944e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">那么如何保证自己有一个纯粹的函数呢？</strong></p><ul class=""><li id="41db" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">仅使用该功能提供的内容；</li><li id="863e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">不要改变函数提供的任何东西；</li><li id="16e5" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">不要直接访问环境、项目API或自定义实现；</li><li id="dad3" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">对于相同的输入，总是产生相同的结果；</li></ul><p id="19f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">为什么这对web开发人员如此重要？嗯，这些功能是如此可靠、安全、易于测试，它们将提高你所构建的一切的质量。此外，Javascript可以在任何地方使用，在任何地方(服务器或客户端)使用相同功能的能力是一个值得利用的惊人特性。</strong></p><h2 id="e298" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">关闭</h2><p id="4cba" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当你嵌套作用域时，你就创建了闭包，因为每个函数都有自己的作用域，嵌套函数将创建函数闭包，这些闭包是做各种事情的超级强大的函数。</p><p id="ecb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以这个计数器为例:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="ad1e" class="ls lt iq ng b gy nk nl l nm nn">const <strong class="ng ir">createCounter</strong> = (start = 0, inc = 1) =&gt; {<br/>  let <strong class="ng ir">count</strong> = start;<br/>  <br/>  return () =&gt; {<br/>    <strong class="ng ir">count</strong> += inc;<br/>    <br/>    return count;<br/>  };<br/>}</span></pre><p id="c847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe np nq nr ng b">createCounter</code>是一个函数，它接受两个参数，创建一个局部范围变量，并返回一个使用这些局部范围数据产生结果的新函数。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="c74f" class="ls lt iq ng b gy nk nl l nm nn">const <strong class="ng ir">getNextCountUpByTwo</strong> = <strong class="ng ir">createCounter</strong>(0, 2);</span><span id="7f15" class="ls lt iq ng b gy no nl l nm nn"><strong class="ng ir">getNextCountUpByTwo</strong>() // returns 2<br/><strong class="ng ir">getNextCountUpByTwo</strong>() // returns 4<br/><strong class="ng ir">getNextCountUpByTwo</strong>() // returns 6<br/><strong class="ng ir">getNextCountUpByTwo</strong>() // returns 8</span></pre><p id="d2e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">闭包很棒，因为它允许您将数据与作用于该数据的函数相关联。它允许你在一定程度上模仿OOP类，因此闭包可以用在你需要对象的任何地方。</p><p id="d30b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我一直使用闭包函数来模拟私有方法和属性，创建模块，并将数据和函数耦合在一起，就像你从上面的<code class="fe np nq nr ng b">counter</code>例子中看到的那样。</p><h2 id="1267" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">递归</h2><p id="ba50" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我处理复杂的数据，如<a class="ae kv" href="https://medium.com/before-semicolon/introduction-to-the-tree-data-structure-16307e3f1967" rel="noopener"> Three </a>和<a class="ae kv" href="https://medium.com/before-semicolon/graph-data-structure-implementation-in-javascript-668f291a8a16" rel="noopener"> Graph </a>有时你无法完成——至少不容易——许多没有递归函数的读取和遍历。由于这个原因，递归成为我的代码中不可或缺的概念，以至于我经常发现自己在任何循环太复杂而难以理解的地方都能从中获得乐趣。</p><p id="e649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说，递归就是如何在没有<code class="fe np nq nr ng b">while</code>和<code class="fe np nq nr ng b">for</code>循环的情况下循环。下面是一个使用递归的<code class="fe np nq nr ng b">forEach</code>函数的例子。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="2164" class="ls lt iq ng b gy nk nl l nm nn">const <strong class="ng ir">forEach</strong> = (list, cb) =&gt; {<br/>  if(list.length) {<br/>    cb(list[0]);<br/>    <strong class="ng ir">forEach</strong>(list.slice(1), cb)<br/>  }<br/>}</span><span id="7384" class="ls lt iq ng b gy no nl l nm nn"><strong class="ng ir">forEach</strong>([2, 4, 6, 8], console.log) <em class="ne">// logs 2, 4, 6, 8</em></span></pre><p id="ae85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">递归函数是直接或间接调用自身的函数。它们不一定比普通的循环快，但是在复杂的循环中要容易得多。例如，看看用几行代码将DOM转换成JSON three是多么容易。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="2bb3" class="ls lt iq ng b gy nk nl l nm nn">function <strong class="ng ir">DOMtoJSON</strong>(el) {<br/>  return {<br/>    nodeName: el.nodeName,<br/>    type: el.nodeType,<br/>    attributes: Array.from(<br/>       el.attributes || [],<br/>       (a) =&gt; ({name: a.name, value: a.value})),<br/>    innerHTML: el.innerHTML,<br/>    children: Array.from(el.childNodes, <strong class="ng ir">DOMtoJSON</strong>),<br/>    textContent: el.textContent<br/>  }<br/>}</span><span id="5d38" class="ls lt iq ng b gy no nl l nm nn">const docBodyJSON = <strong class="ng ir">DOMtoJSON(document.body)</strong></span></pre><p id="2799" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的递归将遍历整个文档体，一个元素一个元素地创建一个JSON。用循环写同样的东西只是一段复杂得多的代码。</p><p id="65f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是递归的作用。当你完全理解并能在你的代码中自如地使用它们时，它们会带来巨大的不同。</p><h2 id="42e1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">绑定函数</h2><p id="ed72" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在web开发中，绑定的概念被提到了很多，所以你必须至少理解它是关于什么的。</p><p id="a0a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在函数式编程世界中，<code class="fe np nq nr ng b">bind</code>函数是一个将一段数据关联到一个创建新绑定函数的函数的函数。在web编程领域，我们经常听说将数据绑定到DOM，这是将一段数据与一个特定的DOM元素相关联，这样当这段数据发生变化时，它就可以被更新。</p><p id="9667" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个可以利用的强大概念，因为它允许我们做超能力的事情，比如拥有读取调用功能，我们可以传递他们已经绑定的所有数据。</p><p id="05b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以像这样创建一个绑定函数:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="eeff" class="ls lt iq ng b gy nk nl l nm nn">function <strong class="ng ir">bind</strong>(fn, ...args) {<br/>  return (...moreArgs) =&gt; fn(...args, ...moreArgs)<br/>}</span></pre><p id="5dec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:绑定函数利用了将要创建的闭包概念</p><p id="f001" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们有一个函数接受两个数字并返回它们的和，我们可以从它创建一个新的绑定函数，只接受第二个数字。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="030a" class="ls lt iq ng b gy nk nl l nm nn">function <strong class="ng ir">add</strong>(a, b) {<br/>  return a + b;<br/>}</span><span id="5398" class="ls lt iq ng b gy no nl l nm nn">const <strong class="ng ir">addTwo</strong> = <strong class="ng ir">bind</strong>(add, 2);</span><span id="5924" class="ls lt iq ng b gy no nl l nm nn"><strong class="ng ir">addTwo</strong>(4); <em class="ne">// returns 6<br/></em><strong class="ng ir">addTwo</strong>(200); <em class="ne">// returns 202</em></span></pre><p id="63b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">bind函数是函数不可或缺的一部分，JavaScript函数已经是现成的了。我们可以这样写上面的内容:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="bb50" class="ls lt iq ng b gy nk nl l nm nn">function add(a, b) {<br/>  return a + b;<br/>}</span><span id="d594" class="ls lt iq ng b gy no nl l nm nn">const addTwo = <strong class="ng ir">add.bind</strong>(null, 2);</span><span id="3cbc" class="ls lt iq ng b gy no nl l nm nn"><strong class="ng ir">addTwo</strong>(4); <em class="ne">// returns 6<br/></em><strong class="ng ir">addTwo</strong>(200); <em class="ne">// returns 202</em></span></pre><p id="1fc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener ugc nofollow" target="_blank"> bind </a>方法将一个要用作<code class="fe np nq nr ng b">this</code>的对象作为第一个参数，并以逗号分隔的参数值列表。</p><p id="df72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bind肯定是需要习惯的东西，并尝试在代码中加入更多内容。我使用bind来传递绑定的函数，而不必指定调用它们的参数值。这允许我创建随时可用的回调函数，甚至是对我有利的劫持对象方法。</p><p id="eccd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，这里有一个如何创建将数据绑定到元素并让您轻松更新数据的函数的示例。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="302e" class="ls lt iq ng b gy nk nl l nm nn">function <strong class="ng ir">bindElementData</strong>(el, prop, value = '') {<br/>  el[prop] = value;<br/>  <br/>  return (newValue) =&gt; {<br/>    el[prop] = newValue;<br/>  }<br/>}</span><span id="1028" class="ls lt iq ng b gy no nl l nm nn">const <strong class="ng ir">btn</strong> = document.querySelector('button#btn');<br/>const <strong class="ng ir">updateBtnText</strong> = <strong class="ng ir">bindElementData</strong>(btn, 'textContent', 'my button');<br/>const <strong class="ng ir">updateBtnDisabled</strong> = <strong class="ng ir">bindElementData</strong>(btn, 'disabled', false);</span><span id="0e51" class="ls lt iq ng b gy no nl l nm nn"><strong class="ng ir">btn.onclick = () =&gt; {<br/>  updateBtnText("btn clicked")<br/>  updateBtnDisabled(true)<br/>}</strong></span></pre><h2 id="031c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">咖喱功能</strong></h2><p id="ab8d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当我向你介绍<code class="fe np nq nr ng b">bind</code>概念的时候，我已经向你展示了一个curried函数。Currying一个函数是把它分解成更小的函数，每个函数接受一个参数。</p><p id="39d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，为了配合上面的<code class="fe np nq nr ng b">add</code>函数示例，它应该是这样的:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="6024" class="ls lt iq ng b gy nk nl l nm nn">function add(a) {<br/>  return (b) =&gt; {<br/>    return a + b<br/>  }<br/>}</span></pre><p id="fc98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们会这样称呼它:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="c93b" class="ls lt iq ng b gy nk nl l nm nn"><em class="ne">// all at once</em><strong class="ng ir"><br/>add</strong>(4)(6); <em class="ne">// returns 10</em></span><span id="f654" class="ls lt iq ng b gy no nl l nm nn"><em class="ne">// or by parts</em></span><span id="4e73" class="ls lt iq ng b gy no nl l nm nn">const <strong class="ng ir">addFourTo</strong> = <strong class="ng ir">add</strong>(4);</span><span id="26b1" class="ls lt iq ng b gy no nl l nm nn"><strong class="ng ir">addFourTo</strong>(6) <em class="ne">// returns 10;</em></span></pre><p id="5a63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那样做是不实际的，因为每次参数改变的时候，你都必须改变函数，这也不太好。为此，我们需要一个currying函数。一个为你服务的功能。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="59ab" class="ls lt iq ng b gy nk nl l nm nn">function <strong class="ng ir">curry</strong>(<strong class="ng ir">func</strong>) { <strong class="ng ir">// 1</strong><br/>  return function <strong class="ng ir">curried</strong>(...args) { <br/>    if (args.length &gt;= <strong class="ng ir">func.length</strong>) { <strong class="ng ir"><em class="ne">// 2</em></strong><br/>      return <strong class="ng ir">func</strong>.<strong class="ng ir">apply</strong>(this, args); <strong class="ng ir"><em class="ne">// 3</em></strong><br/>    }<br/>      <br/>    <strong class="ng ir"><em class="ne">// 4</em></strong><br/>    return (...args2) =&gt; <strong class="ng ir">curried</strong>.<strong class="ng ir">apply</strong>(this, args.concat(args2))<br/>  };<br/>}</span></pre><p id="dd15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:curry函数利用了<strong class="ky ir">闭包</strong>和<strong class="ky ir">递归</strong>等概念。</p><p id="dcdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有很多东西需要解释，所以请允许我解释一下:</p><ul class=""><li id="2c5a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">1</strong>:<code class="fe np nq nr ng b">curry</code>函数本身是一个纯粹的闭包函数，它将被curried的函数作为一个参数，并返回一个新的函数，该函数处理将参数应用于该函数。</li><li id="22fc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir"> 2 </strong>:在JavaScript中，一个函数有<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length" rel="noopener ugc nofollow" target="_blank">的长度</a>，这里的长度是这个函数接受的参数的数量，不包括分布或者有默认值的参数——基本上是必需的参数。该语句检查是否提供了所有参数值。</li><li id="c1bc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir"> 3 </strong>:应用函数的概念类似于绑定概念，不同之处在于它不是返回一个新的绑定函数，而是一次性绑定并调用函数。Apply和bind一样，是内置在Javascript函数中的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="fc2e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir"> 4 </strong>:如果参数仍然与调用函数所需的参数数量不匹配，我们返回一个新函数，它收集其余的参数，当被调用时，它将新的和以前提供的参数应用于内部递归<code class="fe np nq nr ng b">curried</code>函数。</li></ul><p id="4677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们的<code class="fe np nq nr ng b">add</code>函数接受更多的数字:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="fb9d" class="ls lt iq ng b gy nk nl l nm nn">function <strong class="ng ir">add</strong>(a, b, c) {<br/>  return a + b + c;<br/>}</span></pre><p id="a5c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以简单地保持它的原样，并用我们的<code class="fe np nq nr ng b">curry</code>函数创建一个新的咖喱版本:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="975a" class="ls lt iq ng b gy nk nl l nm nn">const <strong class="ng ir">curriedAdd</strong> = curry(add);</span></pre><p id="c60d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以这样称呼它:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="f70d" class="ls lt iq ng b gy nk nl l nm nn"><em class="ne">// all at once</em><strong class="ng ir"><br/>curriedAdd</strong>(4)(6)(5); <em class="ne">// returns 15</em></span><span id="b122" class="ls lt iq ng b gy no nl l nm nn"><em class="ne">// or by parts</em></span><span id="14a1" class="ls lt iq ng b gy no nl l nm nn">const <strong class="ng ir">addFourTo</strong> = <strong class="ng ir">curriedAdd</strong>(4);<br/>const <strong class="ng ir">addTenTo</strong> = <strong class="ng ir">addFourTo</strong>(6);</span><span id="b63c" class="ls lt iq ng b gy no nl l nm nn"><strong class="ng ir">addTenTo</strong>(5) <em class="ne">// returns 15;</em></span></pre><p id="8e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Currying向您介绍了<a class="ae kv" href="https://en.wikipedia.org/wiki/Lazy_evaluation#:~:text=In%20programming%20language%20theory%2C%20lazy,avoids%20repeated%20evaluations%20(sharing)." rel="noopener ugc nofollow" target="_blank">懒惰评估</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Partial_application#:~:text=In%20computer%20science%2C%20partial%20application,producing%20a%20function%20of%20type%20." rel="noopener ugc nofollow" target="_blank">部分应用</a>的世界，这是需要学习的重要概念。它们允许您轻松地收集数据，并仅在需要时处理这些数据。</p><p id="8c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">长表单处理就是一个很好的例子，在这种情况下，您懒洋洋地收集输入的信息，并验证它们，直到最后对信息采取行动。</p><p id="c363" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你不能一次得到所有的东西，或者只是简单地把事情分成小块，在中间做不同的动作，直到你准备好产生最终的结果时，奉承总是很棒的。</p><h2 id="169b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">组合和管道函数</h2><p id="c860" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">函数组合是将简单函数组合成更复杂函数的艺术。这意味着我们可以专注于把我们的功能分解得越小越好，然后像乐高积木一样把它们组合成我们想要的任何东西。这是一个非常有趣的概念。</p><p id="452a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在函数世界中，我们经常听说管道或组合函数是非常相似的概念。它们的工作方式相同，唯一的区别是它们执行所有功能的顺序和方向。Compose execute从右边开始，pipe从左边开始。两者都将使用前一个函数return来传递给下一个函数。</p><p id="8388" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是如何使用JavaScript数组<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> reduce方法</a>创建这两者。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="fe2e" class="ls lt iq ng b gy nk nl l nm nn">const <strong class="ng ir">compose</strong> = (...fns) =&gt; <br/>    x =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc), x);</span><span id="0549" class="ls lt iq ng b gy no nl l nm nn">const <strong class="ng ir">pipe</strong> = (...fns) =&gt; <br/>    x =&gt; fns.reduce((res, fn) =&gt; fn(res), x);</span></pre><p id="be73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我更喜欢<code class="fe np nq nr ng b">pipe</code>这本书，因为它更容易阅读。如果你曾经和RxJs一起工作过，你就会知道管道的力量。我强烈建议进入那个世界。</p><p id="9fff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe np nq nr ng b">pipe</code>和<code class="fe np nq nr ng b">compose</code>函数向您介绍了一种编写函数的新方法。例如，这里有一个函数，给定一个数字列表，返回一个包含唯一偶数的列表。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="6c24" class="ls lt iq ng b gy nk nl l nm nn">const <strong class="ng ir">getUniqueEvenNumbers</strong> = <strong class="ng ir">pipe</strong>(<br/>  list =&gt; new Set(list),<br/>  Array.from,<br/>  list =&gt; list.filter(n =&gt; n % 2 === 0)<br/>);</span><span id="491c" class="ls lt iq ng b gy no nl l nm nn"><strong class="ng ir">getUniqueEvenNumbers(<br/>   </strong>[12, 54, 7, 33, 8, 90, 45, 22, 23, 8, 45, 54, 8, 12, 6]<br/>);<br/><em class="ne">// returns [12,54,8,90,22,6]</em></span></pre><p id="c771" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是使用这种技术而不是强制性编码来创建函数的美妙之处在于，当您拥有一堆小函数时，您可以轻松地组合或通过管道连接在一起来创建整个应用程序。这需要对你如何编程做很多调整，所以我建议开始慢慢探索<code class="fe np nq nr ng b">pipe</code>和<code class="fe np nq nr ng b">compose</code>。</p><p id="c4d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像<a class="ae kv" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>和<a class="ae kv" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> RxJs </a>这样的库是很有意思的，尽管它们一开始可能感觉超级复杂。如果你更喜欢冒险，我建议你学习一点关于λ微积分的知识。你会惊奇地发现你可以单独用函数来表示程序中的一切。</p><h2 id="6c0b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><p id="4b91" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">函数世界可能非常有趣，一开始可能会感觉有点复杂，但是作为任何开发人员，您都应该熟悉不同编程范例的基础知识，这样您就不会感到陌生。我使用一种混合风格，在这种风格中，我混合了许多函数式和面向对象的编程概念来尽可能多地构建东西。</p><p id="a812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解并掌握这几个概念肯定会从总体上改变你的编程方式。它为我改变了。我更加小心翼翼，为了可重用性和测试的缘故，我发现自己尽可能地分解事物。总体而言，它无疑提高了代码质量。我试着在我的发现中寻找乐趣。</p><p id="9cdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论你的风格是什么，关键是享受并不断发现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/79122679204c8ac0aa65ca22857737ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kKfpitAbaRbqRAXx0-YqTw.gif"/></div></div></figure><p id="9d9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> YouTube频道</strong> : <a class="ae kv" href="https://www.youtube.com/channel/UCrU33aw1k9BqTIq2yKXrmBw" rel="noopener ugc nofollow" target="_blank">分号前</a> <br/> <strong class="ky ir">网站</strong>:<a class="ae kv" href="https://beforesemicolon.com/" rel="noopener ugc nofollow" target="_blank">beforesemicolon.com</a></p></div></div>    
</body>
</html>