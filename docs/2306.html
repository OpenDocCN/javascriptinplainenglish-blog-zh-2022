<html>
<head>
<title>Angular vs. React — Lifecycle Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度与反应—生命周期方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-v-s-react-lifecycle-methods-4a9cd3b58891?source=collection_archive---------1-----------------------#2022-05-30">https://javascript.plainenglish.io/angular-v-s-react-lifecycle-methods-4a9cd3b58891?source=collection_archive---------1-----------------------#2022-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="030d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">知道这些生命周期方法何时被执行，并重构你的应用程序以正确利用它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f776911cfc0fbc44b340a74a5487f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZEv_oehm6I5fuIaSOrB5Q.png"/></div></div></figure><p id="4b43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你是Angular和React开发者吗？我是。你有没有想过，当数据改变时，你的UI组件的某些部分没有更新，你不得不求助于对<code class="fe ln lo lp lq b">ngDoCheck/ngOnChanges</code>或<code class="fe ln lo lp lq b">useEffect/shouldComponentUpdate</code>进行某种修改来更新那部分UI？也许是框架或库的问题，但也许你没有完全理解每个生命周期方法的真正含义。今天，我将快速介绍Angular和React中可用的生命周期方法，您可以决定如何使用它们来优化您的应用。</p><h1 id="2688" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">有角度的生命周期挂钩</h1><p id="cee6" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated"><code class="fe ln lo lp lq b">constructor</code> —该方法在组件的整个生命周期中只运行一次。</p><p id="13bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ngOnChanges</code> —此方法在Angular设置或重置数据绑定输入属性时响应，如果组件有绑定输入且输入改变时，此方法在<code class="fe ln lo lp lq b">ngOnInit</code>之前调用。</p><p id="d352" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ngOnInit</code> —在<code class="fe ln lo lp lq b">ngOnChanges</code>第一次运行后，该方法在组件的整个寿命期内只运行一次。</p><p id="2930" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ngDoCheck</code> —该方法在<code class="fe ln lo lp lq b">ngOnChanges</code>之后立即调用，或者在模板中有数据变化时调用(在<code class="fe ln lo lp lq b">changeDetection.default</code>模式下)，或者在<code class="fe ln lo lp lq b">changeDetectionRef.markForCheck</code>被调用时调用(在<code class="fe ln lo lp lq b">changeDetection.onPush</code>模式下)。</p><p id="2d4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ngAfterContentInit</code> —在第一个<code class="fe ln lo lp lq b">ngDoCheck</code>之后，该方法在组件的整个生命周期中只运行一次。</p><p id="56e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ngAfterContentChecked</code> —该方法在<code class="fe ln lo lp lq b">ngAfterContentInit</code>之后首先被调用，然后在每个<code class="fe ln lo lp lq b">ngDoCheck</code>之后被调用。</p><p id="4fa8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ngAfterViewInit</code> —在第一个<code class="fe ln lo lp lq b">ngAfterContentChecked</code>之后，该方法在组件的整个生命周期中只运行一次。</p><p id="f057" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ngAfterViewChecked</code> —该方法在<code class="fe ln lo lp lq b">ngAfterViewInit</code>之后首先被调用，然后在每个<code class="fe ln lo lp lq b">ngAfterContentChecked</code>之后被调用。</p><p id="6f4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ngOnDestroy</code> —在Angular破坏组件之前，该方法在组件的整个生命周期中只运行一次。</p><p id="70bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单介绍一下上面的方法，把你的眼睛放在这几个性能猪身上——<code class="fe ln lo lp lq b">ngOnChanges</code>(如果你有<code class="fe ln lo lp lq b">@input</code>)、<code class="fe ln lo lp lq b">ngDoCheck</code>、<code class="fe ln lo lp lq b">ngAfterContentChecked</code>、<code class="fe ln lo lp lq b">ngAfterViewChecked</code>。在这些hogger函数中保持你的方法简洁明了，你的应用程序将会再次活跃起来。</p><div class="mo mp gp gr mq mr"><a href="https://angular.io/guide/lifecycle-hooks" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">有角的</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Angular是一个构建移动和桌面web应用程序的平台。加入数百万开发者的社区…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">angular.io</p></div></div></div></a></div><h1 id="2f04" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">基于类的React生命周期挂钩</h1><p id="2249" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated"><strong class="kt ir"> <em class="na">初始化阶段</em> </strong></p><p id="4ead" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">constructor</code> —创建组件时调用一次。</p><p id="cf26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">getDerivedStateFromProps</code> —在DOM中呈现元素之前调用此方法。</p><p id="10b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">render</code> —调用该方法来呈现DOM中的元素。</p><p id="410a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">componentDidMount</code> —在DOM中呈现组件后调用该方法。</p><p id="a051" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="na">更新阶段——当状态或道具改变时</em> </strong></p><p id="e298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">getDerivedStateFromProps</code> —此方法在组件更新时但在DOM更新前调用。</p><p id="3c87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">shouldComponentUpdate</code> —该方法允许您运行比较逻辑来检查是否应该更新DOM。</p><p id="dd5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">render</code> —调用此方法来更新DOM中的元素。</p><p id="6656" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">getSnapshotBeforeUpdate</code> —此方法允许您在此周期更新之前访问状态和属性。这个方法必须和componentDidUpdate一起使用。</p><p id="7c49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">componentDidUpdate</code> —在DOM中更新组件后调用此方法。</p><p id="7e0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="na">卸载阶段</em> </strong></p><p id="fca3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">componentWillUnmount</code> —此方法在React从DOM中移除此组件之前调用一次。</p><p id="29f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似于Angular，在<code class="fe ln lo lp lq b">update phase</code>这里有一个快速注释，这里是性能霸。保持这些方法中的逻辑和检查简洁明了，这样就不会花费太多时间在每个状态或道具变化时运行它们。</p><h1 id="1456" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">基于函数的反应挂钩</h1><p id="0f8f" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated"><code class="fe ln lo lp lq b">useState</code> —该方法有两个部分，数组的第一个元素属于初始化赋值，数组的第二个元素属于更新数组的第一个元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/c3f25b68464b81c445ff3bfbf0130af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/0*GAL8kC7LbUzfgcpY.png"/></div></figure><p id="3a86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">useEffect</code> —该方法由许多部分组成，可以在单个组件中多次声明。让我们把它分成4个部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/dc78b90bdc2c23a21f3faa574038a9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/0*og0KKeHT4n_-YHtP.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">part 1</figcaption></figure><p id="0589" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面带方括号的<code class="fe ln lo lp lq b">useEffect</code>实现只会在初始化时调用一次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d8689fc042563a6e30551679c936cd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/0*7q0cS31ZxGTbFt4g.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">part 2</figcaption></figure><p id="b37a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面没有方括号的<code class="fe ln lo lp lq b">useEffect</code>实现将在组件的任何状态或属性发生变化时运行代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4662c5d1d8fc7858d97245c7d52a2cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*d-s_qKGJSR9MkILl.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">part 3</figcaption></figure><p id="a220" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面方括号中变量的<code class="fe ln lo lp lq b">useEffect</code>实现只有在变量被更改或更新时才会运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0d5150281f084f57c64ae43d8fa709e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/0*zwYaAXSXgMcX2J-E.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">part 4</figcaption></figure><p id="f229" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后但并非最不重要的一点，相当于<code class="fe ln lo lp lq b">componentWillUnmount</code>和<code class="fe ln lo lp lq b">ngOnDestroy</code>，上面带有返回回调函数的<code class="fe ln lo lp lq b">useEffect</code>实现将在组件从DOM中移除之前运行清理代码。</p><p id="75eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于第2部分的实现，有一点需要注意，如果你正在使用它，不要在你计划运行的<code class="fe ln lo lp lq b">useEffect</code>代码块中实现状态变化逻辑，否则，你将会陷入一个无限循环。</p><h1 id="4ec3" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">摘要</h1><p id="57f9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">我希望这篇文章能提醒你使用正确的生命周期方法来呈现或重新呈现你的UI组件。在高性能生命周期方法中不正确实现的逻辑会严重影响你的用户和应用。现在你已经看到了Angular和React可用的每一个生命周期方法和钩子，你将如何重构你的应用程序以使它更有性能？如果你有任何有趣的代码重构，请在下面的评论中告诉我。我也很想了解一下。干杯。</p><div class="mo mp gp gr mq mr"><a href="https://medium.com/@devjo/membership" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">用我的推荐链接- DevJo加入媒体</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np kp mr"/></div></div></a></div><p id="89c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="na">更多内容请看</em><a class="ae nq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="na">plain English . io</em></strong></a><em class="na">。报名参加我们的</em> <a class="ae nq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="na">免费周报</em> </strong> </a> <em class="na">。关注我们关于</em><a class="ae nq" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="na">Twitter</em></strong></a><em class="na">和</em><a class="ae nq" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="na">LinkedIn</em></strong></a><em class="na">。查看我们的</em> <a class="ae nq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="na">社区不和谐</em> </strong> </a> <em class="na">加入我们的</em> <a class="ae nq" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="na">人才集体</em> </strong> </a> <em class="na">。</em></p></div></div>    
</body>
</html>