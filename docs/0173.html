<html>
<head>
<title>Understand Scoping in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的作用域</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-scoping-in-javascript-299e88b2989b?source=collection_archive---------7-----------------------#2022-01-11">https://javascript.plainenglish.io/understand-scoping-in-javascript-299e88b2989b?source=collection_archive---------7-----------------------#2022-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c2ed" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解JavaScript中的一个重要主题——作用域。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/40d223aed6ab446dde96d9d0aa6d75df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7LIgTUxJQv27BeWi"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luca Bravo</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kt ku kv"><p id="cb26" class="kw kx ky kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">要理解JavaScript中的作用域是什么，首先必须理解一个叫做提升的重要概念。我将在这里简单地讨论变量提升，而不是函数提升，但是我建议在这里更好地了解这个概念。</p></blockquote><h1 id="ab0e" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">什么是吊装？</h1><p id="ee1e" class="pw-post-body-paragraph kw kx in kz b la ml jo lc ld mm jr lf mn mo li lj mp mq lm ln mr ms lq lr ls ig bi translated">提升是指在代码执行之前，解释器将变量、函数和类声明移动到其各自<em class="ky">范围顶部的过程。<em class="ky">只提升声明，不提升它们的初始化。</em></em></p><p id="a2be" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">这有助于我们在声明变量、函数和类之前使用它们，但这不是好的做法，因为它可能会导致错误。</p><p id="8910" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">让我们看看变量的提升是如何工作的:</p><h2 id="d36c" class="mt lu in bd lv mu mv dn lz mw mx dp md mn my mz mf mp na nb mh mr nc nd mj ne bi translated">→提升带有“var”关键字的变量</h2><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="06f3" class="mt lu in ng b gy nk nl l nm nn">var a = "hello";<br/>console.log(a); // prints "hello". </span></pre><p id="900b" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">提升期间:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="1f13" class="mt lu in ng b gy nk nl l nm nn">var a; // Declaration<br/>a = "hello"; // Initalization<br/>console.log(a); // prints "hello".</span></pre><p id="6000" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">如果我们试图访问一个使用<code class="fe no np nq ng b">var</code>声明的变量，在它被初始化之前，我们会得到<em class="ky">未定义的</em>，因为带有<code class="fe no np nq ng b">var</code>的变量的默认初始化是<em class="ky">未定义的</em>。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="71f7" class="mt lu in ng b gy nk nl l nm nn">console.log(a); // prints undefined.<br/>var a = "hello"; // Initalization</span></pre><h2 id="5ec7" class="mt lu in bd lv mu mv dn lz mw mx dp md mn my mz mf mp na nb mh mr nc nd mj ne bi translated">→使用“let”和“const”关键字提升变量</h2><p id="5256" class="pw-post-body-paragraph kw kx in kz b la ml jo lc ld mm jr lf mn mo li lj mp mq lm ln mr ms lq lr ls ig bi translated">使用<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>定义的变量的提升与使用<code class="fe no np nq ng b">var</code>定义的变量相同。带有<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>的变量与使用<code class="fe no np nq ng b">var</code>定义的变量之间的唯一区别在于默认的初始化值。</p><p id="5f30" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">当我们在<code class="fe no np nq ng b">var</code>变量初始化之前访问它时，我们得到了未定义的变量，因为这是<code class="fe no np nq ng b">var</code>变量的默认初始化。但是在<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>变量的情况下，不存在默认初始化。</p><p id="456c" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">如果我们试图访问<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>变量，我们会得到一个引用错误，说明我们试图在变量初始化之前访问它。请参见下面的示例:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="ad44" class="mt lu in ng b gy nk nl l nm nn">console.log(a); // ReferenceError: Cannot access 'a' before initialization"<br/>const a = 'hello';</span></pre></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="601f" class="lt lu in bd lv lw ny ly lz ma nz mc md jt oa ju mf jw ob jx mh jz oc ka mj mk bi translated">辖域</h1><p id="6c89" class="pw-post-body-paragraph kw kx in kz b la ml jo lc ld mm jr lf mn mo li lj mp mq lm ln mr ms lq lr ls ig bi translated">JavaScript中的范围是指与当前执行上下文相关的变量的可访问性。JavaScript中有3种作用域:I)全局作用域，II)函数作用域，III)块级作用域。</p><p id="a91f" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">JavaScript中的作用域取决于<em class="ky">如何定义变量</em>，即使用<code class="fe no np nq ng b">var</code>、<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>关键字。它还取决于变量在哪里定义的<em class="ky">，即在全局执行上下文中，还是在函数或块中(if-else，for循环，等等)。</em></p><p id="b3ec" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">现在，让我们看看<em class="ky">如何以及在哪里定义</em>一个变量会影响它的可访问性。</p><h1 id="3419" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">变量的可访问性</h1><p id="c692" class="pw-post-body-paragraph kw kx in kz b la ml jo lc ld mm jr lf mn mo li lj mp mq lm ln mr ms lq lr ls ig bi translated">全局执行上下文指的是没有在任何函数、任何块或任何类中定义的代码，你懂的。在全局执行上下文中定义的变量可以在代码中的任何地方使用。</p><p id="07fc" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">使用<code class="fe no np nq ng b">var</code>定义的变量只支持全局和功能级作用域，不支持块级作用域。而<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>变量支持所有三个。</p><p id="d792" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">看看下面的例子:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="fdd3" class="mt lu in ng b gy nk nl l nm nn">var globalVariable = 'hello world'; // variable in the global execution scope</span><span id="c273" class="mt lu in ng b gy od nl l nm nn">funtion test() {<br/>  console.log(globalVariable);<br/>}<br/>test(); // 'hello world'</span></pre><p id="71a5" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">这里，变量“globalVariable”被定义在函数外部的全局作用域中，所以我们可以在“test”函数中访问它。</p><p id="b6d1" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">考虑下面的另一个示例，并尝试猜测以下内容的输出:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="e00e" class="mt lu in ng b gy nk nl l nm nn">var a = 'hello';</span><span id="1860" class="mt lu in ng b gy od nl l nm nn">function test() {<br/>  var a = 'hey';<br/>  console.log(a);<br/>}<br/>test();<br/>console.log(a);</span></pre><p id="ff52" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">这里，函数test 内的第一个“console . log”<em class="ky">将打印“hey”，函数</em>外的第二个“console . log”<em class="ky">将打印“hello”。变量“a”在全局执行上下文中，具有全局范围，但是函数“test”中的变量“a”具有函数范围，因为该变量是在函数本身内部定义的。</em></p><p id="dae5" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">因此，当上面的代码运行时，由于提升会发生以下情况:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="0a24" class="mt lu in ng b gy nk nl l nm nn">var a; // variable "a" is declared<br/>a = 'hello'; // variable "a" is initialized</span><span id="9541" class="mt lu in ng b gy od nl l nm nn">function test() {<br/>  var a;  // variable "a" is moved to the top of its scope<br/>  a = 'hey'; // now the functional scope variable "a" is intialized<br/>  console.log(a); // "hey"<br/>}<br/>test();<br/>console.log(a); // "hello"</span></pre><p id="f2e2" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">现在，假设这是代码:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="ed2e" class="mt lu in ng b gy nk nl l nm nn">var a= 'hello';</span><span id="41a6" class="mt lu in ng b gy od nl l nm nn">function test() {<br/>  a = 'hey';<br/>  console.log(a); // "hey"<br/>}<br/>test();<br/>console.log(a); "hey"</span></pre><p id="a85b" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">这里，由于在函数内部，我们没有使用<code class="fe no np nq ng b">var</code>、<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>关键字来定义变量，它自动在全局范围内引用变量，并将其值从“hello”更新为“hey”。这就是为什么我们在控制台中看到“嘿”打印两次。</p><p id="87f2" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">看看另一个例子:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="d26b" class="mt lu in ng b gy nk nl l nm nn">var a = 'hello';</span><span id="af9f" class="mt lu in ng b gy od nl l nm nn">if(true) {<br/>  var a = 'hey';<br/>  console.log(a);<br/>}</span><span id="a1d1" class="mt lu in ng b gy od nl l nm nn">console.log(a); </span></pre><p id="22c8" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">你能猜出上面代码的输出吗？。如果你对两个“console.log”的回答都是“嘿”,那么你就对了。我们第二次看到“嘿”而不是“你好”的原因是因为<code class="fe no np nq ng b">var</code>关键字。由于使用<code class="fe no np nq ng b">var</code>定义的变量范围仅限于全局和函数范围，它们不适用于块级范围。在这种情况下，发生提升时，代码如下所示:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="15ef" class="mt lu in ng b gy nk nl l nm nn">var a; <br/>a = 'hello';</span><span id="77e1" class="mt lu in ng b gy od nl l nm nn">if(true) {<br/>  a = 'hey';<br/>  console.log(a);<br/>}</span><span id="7647" class="mt lu in ng b gy od nl l nm nn">console.log(a);</span></pre><p id="cfcb" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">因为“var”关键字不支持块级作用域，所以它引用了全局作用域中的变量“a”。</p><p id="a594" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">所以，在JavaScript的<strong class="kz io"> ES6(2015) </strong>之前，只有一种方法可以使用<code class="fe no np nq ng b">var</code>关键字声明变量。ES6(2015)引入了<code class="fe no np nq ng b">let</code>和<code class="fe no np nq ng b">const</code>——声明变量的新方法。<code class="fe no np nq ng b">let</code>和<code class="fe no np nq ng b">const</code>为JavaScript中的变量启用了块级范围。</p><p id="4734" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">让我们看看前面的例子，但是我们将使用<code class="fe no np nq ng b">let</code>而不是<code class="fe no np nq ng b">var</code>来声明一个变量。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="faf0" class="mt lu in ng b gy nk nl l nm nn">let a = 'hello';</span><span id="7b2a" class="mt lu in ng b gy od nl l nm nn">if(true) {<br/>  let a = 'hey';<br/>  console.log(a); // prints "hey"<br/>}</span><span id="e3d3" class="mt lu in ng b gy od nl l nm nn">console.log(a); // prints "hello"</span></pre><p id="fd1e" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">这里第一个<em class="ky"> console.log </em>印“嘿”，第二个印“你好”。这是因为<code class="fe no np nq ng b">let</code>关键字及其提供的块级范围。如果我们使用关键字<code class="fe no np nq ng b">const</code>而不是<code class="fe no np nq ng b">let</code>，同样的事情也会发生。让我们在吊装时看看上面的代码:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="4eb8" class="mt lu in ng b gy nk nl l nm nn">let a;<br/>a = 'hello';</span><span id="e90b" class="mt lu in ng b gy od nl l nm nn">if(true) {<br/>  let a;<br/>  a = 'hey';<br/>  console.log(a); // prints "hey"<br/>}</span><span id="a584" class="mt lu in ng b gy od nl l nm nn">console.log(a); // prints "hello"</span></pre><p id="36be" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">使用<code class="fe no np nq ng b">let</code>声明的变量值可以更新，但是使用<code class="fe no np nq ng b">const</code>声明的变量值不能更新。</p><p id="e05d" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">当使用<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>声明一个变量时，我们不能在这个特定的作用域中用相同的名字命名另一个变量，但是可以在另一个作用域中重复这个名字。</p><p id="5d82" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">看看另一个例子:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="8b3a" class="mt lu in ng b gy nk nl l nm nn">var a = 'hello';</span><span id="0494" class="mt lu in ng b gy od nl l nm nn">function scope() {<br/>  if(a !== undefined) {<br/>   var a = 'hey';<br/>  }<br/>  console.log(a);<br/>}</span><span id="c39b" class="mt lu in ng b gy od nl l nm nn">scope();</span></pre><p id="3d3e" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">在这里,“console.log”将打印“undefined”而不是“hey ”,因为我们知道<code class="fe no np nq ng b">var</code>变量不支持块级作用域，只支持全局和函数级作用域。这是在吊装过程中发生的:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="10d0" class="mt lu in ng b gy nk nl l nm nn">// GLOBAL SCOPE<br/>var a;<br/>a = 'hello';</span><span id="6827" class="mt lu in ng b gy od nl l nm nn">function scope() {<br/> // FUNCTIONAL LEVEL SCOPE <br/>  var a;<br/>  if(a !== undefined) { // this conditional evaluated to false since "a" is undefined (as seen in hoisting)<br/>   a = 'hey';<br/>  }<br/>  console.log(a); // this "a" refrenced the variable "a" in the functional level scope and the not the variable "a" in global scope.<br/>}</span><span id="57be" class="mt lu in ng b gy od nl l nm nn">scope();</span></pre><p id="452a" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">让我们使用<code class="fe no np nq ng b">let</code>或<code class="fe no np nq ng b">const</code>更新上面的代码，</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="3514" class="mt lu in ng b gy nk nl l nm nn">let a = 'hello';</span><span id="774c" class="mt lu in ng b gy od nl l nm nn">function scope() {<br/>  if(a !== undefined) {<br/>   let a = 'hey';<br/>    console.log(a); // prints "hey".<br/>  }<br/>  console.log(a); // prints "hello".<br/>}</span><span id="7892" class="mt lu in ng b gy od nl l nm nn">scope();</span></pre><p id="9224" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">这里," if "块中的第一个" console.log "打印" hey ",第二个" console.log "打印" hello"。让我们看一下吊装，以便更好地理解:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="6da6" class="mt lu in ng b gy nk nl l nm nn">let a;<br/>a = 'hello';</span><span id="32ba" class="mt lu in ng b gy od nl l nm nn">function scope() {<br/>  if(a !== undefined) {<br/>    let a;    <br/>    a = 'hey';<br/>    console.log(a); // prints "hey".<br/>  }<br/>  console.log(a); // prints "hello".<br/>}</span><span id="20ca" class="mt lu in ng b gy od nl l nm nn">scope();</span></pre><p id="ec0d" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">这里,“if”<em class="ky">条件</em>中的变量“a”引用了全局作用域中的变量“a ”,因为函数级作用域中没有变量“a”。</p><p id="0001" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">在“if”条件中，我们创建了一个新变量“a ”,由于它是使用<code class="fe no np nq ng b">let</code>定义的，提升过程只将这个变量移动到块级范围的顶部，而没有移动到函数级范围的顶部，因为<code class="fe no np nq ng b">let</code>和<code class="fe no np nq ng b">const</code>支持块级范围。</p><p id="10fd" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated">因此，第一个“console.log”引用了“if”块级范围内的变量，第二个“console.log”引用了全局范围内的变量，因为在功能级范围内没有变量“a”。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="9e75" class="lt lu in bd lv lw ny ly lz ma nz mc md jt oa ju mf jw ob jx mh jz oc ka mj mk bi translated"><strong class="ak">结论:</strong></h1><p id="bc38" class="pw-post-body-paragraph kw kx in kz b la ml jo lc ld mm jr lf mn mo li lj mp mq lm ln mr ms lq lr ls ig bi translated">希望现在变量提升和变量作用域的概念对你来说更清楚了。这些是JavaScript中最重要的概念，每个JavaScript开发人员都必须理解。这些主题不仅在为你的应用程序编写代码时会派上用场，在面试时也会派上用场。</p><p id="f51f" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf mn lh li lj mp ll lm ln mr lp lq lr ls ig bi translated"><em class="ky">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kz io"><em class="ky">plain English . io</em></strong></a><em class="ky">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> <em class="ky">免费周报</em> </strong> </a> <em class="ky">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> <em class="ky">社区</em> </strong> </a> <em class="ky">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>