<html>
<head>
<title>Custom Implementation of JavaScript Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript方法的自定义实现</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/custom-implementation-javascript-methods-part-2-fa9456ca79a4?source=collection_archive---------12-----------------------#2022-09-12">https://javascript.plainenglish.io/custom-implementation-javascript-methods-part-2-fa9456ca79a4?source=collection_archive---------12-----------------------#2022-09-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e1bd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:用JavaScript中的typeof运算符自定义实现shallowCompare()和deepCompare()。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/a5a2cda762cdd9e6cbc95633c996b8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*TMswwB3rNiQyyo35hYfyzw.png"/></div></figure><h1 id="9952" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated"><span class="l lc ld le bm lf lg lh li lj di">D</span>T3】eep/Shallow与运算符类型的比较</h1><p id="e1e7" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">嗨，伙计们，今天我将向你们展示如何使用自定义的typeof操作符为浅层和深层拷贝编写自定义的实现。</p><p id="d882" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">我们开始吧。</strong></p><p id="694d" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">首先，我们需要知道什么是浅层比较和深层比较。当我们在采访中被问到这些术语时，它们非常吓人，但是一旦你理解了JavaScript运行时环境，它们的意思就变得非常简单了。</p><p id="0588" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">让我告诉你，在JavaScript中，基本类型和非基本类型之间的比较在某些部分非常令人困惑，但是如果你确切地知道JavaScript中基本类型和非基本类型之间的区别，这些将很容易回答并向其他人解释。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="e000" class="ms kl in bd km mt mu dn kq mv mw dp ku lt mx my kw lx mz na ky mb nb nc la nd bi translated">JavaScript中的原语类型和非原语类型是什么？</h2><p id="b1a7" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><em class="ne">原始数据类型不是任何对象，也没有附加属性或方法的数据类型。</em></p><p id="eb96" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">有7种原始数据类型:</strong></p><ul class=""><li id="a326" class="nf ng in lm b ln mg lq mh lt nh lx ni mb nj mf nk nl nm nn bi translated">线</li><li id="d168" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">数字</li><li id="2769" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">bigint</li><li id="f42b" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">布尔型</li><li id="3103" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">不明确的</li><li id="e32c" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">标志</li><li id="f976" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">空</li></ul><p id="db22" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">与原语数据类型相关的重要一点是所有原语都是不可变的。也就是说，它们不能被改变。</p><p id="27af" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">如果你需要了解更多关于原始数据类型的信息，请访问:<a class="ae nt" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Glossary/Primitive</a></p><p id="8359" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><em class="ne">非原始数据类型被称为派生(引用类型),这意味着它仅从原始数据类型派生而来。</em></p><ul class=""><li id="749b" class="nf ng in lm b ln mg lq mh lt nh lx ni mb nj mf nk nl nm nn bi translated">数组</li><li id="e610" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">目标</li></ul><p id="5064" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在我们对什么是原始数据类型和引用数据类型有了一点了解，让我们继续深入浅出比较的话题。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="81cb" class="ms kl in bd km mt mu dn kq mv mw dp ku lt mx my kw lx mz na ky mb nb nc la nd bi translated">1.浅层比较()</h2><p id="4bef" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">浅层比较是一种检查两个值是否相等的比较。应该在一个级别上检查它，这意味着嵌套对象引用还没有准备好进行比较，只允许在原始和非原始数据类型之间进行一个级别的比较。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/4587837bdda0f8ac0b6d6758b9eedcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWokWO1hGb2xzvObXAoKEQ.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Shallow comparison on 1st level</figcaption></figure><p id="aa01" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">该图表明，如果发生浅层比较，它应该正确地发生在一个级别，而不是嵌套级别。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi od"><img src="../Images/44f00880de058c19fbe425571b79892b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogEWHhmZbJzNSl7liWrenQ.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Shallow comparison is not allowed on nested references.</figcaption></figure><p id="f40e" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><em class="ne">在我们跳转到</em> <strong class="lm io"> <em class="ne">自定义实现浅层比较</em> </strong> <em class="ne">之前，我们需要再做一个自定义实现</em> <strong class="lm io"> <em class="ne"> typeof运算符</em> </strong> <em class="ne">(一个内置的JavaScript方法)——你可以使用</em> <code class="fe oe of og oh b"><em class="ne">typeof</em></code> <em class="ne">运算符来查找一个JavaScript变量的数据类型。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6636c875e7e2348cc2900f5d6eef2a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*VbNJx1lGNNknfaGsfilqGw.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Inbuilt type of operator</figcaption></figure><p id="060f" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我认为JavaScript的一个主要缺点是，它会返回所有引用类型的对象类型，如数组、对象、日期、空值等。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/8d2715084c8b2452040bcea167e2c9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*N6RS5chqhCGWjhda99wVMQ.png"/></div></figure><p id="649f" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><em class="ne">所以如果你需要知道它是数组还是对象，那是不可能的。它总是返回一个令人困惑的对象，但毕竟它是由JavaScript设计人员设计的，记住数组被当作一个对象，这是因为它在JavaScript中具有动态类型的特性。** </em></p><p id="5811" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io"> <em class="ne">所以，要实现展示它是数组还是对象，还是日期的功能，我们需要编写我们自定义的typeof运算符。</em> </strong></p><p id="b011" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">让我给你看看它的样子:</p><h2 id="8731" class="ms kl in bd km mt mu dn kq mv mw dp ku lt mx my kw lx mz na ky mb nb nc la nd bi translated"><strong class="ak"> <em class="ok">自定义实现—运算符类型</em> </strong></h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi ol"><img src="../Images/2551220ca4d2ca2e600feabf74bba96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_KDCoyVUI8st1WtEYka3A.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Custom TypeOf operator</figcaption></figure><p id="9daf" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在，我们得到了所传递的引用数据类型的确切类型，无论是数组、对象还是日期。</p><p id="07c4" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在做任何进一步的拖延之前，让我们集中精力进行肤浅的比较。</p><h2 id="aadf" class="ms kl in bd km mt mu dn kq mv mw dp ku lt mx my kw lx mz na ky mb nb nc la nd bi translated"><strong class="ak">自定义实现— shallowCompare() </strong></h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi om"><img src="../Images/f0f08a59c039a9b7b84469552acf6ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvsVNAstYc0UAAZ7AyE6aA.png"/></div></div></figure><p id="6521" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在这个实现中，我们使用了自定义的typeof操作符来检查它是数组、对象、日期还是其他什么。该函数将只在一个级别上进行浅层比较，而不是在嵌套级别上。让我们看一个例子:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi on"><img src="../Images/f51d30a4d6318b634363fafeebf9c9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUi8i9y51cskVgQx8iz3kQ.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Examples</figcaption></figure></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h1 id="44e1" class="kk kl in bd km kn oo kp kq kr op kt ku jt oq ju kw jw or jx ky jz os ka la lb bi translated">2.深度比较()</h1><p id="bee6" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">深度比较是一种检查两个值是否相等的比较，应该在所有级别进行检查，这意味着嵌套的对象引用已准备好进行比较。深度比较是在嵌套对象、数组等上测试的。</p><h2 id="0c52" class="ms kl in bd km mt mu dn kq mv mw dp ku lt mx my kw lx mz na ky mb nb nc la nd bi translated"><strong class="ak">自定义实现— deepCompare() </strong></h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi ot"><img src="../Images/b503c5d33bccc6101da29c870f610753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWa118ualbzLe8FH8lVU8Q.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Deep comparison</figcaption></figure><p id="f53c" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">只有一点需要注意的是，在深度比较中，由于多级或嵌套级的比较，需要对同一个函数进行递归调用。因为我们有嵌套的对象和数组，我们需要在多个层次上检查它们。</p><p id="d7ad" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">此外，由于递归调用，深度比较比浅层比较要慢。</p><p id="0602" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">让我们看看例子:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi ou"><img src="../Images/8e4daca11db8487e2d365abd02cd347d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4Vd_uB1MMNODH99Toykig.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Deep comparison examples.</figcaption></figure><p id="3a9d" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">因此，我们已经了解了JavaScript中的typeof运算符、shallowCompare()和deepCompare()函数的自定义实现，以及它们是如何用于处理和比较原始和非原始数据类型的。</p><p id="334f" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在定制实现的下一部分中，我们将看到更多的定制实现，这将有助于您理解幕后发生的事情。敬请关注更多内容！</p><p id="038b" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><em class="ne">希望你喜欢，请鼓掌、订阅、分享，并保存以备将来参考。:)</em></p><p id="0d7b" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><em class="ne">谢谢</em></p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><p id="37e1" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><em class="ne">更多内容请看</em><a class="ae nt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lm io"><em class="ne">plain English . io</em></strong></a><em class="ne">。报名参加我们的</em> <a class="ae nt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lm io"> <em class="ne">免费周报</em> </strong> </a> <em class="ne">。关注我们关于</em><a class="ae nt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lm io"><em class="ne">Twitter</em></strong></a><a class="ae nt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lm io"><em class="ne">LinkedIn</em></strong></a><em class="ne"/><a class="ae nt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lm io"><em class="ne">YouTube</em></strong></a><em class="ne"/><a class="ae nt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lm io"><em class="ne">不和</em> </strong> </a> <em class="ne">。对增长黑客感兴趣？检查</em> <a class="ae nt" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lm io"> <em class="ne">电路</em> </strong> </a> <em class="ne">。</em></p></div></div>    
</body>
</html>