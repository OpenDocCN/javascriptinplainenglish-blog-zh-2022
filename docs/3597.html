<html>
<head>
<title>Your Next.js Bundle Will Thank You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的Next.js包会感谢你的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/your-next-js-bundle-will-thank-you-89962402a5ec?source=collection_archive---------3-----------------------#2022-09-10">https://javascript.plainenglish.io/your-next-js-bundle-will-thank-you-89962402a5ec?source=collection_archive---------3-----------------------#2022-09-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b08d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果您的Next.js应用程序遇到了非常大的包的问题，那么这篇文章可能是您的救星。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/31c41a811ceeb15a4ea61eda60f0e594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGgIhOSNmQJxcGOgh7CIfQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture by Marek Piwnicki on Unsplash</figcaption></figure><p id="4568" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果您的Next.js应用程序遇到了非常大的包的问题，那么这篇文章可能是您的救星。</p><h1 id="898a" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">前言</h1><p id="1fdc" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">在最后一段时间，我不得不使用Next.js做一个项目，要求提高它的性能，因为不知道什么原因，一切似乎都非常慢。</p><p id="3ef3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">虽然在本文中除了包的大小还有其他问题(缺少图像优化，不良的缓存策略)，但是我将专门关注包的大小所引起的问题。</p><h1 id="e429" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">初始检查</h1><p id="76b9" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">我做了一些检查，运行了几个Lighthouse报告，最终在移动和桌面上的平均性能得分为<strong class="ku io"> 35分</strong>。实际上，他们没有错，只是存在一些问题。在快速检查报告之后，我继续进行另一种类型的测试，启动一个产品构建来检查接下来提供给我们的漂亮报告。这个结果让我<strong class="ku io">从椅子上跳了起来</strong>。</p><p id="f195" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了说明这一点，让我们从正确的东西开始，下面是一个完全可以接受的中小型next应用程序的构建。(其实是我的<a class="ae ml" href="https://renatopozzi.me" rel="noopener ugc nofollow" target="_blank">网站</a>)。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d6b4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如您所看到的，第一个负载JS在100kB以下，所以您漂亮的终端将以令人振奋的绿色显示。</p><p id="b4e1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，在我告诉你的情况下，输出是完全不同的。只是稍微大一点…</p><h1 id="4178" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">分析问题</h1><p id="edb6" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">为了更好地帮助您理解和测试，我准备了一个演示项目，其中包含的问题与我正在处理的问题类似，这样您就可以以一种实用的方式帮助您理解如何着手解决这类问题。您将看到的数据和测量值与这个演示项目相关。你可以看看所有的<a class="ae ml" href="https://github.com/itsrennyman/demo-bundle-analysis" rel="noopener ugc nofollow" target="_blank">源代码</a>，它真的很小，所以需要很短的时间。</p><p id="2b70" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下面是被指控的应用程序的生产版本的输出:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ddf2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你不觉得很麻烦吗？个人觉得，看到这种东西我有点害怕。现在让我们分析这个输出，并找出一些恢复这个应用程序的想法。</p><p id="20ee" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">一些快速注释可以帮助您更好地理解这里的总体问题:</p><h2 id="181d" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">所有文件共享的JS</h2><p id="2dc2" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">如您所见，底部显示了一个部分，其中指定了所有底层代码如何被为API和页面生成的每个块继承。</p><p id="44b5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是什么意思？例如，在/sign-in页面中，第一次加载的JS为303kB，但是公共部分的重量为109kB，这意味着该页面中使用的模块的实际重量为194kB。</p><h2 id="773e" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">CSS不包括在计算中</h2><p id="a2f5" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">对许多人来说这可能是显而易见的，但值得指出的是，对于那些可能是新手的人来说，你在底部看到的任何CSS都不包括在计算中。这并不是说它没有引起可能的问题，而是与另一种类型的问题相关。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="d380" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以，让我们从一些看似显而易见的事情开始，怎么可能所有的页面<strong class="ku io">都是相同大小的</strong>？这是非常奇怪的，看所有的网页都有不同的导入源，因此，它们应该有不同的大小，对吗？同样有趣的是，<em class="nh"> _app </em>是<strong class="ku io">相对较小的</strong>，所以不会对这些巨大的数字产生太大的影响。</p><p id="ecdd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们可以做的一件事是尝试分析我们的生产捆绑包，看看它会告诉我们什么，我们可以使用一个非常好的工具来进行捆绑包分析，称为<a class="ae ml" href="https://www.npmjs.com/package/@next/bundle-analyzer" rel="noopener ugc nofollow" target="_blank"> Next.js Bundle Analyzer </a>它非常容易安装(所以我将跳过这一部分)，它会为您提供一个关于所有软件包大小的漂亮的交互式热图。</p><p id="aa79" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是构建的依赖关系热图，如果您下载了源代码，也可以使用<code class="fe ni nj nk nl b">ANALYZE=true npm run build</code>来完成:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/96653cbc75346740de1abb3cd40e4d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URdaPXwNYLFrTS_06v7MuA.png"/></div></div></figure><p id="533e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你从未见过这样的图表，它可能看起来非常复杂，实际上概念很简单，最大的窗格是最重的，窗格的内容是包含在相应最大窗格中的源代码。</p><p id="3884" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">那么，快速浏览一下图表，你认为问题出在哪里？实际上，这里有两个主要问题，让我们一个一个地深入探讨。</p><p id="5291" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">第一个问题</strong>对于通常不做这类事情的人来说可能很难发现，但是它很快就会变得非常明显:有一大块<strong class="ku io">包含了所有的依赖关系！</strong></p><p id="3c9a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">是的，我说的是左边的那块，你知道吗？这个将与所有导入<strong class="ku io">至少一个依赖项的页面共享，即使后者很小</strong>！我认为这是一个有用的提示，关于为什么所有的页面都有相同的大小！</p><p id="2d8e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">第二个</strong>相反，可能更容易发现，这个应用程序使用了一些巨大的依赖项，首先跳出来的是:</p><ul class=""><li id="a531" class="nn no in ku b kv kw ky kz lb np lf nq lj nr ln ns nt nu nv bi translated">@ mui/x-数据网格</li><li id="ba58" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated">ajv</li><li id="5206" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated">反应电话输入标签</li></ul><p id="766d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在知道这些依赖项的名称后，我们可以采取的一个好的行动是快速查看我们的源代码，看看它们在哪里被使用以及使用了多少。在我们的情况下，如果您愿意，您也可以这样做，但是如果您不愿意，好消息是，我已经为您做了这项工作，结果是:</p><ul class=""><li id="45df" class="nn no in ku b kv kw ky kz lb np lf nq lj nr ln ns nt nu nv bi translated">@mui/x-data-grid在<code class="fe ni nj nk nl b">random-table.js</code>组件中使用，而该组件仅在<code class="fe ni nj nk nl b">table.js</code>页面上使用。</li><li id="3857" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated">“ajv”包非常相似，它被用在了<code class="fe ni nj nk nl b">auth-form.js</code>组件中，而这个组件只被用在了<code class="fe ni nj nk nl b">signin.js</code>页面中。</li><li id="af63" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated">最后一个在<code class="fe ni nj nk nl b">PhoneInput</code>中使用，但是后面的<strong class="ku io">没有在任何页面上使用</strong>！！！</li></ul><p id="cbd0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，知道了是什么导致了这个问题，回头看一下前面构建的输出。WTF正在这里发生！？</p><h1 id="0b81" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">桶形锉的神奇疯狂</h1><p id="11f2" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">明确一下，什么是桶形锉？嗯，你知道什么时候你把所有的导出放在一个<code class="fe ni nj nk nl b">index.js</code>文件中，以便有更容易的导入路径吗？这是一个桶形锉。(你知道Node.js创建者<a class="ae ml" href="https://youtu.be/M3BM9TB-8yA?t=883" rel="noopener ugc nofollow" target="_blank">后悔创建了它</a>吗？)</p><p id="e482" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">因此，我想进行试验，查看捆绑包度量，我们肯定知道<code class="fe ni nj nk nl b">ajv</code>是一个严重的依赖项，因此我将打开<code class="fe ni nj nk nl b">signin.js</code>页面，并对AuthForm组件进行注释。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="aeab" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">太好了，我迫不及待地想重做一次，看看我减了多少体重！所以我重启了一个版本…“快乐音乐停止了”，什么都没改变。<code class="fe ni nj nk nl b">signin.js</code>页<strong class="ku io">还是303kB </strong>...</p><p id="dc90" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在一阵歇斯底里中，我决定尝试一切，所以我也评论了<code class="fe ni nj nk nl b">Navbar</code>组件，会发生一些事情，不是吗？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="463f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在下一个版本<strong class="ku io">神奇的事情发生了</strong>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6e13" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在书页失去了所有的重量！这怎么可能呢？是不是<code class="fe ni nj nk nl b">Navbar</code>组件导致了一切？试着把所有东西都装回去，这次只移除<code class="fe ni nj nk nl b">Navbar</code>组件。有什么变化吗？</p><p id="da14" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我猜猜，没有吧？因此，我们确定，通过分别移除这两个组件，问题仍然存在，但是当我们去移除这两个组件时，一切都神奇地消失了。</p><p id="a9ac" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在我想让你知道我隐藏的一个小秘密，这样你就可以推理和理解发生了什么，我将通过做最后一个测试让你知道，让我们试着像这样改变导入:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6c0b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们启动另一个构建，现在发生了什么？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="780c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">看起来权重降低了不少，当然还是大因为让我们记住<code class="fe ni nj nk nl b">AuthForm</code>使用的是重度依赖，但是和现在相比有什么实质性的区别呢？</p><p id="64db" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果您注意到components文件夹内部，有一个迄今为止从未提及的看似无害的文件index.js:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f1d1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">想一想这个文件中发生了什么，这个文件负责导出<code class="fe ni nj nk nl b">components</code>文件夹中的所有组件，使它们可以用于更简单的导入语法。我将在此粘贴两个导入版本之间的差异:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d6eb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以，是的，我们保存了一个子目录，但是结果是什么呢？从这个<code class="fe ni nj nk nl b">index.js</code>中导入哪怕是一个很小的模块也足以导致页面包中所有其他组件的大量导入。</p><p id="6ebf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这就是为什么当我们只移除了<code class="fe ni nj nk nl b">AuthForm</code>和<code class="fe ni nj nk nl b">Navbar</code>之间的两个组件中的一个时，结果没有改变，因为两者都导致了相同的大规模导入效应。只有将它们都删除，文件<code class="fe ni nj nk nl b">index.js</code>的引用才会丢失，因此没有组件被导入！</p><p id="6cf7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">作为继续之前的最后一个测试，让我们替换每个页面上的所有导入，并启动另一个构建:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4d67" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在一切似乎更加一致，考虑到使用的模块，每个页面似乎都有正确的大小。</p><p id="1e61" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">事实上，<strong class="ku io">页面变大并不奇怪，因为查看热图我们知道@mui/x-data-grid确实很大。</strong></p><h1 id="92c7" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">为什么会这样？</h1><p id="ad7b" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">到目前为止，我们已经发现并解决了所有页面都有一个由未使用的依赖项组成的巨大捆绑包的问题，我们看到这是从一个<code class="fe ni nj nk nl b">index.js</code>文件导入的原因，现在我想解释一下为什么这个东西会导致这个问题。</p><p id="81c1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">通常，在生产构建中，JavaScript代码会经历几个操作，包括移除未使用的模块，这种特殊现象被称为<strong class="ku io">树抖动</strong>。你可以这样想象:你的花园里有一棵树，那棵树是你的应用程序源代码，绿色健康的叶子是你的应用程序使用的模块，而棕色和几乎枯死的叶子是未使用的模块。</p><p id="461f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在想象用你所有的力量摇动这棵树<strong class="ku io">让枯叶落到地上，只留下健康的叶子</strong>。这就是树抖动，在我们的例子中，通常是由Webpack或Rollup这样的模块捆绑器完成的。</p><p id="dac3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">基本上，Next.js的思想是，框架试图通过创建页面相关的块来应用代码分割，试图删除特定页面的所有未使用的模块，以使它们更快地加载，并且没有无用的代码要评估。</p><p id="fc7b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是有些情况下，我们的bundler(这里是webpack，因为它被Next使用)不能自动删除一些模块。这只是因为Terser(web pack用于此操作的模块)<strong class="ku io">不能总是安全地确定是否使用模块导出</strong>。正如webpack文档所说:</p><blockquote class="ob oc od"><p id="62c7" class="ks kt nh ku b kv kw jo kx ky kz jr la oe lc ld le of lg lh li og lk ll lm ln ig bi translated">Terser试图弄清楚，但在许多情况下它并不确定。这并不意味着terser没有做好自己的工作，因为它想不通。在JavaScript这样的动态语言中，要可靠地确定它太难了。</p></blockquote><p id="fe6f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是否意味着桶形文件不能再使用了？<strong class="ku io">大概不是</strong>。</p><h1 id="f418" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">替代解决方案</h1><p id="3fd9" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">我已经听到你们的声音用这样的短语轰炸我的脑袋:</p><blockquote class="ob oc od"><p id="ce74" class="ks kt nh ku b kv kw jo kx ky kz jr la oe lc ld le of lg lh li og lk ll lm ln ig bi translated">是的，一切都很好，但是有没有办法通过保留<code class="fe ni nj nk nl b">index.js</code>来获得相同的结果？</p></blockquote><p id="e539" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">实际上，(大部分时间)对你来说是有替代方案的。</p><p id="c699" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如你刚刚读到的，Terser做得很好，但有时它并不完美。为了让它更好地工作，我们可以给webpack一个叫做<code class="fe ni nj nk nl b">sideEffects</code>的好提示。这个值可以放入一个<code class="fe ni nj nk nl b">package.json</code>，并接受正则表达式、字符串和布尔值作为值。<strong class="ku io">但是</strong>到底是什么副作用呢？</p><p id="abf1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">官方文件可以帮助我们:</p><blockquote class="ob oc od"><p id="6f9e" class="ks kt nh ku b kv kw jo kx ky kz jr la oe lc ld le of lg lh li og lk ll lm ln ig bi translated">“副作用”被定义为在导入时执行特殊行为的代码，而不是公开一个或多个导出。这方面的一个例子是聚合填充，它影响全局范围，通常不提供导出。</p></blockquote><p id="058e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">例如，在我们的例子中，我们不使用任何副作用，所以我们可以直接设置false，帮助webpack删除未使用的模块:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e433" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，如果我们试图创建一个生产构建，从barrel (index.js)文件中保留我们的旧导入，看看会发生什么:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7208" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当我们用单个文件替换桶文件中的所有导入时，我们得到了相同的结果！您还可以查看新的热图，立即发现差异。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/ced7d56a1796d4c809ee0af386ada96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsoqgsGDP48__wBYZVXR2g.png"/></div></div></figure><p id="2bf7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">看看现在有多少不同的块(大小不同)，我们没有更多的大块被所有页面共享！</p><h2 id="0b5f" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">一个聪明的问题</h2><p id="6217" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">你还记得我们什么时候从<code class="fe ni nj nk nl b">signin.js</code>页面中移除了<code class="fe ni nj nk nl b">AuthForm</code>和<code class="fe ni nj nk nl b">Navbar</code>组件吗？我们最初解决了这个问题，但是是我错了，还是仍然存在一个导入的依赖？</p><blockquote class="ob oc od"><p id="380e" class="ks kt nh ku b kv kw jo kx ky kz jr la oe lc ld le of lg lh li og lk ll lm ln ig bi translated">从“@mui/material”导入{ Box }；</p></blockquote><p id="184a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为什么这种依赖没有继续导致其他两个问题？然而这里又一次使用了一个<a class="ae ml" href="https://github.com/mui/material-ui/blob/master/packages/mui-material/src/index.js#L51" rel="noopener ugc nofollow" target="_blank">桶文件</a>来导出所有的组件，嗯，答案还是可以在这里找到<a class="ae ml" href="https://github.com/mui/material-ui/blob/master/packages/mui-material/package.json#L76" rel="noopener ugc nofollow" target="_blank">。如果你想知道，</a><a class="ae ml" href="https://github.com/chakra-ui/chakra-ui/blob/main/packages/components/accordion/package.json#L27" rel="noopener ugc nofollow" target="_blank"> ChakraUI </a>在所有组件上都使用了相同的技术，而<a class="ae ml" href="https://github.com/mantinedev/mantine/blob/master/src/mantine-core/package.json#L10" rel="noopener ugc nofollow" target="_blank"> MantineUI </a>也在使用它，甚至<a class="ae ml" href="https://github.com/lodash/lodash/blob/master/package.json#L10" rel="noopener ugc nofollow" target="_blank"> Lodash </a>(在ESM版本中)也利用了这种技术。</p><h1 id="a53a" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">增强树木摇晃的常见技巧</h1><p id="24b3" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">我认为有许多我们可以应用的技巧，我将在这里写下一些我现在经常使用的技巧。</p><h2 id="c552" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">使用树震动库</h2><p id="f182" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">同样，这可能是老生常谈，但经常看到项目有大量不可树摇动的依赖项，你怎么知道其中一个是否可树摇动呢？使用像<a class="ae ml" href="https://bundlephobia.com/" rel="noopener ugc nofollow" target="_blank">捆绑恐惧症</a>这样的工具。</p><h2 id="2d60" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">避免传输到公共文件</h2><p id="b67b" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">你应该配置你的捆绑器，让你所有的ESM保持完整，而不是把它转移到CJS，否则，树抖动将更难从捆绑器上应用。例如，您可以使用这段代码创建Babel:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="2c80" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">避免明星进口</h2><p id="1da6" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">你应该只导入你需要的模块，避免从一个模块中导入*，否则所有的东西都将包含在你的代码块中，即使它没有被使用！</p><h1 id="73f5" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">处理巨大的依赖性</h1><p id="7cdd" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">所以，一个问题解决了，但我们又有了另一个问题。让我们考虑如何处理这些巨大的依赖性，选择其中之一，我通常会问自己一些问题:</p><ul class=""><li id="2591" class="nn no in ku b kv kw ky kz lb np lf nq lj nr ln ns nt nu nv bi translated">这个库是必需的还是可以用其他东西代替？</li><li id="ad5e" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated">如果我们需要这些功能，有没有更轻量级的替代品来做同样的事情？(想想lodash和lodash-es)</li></ul><p id="db29" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们一个接一个地挑选这些依赖项，看看我们是否可以做一些替换，从最大的那个<strong class="ku io"> @mui/x-data-grid </strong>开始。</p><blockquote class="ob oc od"><p id="2d47" class="ks kt nh ku b kv kw jo kx ky kz jr la oe lc ld le of lg lh li og lk ll lm ln ig bi translated">快速提醒一下，正如我之前说的，这个项目是一个例子，它不是真实的东西，它是为了教学的目的。请根据您的需求考虑这些事项！</p></blockquote><p id="1c69" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以，看看代码，基本上，我们显示的是一个表格，没有任何特殊的需求，它只是一个用户列表。我们不关心这个网格提供给我们的任何复杂特性。而且，在需要排序或搜索的情况下，我们肯定可以使用更轻量级的解决方案，比如更轻量级的<a class="ae ml" href="https://tanstack.com/table/v8" rel="noopener ugc nofollow" target="_blank"> react-table </a>。</p><p id="bc6d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们继续谈论<strong class="ku io"> ajv </strong>，即使在这种情况下，这里的要求是验证一个简单的表单，简单到我们甚至可以手工完成。在这种情况下，没有太多要说的，如果没有障碍，选择一个与此不同的解决方案是很好的。这个库<a class="ae ml" href="https://bundlephobia.com/package/ajv@8.11.0" rel="noopener ugc nofollow" target="_blank">不是树摇式的</a>，这一事实强调了这一点。一个不同的库？超级结构可能很酷(也更轻)。</p><p id="8716" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最后一个是最简单的，实际没有用到<strong class="ku io">react-phone-input-labelled</strong>。这可以很容易地删除，因为它唯一的任务就是增加包的重量，但是为什么我要包含它呢？仅仅是因为<strong class="ku io">通常</strong>如果代码库没有持续维护，那么在各种变更和需求变更之间<strong class="ku io">可能会有一些东西留在源代码中，甚至没有被使用</strong>。因此，有时做一个依赖检查，然后看看是否可以删除一些东西，以节省字节和构建时间，这是很好的。</p><h1 id="1e81" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">最后但同样重要的是！</h1><p id="9466" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">这是一个漫长的旅程，但我希望你们都安然无恙，如果有任何问题或者你只是想停下来打个招呼，你可以在<a class="ae ml" href="https://twitter.com/imarenny" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae ml" href="https://www.linkedin.com/in/itsrennyman/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p><p id="1487" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">另外，顺便在我的留言簿上签名，让我知道你对这篇文章的看法！</p><p id="32c5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我会在下面留下一些可能对你有帮助的链接！</p><ul class=""><li id="d29e" class="nn no in ku b kv kw ky kz lb np lf nq lj nr ln ns nt nu nv bi translated"><a class="ae ml" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">摇树文档(Webpack) </a></li><li id="db47" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated"><a class="ae ml" href="https://bundlephobia.com/" rel="noopener ugc nofollow" target="_blank">恐束症</a></li><li id="c880" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated"><a class="ae ml" href="https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost" rel="noopener ugc nofollow" target="_blank">vs code的导入成本</a></li><li id="70b1" class="nn no in ku b kv nw ky nx lb ny lf nz lj oa ln ns nt nu nv bi translated"><a class="ae ml" href="https://renatopozzi.me/" rel="noopener ugc nofollow" target="_blank">我的网站！</a></li></ul></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="467b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="nh">更多内容请看</em><a class="ae ml" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nh">plain English . io</em></strong></a><em class="nh">。报名参加我们的</em> <a class="ae ml" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="nh">免费周报</em> </strong> </a> <em class="nh">。关注我们关于</em><a class="ae ml" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nh">Twitter</em></strong></a><a class="ae ml" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nh">LinkedIn</em></strong></a><em class="nh"/><a class="ae ml" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nh">YouTube</em></strong></a><em class="nh"/><a class="ae ml" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nh">不和</em> </strong> </a> <em class="nh">。对增长黑客感兴趣？检查</em> <a class="ae ml" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="nh">电路</em> </strong> </a> <em class="nh">。</em></p></div></div>    
</body>
</html>