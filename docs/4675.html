<html>
<head>
<title>How to Compare Array Elements in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何比较JavaScript中的数组元素</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/surviving-the-attack-solving-a-real-world-problem-with-javascript-f80509886cc5?source=collection_archive---------15-----------------------#2022-12-22">https://javascript.plainenglish.io/surviving-the-attack-solving-a-real-world-problem-with-javascript-f80509886cc5?source=collection_archive---------15-----------------------#2022-12-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><h2 id="a085" class="ip iq ir bd b dl is it iu iv iw ix dk iy translated" aria-label="kicker paragraph">DevAdvent 2022</h2><div class=""/><div class=""><h2 id="4926" class="pw-subtitle-paragraph jx ja ir bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">使用函数确定决斗的结果</h2></div><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/16e6b039b0399d757802b265dccaf31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpV-FgwDtRjqNCLBOwgAFA.jpeg"/></div></div></figure><p id="2300" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">今天的DevAdvent的问题是比较两个数组的元素。有趣的是，这个问题是如何通过一个真实世界的例子呈现出来的。想象一下，你想建立一个游戏，让两个团队互相对抗。每一名队员向对方队员挑战。在这种情况下，从数组中得到决斗结果的JavaScript函数正是我们所需要的。</p><h1 id="0d00" class="lx ly ir bd lz ma mb mc md me mf mg mh kg mi kh mj kj mk kk ml km mm kn mn mo bi translated">问题:在攻击中生存下来</h1><p id="e4b7" class="pw-post-body-paragraph lb lc ir ld b le mp kb lg lh mq ke lj lk mr lm ln lo ms lq lr ls mt lu lv lw ik bi translated">链接到<a class="ae mu" href="https://www.codewars.com/kata/634d0f7c562caa0016debac5" rel="noopener ugc nofollow" target="_blank">武士刀</a></p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj mv"><img src="../Images/344c84a7cc2ab41efa1cef934c618ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFwqk-j8lzbk6lIT-SRBag.jpeg"/></div></div></figure><p id="b0ff" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">给定两个数组，其中值是每个士兵的力量，如果你在攻击中幸存，则返回真；如果你死亡，则返回假。</p><p id="0992" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><strong class="ld jb">条件</strong></p><ul class=""><li id="4dbe" class="mw mx ir ld b le lf lh li lk my lo mz ls na lw nb nc nd ne bi translated">每个士兵在阵列的同一索引中攻击对方士兵。幸存者是价值最高的数字。</li><li id="7a24" class="mw mx ir ld b le nf lh ng lk nh lo ni ls nj lw nb nc nd ne bi translated">如果价值是相同的，他们都灭亡了</li><li id="79ca" class="mw mx ir ld b le nf lh ng lk nh lo ni ls nj lw nb nc nd ne bi translated">如果其中一个值为空(不同的数组长度)，则非空值士兵存活。</li><li id="aac8" class="mw mx ir ld b le nf lh ng lk nh lo ni ls nj lw nb nc nd ne bi translated">为了生存，防守方必须比进攻方有更多的幸存者。</li><li id="d003" class="mw mx ir ld b le nf lh ng lk nh lo ni ls nj lw nb nc nd ne bi translated">如果双方的幸存者人数相同，获胜者是初始攻击能力最高的队伍。如果双方的总攻击力量都是一样的，那也是事实。</li><li id="6eb3" class="mw mx ir ld b le nf lh ng lk nh lo ni ls nj lw nb nc nd ne bi translated">初始攻击强度是每个数组中所有值的总和。</li></ul><p id="7a31" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><strong class="ld jb">示例</strong></p><pre class="kq kr ks kt gu nk nl nm bn nn no bi"><span id="d205" class="np ly ir nl b be nq nr l ns nt">attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4, 6, 8 ]<br/>//0 survivors                4 survivors<br/>//return true<br/><br/>attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4 ]<br/>//2 survivors  (16 damage)   2 survivors (6 damage)<br/>//return false<br/><br/>attackers=[ 1, 3, 5, 7 ]   defenders=[ 2, 4, 0, 8 ]<br/>//1 survivors                3 survivors<br/>//return true</span></pre><h1 id="44e7" class="lx ly ir bd lz ma mb mc md me mf mg mh kg mi kh mj kj mk kk ml km mm kn mn mo bi translated">解决方案</h1><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj mv"><img src="../Images/ed141e0bef4cd11cfa54c8db4f633225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vK7yi9sV7k9UFRGzJk2Z7A.jpeg"/></div></div></figure><p id="cd82" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">这个解决方案在概念上非常简单。我可以创建一个类似这样的JavaScript函数:</p><pre class="kq kr ks kt gu nk nl nm bn nn no bi"><span id="ca45" class="np ly ir nl b be nq nr l nu nt">export const hasSurvived = (attackers, defenders) =&gt; {<br/>  let attackingPower = attackers.reduce((acc, val) =&gt; acc + val, 0);<br/>  let defendingPower = defenders.reduce((acc, val) =&gt; acc + val, 0);<br/><br/>  let attackingSurvivors = 0;<br/>  let defendingSurvivors = 0;<br/><br/>  for (let i = 0; i &lt; Math.max(attackers.length, defenders.length); i++) {<br/>    if (i &gt;= attackers.length) {<br/>      defendingSurvivors++;<br/>    } else if (i &gt;= defenders.length) {<br/>      attackingSurvivors++;<br/>    } else if (attackers[i] &gt; defenders[i]) {<br/>      attackingSurvivors++;<br/>    } else if (defenders[i] &gt; attackers[i]) {<br/>      defendingSurvivors++;<br/>    }<br/>  }<br/><br/>  return (<br/>    defendingSurvivors &gt; attackingSurvivors ||<br/>    (defendingSurvivors === attackingSurvivors &amp;&amp;<br/>      defendingPower &gt;= attackingPower) ||<br/>    (defendingSurvivors === attackingSurvivors &amp;&amp;<br/>      attackingPower === defendingPower)<br/>  );<br/>};</span></pre><p id="a282" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">该函数首先计算进攻和防守队的初始进攻力量。然后，它遍历数组并比较每个索引处的值。如果<code class="fe nv nw nx nl b">attackers</code>数组中当前索引处的值大于<code class="fe nv nw nx nl b">defenders</code>数组中相同索引处的值，则攻击幸存者的数量增加。如果<code class="fe nv nw nx nl b">defenders</code>数组中当前索引处的值大于<code class="fe nv nw nx nl b">attackers</code>数组中相同索引处的值，则防御幸存者的数量增加。如果两个阵列中的一个比另一个短，则较长阵列中幸存的士兵也会被计算在内。</p><p id="db21" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">最后，如果防御幸存者的数量大于攻击幸存者的数量，或者如果幸存的士兵数量相同但是防御团队有更高的初始攻击力量，或者如果双方的总攻击力量相同，则函数返回<code class="fe nv nw nx nl b">true</code>。如果不满足这些条件，则返回<code class="fe nv nw nx nl b">false</code>。</p><p id="4fda" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">然而，有一件事我不喜欢。这一系列的“if…then…else”条件使得阅读代码变得困难，并且它们使得函数看起来不那么优雅。随着时间的推移，我注意到当一个JavaScript函数看起来很难看时，这意味着有一些地方需要改进。</p><p id="7790" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">让我们仔细看看代码。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj mv"><img src="../Images/d3cb5c736070ea7a02379106a9e6b20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8z5Z5KVWhqRrStX3ORWLA.jpeg"/></div></div></figure><p id="c1f4" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我想做的是比较数组中的每个元素，然后计算有多少元素满足给定的条件。</p><p id="8f4e" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我将尝试用不同的方式重新表述这个句子:我想从每个数组中获取满足特定条件的所有元素。换句话说，我想过滤掉所有大于另一个数组中相应元素的元素。</p><p id="c3c1" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">在这里，通过重新表述问题，我得到了一个新的想法。我可以使用<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"> Array.filter() </a>方法来比较每个数组中的各种元素，只保留我们感兴趣的元素。</p><pre class="kq kr ks kt gu nk nl nm bn nn no bi"><span id="01e5" class="np ly ir nl b be nq nr l nu nt">let defendersAfterFight = defenders.filter((e, i) =&gt; 0 &lt; e - attackers[i]);<br/>let attackersAfterFight = attackers.filter((e, i) =&gt; 0 &lt; e - defenders[i]);</span></pre><p id="7e07" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">现在我要做的就是计算每个数组的长度，找出进攻方和防守方有多少幸存者。</p><pre class="kq kr ks kt gu nk nl nm bn nn no bi"><span id="a849" class="np ly ir nl b be nq nr l nu nt">const hasSurvived = (attackers, defenders) =&gt; {<br/>  let attackingPower = attackers.reduce((acc, val) =&gt; acc + val, 0);<br/>  let defendingPower = defenders.reduce((acc, val) =&gt; acc + val, 0);<br/><br/>  let defendersAfterFight = defenders.filter((e, i) =&gt; 0 &lt; e - attackers[i]);<br/>  let attackersAfterFight = attackers.filter((e, i) =&gt; 0 &lt; e - defenders[i]);<br/><br/>  return (<br/>    defendersAfterFight.length &gt; attackersAfterFight.length ||<br/>    (defendersAfterFight.length === attackersAfterFight.length &amp;&amp;<br/>      defendingPower &gt;= attackingPower)<br/>  );<br/>};</span></pre><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj ny"><img src="../Images/9a265d2d02aad8ad05669fe3caab6697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGygjEiC6F7zfnaLp_7M1w.png"/></div></div></figure><p id="ef75" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我可以通过直接计算各种数组的长度来进一步简化代码。</p><pre class="kq kr ks kt gu nk nl nm bn nn no bi"><span id="16a7" class="np ly ir nl b be nq nr l nu nt">const hasSurvived = (attackers, defenders) =&gt; {<br/>  let attackingPower = attackers.reduce((acc, val) =&gt; acc + val, 0);<br/>  let defendingPower = defenders.reduce((acc, val) =&gt; acc + val, 0);<br/><br/>  let defendersSurvived = defenders.filter(<br/>    (d, i) =&gt; 0 &lt; d - attackers[i]<br/>  ).length;<br/>  let attackersSurvived = attackers.filter(<br/>    (a, i) =&gt; 0 &lt; a - defenders[i]<br/>  ).length;<br/><br/>  return (<br/>    defendersSurvived &gt; attackersSurvived ||<br/>    (defendersSurvived === attackersSurvived &amp;&amp;<br/>      defendingPower &gt;= attackingPower)<br/>  );<br/>};</span></pre><p id="f177" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">如果要夸大，可以进一步减少解决问题所需的代码行数。</p><p id="30e2" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">但是我不推荐。JavaScript函数很难读懂。使代码过于复杂没有实际好处。最好写干净、易读的代码:我们未来的自己会感谢我们的。</p><pre class="kq kr ks kt gu nk nl nm bn nn no bi"><span id="3663" class="np ly ir nl b be nq nr l nu nt">const hasSurvived = (a, d) =&gt;<br/>  d.filter((x, i) =&gt; 0 &lt; x - a[i]).length &gt;<br/>    a.filter((x, i) =&gt; 0 &lt; x - d[i]).length ||<br/>  (d.filter((x, i) =&gt; 0 &lt; x - a[i]).length ===<br/>    a.filter((x, i) =&gt; 0 &lt; x - d[i]).length &amp;&amp;<br/>    d.reduce((c, v) =&gt; c + v, 0) &gt;= a.reduce((c, v) =&gt; c + v, 0));</span></pre><p id="ba0d" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">感谢阅读！敬请关注更多内容。</p></div><div class="ab cl nz oa hv ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ik il im in io"><p id="9ef0" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><strong class="ld jb"> <em class="og">不要错过我的下一篇文章—报名我的</em> </strong> <a class="ae mu" href="https://medium.com/subscribe/@el3um4s" rel="noopener"> <strong class="ld jb"> <em class="og">中邮箱列表</em> </strong> </a></p><div class="oh oi gq gs oj ok"><a href="https://el3um4s.medium.com/membership" rel="noopener follow" target="_blank"><div class="ol ab fp"><div class="om ab on cl cj oo"><h2 class="bd jb gz z fq op fs ft oq fv fx ja bi translated">通过我的推荐链接加入Medium—Samuele</h2><div class="or l"><h3 class="bd b gz z fq op fs ft oq fv fx dk translated">阅读萨缪尔的每一个故事(以及媒体上成千上万的其他作家)。不是中等会员？在这里加入一块…</h3></div><div class="os l"><p class="bd b dl z fq op fs ft oq fv fx dk translated">el3um4s.medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kz ok"/></div></div></a></div></div><div class="ab cl nz oa hv ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ik il im in io"><p id="ba26" class="pw-post-body-paragraph lb lc ir ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><em class="og">原载于2022年12月22日https://blog.stranianelli.com</em><a class="ae mu" href="https://blog.stranianelli.com/devadvent-2022-22-survive-the-attack/" rel="noopener ugc nofollow" target="_blank"><em class="og"/></a><em class="og">。</em></p><h2 id="257d" class="oz ly ir bd lz pa pb dn md pc pd dp mh lk pe pf mj lo pg ph ml ls pi pj mn ix bi translated">更多内容请访问<a class="ae mu" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> PlainEnglish.io </a>。</h2><p id="e8a0" class="pw-post-body-paragraph lb lc ir ld b le mp kb lg lh mq ke lj lk mr lm ln lo ms lq lr ls mt lu lv lw ik bi translated"><em class="og">报名参加我们的</em> <a class="ae mu" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ld jb"> <em class="og">免费周报</em> </strong> </a> <em class="og">。关注我们上</em> <a class="ae mu" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ld jb"> <em class="og">推特</em> </strong> </a>，<a class="ae mu" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="ld jb"> <em class="og">领英</em> </strong> </a> <strong class="ld jb"> <em class="og">，</em></strong><a class="ae mu" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ld jb"><em class="og">YouTube</em></strong></a><strong class="ld jb"><em class="og">，以及</em></strong><em class="og"/><a class="ae mu" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ld jb"><em class="og">不和</em> </strong> </a>T47】</p><h2 id="9278" class="oz ly ir bd lz pa pb dn md pc pd dp mh lk pe pf mj lo pg ph ml ls pi pj mn ix bi translated">想扩大你的软件创业规模吗？检查<a class="ae mu" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank">电路</a>。</h2></div></div>    
</body>
</html>