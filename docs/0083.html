<html>
<head>
<title>Simple hack with React Element and JSX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的黑客与反应元素和JSX</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-react-elements-position-matters-1e50aa239560?source=collection_archive---------5-----------------------#2022-01-06">https://javascript.plainenglish.io/why-react-elements-position-matters-1e50aa239560?source=collection_archive---------5-----------------------#2022-01-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a50640f2819f5b2b1421844f3ab9c038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zi6_XtN2o_ZxuH6lcTIhbg.png"/></div></div></figure><p id="a315" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有完美的软件。作为开发人员，我们必须时刻意识到未来的变化。明白了这一点，React有一个强大的组合模型，很容易交换组件。因为我们可以创造性地选择如何定位和交换我们的组件，所以会有不同的结果，每种结果都有自己的好处，这取决于上下文。最好，在本文中，我们将讨论定位组件的不同方法，了解它们，并明智地选择合适的方法。</p><h1 id="3f3a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">目录:</h1><ul class=""><li id="0c37" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated"><strong class="jx io">什么是React元素？JSX运输公司？:</strong>为什么？稍后我们将在此基础上解释接下来的概念。</li><li id="26a3" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated"><strong class="jx io">渲染行为:</strong>React元素在渲染过程中的作用，浪费渲染是如何发生的？</li><li id="be5a" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated"><strong class="jx io">常量元素如何帮助优化渲染</strong></li></ul><h1 id="5719" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">什么是React元素？JSX运输公司？</strong></h1><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/7819d6a514b0ce4666188d12b953a53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*yKEMbP5qB7Yug_9t9smbZQ.jpeg"/></div></figure><p id="21ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个<strong class="jx io"> React元素</strong>是由一个<strong class="jx io">组件</strong>返回的。它是一个虚拟描述组件所代表的树节点的对象。</p><p id="69f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">等等，什么？我没有看到组件返回的任何对象？不就是<strong class="jx io"> JSX </strong>吗？</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bda0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我解释一下！</p><p id="9945" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">诚然，Component返回JSX，但JSX是一种JavaScript无法直接读取的特殊语法。相反，它需要transpilers将其转换成createElement调用，这只是JavaScript普通对象。根据你的栈，传输可以通过<strong class="jx io"> Babel </strong>或者<strong class="jx io"> TypeScript </strong>来完成。这就是为什么你总是要用<code class="fe mo mp mq mr b">import React from ‘react’</code>来写JSX，因为它需要运行<strong class="jx io"> </strong> <code class="fe mo mp mq mr b">React.createElement</code>，所以<code class="fe mo mp mq mr b">React</code>需要在范围内。从React 17开始，有了一个新JSX变换——不再需要导入，如果你好奇，可以在这里阅读更多<a class="ae ms" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a14d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想测试一些特定的JSX是如何转换成JavaScript的，你可以试试<a class="ae ms" href="https://babeljs.io/repl" rel="noopener ugc nofollow" target="_blank">巴别在线编译器</a>。</p><h2 id="c351" class="mt ku in bd kv mu mv dn kz mw mx dp ld kg my mz lh kk na nb ll ko nc nd lp ne bi translated">多个孩子</h2><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c420" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React不限制一个组件的子组件数量，它会被编译成:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f72d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，我们学习漂亮的JSX和元素的想法，这将支持即将到来的事情。</p><h1 id="32b8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">渲染行为:</strong></h1><p id="ad09" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ig bi translated">渲染是一个React发现布局树应该是什么样子的过程，它发生在挂载和更新的时候。在更新期间，执行协调以收集新树和旧树之间的差异，一旦组件被标记为需要更新，React将重新渲染其所有子组件，即使这些子组件保持不变。在这方面，浪费的渲染出现，可能会花费很多精力，可能会减慢我们的应用程序。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="ni mn l"/></div></figure><p id="6c91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在GIF中，我建了一个例子，其中<code class="fe mo mp mq mr b">Component A</code> &gt; <code class="fe mo mp mq mr b">Component B</code> &gt; <code class="fe mo mp mq mr b">Component C</code> &gt; <code class="fe mo mp mq mr b">Component D</code>，A是B的父组件，以此类推。由于React中的渲染行为，当组件A被标记为需要重新渲染时，所有子组件也会重新渲染，如果子组件没有更改，它也不会在意。它从父节点开始跟踪并diff到其子节点，所以重新渲染B只触发C &amp; D，A不在其中。</p><p id="8931" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时，其中一个孩子很慢，我们不希望在慢的组件上进行不必要的重新渲染。优化一个东西有两种方法，要么让它跑得更快，要么跳过工作。在React中，大多数优化都是关于跳过工作的。React提供了3个主要方法来实现这一点:<strong class="jx io"> React。PureComponent </strong>，<strong class="jx io"> shouldComponentUpdate </strong>，<strong class="jx io"> React.memo </strong>。我就不赘述了，你可以在<a class="ae ms" rel="noopener ugc nofollow" target="_blank" href="/react-native-why-props-references-break-optimizations-79c463ca0723">我之前的博客</a>里看到。相反，利用对元素和JSX的理解，我们得到了另一个简单的方法，没有使用上述3种方法。</p><h1 id="fb37" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">常量元素如何帮助优化渲染</strong></h1><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bb3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看这个例子，我们有一个<code class="fe mo mp mq mr b">SlowComponent</code>，它将渲染延迟了<strong class="jx io"> 1秒</strong>，还有一个<code class="fe mo mp mq mr b">TestCon</code>显示<code class="fe mo mp mq mr b">count</code>，它在按下时增加计数。</p><p id="ba6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看有<code class="fe mo mp mq mr b">SlowComponent</code>和没有<code class="fe mo mp mq mr b">SlowComponent</code>两种情况的区别:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nj mn l"/></div></figure><p id="73e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所见，当我注释掉<code class="fe mo mp mq mr b">SlowComponent</code>时，我们的反例运行顺利；否则，<code class="fe mo mp mq mr b">SlowComponent</code>会将SlowComponent的渲染延迟<strong class="jx io"> 1秒</strong>，这也会影响到<code class="fe mo mp mq mr b">TestCon</code>。为什么？正如我解释的，上面的渲染行为，<code class="fe mo mp mq mr b">TestCon</code>中的<code class="fe mo mp mq mr b">setCount</code>也触发其子组件重新渲染，<code class="fe mo mp mq mr b">SlowComponent</code>延迟1秒，作为父组件的<code class="fe mo mp mq mr b">TestCon</code>必须等待<code class="fe mo mp mq mr b">SlowComponent</code>完成，最终提交到树。</p><h2 id="463a" class="mt ku in bd kv mu mv dn kz mw mx dp ld kg my mz lh kk na nb ll ko nc nd lp ne bi translated">修复</h2><p id="4667" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ig bi translated">常见的修复是<strong class="jx io">协同状态</strong>，以及我上面提到的3种方法。<strong class="jx io">共置状态</strong>意味着将<code class="fe mo mp mq mr b">count</code>状态和使用它的组件包装成一个单独的组件。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2a77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mo mp mq mr b">WrapperComponent</code>是新添加的组件，用它包装<code class="fe mo mp mq mr b">count</code>状态和布局。这样做可以防止<code class="fe mo mp mq mr b">SlowComponent</code>被重新渲染，因为现在更新被标记在<code class="fe mo mp mq mr b">WrapperComponent</code>处，而不再是<code class="fe mo mp mq mr b">TestCon</code>处，所以它只关注<code class="fe mo mp mq mr b">WrapperComponent</code>及其子节点。</p><p id="e222" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">等等！如果有另一个<code class="fe mo mp mq mr b">MondayComponent</code>需要使用计数，或者一个新的<code class="fe mo mp mq mr b">ParentView</code>也需要使用计数:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f315" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">哦不！在这种情况下我们不能使用共存状态，我们需要<code class="fe mo mp mq mr b">TestCon</code>处的<code class="fe mo mp mq mr b">count</code>将它传递给<code class="fe mo mp mq mr b">ParentView</code>和<code class="fe mo mp mq mr b">MondayComponent</code>。</p><p id="ec2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个简单的技巧就能让<code class="fe mo mp mq mr b">SlowComponent</code>飞起来。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="322c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提升内容意味着将<code class="fe mo mp mq mr b">SlowComponent</code>传递给<code class="fe mo mp mq mr b">TestCon</code>作为道具，孩子只是一个道具，所以<code class="fe mo mp mq mr b">props.children</code>或<code class="fe mo mp mq mr b">props.renderSlow</code>或任何你喜欢的名字都无关紧要。这样做如何防止<code class="fe mo mp mq mr b">SlowComponent</code>重新渲染？</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4650" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了看起来更好，我稍微简化了这个例子，所以现在只有<code class="fe mo mp mq mr b">View</code>和<code class="fe mo mp mq mr b">SlowComponent</code>。</p><p id="606c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们用上面学到的关于<strong class="jx io"> JSX </strong>和<strong class="jx io"> createElement </strong>来描述两种写作方式。</p><p id="a739" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于第一种情况，每次<code class="fe mo mp mq mr b">TestCon</code>重新渲染时，<code class="fe mo mp mq mr b">React.createElement(SlowComponent)</code>都会被调用，因此它在渲染之间总是不同的，所以React只是重新渲染它，这解释了为什么其他子组件也会被重新渲染。</p><p id="fbc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于第二种情况，不管<code class="fe mo mp mq mr b">TestCon</code>重新渲染多少次，<code class="fe mo mp mq mr b">props.children</code>总是相同的，因为基于它被定义的位置，它是一个常数，并且它的引用是相同的。</p><p id="5c87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">引用在React生态系统中起着重要的作用，它影响大多数优化方法，因为React内部使用浅层比较。</p><p id="06b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此提升内容会阻止内容的重新呈现。请注意，在现实世界的例子中，有些情况下，您希望将子对象与父对象一起重新渲染，或者跳过重新渲染子对象以提高性能，这取决于具体情况。所以明智地选择:</p><pre class="mi mj mk ml gt nk mr nl nm aw nn bi"><span id="2c48" class="mt ku in mr b gy no np l nq nr">&lt;TestCon&gt;&lt;SlowComponent/&gt;&lt;/TestCon&gt; and use props.children<br/>==&gt; when you want skip SlowComponent rendering</span><span id="445e" class="mt ku in mr b gy ns np l nq nr">otherwise, use SlowComponent directly for re-render along with parent</span><span id="45fd" class="mt ku in mr b gy ns np l nq nr">const TestCon = ()=&gt;{<br/> return(<br/>   &lt;View&gt;<br/>    &lt;SlowComponent/&gt;<br/>   &lt;/View&gt;<br/> )<br/>}</span></pre><p id="a724" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总的来说，这是优化组件的众多方法中的一个简单的方法，只需将它们放在周围即可。适当地使用它，不同的情况需要不同的方法。</p><p id="3530" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nt">更多内容看</em> <a class="ae ms" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nt">说白了. io </em> </a> <em class="nt">。报名参加我们的</em> <a class="ae ms" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nt">免费周报</em> </a> <em class="nt">。在我们的</em> <a class="ae ms" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nt">社区</em> </a> <em class="nt">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>