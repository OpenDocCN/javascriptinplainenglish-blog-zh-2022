<html>
<head>
<title>Design Patterns: Facade Pattern in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:TypeScript中的外观模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/design-patterns-facade-pattern-in-typescript-53b23f009d9e?source=collection_archive---------3-----------------------#2022-10-28">https://javascript.plainenglish.io/design-patterns-facade-pattern-in-typescript-53b23f009d9e?source=collection_archive---------3-----------------------#2022-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2cfc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Facade模式为一组复杂的子系统接口提供了一个更高级别的统一接口，通过它可以更容易地访问子系统接口</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d7e897886da64e3f133e9d803d3b6c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lfgn6CXSCgzoytfX"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pawel Czerwinski</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f13a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎来到TypeScript 系列的<strong class="ky ir">设计模式，这里介绍了一些使用TypeScript进行web开发时有用的设计模式。</strong></p><div class="ls lt gp gr lu lv"><a href="https://medium.com/frontend-canteen/9-design-patterns-every-engineer-should-know-f2423d36d468" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">每个工程师都应该知道的9种设计模式</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">掌握这9种设计模式，写出更好的代码</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="55b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计模式对于web开发人员来说非常重要，通过掌握它们我们可以写出更好的代码。在本文中，我将使用<strong class="ky ir">类型脚本</strong>来介绍<strong class="ky ir"> Facade模式。</strong></p><p id="d6f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">facade模式为一组复杂的子系统接口提供了一个更高级别的统一接口，通过它可以更容易地访问子系统接口。<strong class="ky ir">通过引入一个新的facade类</strong>，可以降低原有系统的复杂度，减少客户端类和子系统类之间的耦合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/0bad8ad09dc9b9b3910a12aadd0428ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jZCG6tGawZ-vRn1Suh56g.jpeg"/></div></div></figure><p id="719c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Facade模式要求子系统外部与其内部之间的通信通过统一的Facade对象来执行，Facade类将客户端与子系统内部的复杂性分开，这样客户端只需要处理Facade对象，而不需要处理子系统内部的许多对象。</p><p id="8bd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我将介绍如何使用Facade模式使访问子系统接口变得更容易。为了更好地理解下面的代码，我们先来看看相应的UML图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/fdd73a86db803df97c5f59060672e2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1Q4fsw05JQfcXzVQASvqA.png"/></div></div></figure><p id="5269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">外观模式包括以下角色:</p><ul class=""><li id="dc84" class="mm mn iq ky b kz la lc ld lf mo lj mp ln mq lr mr ms mt mu bi translated"><strong class="ky ir">门面</strong> : ShapeFacade</li><li id="5c6f" class="mm mn iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated"><strong class="ky ir">子系统</strong>:圆形、矩形、三角形</li></ul><p id="5e84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们定义<code class="fe na nb nc nd b">Shape</code>接口和实现该接口的三个类来表示不同的形状。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在定义了不同的形状类之后，让我们创建<code class="fe na nb nc nd b">ShapeFacade</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a3f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了<code class="fe na nb nc nd b">ShapeFacade</code>类，客户端对象可以使用<code class="fe na nb nc nd b">ShapeFacade</code>对象来绘制不同的形状。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d305" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了帮助你更好的理解facade模式的作用，我们用一张图来展示不使用facade模式和使用facade模式的区别:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/0daa0002778fd0bca686befcc5c2b57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FF_4TSDHCHCm7dzaQROzVg.jpeg"/></div></div></figure><p id="b8ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">web项目中facade模式的一个常见用例是处理浏览器web API兼容性。例如，在不同的浏览器环境中处理事件监听:</p><pre class="kg kh ki kj gt ng nd nh ni aw nj bi"><span id="d54d" class="nk nl iq nd b gy nm nn l no np">function addHandler(element, type, handler) {<br/>  if (element.addEventListener) {<br/>    element.addEventListener(type, handler, false);<br/>  } else if (element.attachEvent) {<br/>    element.attachEvent("on" + type, handler);<br/>  } else {<br/>    element["on" + type] = handler;<br/>  }<br/>}</span></pre><p id="d995" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们实现了向不同的浏览器添加事件侦听器的过程。代码实现起来也很简单，但是有一个问题，就是每次调用都需要判断，这显然是不合理的。对于以上问题，我们可以通过<strong class="ky ir">懒加载函数</strong>来解决。</p><p id="e6aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所谓懒加载，就是第一次根据条件执行函数时，第二次调用函数时，不再判断条件，直接执行函数。</p><p id="d6ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这个函数，我们可以在满足第一个条件判断中的判断条件的分支中覆盖被调用的函数:</p><pre class="kg kh ki kj gt ng nd nh ni aw nj bi"><span id="8cc8" class="nk nl iq nd b gy nm nn l no np">function addHandler(element, type, handler) {<br/>  if (element.addEventListener) {<br/>    addHandler = function (element, type, handler) {<br/>      element.addEventListener(type, handler, false);<br/>    };<br/>  } else if (element.attachEvent) {<br/>    addHandler = function (element, type, handler) {<br/>      element.attachEvent("on" + type, handler);<br/>    };<br/>  } else {<br/>    addHandler = function (element, type, handler) {<br/>      element["on" + type] = handler;<br/>    };<br/>  }<br/>  // Ensure that the first call can perform monitoring normally<br/>  return addHandler(element, type, handler);<br/>}</span></pre><p id="0857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了使用上述方法，我们还可以使用自执行函数来实现延迟加载:</p><pre class="kg kh ki kj gt ng nd nh ni aw nj bi"><span id="e864" class="nk nl iq nd b gy nm nn l no np">const addHandler = (function () {<br/>  if (document.addEventListener) {<br/>    return function (element, type, handler) {<br/>      element.addEventListener(type, handler, false);<br/>    };<br/>  } else if (document.attachEvent) {<br/>    return function (element, type, handler) {<br/>      element.attachEvent("on" + type, handler);<br/>    };<br/>  } else {<br/>    return function (element, type, handler) {<br/>      element["on" + type] = handler;<br/>    };<br/>  }<br/>})();</span></pre><p id="c763" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们总结一下facade模式的使用场景:</p><ul class=""><li id="6d14" class="mm mn iq ky b kz la lc ld lf mo lj mp ln mq lr mr ms mt mu bi translated">客户端程序和多个子系统之间有很强的依赖性。facade类的引入将子系统与客户端和其他子系统解耦，这可以提高子系统的独立性和可移植性。</li><li id="b894" class="mm mn iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">在分层结构中，facade模式可以用来定义系统中每一层的入口点。不是在层之间创建直接的连接，而是通过facade类建立连接，减少了层之间的耦合。</li></ul><p id="99ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有任何问题，请随时给我留言。稍后我会继续介绍其他模式，如果你有兴趣，可以在<a class="ae kv" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或者<a class="ae kv" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="bbec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想学习打字，那么不要错过<strong class="ky ir">掌握打字</strong>系列。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">有了30+篇文章，学习TypeScript就不会迷茫了</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="nx l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="53a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ny">更内容于</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">普通英语</em> </strong> </a> <em class="ny">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。在</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ny">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ny">LinkedIn</em></strong></a><em class="ny"/><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ny">YouTube</em></strong></a><em class="ny">以及</em><a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">T42不和 </strong> </a> <em class="ny">上跟随我们。对增长黑客感兴趣？查看</em> <a class="ae kv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ny">电路</em> </strong> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>