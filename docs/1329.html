<html>
<head>
<title>Rendering Rooms in a JavaScript Roguelike</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript语言渲染房间</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rendering-roguelike-rooms-with-javascript-8a2dc58f3b63?source=collection_archive---------11-----------------------#2022-03-16">https://javascript.plainenglish.io/rendering-roguelike-rooms-with-javascript-8a2dc58f3b63?source=collection_archive---------11-----------------------#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ee0a51744c8366ce0d31015dbf0b0637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HmbfHivPjQlm60Xcvtxlw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by <a class="ae kc" href="https://niltrace.deviantart.com" rel="noopener ugc nofollow" target="_blank">niltrace on DeviantArt</a></figcaption></figure><p id="9519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从1980年<a class="ae kc" href="https://en.wikipedia.org/wiki/Rogue_(video_game)" rel="noopener ugc nofollow" target="_blank"> Rogue </a>诞生以来，类似的游戏，包括程序生成的基于瓷砖的关卡以及单生命系统，已经吸引了程序员和游戏玩家的想象力。这些游戏被称为<em class="lb"> Roguelikes </em>，每次都呈现一个独特的探索环境，这有助于保持游戏体验的新鲜感。从开发的角度来看，编写一个始终如一地产生引人入胜的游戏环境的算法可能是一个挑战。</p><p id="43d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近用JavaScript构建了一个简单的<a class="ae kc" href="https://codepen.io/nevkatz/pen/QWOmaGm" rel="noopener ugc nofollow" target="_blank"> Roguelike </a>，实现了随机漫步算法，这使得关卡看起来更像洞穴而不是地牢。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/1ac216e98adb4c5625a348fad8c29651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tN9fGIGRZ0wfQQBzOzmNEw.png"/></div></div></figure><p id="ee58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在完成洞穴游戏的教程后，我试着做了一个有房间和走廊的版本。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/234f7cdceb9ec9a61b9c9857f0797c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7PF-xSet6QFvWG6tg4-fXQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The same Roguelike with a rooms algorithm.</figcaption></figure><p id="2abe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这两个游戏中，穿蓝色衣服的玩家是由光标键控制的。你与红色的敌人战斗，收集绿色和橙色的健康药水和武器。如果你打败了所有的敌人，你就赢了；如果你耗尽了健康，游戏就结束了。赢了或输了之后，会出现一个新的地牢，游戏可以继续。</p><p id="bf7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文重点介绍我如何编写生成房间的逻辑，然后标记它们以便调试。它还包括一些建议的后续步骤，以建立完整的游戏。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/ce945ffd2605120344dd4385d70a043a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8YotD7ABwRDaEBslSzL4hg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The output of a rooms generation program with debugging turned on.</figcaption></figure><p id="1f57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对构建房间生成逻辑感兴趣，有两个主要的选择:构建上面显示的演示或者开始构建完整的游戏。</p><h2 id="9133" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">选项1:构建房间生成演示</h2><p id="6df0" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">这两个游戏的代码，以及房间生成演示的启动代码可以在Github repo 的<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-1/tree/main/games" rel="noopener ugc nofollow" target="_blank">游戏</a>目录中找到。要获得完整的代码库，点击<em class="lb">代码</em>，然后点击<em class="lb">下载ZIP。</em>或者，您可以从命令行克隆它:</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="03fe" class="lj lk iq mi b gy mm mn l mo mp">git clone <a class="ae kc" href="https://github.com/nevkatz/js-roguelike-1.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nevkatz/js-roguelike-1.git</a></span></pre><p id="978a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的项目目录被命名为<code class="fe mq mr ms mi b">tutorial-rooms</code>，并有一个<code class="fe mq mr ms mi b">script.js</code>文件。</p><h2 id="4006" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">选项2:构建完整游戏的第一阶段</h2><p id="0dbc" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">如果你想尝试构建完整的游戏，你也可以下载完整的roguelike项目，它分为几个阶段，可以通过下面的命令克隆。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="baec" class="lj lk iq mi b gy mm mn l mo mp">git clone <a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nevkatz/js-roguelike-rooms.git</a></span></pre><p id="9d4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文涵盖了第1阶段。在下载的repo中，有一个结构如下的<code class="fe mq mr ms mi b">phase-1-rooms</code>目录。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="b479" class="lj lk iq mi b gy mm mn l mo mp">phase-1-rooms<br/>  |<br/>  *--index.html<br/>  |<br/>  *--css <br/>  |   |<br/>  |   *--style.css<br/>  |<br/>  *--js <br/>      |<br/>      *--script.js<br/>      |<br/>      *--game.js<br/>      |<br/>      *--room.js<br/>      |<br/>      *--path.js</span></pre><p id="7368" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了在<code class="fe mq mr ms mi b">script.js</code>中工作，你还将在<code class="fe mq mr ms mi b">game.js</code>中为<code class="fe mq mr ms mi b">Game</code>类编写代码，并在<code class="fe mq mr ms mi b">room.js</code>中为<code class="fe mq mr ms mi b">Room</code>类添加方法。</p><p id="1be4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了项目结构之后，现在让我们来看一下实现以下目标的方法:</p><ul class=""><li id="2fb8" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">房间和游戏课程</li><li id="c0b2" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">添加房间</li><li id="2903" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">检查重叠</li><li id="60b6" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">用房间填充地图阵列</li><li id="d8b5" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">在<canvas>元素上绘制地图</canvas></li><li id="816b" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">给房间贴标签</li></ul></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="db80" class="no lk iq bd ll np nq nr lo ns nt nu lr nv nw nx lu ny nz oa lx ob oc od ma oe bi translated">班级</h1><h2 id="e8d5" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">房间</h2><p id="dae5" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">首先，我在构建房间时采用了面向对象的方法，并习惯于主类，从一个<code class="fe mq mr ms mi b">Room</code>类开始。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The room class.</figcaption></figure><p id="27df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是对这些属性的快速解释。</p><ul class=""><li id="bd62" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe mq mr ms mi b">start</code>、<code class="fe mq mr ms mi b">end</code>和<code class="fe mq mr ms mi b">center</code>属性都是存储<code class="fe mq mr ms mi b">x</code>和<code class="fe mq mr ms mi b">y</code>坐标的对象。</li><li id="22b4" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mq mr ms mi b">start</code>坐标是房间的左上角。</li><li id="416a" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mq mr ms mi b">end</code>坐标是房间的右下角。</li><li id="5bd0" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mq mr ms mi b">center</code>是房间的中心。这可以作为一种方法来计算，虽然我经常使用它，但把它作为一种属性很方便。</li><li id="b42e" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mq mr ms mi b">id</code>是房间的唯一编号。</li><li id="5418" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mq mr ms mi b">neighbors</code>属性是房间直接连接到的<code class="fe mq mr ms mi b">Room</code>对象的数组。这对于在房间之间建立连接变得非常有用。</li></ul><h2 id="dee5" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">游戏</h2><p id="37b7" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我还创建了一个<code class="fe mq mr ms mi b">Game</code>类，它的一个实例存储了游戏范围内的变量。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The game class.</figcaption></figure><ul class=""><li id="ce37" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">属性存储了一个<code class="fe mq mr ms mi b">room</code>对象列表，每个对象都有它们的位置、尺寸和<code class="fe mq mr ms mi b">id</code>。</li><li id="6b3b" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">我添加了一个分配给每个新房间的<code class="fe mq mr ms mi b">curRoomId</code>,并且每当一个新房间被添加到地图上时它就会增加。</li><li id="d504" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">这里有一个<code class="fe mq mr ms mi b">map</code> 2D数组，它将游戏地图的表示存储为0和1</li><li id="967f" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mq mr ms mi b">canvas</code>是在其上绘制地图的HTML元素。</li><li id="6ec6" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mq mr ms mi b">context</code>是用于绘制<code class="fe mq mr ms mi b">&lt;canvas&gt;</code>元素的API方法包。</li></ul><p id="b17d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mi b">game</code>实例最初被声明为一个全局变量。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="1b46" class="lj lk iq mi b gy mm mn l mo mp">var game = null;</span></pre><p id="f481" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后使用Canvas API在启动函数中初始化它。我们将很快讨论这在哪里发生。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="925c" class="lj lk iq mi b gy mm mn l mo mp">game = new Game();<br/>game.canvas = document.getElementById("grid");<br/>game.context = game.canvas.getContext("2d");</span></pre></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="aa66" class="no lk iq bd ll np nq nr lo ns nt nu lr nv nw nx lu ny nz oa lx ob oc od ma oe bi translated">添加房间</h1><p id="96fa" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">添加一个新房间会以三种方式影响<code class="fe mq mr ms mi b">game</code>对象。</p><ul class=""><li id="2150" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe mq mr ms mi b">room</code>对象被添加到游戏的<code class="fe mq mr ms mi b">rooms</code>数组中。</li><li id="dec4" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">一组<code class="fe mq mr ms mi b">1</code>被添加到游戏的<code class="fe mq mr ms mi b">map</code> 2D数组中，其索引对应于房间的坐标。例如，如果一个3x2的房间被添加到一个5x4的地图的中心，那么<code class="fe mq mr ms mi b">map</code>数组将如下所示:</li></ul><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="3ea9" class="lj lk iq mi b gy mm mn l mo mp">[[0,0,0,0,0],<br/> [0,1,1,1,0],<br/> [0,1,1,1,0],<br/> [0,0,0,0,0]]</span></pre><ul class=""><li id="20ed" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">房间绘制在DOM中游戏对象的<code class="fe mq mr ms mi b">&lt;canvas&gt;</code>元素上。</li></ul><p id="cfc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这一点，<code class="fe mq mr ms mi b">addRoom</code>函数需要额外的助手来完成以下任务:</p><ul class=""><li id="a505" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">生成新房间的尺寸</li><li id="5afe" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">生成新房间的中心和角坐标</li><li id="f776" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">创建一个<code class="fe mq mr ms mi b">Room</code>对象并将其添加到<code class="fe mq mr ms mi b">Game</code>类的<code class="fe mq mr ms mi b">rooms</code>数组中</li><li id="9aa9" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">测试房间是否与其他房间重叠</li><li id="2c5e" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">更改游戏地图和房间列表</li></ul><h2 id="58d2" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">生成宽度和高度</h2><p id="fdde" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我启动了一个名为<code class="fe mq mr ms mi b">addRoom</code>的新功能。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="64eb" class="lj lk iq mi b gy mm mn l mo mp">function addRoom() {<br/>}</span></pre><p id="22b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数要做的第一件事是生成一些新的房间尺寸，所以我编写了一个名为<code class="fe mq mr ms mi b">genDim()</code>的助手函数，它返回一个具有<code class="fe mq mr ms mi b">width</code>和<code class="fe mq mr ms mi b">height</code>属性的对象。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The genDim function for generating room dimensions.</figcaption></figure><p id="cc97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mq mr ms mi b">genDim</code>中是一个常数<code class="fe mq mr ms mi b">BASE_DIM</code>，它代表最小可能的宽度和高度。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="c716" class="lj lk iq mi b gy mm mn l mo mp">const BASE_DIM = 8;</span></pre><p id="9dbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我首先使用<code class="fe mq mr ms mi b">BASE_DIM</code>来设置<code class="fe mq mr ms mi b">width</code>和<code class="fe mq mr ms mi b">height</code>彼此相等。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="7ad2" class="lj lk iq mi b gy mm mn l mo mp">let width, height;</span><span id="94ac" class="lj lk iq mi b gy oh mn l mo mp">width = height = BASE_DIM;</span></pre><p id="4cfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我添加了一个<code class="fe mq mr ms mi b">EXTRA</code>常量，用来增加房间的宽度或高度。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="e516" class="lj lk iq mi b gy mm mn l mo mp">const EXTRA = 5;</span></pre><p id="c65e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将它设置为<code class="fe mq mr ms mi b">5</code>，并用它来生成一个介于<code class="fe mq mr ms mi b">0</code>和<code class="fe mq mr ms mi b">4</code>之间的随机整数。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="324f" class="lj lk iq mi b gy mm mn l mo mp">let additional = Math.round(Math.random() * EXTRA);</span></pre><p id="2a45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我写了一行代码来确定它是否会改变房间的宽度或高度。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="df83" class="lj lk iq mi b gy mm mn l mo mp">let type = (Math.random() &lt; 0.5) ? 'tall' : 'wide';</span></pre><p id="7882" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑的下一位用生成的数字增加宽度或高度。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="84ba" class="lj lk iq mi b gy mm mn l mo mp">if (type == 'tall') {<br/>      height += additional;<br/>} else {<br/>      width += additional;<br/>}</span></pre><p id="ba63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，该函数将两个维度作为对象返回。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="930c" class="lj lk iq mi b gy mm mn l mo mp">return {<br/>    width,<br/>    height<br/>};</span></pre><p id="08b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我把<code class="fe mq mr ms mi b">genDim</code>加到了<code class="fe mq mr ms mi b">addRoom</code>上。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="ce20" class="lj lk iq mi b gy mm mn l mo mp">function addRoom() {</span><span id="32b9" class="lj lk iq mi b gy oh mn l mo mp"><strong class="mi ir">   let { width, height } = genDim();</strong></span><span id="9685" class="lj lk iq mi b gy oh mn l mo mp">}</span></pre><h2 id="66d9" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">2.生成房间中心坐标</h2><p id="54d5" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated"><code class="fe mq mr ms mi b">addRoom</code>函数还需要为房间的中心生成一组有效的坐标。要做到这一点，它需要地图的宽度和高度，我把它们放在文件的顶部。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="71dd" class="lj lk iq mi b gy mm mn l mo mp">// top of file</span><span id="a9cc" class="lj lk iq mi b gy oh mn l mo mp">const COLS = 80;<br/>const ROWS = 60;</span></pre><p id="4552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我计划用<code class="fe mq mr ms mi b">COLS</code>、<code class="fe mq mr ms mi b">ROWS</code>和<code class="fe mq mr ms mi b">getDim().</code>的<code class="fe mq mr ms mi b">width</code>和<code class="fe mq mr ms mi b">height</code>来确定中心坐标</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="9cda" class="lj lk iq mi b gy mm mn l mo mp">function addRoom() {<br/>  let { width, height} = genDim();</span><span id="f653" class="lj lk iq mi b gy oh mn l mo mp"> <strong class="mi ir"> let coords = {<br/>      x: genCenterCoord(COLS, width),<br/>      y: genCenterCoord(ROWS, height)<br/>   }</strong><br/>}</span></pre><p id="4df5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这一步，我启动了第二个助手函数:<code class="fe mq mr ms mi b">genCenterCoord</code>，它有两个参数。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="3a96" class="lj lk iq mi b gy mm mn l mo mp">function genCenterCoord (numCells, dim) {</span><span id="1a13" class="lj lk iq mi b gy oh mn l mo mp">}</span></pre><ul class=""><li id="d694" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">如果生成一个<code class="fe mq mr ms mi b">x</code>坐标，<code class="fe mq mr ms mi b">numCells</code>为<code class="fe mq mr ms mi b">COLS</code>，<code class="fe mq mr ms mi b">dim</code>为<code class="fe mq mr ms mi b">width.</code></li><li id="7268" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">如果生成一个<code class="fe mq mr ms mi b">y</code>坐标，<code class="fe mq mr ms mi b">numCells</code>为<code class="fe mq mr ms mi b">ROWS</code>，<code class="fe mq mr ms mi b">dim</code>为<code class="fe mq mr ms mi b">height</code>。</li></ul><p id="e0a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我首先需要找到房间中心离地图边缘有多近。为此，我初始化了一个新变量<code class="fe mq mr ms mi b">minDist</code>，它被设置为中心到边缘的最小距离。</p><p id="300d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了找到它，我使用了一个新的常量<code class="fe mq mr ms mi b">OUTER_LIMIT</code>，它指定了一个图块与地图边缘的最近距离。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="ced2" class="lj lk iq mi b gy mm mn l mo mp">const OUTER_LIMIT = 3</span></pre><p id="906a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我用<code class="fe mq mr ms mi b">dim / 2</code>找到了房间一半的宽度或高度。</p><p id="a6e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">于是我在<code class="fe mq mr ms mi b">Math.round(dim / 2)</code>上加了<code class="fe mq mr ms mi b">OUTER_LIMIT</code>得到最小距离。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="7c88" class="lj lk iq mi b gy mm mn l mo mp">function genCenterCoord (numCells, dim) {</span><span id="0420" class="lj lk iq mi b gy oh mn l mo mp">    let minDist = OUTER_LIMIT + Math.round(dim / 2);<br/>}</span></pre><p id="1881" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我建立了<code class="fe mq mr ms mi b">range</code>，它描述了我们可以放置瓷砖的区域的宽度或高度。例如，如果我们正在寻找<code class="fe mq mr ms mi b">x</code>，而<code class="fe mq mr ms mi b">numCells</code>(地图宽度)是<code class="fe mq mr ms mi b">80</code></p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="b306" class="lj lk iq mi b gy mm mn l mo mp">let range = numCells - 2 * minDist;</span></pre><p id="d72d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得实际的图块坐标，我将<code class="fe mq mr ms mi b">range</code>中的一个随机整数加上了<code class="fe mq mr ms mi b">minDist</code>。例如，如果<code class="fe mq mr ms mi b">minDist</code>是<code class="fe mq mr ms mi b">10</code>，范围是<code class="fe mq mr ms mi b">60</code>，那么坐标将在<code class="fe mq mr ms mi b">10</code>和<code class="fe mq mr ms mi b">70</code>之间。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="d01b" class="lj lk iq mi b gy mm mn l mo mp">return minDist + Math.round(Math.random() * range);</span></pre><p id="7463" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe mq mr ms mi b">genCenterCoord</code>功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The function for getting one center coordinate.</figcaption></figure><h2 id="c75f" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">3.生成房间对象</h2><p id="e68b" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">在获得房间尺寸和中心坐标后，我想根据这些值生成实际的房间。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="540c" class="lj lk iq mi b gy mm mn l mo mp">function addRoom() {</span><span id="70ed" class="lj lk iq mi b gy oh mn l mo mp">  let { width, height } = genDim();</span><span id="7d33" class="lj lk iq mi b gy oh mn l mo mp">  let coords = {<br/>      x: genCenterCoord(COLS, width),<br/>      y: genCenterCoord(ROWS, height)<br/>   }</span><span id="73db" class="lj lk iq mi b gy oh mn l mo mp"><strong class="mi ir">  let room = generateRoom(coords, width, height);<br/>}</strong></span></pre><p id="a7fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我是这样写<code class="fe mq mr ms mi b">generateRoom</code>函数的:</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="008c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我首先使用另一个新函数<code class="fe mq mr ms mi b">setRoomCoords</code>确定房间的<code class="fe mq mr ms mi b">start</code>和<code class="fe mq mr ms mi b">end</code>坐标，稍后我将对此进行解释。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="cca9" class="lj lk iq mi b gy mm mn l mo mp">let { start, end} = setRoomCoords(center, width, height);</span></pre><p id="1e63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我声明了一个新的<code class="fe mq mr ms mi b">room</code>对象。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="1d68" class="lj lk iq mi b gy mm mn l mo mp">let room = new Room(center, start, end);</span></pre><p id="740b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我根据变量<code class="fe mq mr ms mi b">game</code>的<code class="fe mq mr ms mi b">curRoomId</code>确定房间的<code class="fe mq mr ms mi b">id</code>，并返回对象。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="11c4" class="lj lk iq mi b gy mm mn l mo mp">room.id = game.curRoomId;</span><span id="72df" class="lj lk iq mi b gy oh mn l mo mp">return room;</span></pre><h2 id="6206" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">4.设置房间的角坐标</h2><p id="ee8d" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">虽然我们有了中心坐标，但这种方法需要房间左上角和右下角的坐标来正确填充<code class="fe mq mr ms mi b">map</code> 2D数组。所以我写了下面的<code class="fe mq mr ms mi b">setRoomCoords</code>帮助器，根据<code class="fe mq mr ms mi b">center</code>、<code class="fe mq mr ms mi b">width</code>和<code class="fe mq mr ms mi b">height</code>找到这些坐标。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Setting the room coordinates.</figcaption></figure><p id="4c22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我获得了一半宽度和一半高度的值。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="aee8" class="lj lk iq mi b gy mm mn l mo mp">let halfW = Math.round(width / 2);<br/>let halfH = Math.round(height / 2);</span></pre><p id="cedb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，通过从中心坐标的x和y属性中减去这些值，我找到了左上角的位置。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="9642" class="lj lk iq mi b gy mm mn l mo mp">let start = {<br/>      x: center.x - halfW,<br/>      y: center.y - halfH<br/>};</span></pre><p id="e7d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我通过添加找到了右下角的位置。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="bfe4" class="lj lk iq mi b gy mm mn l mo mp">let end = {<br/>      x: center.x + halfW,<br/>      y: center.y + halfH<br/>};</span></pre><p id="30b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我在一个对象中返回了这两个值。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="fc46" class="lj lk iq mi b gy mm mn l mo mp">return {<br/>      start,<br/>      end<br/>};</span></pre><p id="c5e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这允许<code class="fe mq mr ms mi b">generateRoom</code>用<code class="fe mq mr ms mi b">start</code>、<code class="fe mq mr ms mi b">end</code>和<code class="fe mq mr ms mi b">center</code>坐标构建一个<code class="fe mq mr ms mi b">room</code>对象。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="e203" class="lj lk iq mi b gy mm mn l mo mp">let { start, end } = <strong class="mi ir">setRoomCoords(center, width, height);</strong></span><span id="3ab3" class="lj lk iq mi b gy oh mn l mo mp">let room = new Room(center, start, end);</span></pre><h2 id="429c" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">5.加还是不加？</h2><p id="fb95" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">一旦我生成了房间，我想在添加它之前确保它不与其他房间重叠。所以在<code class="fe mq mr ms mi b">addRoom</code>中，我写了一个循环，遍历每个现有的房间。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="e3d4" class="lj lk iq mi b gy mm mn l mo mp">let room = generateRoom(coords, width, height);</span><span id="85b6" class="lj lk iq mi b gy oh mn l mo mp"><strong class="mi ir">for (var gameRoom of game.rooms) {</strong></span><span id="7218" class="lj lk iq mi b gy oh mn l mo mp"><strong class="mi ir">}</strong></span></pre><p id="f07f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个循环中，我使用了一个新的方法<code class="fe mq mr ms mi b">overlaps</code>，来检查这个房间是否与一个现有的房间重叠。如果是这样，我用<code class="fe mq mr ms mi b">return</code>取消这个过程，房间永远不会被添加。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="bb3f" class="lj lk iq mi b gy mm mn l mo mp">let room = generateRoom(coords, width, height);</span><span id="387a" class="lj lk iq mi b gy oh mn l mo mp">for (var gameRoom of game.rooms) {<br/>      <strong class="mi ir">if (room.overlaps(gameRoom, 1)) {<br/>         return false;<br/>      }<br/></strong>}</span></pre><p id="59f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果房间没有重叠，我继续前进，增加<code class="fe mq mr ms mi b">curRoomId</code>。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="03d0" class="lj lk iq mi b gy mm mn l mo mp">game.curRoomId++;</span></pre><p id="0399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我使用一种新的方法<code class="fe mq mr ms mi b">carveRoom</code>，来填充游戏的2D地图数组。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="0c44" class="lj lk iq mi b gy mm mn l mo mp">game.carveRoom(room);</span></pre><p id="e453" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我将新的<code class="fe mq mr ms mi b">room</code>放入<code class="fe mq mr ms mi b">game</code>对象的<code class="fe mq mr ms mi b">rooms</code>数组中。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="7fdc" class="lj lk iq mi b gy mm mn l mo mp">game.rooms.push(room);</span></pre><p id="cba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我返回<code class="fe mq mr ms mi b">true</code>来表示成功。</p><p id="2359" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是整个<code class="fe mq mr ms mi b">addRoom</code>功能。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="01b1" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">6.添加多个房间</h2><p id="a09a" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">然后我写了<code class="fe mq mr ms mi b">generateMap</code>，它在一个<code class="fe mq mr ms mi b">for</code>循环中调用<code class="fe mq mr ms mi b">addRoom</code>。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="7293" class="lj lk iq mi b gy mm mn l mo mp">function generateMapRooms() {</span><span id="5c3c" class="lj lk iq mi b gy oh mn l mo mp">  let maxRooms = 100;</span><span id="090d" class="lj lk iq mi b gy oh mn l mo mp">  for (var i = 0; i &lt; maxRooms; ++i) {<br/>      addRoom();<br/>   }<br/>}</span></pre><p id="fc5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为一个房间只有在不与其他房间重叠的情况下才会被添加，所以房间的数量会受到房间和地图尺寸的限制。当使用一个<code class="fe mq mr ms mi b">while</code>循环来添加房间的确切数量时，这就成了一个问题，因为它有无限循环的风险。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="f312" class="lj lk iq mi b gy mm mn l mo mp">let numRooms = 10;</span><span id="6276" class="lj lk iq mi b gy oh mn l mo mp">while (game.rooms.length &lt; numRooms) {<br/>   addRoom();</span><span id="f7b7" class="lj lk iq mi b gy oh mn l mo mp">}</span></pre><p id="9c16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你使用这种方法，确保你的地图上每次都有足够的空间来容纳房间的数量——否则，你的游戏会不断尝试添加剩余的房间，但没有用。</p><p id="e48b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然<code class="fe mq mr ms mi b">addRoom</code>函数已经完成，我将向您展示<code class="fe mq mr ms mi b">overlaps</code>和<code class="fe mq mr ms mi b">carveRoom</code>方法。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="65ed" class="no lk iq bd ll np nq nr lo ns nt nu lr nv nw nx lu ny nz oa lx ob oc od ma oe bi translated">检查重叠</h1><p id="4ad3" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我发现构建重叠方法最清晰的方式是首先从两个更简单的方法开始。</p><p id="5a92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mi b">overlapsHoriz</code>方法检查每个房间的结束边缘是否在另一个房间开始边缘的<em class="lb">右侧</em>。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/97f9f0ea46835a73c038bb709fd27d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*pErjiRLBJDgPUYBNMnwjXA.png"/></div></figure><p id="fc06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪个房间更靠右，都应该是这种情况——房间的终点总是在另一个房间起点的右边。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/05d1cfec48cde562f1803cd3e8263c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*S3pmnli0LzzLFMce_Ay7Pw.png"/></div></figure><p id="cf45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果每个的结束边缘在另一个的开始边缘的右边，下面的代码返回<code class="fe mq mr ms mi b">true</code>。<code class="fe mq mr ms mi b">wall</code>变量指定房间之间的虚拟墙应该有多宽。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/a91b34e687f5217190fd928239ae32d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*aEd9ayvUykDacj0wpSCi9g.png"/></div></figure><p id="ba92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mi b">overlapsVert</code>方法检查每个房间的下边缘是否低于另一个房间的上边缘，如下图所示。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/22de2eeee2f3cb99ee6876c433069dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*7-uDN0IlEfYzezfIf6h7aA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">If there is vertical overlap, the bottom of one room is always below the top of another.</figcaption></figure><p id="feb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是这种情况，下面的代码返回<code class="fe mq mr ms mi b">true</code>，并以同样的方式使用<code class="fe mq mr ms mi b">wall</code>。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/cc337601b66eda105e47788d5fb79cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*JWiybb5juJuBydnPcDTCBw.png"/></div></figure><p id="bcb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是使用<code class="fe mq mr ms mi b">overlapsHoriz</code>和<code class="fe mq mr ms mi b">overlapsVert</code>测试两种情况的<code class="fe mq mr ms mi b">overlaps</code>方法。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/17c5b8d5fb7ad75933a33007a2598daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*NtO4DuQtGtXmNkeZ0N8uRg.png"/></div></figure><h2 id="1f29" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">考虑壁厚</h2><p id="374e" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">默认为<code class="fe mq mr ms mi b">0</code>的<code class="fe mq mr ms mi b">wall</code>变量允许我考虑房间之间的墙壁厚度，并更自由地定义重叠部分。考虑下面来自<code class="fe mq mr ms mi b">addRoom</code>的代码。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="5808" class="lj lk iq mi b gy mm mn l mo mp">if (room.overlaps(gameRoom, 1)) {<br/>         return false;<br/>      }<br/>}</span></pre><p id="6e9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我使用了一个<code class="fe mq mr ms mi b">1</code>的<code class="fe mq mr ms mi b">wall</code>值，这导致了对重叠的更宽泛的定义。在<code class="fe mq mr ms mi b">overlapsTop</code>的情况下，当前房间被视为高出一个瓷砖，这样可以防止房间靠得太近，如下图所示。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/235e3577095bffa243f7211a4ac9ec70.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*-abqaHn3gcTjz09LZFeS0Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This could happen if the wall variable is set to 0.</figcaption></figure><p id="d660" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是这三种方法的综合。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The three overlaps methods that are used to prevent rooms from landing on top of each other.</figcaption></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="b861" class="no lk iq bd ll np nq nr lo ns nt nu lr nv nw nx lu ny nz oa lx ob oc od ma oe bi translated">填充地图</h1><p id="7c3d" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">当我试验添加房间和测试重叠的逻辑时，我使用2D数组填充结合一些画布渲染来检查结果。</p><p id="d1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2D数组由<code class="fe mq mr ms mi b">0</code>和<code class="fe mq mr ms mi b">1</code>组成，分别是地板和瓷砖代码。顶部的两个常数让我可以让这些代码更易读。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="af70" class="lj lk iq mi b gy mm mn l mo mp">const WALL_CODE = 0;<br/>const FLOOR_CODE = 1;</span></pre><p id="a0cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是用一个房间填充2D <code class="fe mq mr ms mi b">map</code>数组的<code class="fe mq mr ms mi b">carveRoom</code>方法。它是一个嵌套循环，将房间所包围的数组元素从<code class="fe mq mr ms mi b">0</code>的<code class="fe mq mr ms mi b">WALL_CODE</code>改变为<code class="fe mq mr ms mi b">1</code>的<code class="fe mq mr ms mi b">FLOOR_CODE</code>。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="17bd" class="no lk iq bd ll np nq nr lo ns nt nu lr nv nw nx lu ny nz oa lx ob oc od ma oe bi translated">绘制地图</h1><p id="e03d" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">在我尝试绘制地图之前，我需要一块画布来作画——所以我写了一个<code class="fe mq mr ms mi b">createDOM</code>函数来创建一个<code class="fe mq mr ms mi b">&lt;canvas&gt;</code>元素。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我使用了一个<code class="fe mq mr ms mi b">init</code>函数来调用<code class="fe mq mr ms mi b">createDOM</code>并将<code class="fe mq mr ms mi b">&lt;canvas&gt;</code>元素连接到<code class="fe mq mr ms mi b">game</code>对象。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="2756" class="lj lk iq mi b gy mm mn l mo mp">function init() {</span><span id="dc64" class="lj lk iq mi b gy oh mn l mo mp">   createDOM();</span><span id="a446" class="lj lk iq mi b gy oh mn l mo mp">   game = new Game();<br/>   game.canvas = document.getElementById("grid");<br/>   game.context = game.canvas.getContext("2d");<br/>}</span></pre><p id="5360" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我添加了<code class="fe mq mr ms mi b">generateMapRooms</code>，它通过多次调用<code class="fe mq mr ms mi b">addRoom</code>在幕后填充我们的2D数组和<code class="fe mq mr ms mi b">rooms</code>列表。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="9fd7" class="lj lk iq mi b gy mm mn l mo mp">function init() {<br/>   createDOM();<br/>   game = new Game();<br/>   game.canvas = document.getElementById("grid");<br/>   game.context = game.canvas.getContext("2d");</span><span id="16fc" class="lj lk iq mi b gy oh mn l mo mp"><strong class="mi ir">   generateMapRooms();</strong><br/>}</span></pre><p id="3cd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是为了在画布上实际绘制，我编写了我的<code class="fe mq mr ms mi b">drawMap</code>函数，它在<code class="fe mq mr ms mi b">&lt;canvas&gt;</code>元素上呈现2D数组。</p><p id="903a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了渲染地图，它遍历地图上的每个切片代码，一次绘制一个切片。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The drawMap function.</figcaption></figure><p id="6132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着循环的每一次循环，<code class="fe mq mr ms mi b">drawMap</code>在地图的当前索引处抓取<code class="fe mq mr ms mi b">tileCode</code>，获取该代码的颜色，并使用它来调用一个新函数:<code class="fe mq mr ms mi b">drawObject</code>。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="89e0" class="lj lk iq mi b gy mm mn l mo mp">let idx = game.map[row][col];</span><span id="708c" class="lj lk iq mi b gy oh mn l mo mp">let tileCode = TILE_COLORS[idx];<br/>         <br/>drawObject(col, row, tileCode);</span></pre><p id="1cd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，<code class="fe mq mr ms mi b">drawObject</code>函数使用Canvas API在地图上绘制一个图块。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2670" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，瓷砖的实际位置是用<code class="fe mq mr ms mi b">TILE_DIM</code>获得的，它是瓷砖的宽度和高度。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="9464" class="lj lk iq mi b gy mm mn l mo mp">game.context.rect(x * TILE_DIM, y * TILE_DIM, TILE_DIM, TILE_DIM);</span></pre><ul class=""><li id="fe6b" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">前两个参数是图块左上角的起始坐标:<code class="fe mq mr ms mi b">x * TILE_DIM</code>和<code class="fe mq mr ms mi b">y * TILE_DIM</code>。</li><li id="8e82" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">宽度和高度参数都是<code class="fe mq mr ms mi b">TILE_DIM</code>。</li></ul><p id="8650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我将<code class="fe mq mr ms mi b">drawMap</code>添加到我的<code class="fe mq mr ms mi b">init</code>函数中，最后调用<code class="fe mq mr ms mi b">init()</code>来测试它。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="15a3" class="lj lk iq mi b gy mm mn l mo mp">function init() {<br/>   createDOM();<br/>   game = new Game();<br/>   game.canvas = document.getElementById("grid");<br/>   game.context = game.canvas.getContext("2d");</span><span id="cfc4" class="lj lk iq mi b gy oh mn l mo mp">   generateMapRooms();</span><span id="0a66" class="lj lk iq mi b gy oh mn l mo mp"><strong class="mi ir">   drawMap(0, 0, COLS, ROWS);</strong><br/>}<br/>init();</span></pre><p id="c8d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe mq mr ms mi b">maxRooms</code>在<code class="fe mq mr ms mi b">100</code>时，我的地图看起来是这样的:</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/3a4ea9489aa6bdca1344a1adef8c35e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WK4YMVE3bvm80ZNerYk6wA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">An unlabeled map of rooms</figcaption></figure><h2 id="2526" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">给房间贴标签</h2><p id="7e1b" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">随着我更进一步，开始将房间与走廊连接起来，调试变得很困难，因为不知道哪个房间是哪个房间——所以我编写了用其<code class="fe mq mr ms mi b">id</code>和左上角坐标标记每个房间的逻辑。这让我在调试时减少了很多猜测。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我设置标签的颜色和字体大小。</p><pre class="ld le lf lg gt mh mi mj mk aw ml bi"><span id="2064" class="lj lk iq mi b gy mm mn l mo mp">game.context.fillStyle ='black';<br/>game.context.font = '15px Arial';</span></pre><p id="52d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我遍历每个房间，并使用下面的<code class="fe mq mr ms mi b">forEach</code>循环标记它。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/b846ed21efa027e2ce0ed922952cffe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WqowL-Swzqdq_LHIg4IFQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The logic for labeling the tiles.</figcaption></figure><p id="d08f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我用<code class="fe mq mr ms mi b">labelRooms</code>完成的全部<code class="fe mq mr ms mi b">init</code>功能。我通常在完成调试后将其注释掉一次。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">T</figcaption></figure><p id="7501" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您已经构建了自己的版本，这里有一个快速演示来进行比较。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="oo og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The full room creation demo.</figcaption></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="e169" class="no lk iq bd ll np nq nr lo ns nt nu lr nv nw nx lu ny nz oa lx ob oc od ma oe bi translated">构建完整的游戏</h1><p id="8894" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">如果您对创建完整的游戏感兴趣，那么在<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms" rel="noopener ugc nofollow" target="_blank">可下载Github项目</a>的<code class="fe mq mr ms mi b">phase-1-rooms</code>目录中编写本文中的代码是一个很好的开端。</p><p id="85f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在你完成第一阶段后，教程的<a class="ae kc" href="https://www.linkedin.com/pulse/javascript-roguelike-series-nevin-katz" rel="noopener ugc nofollow" target="_blank">部分将指导你编写房间连接逻辑，从而完成游戏。</a></p><p id="0d36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在与我们一起构建，并且有兴趣继续，下面是第2阶段教程的链接。</p><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">用JavaScript语言连接房间</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">让我们用香草JS建造一些走廊。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg jw os"/></div></div></a></div><p id="7dc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">无限制访问我的文章，考虑</em> <a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"> <strong class="kf ir"> <em class="lb">报名中</em> </strong> </a> <strong class="kf ir"> <em class="lb">。</em>T19】</strong></p><p id="e534" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更多内容请看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">说白了就是</em> </strong> </a> <em class="lb">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">免费每周简讯</em> </strong> </a> <em class="lb">。关注我们</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">Twitter</em></strong></a><em class="lb">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">LinkedIn</em></strong></a><em class="lb">。加入我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lb">社区不和谐</em> </strong> </a> <em class="lb">。</em></p></div></div>    
</body>
</html>