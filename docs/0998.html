<html>
<head>
<title>Why RxJS? RxJS vs Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是RxJS？RxJS vs承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-rxjs-rxjs-vs-promises-b28962771d68?source=collection_archive---------6-----------------------#2022-02-25">https://javascript.plainenglish.io/why-rxjs-rxjs-vs-promises-b28962771d68?source=collection_archive---------6-----------------------#2022-02-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="bef3" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/rxjs-39bc4f4110ec" rel="noopener"> RxJS </a></h2><div class=""/><figure class="gl gn ju jv jw jx gh gi paragraph-image"><div class="gh gi jt"><img src="../Images/2b1d4527bb57ba79e40b9572293a0cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*zpGnmdxuwTNWPxEqEJI9hQ.png"/></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">A clear statement about this post</figcaption></figure><p id="12a7" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">RxJS是一个帮助我们管理和操作数据的库。通常，这涉及到异步操作。</p><p id="bec4" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">尽管有其他技术来管理异步和基于事件的数据，我们可能还是想使用RxJS。</p><p id="e303" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">下面，我将简要回顾一些处理异步和基于事件的数据的传统技术。之后我会和RxJS对比那些技术。</p><h1 id="6533" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">传统技术</h1><h2 id="e523" class="ma ld in bd le mb mc dn li md me dp lm kp mf mg lq kt mh mi lu kx mj mk ly it bi translated">回调函数</h2><p id="b16b" class="pw-post-body-paragraph ke kf in kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ig bi translated">异步操作完成后回调函数。当处理许多异步操作或者这些操作相互嵌套时，回调可能很难管理。你可能想避免回调地狱。</p><h2 id="7eaf" class="ma ld in bd le mb mc dn li md me dp lm kp mf mg lq kt mh mi lu kx mj mk ly it bi translated">承诺</h2><p id="98d1" class="pw-post-body-paragraph ke kf in kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ig bi translated">"<em class="mq">承诺对象表示异步操作的最终完成(或失败)及其结果值</em>，<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> MDN </a>。但是，承诺只能处理一个值，并且不可取消。</p><h2 id="4a05" class="ma ld in bd le mb mc dn li md me dp lm kp mf mg lq kt mh mi lu kx mj mk ly it bi translated">异步/等待</h2><p id="82e5" class="pw-post-body-paragraph ke kf in kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ig bi translated">"<em class="mq">async和await关键字使异步的、基于承诺的行为能够以更简洁的方式编写，避免了显式配置承诺链</em>，<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> MDN </a>。</p><p id="5636" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">正如MDN上所报道的，async/await的"<em class="mq">目的是简化使用基于承诺的API所必需的语法。</em>“因此，async/await是基于承诺的，这种语法具有与承诺相同的特征。</p><p id="b402" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">Async/await只能处理一次发射，并且不可取消。</p><h1 id="703b" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">RxJS(可观察到的)与承诺</h1><p id="6ee3" class="pw-post-body-paragraph ke kf in kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ig bi translated">尽管还没有介绍<a class="ae mr" href="https://www.vitainbeta.org/2022/02/01/what-are-observables/" rel="noopener ugc nofollow" target="_blank">可观的东西</a>，我们可以把可观的东西看作“RxJS的承诺”。目前，这已经足够了。我们将很快引入Observables。</p><p id="800c" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">由于RxJS是一个库，所以不能拿RxJS和Promises比较。然而，可以将“RxJS的承诺”，即可观察到的承诺，与传统的承诺进行比较。</p><p id="f7ad" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">正如<a class="ae mr" href="https://angular.io/guide/comparing-observables#observables-compared-to-promises" rel="noopener ugc nofollow" target="_blank"> angular.io </a>所报道的，可观察到的和承诺之间有一些关键的区别。</p><p id="89eb" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">虽然承诺返回一个值，但可观测量可以提供多个值。<em class="mq">这使得observables对于随时间推移获取多个值非常有用</em>。</p><p id="5386" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">虽然承诺在创造时就开始执行，但可观察的事物直到我们想要它们开始时才会开始执行。为了调用一个可观察对象并获得一个或多个值，我们需要<em class="mq">订阅</em>它。可观察的东西是懒惰的，承诺不是。</p><p id="3050" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">还有更多的不同，但这些足以得出一些结论，为什么RxJS可能比传统的承诺更受欢迎。</p><h1 id="f916" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么是RxJS？</h1><p id="896a" class="pw-post-body-paragraph ke kf in kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ig bi translated">使用RxJS有几个好处。</p><ul class=""><li id="ce35" class="ms mt in kg b kh ki kl km kp mu kt mv kx mw lb mx my mz na bi translated"><strong class="kg ix">一库多用</strong>。我们可以使用一个库，通过相同的操作符来处理任何类型的数据。例如多个数据源、事件发射器和API。</li><li id="0fc4" class="ms mt in kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated"><strong class="kg ix">作文</strong>。我们可以随心所欲地将几个来源的数据结合起来。</li><li id="5b2b" class="ms mt in kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated"><strong class="kg ix">警惕的</strong>。随着时间的推移，RxJS可以产生多个值，当特定事件发生时，它使用推送模型来通知我们。这允许进行反应式编程，因为可以观察用户的动作和变化并对其做出反应。</li><li id="13f8" class="ms mt in kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated"><strong class="kg ix">懒散</strong>。评估直到订阅才开始。</li><li id="e9f0" class="ms mt in kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated"><strong class="kg ix">内置错误处理</strong></li><li id="7cb3" class="ms mt in kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated"><strong class="kg ix">可取消</strong>。与承诺不同，取消异步操作是可能的。</li></ul><p id="164e" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">接下来:<a class="ae mr" href="https://medium.com/p/5707e0c4c7ba" rel="noopener">什么是RxJS可观测量？</a></p><p id="b8fe" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated"><em class="mq">更多内容请看</em> <a class="ae mr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kg ix"> <em class="mq">说白了就是</em> </strong> </a> <em class="mq">。报名参加我们的</em> <a class="ae mr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kg ix"> <em class="mq">免费每周简讯</em> </strong> </a> <em class="mq">。关注我们</em><a class="ae mr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kg ix"><em class="mq">Twitter</em></strong></a><em class="mq">和</em><a class="ae mr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kg ix"><em class="mq">LinkedIn</em></strong></a><em class="mq">。加入我们的</em> <a class="ae mr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kg ix"> <em class="mq">社区不和谐</em> </strong> </a> <em class="mq">。</em></p></div></div>    
</body>
</html>