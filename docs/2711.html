<html>
<head>
<title>Make Your React Apps More Performant using Debouncing &amp; Throttling 🔥🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用去抖动和节流功能，提高React应用的性能🔥🚀</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/make-your-react-apps-more-performant-using-debouncing-throttling-f90bb4c36855?source=collection_archive---------9-----------------------#2022-06-28">https://javascript.plainenglish.io/make-your-react-apps-more-performant-using-debouncing-throttling-f90bb4c36855?source=collection_archive---------9-----------------------#2022-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/d37355570a85ffb7ad3f0a5ed890d7b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCHKlzzm0GFeYpVKPwmRvA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Learn Debouncing &amp; Throttling to improve web app performance</figcaption></figure><div class=""/><div class=""><h2 id="622f" class="pw-subtitle-paragraph jz jb jc bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用去抖动和节流优化React应用性能的简单指南。</h2></div><p id="b6e9" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">你好啊。👋我看到你来这里是为了了解如何使你的React应用程序具有高性能，并使用去抖动和节流来优化它们，这很好，因为这意味着你真的关心你的应用程序的性能。值得称赞！👏</p><p id="3ec6" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">请注意，这篇博客假设你对React如何工作有一个基本的了解，并且你熟悉T2 React钩子。</p><p id="aee9" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在我们开始之前，让我们了解一下为什么要优化React应用程序的性能？</p><p id="304a" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">假设您有一个非常简单的React应用程序，带有一个输入栏来搜索城市，如下所示，</p><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ln"><img src="../Images/8761d4a783c7ca4bf01368560f527cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2hYadxfY-23pSyQY8llg-w.gif"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">A laggy and poorly performant React app</figcaption></figure><p id="15db" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">正如你所看到的，这个应用程序是超级滞后，这个应用程序的UX是💩。我们只是进行一个非常简单的搜索，根据用户输入从城市列表中过滤城市。</p><p id="555b" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">PS:-愿意的可以试试(请自担风险，你不想挂电脑！)——【codesandbox.io/s/debouncing-example-demo-0d.. T4】</p><h1 id="fe64" class="lt lu jc bd lv lw lx ly lz ma mb mc md ki me kj mf kl mg km mh ko mi kp mj mk bi translated">现在，你可能会问为什么这个React应用程序如此落后？</h1><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/0cff682b8604d76b9a1cead3d1abc78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*9gbeoWcdmDi4CGwE.gif"/></div></figure><p id="139d" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">如果你从上面的应用程序演示中仔细注意到，我们正在从用户每次击键的城市列表中筛选城市(注意演示中虚拟键盘上的击键)。</p><p id="6418" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在看，这根本不是一个高性能的应用程序，需要优化以提供更好的用户体验。</p><p id="152e" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我们来看看优化这类app的两种方法，让它们变得更好！</p><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/02608960e627ff1c8d27e3fae79b9834.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*dnQV6qF5-jbRdsVV.gif"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Let’s understand Debouncing &amp; Throttling</figcaption></figure><h1 id="386b" class="lt lu jc bd lv lw lx ly lz ma mb mc md ki me kj mf kl mg km mh ko mi kp mj mk bi translated">什么是去抖动和节流？</h1><p id="4f16" class="pw-post-body-paragraph kr ks jc kt b ku mn kd kw kx mo kg kz la mp lc ld le mq lg lh li mr lk ll lm ig bi translated">有很多情况会降低你的应用程序的性能，比如每次用户在搜索栏上击键时调用API，点击按钮时执行计算密集型操作，调整窗口大小，或者在滚动条上频繁滚动。</p><p id="956c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">基本上，任何在事件或用户动作上进行昂贵的(就计算或执行时间而言)函数调用的场景都会影响应用程序的性能。</p><p id="9b19" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，我们来了解一下<strong class="kt jd">去抖</strong> &amp; <strong class="kt jd">节流</strong>。</p><p id="66dc" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd">去抖</strong>:在去抖中，我们试图通过仅在两个连续事件触发(用户动作)之间的时间差<strong class="kt jd">大于或等于</strong>一个<strong class="kt jd">指定的延迟</strong>时调用<strong class="kt jd">来减少昂贵的函数调用的数量。这个<strong class="kt jd">延迟</strong>可以根据<strong class="kt jd">用例</strong>或者你试图为你的应用设计的<strong class="kt jd">用户体验</strong>的种类来调整。</strong></p><p id="d408" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd">节流</strong>:在节流中，我们试图<strong class="kt jd">限制</strong>高开销函数调用的数量，方法是只有在从<strong class="kt jd">最后一次函数调用</strong>起经过一定的时间限制<strong class="kt jd">后，才每次调用它们。同样，这个时间限制可以根据您的使用情况进行调整。</strong></p><p id="a322" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">去抖动和节流对于处理<strong class="kt jd">速率限制错误</strong>非常有用，这些错误是由<strong class="kt jd">速率限制</strong>在您的应用程序可能使用的某些API上引起的，因为我们正在尝试使用这些优化来减少这种昂贵的函数调用的数量。</p><p id="1567" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，您已经对去抖动和节流有了一些了解，让我们使用一个简单的例子来说明它们的一些常见用例，从而更深入地了解每个概念。</p><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/0693cc7e456da6dfebcd5f6277d301e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/0*ptqcPGa8MEboYrFQ.gif"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Are you ready?</figcaption></figure><h1 id="98aa" class="lt lu jc bd lv lw lx ly lz ma mb mc md ki me kj mf kl mg km mh ko mi kp mj mk bi translated">使用去抖动优化应用</h1><p id="9828" class="pw-post-body-paragraph kr ks jc kt b ku mn kd kw kx mo kg kz la mp lc ld le mq lg lh li mr lk ll lm ig bi translated">让我们回到我们看到的第一个例子，我们有一个简单的搜索栏，它根据用户输入从城市列表中过滤城市。</p><p id="8695" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在这种情况下，我们可以使用<strong class="kt jd">去抖动</strong>来减少从列表中过滤城市的函数调用的数量。</p><p id="e20c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">但是首先，让我们看看演示的初始代码。</p><p id="65b5" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd">初始代码</strong> -</p><pre class="lo lp lq lr gt mt mu mv mw aw mx bi"><span id="0fbd" class="my lu jc mu b gy mz na l nb nc">import "./styles.css";<br/>import React, { useState } from "react";<br/>import cities from "cities-list";<br/>import { v4 as uuidv4 } from "uuid";<br/><br/>// An array of city names<br/>const citiesArray = Object.keys(cities);<br/><br/>export default function App() {<br/>  const [cityInput, setCityInput] = useState("");<br/>  const [filteredCities, setFilteredCities] = useState([]);<br/><br/>  // Function that filters cities from the list based on user input<br/>  const cityFilter = (query) =&gt; {<br/>    console.log(query);<br/>    if (!query) return setFilteredCities([]);<br/><br/>    setFilteredCities(<br/>      citiesArray.filter((city) =&gt;<br/>        city.toLowerCase().includes(query.toLowerCase())<br/>      )<br/>    );<br/>  };<br/><br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1 className="app-header"&gt;Find cities&lt;/h1&gt;<br/>      &lt;div className="city-input"&gt;<br/>        &lt;input<br/>          type="text"<br/>          value={cityInput}<br/>          onChange={(e) =&gt; {<br/>            setCityInput(e.target.value);<br/>            cityFilter(e.target.value);<br/>          }}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        {filteredCities.map((city) =&gt; {<br/>          return &lt;div key={uuidv4()}&gt;{city}&lt;/div&gt;;<br/>        })}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="ab1e" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">上面的代码片段代表了一个<strong class="kt jd">简单的React组件</strong>，它带有一个<strong class="kt jd">输入搜索栏</strong>和一个<strong class="kt jd">容器，该容器显示过滤后的城市</strong>。</p><pre class="lo lp lq lr gt mt mu mv mw aw mx bi"><span id="1662" class="my lu jc mu b gy mz na l nb nc">// Function that filters cities from the list based on user input<br/>  const cityFilter = (query) =&gt; {<br/>    console.log(query);<br/>    if (!query) return setFilteredCities([]);<br/><br/>    setFilteredCities(<br/>      citiesArray.filter((city) =&gt;<br/>        city.toLowerCase().includes(query.toLowerCase())<br/>      )<br/>    );<br/>  };</span></pre><p id="8f22" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">函数<code class="fe nd ne nf mu b">cityFilter</code>将<strong class="kt jd">用户搜索查询</strong>作为输入参数，并从城市列表中过滤城市(从名为<code class="fe nd ne nf mu b">cities-list</code>的npm包中获取)。目前，用户在搜索栏上的每一次击键都会运行这个函数。</p><p id="9b9e" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，让我们为上面的<code class="fe nd ne nf mu b">cityFilter</code>函数写一个<strong class="kt jd">去抖版本</strong>，使其更加优化。我们将在JavaScript中使用<code class="fe nd ne nf mu b">setTimeout</code>来实现这一点。</p><pre class="lo lp lq lr gt mt mu mv mw aw mx bi"><span id="a8c5" class="my lu jc mu b gy mz na l nb nc">// `timer` to help while clearing setTimeout <br/>// inside `debouncedCityFilter` function<br/>let timer;<br/><br/>// Debounced version of the `cityFilter` func to filter cities <br/>// based on user search query<br/>  const debouncedCityFilter = (query) =&gt; {<br/>    clearTimeout(timer);<br/>    if (!query) return setFilteredCities([]);<br/><br/>    timer = setTimeout(() =&gt; {<br/>      console.log(query);<br/><br/>      setFilteredCities(<br/>        citiesArray.filter((city) =&gt;<br/>          city.toLowerCase().includes(query.toLowerCase())<br/>        )<br/>      );<br/>    }, 500);<br/>  };</span></pre><p id="9213" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">根据去抖动的概念，只有当两个连续事件触发(用户动作)之间的<strong class="kt jd">时间差大于或等于指定延迟的</strong>时，我们才进行函数调用。</p><p id="ab08" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在上面的代码片段中，我们使用<code class="fe nd ne nf mu b">setFilteredCities()</code>设置状态以获得过滤的城市，它在延迟为<code class="fe nd ne nf mu b">500ms</code>的<code class="fe nd ne nf mu b">setTimeout</code>中被调用(这个延迟可以根据用例进行调整)。因此，每当在输入搜索栏上记录到用户击键时，就会调用<code class="fe nd ne nf mu b">debouncedCityFilter</code>函数来触发<code class="fe nd ne nf mu b">setTimeout</code>，并在<code class="fe nd ne nf mu b">500ms</code>之后使用<code class="fe nd ne nf mu b">setFilteredCities()</code>来设置状态。</p><p id="fc93" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">然而，如果用户的另一次击键刚好在<code class="fe nd ne nf mu b">500ms</code>的时间延迟内被记录，则需要清除之前的<code class="fe nd ne nf mu b">setTimeout</code>以避免过滤城市和设置州。为此，我们使用接受由<code class="fe nd ne nf mu b">setTimeout</code>函数返回的<code class="fe nd ne nf mu b">id</code>的<code class="fe nd ne nf mu b">clearTimeout</code>。</p><p id="c264" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，这个<code class="fe nd ne nf mu b">id</code>需要被保留，以便当我们需要使用<code class="fe nd ne nf mu b">clearTimeout</code>清除定时器时，它是可用的。我们在JavaScript中使用了一个非常流行的概念叫做<a class="ae ls" href="https://www.freecodecamp.org/news/lets-learn-javascript-closures-66feb44f6a44/" rel="noopener ugc nofollow" target="_blank">闭包</a>，以便能够在<code class="fe nd ne nf mu b">debouncedCityFilter</code>函数中访问这个<code class="fe nd ne nf mu b">id</code>。因此，如果你已经注意到了，我们已经在<code class="fe nd ne nf mu b">debouncedCityFilter</code>函数之外定义了一个<code class="fe nd ne nf mu b">timer</code>变量，用于该函数内部。</p><p id="49ab" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">通过简单地去抖动<code class="fe nd ne nf mu b">cityFilter</code>函数，我们能够减少函数调用的数量，从而能够显著提高React应用的性能。</p><p id="e378" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">让我们看看做出这些更改后，我们的React组件代码是什么样子的。</p><p id="5c00" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd">最终代码</strong> -</p><pre class="lo lp lq lr gt mt mu mv mw aw mx bi"><span id="9ddf" class="my lu jc mu b gy mz na l nb nc">import "./styles.css";<br/>import React, { useState } from "react";<br/>import cities from "cities-list";<br/>import { v4 as uuidv4 } from "uuid";<br/><br/>// An array of city names<br/>const citiesArray = Object.keys(cities);<br/><br/>// `timer` to help while clearing setTimeout <br/>// inside `debouncedCityFilter` function<br/>let timer;<br/><br/>export default function App() {<br/>  const [cityInput, setCityInput] = useState("");<br/>  const [filteredCities, setFilteredCities] = useState([]);<br/><br/>  // Function that filters cities from the list based on user input<br/>  const cityFilter = (query) =&gt; {<br/>    console.log(query);<br/>    if (!query) return setFilteredCities([]);<br/><br/>    setFilteredCities(<br/>      citiesArray.filter((city) =&gt;<br/>        city.toLowerCase().includes(query.toLowerCase())<br/>      )<br/>    );<br/>  };<br/><br/>  // Debounced version of the `cityFilter` func to filter <br/>  // cities based on user search query<br/>  const debouncedCityFilter = (query) =&gt; {<br/>    clearTimeout(timer);<br/>    if (!query) return setFilteredCities([]);<br/><br/>    timer = setTimeout(() =&gt; {<br/>      console.log(query);<br/><br/>      setFilteredCities(<br/>        citiesArray.filter((city) =&gt;<br/>          city.toLowerCase().includes(query.toLowerCase())<br/>        )<br/>      );<br/>    }, 500);<br/>  };<br/><br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1 className="app-header"&gt;Find cities&lt;/h1&gt;<br/>      &lt;div className="city-input"&gt;<br/>        &lt;input<br/>          type="text"<br/>          value={cityInput}<br/>          onChange={(e) =&gt; {<br/>            setCityInput(e.target.value);<br/>            debouncedCityFilter(e.target.value);<br/>          }}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        {filteredCities.map((city) =&gt; {<br/>          return &lt;div key={uuidv4()}&gt;{city}&lt;/div&gt;;<br/>        })}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="6ce8" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，看看去抖如何显著提高该元件的性能！🚀</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bd00" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">如果您想处理更多的边缘情况来消除此类函数的抖动，那么您可以查看<a class="ae ls" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>，它有一个<code class="fe nd ne nf mu b">debounce</code>方法，覆盖了所涉及的大多数边缘情况，以使此类函数更加优化。</p><p id="5ffa" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，让我们看一个简单的例子，它使用节流来提高性能。</p><h1 id="1c9d" class="lt lu jc bd lv lw lx ly lz ma mb mc md ki me kj mf kl mg km mh ko mi kp mj mk bi translated">使用节流优化应用</h1><p id="e357" class="pw-post-body-paragraph kr ks jc kt b ku mn kd kw kx mo kg kz la mp lc ld le mq lg lh li mr lk ll lm ig bi translated">让我们假设，您有一个简单的React组件，它由一个<code class="fe nd ne nf mu b">button</code>组成，单击<strong class="kt jd">调用一个API </strong>来获取一些与不同国家的所有货币相关的数据。</p><p id="1835" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd">初始代码</strong> -</p><pre class="lo lp lq lr gt mt mu mv mw aw mx bi"><span id="4afc" class="my lu jc mu b gy mz na l nb nc">import "./styles.css";<br/>import React, { useState } from "react";<br/>import axios from "axios";<br/>import { v4 as uuid } from "uuid";<br/><br/>export default function App() {<br/>  const [currencyData, setCurrencyData] = useState({});<br/>  const [clickCounter, setClickCounter] = useState(0);<br/><br/>  const getCurrencyData = async () =&gt; {<br/>    console.log("Fetching data ....");<br/><br/>    const { data } = await axios.get(<br/>      "https://cdn.jsdelivr.net/gh/fawazahmed0/currency-api@1/latest/currencies.json"<br/>    );<br/><br/>    // Fetching only 15 currencies for now<br/>    const countryCurrencies = {};<br/>    const currencyObjKeys = Object.keys(data).slice(0, 15);<br/><br/>    currencyObjKeys.forEach((key) =&gt; {<br/>      countryCurrencies[key] = data[key];<br/>    });<br/><br/>    setCurrencyData({ ...countryCurrencies });<br/>  };<br/><br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1&gt;Currencies of different Countries&lt;/h1&gt;<br/>      &lt;button<br/>        className="currency-btn"<br/>        onClick={() =&gt; {<br/>          setClickCounter((clickCount) =&gt; clickCount + 1);<br/>          getCurrencyData();<br/>        }}<br/>      &gt;<br/>        Click to get all currencies<br/>      &lt;/button&gt;<br/>      &lt;span&gt;Btn clicked - {clickCounter} times&lt;/span&gt;<br/>      &lt;div className="currencies"&gt;<br/>        {Object.keys(currencyData).map((currency) =&gt; {<br/>          return (<br/>            &lt;div key={uuid()}&gt;<br/>              {currency}: {currencyData[currency]}<br/>            &lt;/div&gt;<br/>          );<br/>        })}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="893c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">上面的代码片段是我们的简单组件，有两种状态— <code class="fe nd ne nf mu b">currencyData</code> &amp; <code class="fe nd ne nf mu b">clickCounter</code>。在点击按钮时，我们更新<code class="fe nd ne nf mu b">clickCounter</code>状态以反映到目前为止点击按钮的总数，并调用<code class="fe nd ne nf mu b">getCurrencyData()</code>函数进行API调用以获取货币数据。</p><p id="c676" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我们来看看这个组件是什么样子的！</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="ni nh l"/></div></figure><p id="1c52" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">您可能已经注意到，每一次按钮点击都会触发一个API调用。现在，假设您的应用程序被成百上千的用户使用，那么API调用的数量将是巨大的！由于如此多的点击，您的后端服务器可能会面临来自每个用户的大量请求。此外，如果您正在使用任何外部付费API或服务，那么由于API端点上的<strong class="kt jd">速率限制</strong>，端点可能会开始抛出错误。</p><p id="a4d1" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">即使你没有对这样的按钮点击进行任何API调用，而是执行一些<strong class="kt jd">计算繁重的</strong>操作，这也会严重影响你的应用程序的性能！</p><p id="1dfe" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，这是一个小问题😅</p><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/622fd53507583c1dc8252c66dd625952.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/0*i79vVcBEUPSGuK_M.gif"/></div></figure><p id="69a9" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">让我们尝试使用节流来解决这个问题！✨</p><p id="9fc5" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我们将限制每次点击按钮时发出API调用的<code class="fe nd ne nf mu b">getCurrencyData</code>函数。</p><p id="9b3b" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">目前，<code class="fe nd ne nf mu b">getCurrencyData</code>的代码看起来像这样，</p><pre class="lo lp lq lr gt mt mu mv mw aw mx bi"><span id="e974" class="my lu jc mu b gy mz na l nb nc">const getCurrencyData = async () =&gt; {<br/>    console.log("Fetching data ....");<br/><br/>    const { data } = await axios.get(<br/>      "https://cdn.jsdelivr.net/gh/fawazahmed0/currency-api@1/latest/currencies.json"<br/>    );<br/><br/>    // Fetching only 15 currencies for now<br/>    const countryCurrencies = {};<br/>    const currencyObjKeys = Object.keys(data).slice(0, 15);<br/><br/>    currencyObjKeys.forEach((key) =&gt; {<br/>      countryCurrencies[key] = data[key];<br/>    });<br/><br/>    setCurrencyData({ ...countryCurrencies });<br/>  };</span></pre><p id="1ced" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，我们将编写一个函数<code class="fe nd ne nf mu b">throttledGetCurrencyData</code>，它将节流并使用<code class="fe nd ne nf mu b">getCurrencyData</code>函数来减少对它的调用次数。</p><pre class="lo lp lq lr gt mt mu mv mw aw mx bi"><span id="8d00" class="my lu jc mu b gy mz na l nb nc">// A flag to control the function calls to the `getCurrencyData` function<br/>let shouldFuncBeCalled = true;<br/><br/>const throttledGetCurrencyData = async () =&gt; {<br/>    if (shouldFuncBeCalled) {<br/>      await getCurrencyData();<br/>      shouldFuncBeCalled = false;<br/><br/>      setTimeout(() =&gt; {<br/>        shouldFuncBeCalled = true;<br/>      }, 500);<br/>    }<br/>  };</span></pre><p id="408b" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">只有当<code class="fe nd ne nf mu b">shouldFuncBeCalled</code>标志被设置为<code class="fe nd ne nf mu b">true</code>时，<code class="fe nd ne nf mu b">throttledGetCurrencyData</code>函数才会调用<code class="fe nd ne nf mu b">getCurrencyData</code>函数。一旦这个函数被调用，我们通过使用<code class="fe nd ne nf mu b">setTimeout</code>延迟对<code class="fe nd ne nf mu b">getCurrencyData</code>函数的下一个函数调用(这个延迟限制可以根据您的用例进行调整)。</p><p id="96ed" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">这样，我们只允许从最后一次函数调用起过了一定的时间后再调用函数。这样，我们可以避免使用户界面变慢，或者超过为你的应用程序可能使用的任何API定义的速率限制。</p><p id="ae2c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我们来看看现在的app是如何运作的。</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="ni nh l"/></div></figure><p id="8f3c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">正如您在控制台上看到的，即使在点击按钮这么多次之后，API调用的数量还是显著减少了！</p><p id="6820" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">查看下面的CodeSandbox，看看使用Throttling后我们组件的代码是什么样子。</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6c48" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">如果你想处理更多的边缘情况来抑制这样的函数，那么你可以看看<a class="ae ls" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>，它有一个<code class="fe nd ne nf mu b">throttle</code>方法，覆盖了大部分的边缘情况，使这样的函数更加优化。</p><h1 id="3cb7" class="lt lu jc bd lv lw lx ly lz ma mb mc md ki me kj mf kl mg km mh ko mi kp mj mk bi translated">去抖vs节流，什么时候用哪个？</h1><p id="8605" class="pw-post-body-paragraph kr ks jc kt b ku mn kd kw kx mo kg kz la mp lc ld le mq lg lh li mr lk ll lm ig bi translated">现在我们已经了解了去抖动和节流是如何工作的，让我们来了解一下它们之间的区别以及何时使用去抖动或节流。</p><p id="92ff" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd">节流</strong>强制每次从最后一次函数调用起一定时间(或延迟)后必须调用一次函数。</p><p id="6678" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">然而，<strong class="kt jd">去抖动</strong>强制一个函数只有在经过一定时间(或延迟)后才被调用。如果没有超过该时间，则<strong class="kt jd">去抖计时器</strong>保持<strong class="kt jd">复位</strong>，并且避免<strong class="kt jd">功能调用</strong>。</p><h1 id="bb78" class="lt lu jc bd lv lw lx ly lz ma mb mc md ki me kj mf kl mg km mh ko mi kp mj mk bi translated">什么时候用什么？</h1><ul class=""><li id="ef0b" class="nk nl jc kt b ku mn kx mo la nm le nn li no lm np nq nr ns bi translated"><strong class="kt jd">搜索栏</strong>:使用<strong class="kt jd">反跳</strong>避免用户每次击键时都进行搜索。<strong class="kt jd">节流</strong>在这种情况下不方便使用，因为您不想让您的用户等待太长时间来获取搜索结果(在最坏的情况下，如果前一个函数调用是在用户停止键入时进行的)。</li><li id="8ee4" class="nk nl jc kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated"><strong class="kt jd">射击游戏</strong>:在鼠标点击时使用<strong class="kt jd">节流</strong>，因为射击手枪需要几秒钟的时间来注册，这有助于避免用户在注册前一次射击之前进行射击。<strong class="kt jd">去抖</strong>直到手枪未发射一定时间后才会发射子弹。</li></ul><p id="f568" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">你也可以看看这篇惊人的<a class="ae ls" href="https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function" rel="noopener ugc nofollow" target="_blank"> Stackoverflow帖子</a>来了解<strong class="kt jd">去抖</strong> &amp; <strong class="kt jd">节流</strong>和什么时候用什么的区别。</p><h1 id="32c4" class="lt lu jc bd lv lw lx ly lz ma mb mc md ki me kj mf kl mg km mh ko mi kp mj mk bi translated">结论</h1><p id="3a2a" class="pw-post-body-paragraph kr ks jc kt b ku mn kd kw kx mo kg kz la mp lc ld le mq lg lh li mr lk ll lm ig bi translated"><strong class="kt jd">去抖动</strong> &amp; <strong class="kt jd">节流</strong>只是让React应用更具性能的几种方法&amp;每种技术都有自己的优缺点，具体取决于使用案例。在这篇博客中，我们首先讨论了<strong class="kt jd">为什么我们应该关心React应用程序的性能</strong>，然后我们理解了<strong class="kt jd">我们如何使用去抖动&amp;节流</strong>来优化我们的应用程序的性能，最后我们看到了当我们使用哪种技术时，两种技术和<strong class="kt jd">之间的主要区别<strong class="kt jd">。</strong></strong></p><p id="f634" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我说的就是这些，非常感谢你们阅读我的博客！🙌我希望这篇博客对你有所帮助，让你了解如何让你的React应用程序更有性能。现在，继续让您的应用程序变得更加神奇吧！🚀</p><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/75b3d429e45c62e0c238d038ac387134.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*TPy9mfOg6-B0LulW.gif"/></div></figure><blockquote class="ny nz oa"><p id="1049" class="kr ks ob kt b ku kv kd kw kx ky kg kz oc lb lc ld od lf lg lh oe lj lk ll lm ig bi translated"><em class="jc">随时联系我:<br/></em><a class="ae ls" href="https://twitter.com/DevanshYtweets" rel="noopener ugc nofollow" target="_blank"><em class="jc">Twitter</em></a><em class="jc"><br/></em><a class="ae ls" href="https://www.linkedin.com/in/devansu-yadav/" rel="noopener ugc nofollow" target="_blank"><em class="jc">Linkedin</em></a><em class="jc"><br/></em><a class="ae ls" href="https://github.com/Devansu-Yadav" rel="noopener ugc nofollow" target="_blank"><em class="jc">GitHub</em></a><em class="jc"><br/>您也可以通过邮件联系我:</em><a class="ae ls" href="mailto:devansuyadav@gmail.com" rel="noopener ugc nofollow" target="_blank"><em class="jc">devansuyadav@gmail.com</em></a></p></blockquote></div><div class="ab cl of og hr oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ig ih ii ij ik"><p id="936c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><em class="ob">更多内容看</em> <a class="ae ls" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> <em class="ob">说白了。报名参加我们的</em> <a class="ae ls" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> <em class="ob">免费周报</em> </strong> </a> <em class="ob">。关注我们关于</em><a class="ae ls" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt jd"><em class="ob">Twitter</em></strong></a><em class="ob">和</em><a class="ae ls" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt jd"><em class="ob">LinkedIn</em></strong></a><em class="ob">。查看我们的</em> <a class="ae ls" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> <em class="ob">社区不和谐</em> </strong> </a> <em class="ob">加入我们的</em> <a class="ae ls" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> <em class="ob">人才集体</em> </strong> </a> <em class="ob">。</em></strong></a></p></div></div>    
</body>
</html>