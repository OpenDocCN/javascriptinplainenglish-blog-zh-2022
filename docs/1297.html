<html>
<head>
<title>Clean Up Your React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清理您的React代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/clean-up-your-react-code-63992a82d8e7?source=collection_archive---------0-----------------------#2022-03-15">https://javascript.plainenglish.io/clean-up-your-react-code-63992a82d8e7?source=collection_archive---------0-----------------------#2022-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5327" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:清理React代码。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2f7c8ded9538ec16de2110152499316c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiPVLg_u3axdFaRhBrBtJQ.jpeg"/></div></div></figure><blockquote class="ko kp kq"><p id="b04c" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下一次你写一行代码的时候，记住你是一个作者，是为那些会评判你努力的读者而写的。~干净的代码(罗伯特·c·马丁)</p></blockquote><h2 id="0fbc" class="lo lp in bd lq lr ls dn lt lu lv dp lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">道具类型</strong></h2><p id="1c96" class="pw-post-body-paragraph kr ks in ku b kv mk jo kx ky ml jr la lx mm ld le mb mn lh li mf mo ll lm ln ig bi translated">JavaScript是一种动态类型语言。动态类型语言在运行项目时检查类型。这种性质既有利于为您的代码提供灵活性，同时也会使您的代码容易出错。</p><blockquote class="ko kp kq"><p id="f910" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">“随着应用程序的增长，你可以通过类型检查发现很多错误。对于某些应用程序，您可以使用JavaScript扩展，如<a class="ae mp" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank"> Flow </a>或<a class="ae mp" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>来检查整个应用程序的类型。但即使你不使用这些，React也有一些内置的类型检查功能。”~ reactjs.org</p></blockquote><p id="867c" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">有了prop类型，我们可以使我们的组件(类和函数组件)定义良好——通过表达组件期望接收的prop及其类型(验证规则)。</p><p id="977d" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">让我们来看一个例子。假设我们有一个“输入”组件:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/7ec55b344ba67a32bc81a15642b2ab69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTA-M9oOswggccUzjCQg8g.png"/></div></div></figure><p id="e814" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">很好，只要看看代码，我们就知道“输入”组件有什么属性，这些属性是必需的还是可选的，以及可选属性的默认值。</p><p id="854d" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">现在，如果我们在没有设置的情况下使用“输入”组件，例如“类型”属性，我们将在浏览器控制台中收到警告(由于性能原因，仅在开发模式下)。</p><p id="7eef" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">为了用PropTypes进行类型检查并使用它的不同工具，我们必须安装<a class="ae mp" href="https://www.npmjs.com/package/prop-types" rel="noopener ugc nofollow" target="_blank"><em class="kt">prop-types库</em> </a>(从React v15.5开始)。</p><h2 id="bf48" class="lo lp in bd lq lr ls dn lt lu lv dp lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">构图</strong></h2><p id="b3a9" class="pw-post-body-paragraph kr ks in ku b kv mk jo kx ky ml jr la lx mm ld le mb mn lh li mf mo ll lm ln ig bi translated">React有一个声明式编程方法。在本文的第一部分中，我们讨论了不变性和纯函数。</p><p id="bec9" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">组合是函数式编程的另一个重要概念。</p><p id="e753" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">让我们看一个简单的函数示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/b5d1614b49028204c9faa444003922c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ot_UqMLROyPl-HTk_AuTw.png"/></div></div></figure><p id="de8b" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">因此，我们创建了两个小的、可测试的纯函数。我们可以单独使用这些函数，也可以将它们组合在一起创建一个新函数。</p><p id="21d3" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">现在，让我们深入一个组件通信的例子。<br/>假设，我们在应用程序中有“日期选择器”和“表格”可重用组件。并且需要创建一个“用户列表”组件，并按出生日期过滤用户。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/02a549c4e028b2a698ae83ac6521e451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4D6UpaWYKsNThClwFy8RoA.png"/></div></div></figure><p id="63d0" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">因此，我们可以简单地将这些“Table”和“DatePicker”组件添加到render方法中。</p><p id="b734" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">因此，通过遵循组合范例，我们有了干净的、小的、可测试的组件，我们可以将这些组件组合在一起，并创建可维护的、可读的、复杂的应用程序。</p><h2 id="813f" class="lo lp in bd lq lr ls dn lt lu lv dp lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">最佳实践</strong></h2><ul class=""><li id="262b" class="mt mu in ku b kv mk ky ml lx mv mb mw mf mx ln my mz na nb bi translated"><strong class="ku io"> <em class="kt">片段</em> </strong> <em class="kt"> <br/> </em> React组件不能返回多个元素而不将它们包装到父元素中。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/642712712439528a9746eb7043df9444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBmkeAy_BF5LetIvy_tFJQ.png"/></div></div></figure><p id="f29a" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">用React。片段，我们避免将子元素包装到不必要的div元素中。</p><p id="64a9" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">为什么返回多个元素会出错？</p><p id="0dfa" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">JSX不是HTML，它把文件转换成JavaScript。<br/>当我们试图返回多个元素时，意味着我们试图在JavaScript中返回多个函数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/dec65721996c8331c64d0cc4983c8720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOrsnB40wkN3OuBl05nsnQ.png"/></div></div></figure><ul class=""><li id="054b" class="mt mu in ku b kv kw ky kz lx ne mb nf mf ng ln my mz na nb bi translated"><strong class="ku io"> <em class="kt">字符串道具</em> </strong> <em class="kt"> <br/> </em>去掉字符串文字道具周围的花括号。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/5fc5de84bd0d121548aa8fdd10f80335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdohdcRySGrZ0ijGwGIktg.png"/></div></div></figure><ul class=""><li id="2756" class="mt mu in ku b kv kw ky kz lx ne mb nf mf ng ln my mz na nb bi translated"><strong class="ku io"> <em class="kt">布尔道具</em> </strong> <em class="kt"> <br/> </em> JSX有布尔道具的简写。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/92ecc657bf4465a8bc728cc5f0120fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mz2LHJOiCrv5KFrtSOCgiw.png"/></div></div></figure><p id="ad77" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated">所以我们不需要写我们的prop等于true。</p><ul class=""><li id="d2ed" class="mt mu in ku b kv kw ky kz lx ne mb nf mf ng ln my mz na nb bi translated"><strong class="ku io"> <em class="kt">引号</em> </strong> <em class="kt"> <br/> </em>对JSX属性使用双引号，但对JavaScript字符串使用单引号。</li></ul><blockquote class="ko kp kq"><p id="bdb7" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">“为什么？常规的HTML属性通常也使用双引号而不是单引号，所以JSX属性反映了这一约定~ Airbnb React/JSX风格指南</p></blockquote><ul class=""><li id="7296" class="mt mu in ku b kv kw ky kz lx ne mb nf mf ng ln my mz na nb bi translated"><strong class="ku io"> <em class="kt">组件作为道具</em> </strong> <em class="kt"> <br/> </em>如果你传递一个组件作为道具值就使用PascalCase。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/3b235f90d01b3b1ca978e0311f102f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-p8DtxuYJLdBHvl-maysCA.png"/></div></div></figure><ul class=""><li id="f040" class="mt mu in ku b kv kw ky kz lx ne mb nf mf ng ln my mz na nb bi translated"><strong class="ku io"> <em class="kt">析构</em> </strong> <br/>不使用点符号来访问对象的多个属性，而是使用对象析构。</li></ul><blockquote class="ko kp kq"><p id="ebeb" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">“为什么？析构使您不必为这些属性创建临时引用，也不必重复访问对象。重复的对象访问会产生更多的重复代码，需要更多的阅读，并产生更多的出错机会。”~ Airbnb React/JSX风格指南</p></blockquote><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/f5d757d37fa351628ab7929eaf98673a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WtSrgArRX-dEiPiR-57Fw.png"/></div></div></figure><p id="1950" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/clean-up-your-react-js-code-fd6dc54dcde">清理你的React代码(第一部分)</a></p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="11c3" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated"><em class="kt">作者Mariam Kochumian </em>。</p><p id="061a" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lx lc ld le mb lg lh li mf lk ll lm ln ig bi translated"><em class="kt">更多内容请看</em><a class="ae mp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="kt">plain English . io</em></strong></a><em class="kt">。报名参加我们的</em> <a class="ae mp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="kt">免费周报</em> </strong> </a> <em class="kt">。关注我们关于</em><a class="ae mp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="kt">Twitter</em></strong></a><em class="kt">和</em><a class="ae mp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="kt">LinkedIn</em></strong></a><em class="kt">。加入我们的</em> <a class="ae mp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="kt">社区不和谐</em> </strong> </a> <em class="kt">。</em></p></div></div>    
</body>
</html>