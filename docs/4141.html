<html>
<head>
<title>Working With Linked Lists In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/working-with-linked-lists-in-javascript-99b0278e85f2?source=collection_archive---------2-----------------------#2022-10-30">https://javascript.plainenglish.io/working-with-linked-lists-in-javascript-99b0278e85f2?source=collection_archive---------2-----------------------#2022-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="04db" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于JavaScript中的链表，您只需要知道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5430bb56d1f402b4dde0e6a28f0e7fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BE1kOZ60lOEB4FeC8i65wA.png"/></div></div></figure><p id="6d6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谈到数据结构，链表可不是闹着玩的，它是一种复杂的数据结构，比<strong class="kt ir">数组</strong>和<strong class="kt ir">散列表</strong>有很多优势。在JavaScript中，没有像在其他语言中那样内置的快捷方式来构建链表，但是，我们可以使用提供给我们的对象来创建一个链表。您还将学习如何使用更少的代码行实现一个链表，在这里您可以轻松地<strong class="kt ir">追加</strong> <strong class="kt ir">前置</strong> &amp; <strong class="kt ir">插入</strong>项，而无需过多的代码行。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="efde" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">链接列表</h1><p id="f9eb" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">业内最常用的数据结构之一，由于其优于<em class="mr">时间</em> &amp; <em class="mr">空间</em>复杂性，它提供了一种在需要时立即存储数据和配置的极好方法。在我们开始实现部分之前，你应该知道链表是什么样子的。</p><p id="6f95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="mr">例如:</em> </strong></p><ul class=""><li id="13a7" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">你可以想象一张地铁站地图，上面每个站都有自己的名字&amp;一个指向下一站的指针。链表非常相似，我们有一个指针来指示下一个要存储的项和值。</li><li id="9518" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">还有，起点叫做<strong class="kt ir">头</strong>，终点叫做<strong class="kt ir">尾</strong>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/f6f8e8ba2855f0f5cc57478d1911688f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgZvHNbmdVoJW1Ym-5j-yQ.png"/></div></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="98a9" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">JavaScript中的链表</h1><p id="0ddb" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">JavaScript没有内置的链表，为了建立一个链表，你必须很好地了解JavaScript中的<strong class="kt ir">对象</strong>和<strong class="kt ir">类</strong>如何工作。我们将使用类来构建我们的链表。此外，请注意，这可能需要一些时间来建立，但随着您的实践，它会成为第二天性。</p><blockquote class="nh"><p id="e731" class="ni nj iq bd nk nl nm nn no np nq lm dk translated">为了更清楚的理解，我们将构建一个简单的有头有尾的链表。</p></blockquote><blockquote class="nr ns nt"><p id="0bfb" class="kr ks mr kt b ku nu jr kw kx nv ju kz nw nx lc ld ny nz lg lh oa ob lk ll lm ij bi translated">注意，在我们开始之前，你必须对<em class="iq"> JavaScript </em>中的<strong class="kt ir">这个</strong>关键字有很好的了解。</p></blockquote><ul class=""><li id="cd4f" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">为了构建一个链表，我们使用一个名为<strong class="kt ir"> LinkedList </strong>的类，它接受一个<strong class="kt ir">值</strong>，该值存储在我们的Linked List中。</li><li id="e6cd" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">另外，请注意，我们在类中使用了构造函数。</li><li id="0f34" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">为了构建Head &amp; Tail，我们需要处理两个属性，它们将负责我们如何连接链表。这两个属性将是<strong class="kt ir">value</strong>&amp;<strong class="kt ir">next</strong>，其中value是我们要存储的数据，next是指向列表中下一个项目的指针。</li><li id="8db7" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在这个例子中，我们的链表只包含一个条目，这就是为什么头尾是相同的。</li><li id="a6c0" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">如您所见，属性<em class="mr">值</em>被设置为将由我们提供的值&amp;下一个被设置为<strong class="kt ir"> <em class="mr"> null </em> </strong>，因为我们的链表在此阶段包含的条目不超过1个。</li><li id="e52c" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">此外，我们设置了<strong class="kt ir"> this.tail = this.head </strong>，因为在只有一项的链表中，它们是相同的。</li><li id="8e57" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在最后一步，我们必须定义链表的长度，它会随着我们添加更多的条目而不断增加。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/be0fa441a2bc9d2de1b909ef98a5cb45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxXa4uiixFesL9fjioKUCQ.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk"><strong class="bd oh">A Simple Linked List</strong></figcaption></figure><ul class=""><li id="e395" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">因此，您可以观察到，当我们输入值<strong class="kt ir"> 19 </strong>时，我们能够构建一个值为<strong class="kt ir"> 19 </strong>的链表，该链表具有<strong class="kt ir">头</strong> &amp; <strong class="kt ir">尾</strong>。</li></ul></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="c560" class="oi lv iq bd lw oj ok dn ma ol om dp me la on oo mg le op oq mi li or os mk ot bi translated">在链接列表中追加项目</h2><p id="107c" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在这个阶段，我们能够建立一个链表，其中一个条目的头尾相同。下一个任务是将项目添加到链表中。注意追加条目意味着我们要在链表的尾部添加条目。</p><ul class=""><li id="032e" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">如果您清楚地了解事情是如何进行的，那么实现这个特性将是一件容易的事情。当追加项目时，我们的链表的尾部需要改变，我们必须改变它所保存的值和指向下一个项目的指针，如果它存在的话。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/28969f0b77f08c830f0f1e0c14437d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hedMGla9XdtQRyjkVURmg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk"><strong class="bd oh">Linked List with Append Method</strong></figcaption></figure><ul class=""><li id="b4ae" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">既然我们知道了需要改变什么，我们就可以很容易地理解append方法。</li><li id="071e" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">我们的append方法接受一个需要添加的<strong class="kt ir">值</strong>。</li><li id="8f89" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在这个阶段，我们必须构建一个新的节点来连接我们的链表，我们将一个<em class="mr"> const </em>命名为<strong class="kt ir"> newNode </strong>，它包含所有的初始值(<strong class="kt ir"> value &amp; next </strong>)。</li><li id="ec46" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">当我们创建完一个新节点后，就该用我们新创建的<strong class="kt ir"> newNode </strong>来更新我们的Tail了。</li><li id="ebbf" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">为了做到这一点，我们使用了<strong class="kt ir"> this.tail.next </strong>来访问我们的Tail &amp;中的属性<strong class="kt ir"> next </strong>，将其设置为等于我们的<strong class="kt ir"> <em class="mr"> newNode </em> </strong>。同样，我们需要设置<strong class="kt ir"> this.tail </strong>到<em class="mr"> newNode </em>作为最后一步。</li><li id="2883" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">最后，我们使用<strong class="kt ir"> this.length++来增加链表的长度。</strong></li></ul><blockquote class="nh"><p id="009f" class="ni nj iq bd nk nl ov ow ox oy oz lm dk translated"><strong class="ak"> <em class="pa">注意:</em> </strong> <em class="pa">控制台输出以不同的方式显示，使事情看起来更容易，实际上我们在输出中仍然得到相同的对象。这个例子中显示的数组是用来显示在链表末尾插入的条目的。</em></p></blockquote></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="213b" class="oi lv iq bd lw oj ok dn ma ol om dp me la on oo mg le op oq mi li or os mk ot bi translated">在链接列表中前置项目</h2><p id="f9c8" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">如果你能理解上面的append方法，prepend就不是一件很难理解的事情。通过一些改变，我们可以在链表中预先放置项目。</p><ul class=""><li id="bc68" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">为了预先计划项目，我们只需与头部一起工作。在这种情况下，头部将连接到我们添加的项目。</li><li id="acf6" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">当我们从前面添加项目时，新添加的项目成为<strong class="kt ir">头</strong>，我们之前的头需要相应地配置。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/2ea57d32d8420fde902419afcfd45c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5SG3eKje0bmHTBLA7Awrw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk"><strong class="bd oh">Linked List With Prepend Method</strong></figcaption></figure><ul class=""><li id="069b" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">如您所见，我们只需对append方法做一些更改。<strong class="kt ir"> newNode </strong>现在是从前面连接，这就是我们使用<strong class="kt ir"> newNode.next = this.head </strong>的原因。使用这个，我们将我们的<strong class="kt ir"> <em class="mr"> newNode </em> </strong>连接到<strong class="kt ir"> <em class="mr"> Head </em> </strong>。</li><li id="bd11" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">当newNode被连接时，我们必须将Head改为我们的newNode，为此我们使用了<strong class="kt ir"> this.head = newNode </strong>。</li><li id="a7f2" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">同样，我们使用<strong class="kt ir"> this.length++增加长度。</strong></li></ul></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="cec0" class="oi lv iq bd lw oj ok dn ma ol om dp me la on oo mg le op oq mi li or os mk ot bi translated">在链表中插入项目</h2><p id="d631" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">最复杂的操作，但是如果你熟悉链表中的条目是如何添加的，这对你来说将是一个快速的任务。为了在链表中的某个位置添加条目，我们需要索引来添加条目。</p><blockquote class="nh"><p id="cbaf" class="ni nj iq bd nk nl nm nn no np nq lm dk translated">注意，我们必须在两个项目之间添加我们的项目，为了做到这一点，我们必须选择两个索引。</p></blockquote><ul class=""><li id="a2cd" class="ms mt iq kt b ku nu kx nv la pb le pc li pd lm mx my mz na bi translated"><strong class="kt ir">索引(i) </strong>，在这里我们要添加我们的物品。</li><li id="1d1d" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><strong class="kt ir">索引(i-1) </strong>，它将出现在索引<strong class="kt ir"> i </strong>之前。</li><li id="f8db" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">使用这种方法，我们能够保存两个索引。而且在你开始实施<strong class="kt ir"> <em class="mr">插入</em> </strong>的方法之前，确保你能够在引擎盖下可视化这个过程，让事情变得更顺利。</li><li id="2c4c" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">可以看到我们的<strong class="kt ir"> insert </strong>方法需要两个输入(<strong class="kt ir"><em class="mr">index</em></strong><em class="mr">&amp;</em><strong class="kt ir"><em class="mr">value</em></strong>)才能工作。</li><li id="2001" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在我们开始向索引添加条目之前，我们必须确保我们的参数是有效的，为此，我们使用了一个简单的<strong class="kt ir"> <em class="mr"> if条件</em> </strong>，如果索引大于或等于链表的长度，我们将返回<strong class="kt ir"> <em class="mr"> append </em> </strong>方法。</li><li id="824b" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">与其他方法类似，我们必须创建一个带有属性的<strong class="kt ir"> newNode </strong>(值<strong class="kt ir"/>&amp;<strong class="kt ir">下一个</strong>)。</li><li id="e788" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在这个阶段，事情很简单，很有意义，但现在我们必须看得更深一点。为了在某个索引处添加项目，我们必须从头遍历到指定的索引，这样我们就可以选择索引<strong class="kt ir"> (i) </strong>和它之前的索引<strong class="kt ir"> (i-1) </strong>。使用这两个索引，我们可以很容易地决定把我们的新项目放在链表中的什么位置。</li><li id="1583" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在我们继续之前，看一下<strong class="kt ir"> traverseToIndex </strong>函数，它负责挑选我们需要的索引。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/83dd2c0d6030d1199592d39dbd5c6cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_0uffMHOskKk-QSDybCTQ.png"/></div></div></figure><ul class=""><li id="3e5c" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">该函数将索引作为<strong class="kt ir"> <em class="mr">输入</em> </strong>，并在指定索引处遍历链表。此外，我们采用了<strong class="kt ir"> counter = 0 </strong>，它用于遍历&amp;定义的<strong class="kt ir"> currentNode = this.head </strong>，因为我们需要一个新的节点。此后，使用一个<strong class="kt ir"> <em class="mr"> while循环</em> </strong>并保持运行，直到<strong class="kt ir">计数器</strong>等于<strong class="kt ir">索引。</strong></li><li id="fa16" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">另外，<strong class="kt ir"> currentNode </strong>变得等于<strong class="kt ir"> currentNode.next </strong>，我们继续递增计数器。</li><li id="d80e" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">现在到了棘手的部分，在<strong class="kt ir">索引(i) </strong>之前选择<strong class="kt ir"> <em class="mr">索引</em> </strong>，这可以通过使用<strong class="kt ir">this . traversetoindex(index-1)</strong>轻松完成。</li><li id="d879" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">此外，我们需要选择索引<strong class="kt ir"> i </strong>，为此，我们可以使用<strong class="kt ir"> leader。接下来，</strong>使用这种方法，我们使用一个指针，这个指针需要在我们的方法<strong class="kt ir">中使用。</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/e4781a3838c76a2b95ec1d83e4e91ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuHrZBOIFk2BMguAW3_5vg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk"><strong class="bd oh">Insertion of Item at Index i</strong></figcaption></figure><ul class=""><li id="e310" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">既然我们已经有了可以在索引上获取的指针，我们就可以轻松地添加条目了。为此，我们必须将<strong class="kt ir"> leader.next </strong>分配给我们的<strong class="kt ir">new node</strong>&amp;<strong class="kt ir">new node . next</strong>分配给我们的<strong class="kt ir"> holdingPointer </strong> &amp;在最后一步增加长度。</li><li id="051a" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">正如你在控制台中看到的，当我们在<strong class="kt ir"> 1 </strong>的索引处添加<strong class="kt ir"> 345 </strong>时，它工作并且类似于<strong class="kt ir"> 199 </strong>在<strong class="kt ir"> 2 </strong>的索引处。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/ce1477927757a65add0067b53ee45a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItpV3XerF09wLPrDpGxakw.png"/></div></div></figure><blockquote class="nh"><p id="d228" class="ni nj iq bd nk nl ov ow ox oy oz lm dk translated"><strong class="ak"> <em class="pa">为了更好的理解，可以看看下面给出的可视化过程。</em>T53】</strong></p></blockquote></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt ph"><a rel="noopener  ugc nofollow" target="_blank" href="/6-awesome-javascript-one-liners-you-need-to-know-f0e0d2694fae"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">你需要知道的6个很棒的JavaScript一行程序</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">以前所未有的速度编写JavaScript</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv kp ph"/></div></div></a></div><div class="pw px gp gr py ph"><a rel="noopener  ugc nofollow" target="_blank" href="/3-advanced-javascript-concepts-you-must-know-as-a-senior-developer-b1f4e8379305"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">作为高级开发人员，你必须知道的3个高级JavaScript概念</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">引用类型、上下文和实例化</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pq l"><div class="pz l ps pt pu pq pv kp ph"/></div></div></a></div><div class="pw px gp gr py ph"><a rel="noopener  ugc nofollow" target="_blank" href="/4-minute-guide-to-ultra-a-new-react-web-framework-7f12a853f58"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">Ultra 4分钟指南:一个新的React Web框架</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">解开网络捆绑</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pq l"><div class="qa l ps pt pu pq pv kp ph"/></div></div></a></div><p id="b804" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mr">更多内容请看</em><a class="ae qb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mr">plain English . io</em></strong></a><em class="mr">。报名参加我们的</em> <a class="ae qb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mr">免费周报</em> </strong> </a> <em class="mr">。关注我们关于</em><a class="ae qb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mr">Twitter</em></strong></a><a class="ae qb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mr">LinkedIn</em></strong></a><em class="mr"/><a class="ae qb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mr">YouTube</em></strong></a><em class="mr"/><a class="ae qb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mr">不和</em> </strong> </a> <em class="mr">。对增长黑客感兴趣？检查</em> <a class="ae qb" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mr">电路</em> </strong> </a> <em class="mr">。</em></p></div></div>    
</body>
</html>