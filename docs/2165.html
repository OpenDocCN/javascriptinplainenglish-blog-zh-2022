<html>
<head>
<title>Binary Search in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的二分搜索法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-search-35801fd39047?source=collection_archive---------16-----------------------#2022-05-18">https://javascript.plainenglish.io/binary-search-35801fd39047?source=collection_archive---------16-----------------------#2022-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ae9a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于JavaScript中排序数组的二分搜索法的教程。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d78f98660e730e90fdc3b2244cf5a3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UwBYH3tjBYscL-cZYBzmQ.jpeg"/></div></div></figure><p id="a114" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我不怕承认我对二叉树感到奇怪的兴奋。他们的搜索效率是惊人的——在每一步，我们可以消除一半的剩余可用值。</p><p id="d9e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我以前写过描述递归函数遍历树的方法的文章，但今天我只想处理这些结构的一个最基本的应用:</p><p id="7450" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">像往常一样，二分搜索法在一个有序的数组中,,我的目标是长话短说。</p><p id="97d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，该函数将接收一个数组和一个目标值作为参数。如果目标出现在数组中，我们将返回它的索引。如果没有，我们将返回-1。</p><p id="ec69" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将提供两个解决方案，一个是迭代的，一个是递归的。它们几乎是相同的，但有时我喜欢重构，这样我可以在迭代和递归之间画出更清晰的联系。</p><p id="8784" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还值得一提的是，这些方法将以不破坏原始数组的方式实现这一点(我有时认为这是挑战问题的一个约束)。</p><p id="4a08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">迭代… </strong></p><p id="8e4c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我根本不想改变原始数组，所以我的做法是利用两个指针(“start”和“end”)以及它们之间的“middle”索引。</p><p id="5119" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">基本想法是这样的:</p><ol class=""><li id="efba" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">查找数组当前部分的中间索引(首先是数组的全长)</li><li id="543f" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">如果中间索引处的值是我们的目标值，我们就完成了——返回那个索引。</li><li id="12cc" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">如果我们的目标值小于中间索引处的值，则将“end”重新定义为中间值- 1，并重复此过程。</li><li id="aac8" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">另一方面，如果我们的目标值大于中间索引处的值，则将“start”重新定义为middle + 1，并重复此过程。</li></ol><p id="d7cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每次这样做，我们都会将搜索范围缩小一半，直到找到目标值。还涉及到更多的细节，但是让我们直接进入代码，从那里开始。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="a778" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ma">分解… </em></p><ul class=""><li id="0773" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mb lq lr ls bi translated">第3行和第4行:这里我将整个数组建立为“搜索区域”。</li><li id="0c97" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj mb lq lr ls bi translated">第6行:现在我开始我的循环，只要“start”小于或等于“end ”,它就会运行。换句话说，如果“start”遮住了“end ”,那么我将看到数组中的每个值，但没有找到匹配的值。</li><li id="9534" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj mb lq lr ls bi translated">第8行:将“中间”定义为当前“开始”和“结束”中间的索引。</li><li id="56c7" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj mb lq lr ls bi translated">第10–16行:首先，我将检查arr[middle]是否是我要搜索的目标值。如果是这样，我会返回它的位置。如果目标低于中间值，那么我的新“end”索引将是middle - 1，因为现在我可以忽略数组的右半部分。类似地，如果目标值高于中间值，我现在可以忽略数组的左半部分，把我的新“开始”索引设为middle + 1。</li><li id="4e43" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj mb lq lr ls bi translated">第19行:现在，如果循环结束，而我还没有找到目标值，我将返回-1。</li></ul><p id="5ab2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">搞定了。现在…</p><p id="ae6e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"><em class="ma">…递归</em> </strong></p><p id="a1f0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">内部工作几乎是相同的，我们只是对它们进行不同的打包。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="dc66" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以，同样的逻辑，只是现在我们将返回内部递归帮助函数的返回值。</p><p id="0aac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">二分搜索法——极致的简单和高效！</p><p id="681a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ma">更多内容请看</em><a class="ae mc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ma">plain English . io</em></strong></a><em class="ma">。报名参加我们的</em> <a class="ae mc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ma">免费周报</em> </strong> </a> <em class="ma">。关注我们关于</em><a class="ae mc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ma">Twitter</em></strong></a><em class="ma">和</em><a class="ae mc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ma">LinkedIn</em></strong></a><em class="ma">。查看我们的</em> <a class="ae mc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ma">社区不和谐</em> </strong> </a> <em class="ma">加入我们的</em> <a class="ae mc" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ma">人才集体</em> </strong> </a> <em class="ma">。</em></p></div></div>    
</body>
</html>