<html>
<head>
<title>Multitasking in Node.js With the Cluster Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中使用集群模块的多任务处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/multitasking-in-node-js-with-the-cluster-module-ee8480208f86?source=collection_archive---------7-----------------------#2022-08-23">https://javascript.plainenglish.io/multitasking-in-node-js-with-the-cluster-module-ee8480208f86?source=collection_archive---------7-----------------------#2022-08-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d2ed" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Node.js中使用集群模块进行多任务处理的教程。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c680516394ec317d80a6f42494b7fc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2DwOVDR9qWNOAU8MQLV4g.png"/></div></div></figure><p id="195a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经知道Node.js是单线程的，这意味着它将在一个可能有多个内核的系统中使用一个处理器内核。尽管对于单线程系统来说，它很好地处理了负载，但肯定还有优化的空间，集群模块就是这样做的一种方式。</p><p id="15f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">引入集群模块是为了通过在多个处理器内核上运行工作进程/子进程来扩展应用程序的执行。这些进程共享同一个服务器端口，但即使使用同一个端口，它们最终也是独立的进程。所以他们每个人都有自己的V8实例、事件循环、自己的内存等等。这些进程使用IPC(进程间通信)通道与父进程通信。我们将在本教程中讨论所有的特性，所以让我们开始吧。</p><p id="a12c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Youtube上也有这个教程的视频版本。  </p><h1 id="f962" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">我们试图解决的问题</h1><p id="c0f8" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">让我们通过键入<code class="fe mj mk ml mm b">npm init -y</code>快速设置一个节点项目。(为了方便起见，我将添加express，但您不必这样做)。通过键入<code class="fe mj mk ml mm b">npm i express loadtest</code>安装express和loadtest。在本教程的后面部分，我们将使用loadtest来研究使用集群模块可以获得的性能优势。安装完成后，创建一个名为nonCluster.js的文件，并复制这段代码(为了比较，这个文件的代码为<strong class="kq io">，没有</strong>集群模块)。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="3a5e" class="mr ln in mm b gy ms mt l mu mv">const app = require("express")()<br/>const port = 3000;</span><span id="536b" class="mr ln in mm b gy mw mt l mu mv">app.get("/<strong class="mm io">heavy</strong>", (req, res) =&gt; {<br/>   let counter = 0;<br/>   while (counter &lt; 900000000) {<br/>      counter++;<br/>   } <br/>   res.end(`${counter} iterations completed! \n`);<br/>})</span><span id="48c2" class="mr ln in mm b gy mw mt l mu mv">app.get("/<strong class="mm io">light</strong>", (req, res) =&gt; {<br/>   res.send(`Done \n`);<br/>})</span><span id="d952" class="mr ln in mm b gy mw mt l mu mv">app.listen(port, () =&gt; console.log("Listening to port 3000"));</span></pre><p id="8235" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个非常简单的快速应用程序，有两个请求。<code class="fe mj mk ml mm b">/heavy</code>端点执行CPU密集型任务，阻塞事件循环。<code class="fe mj mk ml mm b">/light</code>端点立即返回响应。简单！</p><p id="81cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在运行服务器，首先向<code class="fe mj mk ml mm b">/heavy</code>发出请求，然后向<code class="fe mj mk ml mm b">/light</code>端点发出请求。<code class="fe mj mk ml mm b">/heavy</code>端点显然需要时间，但是您会注意到<code class="fe mj mk ml mm b">/light</code>端点也需要同样多的时间。这是因为<code class="fe mj mk ml mm b">/heavy</code>端点占用了计算请求的时间，因此阻塞了事件循环。因此，在<code class="fe mj mk ml mm b">/heavy</code>请求之后发出的任何请求现在都必须等待其完成。</p><h1 id="86ec" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">问题的解决方案</h1><p id="54fb" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">所以为了避免这种堵塞，让我们添加集群模块。在一个名为<strong class="kq io"> cluster.js的新文件中，</strong>复制了这段代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="eb2f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们来分析一下。最初，当你有一个单一的进程，它解决所有的请求进来。现在我们使用集群模块，将有两种类型的流程。一个<strong class="kq io">父/主</strong>和一个<strong class="kq io">子</strong>进程。最初，当服务器启动时，它将启动一个进程集群。此后，每当有人向服务器发出请求时，父进程就会将请求转发给子进程(通常以循环方式)。然后，子进程将最终解析该请求。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="fd0f" class="mr ln in mm b gy ms mt l mu mv">if(cluster.isMaster){<br/>   //spin up cluster of processes<br/>} else{<br/>   //resolve request<br/>}</span></pre><p id="f915" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe mj mk ml mm b">if</code>块中，我们将检查当前进程是否是父进程。集群模块有一个名为<code class="fe mj mk ml mm b">isMaster</code>的属性，它让您知道当前进程是子进程还是父进程。如果是父进程，那么我们使用fork方法创建集群。(我们只加速与系统中存在的内核总数相等的进程，以避免调度开销。)<br/>如果它不是父进程，那意味着它是子进程。所以这个子进程现在实际上负责解析请求。它将拥有所有的API端点及其相应的逻辑。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="e9b2" class="mr ln in mm b gy ms mt l mu mv">cluster.on("<strong class="mm io">online</strong>", (worker) =&gt; {<br/>   console.log("Worker " + worker.process.pid + ' is online.');    })     </span><span id="a76a" class="mr ln in mm b gy mw mt l mu mv">cluster.on('<strong class="mm io">exit</strong>', (worker, code, signal) =&gt; {<br/>   console.log(`${worker.process.pid} exited with code ${code});<br/>   console.log('Starting a new worker');        <br/>   cluster.fork();<br/>});</span></pre><p id="400c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在派生一个新的worker之后，它会用一个<code class="fe mj mk ml mm b"><strong class="kq io">online</strong></code>事件来响应。我们将在父进程上监听这个事件，看看是否所有的进程都按照预期创建。</p><p id="8ba9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当一个工人死亡时，集群模块发出一个<code class="fe mj mk ml mm b"><strong class="kq io">exit</strong></code>事件。因此，为了让我们的应用程序不停机，我们将在一个进程停机时派生一个新的进程。这样，即使任何其他流程由于任何有意或无意的原因而关闭，我们也将始终有一组流程在运行。</p><p id="c9cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好吧，这看起来不错。现在，如果您运行这个文件，并发出相同的请求(首先向<code class="fe mj mk ml mm b">/heavy</code>端点，然后向<code class="fe mj mk ml mm b">/light</code>端点),您将看到它像预期的那样工作，没有阻塞事件循环。因此，添加一组进程确实有所帮助。现在让我们使用loadtest包来做一些相对繁重的测试。</p><p id="e7c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">既然您已经运行了集群应用程序，那么让我们首先测试它。键入<code class="fe mj mk ml mm b">loadtest -n 1000 -c 100 <a class="ae lk" href="http://localhost:3000/heavy" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/heavy</a></code>运行测试。(如果没有全局安装loadtest，只需在命令开头添加npx。)</p><p id="7c8f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> -n </strong>代表请求的总数，我已经设置为1000。<br/><strong class="kq io">-c</strong>代表并发。它基本上模拟了一个真实的环境，在这个环境中，一个应用程序同时接收来自多个客户端的请求，在本例中，将有100个并发客户端。</p><p id="df5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些是“<strong class="kq io">集群化”</strong>应用程序的汇总结果。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="8d05" class="mr ln in mm b gy ms mt l mu mv"><strong class="mm io">//With cluster </strong><br/>Total time : 7.178850510999999 s<br/>Requests per second : 139<br/>Mean latency : 685.8ms</span></pre><p id="9d28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们切换到"<strong class="kq io">非集群化"</strong>应用程序，再次运行相同的测试。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="c7eb" class="mr ln in mm b gy ms mt l mu mv"><strong class="mm io">//Without cluster</strong><br/>Total time : 27.252680297999998 s<br/>Requests per second : 37<br/>Mean latency : 2583.1 ms</span></pre><p id="1588" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用集群时，整体性能明显有显著提高。但是有一个问题。这两个测试都是针对<code class="fe mj mk ml mm b">/heavy</code>端点的，这是一个CPU密集型操作。让我们尝试运行相同的测试，但是这次是针对<code class="fe mj mk ml mm b">/light</code>端点。</p><pre class="kd ke kf kg gt mn mm mo mp aw mq bi"><span id="0e44" class="mr ln in mm b gy ms mt l mu mv"><strong class="mm io">//With cluster</strong><br/>Total time: 0.5144123509999999 s<br/>Requests per second: 1944<br/>Mean latency: 48.8 ms</span><span id="b20a" class="mr ln in mm b gy mw mt l mu mv"><strong class="mm io">//Without cluster</strong><br/>Total time: 0.45111675100000004 s<br/>Requests per second: 2217<br/>Mean latency: 42 ms</span></pre><p id="823f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">惊喜惊喜。在本例中使用集群时，我们实际上获得了相对较差的性能。这是为什么呢？</p><p id="5b02" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你看，Node.js主要是为I/O操作设计的，它在很大程度上不会阻塞事件循环。因此，因为它知道如何处理这些类型的操作，所以添加额外的进程并将请求路由到这些进程中的每一个最终是一种开销，这很可能是不需要的。然而，在CPU密集型阻塞操作的情况下，如果在我们确实需要集群的进程之间划分请求数量，效果会更好。</p><p id="f851" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以它最终归结为你的应用程序是为什么而设计的。如果您有一个微服务架构，并且有一个处理CPU密集型操作的特定服务，您可以为该特定服务启动一个集群，其余的可以由您的单线程节点进程处理。</p><p id="9ee9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是在Node.js应用程序中处理集群的方式。它有自己的一套注意事项，在将它添加到您的代码库之前，您需要了解它们。这篇文章是我们研究Node.js中多任务处理的系列文章的一部分。</p><ul class=""><li id="c57a" class="mz na in kq b kr ks ku kv kx nb lb nc lf nd lj ne nf ng nh bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/multitasking-in-node-js-with-child-process-d82841fd8d29"><strong class="kq io">node . js中多任务带子进程</strong> </a></li></ul><p id="f370" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Youtube上也有这个教程的视频版本。 </p><p id="045b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何疑问或建议，你可以在评论中提出，或者通过我的任何一个社交网站与我联系。干杯！</p><p id="bde4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://www.youtube.com/channel/UCaktnqx_IENyT5T2lJ3F09w" rel="noopener ugc nofollow" target="_blank">YouTube</a><br/>T3】LinkedInT5<a class="ae lk" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a>T8<a class="ae lk" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">GitHub</a></p></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="9ae1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">更多内容看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">说白了。报名参加我们的</em><strong class="kq io"><em class="ll"/></strong><a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">免费每周简讯</em> </strong> </a> <em class="ll">。关注我们</em> <a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">推特</em> </strong> </a>，<a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">领英</em> </strong> </a> <em class="ll">，</em><a class="ae lk" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">YouTube</em></strong></a><em class="ll">，</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ll">不和</em> </strong> </a> <em class="ll">。</em></strong></a></p></div></div>    
</body>
</html>