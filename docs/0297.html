<html>
<head>
<title>4 Angular Performance Pitfalls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4个角度性能陷阱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/4-angular-performance-pitfalls-a221fedc709a?source=collection_archive---------4-----------------------#2022-01-18">https://javascript.plainenglish.io/4-angular-performance-pitfalls-a221fedc709a?source=collection_archive---------4-----------------------#2022-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/bb3aa0345421fb00b672ee6cab148ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n7Z9y5wi8tECLtDw"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@alexb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Blăjan</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="a48c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular是一个强大的框架，拥有许多有用的工具，使web开发变得轻而易举。但是如果你不小心的话，这些工具中的许多都可能对你不利。以下是Angular应用程序影响性能的4种方式，以及如何修复它们。</p><h1 id="5833" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> 1。在插值中使用函数🚫</strong></h1><p id="d7da" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">插值是Angular最有价值的特性之一。然而，如果使用不当，会大大降低应用程序的运行速度。请考虑以下情况:</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="79f5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将函数本身放入模板来显示格式化的值可能是一个显而易见的解决方案。问题是每次变化检测触发更新时，这个<code class="fe mk ml mm mn b">expensiveCalculation()</code>都会被调用。如果这种计算非常昂贵，需要大量的迭代、计算或其他耗时的任务，当应用程序等待它完成时，它可能会导致帧速率下降。</p><p id="a534" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">解决方案:</strong></p><p id="5440" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular具有服务于这种特定情况的功能:管道。管道用于直接在模板中转换数据。然而，与直接插值不同的是，只有当管道修改的数据发生变化时，才会调用管道。因此，如果管道被附加到变量“val ”,则只有当“val”本身改变时，管道才会被调用，而不是每次检测到任何类型的改变时。</p><p id="9e83" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">关于管道的说明:</strong></p><p id="0281" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用管道时需要考虑的一个重要问题是，管道有两种类型:纯管道和不纯管道。默认情况下，您创建的任何管道都将被视为纯管道。纯管道只有在检测到纯变化时才会被触发。</p><blockquote class="mo mp mq"><p id="465c" class="kd ke mr kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated">纯粹的改变要么是对原始输入值的改变(如<code class="fe mk ml mm mn b">String</code>、<code class="fe mk ml mm mn b">Number</code>、<code class="fe mk ml mm mn b">Boolean</code>或<code class="fe mk ml mm mn b">Symbol</code>)，要么是改变的对象引用(如<code class="fe mk ml mm mn b">Date</code>、<code class="fe mk ml mm mn b">Array</code>、<code class="fe mk ml mm mn b">Function</code>或<code class="fe mk ml mm mn b">Object</code>)。</p></blockquote><p id="ff47" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，如前所述，只有当他们修改的变量本身发生变化时，才会调用纯管道。</p><p id="a74c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当管道需要在复合对象的数据更改后修改变量时，应该使用不纯管道。</p><blockquote class="mo mp mq"><p id="c4bc" class="kd ke mr kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated">Angular在每次检测到每次击键或鼠标移动的变化时都会执行一个不纯管道。</p></blockquote><p id="1186" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将管道指定为不纯的，您只需将其“纯”标志设置为false:</p><pre class="me mf mg mh gt mv mn mw mx aw my bi"><span id="3820" class="mz lc jg mn b gy na nb l nc nd">@<a class="ae jd" href="https://angular.io/api/core/Pipe" rel="noopener ugc nofollow" target="_blank">Pipe</a>({   name: 'myPipe',   pure: false })</span></pre><p id="45a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很明显，不纯的管道会比纯的管道运行得更频繁。因此，不纯管道的使用应该保留在特殊情况下，不要过度使用，以免牺牲应用程序的性能。</p><h1 id="7704" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.大型阵列或昂贵的迭代🚫</h1><p id="dd3e" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">虽然使用结构化指令ngFor非常有用，但是使用不当会导致性能下降。</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8a8d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，如果数组“myItems”非常大，比如说5000个项目，那么每次数组<code class="fe mk ml mm mn b">&lt;li&gt;</code>需要重绘时，都会严重影响帧率。同样，如果应用程序的结构中“myItems”经常变化，这可能会影响性能。</p><p id="1b14" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，<code class="fe mk ml mm mn b">ngFor</code>指令会在给定数组中的项目发生变化或者数组本身发生变化时重绘。但是假设我们有一个应用程序，其中的数据不断更新，一次更新几项。</p><p id="626d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">解决方案:</strong></p><p id="ba3f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比起重画整个列表，更实际的做法是只重画改变的项目。这就是<code class="fe mk ml mm mn b">TrackBy</code>功能发挥作用的地方。</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c986" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子现在被修改成包括一个<code class="fe mk ml mm mn b">trackBy</code>参数，我们将函数<code class="fe mk ml mm mn b">trackMyItems</code>传递给它，看起来像这样:</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2671" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设每一项都有一个名为“id”的惟一属性，我们只需返回该id。此函数返回的值是Angular如何确定数组中每一项的唯一性。</p><p id="9ff6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，它不再为任何类型的更改重绘整个列表，而是只根据更改的项目的唯一性重绘它们。换句话说，只有当项目的“id”改变时，项目才会被重绘。</p><h1 id="2ac1" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.过于频繁的变化检测🚫</h1><p id="caaf" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">变更检测虽然至关重要，但有时会成为应用程序的过度负担。如果不是每次更新都呈现一个简单的项目列表，而是每次底层数据改变时都重新绘制一个完整的高度格式化的数据集合，那会怎么样？与<code class="fe mk ml mm mn b">ngFor</code>提出的问题类似，数据快速变化的应用可能会影响帧率。</p><p id="7375" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当我们不仅仅使用简单的<code class="fe mk ml mm mn b">ngFor</code>时，我们如何补救呢？有两种可能的解决方案。</p><h2 id="9f00" class="mz lc jg bd ld ne nf dn lh ng nh dp ll ko ni nj lp ks nk nl lt kw nm nn lx no bi translated">解决方案1:从变更检测中分离组件树</h2><p id="7af9" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用组件<code class="fe mk ml mm mn b">ChangeDetectorRef</code>,我们可以从变更检测生命周期中分离出一个组件(及其所有子组件)。它的构造函数如下所示:</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5be1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，组件将不会被包括在变化检测过程中，直到它被重新附加，或者被强制更新。</p><h2 id="0f6d" class="mz lc jg bd ld ne nf dn lh ng nh dp ll ko ni nj lp ks nk nl lt kw nm nn lx no bi translated">解决方案2:更改ChangeDetectionStrategy</h2><p id="8de5" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过在装饰器中指定组件变更检测策略来实现类似的目标，本质上是使组件在默认情况下分离。</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="dc5d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mk ml mm mn b">OnPush</code>策略，一个组件(及其所有子组件)有更少的变化检测触发器。当它的任何输入属性改变时，当一个事件或可观察事件触发时，或者一个方法如<code class="fe mk ml mm mn b">this.ref.detectChanges()</code>被使用时，组件将会更新。</p><p id="cdda" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法允许我们明确地定义变更检测这一费力的任务应该何时发生。我们可以设置一个每秒运行一次的方法来手动调用变更检测，从而大大减少重绘的次数。</p><h1 id="cd38" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4.太多可观察的东西</h1><p id="6a9d" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">第四种影响应用程序性能的方式是太多的可观察性。这通常是一个隐藏的杀手，虽然除了最重的应用程序之外，它可能不会成为任何问题。</p><p id="841a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可观的东西会占用内存。订阅流、等待API调用和观察变量都是它们可能被使用的方式。然而，如果使用不当，你的应用程序可能会有太多的内存泄漏，以至于很快就会停止运行。</p><p id="5e72" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">解决方案:</strong></p><p id="6ed4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管理可观物的最好办法是养成退订的习惯。当不再需要某个组件时，应取消订阅观察项。使用<code class="fe mk ml mm mn b">NgOnDestroy</code>生命周期挂钩，取消变量订阅就像:</p><pre class="me mf mg mh gt mv mn mw mx aw my bi"><span id="2c2f" class="mz lc jg mn b gy na nb l nc nd">this.pageSubscription.unsubscribe();</span></pre><p id="f98c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在<code class="fe mk ml mm mn b">pageSubscription</code>不会留在用户的记忆中。</p><p id="8842" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个短期保存记忆的方法是分享可观察的事物。虽然严格来说这不是一个角度问题，但是如果几个组件或服务订阅了异步承诺，那么共享异步承诺会很有帮助:</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f097" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">订阅上述http调用的任何组件或服务现在都将共享该承诺。实际上，这个承诺不会占用内存中的几个不同位置，而是只使用一个位置，结果由每个订阅者处理。</p><h2 id="27c9" class="mz lc jg bd ld ne nf dn lh ng nh dp ll ko ni nj lp ks nk nl lt kw nm nn lx no bi translated"><strong class="ak">有用链接</strong></h2><p id="6fe6" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae jd" href="https://angular.io/guide/pipes" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/pipes</a>T8<a class="ae jd" href="https://angular.io/api/common/NgForOf" rel="noopener ugc nofollow" target="_blank">https://angular.io/api/common/NgForOf</a>T11】T12】https://angular.io/api/core/ChangeDetectorRef#usage-notes</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="0343" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mr">更多内容看</em> <a class="ae jd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="mr">说白了就是</em> </strong> </a> <em class="mr">。报名参加我们的</em> <a class="ae jd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="mr">免费周报</em> </strong> </a> <em class="mr">。在我们的</em> <a class="ae jd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="mr">社区不和谐</em> </strong> </a> <em class="mr">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>