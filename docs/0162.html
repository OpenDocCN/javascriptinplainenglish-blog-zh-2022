<html>
<head>
<title>Built-in Methods of the Promise Object in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中Promise对象的内置方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/built-in-methods-of-the-promise-object-in-javascript-e6066580d3f4?source=collection_archive---------21-----------------------#2022-01-10">https://javascript.plainenglish.io/built-in-methods-of-the-promise-object-in-javascript-e6066580d3f4?source=collection_archive---------21-----------------------#2022-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="de5a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">的。全部，。全部解决。任何还有。比赛方法解释</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/183e681927fc6a83aaf1310e24a1e56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*akXR6ZyFhwyu6ufA.jpg"/></div></div></figure><p id="38dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你已经做了一段时间的JavaScript开发人员，你一定遇到过承诺。如果没有，这里有一个快速介绍:</p><blockquote class="lk ll lm"><p id="f0cc" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated"><em class="in">一个承诺是一个价值的代理，这个价值在承诺产生时不一定是已知的。— MDN </em></p></blockquote><p id="390e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我处理承诺已经有一段时间了，我认为它们是用JavaScript表示异步操作的一种很好的方式。尽管它们很棒，但仍然有很多我们大多数人甚至不知道的内置功能(包括我自己，直到一周前)。</p><p id="a5db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过今天这个帖子，我想解释一下Promise对象的四个有趣的内置特性。</p><p id="f9f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们开始之前，这里是我在演示中使用的工具</p><pre class="kd ke kf kg gt lr ls lt lu aw lv bi"><span id="a721" class="lw lx in ls b gy ly lz l ma mb">// configs for the createPromiseArrayFromConfig function<br/>const allItemsWillResolve = [<br/>  { settleAfterSeconds: 1, shouldReject: false },<br/>  { settleAfterSeconds: 1, shouldReject: false },<br/>];<br/>const someItemsReject = [<br/>  { settleAfterSeconds: 1, shouldReject: false },<br/>  { settleAfterSeconds: 1, shouldReject: true },<br/>  { settleAfterSeconds: 1, shouldReject: false },<br/>];<br/>const allItemsReject = [<br/>  { settleAfterSeconds: 1, shouldReject: true },<br/>  { settleAfterSeconds: 1, shouldReject: true }<br/>];<br/>const itemsWillResolveAtDifferentTime = [<br/>  { settleAfterSeconds: 1, shouldReject: false },<br/>  { settleAfterSeconds: 2, shouldReject: false },<br/>];<br/><br/>// creates an array of promises from the provided config<br/>function createPromiseArrayFromConfig(arrayOfConfigs) {<br/>  // map over the array config objects and return a new Promise for each item as per the config<br/>  return arrayOfConfigs.map(<br/>    ({ settleAfterSeconds, shouldReject }, index) =&gt;<br/>      new Promise((resolve, reject) =&gt; {<br/>        // wait "settleAfterSeconds" seconds before settling the promise<br/>        setTimeout(() =&gt; {<br/>          if (shouldReject) {<br/>            reject(`Item at ${index} index couldn't resolve! `);<br/>          } else {<br/>            resolve(`Item at ${index} index resolved fine!`);<br/>          }<br/>        }, settleAfterSeconds * 1000);<br/>      })<br/>  );</span></pre><p id="4def" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如您从实用程序中可以猜到的，我们将使用每一个<code class="fe mc md me ls b">Promise</code>方法运行这四个场景，并观察每一个方法的行为。</p><h1 id="5dd6" class="mf lx in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">Promise.all()</h1><p id="8fe2" class="pw-post-body-paragraph ko kp in kq b kr mw jo kt ku mx jr kw kx my kz la lb mz ld le lf na lh li lj ig bi translated"><code class="fe mc md me ls b">Promise.all</code>接受一个可迭代的承诺作为输入，然后返回一个承诺，这个承诺将被解析为输入承诺的结果数组。</p><p id="049c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，即使输入数组中有一个承诺被拒绝，返回的承诺也会被拒绝。拒绝消息/错误将是第一个被拒绝的项目。</p><p id="8f50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们通过代码来看看它的行为。</p><pre class="kd ke kf kg gt lr ls lt lu aw lv bi"><span id="bbaa" class="lw lx in ls b gy ly lz l ma mb">// returns an array of result, if every promise resolves otherwise throws an error from the first rejected item<br/>async function withAll() {<br/>  const allPassing = await Promise.all(<br/>    createPromiseArrayFromConfig(allItemsWillResolve)<br/>  );<br/>  console.log(" withAll ~ allPassing", allPassing);<br/>  try {<br/>    const someFail = await Promise.all(<br/>      createPromiseArrayFromConfig(someItemsReject)<br/>    );<br/>    console.log(" withAll ~ someFail", someFail);<br/>  } catch (err) {<br/>    console.log(" withAll ~ err", err);<br/>  }<br/>  try {<br/>    const allFail = await Promise.all(createPromiseArrayFromConfig(allItemsReject));<br/>    console.log(" withAll ~ allFail", allFail);<br/>  } catch (error) {<br/>    console.error(" withAll", error);<br/>  }<br/>  const before = Date.now();<br/>  const raceCondition = await Promise.all(<br/>createPromiseArrayFromConfig(itemsWillResolveAtDifferentTime)<br/>  );<br/>  const later = Date.now();<br/>  console.log(" withAll ~ raceCondition", raceCondition);<br/>  console.log(<br/>    "Time ~ withAll ~ raceCondition",<br/>    Math.round((later - before) / 1000),<br/>    " seconds"<br/>  );<br/>}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/ad897129258962d47ff19a0feaf2caaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o8ljqKi3rWBY9289.png"/></div></div></figure><p id="9f90" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们在上图中看到的，</p><ol class=""><li id="fed2" class="nc nd in kq b kr ks ku kv kx ne lb nf lf ng lj nh ni nj nk bi translated"><code class="fe mc md me ls b">allItemsWillResolve</code>配置解析为两个字符串消息的数组。</li><li id="a825" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated">第二次拒绝承诺时<code class="fe mc md me ls b">someItemsReject</code>配置失败，因为这是第一次失败。</li><li id="f684" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><code class="fe mc md me ls b">allItemsReject</code>配置在第一个承诺拒绝时失败，因为这是第一个失败的。</li><li id="c5c5" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><code class="fe mc md me ls b">itemsWillResolveAtDifferentTime</code>，需要两秒钟解决。这是因为所有的项目同时开始解析，并且<code class="fe mc md me ls b">Promise.all</code>与数组中最长的承诺花费几乎相同的时间来解析。</li></ol><blockquote class="lk ll lm"><p id="61e6" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated"><em class="in">这里需要注意的一点是，在一些像“codesandbox”这样的环境中，你可能会看到3秒的输出，</em>(发生在我身上)<em class="in">。这可能是由于应用程序中运行的其他东西，使</em> <code class="fe mc md me ls b"><em class="in">setTimeout</em></code> <em class="in">没有机会在2秒后运行。我建议在新的选项卡中打开输出，看看输出是否正确。</em></p></blockquote><p id="333a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用<code class="fe mc md me ls b">Promise.all</code>的一个好地方是映射一个数组来进行<strong class="kq io">相关的</strong>异步操作，然后用<code class="fe mc md me ls b">Promise.all</code>调用包装返回的承诺数组。</p><p id="5f63" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有一个<code class="fe mc md me ls b">Promise.all</code>的潜在用例，考虑一个用户“希望从我们的平台压缩他们的所有图像，他们不想要部分数据，即要么全部完成，要么将其视为失败。”</p><p id="a4b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里的操作<strong class="kq io">相互依赖</strong>，也就是说，我们只关心是否所有的操作/承诺都解决了，因为即使zip中缺少了其中一个，“我们的操作也是不完整的”。因此，最好使用单个<code class="fe mc md me ls b">Promise.all</code>调用来完成，如果任何操作失败，就向用户显示错误。</p><h1 id="bf3f" class="mf lx in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">Promise.allSettled()</h1><p id="5e7c" class="pw-post-body-paragraph ko kp in kq b kr mw jo kt ku mx jr kw kx my kz la lb mz ld le lf na lh li lj ig bi translated"><code class="fe mc md me ls b">Promise.allSettled</code>将一个可重复的承诺作为输入，并返回一个承诺，在所有给定的承诺被解决或拒绝后，该承诺将被解决，并带有一个对象数组，每个对象使用<code class="fe mc md me ls b">value</code>或<code class="fe mc md me ls b">reason</code>描述每个承诺的结果。</p><p id="e96c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们通过代码来看看它的行为。</p><pre class="kd ke kf kg gt lr ls lt lu aw lv bi"><span id="9ae3" class="lw lx in ls b gy ly lz l ma mb">// method returns a promise that resolves after all of the given promises<br/>// have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise.<br/>async function withAllSettled() {<br/>  const allPassing = await Promise.allSettled(<br/>    createPromiseArrayFromConfig(allItemsWillResolve)<br/>  );<br/>  console.log(" withAllSettled ~ allPassing", allPassing);<br/>  try {<br/>    const someFail = await Promise.allSettled(<br/>      createPromiseArrayFromConfig(someItemsReject)<br/>    );<br/>    console.log(" withAllSettled ~ someFail", someFail);<br/>  } catch (error) {<br/>    console.error("withAllSettled", error);<br/>  }<br/>  try {<br/>    const allFail = await Promise.allSettled(<br/>      createPromiseArrayFromConfig(allItemsReject)<br/>    );<br/>    console.log(" withAllSettled ~ allFail", allFail);<br/>  } catch (error) {<br/>    console.error(" withAllSettled", error);<br/>  }<br/>  const before = Date.now();<br/>  const raceCondition = await Promise.allSettled(<br/>createPromiseArrayFromConfig(itemsWillResolveAtDifferentTime)<br/>  );<br/>  const later = Date.now();<br/>  console.log(" withAllSettled ~ raceCondition", raceCondition);<br/>  console.log(<br/>    "Time ~ withAllSettled ~ raceCondition",<br/>    Math.round((later - before) / 1000),<br/>    " seconds"<br/>  );<br/>}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/5683a9b7ccb03e4cf6d005ffd11344f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vMNEQ5nFotE8yApg.png"/></div></div></figure><p id="de92" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们在上图中看到的，</p><ol class=""><li id="3476" class="nc nd in kq b kr ks ku kv kx ne lb nf lf ng lj nh ni nj nk bi translated"><code class="fe mc md me ls b">allItemsWillResolve</code>配置解析为两个对象的数组，每个对象都有一个<code class="fe mc md me ls b">status</code>和一个<code class="fe mc md me ls b">value</code>。</li><li id="4519" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated">这次<code class="fe mc md me ls b">someItemsReject</code> config没有拒绝，相反，它返回一个由3个对象组成的数组，其中第二个对象的<code class="fe mc md me ls b">status</code>为“拒绝的”,而<code class="fe mc md me ls b">reason</code>为<code class="fe mc md me ls b">error message</code>。值得注意的是，第二项缺少名为<code class="fe mc md me ls b">value</code>的键。</li><li id="5ffe" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><code class="fe mc md me ls b">allItemsReject</code>配置返回两个项目，其中<code class="fe mc md me ls b">status</code>为“拒绝”。</li><li id="bfe3" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><code class="fe mc md me ls b">itemsWillResolveAtDifferentTime</code>需要两秒钟来解决，因为它像<code class="fe mc md me ls b">Promise.all</code>一样工作。</li></ol><p id="b77f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于<code class="fe mc md me ls b">Promise.allSettled</code>，一个很好的用例是向我们的用户<em class="ln">(来自上面的</em><code class="fe mc md me ls b"><em class="ln">Promise.all</em></code><em class="ln">)</em>，一个对话框，通过查看返回的数据并显示它们各自的消息，其中的所有文件都不能被压缩。与上一个相比，这是一个更好的用户体验，在上一个中，我们只显示了我们发现的第一个错误。</p><h1 id="1209" class="mf lx in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">Promise.any()</h1><p id="314f" class="pw-post-body-paragraph ko kp in kq b kr mw jo kt ku mx jr kw kx my kz la lb mz ld le lf na lh li lj ig bi translated"><code class="fe mc md me ls b">Promise.any</code>将一个承诺数组作为输入，并返回一个承诺，一旦<strong class="kq io">数组中的一个</strong>承诺实现，这个承诺就解决，并返回实现的承诺的值。</p><blockquote class="lk ll lm"><p id="155d" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated"><em class="in"> Promise.any仅适用于节点版本15及以上</em></p></blockquote><p id="a24e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们通过代码来看看它的行为。</p><pre class="kd ke kf kg gt lr ls lt lu aw lv bi"><span id="ef9f" class="lw lx in ls b gy ly lz l ma mb">// method returns a promise that resolves after all of the given promises<br/>// have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise.<br/>async function withAllSettled() {<br/>  const allPassing = await Promise.allSettled(<br/>    createPromiseArrayFromConfig(allItemsWillResolve)<br/>  );<br/>  console.log(" withAllSettled ~ allPassing", allPassing);<br/>  try {<br/>    const someFail = await Promise.allSettled(<br/>      createPromiseArrayFromConfig(someItemsReject)<br/>    );<br/>    console.log(" withAllSettled ~ someFail", someFail);<br/>  } catch (error) {<br/>    console.error("withAllSettled", error);<br/>  }<br/>  try {<br/>    const allFail = await Promise.allSettled(<br/>      createPromiseArrayFromConfig(allItemsReject)<br/>    );<br/>    console.log(" withAllSettled ~ allFail", allFail);<br/>  } catch (error) {<br/>    console.error(" withAllSettled", error);<br/>  }<br/>  const before = Date.now();<br/>  const raceCondition = await Promise.allSettled(<br/>createPromiseArrayFromConfig(itemsWillResolveAtDifferentTime)<br/>  );<br/>  const later = Date.now();<br/>  console.log(" withAllSettled ~ raceCondition", raceCondition);<br/>  console.log(<br/>    "Time ~ withAllSettled ~ raceCondition",<br/>    Math.round((later - before) / 1000),<br/>    " seconds"<br/>  );<br/>}</span></pre><p id="adc7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们在上图中看到的，</p><ol class=""><li id="ee7a" class="nc nd in kq b kr ks ku kv kx ne lb nf lf ng lj nh ni nj nk bi translated"><code class="fe mc md me ls b">allItemsWillResolve</code>配置解析为第一项的承诺。</li><li id="6da2" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><code class="fe mc md me ls b">someItemsReject</code>配置解析为第一项的承诺。</li><li id="4ee9" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated">由于所有的承诺都被拒绝，<code class="fe mc md me ls b">allItemsReject</code>配置返回一个<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError" rel="noopener ugc nofollow" target="_blank">聚合错误</a>。</li><li id="3b7d" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><code class="fe mc md me ls b">itemsWillResolveAtDifferentTime</code>需要一秒钟来解决，因为在我们提供的两个承诺中，第一个仅需要一秒钟来解决。</li></ol><p id="00e3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mc md me ls b">Promise.any</code>的一个很好的用例是从多个来源请求相同的资源，并显示收到的第一个。想象一下，如果您要将我们的客户连接到第一个支持助理，最好的方法是请求连接到所有人，并选择响应最快的一个。</p><h1 id="81d8" class="mf lx in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">承诺.比赛</h1><p id="72af" class="pw-post-body-paragraph ko kp in kq b kr mw jo kt ku mx jr kw kx my kz la lb mz ld le lf na lh li lj ig bi translated"><code class="fe mc md me ls b">Promise.race</code>将一个承诺数组作为输入，并返回一个承诺，只要数组中的一个承诺满足或拒绝，该承诺就会满足或拒绝，并返回该承诺的值或原因。</p><p id="344c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们通过代码来看看它的行为。</p><pre class="kd ke kf kg gt lr ls lt lu aw lv bi"><span id="b669" class="lw lx in ls b gy ly lz l ma mb">// returns a promise that fulfills or rejects<br/>// as soon as one of the promises in an iterable fulfills or rejects<br/>// If the iterable passed is empty, the promise returned will be forever pending.<br/>async function withRace() {<br/>  const allPassing = await Promise.race(<br/>    createPromiseArrayFromConfig(allItemsWillResolve)<br/>  );<br/>  console.log(" withRace ~ allPassing", allPassing);<br/>  try {<br/>    const someFail = await Promise.race(<br/>      createPromiseArrayFromConfig(someItemsReject)<br/>    );<br/>    console.log(" withRace ~ someFail", someFail);<br/>  } catch (error) {<br/>    console.error(" withRace", error);<br/>  }<br/>  try {<br/>    const allFail = await Promise.race(<br/>      createPromiseArrayFromConfig(allItemsReject)<br/>    );<br/>    console.log(" withRace ~ allFail", allFail);<br/>  } catch (error) {<br/>    console.error(" withRace", error);<br/>  }<br/>  const before = Date.now();<br/>  const raceCondition = await Promise.race(<br/>    createPromiseArrayFromConfig(itemsWillResolveAtDifferentTime)<br/>  );<br/>  const later = Date.now();<br/>  console.log(" withRace ~ raceCondition", raceCondition);<br/>  console.log(<br/>    "Time ~ withRace ~ raceCondition",<br/>    Math.round((later - before) / 1000),<br/>    " seconds"<br/>  );<br/>}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/db994bea15eaaa1ebbcc44699e2e108c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fKO8xhGaJi5De07w.png"/></div></div></figure><p id="e4bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们在上图中看到的，</p><ol class=""><li id="dedf" class="nc nd in kq b kr ks ku kv kx ne lb nf lf ng lj nh ni nj nk bi translated"><code class="fe mc md me ls b">allItemsWillResolve</code>配置解析为第一项的承诺。</li><li id="706c" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><code class="fe mc md me ls b">someItemsReject</code>配置解析为第一个项目的承诺。</li><li id="50cd" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated">配置返回第一个承诺被拒绝的错误。</li><li id="be2d" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated"><code class="fe mc md me ls b">itemsWillResolveAtDifferentTime</code>需要一秒钟来解决，因为在我们提供的两个承诺中，第一个只需要一秒钟来解决。</li></ol><p id="2998" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一些重要的观点</p><ol class=""><li id="7bb0" class="nc nd in kq b kr ks ku kv kx ne lb nf lf ng lj nh ni nj nk bi translated">如果传递的iterable为空，则返回的承诺将永远挂起。</li><li id="b493" class="nc nd in kq b kr nl ku nm kx nn lb no lf np lj nh ni nj nk bi translated">如果iterable包含一个或多个非承诺值和/或一个已经确定的承诺，那么Promise.race将解析到iterable中找到的第一个值。</li></ol><blockquote class="lk ll lm"><p id="c275" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated"><em class="in">此外，与返回第一个履行值的</em> <code class="fe mc md me ls b"><em class="in">Promise.any()</em></code> <em class="in">不同，该方法返回第一个结算(履行或拒绝)值。</em></p></blockquote><p id="5bb6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mc md me ls b">Promise.race</code>的一个很好的用例是为操作设置一个截止计时器，这样如果给定的操作没有在x秒内完成，我们就会抛出一个错误。</p><h1 id="41bc" class="mf lx in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">视频教程和示例</h1><p id="61fd" class="pw-post-body-paragraph ko kp in kq b kr mw jo kt ku mx jr kw kx my kz la lb mz ld le lf na lh li lj ig bi translated">你也可以观看Youtube视频<a class="ae nq" href="https://www.youtube.com/watch?v=1Mc4cFuJ224" rel="noopener ugc nofollow" target="_blank">来看看实际的例子</a></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Youtube video</figcaption></figure><p id="1905" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你也可以在这里使用代码沙箱<a class="ae nq" href="https://codesandbox.io/s/promises-by-anshuman-4v17s" rel="noopener ugc nofollow" target="_blank">进行派生和游戏。</a></p><p id="e930" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我希望这篇文章对你有帮助。如果您有任何反馈或问题，请随时在下面的评论中提出。我很想听听他们的想法并为之努力。</p><p id="a38c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">更多此类帖子请关注我<a class="ae nq" href="https://twitter.com/sun_anshuman" rel="noopener ugc nofollow" target="_blank"> @sun_anshuman </a>。</p><h1 id="65cb" class="mf lx in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">使用的资源</h1><p id="47c2" class="pw-post-body-paragraph ko kp in kq b kr mw jo kt ku mx jr kw kx my kz la lb mz ld le lf na lh li lj ig bi translated">在为这篇文章做研究时，我跟踪了<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>。</p></div><div class="ab cl nx ny hr nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ig ih ii ij ik"><p id="1c2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ln">原载于2022年1月10日</em><a class="ae nq" href="https://theanshuman.dev/articles/built-in-methods-of-promise-object-in-javascript-the-all-allsettled-any-and-race-explained-27p4" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://theanshuman . dev</em></a><em class="ln">。</em></p><p id="b505" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ln">更多内容看</em> <a class="ae nq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ln">说白了。报名参加我们的</em> <a class="ae nq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ln">免费周报</em> </strong> </a> <em class="ln">。在我们的</em> <a class="ae nq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ln">社区不和谐</em> </strong> </a> <em class="ln">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>