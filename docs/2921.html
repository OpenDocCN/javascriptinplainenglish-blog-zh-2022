<html>
<head>
<title>How to Add Swipe Control to a JavaScript Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript游戏中添加滑动控件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-swipe-control-to-a-javascript-roguelike-e8ef327e9930?source=collection_archive---------11-----------------------#2022-07-14">https://javascript.plainenglish.io/how-to-add-swipe-control-to-a-javascript-roguelike-e8ef327e9930?source=collection_archive---------11-----------------------#2022-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fbb43f8621e212dff74697938cbb3371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQvAHD8Q5mN_0ISJIrhhOQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.freepik.com/vectors/phone-design" rel="noopener ugc nofollow" target="_blank">Phone design vector</a> created by <a class="ae kc" href="https://www.freepik.com/author/wangxina" rel="noopener ugc nofollow" target="_blank">WangXiNa</a> on <a class="ae kc" href="https://www.freepik.com" rel="noopener ugc nofollow" target="_blank">freepik</a></figcaption></figure><p id="298f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">roguelike是一种自动生成关卡的冒险游戏，自20世纪80年代以来一直吸引着玩家的想象力。在制作了许多带有键盘控制的roguelike演示之后，我最近制作了一个可以在智能手机上使用的带有滑动控制的演示。</p><p id="9bc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将从一个仅包含一个播放器和一个由墙砖和地砖组成的简单环境的演示开始。虽然播放器一开始是由光标键控制的，但我将向您展示如何让播放器响应单触式滑动而移动。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/cebd1bc55c6c39fc9b0d31ff9084522f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHGtG2rKg83wcaP2xKb_vg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The demo we will add our swipe logic to.</figcaption></figure><p id="45dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那之后，我们可以将它与一款拥有额外功能和相似刷卡逻辑的<a class="ae kc" href="https://roguelike-swipe.netlify.app/game/index.html" rel="noopener ugc nofollow" target="_blank">游戏</a>进行比较。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/eb0c5fc34f70c912876a37ebd66074bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gO1tTKw4Txp_J8HE7wSuvQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A game with adjusted swipe logic for handling the enemies in red.</figcaption></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="9458" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">入门指南</h1><p id="cfc2" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">请随意下载<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-swipe/archive/refs/heads/main.zip" rel="noopener ugc nofollow" target="_blank">启动代码</a>，其中包含以下内容:</p><ul class=""><li id="7d3a" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la mw mx my mz bi translated">我们的工作将在那里进行。</li><li id="61e4" class="mr ms iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">三个<code class="fe na nb nc nd b">phase</code>目录，包含教程每个阶段的解决方案。</li><li id="8f92" class="mr ms iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">一个带有游戏示例的<code class="fe na nb nc nd b">game</code>目录。</li><li id="a6c0" class="mr ms iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">一个<code class="fe na nb nc nd b">css</code>目录，包含所有版本使用的样式。</li></ul><p id="850f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些文件夹旁边是一个<code class="fe na nb nc nd b">js</code>目录，里面有四个文件:</p><ul class=""><li id="25cb" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la mw mx my mz bi translated"><code class="fe na nb nc nd b">script.js</code>，运行演示关卡。</li><li id="79be" class="mr ms iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated"><code class="fe na nb nc nd b">player.js</code>，包含玩家类。</li><li id="8e3c" class="mr ms iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated"><code class="fe na nb nc nd b">game.js</code>，包含游戏类。</li><li id="af76" class="mr ms iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated"><code class="fe na nb nc nd b">random_walk.js</code>，生成玩家所在的洞穴。</li></ul><p id="2d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们仔细看看游戏和玩家职业。</p><h2 id="23c0" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">游戏课</h2><p id="ac31" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><code class="fe na nb nc nd b">game.js</code>中的游戏对象持有地图、<code class="fe na nb nc nd b">&lt;canvas&gt;</code>元素和称为<code class="fe na nb nc nd b">context.</code>的绘图方法包。<code class="fe na nb nc nd b">touchCoords</code>属性存储滑动期间最后记录的触摸位置，<code class="fe na nb nc nd b">timer</code>属性帮助处理玩家在阶段3中的滑行。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The game class.</figcaption></figure><p id="ec69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">游戏的<code class="fe na nb nc nd b">map</code>属性是一个2D数组。每块墙砖是一个<code class="fe na nb nc nd b">0</code>，每块地砖是一个<code class="fe na nb nc nd b">1</code>。下面是一张5x4的地图，有两块瓷砖宽的走廊。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="2d62" class="nj lp iq nd b gy ob oc l od oe">[[0,0,0,0,0], <br/> [1,1,1,1,1],<br/> [1,1,1,1,1],<br/> [0,0,0,0,0]]</span></pre><h2 id="e9e0" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">玩家对象</h2><p id="6911" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们在<code class="fe na nb nc nd b">player.js</code>中的玩家对象存储了两个属性:速度和位置。两者都有<code class="fe na nb nc nd b">x</code>和<code class="fe na nb nc nd b">y</code>组件。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="edf3" class="nj lp iq nd b gy ob oc l od oe">class Player {<br/>    constructor(coords) {<br/>        this.coords = coords;</span><span id="e5ff" class="nj lp iq nd b gy of oc l od oe">        this.velocity = {<br/>            x:0,<br/>            y:0<br/>        };<br/>    }<br/>}</span></pre><p id="72c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">速度从零开始，当我们在<code class="fe na nb nc nd b">script.js</code>中创建玩家时，我们通过地图的中心作为位置。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="2155" class="nj lp iq nd b gy ob oc l od oe">// script.js </span><span id="758d" class="nj lp iq nd b gy of oc l od oe">let coords = {<br/>        x: COLS / 2,<br/>        y: ROWS / 2<br/>};</span><span id="847e" class="nj lp iq nd b gy of oc l od oe">player = new Player(coords);</span></pre><h2 id="9dbd" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">检查方向</h2><p id="2b31" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">用光标键移动播放器应该已经在<code class="fe na nb nc nd b">project</code>目录中工作了，因为<code class="fe na nb nc nd b">script.js</code>有处理按键的逻辑，如下所示。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="dca9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的<code class="fe na nb nc nd b">checkDirection</code>中，我们使用一个开关/盒子来根据键码移动玩家。</p><p id="5207" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经走过了<code class="fe na nb nc nd b">game.js</code>、<code class="fe na nb nc nd b">player.js</code>和<code class="fe na nb nc nd b">script.js</code>的关键部分，让我们开始添加滑动逻辑。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="b550" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">阶段1:基本刷卡响应</h1><p id="2763" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们的工作将发生在<code class="fe na nb nc nd b">project</code>目录的<code class="fe na nb nc nd b">swipe.js</code>中，它从空函数开始。对于阶段1，我们将编写五个:</p><ul class=""><li id="8aad" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la mw mx my mz bi translated">两个触摸处理器，<code class="fe na nb nc nd b">swipeStart</code>和<code class="fe na nb nc nd b">swipeMove</code></li><li id="9454" class="mr ms iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">两个辅助功能，<code class="fe na nb nc nd b">setVelocityX</code>和<code class="fe na nb nc nd b">setVelocityY</code></li><li id="319a" class="mr ms iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">一种称为<code class="fe na nb nc nd b">checkPlayer</code>的碰撞检测功能</li></ul><h2 id="fb1c" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">开始刷卡</h2><p id="d7e1" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在<code class="fe na nb nc nd b">script.js</code>的<code class="fe na nb nc nd b">init()</code>功能中有一个用于开始滑动的监听器。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="52a3" class="nj lp iq nd b gy ob oc l od oe">game.canvas.addEventListener('touchstart', swipeStart);</span></pre><p id="b53e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是我们初始的<code class="fe na nb nc nd b">swipeStart</code>函数，它以<code class="fe na nb nc nd b">event</code>为参数。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="175d" class="nj lp iq nd b gy ob oc l od oe">function swipeStart(event) {<br/>}</span></pre><p id="ea96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe na nb nc nd b">event</code>对象保存一个名为<code class="fe na nb nc nd b">touches</code>的数组。<code class="fe na nb nc nd b">touches</code>数组中的每个对象代表一个触摸设备表面的手指。</p><p id="147a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该只在屏幕上有一个手指的情况下做出响应——如果有两个手指，我们希望允许缩放。所以让我们检查一下数组的长度。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="c2ec" class="nj lp iq nd b gy ob oc l od oe">function swipeStart(event) {</span><span id="fdc2" class="nj lp iq nd b gy of oc l od oe">   if (event.touches.length == 1) {</span></pre><p id="3f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果只有一次触摸，让我们用<code class="fe na nb nc nd b">preventDefault()</code>方法来防止默认触摸响应。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="6691" class="nj lp iq nd b gy ob oc l od oe">function swipeStart(event) {</span><span id="04c7" class="nj lp iq nd b gy of oc l od oe">   if (event.touches.length == 1) {</span><span id="a074" class="nj lp iq nd b gy of oc l od oe"><strong class="nd ir">     event.preventDefault();<br/>   }<br/>}</strong></span></pre><p id="c135" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们抓住第一个<code class="fe na nb nc nd b">touch</code>对象。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="0aab" class="nj lp iq nd b gy ob oc l od oe">event.preventDefault();</span><span id="6312" class="nj lp iq nd b gy of oc l od oe"><strong class="nd ir">let obj = event.touches[0];</strong></span></pre><p id="06a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来提取两个属性:<code class="fe na nb nc nd b">clientX</code>和<code class="fe na nb nc nd b">clientY</code>，代表触摸的坐标。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="cd1c" class="nj lp iq nd b gy ob oc l od oe">let obj = event.touches[0];</span><span id="e096" class="nj lp iq nd b gy of oc l od oe"><strong class="nd ir">let {clientX, clientY} = obj;</strong></span></pre><p id="0634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们将触摸的起点存储在<code class="fe na nb nc nd b">game</code>对象中。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="09d3" class="nj lp iq nd b gy ob oc l od oe">game.touchCoords.x = clientX;<br/>game.touchCoords.y = clientY;</span></pre><p id="2320" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe na nb nc nd b">swipeStart</code>功能。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The swipeStart function.</figcaption></figure><h2 id="0471" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">跟踪刷卡</h2><p id="bf81" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">隐藏在我们的<code class="fe na nb nc nd b">init</code>函数中的是另一个监听器，用于检测<code class="fe na nb nc nd b">touchMove</code>事件。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="9081" class="nj lp iq nd b gy ob oc l od oe">game.canvas.addEventListener('touchmove', swipeMove);</span></pre><p id="6c98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe na nb nc nd b">swipeStart</code>一样，让我们通过检查触摸次数和阻止默认动作(如滚动)来启动<code class="fe na nb nc nd b">swipeMove</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="c8a9" class="nj lp iq nd b gy ob oc l od oe">function swipeMove(event) {</span><span id="0c0f" class="nj lp iq nd b gy of oc l od oe">  if (event.touches.length == 1) {</span><span id="6abe" class="nj lp iq nd b gy of oc l od oe">     event.preventDefault();<br/>  }<br/>}</span></pre><p id="0370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和<code class="fe na nb nc nd b">swipeStart</code>一样，我们需要从触摸对象中提取<code class="fe na nb nc nd b">clientX</code>和<code class="fe na nb nc nd b">clientY</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="24cb" class="nj lp iq nd b gy ob oc l od oe">event.preventDefault();</span><span id="9ff4" class="nj lp iq nd b gy of oc l od oe"><strong class="nd ir">let obj = event.touches[0];</strong></span><span id="5870" class="nj lp iq nd b gy of oc l od oe"><strong class="nd ir">let {clientX,clientY} = obj;</strong></span></pre><h2 id="4da3" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">寻找旅行的距离</h2><p id="fbc6" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">现在让我们来测量手指从最后一个记录点移动了多远。对于x和y坐标，我们将获得当前位置，在<code class="fe na nb nc nd b">touchCoords</code>中减去过去的位置，并找出差异。我们可以在一个叫做<code class="fe na nb nc nd b">diff</code>的对象中存储沿每个轴移动的距离。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="80b9" class="nj lp iq nd b gy ob oc l od oe">let diff = {<br/>   x: clientX - game.touchCoords.x,<br/>   y: clientY - game.touchCoords.y<br/>};</span></pre><p id="503c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在测试<code class="fe na nb nc nd b">diff</code>之前，我们先把玩家当前的坐标保存在<code class="fe na nb nc nd b">oldX</code>和<code class="fe na nb nc nd b">oldY</code>两个常量中。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="bda7" class="nj lp iq nd b gy ob oc l od oe">const {x: oldX, y: oldY} = player.coords;</span></pre><p id="bde4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也把它们存储在两个变量中，<code class="fe na nb nc nd b">newX</code>和<code class="fe na nb nc nd b">newY</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="e8ed" class="nj lp iq nd b gy ob oc l od oe">let {x: newX, y: newY} = player.coords;</span></pre><h2 id="9e46" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">检查阈值</h2><p id="ef5e" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">因为即使是轻微的移动也会触发一个<code class="fe na nb nc nd b">touchMove</code>事件，我们不希望我们的玩家在每次这样的事件注册时都移动——因为它会移动得太快。相反，我们只希望它在手指位置距离最后一次记录的触摸足够远的情况下移动。</p><p id="e341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，只有当手指沿轴移动的距离超过下面的阈值时，我们才会触发移动。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="d8e2" class="nj lp iq nd b gy ob oc l od oe">const threshold = 20;</span></pre><p id="484d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果水平距离或<code class="fe na nb nc nd b">diff.x</code>超过了那个阈值，让我们调用一个新的<code class="fe na nb nc nd b">setVelocityX</code>函数，并将<code class="fe na nb nc nd b">newX</code>设置为它的返回值。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="c3eb" class="nj lp iq nd b gy ob oc l od oe">if (Math.abs(diff.x) &gt; threshold) {<br/>    newX = setVelocityX(diff, clientX, clientY, newX, newY);<br/>}</span></pre><p id="1354" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也来测试一下<code class="fe na nb nc nd b">diff.y</code>。如果超出阈值，我们通过调用<code class="fe na nb nc nd b">setVelocityY</code>来重新定义<code class="fe na nb nc nd b">newY</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="55cd" class="nj lp iq nd b gy ob oc l od oe">if (Math.abs(diff.y) &gt; threshold) {<br/>     newY = setVelocityY(diff, clientX, clientY, newX, newY);<br/>}</span></pre><p id="56ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe na nb nc nd b">newX</code>或<code class="fe na nb nc nd b">newY</code>已经改变，让我们调用我们的碰撞检测函数。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="bae6" class="nj lp iq nd b gy ob oc l od oe">if (newY != oldY || newX != oldX) {<br/>    checkPlayer(oldX, oldY, newX, newY);<br/>}</span></pre><p id="3787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe na nb nc nd b">swipeMove</code>功能。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The swipeMove function.</figcaption></figure><h2 id="8f81" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">设定速度</h2><p id="3d14" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">现在让我们来研究速度的辅助函数。为了让玩家移动一格，我们通过将<code class="fe na nb nc nd b">diff.x</code>除以其绝对值来设置速度为<code class="fe na nb nc nd b">-1</code>或<code class="fe na nb nc nd b">1</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="44b6" class="nj lp iq nd b gy ob oc l od oe">function setVelocityX(diff, clientX, clientY, newX, newY) {</span><span id="4965" class="nj lp iq nd b gy of oc l od oe">     player.velocity.x = diff.x / Math.abs(diff.x);<br/>}</span></pre><p id="fc7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将触摸位置的x坐标<code class="fe na nb nc nd b">clientX</code>作为新的<code class="fe na nb nc nd b">x</code>值存储在<code class="fe na nb nc nd b">touchCoords</code>中。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="410d" class="nj lp iq nd b gy ob oc l od oe">player.velocity.x = diff.x / Math.abs(diff.x);</span><span id="55c5" class="nj lp iq nd b gy of oc l od oe"><strong class="nd ir">game.touchCoords.x = clientX;</strong></span></pre><p id="d0b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe na nb nc nd b">touchCoords</code>已经更新，玩家不会水平移动，直到触摸向右或向左再移动20个像素。</p><p id="05b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将<code class="fe na nb nc nd b">velocity.x</code>值与<code class="fe na nb nc nd b">player.coords.x</code>相加，并将总和存储在<code class="fe na nb nc nd b">newX</code>中。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="db05" class="nj lp iq nd b gy ob oc l od oe">game.touchCoords.x = clientX;</span><span id="1d9b" class="nj lp iq nd b gy of oc l od oe"><strong class="nd ir">newX = player.coords.x + player.velocity.x;</strong></span></pre><p id="d191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们返回<code class="fe na nb nc nd b">newX</code>。</p><p id="fb33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是设置水平速度的全部功能。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The setVelocityX method.</figcaption></figure><p id="741a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个类似的函数，设置垂直速度，更新最近的触摸位置，设置<code class="fe na nb nc nd b">newY</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The setVelocityY method.</figcaption></figure><p id="4eb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您现在运行代码，播放器将忽略墙壁—所以让我们添加一些碰撞检测。</p><h2 id="e483" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">冲突检出</h2><p id="90c1" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在<code class="fe na nb nc nd b">swipeMove</code>结束时，如果<code class="fe na nb nc nd b">newX</code>或<code class="fe na nb nc nd b">newY</code>有变化，我们就叫<code class="fe na nb nc nd b">checkPlayer</code>，</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="c025" class="nj lp iq nd b gy ob oc l od oe">if (newY != oldY || newX != oldX) {<br/>     checkPlayer(oldX, oldY, newX, newY);<br/>}</span></pre><p id="4158" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在就写<code class="fe na nb nc nd b">checkPlayer</code>吧。我们将从检测空闲块的辅助函数开始。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="888b" class="nj lp iq nd b gy ob oc l od oe">function checkPlayer(oldX, oldY, newX, newY) {<br/>    const freeTile = (x, y) =&gt; game.map[y][x] != WALL_CODE;<br/>}</span></pre><p id="8cdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果目标牌是空的，玩家可以移动到那里。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="5efa" class="nj lp iq nd b gy ob oc l od oe">function checkPlayer(oldX, oldY, newX, newY) {<br/>    const freeTile = (x, y) =&gt; game.map[y][x] != WALL_CODE;<br/>    <br/>    if (freeTile(newX, newY)) {<br/>        movePlayer(newX, newY);<br/>    }<br/> <br/>}</span></pre><p id="e683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，当沿轴超过距离阈值时，相应地设置速度，只要没有障碍物，玩家就移动一个方格。</p><p id="9dcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经完成了第一阶段。如果你一直和我们一起编码，你可以看看<a class="ae kc" href="https://roguelike-swipe.netlify.app/phase-1/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>来比较你的工作。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="3957" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">第二阶段:对角线运动</h1><p id="8844" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">既然基本的滑动逻辑已经工作了，让我们来决定我们是想要直线移动还是对角线移动。</p><p id="30c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要一个对角滑动的阈值。要设置一个，想象一个45–45°的三角形，其中对角线扫动是斜边c边。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/fd269b12a1bd7169de2fae1d0acb2940.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*qQz5y7iNEx2d8IMjBP8Tlg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image from <a class="ae kc" href="http://www.omnicalculator.com." rel="noopener ugc nofollow" target="_blank">www.omnicalculator.com.</a></figcaption></figure><p id="e3b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们希望对角线滑动超过20°，水平和垂直滑动应该超过这个三角形的边长，也就是14.14。在<code class="fe na nb nc nd b">swipeMove</code>中，让我们用这个值初始化<code class="fe na nb nc nd b">diag_threshold</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="cb38" class="nj lp iq nd b gy ob oc l od oe">const threshold = 20;<br/><strong class="nd ir">const diag_threshold = 14.14;</strong></span></pre><p id="d9d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面，让我们通过查看<code class="fe na nb nc nd b">x</code>和<code class="fe na nb nc nd b">y</code>值的变化是否超过这个较小的阈值来测试对角滑动。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Code for handling the diagonal case.</figcaption></figure><p id="264e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将水平情况更改为<code class="fe na nb nc nd b">else-if</code>语句，以确保它不会与对角线情况同时出现。如果玩家水平移动，我们把垂直速度设为零。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="3992" class="nj lp iq nd b gy ob oc l od oe">} else if (Math.abs(diff.x) &gt; threshold) {  <br/>                                   <br/>   newX = setVelocityX(diff, clientX, clientY, newX, newY); <br/>                                   <br/>   player.velocity.y = 0;                                                           }</span></pre><p id="02f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们对垂直的情况做同样的事情，把它改为<code class="fe na nb nc nd b">else-if</code>，把水平速度设置为零。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="ba9e" class="nj lp iq nd b gy ob oc l od oe">} else if (Math.abs(diff.y) &gt; threshold) {  <br/>                                      <br/>    newY = setVelocityY(diff, clientX, clientY, newX, newY);  <br/>                              <br/>    player.velocity.x = 0;  <br/>}                         </span></pre><p id="f652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe na nb nc nd b">swipeMove</code>函数中的if-else树。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The full if-else tree.</figcaption></figure><h2 id="a14d" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">增加球员移动的灵活性</h2><p id="4d5a" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在<code class="fe na nb nc nd b">checkPlayer</code>中，如果玩家沿对角线移动，我们检查目标牌是否空闲。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="ffa9" class="nj lp iq nd b gy ob oc l od oe">if (freeTile(newX, newY)) {</span><span id="3e72" class="nj lp iq nd b gy of oc l od oe">   movePlayer(newX, newY);</span><span id="2ebc" class="nj lp iq nd b gy of oc l od oe">}</span></pre><p id="a3d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让玩家的动作尽可能流畅，让玩家尝试水平或垂直运动，作为对角运动受阻时的备用。让我们首先在垂直速度的方向上寻找一个自由瓷砖。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="01e6" class="nj lp iq nd b gy ob oc l od oe">else if (<strong class="nd ir">newY</strong> != oldY &amp;&amp; freeTile(oldX, <strong class="nd ir">newY</strong>)) {</span><span id="e1b2" class="nj lp iq nd b gy of oc l od oe">    movePlayer(oldX, newY);<br/>} </span></pre><p id="5c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果该块不是空闲的，让我们也检查一下水平相邻的块是否可用。如果是，玩家水平移动。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="1708" class="nj lp iq nd b gy ob oc l od oe">else if (<strong class="nd ir">newX </strong>!= oldX &amp;&amp; freeTile(<strong class="nd ir">newX,</strong> oldY)) {</span><span id="b8a6" class="nj lp iq nd b gy of oc l od oe">     movePlayer(newX, oldY);<br/>}</span></pre><p id="462a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是更新后的<code class="fe na nb nc nd b">checkPlayer</code>功能，它允许玩家在对角线移动受阻但附近有瓷砖可用的情况下移动。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="917f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您已经完成了对角线逻辑，请继续将您的工作与<a class="ae kc" href="https://roguelike-swipe.netlify.app/phase-2/index.html'" rel="noopener ugc nofollow" target="_blank">阶段2演示</a>进行比较。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="b3b8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">第三阶段:滑行</h1><p id="a564" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">让我们添加滑行行为，这样，如果一个手指停留下来并停止移动，玩家将继续向那个方向移动，直到碰到一面墙。为了实现这个，我们会写两个函数，<code class="fe na nb nc nd b">coastPlayer</code>和<code class="fe na nb nc nd b">stopCoast</code>，在各个地方调用它们。</p><p id="8e20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">滑行需要玩家周期性地移动，而不需要更多的输入。虽然我们可以使用<code class="fe na nb nc nd b">setInterval</code>来实现这一点，但我们将使用<code class="fe na nb nc nd b">requestAnimationFrame</code>，它只在屏幕准备重绘时移动播放器。</p><h2 id="0602" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">从海岸开始</h2><p id="27dd" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">让我们更新<code class="fe na nb nc nd b">swipeMove</code>，这样如果一个滑动导致玩家移动，我们等待125毫秒，然后请求一个动画帧，用<code class="fe na nb nc nd b">coastPlayer</code>作为回调。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="2e78" class="nj lp iq nd b gy ob oc l od oe">if (newY != oldY || newX != oldX) {</span><span id="8ae4" class="nj lp iq nd b gy of oc l od oe">   checkPlayer(oldX, oldY, newX, newY);</span><span id="8f38" class="nj lp iq nd b gy of oc l od oe">   if (!game.timer) {<br/>         let delay = 125;<br/>         game.timer = window.setTimeout(function() {<br/>               window.requestAnimationFrame(coastPlayer);<br/>         }, delay);<br/>   }<strong class="nd ir"><br/></strong>}</span></pre><h2 id="dab8" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">海岸线</h2><p id="940b" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在<code class="fe na nb nc nd b">coastPlayer</code>函数中，我们根据玩家当前的速度来移动玩家。为此，我们首先提取速度的<code class="fe na nb nc nd b">x</code>和<code class="fe na nb nc nd b">y</code>值。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="5de6" class="nj lp iq nd b gy ob oc l od oe">function coastPlayer() {</span><span id="8d7a" class="nj lp iq nd b gy of oc l od oe">   let {x,y} = player.velocity;</span></pre><p id="f4a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如在<code class="fe na nb nc nd b">swipeMove</code>中，我们然后设置旧的和新的坐标。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="1c53" class="nj lp iq nd b gy ob oc l od oe">const { x: oldX, y: oldY} = player.coords;</span><span id="8e77" class="nj lp iq nd b gy of oc l od oe">let {x: newX, y: newY} = player.coords;</span></pre><p id="6fc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果速度的<code class="fe na nb nc nd b">x</code>分量非零，我们将其加到<code class="fe na nb nc nd b">newX</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="c026" class="nj lp iq nd b gy ob oc l od oe">if (x) {<br/>        newX = player.coords.x + x;<br/>}</span></pre><p id="662f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe na nb nc nd b">y</code>不为零，我们将<code class="fe na nb nc nd b">y</code>分量加到<code class="fe na nb nc nd b">newY</code>上。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="fc0e" class="nj lp iq nd b gy ob oc l od oe">if (y) {<br/>     newY = player.coords.y + y;<br/>}</span></pre><p id="4d12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们检查是否可以移动玩家。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="d202" class="nj lp iq nd b gy ob oc l od oe">checkPlayer(oldX, oldY, newX, newY);</span></pre><p id="5d21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe na nb nc nd b">game.timer</code>为非空，这意味着动画仍在继续，因此请求另一个动画帧，递归调用<code class="fe na nb nc nd b">coastPlayer</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="cd25" class="nj lp iq nd b gy ob oc l od oe">if (game.timer) {<br/>   let delay = 100;<br/>   game.timer = window.setTimeout(function() {<br/>      window.requestAnimationFrame(coastPlayer);<br/>   }, delay);<br/>}</span></pre><p id="21c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe na nb nc nd b">coastPlayer</code>功能。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="5821" class="nj lp iq bd lq nk nl dn lu nm nn dp ly ko no np mc ks nq nr mg kw ns nt mk nu bi translated">停止海岸</h2><p id="f957" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在我们的<code class="fe na nb nc nd b">stopCoast</code>函数中，如果超时事件正在发生，我们会将其清除，并将<code class="fe na nb nc nd b">game.timer</code>设置为<code class="fe na nb nc nd b">null</code>，以表示滑行间隔既不在进行中也不会发生。然后我们更新地图。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="8c81" class="nj lp iq nd b gy ob oc l od oe">function stopCoast() {<br/>    window.clearTimeout(game.timer);<br/>    game.timer = null;<br/>    drawMap(0, 0, COLS, ROWS);<br/>}</span></pre><p id="224a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果碰到墙，如果接触结束，或者手指有移动，玩家应该停止滑行。为了进行任何显著的触摸运动来取消滑行，让我们在<code class="fe na nb nc nd b">setVelocityX</code>和<code class="fe na nb nc nd b">setVelocityY</code>开始时调用<code class="fe na nb nc nd b">stopCoast</code>。例如:</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="7262" class="nj lp iq nd b gy ob oc l od oe">function setVelocityX(diff, clientX, clientY, newX, newY) {<br/>    stopCoast();</span></pre><p id="d49b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在玩家碰壁时停止滑行，让我们在<code class="fe na nb nc nd b">checkPlayer</code>结束时的最终<code class="fe na nb nc nd b">else</code>条件下调用<code class="fe na nb nc nd b">stopCoast</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The new if-else tree with stopCoast.</figcaption></figure><p id="4da1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们在刷卡结束时停止滑行。在<code class="fe na nb nc nd b">script.js</code>中，有一个监听器调用<code class="fe na nb nc nd b">swipeEnd</code>来结束一个触摸动作。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="1810" class="nj lp iq nd b gy ob oc l od oe">game.canvas.addEventListener('touchend', swipeEnd);</span></pre><p id="c627" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe na nb nc nd b">swipeEnd</code>中，让我们阻止默认动作，将速度设置为零，并调用<code class="fe na nb nc nd b">stopCoast</code>。</p><pre class="lc ld le lf gt nx nd ny nz aw oa bi"><span id="6f72" class="nj lp iq nd b gy ob oc l od oe">function swipeEnd(e) {<br/>    e.preventDefault();<br/>    player.velocity = {<br/>        x: 0,<br/>        y: 0<br/>    };<br/>    stopCoast();<br/>}</span></pre><p id="0378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经走到这一步，恭喜你！您已经完成了教程。请随意将您的代码与<a class="ae kc" href="https://roguelike-swipe.netlify.app/phase-3/index.html" rel="noopener ugc nofollow" target="_blank">阶段3演示</a>进行比较。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="b841" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">更进一步</h1><p id="2972" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">一个可能的下一步是添加其他功能，使这个项目感觉更像一个游戏。作为一个例子，我在一个<a class="ae kc" href="https://roguelike-swipe.netlify.app/game/index.html" rel="noopener ugc nofollow" target="_blank">示例游戏</a>中添加了类似的滑动代码，该游戏有滚动、敌人、要收集的遗迹和恢复生命的药剂。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/4ac1b4a33d6d606e815efa267b8f0e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*QpgZIV56n3I7p7fPM8Wn1Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The game with red enemies, green potions, and orange weapons.</figcaption></figure><p id="ab39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个游戏的<code class="fe na nb nc nd b">swipe.js</code>文件中，<code class="fe na nb nc nd b">checkPlayer</code>逻辑被调整为处理敌人碰撞。您可以<a class="ae kc" href="https://roguelike-swipe.netlify.app/game/index.html" rel="noopener ugc nofollow" target="_blank">尝试一下</a>并在<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-swipe/tree/main/game" rel="noopener ugc nofollow" target="_blank"> Github </a>或您下载的<code class="fe na nb nc nd b">game</code>目录中检查代码。</p><p id="4d94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！请随意访问<a class="ae kc" href="https://roguelike-swipe.netlify.app/" rel="noopener ugc nofollow" target="_blank">主演示页面</a>查看游戏、启动项目和分阶段解决方案。</p><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-add-scrolling-to-a-javascript-roguelike-c9f835d10537"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">如何制作一个JavaScript Roguelike卷轴</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">让我们一次只展示地牢的一部分。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz jw ol"/></div></div></a></div><p id="6e22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="pa">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="pa">plain English . io</em></strong></a><em class="pa">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pa">免费周报</em> </strong> </a> <em class="pa">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="pa">Twitter</em></strong></a><em class="pa">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="pa">LinkedIn</em></strong></a><em class="pa">。查看我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pa">社区不和谐</em> </strong> </a> <em class="pa">加入我们的</em> <a class="ae kc" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pa">人才集体</em> </strong> </a> <em class="pa">。</em></p></div></div>    
</body>
</html>