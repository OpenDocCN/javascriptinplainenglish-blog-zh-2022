<html>
<head>
<title>Don’t Deep Copy With JSON.Stringify and JSON.Parse in JS — Here’s Why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要用JSON深度复制。Stringify和JSON。用JS解析——原因如下</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dont-deep-copy-with-json-stringify-and-json-parse-in-js-here-s-why-c3f2783661e9?source=collection_archive---------2-----------------------#2022-05-16">https://javascript.plainenglish.io/dont-deep-copy-with-json-stringify-and-json-parse-in-js-here-s-why-c3f2783661e9?source=collection_archive---------2-----------------------#2022-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4b56" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果您关心常见的数据类型，包括正确获得深度复制的<code class="fe kf kg kh ki b">Date</code>对象和<code class="fe kf kg kh ki b">undefined</code>，请注意这种由JSON规范中的怪癖引起的常见错误。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/c7cc5e62839380d49b9070b193c150cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fPATW_vrRjBRAFQq"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@quaritsch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Quaritsch Photography</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b3cb" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我问你一个面试问题，向我解释一下<a class="ae kz" href="https://medium.com/swlh/what-is-json-used-for-in-javascript-programming-9d71284359a9" rel="noopener">JavaScript Object Notation(JSON)</a>，你会提到它的具体局限性吗？</p><div class="lw lx gp gr ly lz"><a href="https://medium.com/swlh/what-is-json-used-for-in-javascript-programming-9d71284359a9" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">JSON在JavaScript编程中是用来做什么的？</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">JSON (JavaScript Object Notation)是一种常用的文件格式，用于存储数据，而不是像XML或YAML这样的替代文件</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kt lz"/></div></div></a></div><p id="de23" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我来回答这个问题，我可能不会提到任何限制。我认为JSON是一种有用的编写JavaScript对象的方法，使用的语法基本上与JS本身相同。</p><p id="adb5" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">除此之外，我要补充的是，它通常用于以文本格式存储数据，并且有<code class="fe kf kg kh ki b">JSON.stringify()</code>和<code class="fe kf kg kh ki b">JSON.parse()</code>助手方法。</p><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-use-stringify-and-parse-in-javascript-6b637b571a32"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">如何在JavaScript中使用JSON.stringify()和JSON.parse()</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">JSON.stringify()和JSON.parse()是处理JSON格式内容的有用工具</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn kt lz"/></div></div></a></div><p id="c30e" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是我会完全跳过JSON的限制和怪癖，从它不能处理许多常见的数据类型到我实际上更喜欢使用<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/p/3242c9eae48c" rel="noopener">ES6 export</a></code>将对象存储在<code class="fe kf kg kh ki b">.js</code>(或者<code class="fe kf kg kh ki b">.ts</code>，对于<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-sort-imports-in-typescript-automatically-in-vs-code-f4fe4e499bb1"> TypeScript </a>)文件中。</p><p id="acee" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我猜<a class="ae kz" href="https://blog.devgenius.io/why-you-cant-just-be-a-software-engineer-689e56eacef3" rel="noopener ugc nofollow" target="_blank">我不会雇佣自己</a>做<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/top-10-advanced-vs-code-settings-for-senior-developers-46e348351bd6">高级开发人员</a>或者类似的事情。好吧，也许这有点苛刻。你还记得你头顶上的限制吗？如果你有，你比我强。如果没有，请继续阅读！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="1046" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">JSON的局限性，以及它们的重要性</h1><p id="072b" class="pw-post-body-paragraph la lb iq lc b ld no jr lf lg np ju li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">在你的记忆库中，你可能有一个模糊的记忆，JSON并不完美，某些数据类型不能被"<a class="ae kz" href="https://www.oreilly.com/library/view/javascript-the-definitive/9781449393854/ch06s09.html" rel="noopener ugc nofollow" target="_blank">序列化</a>"</p><p id="d1fa" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这么说吧，JSON规范有点粗糙，以至于我已经习惯了为JavaScript代码格式化器更漂亮的而不是默认的<code class="fe kf kg kh ki b">.prettierrc</code>制作一个<code class="fe kf kg kh ki b"><a class="ae kz" href="https://betterprogramming.pub/how-to-set-up-vs-code-like-a-pro-in-just-5-minutes-65aaa5788c0d" rel="noopener ugc nofollow" target="_blank">prettier.config.js</a></code>文件。</p><p id="deda" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在这种情况下，没有什么理由更喜欢使用<code class="fe kf kg kh ki b">.js</code>文件扩展名而不是隐含的JSON文件扩展名<code class="fe kf kg kh ki b">.prettierrc</code>，但我还是这么做了。</p><p id="09e2" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这有助于提醒我JSON中存在某些问题，例如:</p><ul class=""><li id="98ba" class="nt nu iq lc b ld le lg lh lj nv ln nw lr nx lv ny nz oa ob bi translated">在JSON文件的列表中不能有尾随逗号，但是在JavaScript中可以，这会影响到<a class="ae kz" href="https://levelup.gitconnected.com/how-to-check-for-an-object-in-javascript-object-null-check-3b2632330296" rel="noopener ugc nofollow" target="_blank">对象</a>和<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-an-array-in-javascript-6ad20f7a0e21">数组</a>的语法。</li><li id="3d7d" class="nt nu iq lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">值<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/coding-at-dawn/how-to-check-for-undefined-in-javascript-bcedd62c8ad" rel="noopener">undefined</a></code>无效，<code class="fe kf kg kh ki b"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-a-symbol-in-javascript-30c3f294ea65">Symbol</a></code> s无效，<code class="fe kf kg kh ki b"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-a-function-in-javascript-986248827790">Function</a></code>T15】s也无效。</li><li id="dc6e" class="nt nu iq lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated"><code class="fe kf kg kh ki b">Date</code>值通过<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString" rel="noopener ugc nofollow" target="_blank">date.toISOString()</a></code>进行转换，因此它们可以存储为<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-a-string-in-javascript-a16b196915ff">字符串</a> <a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/what-are-primitive-types-in-javascript-671909def6ca">原语</a>。</li><li id="9718" class="nt nu iq lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">特殊的<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-a-number-in-javascript-8d9024708153"> JavaScript数字</a> <code class="fe kf kg kh ki b"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-a-number-in-javascript-8d9024708153">NaN</a></code> <a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-a-number-in-javascript-8d9024708153">(非数字</a>)和<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/swlh/what-is-infinity-in-javascript-%EF%B8%8F-1faf82f100bc" rel="noopener">Infinity</a></code>被转换成<code class="fe kf kg kh ki b"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-null-in-javascript-dffab64d8ed5">null</a></code>，尽管<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/coding-at-dawn/is-negative-zero-0-a-number-in-javascript-c62739f80114" rel="noopener">-0</a></code> <a class="ae kz" href="https://medium.com/coding-at-dawn/is-negative-zero-0-a-number-in-javascript-c62739f80114" rel="noopener">(负零)</a>也可以。</li></ul><p id="9b97" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">哇，真是一大堆无聊的琐事，对吧？不对！正如我们将在后面看到的，当试图用JavaScript进行深层复制时，您可以对您的数据集进行修改。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="4e40" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">关于JSON需要知道的其他重要事情</h1><p id="8997" class="pw-post-body-paragraph la lb iq lc b ld no jr lf lg np ju li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">在处理某些数据类型时，还有一些其他重要的差异会导致特定的问题:</p><ul class=""><li id="b575" class="nt nu iq lc b ld le lg lh lj nv ln nw lr nx lv ny nz oa ob bi translated">“如果值有一个<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#tojson_behavior" rel="noopener ugc nofollow" target="_blank">toJSON()</a></code>方法，它负责定义哪些数据将被序列化。[…]</li><li id="6781" class="nt nu iq lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated"><code class="fe kf kg kh ki b">JSON.stringify()</code>可以在传入<code class="fe kf kg kh ki b">JSON.stringify(function() {})</code>或<code class="fe kf kg kh ki b">JSON.stringify(undefined)</code>等“纯”值时返回<code class="fe kf kg kh ki b">undefined</code>。</li><li id="b880" class="nt nu iq lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">所有<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">Symbol</a></code>键控属性将被完全忽略，即使使用<code class="fe kf kg kh ki b">replacer</code>功能。</li><li id="8657" class="nt nu iq lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">所有其他的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">Object</a></code>实例(包括<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">Map</a></code>、<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">Set</a></code>、<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank">WeakMap</a></code>和<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet" rel="noopener ugc nofollow" target="_blank">WeakSet</a></code>)将只有它们的可枚举属性被序列化。"<br/> — <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></li></ul><p id="f01d" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">把这些都放在一起，JSON没用吗？我们是否应该将对象加载到JavaScript文件中，而不是JSON文件中，然后就此结束？</p><p id="9a27" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">实际上JSON很好，但是有时候(比如使用<code class="fe kf kg kh ki b">undefined</code>)你可能需要将JavaScript对象保存为<code class="fe kf kg kh ki b">.js</code>文件，而不是<code class="fe kf kg kh ki b">.json</code>。</p><p id="6bfc" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是还有一件更重要的事情需要记住，那就是<a class="ae kz" href="https://en.wikipedia.org/wiki/Recursive_islands_and_lakes" rel="noopener ugc nofollow" target="_blank">数组嵌套在</a>数组内部的数组内部。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="8ecb" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">关键要点:记住这些JSON限制会影响深层副本</h1><p id="f32b" class="pw-post-body-paragraph la lb iq lc b ld no jr lf lg np ju li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">JSON在其规范中具有某些怪癖的最重要的影响与使用内置递归算法来深度复制JavaScript中的“深度嵌套”对象有关。</p><p id="86ef" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当处理类似于<a class="ae kz" href="https://en.wikipedia.org/wiki/Matryoshka_doll" rel="noopener ugc nofollow" target="_blank"> Matryoshka doll </a>的数据结构时，你需要小心，你成功地“深度复制”了所有的对象，正如我在我以前的权威指南中谈到的那样。</p><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">如何在JavaScript中深度复制对象和数组</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">复制对象或数组的常用方法只能进行浅层复制，所以深度嵌套的引用是个问题…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="oh l mk ml mm mi mn kt lz"/></div></div></a></div><p id="69d1" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">既然<code class="fe kf kg kh ki b"> JSON.stringify()</code>将成功地将其他对象内部的对象(“深度嵌套”对象和数组)编码成JSON格式，那么很明显，您可以使用<code class="fe kf kg kh ki b">JSON.parse()</code>进行“深度复制”。</p><p id="e045" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">事实上，这是网上给出的关于如何深度克隆可能包含其他对象的对象数组的常见解释——只需使用JSON，深度复制对象就再也不会有任何问题了。</p><p id="2944" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="oi">下面是要知道的。</em> <strong class="lc ir">如果</strong>你的深度嵌套<a class="ae kz" href="https://levelup.gitconnected.com/how-to-check-for-an-object-in-javascript-object-null-check-3b2632330296" rel="noopener ugc nofollow" target="_blank">对象</a>或数组只包含某些原始值(<a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-string-in-javascript-a16b196915ff" rel="noopener">字符串</a>、<a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-number-in-javascript-8d9024708153" rel="noopener">数字</a>、<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-a-boolean-in-javascript-98fdc8aec2a7">布尔</a>、<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-check-for-null-in-javascript-dffab64d8ed5">空值</a>，那么你可以使用<code class="fe kf kg kh ki b">JSON.parse()</code> &amp; <code class="fe kf kg kh ki b">JSON.stringify()</code>进行深度复制而不会出现问题。</p><p id="ced0" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们来看看当你尝试使用这种方法深度复制<code class="fe kf kg kh ki b">undefined</code>、<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/coding-in-simple-english/how-to-parse-a-date-using-a-regular-expression-in-javascript-f4e5b1d02935" rel="noopener">Date</a></code>、<a class="ae kz" href="https://medium.com/coding-in-simple-english/how-to-parse-a-date-using-a-regular-expression-in-javascript-f4e5b1d02935" rel="noopener">、</a>、<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/coding-in-simple-english/how-to-parse-a-date-using-a-regular-expression-in-javascript-f4e5b1d02935" rel="noopener">RegExp</a></code>、<a class="ae kz" href="https://medium.com/coding-in-simple-english/how-to-parse-a-date-using-a-regular-expression-in-javascript-f4e5b1d02935" rel="noopener">对象</a>或<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/swlh/what-is-infinity-in-javascript-%EF%B8%8F-1faf82f100bc" rel="noopener">Infinity</a></code>时会发生什么。记住，这些都是不可序列化的JSON数据的例子，所以我们预计会有意想不到的结果。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="c616" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">带有不可序列化的JSON数据的<code class="fe kf kg kh ki b">Date</code></h1><p id="12d6" class="pw-post-body-paragraph la lb iq lc b ld no jr lf lg np ju li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">正如您将要看到的，当处理无法“字符串化”的不可序列化的数据时，我们的深层副本不会成功</p><p id="7a0b" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我在使用内置JavaScript <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.datadriveninvestor.com/how-to-find-unique-dates-in-an-array-in-javascript-efd87ecfea66" rel="noopener ugc nofollow" target="_blank">Date</a></code>对象时最常遇到这个问题，该对象被转换成ISO字符串。</p><p id="f8f2" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">顺便说一下，您可能想阅读我的另一篇文章，这篇文章使用<a class="ae kz" href="https://medium.com/coding-at-dawn/how-to-use-set-to-filter-unique-items-in-javascript-es6-196c55ce924b" rel="noopener">ES6</a>T1】对象来查找数组中包含的唯一的<code class="fe kf kg kh ki b">Dates</code>:</p><div class="lw lx gp gr ly lz"><a href="https://medium.datadriveninvestor.com/how-to-find-unique-dates-in-an-array-in-javascript-efd87ecfea66" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">如何在JavaScript中查找数组中的唯一日期</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">JavaScript有三种方法来定义日期对象是否惟一:它是否有惟一的对象引用…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="mi l"><div class="oj l mk ml mm mi mn kt lz"/></div></div></a></div><p id="54a9" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">那篇文章还讨论了一些关于“对象引用”的细节，以及在JavaScript中作为唯一对象的真正含义。</p><p id="b042" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，我们将看到当我们试图将不“JSON安全”的数据输入到<code class="fe kf kg kh ki b">JSON.parse()</code>和<code class="fe kf kg kh ki b">JSON.stringify()</code>的等待口中时会发生什么。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="191d" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">复制不安全:<code class="fe kf kg kh ki b">Date</code>、<code class="fe kf kg kh ki b">undefined</code>和<code class="fe kf kg kh ki b">Infinity</code></h1><p id="c514" class="pw-post-body-paragraph la lb iq lc b ld no jr lf lg np ju li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">在第一个例子中，我们成功地制作了深层副本，但是由于JSON的限制，我们在这个过程中丢失了所有数据:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ok"><img src="../Images/04cb3bcb9fe73047aaad046ad27de6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ttb93EM3wyO6jsDMlkl_WA.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/4b3f092b6fdc9ce3143b9bafaadba752" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="a75f" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">从上面我们可以看到，我们确实有一个“深度克隆”，我们可以在不影响原始对象或数组的情况下改变嵌套值。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="129e" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">安全复制JSON数据:原始类型</h1><p id="29bc" class="pw-post-body-paragraph la lb iq lc b ld no jr lf lg np ju li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">另一方面，如果您能够保证您的数据只包含某些JSON认可的原语，那么您就可以参加比赛了。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ol"><img src="../Images/02f8174e4478d8813bf6ee4c03f5f189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jmJNiBWpGzlYv-TDFrOKA.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/f71798fd5498345ba3d0f4ce3253d397" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="d8b2" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">是的，这肯定比编写自定义递归函数或导入一些外部依赖项更方便。</p><p id="2f73" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">毕竟，不管怎样，谁会费心去记住<a class="ae kz" href="https://medium.com/p/3242c9eae48c" rel="noopener">你是应该使用</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/p/3242c9eae48c" rel="noopener">import</a></code> <a class="ae kz" href="https://medium.com/p/3242c9eae48c" rel="noopener">还是</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/p/3242c9eae48c" rel="noopener">require</a></code>来加载那个Lodash助手函数呢？</p><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/the-huge-difference-between-es6-import-and-es5-require-in-javascript-3242c9eae48c"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">JavaScript中ES6的“导入”和ES5的“要求”之间的巨大差异</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">你还在代码库中使用require吗？让我们尽快将您升级到现代JavaScript导入语法…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="om l mk ml mm mi mn kt lz"/></div></div></a></div><p id="c4eb" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这种方法不一定管用，真的太可惜了。JavaScript中没有可靠的内置深度复制方法，t <a class="ae kz" href="https://www.urbandictionary.com/define.php?term=Them%27s%20the%20breaks" rel="noopener ugc nofollow" target="_blank">哼哼的是breaks </a>。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="9617" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">第二个要点:在JavaScript中用JSON Parse和Stringify进行深度复制什么时候是安全的？</h1><p id="31a7" class="pw-post-body-paragraph la lb iq lc b ld no jr lf lg np ju li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">在某些情况下，使用我们在这里讨论的JSON helper方法进行深度复制是完全安全的。</p><p id="b6f7" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">事实上，知道如何方便地做到这一点可能会在任何涉及深层拷贝话题的技术面试中有所帮助。</p><p id="c9f7" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">另一方面，如果面试官期待的是递归算法，那么随便使用<code class="fe kf kg kh ki b">JSON.stringify()</code>和<code class="fe kf kg kh ki b">JSON.parse()</code>可能会让你看起来很糟糕。</p><p id="4707" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我想说，你回答这个问题的方式应该取决于该公司是否热衷于“技术不可知论”</p><p id="adab" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对于像谷歌、脸书这样的大雇主，以及某些喜欢在面试中问关于算法和数据结构的问题的小公司，你可能应该准备实施一个定制的递归解决方案。</p><p id="16b0" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果你申请的是一家更“致力于”某项技术的公司，比如我只申请了使用Next.js (React)和Tailwind CSS的公司，那么我认为你使用JSON <code class="fe kf kg kh ki b">stringify()</code>和<code class="fe kf kg kh ki b">parse()</code>会很安全。</p><p id="f5b0" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">事实上，记住本文中的JSON限制是展示您JavaScript知识深度的一种有用方式，特别是如果您能够将它与您以前的工作联系起来。<a class="ae kz" href="https://www.youtube.com/watch?v=V-OYKd8SVrI" rel="noopener ugc nofollow" target="_blank">能挖吗？</a></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="999f" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">延伸阅读:你知道怎么排序吗？</h1><p id="2881" class="pw-post-body-paragraph la lb iq lc b ld no jr lf lg np ju li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">如果你喜欢这篇文章，你可能会喜欢阅读我在Medium上的其他作品，发表在<em class="oi"> Coding at Dawn </em>和<em class="oi">JavaScript in Plain English</em>:</p><div class="lw lx gp gr ly lz"><a href="https://medium.com/coding-at-dawn/sorts-in-60-seconds-speedy-javascript-interview-answers-on-sorting-acb72bdea8a2" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">60秒内排序:关于排序的快速JavaScript面试答案</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">开发者访谈经常会问到排序算法——以下是如何解释10种不同的排序算法…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com\</p></div></div><div class="mi l"><div class="on l mk ml mm mi mn kt lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-sort-a-set-in-javascript-es6-51b53f6ef71a"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">如何在JavaScript ES6中对集合进行排序</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">需要排序一套？我已经用这个方便快捷的教程给你介绍了如何对一组独特的物品进行分类…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="oo l mk ml mm mi mn kt lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-sort-an-array-of-strings-in-javascript-5d59b1ac64be"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">如何在JavaScript中对字符串数组进行排序</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">JavaScript的默认值。sort()方法按字母升序对数组进行排序，如果您正在处理…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="op l mk ml mm mi mn kt lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a href="https://medium.com/coding-at-dawn/46-encouraging-quotes-for-web-developers-21f3e68a9fdd" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">给网络开发者的46条鼓励语录</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">过多的网络开发让你沮丧？当我有这种感觉时，我喜欢读这份引语清单，让自己振作起来…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="oq l mk ml mm mi mn kt lz"/></div></div></a></div><p id="2579" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">或者，你可能已经是所有这些话题的专家了。那也很好。</p><p id="45b0" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ir">编码快乐！</strong>🌠🍀🤞😉😄</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi or"><img src="../Images/2b01dca2fafc91cebee410cce2079470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SnArDKBrSkwih1zX"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@girlwithredhat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Girl with red hat</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="db2f" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kz" href="https://www.linkedin.com/in/derek-austin/" rel="noopener ugc nofollow" target="_blank">德里克·奥斯丁</a>博士是《职业规划<a class="ae kz" href="https://www.amazon.com/dp/B0BRJDLJ43" rel="noopener ugc nofollow" target="_blank"> <em class="oi">:如何在6个月内成为一名成功的6位数程序员</em> </a>的作者，现在亚马逊上有售。</p></div></div>    
</body>
</html>