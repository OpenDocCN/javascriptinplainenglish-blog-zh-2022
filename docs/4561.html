<html>
<head>
<title>SolidJS in Contrast to React: Could It Be Better?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SolidJS对比React:还能更好吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solidjs-in-contrast-to-react-could-it-be-better-1aad3ad0f169?source=collection_archive---------1-----------------------#2022-12-14">https://javascript.plainenglish.io/solidjs-in-contrast-to-react-could-it-be-better-1aad3ad0f169?source=collection_archive---------1-----------------------#2022-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b26b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解SolidJS和React的区别。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c238e05b96969b9e526851007616585a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyxUH77Wayu2MO-_idJD3w.png"/></div></div></figure><p id="b380" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不是一篇关于Solid JS与React JS的文章，而是一篇帮助您理解Solid JS并了解React开发人员的区别的文章。在开发社区中看到框架的比较是很常见的，有时很有趣，有时很私人化，但是接近框架的最好方法是把它们仅仅看作工具。您想要构建什么应该会影响使用哪个工具，或者您知道如何使用哪个工具应该会影响您接下/从事什么项目。</p><p id="15a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">够了。</p><h1 id="9b17" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated"><strong class="ak">什么是固体JS？</strong></h1><p id="cab5" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">Solid是一个<strong class="kq io">反应式</strong> JavaScript框架，用于制作交互式网络应用。使用Solid，您可以使用现有的HTML和JavaScript知识来构建可以在整个应用程序中重用的组件。Solid提供了增强组件反应能力的工具:声明性的JavaScript代码，将用户界面与它使用和创建的数据联系起来。</p><h1 id="76f9" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">固体JS中的组件</h1><p id="8f31" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">与React一样，组件是接受props对象并返回JSX元素(包括原生DOM元素和其他组件)的函数。实际上，组件是为了更好的模块化和可重用性。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="f42c" class="mn ll in mj b be mo mp l mq mr">function SimpleComponent(props) {<br/>  return &lt;div&gt;Hello {props.name}&lt;/div&gt;;<br/>}<br/><br/>&lt;SimpleComponent name="Joseph"/&gt;;</span></pre><p id="13f0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Solid JS中的组件不是有状态的，它们不拥有自己的状态，也不依赖于状态。它们主要是用来构建/组织JSX元素或者你的代码。因此，它们可以存在，也可以不存在。</p><p id="bfdd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样令人高兴的是，组件函数被调用一次后就不复存在了，这意味着你不需要担心像ReactJS中那样意外的重新呈现。所有更新由<strong class="kq io">固体反应系统</strong>应用。</p><h1 id="0b15" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">固体JS中的反应性</h1><p id="92cb" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">固体的惊人反应取决于<em class="mh">信号</em>、<em class="mh">备忘录</em>和<em class="mh">效果</em>。React中的钩子通常带有前缀<strong class="kq io"> use ( </strong> <em class="mh">如useState、useEffect、useMemo等)</em>、Solid中的钩子通常带有前缀<strong class="kq io"> create </strong>。</p><h2 id="6279" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated">信号</h2><p id="25b4" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">类似于React 中的<strong class="kq io">状态，信号是固体中反应性的基石。它们包含随时间变化的值；当你改变一个信号的值时，它<strong class="kq io">会自动</strong>更新任何使用它的东西。</strong></p><p id="def5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">信号的值开始等于传递的第一个参数<code class="fe ne nf ng mj b">initialValue</code>(如果没有参数，则为<code class="fe ne nf ng mj b">undefined</code>)。<code class="fe ne nf ng mj b">createSignal</code>函数返回一对函数，<strong class="kq io"> getter </strong>和<strong class="kq io"> setter </strong>函数读取和更新值。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="55f3" class="mn ll in mj b be mo mp l mq mr">const [count, setCount] = createSignal(0);<br/><br/>// to update the value of count<br/>setCount(1);</span></pre><p id="6457" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mh"> Solid的signals setter函数(</em><strong class="kq io"><em class="mh">set count</em></strong><em class="mh">)也接受一个函数形式，可以使用前一个值来设置下一个值。</em></p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="5117" class="mn ll in mj b be mo mp l mq mr">setCount(c =&gt; c + 1);</span></pre><p id="7a00" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作为函数调用getter(如<code class="fe ne nf ng mj b">count()</code>)返回信号的当前值。这与ReactJs相反，react js将getter直接用作变量。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="08a4" class="mn ll in mj b be mo mp l mq mr">const App = () =&gt; {<br/>  const [count, setCount] = createSignal(0);<br/><br/>  return &lt;div&gt;{count()}&lt;/div&gt;;<br/>};</span></pre><p id="1318" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mh">更多关于信号… </em> </strong></p><p id="7350" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用上面的代码示例，Solid自动跟踪对<strong class="kq io"><em class="mh">count()</em></strong><em class="mh"/>的任何调用，并在其值发生变化时更新它。Solid称之为粒度更新。同时在React中，当<strong class="kq io">计数</strong>改变时，整个组件被重新渲染。</p><p id="e5d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当在<em class="mh">跟踪范围</em>中调用依赖性时，例如在构建“计算”(<code class="fe ne nf ng mj b">createEffect</code>、<code class="fe ne nf ng mj b">createMemo</code>等)的JSX表达式或API调用中，这种依赖性的自动跟踪起作用。)</p><blockquote class="nh ni nj"><p id="d11d" class="ko kp mh kq b kr ks jo kt ku kv jr kw nk ky kz la nl lc ld le nm lg lh li lj ig bi translated"><strong class="kq io">跟踪范围:</strong>这些是SolidJS源代码中的特定块，当信号的值改变时，信号的值将在这些块中更新。createEffect是一个跟踪作用域，组件中的JSX是一个跟踪作用域，所以在JSX使用的任何信号在它改变值时都会被更新。</p></blockquote><p id="bead" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，日志记录<em class="mh">(console . log)</em>count的值将只运行一次，即使count被更新也不会再次运行。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="34e2" class="mn ll in mj b be mo mp l mq mr">function Counter() {<br/>  const [count, setCount] = createSignal(1);<br/>  setInterval(() =&gt; setCount(count() + 1), 1000);<br/><br/>  console.log(count()); // This will only run when the component firsts renders<br/><br/>  return (<br/>    &lt;div&gt;<br/>      {count()} // This will update when count changes value<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="fd50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了使<code class="fe ne nf ng mj b">console.log</code>在每次计数更新时运行，它必须在<em class="mh">跟踪范围内(在JSX元素中用括号括起来，或者在效果和备忘录API中使用)</em>，如下所示:</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="ad24" class="mn ll in mj b be mo mp l mq mr">createEffect(() =&gt; {<br/>    console.log(count()); // This will run everytime count is updated<br/>  })</span></pre><p id="bc22" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mh">创建信号时完成样本代码</em> </strong></p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="17dd" class="mn ll in mj b be mo mp l mq mr">import { render } from "solid-js/web";<br/>import { createSignal } from "solid-js";<br/><br/>function Counter() {<br/>  const [count, setCount] = createSignal(1);<br/><br/>  setInterval(() =&gt; setCount(count() + 1), 1000);<br/><br/>  return &lt;div&gt;Count: {count()}&lt;/div&gt;;<br/>}<br/><br/>render(() =&gt; &lt;Counter /&gt;, document.getElementById('app'));</span></pre><h2 id="7597" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated">效果</h2><p id="8b86" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">像ReactJS中的<em class="mh"> useEffect </em>一样，效果是包装我们信号的getter函数的函数，并且每当依赖信号的值改变时重新执行。这对于创建副作用很有用，比如渲染。</p><p id="2561" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">可以通过从<code class="fe ne nf ng mj b">solid-js</code>导入<code class="fe ne nf ng mj b">createEffect</code>并为其提供一个函数来创建一个效果。效果<strong class="kq io">自动</strong>订阅功能执行期间读取的任何信号，并在任何信号发生变化时重新运行。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="eef0" class="mn ll in mj b be mo mp l mq mr">createEffect(() =&gt; console.log("The latest count is", count()));</span></pre><p id="9f56" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用上面的代码，我们创建了一个<em class="mh">效果</em>，每当<code class="fe ne nf ng mj b">count</code>改变时，它就会重新运行。</p><p id="e772" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与React不同，您不需要指定效果的从属对象。Solid JS自动检测效果中直接或间接使用的每个<strong class="kq io">信号</strong>，并为效果订阅信号更新。</p><p id="109f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mh">注:</em> </strong> <em class="mh">你可以想象JSX的每一个表情都自动被一个效果包围，每当它的依赖信号发生变化时，这个效果就会重新执行。这就是为什么JSX也是一个</em> <strong class="kq io"> <em class="mh">可追踪范围</em> </strong> <em class="mh">。</em></p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="22d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mh">📝我再提醒你一下:</em> </strong> <em class="mh">当你在JSX访问一个</em> <strong class="kq io"> <em class="mh">信号</em> </strong> <em class="mh">时，它会自动更新视图当那个</em> <strong class="kq io"> <em class="mh">信号</em> </strong> <em class="mh">发生变化时。但是组件函数本身只执行一次。</em></p><h2 id="1f76" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated">衍生信号</h2><p id="cb55" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">通过将信号包装在函数中，我们可以创建依赖于信号的新表达式。访问信号的函数实际上也是一个信号:当其包装的信号改变时，它将依次更新其读取器。我的意思是:</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="778e" class="mn ll in mj b be mo mp l mq mr">const doubleCount = () =&gt; count() * 2; <br/>// doubleCount is a derived signal</span></pre><p id="5402" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们可以像JSX中的信号一样呼叫<code class="fe ne nf ng mj b">doubleCount</code>:</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="85ee" class="mn ll in mj b be mo mp l mq mr">return &lt;div&gt;Count: {doubleCount()}&lt;/div&gt;;</span></pre><p id="5a08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们称这些函数为<strong class="kq io"> <em class="mh">衍生信号</em> </strong>，因为它们从其访问的信号中获得反应。它们本身并不存储一个值(如果你创建了一个派生信号，但从未调用它，它将像任何未使用的函数一样从Solid的输出中被剥离)，但它们将更新任何依赖于它们的效果，并且它们将触发一个重新渲染<strong class="kq io">(不是字面上的，固体方式)</strong>(如果包含在视图中)。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h2 id="dd63" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated">备忘录</h2><p id="2ff9" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">备忘录是缓存的派生值。它们共享信号(<em class="mh">只读</em>)和效果(<em class="mh">观察者</em>)的属性。它们跟踪自己的相关信号，只有当这些信号发生变化时才重新执行，它们本身就是可跟踪的信号。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="3ffc" class="mn ll in mj b be mo mp l mq mr">const fullName = createMemo(() =&gt; `${firstName()} ${lastName()}`);</span></pre><p id="6ebd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以使用备忘录来评估一个函数并存储结果，直到它的依赖关系改变。这对于缓存具有其他依赖关系的效果的计算和减轻代价高昂的操作(如DOM节点创建)所需的工作非常有用。</p><p id="80e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">创建备忘录就像传递一个从<code class="fe ne nf ng mj b">solid-js</code>导入的函数给<code class="fe ne nf ng mj b">createMemo</code>一样简单。</p><p id="f2de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的例子中，重新计算<strong class="kq io"> <em class="mh"> fib() </em> </strong>的值随着每次点击变得越来越昂贵，因为它在JSX中被调用<strong class="kq io"> 50次</strong>。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="ac82" class="mn ll in mj b be mo mp l mq mr">import { render } from 'solid-js/web';<br/>import { createSignal, createMemo } from 'solid-js';<br/><br/>function fibonacci(num) {<br/>  if (num &lt;= 1) return 1;<br/><br/>  return fibonacci(num - 1) + fibonacci(num - 2);<br/>}<br/><br/>function Counter() {<br/>  const [count, setCount] = createSignal(10);<br/>  const fib = () =&gt; fibonacci(count());<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; setCount(count() + 1)}&gt;Count: {count()}&lt;/button&gt;<br/><br/>      &lt;div&gt;1. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;2. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;3. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;4. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;5. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;6. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;7. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;8. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;9. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>      &lt;div&gt;10. {fib()} {fib()} {fib()} {fib()} {fib()}&lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>render(() =&gt; &lt;Counter /&gt;, document.getElementById('app'))</span></pre><p id="dc74" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们将<strong class="kq io"> fib(count()) </strong>包装在<code class="fe ne nf ng mj b">createMemo</code>中，它每次点击只重新计算一次，例如当<strong class="kq io"> count() </strong>为10时，<strong class="kq io"> fib(count()) </strong>即<strong class="kq io"> fib(10) </strong>将在第一次调用时缓存其值，任何其他对<strong class="kq io"> fib(10) </strong>的调用将再次使用已经计算的值，而不是再次重新计算。在上面的例子中，createMemo 为我们节省了49次重新计算。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="1d69" class="mn ll in mj b be mo mp l mq mr">const fib = createMemo(() =&gt; {<br/>    // The console.log is added to help monitor how many times the function is called<br/>    console.log('Calculating Fibonacci');<br/>    return fibonacci(count());<br/>  });</span></pre><h1 id="2148" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">控制固体中的流动</h1><p id="a3a5" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">如果，我之前没有声明，SOLID不像React一样使用虚拟DOM。因此，天真地使用像<code class="fe ne nf ng mj b">Array.prototype.map</code>这样的东西会浪费地在每次更新时重新创建所有的DOM节点。对于一个简单的文本节点，也许这不是问题，但是对于一个越来越大的组件，这是一个问题。</p><p id="0ad9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Solid附带了用于包装组件的模板助手，以便于控制流，如条件渲染、循环等。</p><h2 id="75e3" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated"><code class="fe ne nf ng mj b"><strong class="ak">&lt;Show /&gt; Component</strong></code></h2><p id="df09" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><strong class="kq io">处理三元组(</strong> <code class="fe ne nf ng mj b"><strong class="kq io">a ? b : c</strong></code> <strong class="kq io">)和布尔表达式(</strong> <code class="fe ne nf ng mj b"><strong class="kq io">a &amp;&amp; b</strong></code> <strong class="kq io"> ) </strong>，实为我们提供了<code class="fe ne nf ng mj b"><strong class="kq io">&lt;Show /&gt;</strong></code>分量。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="634c" class="mn ll in mj b be mo mp l mq mr">&lt;Show<br/>  when={loggedIn()}<br/>  fallback={&lt;button onClick={toggle}&gt;Log in&lt;/button&gt;}<br/>&gt;<br/>  &lt;button onClick={toggle}&gt;Log out&lt;/button&gt;<br/>&lt;/Show&gt;</span></pre><p id="6671" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ne nf ng mj b"><strong class="kq io">fallback</strong></code>道具充当<code class="fe ne nf ng mj b">else</code>并在<code class="fe ne nf ng mj b"><strong class="kq io">when</strong></code>中的条件不正确时显示。</p><h2 id="16c0" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated"><code class="fe ne nf ng mj b"><strong class="ak">&lt;For /&gt; </strong></code>组件</h2><p id="be9b" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><strong class="kq io">为了处理对象数组的循环，</strong> SOLID为我们提供了<code class="fe ne nf ng mj b"><strong class="kq io">&lt;For /&gt;</strong></code>组件。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="91ea" class="mn ll in mj b be mo mp l mq mr">&lt;For each={cats()}&gt;<br/>  {(cat, i) =&gt;<br/>  &lt;li&gt;<br/>    &lt;a target="_blank" href={`https://www.youtube.com/watch?v=${cat.id}`}&gt;<br/>      {i() + 1}: {cat.name}<br/>    &lt;/a&gt;<br/>  &lt;/li&gt;<br/>  }<br/>&lt;/For&gt;<br/><br/>// Note how we referenced i as i(), its a signal<br/>// The array element is not a signal</span></pre><p id="5add" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ne nf ng mj b">&lt;For&gt;</code>组件上有一个道具:<code class="fe ne nf ng mj b">each</code>，在这里传递数组进行循环。</p><p id="438c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，不是直接在<code class="fe ne nf ng mj b"><strong class="kq io">&lt;For&gt;</strong></code>和<code class="fe ne nf ng mj b"><strong class="kq io">&lt;/For&gt;</strong></code>之间编写节点，而是传递一个<strong class="kq io"> <em class="mh">回调</em> </strong> <em class="mh"> </em>，它应该返回一个要呈现的节点..这是一个类似于JavaScript的<code class="fe ne nf ng mj b"><a class="ae nu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#parameters" rel="noopener ugc nofollow" target="_blank">map</a></code> <a class="ae nu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#parameters" rel="noopener ugc nofollow" target="_blank">回调</a>的函数。</p><p id="c25b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注意</strong>该指数是一个<em class="mh">信号</em>，不是一个常数。这是因为<code class="fe ne nf ng mj b"><strong class="kq io">&lt;For&gt;</strong></code>是<em class="mh">“由引用键控”</em>:它呈现的每个节点都耦合到数组中的一个元素。换句话说，如果一个元素改变了在数组中的位置，而不是被销毁和重新创建，那么相应的节点也会移动，其索引也会改变。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="7d24" class="mn ll in mj b be mo mp l mq mr">import { render } from 'solid-js/web';<br/>import { createSignal, For } from 'solid-js';<br/><br/>function App() {<br/>  const [cats, setCats] = createSignal([<br/>    { id: 'z_AbfPXTKms', name: 'Maru' },<br/>    { id: 'J---aiyznGQ', name: 'Keyboard Cat' },<br/>    { id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' }<br/>  ]);<br/>  <br/>  return (<br/>    &lt;ul&gt;<br/>      &lt;For each={cats()}&gt;{(cat, i) =&gt;<br/>        &lt;li&gt;<br/>          &lt;a target="_blank" href={`https://www.youtube.com/watch?v=${cat.id}`}&gt;<br/>            {i() + 1}: {cat.name}<br/>          &lt;/a&gt;<br/>        &lt;/li&gt;<br/>      }&lt;/For&gt;<br/>    &lt;/ul&gt;<br/>  );<br/>}<br/><br/>render(() =&gt; &lt;App /&gt;, document.getElementById('app'))</span></pre><p id="3cbc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">🗒 <strong class="kq io"> <em class="mh">注:</em> </strong> <em class="mh">如果你的阵是静态的，用阵图也不错。</em></p><h2 id="f2e0" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated"><code class="fe ne nf ng mj b"><strong class="ak">&lt;Index&gt;</strong></code>组件<strong class="ak">组件</strong></h2><p id="74fd" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">与<code class="fe ne nf ng mj b">&lt;For&gt;</code>有相似的签名，e<em class="mh">x除了这次</em> <strong class="kq io"> <em class="mh">项</em> </strong> <em class="mh">是信号，索引是固定的</em>。每个渲染节点对应于数组中的一个点。每当该点的数据发生变化，信号就会更新。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="a9cb" class="mn ll in mj b be mo mp l mq mr">&lt;Index each={cats()}&gt;{(cat, i) =&gt;<br/>  &lt;li&gt;<br/>    &lt;a target="_blank" href={`https://www.youtube.com/watch?v=${cat().id}`}&gt;<br/>      {i + 1}: {cat().name}<br/>    &lt;/a&gt;<br/>  &lt;/li&gt;<br/>}&lt;/Index&gt;<br/><br/>// Note how we referenced cat as cat(), its a signal<br/>// i is not a signal here</span></pre><p id="f4b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ne nf ng mj b">&lt;For&gt;</code>和<code class="fe ne nf ng mj b">&lt;Index&gt;</code>每个渲染节点都带有一个数组元素，所以当一个数组元素改变时，只有对应的节点会重新渲染。</p><p id="9e98" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">不同之处在于当数组元素改变时DOM如何更新。</strong></p><p id="8c5c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ne nf ng mj b">&lt;Index&gt;</code>会按索引做这个<em class="mh">:每个节点对应数组中的一个索引；<code class="fe ne nf ng mj b">&lt;For&gt;</code>会这样做<em class="mh">按值</em>:每个节点对应数组中的一段数据。这就是为什么在回调中，<code class="fe ne nf ng mj b">&lt;Index&gt;</code>给你一个项目的信号:每个项目的索引被认为是固定的，但是在那个索引上的数据可以改变。另一方面，<code class="fe ne nf ng mj b">&lt;For&gt;</code>为索引提供了一个信号:该项的内容被认为是固定的，但是如果数组中的元素被移动，它可以移动。</em></p><p id="985c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ne nf ng mj b"><em class="mh">&lt;For&gt;</em></code> <em class="mh">关心你数组中的每一条数据，并且那些数据的位置可以改变；</em> <code class="fe ne nf ng mj b"><em class="mh">&lt;Index&gt;</em></code> <em class="mh">关心你数组中的每个索引，每个索引处的内容可以变化。</em></p><h2 id="9cbf" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated"><code class="fe ne nf ng mj b"><strong class="ak">&lt;Switch&gt;</strong></code> <strong class="ak">和</strong> <code class="fe ne nf ng mj b"><strong class="ak">&lt;Match&gt;</strong></code> <strong class="ak">分量</strong></h2><p id="a353" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们经常处理具有多个独立结果的条件句，模仿Javascript的<code class="fe ne nf ng mj b">switch</code> / <code class="fe ne nf ng mj b">case</code>的<code class="fe ne nf ng mj b">&lt;Switch&gt;</code>和<code class="fe ne nf ng mj b">&lt;Match&gt;</code>组件可以在这种情况下派上用场。</p><p id="43f0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们用<code class="fe ne nf ng mj b">&lt;Switch&gt;</code>替换这个<code class="fe ne nf ng mj b">&lt;Show&gt;</code>组件</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="25bc" class="mn ll in mj b be mo mp l mq mr">&lt;Show<br/>      when={x() &gt; 10}<br/>      fallback={<br/>        &lt;Show<br/>          when={5 &gt; x()}<br/>          fallback={&lt;p&gt;{x()} is between 5 and 10&lt;/p&gt;}<br/>        &gt;<br/>          &lt;p&gt;{x()} is less than 5&lt;/p&gt;<br/>        &lt;/Show&gt;<br/>      }<br/>    &gt;<br/>      &lt;p&gt;{x()} is greater than 10&lt;/p&gt;<br/>&lt;/Show&gt;<br/><br/>// Feels like callback hell 😃</span></pre><p id="6e51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用<code class="fe ne nf ng mj b">&lt;Switch&gt;</code>的更优雅的解决方案</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="9860" class="mn ll in mj b be mo mp l mq mr">&lt;Switch fallback={&lt;p&gt;{x()} is between 5 and 10&lt;/p&gt;}&gt;<br/>  &lt;Match when={x() &gt; 10}&gt;<br/>    &lt;p&gt;{x()} is greater than 10&lt;/p&gt;<br/>  &lt;/Match&gt;<br/>  &lt;Match when={5 &gt; x()}&gt;<br/>    &lt;p&gt;{x()} is less than 5&lt;/p&gt;<br/>  &lt;/Match&gt;<br/>&lt;/Switch&gt;</span></pre><h2 id="ad20" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated"><code class="fe ne nf ng mj b"><strong class="ak">&lt;Dynamic&gt;</strong></code> <strong class="ak">组件</strong></h2><p id="abaf" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这在呈现表单数据时非常有用。它允许您传递一个本地元素的字符串或一个组件函数，并且它将使用提供的其他属性来呈现它。</p><p id="d16f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面用样例代码来理解一下吧；</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="dc4e" class="mn ll in mj b be mo mp l mq mr">import { render, Dynamic } from "solid-js/web";<br/>import { createSignal, Switch, Match, For } from "solid-js";<br/><br/>const RedThing = () =&gt; &lt;strong style="color: red"&gt;Red Thing&lt;/strong&gt;;<br/>const GreenThing = () =&gt; &lt;strong style="color: green"&gt;Green Thing&lt;/strong&gt;;<br/>const BlueThing = () =&gt; &lt;strong style="color: blue"&gt;Blue Thing&lt;/strong&gt;;<br/><br/>const options = {<br/>  red: RedThing,<br/>  green: GreenThing,<br/>  blue: BlueThing<br/>}<br/><br/>function App() {<br/>  const [selected, setSelected] = createSignal("red");<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;select value={selected()} onInput={e =&gt; setSelected(e.currentTarget.value)}&gt;<br/>        &lt;For each={Object.keys(options)}&gt;{<br/>          color =&gt; &lt;option value={color}&gt;{color}&lt;/option&gt;<br/>        }&lt;/For&gt;<br/>      &lt;/select&gt;<br/>      {// To be replaced with Dynamic tag}<br/>      &lt;Switch fallback={&lt;BlueThing /&gt;}&gt;<br/>        &lt;Match when={selected() === "red"} &gt;&lt;RedThing /&gt;&lt;/Match&gt;<br/>        &lt;Match when={selected() === "green"}&gt;&lt;GreenThing /&gt;&lt;/Match&gt;<br/>      &lt;/Switch&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>render(() =&gt; &lt;App /&gt;, document.getElementById("app"));</span></pre><p id="d5a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这段代码运行良好。但是使用<code class="fe ne nf ng mj b">&lt;Dynamic&gt;</code>组件可以使其更加紧凑。<strong class="kq io">请注意上面代码中的选项对象。</strong></p><p id="b903" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，我们可以替换<code class="fe ne nf ng mj b">&lt;Switch&gt;</code>语句:</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="397a" class="mn ll in mj b be mo mp l mq mr">&lt;Switch fallback={&lt;BlueThing /&gt;}&gt;<br/>  &lt;Match when={selected() === 'red'}&gt;&lt;RedThing /&gt;&lt;/Match&gt;<br/>  &lt;Match when={selected() === 'green'}&gt;&lt;GreenThing /&gt;&lt;/Match&gt;<br/>&lt;/Switch&gt;</span></pre><p id="2242" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用:</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="1f58" class="mn ll in mj b be mo mp l mq mr">&lt;Dynamic component={options[selected()]} /&gt;</span></pre><h2 id="f412" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated"><code class="fe ne nf ng mj b"><strong class="ak">&lt;Portal&gt;</strong></code>组件<strong class="ak">组件</strong></h2><p id="1531" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">Solid有一个<code class="fe ne nf ng mj b">&lt;Portal&gt;</code>组件，它的子内容将被插入到您选择的位置。<em class="mh">默认情况下，其元素会呈现在</em><code class="fe ne nf ng mj b"><em class="mh">&lt;div&gt;</em></code><em class="mh"/><code class="fe ne nf ng mj b"><em class="mh">document.body</em></code><em class="mh">中。</em></p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="603c" class="mn ll in mj b be mo mp l mq mr">&lt;Portal&gt;<br/>  &lt;div class="popup"&gt;<br/>    &lt;h1&gt;Popup&lt;/h1&gt;<br/>    &lt;p&gt;Some text you might need for something or other.&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/Portal&gt;</span></pre><p id="585d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ne nf ng mj b">useShadow</code>将元素放在阴影根中进行样式隔离，如果插入到SVG元素中则需要<code class="fe ne nf ng mj b">isSVG</code>，这样就不会插入<code class="fe ne nf ng mj b">&lt;div&gt;</code>。</p><h2 id="11f3" class="ms ll in bd lm mt mu dn lq mv mw dp lu kx mx my lw lb mz na ly lf nb nc ma nd bi translated"><errorboundary>组件</errorboundary></h2><p id="eddd" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">源于UI的JavaScript错误不应该破坏整个应用程序。错误边界是捕捉子组件树中任何位置的JavaScript错误、记录这些错误并显示一个后备UI而不是崩溃的组件树的组件。</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="bedf" class="mn ll in mj b be mo mp l mq mr">&lt;ErrorBoundary fallback={err =&gt; err}&gt;<br/>  &lt;Broken /&gt;<br/>&lt;/ErrorBoundary&gt;</span></pre><p id="a834" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">示例源代码:</p><pre class="kd ke kf kg gt mi mj mk bn ml mm bi"><span id="ac87" class="mn ll in mj b be mo mp l mq mr">import { render } from "solid-js/web";<br/>import { ErrorBoundary } from "solid-js";<br/><br/>const Broken = (props) =&gt; {<br/>  throw new Error("Oh No");<br/>  return &lt;&gt;Never Getting Here&lt;/&gt;<br/>}<br/><br/>function App() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;div&gt;Before&lt;/div&gt;<br/>      &lt;ErrorBoundary fallback={err =&gt; err}&gt;<br/>        &lt;Broken /&gt;<br/>      &lt;/ErrorBoundary&gt;<br/>      &lt;div&gt;After&lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>render(() =&gt; &lt;App /&gt;, document.getElementById("app"));</span></pre></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="c2ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过以上的讨论，我相信你已经可以看到SOLIDJS是多么的可爱和有用。还有更多要谈的，生命周期，绑定，存储，甚至用SOLIDJS读取数据。</p><p id="3942" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一定要拍下这篇文章，关注我的进一步更新。</p><p id="572c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mh">更多内容请看</em><a class="ae nu" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mh">plain English . io</em></strong></a><em class="mh">。报名参加我们的</em> <a class="ae nu" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mh">免费周报</em> </strong> </a> <em class="mh">。关注我们关于</em><a class="ae nu" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mh">Twitter</em></strong></a><a class="ae nu" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mh">LinkedIn</em></strong></a><em class="mh"/><a class="ae nu" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mh">YouTube</em></strong></a><em class="mh"/><a class="ae nu" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mh">不和</em> </strong> </a> <strong class="kq io"> <em class="mh">。</em>T49】</strong></p><p id="9d13" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mh">对缩放您的软件启动感兴趣</em> </strong> <em class="mh">？检查</em> <a class="ae nu" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mh">电路</em> </strong> </a> <em class="mh">。</em></p></div></div>    
</body>
</html>