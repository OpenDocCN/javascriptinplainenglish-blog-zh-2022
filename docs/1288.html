<html>
<head>
<title>How to Make a Typed-Text React Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作类型化文本反应组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-a-typed-text-react-component-f92a035d194?source=collection_archive---------10-----------------------#2022-03-14">https://javascript.plainenglish.io/how-to-make-a-typed-text-react-component-f92a035d194?source=collection_archive---------10-----------------------#2022-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4915921b0f10396bca04e71cf4266eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DAaGxdzNZUHoWUmQ"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@bernardhermant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bernard Hermant</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5e4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最近构建了一个“输入文本”React组件，用于我的<a class="ae jz" href="http://wilstaley.com" rel="noopener ugc nofollow" target="_blank">网站</a>。该组件将获取任何文本，并使其看起来像正在被键入一样。</p><p id="ff9a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，我想介绍一下我是如何构建这个组件的，因为我认为这是一个很好的练习，可以帮助您构建反应技能。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="6095" class="lf lg in bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">这个计划</h2><p id="b015" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">有很多方法可以解决这个问题！让我概述一下我想如何用一个定制的React组件来完成这个任务…</p><p id="e7eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个“TypedText”组件将通过children prop接收一些文本。它将负责简单的文本动画，没有花哨的样式或类似的东西。然后，任何我们希望“键入”的文本，我们都可以放在<code class="fe md me mf mg b">&lt;TypedText&gt;</code>组件中。我们将通过最初呈现一个空字符串来执行动画，然后按照设定的时间间隔追加每个字符，一次一个。我们将一直这样做，直到完整的字符串被呈现出来，并且看起来已经被输入到屏幕上！下面是最终的结果:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/2706785e22f75dcafe61cea5e792dd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/1*BmktHPdgtyI49Pxy6IlUnw.gif"/></div></figure><p id="bc26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还会添加一个“延迟”道具，这样你就可以自定义显示角色之间的延迟时间。</p><h2 id="fa7c" class="lf lg in bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">让我们建造它！</h2><p id="7875" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">让我们从创建一个基本组件开始:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/6ec23a00a41f286ff21233b83e53242d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzoYvU-P-bVrhdZorttA9w.png"/></div></div></figure><p id="3645" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有这些都是返回通过儿童道具提供的文本……目前看来毫无意义。现在让我们添加一些状态来跟踪有多少字母被泄露:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/cafb77e81aa02d13801cfc246a30a572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCpToU6u9l7XZT5gT-6_vw.png"/></div></div></figure><p id="89dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们将<code class="fe md me mf mg b">revealedLetters</code>状态初始化为0，因为我们希望从没有字母显示开始。我们将这个状态与<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring" rel="noopener ugc nofollow" target="_blank"> substring </a>方法一起使用，只返回通过子属性传递给这个组件的字母的子集。</p><p id="e42f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">substring方法的作用与您想象的完全一样，它返回调用它的原始字符串的子字符串。例如:</p><p id="4371" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">'cowboy'.substring(0, 3) === 'cow'</code></p><p id="ab02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的，我们有办法返回所提供的字母的特定子集。现在，我们需要一种方法来增加某个时间间隔内显示字母的数量。让我们添加一些东西来做到这一点:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/4b74eba081039194adb9ec964d0392f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xk8kDWmjpH1E4HmHhejKA.png"/></div></div></figure><p id="8408" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们调用<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/API/setInterval" rel="noopener ugc nofollow" target="_blank"> setInterval </a>来增加在设定的时间间隔内显示的字母的数量。<code class="fe md me mf mg b">setInterval</code>方法将函数和延迟作为参数。它将连续调用提供的函数，每次调用之间有固定的时间延迟。查看这段特定的代码，<code class="fe md me mf mg b">setInterval(() =&gt; setRevealedLetters(l =&gt; l + 1), 110)</code>，我们提供了一个函数，它将每110毫秒递增一次revealedLetters状态。</p><p id="41a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们知道了setInterval是如何工作的，我们需要一些方法来停止它！我们不希望它永远持续运行我们的功能！事实上，如果我们只是调用<code class="fe md me mf mg b">setInterval()</code>而不告诉它停止增加我们的状态，这将是一个等待发生的错误。为什么？因为当我们的TypedText组件卸载时，setInterval会继续尝试更新不再在dom中的组件的状态。如果您曾经尝试更新未安装组件的状态，您可能会在控制台中看到类似这样的弹出错误:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/3d43e17287b6b438175decf1446b473a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5UNt72U8QdSAK1ycJXbQg.png"/></div></div></figure><p id="5007" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意错误消息末尾的内容:<em class="mq">“要解决这个问题，请取消useEffect清理函数中的所有订阅和异步任务”</em>。</p><p id="6a81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">^这就是为什么我们在setInterval之外增加了useEffect。如果从useEffect钩子中返回一个函数，React将在组件卸载时执行这个函数。这就是所谓的“清理”功能，可用于取消组件卸载后您不希望发生的任务。清理功能可以用于很多事情，比如取消网络请求，但是在我们的例子中，我们将使用它来清理我们的时间间隔。</p><p id="bc87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能注意到，当我们调用<code class="fe md me mf mg b">setInterval()</code>时，我们将其返回值赋给一个叫做“interval”的常数。调用<code class="fe md me mf mg b">setInterval()</code>的返回值是一个id，用来标识刚刚创建的区间。我们需要存储一个对该id的引用，这样我们就可以通过将该id传递给<code class="fe md me mf mg b">clearInterval()</code>来取消间隔。</p><h1 id="371c" class="mr lg in bd lh ms mt mu lk mv mw mx ln my mz na lq nb nc nd lt ne nf ng lw nh bi translated">全部完成！对吗？</h1><p id="67d8" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">不完全是！</p><p id="94f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然我们的TypedText组件完全可以工作并且看起来不错，但是它并没有经过优化。要看到这一点，尝试在组件的顶层添加一个<code class="fe md me mf mg b">console.log</code>,如下所示:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/6c1260536fd4e6fc5c81dc7c496cfa2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ru-9-fTviWWiGyFkMoJABw.png"/></div></div></figure><p id="2084" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果打开控制台，您会看到“TypedText rendered！”不断地被打印——组件不必要地重新呈现自己！它为什么这样做？因为，setInterval会不断更新revealedLetters的状态，即使在所有字母都已显示之后。在React中，更新组件的状态会导致组件重新呈现。</p><p id="d72d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦所有的角色都被展示出来，我们真的应该停止我们的幕间休息。我们将这样做:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/213ea75133e6b88f4ab376040c7a0cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0VWyOg5slbbomNNjpBF5w.png"/></div></div></figure><p id="e214" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们添加了另一个useEffect钩子。这个useEffect在其依赖数组中包含了<code class="fe md me mf mg b">revealedLetters</code>，所以每次<code class="fe md me mf mg b">revealedLetters</code>递增时，它都会重新运行这个函数。我们在这里所做的就是检查是否所有的字母都被显示了，如果是，清除我们的间隔。这将防止我们的TypedText组件在所有字母显示后不必要地重新呈现。</p><p id="ffa1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能想知道为什么需要两个独立的使用效果。为什么不直接把返回的“清理”函数放在第一个useEffect中呢？嗯，我还没有告诉你这些清理函数是如何工作的……当组件被卸载时，从useEffect返回的清理函数不仅仅是<em class="mq">调用的</em>。每次效果运行之前都会调用它，以便从上次运行中清理。因此，如果我们试图从第一个useEffect返回我们的cleanup函数，它会在每次显示另一个字母时尝试清除我们的间隔。那可不好。好消息是，在一个React组件中有多个useEffect完全没问题😀</p><h2 id="3648" class="lf lg in bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">奖励积分</h2><p id="fd73" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">现在我们的组件性能更高了。让我们再添加一些小东西来使这个组件<strong class="kc io"> <em class="mq">更上一层楼</em> </strong>！</p><p id="bc1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们添加我在开始时提到可选延迟属性:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/88b97b428a68b2f33786a27efe4c7371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nhkPrj-eRA3oqUWLOGmsg.png"/></div></div></figure><p id="228d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，我们添加了一个简单的“延迟”道具。我们给它一个默认值110，这样如果用户没有指定这个属性，它将有一个合理的默认值。然后我们简单地用延迟变量替换<code class="fe md me mf mg b">setInterval()</code>中硬编码的110毫秒。很简单。</p><p id="52e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，让我们记住这个组件:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/ada439792abfdc89f11a09bd2d8ce30b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZ819Z2D4AEcPdxWHpVaeA.png"/></div></div></figure><p id="deb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在这里所做的就是从react导入<code class="fe md me mf mg b">memo</code>,并将默认导出包装在这个高阶组件中。我们为什么要这么做？我认为React的<a class="ae jz" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">文档</a>最好地解释了这一点:</p><blockquote class="ni nj nk"><p id="0e7b" class="ka kb mq kc b kd ke kf kg kh ki kj kk nl km kn ko nm kq kr ks nn ku kv kw kx ig bi translated">"如果您的组件在给定相同的属性的情况下呈现相同的结果，您可以将它包装在对React.memo的调用中，在某些情况下通过记忆结果来提高性能。这意味着React将跳过组件的渲染，并重用最后一次渲染的结果… React.memo只检查属性更改。如果React.memo中包装的函数组件在其实现中有一个useState、useReducer或useContext挂钩，当状态或上下文发生变化时，它仍会重新呈现。</p></blockquote><p id="b9b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你知道了！一个优化的、灵活的、令人敬畏的React组件，可以用于任何文本！</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="898a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这有助于您通过构建这个基本组件学到一些东西。如果你喜欢这篇文章，并希望看到更多类似的文章，请考虑成为https://www.patreon.com/wilstaley的顾客！</p><h2 id="626d" class="lf lg in bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">进一步阅读</h2><div class="no np gp gr nq nr"><a href="https://bit.cloud/blog/design-tokens-in-components-with-react-and-bit-l28qlxq6" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">用React和Bit设计组件中的令牌</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">现场演示更好。在我们深入细节之前，让我们看一下使用Bit设计令牌如何帮助我们构建…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">比特云</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jt nr"/></div></div></a></div><p id="a4fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">plain English . io</em></strong></a><em class="mq">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mq">免费周报</em> </strong> </a> <em class="mq">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">LinkedIn</em></strong></a><strong class="kc io"><em class="mq"/></strong><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">YouTube</em></strong></a><strong class="kc io"><em class="mq">，以及</em></strong><em class="mq"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">不和</em> </strong> </a>  <em class="mq">对成长黑客感兴趣？检查</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mq">电路</em> </strong> </a> <strong class="kc io"> <em class="mq">。</em> </strong></p></div></div>    
</body>
</html>