<html>
<head>
<title>Understand the Pattern of Breadth First Search (BFS)/Level Order Traversal in a Binary Tree 🌳</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解二叉树中广度优先搜索(BFS)/层次顺序遍历的模式🌳</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-pattern-of-bfs-level-order-traversal-in-binary-tree-d675bcbe44a9?source=collection_archive---------2-----------------------#2022-08-21">https://javascript.plainenglish.io/understand-pattern-of-bfs-level-order-traversal-in-binary-tree-d675bcbe44a9?source=collection_archive---------2-----------------------#2022-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b85e8e86188bae2762a612feca864347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgKm6oIyw-Yt0c1I9uXy6w.png"/></div></div></figure><p id="ad1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇博客中，我们将讨论<strong class="jx io">模式</strong><strong class="jx io"/><strong class="jx io">广度优先搜索(BFS)二叉树。</strong></p><h2 id="6a6a" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak"> BFS遍历也称为层次顺序遍历</strong></h2><p id="78ef" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">伙计，好吧！👍</p><h2 id="f5cc" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">我的动力是什么？我为什么要研究这种层次顺序遍历？</strong></h2><p id="f43d" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><strong class="jx io">简答:</strong>很多高水平的面试问题和LeetCode中硬水平的问题，如果理解了这个模式就可以解决了。</p><h2 id="e04b" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">我们先来了解一下什么是广度优先搜索</h2><p id="7e8f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们通常会读到关于图的BFS遍历。如果我们仔细观察，<strong class="jx io">二叉树</strong>也是一个图，其中每个节点最多有两(2)个子节点。</p><p id="95ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从上图可以明显看出每一级的元素。</p><p id="eac8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更加清晰，我将逐层打印值。</p><p id="cce0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">0-34级</strong></p><p id="1f61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">一级— 20，56 </strong></p><p id="ce19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">2级— 10、22、45、59 </strong></p><p id="d54d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第三级——9、14、21、25、40、49、58、89级</p><p id="98f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注</strong>:如果你仔细注意，每一层的元素个数都是上一层的两倍(满二叉树规则)。</p><p id="832b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，足够的理论，让我们进入代码实现。</p><p id="07b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下面的代码中，我假设已经创建了树，并且为我们提供了树的根。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3fc4" class="kt ku in lw b gy ma mb l mc md">void levelOrderTraversalBinaryTree(TreeNode* root){<br/>        <br/>        if(!root) return; // return if there is no element in Binary   tree   <br/>        <br/>        queue&lt;TreeNode*&gt; q;<br/>        q.push(root);<br/>        q.push(NULL); // NULL acts a separator between levels<br/>        <br/>        // at last queue is left with one element which is NULL<br/>        while(!(q.size()==1&amp;&amp;q.front()==NULL)){<br/>            TreeNode* node = q.front();<br/>            q.pop();<br/>            <br/>            if(node){<br/>                cout&lt;&lt;node-&gt;val&lt;&lt;" ";<br/>                if(node-&gt;left) q.push(node-&gt;left);<br/>                if(node-&gt;right) q.push(node-&gt;right);<br/>            }else{<br/>                //if we encounter NULL in queue<br/>                //it means we are going to next level, hence print new line here<br/>                cout&lt;&lt;"\n";<br/>                q.push(NULL);<br/>            }            <br/>        }        <br/>    }</span></pre><p id="2b6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，我们使用了一个队列来存储元素。</p><p id="d2a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最初，我将根元素放入队列，之后为Null。Null只是用来区分两个级别。</p><p id="bcb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们开始循环并从队列中移除前面的元素。移除前面的元素后，我们将移除元素的子元素放入队列中。</p><p id="9c18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们只剩下空元素并退出循环。</p><p id="051b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想看到代码的流程，请看下图:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/e254e77c9cedb3761fc1b573e1ac981c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzIDCQAn9QjqGQLe-RcckA.png"/></div></div></figure><p id="4878" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，没关系。</p><p id="4d66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我正在添加一个可以用上述模式解决的问题列表。</p><ol class=""><li id="5264" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated"><a class="ae mo" href="https://leetcode.com/problems/binary-tree-level-order-traversal/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/二叉树层次顺序遍历/ </a></li></ol></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="3628" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mw">更多内容请看</em><a class="ae mo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mw">plain English . io</em></strong></a><em class="mw">。报名参加我们的</em> <a class="ae mo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em><a class="ae mo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mw">Twitter</em></strong></a><a class="ae mo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mw">LinkedIn</em></strong></a><em class="mw"/><a class="ae mo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mw">YouTube</em></strong></a><em class="mw"/><a class="ae mo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mw">不和</em> </strong> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>