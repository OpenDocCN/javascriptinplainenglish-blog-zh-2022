<html>
<head>
<title>7 Common Bugs in TypeScript (and JavaScript)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript(和JavaScript)中的7个常见错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-common-bugs-in-typescript-and-javascript-5adbad7df5fb?source=collection_archive---------3-----------------------#2022-05-29">https://javascript.plainenglish.io/7-common-bugs-in-typescript-and-javascript-5adbad7df5fb?source=collection_archive---------3-----------------------#2022-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af91" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何修复它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/17b7a007c1e0f876432ec6d4b1ec9350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QQhry4O1iOy3V3L2"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是什么让你成为一名优秀的TypeScript/JavaScript开发人员？可能是因为你创造了一些很酷的项目，或者你在这个行业有多年的经验？不完全是。</p><p id="90e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的代码应该总是正确运行。优秀的开发人员会使用ESLint这样的软件来确保他们使用最好的标准进行编码，并检查潜在的致命错误。外面有一个很好的软件叫<a class="ae kv" href="https://sonarcloud.io/" rel="noopener ugc nofollow" target="_blank"> SonarCloud </a>(没有任何隶属关系，我自己就用)。有了良好的配置，SonarCloud和ESLint可以显著提高代码的质量，还能捕捉到您可能不知道的错误。</p><p id="35b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我明白了，不是每个人都研究JavaScript文档中的每一个小函数、API、类等等。但是知道一些你在编写代码时可能犯的无辜的错误是有好处的。</p><h1 id="2bef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1)排序数组</h1><p id="a81c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><em class="mp">使用</em> <code class="fe mq mr ms mt b"><em class="mp">Array.prototype.sort()</em></code>时应提供比较功能</p><h2 id="a93c" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">问题是</h2><p id="4244" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JS/TS中的数组排序看起来非常简单；使用<code class="fe mq mr ms mt b">Array.sort()</code>方法。但是有一个问题:试着运行下面的代码:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="ef62" class="mu lt iq mt b gy nk nl l nm nn">const arr = [1, 3, 20, 30];<br/>arr.sort();<br/>console.log(arr);</span></pre><p id="df74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能希望sort方法按照升序对数字进行排序，将所有元素保持在相同的位置。相反，您会注意到元素按以下顺序排序:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="62f1" class="mu lt iq mt b gy nk nl l nm nn">[1, 20, 3, 30]</span></pre><p id="766b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这显然没有正确排序。JavaScript实际上将数字转换成字符串，然后按字母顺序对元素进行排序。JS数组排序方法总是通过<code class="fe mq mr ms mt b">string</code>进行排序。也就是说，只有在不提供比较函数的情况下。</p><h2 id="39e6" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案</h2><p id="74bf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">传入一个比较函数，并确保没有将值转换为字符串:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="71cb" class="mu lt iq mt b gy nk nl l nm nn">const array = /* some elements */<br/>array.sort((a, b) =&gt; a - b);</span></pre><h1 id="fa47" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2)与南京相比</h1><p id="4c92" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mq mr ms mt b"><em class="mp">NaN</em></code> <em class="mp">不应用于比较</em></p><h2 id="22b8" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">问题是</h2><p id="01da" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在JS/TS中，有一种特殊的数字数据类型叫做<code class="fe mq mr ms mt b">NaN</code>，它代表“不是一个数字”有时操作可能返回<code class="fe mq mr ms mt b">NaN</code>而不是实际数字。这些操作中最常见的是<code class="fe mq mr ms mt b">parseInt</code>和<code class="fe mq mr ms mt b">parseFloat</code>。</p><p id="1d54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们假设您正试图将一些用户提供的数据从一个<code class="fe mq mr ms mt b">string</code>转换到<code class="fe mq mr ms mt b">number</code>。由于它应该是一个整数，所以你选择使用<code class="fe mq mr ms mt b">parseInt</code>，然后检查确保它的值是一个数字(不等于<code class="fe mq mr ms mt b">NaN</code>)。您需要执行以下操作:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="e047" class="mu lt iq mt b gy nk nl l nm nn">const value = parseInt(/* User data here */);</span><span id="e244" class="mu lt iq mt b gy no nl l nm nn">if (value === NaN) {<br/>    // Do stuff<br/>}</span></pre><p id="7eee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是不对的！即使使用<code class="fe mq mr ms mt b">==</code>，与<code class="fe mq mr ms mt b">NaN</code>比较的结果也总是假的。甚至<code class="fe mq mr ms mt b">NaN</code>也不等于它本身。一般来说，你不应该使用总是以同样方式计算的条件句。</p><p id="f817" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个bug实际上给出了非常可预测的结果，但不是以你期望的方式，因为再一次，与<code class="fe mq mr ms mt b">NaN</code>的比较总是错误的。</p><h2 id="ec4e" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案</h2><p id="cd59" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">ES2015提供了对<code class="fe mq mr ms mt b">Number.isNaN</code>的支持，因此您可以使用该功能来检查数字是否为<code class="fe mq mr ms mt b">NaN</code>:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="9768" class="mu lt iq mt b gy nk nl l nm nn">const value = parseInt(...);</span><span id="a33c" class="mu lt iq mt b gy no nl l nm nn">if (Number.isNaN(value)) {<br/>    // Do stuff<br/>}</span></pre><p id="bee3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的目标是一个非常非常过时的浏览器，那么你应该使用这个符号:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="8be5" class="mu lt iq mt b gy nk nl l nm nn">const value = parseInt(...);</span><span id="b7cc" class="mu lt iq mt b gy no nl l nm nn">if (value !== value) {<br/>    // Do stuff<br/>}</span></pre><p id="9d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能首先认为<code class="fe mq mr ms mt b">value</code>必须始终等于自身，所以这个永远不会计算到<code class="fe mq mr ms mt b">true</code>。<strong class="ky ir">那其实是错的</strong>。由于<code class="fe mq mr ms mt b">NaN</code>永远不能等于<code class="fe mq mr ms mt b">NaN</code>，那么如果<code class="fe mq mr ms mt b">value = NaN</code>那么<code class="fe mq mr ms mt b">value !== value</code>将是<code class="fe mq mr ms mt b">true</code>。</p><h1 id="6bad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Finally块中的跳转语句</h1><p id="6187" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><em class="mp">跳转语句不应出现在</em>的“finally”块中</p><h2 id="7c64" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">问题是</h2><p id="2b59" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JS/TS跳转语句有<code class="fe mq mr ms mt b">return</code>、<code class="fe mq mr ms mt b">throw</code>、<code class="fe mq mr ms mt b">break</code>和<code class="fe mq mr ms mt b">continue</code>。它们被称为跳转语句，因为它们使JS引擎跳转到代码中的另一点:</p><ul class=""><li id="8cfd" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">Return语句跳出函数</li><li id="0602" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">Throw跳出函数并引发错误</li><li id="2d0b" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">Break跳出循环</li><li id="6528" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">继续跳转到循环的开始</li></ul><p id="8e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mq mr ms mt b">finally</code>程序块中使用任何跳转语句都会导致意外行为:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="5bc7" class="mu lt iq mt b gy nk nl l nm nn">function doSomething() {<br/>    try {<br/>        // Some code which might throw an error here<br/>        return 1;<br/>    } catch (err) {<br/>        return 2;<br/>    } finally {<br/>        return 3;<br/>    }<br/>}</span></pre><p id="233a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe mq mr ms mt b">doSomething()</code>时，如果在<code class="fe mq mr ms mt b">try</code>块中没有抛出错误，您会期望返回<code class="fe mq mr ms mt b">1</code>。如果抛出一个错误，那么你会期望返回<code class="fe mq mr ms mt b">2</code>。相反，如果你调用<code class="fe mq mr ms mt b">doSomething()</code>，你会注意到<code class="fe mq mr ms mt b">3</code>是<strong class="ky ir">总是</strong>返回。这是因为如果提供了<code class="fe mq mr ms mt b">finally</code>块，则<strong class="ky ir">总是</strong>运行。</p><h2 id="45ab" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案</h2><p id="1697" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">只需删除<code class="fe mq mr ms mt b">finally</code>语句:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="98be" class="mu lt iq mt b gy nk nl l nm nn">function doSomething() {<br/>    try {<br/>        return 1;<br/>    } catch (err) {<br/>        return 2;<br/>    }<br/>}</span></pre><p id="dfe4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这确实是唯一的解决办法😐。</p><h1 id="5f37" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4)捕捉拒绝承诺</h1><h2 id="2742" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">问题是</h2><p id="be76" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">ES6 (ES2015)为JavaScript引入了大量令人惊叹的功能。有些人仍在学习诀窍。您可能已经在NodeJS中看到错误，未捕获的承诺拒绝将很快导致您的服务器退出，并返回非零退出代码。你自己可能也在浏览器中遇到过一些承诺拒绝错误；它们在控制台窗口中显示为JavaScript错误。</p><p id="b602" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，处理这些错误的最简单的解决方案是用try-catch块包围承诺:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="4d22" class="mu lt iq mt b gy nk nl l nm nn">function doSomething() {<br/>    try {<br/>        axios.get(...).then(response =&gt; {<br/>            // Do something<br/>        });<br/>    } catch (err) {<br/>        // Handle the error<br/>    }<br/>}</span></pre><p id="df7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用常规的try-catch语句处理承诺拒绝是JS/TS中的一个常见错误。当试图在一个新的线程中完成一个操作时，比如发送一个网络请求，使用承诺。承诺有一种独立的方式来处理决心(承诺成功)和拒绝(承诺失败)。</p><h2 id="3402" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案(异步/等待)</h2><p id="a0af" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个问题最简单的解决方案是在包含承诺的函数中添加async修饰符，然后等待承诺:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="62ef" class="mu lt iq mt b gy nk nl l nm nn">async function doSomething() {<br/>    try {<br/>        const response = await axios.get(...);<br/>        // Do some stuff with the HTTP response<br/>    } catch (err) {<br/>        // Handle the error<br/>    }<br/>}</span></pre><p id="acbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用<code class="fe mq mr ms mt b">async</code>定义一个函数/方法可以让JavaScript知道这个函数包含一个异步操作。关键字<code class="fe mq mr ms mt b">await</code>告诉JavaScript停止当前线程，直到承诺解决。async/await解决方案是用于Promise对象的then/catch链接方法的语法糖。</p><h2 id="a1be" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案(然后/抓住)</h2><p id="e689" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">处理承诺解析/拒绝的标准方式是对承诺对象使用<code class="fe mq mr ms mt b">catch</code>函数:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="bff8" class="mu lt iq mt b gy nk nl l nm nn">function doSomething() {<br/>    axios.get(...)<br/>         .then(response =&gt; {<br/>             // Do something<br/>         })<br/>         .catch(err =&gt; {<br/>             // Handle error<br/>         });<br/>}</span></pre><h1 id="8391" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5)删除关键字</h1><p id="6198" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><em class="mp">删除关键字只应用于对象属性。</em></p><h2 id="9d44" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">问题是</h2><p id="fe16" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在JavaScript中，声明一个变量有几个关键字:<code class="fe mq mr ms mt b">var</code>(已经过时了)、<code class="fe mq mr ms mt b">let</code>(在最里面的作用域声明)、和<code class="fe mq mr ms mt b">const</code>(声明一个常量)。有时(这是不好的做法)，您可能会创建一个没有任何声明性关键字的变量:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="3720" class="mu lt iq mt b gy nk nl l nm nn">myVariable = "hi";</span></pre><p id="8c8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管您不应该这样声明变量，但是您可以这样做。当你以这种方式声明一个变量时，你可以使用<code class="fe mq mr ms mt b">delete</code>关键字来移除引用。这是因为<code class="fe mq mr ms mt b">myVariable</code>实际上附加到了<code class="fe mq mr ms mt b">window</code>对象上。如果你使用<code class="fe mq mr ms mt b">var</code>、<code class="fe mq mr ms mt b">let</code>或<code class="fe mq mr ms mt b">const</code>声明一个变量，你不能使用delete关键字(你可以，只是它不起作用)。</p><p id="3d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键字背后的主要意图是能够删除对象属性；例如，下面是你应该如何使用<code class="fe mq mr ms mt b">delete</code>:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="fe78" class="mu lt iq mt b gy nk nl l nm nn">const data = { message: "Hello World", timestamp: Date.now() };</span><span id="ab61" class="mu lt iq mt b gy no nl l nm nn">delete data.message;<br/>console.log(data); // data = { timestamp: ... }</span><span id="2e43" class="mu lt iq mt b gy no nl l nm nn">delete data.timestamp<br/>console.log(data); // data = {}</span></pre><h2 id="1767" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案</h2><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="4d14" class="mu lt iq mt b gy nk nl l nm nn">let myVariable: string | undefined = "Hello";</span><span id="6a14" class="mu lt iq mt b gy no nl l nm nn">// Use the variable here</span><span id="0607" class="mu lt iq mt b gy no nl l nm nn">myVariable = undefined</span></pre><p id="8d35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候你可能想“删除”一个变量。这通常是为了优化内存使用。在这种情况下，您应该将变量分配给<code class="fe mq mr ms mt b">undefined</code>。这将释放与变量相关的内存。</p><p id="375b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在TypeScript中，您必须将变量赋给一个类型联合，将数据类型与<code class="fe mq mr ms mt b">undefined</code>结合起来。</p><h1 id="6805" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6)未过滤的For-In循环</h1><p id="6b88" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><em class="mp"> For-in循环应始终过滤对象属性</em></p><h2 id="7435" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">问题是</h2><p id="2b27" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">任何开发人员都会告诉你for-each循环可以节省大量时间。它们让你不用实例化那个<code class="fe mq mr ms mt b">i</code>变量，并提供了一个简洁的语法框架。JavaScript为迭代可迭代对象中的索引提供了良好的for-in语法。您可能见过类似这样的代码:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="bab1" class="mu lt iq mt b gy nk nl l nm nn">const array = [5, 6, 7, 8];<br/>const obj = { name: "Bob", organization: "The Soggy Waffle" };</span><span id="6b81" class="mu lt iq mt b gy no nl l nm nn">for (let i in array) {<br/>    console.log(array[i]);<br/>}</span><span id="b5b5" class="mu lt iq mt b gy no nl l nm nn">// or</span><span id="2d41" class="mu lt iq mt b gy no nl l nm nn">for (let key in obj) {<br/>    console.log(obj[key]);<br/>}</span></pre><p id="82f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，这可能会导致错误。虽然TypeScript是面向对象的，但JavaScript不是。JavaScript是基于原型的。有时候，在迭代数组或对象时，会遇到一些传递给对象的原型属性。特别是在TypeScript中，原型由TSC修改。</p><p id="6987" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能会导致包含您不期望的键:</p><ul class=""><li id="6093" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">您不知道属性的存在，因为它是在原型链的更高层定义的</li><li id="5bb2" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">For-in循环还可以通过</li></ul><h2 id="58d1" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案(针对阵列)</h2><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="c19c" class="mu lt iq mt b gy nk nl l nm nn">const array = [5, 6, 7, 8];</span><span id="7580" class="mu lt iq mt b gy no nl l nm nn">array.forEach(n =&gt; {<br/>    // Do stuff<br/>});</span></pre><p id="fff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与for-in语法不同，这类似于for-each循环。<code class="fe mq mr ms mt b">n</code>是元素的值。如果您也需要索引，那么回调可以接受一个附加参数:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="57b3" class="mu lt iq mt b gy nk nl l nm nn">const array = [5, 6, 7, 8];</span><span id="3cd4" class="mu lt iq mt b gy no nl l nm nn">array.forEach((n, i) =&gt; {<br/>    // n is the value<br/>    // i is the index<br/>});</span></pre><h2 id="4b31" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案(针对对象)</h2><p id="ec7d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">数组附带了一组很好的函数，您可以将它们链接起来，但是普通的JS对象却不能。所以您可能需要使用for-in语法进行迭代。幸运的是，对象确实有一个名为<code class="fe mq mr ms mt b">hasOwnProperty</code>的内置方法。这确保了您正在检查的属性在对象中正常存在。</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="1bb3" class="mu lt iq mt b gy nk nl l nm nn">const obj = /* Any object definition here */</span><span id="644e" class="mu lt iq mt b gy no nl l nm nn">for (const key in obj) {<br/>    if (obj.hasOwnProperty(key)) {<br/>        // Do stuff here<br/>    }<br/>}</span></pre><h2 id="b1ca" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">例外</h2><p id="4339" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个规则有一个例外:当克隆一个对象时。</p><p id="2e3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">克隆JS/TS对象的基本代码是:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="01df" class="mu lt iq mt b gy nk nl l nm nn">const obj = /* something */;<br/>const newObj = {};</span><span id="c625" class="mu lt iq mt b gy no nl l nm nn">for (const key in obj) {<br/>    newOjb[key] = obj[key];<br/>}</span></pre><p id="e79a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不会引入错误，因为将一个对象的原型克隆到同一原型的另一个对象中不会产生任何意外的行为。</p><h1 id="3db9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7)接口中的构造函数</h1><p id="1c4f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><em class="mp">构造函数不应该在接口内部声明</em></p><h2 id="88d4" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">问题是</h2><p id="3b1f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您使用没有任何类型定义的JS库，您可能已经创建了自己的<code class="fe mq mr ms mt b">.d.ts</code>文件来指定类型，这样您就可以将代码包含在您的TS项目中。此外，您可能是JS代码的作者，并且希望提供类型声明，以便其他人可以在更广泛的项目中包含您的库。</p><p id="21b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个类定义，您可能以前编写过这样的接口声明:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="d670" class="mu lt iq mt b gy nk nl l nm nn">interface MyType {<br/>    value: number;<br/>    getValue(): number;<br/>    <br/>    constructor(value: number): MyType;<br/>    // or<br/>    new(value: number): MyType;<br/>}</span></pre><p id="6756" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这实际上声明了一个名为<code class="fe mq mr ms mt b">constructor</code>或<code class="fe mq mr ms mt b">new</code>的方法，并且实际上会在将来引入更多的类型脚本错误。</p><h2 id="08e6" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">解决方案</h2><p id="ce2c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">相反，您应该提供一个类声明:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="3cd5" class="mu lt iq mt b gy nk nl l nm nn">declare class MyType {<br/>    value: number;<br/>    getValue(): number;</span><span id="42b1" class="mu lt iq mt b gy no nl l nm nn">    constructor(value: number);<br/>}</span></pre></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="d97d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章对你有所帮助。如果你学到了一些你还不知道的东西，并且想通过解决这些鲜为人知的错误来改进你的代码，这里是我的建议:</p><ul class=""><li id="2ed9" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">关注一个关于JavaScript的媒体出版物<em class="mp">(用简单英语写的JavaScript是一个很好的例子)</em></li><li id="bd08" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">通过林挺软件运行你的代码<em class="mp">(ESLint，Codacy，SonarCloud都是不错的选择)</em></li><li id="6c80" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">永远不要停止学习！</li></ul><p id="10fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mp">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mp">说白了就是</em> </strong> </a> <em class="mp">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mp">免费周报</em> </strong> </a> <em class="mp">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mp">Twitter</em></strong></a><em class="mp">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mp">LinkedIn</em></strong></a><em class="mp">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mp">社区不和谐</em> </strong> </a> <em class="mp">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mp">人才集体</em> </strong> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>