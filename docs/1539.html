<html>
<head>
<title>Connecting Rooms in a JavaScript Roguelike</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript语言连接房间</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9?source=collection_archive---------7-----------------------#2022-03-31">https://javascript.plainenglish.io/connecting-rooms-in-a-javascript-roguelike-8e6212c54c9?source=collection_archive---------7-----------------------#2022-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0d30fe02bee5e129b7752391419575fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezcJKOIa8yhQ-8SceB-oFQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by <a class="ae kc" href="https://www.deviantart.com/louisetheanimator" rel="noopener ugc nofollow" target="_blank">Louisetheanimator</a> on <a class="ae kc" href="https://www.deviantart.com/louisetheanimator/art/Door-to-the-Dungeon-759562325" rel="noopener ugc nofollow" target="_blank">Deviantart</a></figcaption></figure><p id="5329" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几个星期以来，我一直在使用JavaScript构建Roguelikes，它以程序化生成的地图而闻名。</p><p id="7867" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我之前写的一篇文章分解了用随机漫步算法构建洞穴状地牢爬虫的过程。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/64293f2f2fe084111a3608b3cf4d3231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSTDBSlKCmbs87Hx-7oWPg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A roguelike level was created with a random walk process.</figcaption></figure><p id="4b1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我被为互联房间编写算法的想法迷住了——所以在大量的构建和测试之后，我用它编写了一个完整的游戏，并开始了一个新的系列教程。系列的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/rendering-roguelike-rooms-with-javascript-8a2dc58f3b63">第一个教程</a>涵盖了程序生成的房间，如下所示。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/1b926284ba8119a04ff317db4183aaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wt-MfFK23uaZ9tPEOTMHXQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">An algorithm for creating dungeon rooms.</figcaption></figure><p id="7e4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将继续这个算法，用一个走廊连接直接面对的房间，并打开其余的游戏逻辑。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/b4b15c3fac26c4d8ea841c79ad7b2916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqmcyirZJuHBatMqC1J67w.png"/></div></div></figure><p id="6a4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在上面的图表中看到的，这通常不会创建一个完整的网络，但这是创建完整游戏的重要一步。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/f52bd20d267a3c7be512ea773790376d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcSiLdpOmgmceBJMRjoMyQ.png"/></div></div></figure><p id="6894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以在这个<a class="ae kc" href="https://stellular-biscuit-6757a3.netlify.app/solution/index.html" rel="noopener ugc nofollow" target="_blank">演示页面</a>上玩的完整游戏，有着和随机漫步版本一样的机制，但是有一个由房间和走廊组成的关卡，而不是一个洞穴。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="eee0" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">整体流程</h1><p id="fcf2" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">整个教程系列包括编写一个算法，该算法执行以下操作，我们正在处理的步骤以粗体显示。</p><ul class=""><li id="c4b0" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">生成房间。</li><li id="5943" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><strong class="kf ir">尝试将每个房间与直接面对它的一个或多个房间连接起来。</strong></li><li id="6c75" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">尝试将每个房间与附近的另一个房间连接起来，该房间可以面向它，也可以与它成对角线。</li><li id="ac2c" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">连接其他房间无法到达的剩余房间。</li></ul><p id="595e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始吧。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="e46f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">教程资源</h1><p id="7691" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在本文中，我将带您了解如何将房间连接逻辑添加到可以从Github克隆的<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms" rel="noopener ugc nofollow" target="_blank">代码库中。下面是我们将涵盖的内容的简要概述。</a></p><ol class=""><li id="1465" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la nh mz na nb bi translated"><a class="ae kc" href="#bacf" rel="noopener ugc nofollow">文件结构</a></li><li id="87ee" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la nh mz na nb bi translated"><a class="ae kc" href="#5856" rel="noopener ugc nofollow">整体流程</a></li><li id="134a" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la nh mz na nb bi translated"><a class="ae kc" href="#262d" rel="noopener ugc nofollow">班级</a></li><li id="aaf6" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la nh mz na nb bi translated"><a class="ae kc" href="#e236" rel="noopener ugc nofollow">游戏方法</a></li><li id="0d85" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la nh mz na nb bi translated"><a class="ae kc" href="#c124" rel="noopener ugc nofollow">发电机房</a></li><li id="e553" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la nh mz na nb bi translated">如何找到面对面的房间</li><li id="be91" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la nh mz na nb bi translated"><a class="ae kc" href="#13cd" rel="noopener ugc nofollow">用线连接房间</a></li></ol></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="bacf" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">项目文件</h1><p id="63b2" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">要下载项目目录，可以去这个<a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms" rel="noopener ugc nofollow" target="_blank"> Git repo </a>，点击<em class="ni">代码</em>，点击<em class="ni">下载ZIP。</em>或者，您可以从命令行克隆它:</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="97d1" class="no lr iq nk b gy np nq l nr ns">git clone <a class="ae kc" href="https://github.com/nevkatz/js-roguelike-rooms.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nevkatz/js-roguelike-rooms.git</a></span></pre><p id="79d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下载的repo中，有一个<code class="fe nt nu nv nk b">phase-2-paths</code>目录，您可以使用下面的结构在其中工作。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="01e6" class="no lr iq nk b gy np nq l nr ns">phase-2-paths<br/>  |<br/>  *--index.html<br/>  |<br/>  *--css <br/>  |   |<br/>  |   *--style.css<br/>  |<br/>  |<br/>  *--js <br/>      |<br/>      *--room.js<br/>      |<br/>      *--path.js<br/>      |<br/>      *--game.js<br/>      |<br/>      *--script.js</span></pre><p id="fdcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个教程的目录<code class="fe nt nu nv nk b">phase-3-corners</code>，从我们将在这里完成的所有代码开始。还有一个<code class="fe nt nu nv nk b">solution</code>目录，里面有完整的游戏，你可以参考比较。</p><p id="80f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nt nu nv nk b">phase-2-paths</code>目录中有一些你不必接触的文件，比如<code class="fe nt nu nv nk b">index.html</code>和<code class="fe nt nu nv nk b">style.css</code>。主要工作将发生在四个JavaScript文件中:</p><ul class=""><li id="e67c" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe nt nu nv nk b">script.js</code>，运行游戏</li><li id="c66c" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">room.js</code>，其中包含了<code class="fe nt nu nv nk b">Room</code>类</li><li id="fabd" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">game.js</code>，它包含了<code class="fe nt nu nv nk b">Game</code>类</li><li id="9690" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">path.js</code>，包含<code class="fe nt nu nv nk b">Path</code>类</li></ul><p id="65bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个JavaScript文件中，您会看到如下所示的方法。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/ee2cd1d4ce5f7575f7c6804e335dc709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bkprFgP5lhvpNgO0cVRSw.png"/></div></div></figure><p id="6f7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你克隆了回购协议，转到<code class="fe nt nu nv nk b">phase-2-paths</code>并在浏览器中打开<code class="fe nt nu nv nk b">index.html</code>文件，你会看到一个相当荒谬的场景，穿蓝色衣服的玩家被困在一个房间里，可能还有一个敌人。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/72b3000d0a0ba97d74092da1870c3fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmB0wmUym3GGMzb7i7ge5g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Not a good situation.</figcaption></figure><p id="5237" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，是的，我们真的需要增加那些走廊。</p><p id="208a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到本教程结束时，你的算法应该能够用一条直线连接彼此面对的房间，如下所示。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1a5438b08fe09618e79bff14c549b17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*WFDvPnXeW8znm0t81jSfDQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Each of these rooms faces at least one other room.</figcaption></figure></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="262d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">上层社会</h1><p id="08de" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在编写更多代码之前，让我们先来看看我们将为其构建方法的三个类:<code class="fe nt nu nv nk b">Game</code>、<code class="fe nt nu nv nk b">Room</code>和<code class="fe nt nu nv nk b">Path</code>。</p><h2 id="a140" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">游戏课</h2><p id="160c" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">存储游戏属性的game类有一个房间对象数组。当它创建一个新房间时，它给它分配<code class="fe nt nu nv nk b">curRoomId</code>然后递增。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The game class</figcaption></figure><p id="f3bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也有一个<code class="fe nt nu nv nk b">map</code> 2D阵。为了让游戏地图可见，它使用它的<code class="fe nt nu nv nk b">context</code>绘制它的<code class="fe nt nu nv nk b">&lt;canvas&gt;</code>元素。</p><h2 id="4fd5" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">房间类</h2><p id="ce27" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">下面是我们的<code class="fe nt nu nv nk b">room</code>班。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6250" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个房间都有一个<code class="fe nt nu nv nk b">id</code>和三组坐标:</p><ul class=""><li id="b7d1" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe nt nu nv nk b">start</code>，代表左上角</li><li id="018f" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">end</code>，代表右下角</li><li id="f7f0" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">center</code>，代表房间的中心。</li></ul><p id="e1c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个房间都有一个和<code class="fe nt nu nv nk b">id</code>以及一个<code class="fe nt nu nv nk b">neighbors</code>的数组，这是游戏地图上它连接到的房间。</p><h2 id="eb41" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">路径类</h2><p id="a6b6" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">该课程有助于创建房间之间的线条。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="1cfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看到<code class="fe nt nu nv nk b">start</code>和<code class="fe nt nu nv nk b">end</code>坐标被定义并有默认值。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="b28c" class="no lr iq nk b gy np nq l nr ns">this.start = points.start || {x:0,y:0};</span><span id="c98e" class="no lr iq nk b gy om nq l nr ns">this.end = points.end || {x:0,y:0};</span></pre><p id="d916" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我可以很容易地声明一个新路径，而不必马上设置具体的坐标。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="f893" class="no lr iq nk b gy np nq l nr ns">let path = new Path();</span></pre><p id="547a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个以<code class="fe nt nu nv nk b">false</code>开始的<code class="fe nt nu nv nk b">allowed</code>属性，但是只要该路径不与其他路径长时间相邻，它就会变为<code class="fe nt nu nv nk b">TRUE</code>。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="e236" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">游戏方法</h1><p id="8d5b" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">先从<code class="fe nt nu nv nk b">game.js</code>开始，写三个方法:<code class="fe nt nu nv nk b">resetMap</code>、<code class="fe nt nu nv nk b">carveRoom</code>、<code class="fe nt nu nv nk b">addPath</code>。所有这些函数改变了<code class="fe nt nu nv nk b">game</code>对象的<code class="fe nt nu nv nk b">map</code> 2D数组。</p><h2 id="e79a" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">重置地图</h2><p id="c42e" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">第一种方法，<code class="fe nt nu nv nk b">resetMap()</code>，通过在2D阵列中的每个空间添加一个<code class="fe nt nu nv nk b">WALL_CODE</code>或<code class="fe nt nu nv nk b">0</code>，使房间成为一个实体墙。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9cc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们添加房间和路径时，我们将凿穿这堵墙，并向代表地砖的数组的每个部分添加一个<code class="fe nt nu nv nk b">FLOOR_CODE</code> of <code class="fe nt nu nv nk b">1</code>。</p><h2 id="49b4" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">添加房间</h2><p id="1fe2" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">第二种方法，<code class="fe nt nu nv nk b">carveRoom</code>，基于传入的<code class="fe nt nu nv nk b">room</code>对象在地图中挖空一个矩形的<code class="fe nt nu nv nk b">FLOOR_CODE</code>图块。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="01d6" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">房间的<code class="fe nt nu nv nk b">start</code>是它的左上角。</li><li id="9b7d" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">房间的<code class="fe nt nu nv nk b">end</code>是它的右下角。</li></ul><h2 id="7ef3" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">添加路径</h2><p id="42b0" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">第三种方法是<code class="fe nt nu nv nk b">addPath</code>，在游戏中创建一条直线路径，宽度为一个方块。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="02ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你在<code class="fe nt nu nv nk b">game.js</code>中完成这些方法后，让我们转到<code class="fe nt nu nv nk b">script.js</code>并展开<code class="fe nt nu nv nk b">generateMapRooms</code>，创建房间并连接它们的“大图”功能。</p><h1 id="c124" class="lq lr iq bd ls lt on lv lw lx oo lz ma mb op md me mf oq mh mi mj or ml mm mn bi translated">发电机房</h1><p id="e66a" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">当游戏第一次加载时，<code class="fe nt nu nv nk b">generateMapRooms</code>的初始版本只是创建房间。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The initial function you will see in script.js.</figcaption></figure><p id="a000" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">房间的添加将在本教程的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/rendering-roguelike-rooms-with-javascript-8a2dc58f3b63">中介绍。它是这样工作的:</a></p><ul class=""><li id="4c3d" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">生成房间尺寸和中心坐标。</li><li id="8c90" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">创建一个房间对象，并测试它是否与其他房间重叠。</li><li id="b0da" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">如果它不与其他房间重叠，请添加该房间。</li></ul><h2 id="666c" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">建立联系</h2><p id="6960" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">我们的目标是通过让每个房间尝试连接到另外两个房间来建立一个房间网络:一个房间直接面对它，另一个房间在它附近。然后，我们将尝试连接网络之外的任何房间。</p><p id="11ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从第一步开始:遍历每个房间，并尝试将其连接到另一个面对的房间。在<code class="fe nt nu nv nk b">generateMapRooms</code>中，让我们创建一个<code class="fe nt nu nv nk b">success</code>变量、一个<code class="fe nt nu nv nk b">min</code>常量和一个<code class="fe nt nu nv nk b">for...of</code>循环，如下所示。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="1e1a" class="no lr iq nk b gy np nq l nr ns">let success = false;</span><span id="2071" class="no lr iq nk b gy om nq l nr ns">const min = 3;</span><span id="bc4f" class="no lr iq nk b gy om nq l nr ns">for (var room of game.rooms) {</span><span id="9518" class="no lr iq nk b gy om nq l nr ns">     success = room.findFacingRooms(min);<br/> <br/>     console.log(`Room${room.id} findFacing: ${success}`);<br/>}</span></pre><p id="772c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nt nu nv nk b">min</code>常数是一个房间应该与面对它的另一个房间共享的<code class="fe nt nu nv nk b">x</code>或<code class="fe nt nu nv nk b">y</code>坐标的最小数量。</p><p id="994c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是迄今为止完整的<code class="fe nt nu nv nk b">generateMapRooms</code>函数。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最终会添加其他方法来连接房间，但现在，让我们编写<code class="fe nt nu nv nk b">findFacingRooms</code>及其助手方法。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="4ff7" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">如何找到面对面的房间</h1><p id="8879" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">每个<code class="fe nt nu nv nk b">Room</code>对象都可以调用<code class="fe nt nu nv nk b">findFacingRooms</code>方法来找到一个正对着它的房间。下面是我们如何开始这个方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The start to the findFacingRooms function.</figcaption></figure><p id="36bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们尝试连接之前，我们必须找到可供连接的潜在房间。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="860e" class="no lr iq nk b gy np nq l nr ns">let rooms = this.findPotentialRooms();</span></pre><p id="f2f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们也在<code class="fe nt nu nv nk b">room.js</code>中为此编写方法。</p><h2 id="6955" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">寻找潜在的房间</h2><p id="dd07" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">每个<code class="fe nt nu nv nk b">room</code>对象都有一个<code class="fe nt nu nv nk b">neighbors</code>数组，或者说它已经连接的房间。每当我们搜索新的连接时，我们都不想包含现有的邻居。</p><p id="a6b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像这样过滤掉调用该方法的房间:</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="01a5" class="no lr iq nk b gy np nq l nr ns">Room.prototype.findPotentialRooms = function() {</span><span id="93cc" class="no lr iq nk b gy om nq l nr ns">   let rooms = game.rooms.filter(x =&gt; x.id != this.id);<br/>}</span></pre><p id="913b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用类似的方式填写邻居:</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="cabb" class="no lr iq nk b gy np nq l nr ns">if (this.neighbors.length &gt; 0) {<br/>      <br/>     rooms = rooms.filter(x =&gt; !this.neighbors.includes(x));<br/>}</span></pre><p id="0d77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe nt nu nv nk b">findPotentialRooms</code>方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="d8e8" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">开始循环</h2><p id="a2a1" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">好吧，回到<code class="fe nt nu nv nk b">findFacingRooms</code>。找到潜在的房间后，我们开始遍历它们以找到一个要连接的房间。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="6a33" class="no lr iq nk b gy np nq l nr ns">let rooms = this.findPotentialRooms();</span><span id="92e4" class="no lr iq nk b gy om nq l nr ns">for (var room of rooms) {</span><span id="9e4f" class="no lr iq nk b gy om nq l nr ns">}</span></pre><h2 id="765e" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">如何定义“面子”</h2><p id="edc3" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">为了让一个房间面对另一个房间，这两个房间必须共享足够的x或y坐标，并且它们之间不能有另一个房间。</p><p id="af8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，下面的房间共享共同的<code class="fe nt nu nv nk b">x</code>值，并且几乎对齐。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/4d456260bdd8307be09568e262ea3cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*VM7aG9fGqpkW6wZP7xfkrA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Two rooms sharing x coordinates</figcaption></figure><p id="0f1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这两个房间有共同的价值观，它们可以很容易地形成一条直线。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f570fb539bcc94fcecd48eff1cf781e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*UvlfiGDK-ZcwLyzq8YwaCQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Two rooms sharing y coordinates</figcaption></figure><p id="7f9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一下“中间没有房间”的情况。在下图中，房间1和房间2不会面对，因为中间有一个房间。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/a9e75d1176a228e9b5e1c3c6a9c7063f.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*rxCYSKUSb-PcbPPuZ91FFg.png"/></div></figure><p id="cdf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查这些条件，让我们在我们的循环中添加两个新方法— <code class="fe nt nu nv nk b">roomBetween</code>，它检查两个房间之间没有其他房间，和<code class="fe nt nu nv nk b">sharesCoordsWith</code>，它检查房间是否共享足够的<code class="fe nt nu nv nk b">x</code>或<code class="fe nt nu nv nk b">y</code>坐标。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="fbda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果潜在的房间通过了这些测试，方法调用房间就试图与它连接。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="e392" class="no lr iq nk b gy np nq l nr ns">success = this.connectRoom(room, min);</span></pre><p id="fbe0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它连接的房间数量超过最大值，请添加下面的逻辑来打破循环。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="01cd" class="no lr iq nk b gy np nq l nr ns">   success = this.connectRoom(room, min);<br/>}  <br/><strong class="nk ir">if (this.neighbors.length &gt;= maxRooms) {</strong></span><span id="bab7" class="no lr iq nk b gy om nq l nr ns"><strong class="nk ir">   break;<br/>}</strong></span></pre><p id="232f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在方法参数中，我通常将<code class="fe nt nu nv nk b">maxRooms</code>设置为<code class="fe nt nu nv nk b">1</code>作为默认值。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="d8db" class="no lr iq nk b gy np nq l nr ns">Room.prototype.findFacingRooms = function(min=1, <strong class="nk ir">maxRooms=1) </strong>{</span></pre><p id="2e66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经接触了<code class="fe nt nu nv nk b">connectRoom</code>函数和<code class="fe nt nu nv nk b">maxRooms</code>，我们现在有两个方法可以写:<code class="fe nt nu nv nk b">sharesCoordsWith</code>和<code class="fe nt nu nv nk b">roomBetween</code>，都在<code class="fe nt nu nv nk b">room.js</code>中。</p><h2 id="7ebb" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">测试共享坐标</h2><p id="1517" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">出于美观的原因，我不喜欢让小路碰到房间的角落。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/46288c055fb2e72270235947c895f057.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*Xowcot6aBILFeFfjvJyiqw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This is not desired.</figcaption></figure><p id="6efd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我只希望房间能够直接连接，如果它们至少有三个共同的坐标，那么它们应该有以下之一:</p><ul class=""><li id="a7b9" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">如果一个在另一个之上，至少三个<code class="fe nt nu nv nk b">x</code>坐标相同，</li><li id="d93b" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">或者如果并排，至少有三个<code class="fe nt nu nv nk b">y</code>坐标相同。</li></ul><p id="4f70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于上述限制，下面的房间没有共享足够的<code class="fe nt nu nv nk b">x</code>坐标来直接连接。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/296905e0b30d4e2b0b11b76e5905bdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*0U80f8lo8WHdLLhkSRKEmA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">These two rooms only share one x coordinate.</figcaption></figure><p id="abff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相比之下，下面的房间共享三个瓷砖的坐标空间，因此它们被认为是相互面对的。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/46dc66977b566a35185eadf1e9bdeebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*AgBUqYWdkb9Ee0oYjEgp2Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">These rooms share three x coordinates.</figcaption></figure><p id="e68f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以用一条直线将它们连接起来。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/e7e78b269b3449262374e83fc87775db.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*Yw7N2ZSaFBRpoSPlodAnyA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Now we can connect them.</figcaption></figure><p id="aa7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编写<code class="fe nt nu nv nk b">sharesCoordsWith</code>方法，帮助我们确定两个房间是否共享足够的<code class="fe nt nu nv nk b">x</code>或<code class="fe nt nu nv nk b">y</code>坐标。</p><p id="de02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法开始如下。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="00c5" class="no lr iq nk b gy np nq l nr ns">Room.prototype.sharesCoordsWith = function(room, coord, min=1) {</span><span id="ceb0" class="no lr iq nk b gy om nq l nr ns">}</span></pre><p id="d94e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于参数:</p><ul class=""><li id="ecc8" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe nt nu nv nk b">room</code>是我们正在测试的相邻房间。</li><li id="7b66" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">coord</code>变量可以是<code class="fe nt nu nv nk b">x</code>或<code class="fe nt nu nv nk b">y</code>。</li><li id="4dce" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">min</code>参数，我经常以<code class="fe nt nu nv nk b">3</code>的形式传入，表示房间应该共享的最小坐标数。它有一个默认的<code class="fe nt nu nv nk b">1</code>，如果你不介意走廊接触房间角落，你可以使用它。</li></ul><p id="b3b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们在函数中添加的内容。注意，我们在<code class="fe nt nu nv nk b">end</code>和<code class="fe nt nu nv nk b">start</code>坐标之间的差值上加上了<code class="fe nt nu nv nk b">1</code>。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="9647" class="no lr iq nk b gy np nq l nr ns">return room.end[coord] - this.start[coord] + 1 &gt;= min &amp;&amp;<br/>       this.end[coord] - room.start[coord] + 1 &gt;= min;</span></pre><p id="fdbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为找到最接近的<code class="fe nt nu nv nk b">start</code>和<code class="fe nt nu nv nk b">end</code>坐标值之间的差值——在本例中为<code class="fe nt nu nv nk b">11 — 9</code>——总是比共享的图块数少1。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a603d224cf701622a412611ba8b7e398.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*I0MsGHDeOdVoMRinMwx4qQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Three tiles shared with a start/end difference of 2.</figcaption></figure><p id="1cf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的完整方法很短，但从概念上讲，它有很多内容。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The full sharesCoordsWith method.</figcaption></figure><p id="0618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，坐标共享条件已涵盖。</p><h2 id="e74f" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">检查中间的房间</h2><p id="7def" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">现在让我们从下面的代码开始写一个测试一个房间是否在两个房间之间的方法。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="435f" class="no lr iq nk b gy np nq l nr ns">Room.prototype.roomBetween = function(room) {</span><span id="fb0f" class="no lr iq nk b gy om nq l nr ns">}</span></pre><p id="4694" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住以下几点:</p><ul class=""><li id="f5bf" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe nt nu nv nk b">this</code>是方法调用室在尝试连接。</li><li id="d6fc" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">room</code>是<code class="fe nt nu nv nk b">this</code>可能连接也可能不连接的房间。</li></ul><p id="d725" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得一个有效的<code class="fe nt nu nv nk b">testRooms</code>数组，我们使用<code class="fe nt nu nv nk b">filter</code>方法移除这些房间。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Filtering out the method caller and the room facing it.</figcaption></figure><p id="1870" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了<code class="fe nt nu nv nk b">testRooms</code>，我们必须测试两种可能性:</p><p id="4896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nt nu nv nk b">testRoom</code>水平位于……</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/76262f7123a90d835387576e990209df.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*cLEB_uLGejiASsNrmiMEbw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Horizontal case</figcaption></figure><p id="5623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…或者在垂直方向上介于两者之间。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/bba10faea0a39a3b5b600a40e753f5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*iJo_sbJCDTWYuTz9okXzUg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Vertical case</figcaption></figure><p id="f4ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以当我们迭代<code class="fe nt nu nv nk b">testRooms</code>时，让我们调用两个新方法:<code class="fe nt nu nv nk b">betweenVert</code>和<code class="fe nt nu nv nk b">betweenHoriz</code>。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="c35e" class="no lr iq nk b gy np nq l nr ns">for (var testRoom of testRooms) {</span><span id="eb8a" class="no lr iq nk b gy om nq l nr ns">if (testRoom.betweenVert(this,room) || <br/>       testRoom.betweenHoriz(this,room)) {<br/>         <br/>         return true;<br/>     }<br/>}<br/>return false;</span></pre><p id="c612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是测试过滤数组中每个房间的完整的<code class="fe nt nu nv nk b">roomBetween</code>方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The complete roomBetween method.</figcaption></figure><p id="4ea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们来写它的两个helper方法。</p><h2 id="95b6" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">横向检查</h2><p id="f994" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">下面的部分方法测试每个房间是否在它的两个同伴之间水平。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="f8cc" class="no lr iq nk b gy np nq l nr ns">Room.prototype.betweenHoriz = function(room1,room2) {</span><span id="d856" class="no lr iq nk b gy om nq l nr ns">   return this.sharesCoordsWith(room1,'y') &amp;&amp; <br/>          this.sharesCoordsWith(room2,'y') &amp;&amp;<br/>         room1.sharesCoordsWith(room2,'y') &amp;&amp;</span><span id="14f8" class="no lr iq nk b gy om nq l nr ns">}</span></pre><ul class=""><li id="8955" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">参数<code class="fe nt nu nv nk b">room1</code>和<code class="fe nt nu nv nk b">room2</code>是试图连接的两个房间。</li><li id="d655" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">因为被测房间在调用方法，所以引用为<code class="fe nt nu nv nk b">this</code>。</li></ul><p id="6959" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这三个房间共用一个坐标并不意味着测试室就在另外两个房间之间，所以现在我们必须检查房间的顺序。</p><h2 id="2522" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">检查序列</h2><p id="83b3" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">如果这些房间共享<code class="fe nt nu nv nk b">y</code>坐标，则需要关注的场景是测试房间是否在一个房间之后和另一个房间之前。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/7391fe55eaa4c835d0f81756fa02376b.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*0Yn4x-_g1uZC5P_vGIuMzA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Scenario 1.</figcaption></figure><p id="967b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确定是否是这种情况，下面的代码测试<code class="fe nt nu nv nk b"> room1</code>是否在测试室的左边(如<code class="fe nt nu nv nk b">this</code>所示)以及<code class="fe nt nu nv nk b">room2</code>是否在右边。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="ba46" class="no lr iq nk b gy np nq l nr ns"><strong class="nk ir">this</strong>.center.x <strong class="nk ir">&gt; room1</strong>.center.x &amp;&amp; <strong class="nk ir">this</strong>.center.x <strong class="nk ir">&lt; room2</strong>.center.x</span></pre><p id="2a34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们测试相反的:左边的<code class="fe nt nu nv nk b">room2</code>和右边的<code class="fe nt nu nv nk b">room1</code>。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/fa857787181bbfacfa35520322260b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*bVHf0q-pOZO9jVbUvQCGzA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Scenario 2.</figcaption></figure><p id="946a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码几乎相同，只是交换了<code class="fe nt nu nv nk b">room1</code>和<code class="fe nt nu nv nk b">room2</code>。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="a9c3" class="no lr iq nk b gy np nq l nr ns"><strong class="nk ir">this</strong>.center.x &gt;<strong class="nk ir"> room2</strong>.center.x &amp;&amp; <strong class="nk ir">this</strong>.center.x &lt; <strong class="nk ir">room1</strong>.center.x</span></pre><p id="0882" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe nt nu nv nk b">betweenHoriz</code>方法，包括坐标共享测试和相对位置测试。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The complete betweenHoriz method.</figcaption></figure><h2 id="4ab5" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">垂直检查</h2><p id="a07d" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">为了测试一个房间是否垂直位于两个可能相连的房间之间，我们使用了一个<code class="fe nt nu nv nk b">betweenVert</code>方法，它使用了相同的方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="28b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在下面看到<code class="fe nt nu nv nk b">betweenVert</code>测试的两个场景。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/780489d7cb743abc192efbe785197e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*KQaPk5JnQZT3biKHfi83rg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Is the test room below room1 and above room2?</figcaption></figure><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/1b6682361c2ce6039f44838a8ece67f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*6KQuaC5J_aL9hHR6enuquw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">How about vice-versa?</figcaption></figure><p id="41cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回顾一下。</p><ul class=""><li id="691b" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">我们编写了<code class="fe nt nu nv nk b">shareCoordsWith</code>方法来测试水平或垂直空间的共享。</li><li id="50b4" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">我们创建了<code class="fe nt nu nv nk b">roomBetween</code>方法来测试一个房间是否在中间。</li><li id="2a4f" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">然后我们精心制作了它的两个助手:<code class="fe nt nu nv nk b">betweenHoriz</code>和<code class="fe nt nu nv nk b">betweenVert</code>。</li></ul><p id="289a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是现在使用<code class="fe nt nu nv nk b">sharesCoordsWith</code>和<code class="fe nt nu nv nk b">roomBetween</code>的<code class="fe nt nu nv nk b">findFacingRooms</code>方法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The find facing rooms method</figcaption></figure><p id="90df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe nt nu nv nk b">findFacingRooms</code>中的大致流程。</p><ul class=""><li id="8ec6" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">遍历潜在的房间。</li><li id="9ad0" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">找一个有足够垂直或水平坐标的房间。</li><li id="b259" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">验证在方法调用房间和潜在房间之间没有其他房间。</li><li id="53c1" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">如果通过验证，呼叫室会立即尝试连接。</li><li id="f3b2" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">一旦呼叫房间有足够多的邻居，它就跳出循环并返回。</li></ul><h2 id="edfd" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">快速测试</h2><p id="69b0" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">如果您想测试您的逻辑，请转到<code class="fe nt nu nv nk b">findFacingRooms</code>并注释掉下面的行。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="f331" class="no lr iq nk b gy np nq l nr ns">// success = this.connectRoom(room, min);</span></pre><p id="aded" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，加上这一行。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="88fe" class="no lr iq nk b gy np nq l nr ns">console.log(`${this.id} is connected to ${room.id}!`);</span></pre><p id="a12b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在继续下一步之前，您可以测试您寻找面对面房间的逻辑是否可行。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="13cd" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">用线连接房间</h1><p id="9dda" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">现在两个面对的房间可以找到对方，让我们从下面的<code class="fe nt nu nv nk b">connectRoom</code>方法开始连接它们。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="dcd1" class="no lr iq nk b gy np nq l nr ns">Room.prototype.connectRoom = function(room, min=3) { <br/>   let success = false;</span><span id="8cbe" class="no lr iq nk b gy om nq l nr ns">   return success;<br/>}</span></pre><p id="5846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这种方法也将连接对角非面对的房间，我们将最终尝试以两种方式连接房间:</p><ul class=""><li id="ccf8" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated">用一条直线，</li><li id="0ed1" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated">或者两条线在一个角上相交。</li></ul><h2 id="11b2" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">单线连接</h2><p id="778a" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">如果房间共享足够的水平或垂直空间，我们尝试使用一种新的<code class="fe nt nu nv nk b">directConnect</code>方法将它们直接连接起来，这将产生一条如下所示的路径:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/40727b08a64ef2c2d9f5a3dc98c1c678.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*MQaQrv_Qd0Mkj2bFxWdEAA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Two rooms connecting directly with a straight-line path.</figcaption></figure><p id="f31a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了查看直接连接是否可行，我们通过对<code class="fe nt nu nv nk b">sharesCoordsWith</code>方法的两次调用来检查<code class="fe nt nu nv nk b">x</code>或<code class="fe nt nu nv nk b">y</code>坐标的共享。如果两个房间在<code class="fe nt nu nv nk b">x</code>或<code class="fe nt nu nv nk b">y</code>轴上有三个或更多的共同坐标，我们尝试<code class="fe nt nu nv nk b">directConnect</code>并返回努力的<code class="fe nt nu nv nk b">success</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This implementation only connects rooms directly.</figcaption></figure><h2 id="9bb9" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">编写直接连接方法</h2><p id="59b3" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">下面是<code class="fe nt nu nv nk b">directConnect</code>法，专门连接对向房间。我们很快就会写出它的助手:<code class="fe nt nu nv nk b">addVertPath</code>和<code class="fe nt nu nv nk b">addHorizPath</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d41c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在方法的开始，我们首先声明一个新的path对象。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="af79" class="no lr iq nk b gy np nq l nr ns">let path = new Path();</span></pre><p id="548f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免在房间角落创建房间出口，我们基于<code class="fe nt nu nv nk b">min</code>初始化一个<code class="fe nt nu nv nk b">wall</code>常数，这是房间应该共享的最小数量的<code class="fe nt nu nv nk b">x</code>或<code class="fe nt nu nv nk b">y</code>坐标。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="fe32" class="no lr iq nk b gy np nq l nr ns">const wall = parseInt((min-1)/2);</span></pre><p id="8cb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe nt nu nv nk b">x</code>坐标共享，我们创建一个垂直路径；如果<code class="fe nt nu nv nk b">y</code>坐标共享，我们创建一个水平路径。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="7f3c" class="no lr iq nk b gy np nq l nr ns">if (this.sharesCoordsWith(room, 'x', min)) {</span><span id="eeeb" class="no lr iq nk b gy om nq l nr ns">     path = this.addVertPath(room,path,wall);  <br/>}<br/>else {<br/>      path = this.addHorizPath(room,path,wall);<br/>}</span></pre><p id="f180" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们返回<code class="fe nt nu nv nk b">path.allowed</code>，这是一个布尔值，表明路径是否被允许放置。这成为<code class="fe nt nu nv nk b">connectRoom</code>将看到的<code class="fe nt nu nv nk b">success</code>标志。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="956f" class="no lr iq nk b gy np nq l nr ns">return path.allowed;</span></pre><h2 id="ecdb" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">添加垂直路径的起点</h2><p id="175f" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">让我们启动<code class="fe nt nu nv nk b">directConnect</code>使用的<code class="fe nt nu nv nk b">addVertPath</code> helper方法。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="d7f5" class="no lr iq nk b gy np nq l nr ns">Room.prototype.addVertPath = function(room, path, wall) {</span><span id="f396" class="no lr iq nk b gy om nq l nr ns">}</span></pre><p id="99e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe nt nu nv nk b">game</code>对象的<code class="fe nt nu nv nk b">drawPath</code>方法总是向下绘制垂直路径，并且<code class="fe nt nu nv nk b">y</code>值随着它的下降而增加。鉴于此，基于较小的<code class="fe nt nu nv nk b">end.y</code>坐标开始路径是可行的方法。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/7dbb3e54da0b22b402770706efbd1f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*9d-AFm9dgOLdhlF2B80qBw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The bottom edge of the top room is the place to start.</figcaption></figure><p id="b7a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面我们使用<code class="fe nt nu nv nk b">Math.min</code>根据哪个房间的<code class="fe nt nu nv nk b">end.y</code>坐标较少来确定路径的起始图块。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="6b37" class="no lr iq nk b gy np nq l nr ns">Room.prototype.addVertPath = function(room, path, wall) {</span><span id="f153" class="no lr iq nk b gy om nq l nr ns">    path.start.y = <strong class="nk ir">Math.min</strong>(this.end.y,room.end.y) + 1;<br/>}</span></pre><p id="d7eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了<code class="fe nt nu nv nk b">1</code>,所以路径从房间下面的一个瓷砖开始。</p><h2 id="0943" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">添加垂直路径的终点</h2><p id="66d7" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">该路径应该正好在较低房间的顶部边缘结束，因此底部房间的<code class="fe nt nu nv nk b">start.y</code>坐标是要抓取的坐标。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/4d07ef541f155b9e86b48e799b02bf3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*i-ydXdDUnZmgl5AAZ3OZSw.png"/></div></figure><p id="ef38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了找到路径的终点，我们使用<code class="fe nt nu nv nk b">Math.max</code>来找到两个<code class="fe nt nu nv nk b">start.y</code>坐标中较大的一个。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="c412" class="no lr iq nk b gy np nq l nr ns">path.end.y = Math.max(this.start.y,room.start.y) - 1;</span></pre><p id="df3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们减去一块瓷砖，所以路径在进入房间之前停止。</p><h2 id="c206" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">水平定位垂直路径</h2><p id="1c44" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">现在我们有了垂直路径的起点和终点，我们必须水平放置它。为此，有一个名为<code class="fe nt nu nv nk b">possibleExits</code>的函数会有所帮助，它可以找到最右边和最左边可能的<code class="fe nt nu nv nk b">x</code>值。让我们先看看这个方法，稍后我会告诉你在哪里调用它。</p><h2 id="ee8a" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">寻找可能的路径</h2><p id="f20d" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><code class="fe nt nu nv nk b">possibleExits</code>方法可用于垂直和水平路径。它的第二个参数<code class="fe nt nu nv nk b">axis</code>，可以是<code class="fe nt nu nv nk b">x</code>也可以是<code class="fe nt nu nv nk b">y</code>。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The code for finding possible paths that exit out of the room.</figcaption></figure><p id="9a71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在垂直路径的情况下，<code class="fe nt nu nv nk b">possibleExits</code>找到代表垂直路径可能放置的可能的<code class="fe nt nu nv nk b">x</code>坐标范围的<code class="fe nt nu nv nk b">start</code>和<code class="fe nt nu nv nk b">end</code>值。</p><p id="0317" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了找到这个，它使用房间之间共享的<code class="fe nt nu nv nk b">x</code>坐标范围，以及<code class="fe nt nu nv nk b">wall</code>值。</p><p id="1713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下图中，三个允许的路径位置是蓝色的。红色的位置是不允许的，因为它们离边缘太近了。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/00d3d70532e8c9c6a3fa9666cd7a979a.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*wQYxnVLl3yIZa32MJclyvg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The X positions that are allowed are in blue; those that are not are in red.</figcaption></figure><p id="ccc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请看下面的片段，其中<code class="fe nt nu nv nk b">axis</code>代表<code class="fe nt nu nv nk b">x</code>。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/3f0344e068b37a8c29d8fbf098df8eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okXRCyO9qrHSE7cRQmatjQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">How Math.max() and Math.min() are used to find the possible range of coordinates.</figcaption></figure><ul class=""><li id="c2a9" class="mt mu iq kf b kg kh kk kl ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe nt nu nv nk b">Math.max()</code>用于查找最右边房间的左边缘，或<code class="fe nt nu nv nk b">start.x</code>。</li><li id="7588" class="mt mu iq kf b kg nc kk nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe nt nu nv nk b">Math.min()</code>用于查找最左边房间的右边缘，或<code class="fe nt nu nv nk b">end.x</code>。</li></ul><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/c4a193cc856b36ef593bf6ce8b35c7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*60xkVdWrXsMByFHdAtwdbA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Here is how Math.max() and Math.min() look in the diagram.</figcaption></figure><p id="78de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nt nu nv nk b">start</code>和<code class="fe nt nu nv nk b">end</code>值然后在一个对象中返回到<code class="fe nt nu nv nk b">placePath</code>。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="b8ff" class="no lr iq nk b gy np nq l nr ns">return {start, end};</span></pre><p id="9539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们编写一个名为<code class="fe nt nu nv nk b">placePath</code>的助手，它调用<code class="fe nt nu nv nk b">possibleExits</code>来查找最左边和最右边的<code class="fe nt nu nv nk b">x</code>值。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="20fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先调用<code class="fe nt nu nv nk b">possibleExits</code>得到两个房间共享的最左边和最右边允许的<code class="fe nt nu nv nk b">x</code>值。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="c9df" class="no lr iq nk b gy np nq l nr ns">let {start, end} = this.possibleExits(room, axis, wall);</span></pre><p id="5f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们找到最左边和最右边值的平均值，并得出路径的开始和结束<code class="fe nt nu nv nk b">x</code>值。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="4418" class="no lr iq nk b gy np nq l nr ns">`path.start[axis] = path.end[axis] = Math.round((start+end)/2);</span></pre><p id="7294" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最终批准了这条路，并返回。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="0024" class="no lr iq nk b gy np nq l nr ns">path.allowed = true;    </span><span id="77e0" class="no lr iq nk b gy om nq l nr ns">return path;</span></pre><p id="590b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nt nu nv nk b">possibleExits</code>和<code class="fe nt nu nv nk b">placePath</code>都完成后，我们现在可以在<code class="fe nt nu nv nk b">addVertPath</code>里面调用<code class="fe nt nu nv nk b">placePath</code>来得到垂直线的<code class="fe nt nu nv nk b">x</code>坐标。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="d850" class="no lr iq nk b gy np nq l nr ns">Room.prototype.addVertPath = function(room, path, wall) {  </span><span id="0919" class="no lr iq nk b gy om nq l nr ns">     path.start.y = Math.min(this.end.y,room.end.y) + 1;   <br/>    <br/>     path.end.y = Math.max(this.start.y,room.start.y) - 1; </span><span id="da18" class="no lr iq nk b gy om nq l nr ns">    <strong class="nk ir"> path = this.placePath(room,path,wall,'x')</strong><br/>}</span></pre><p id="cb2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们检查路径是否被允许。如果是这样，我们将其添加到游戏地图中，并使房间成为邻居。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="b222" class="no lr iq nk b gy np nq l nr ns">   path = this.placePathX(room,path,wall);<br/> <br/><strong class="nk ir">   if (path.allowed) {</strong></span><span id="c85c" class="no lr iq nk b gy om nq l nr ns"><strong class="nk ir">       game.addPath(path);</strong></span><span id="3e4b" class="no lr iq nk b gy om nq l nr ns"><strong class="nk ir">       this.addNeighbor(room);<br/>   }<br/>   return path;</strong></span><span id="3e90" class="no lr iq nk b gy om nq l nr ns">}</span></pre><p id="0701" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nt nu nv nk b">addPath</code>法较早被覆盖，以下为<code class="fe nt nu nv nk b">addNeighbor</code>法。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="427b" class="no lr iq nk b gy np nq l nr ns">Room.prototype.addNeighbor = function(room) {<br/>   this.neighbors.push(room);<br/>   room.neighbors.push(this);<br/>}</span></pre><p id="c33f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的<code class="fe nt nu nv nk b">addVertPath</code>一体法。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The complete addVertPath method.</figcaption></figure><p id="7571" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干得好。我们现在有了在两个相对的房间之间添加垂直路径所需的所有逻辑。</p><h2 id="8471" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">添加水平路径</h2><p id="79b5" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">让我们以类似的方式开始<code class="fe nt nu nv nk b">addHorizPath</code>方法。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="fc25" class="no lr iq nk b gy np nq l nr ns">Room.prototype.addHorizPath = function(room, path, wall) {</span><span id="569d" class="no lr iq nk b gy om nq l nr ns">}</span></pre><p id="0053" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们根据左边的房间来确定路径的起始瓦片。我们找到两个<code class="fe nt nu nv nk b">end.x</code>坐标中较小的一个，并添加一个图块。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="3c59" class="no lr iq nk b gy np nq l nr ns">path.start.y = Math.min(this.end.y,room.end.y) + 1;</span></pre><p id="a756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了计算路径的终点，我们找到两个<code class="fe nt nu nv nk b">start.x</code>坐标中较大的一个并减去一个图块。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="0faf" class="no lr iq nk b gy np nq l nr ns">path.end.x = Math.max(this.start.x,room.start.x) - 1;</span></pre><p id="efb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们称<code class="fe nt nu nv nk b">placePath</code>为<code class="fe nt nu nv nk b">y</code>坐标。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="954c" class="no lr iq nk b gy np nq l nr ns">path = this.placePath(room,path,wall,'y');</span></pre><p id="dba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其余与<code class="fe nt nu nv nk b">addVertPath</code>相同。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="f379" class="no lr iq nk b gy np nq l nr ns">if (path.allowed) {</span><span id="c0e6" class="no lr iq nk b gy om nq l nr ns">    game.addPath(path);</span><span id="d7c9" class="no lr iq nk b gy om nq l nr ns">    this.addNeighbor(room);<br/>}<br/>return path;</span></pre><p id="99c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些都是用一条线连接路径所需的方法。</p><h2 id="91fc" class="no lr iq bd ls nz oa dn lw ob oc dp ma ko od oe me ks of og mi kw oh oi mm oj bi translated">测试你的游戏</h2><p id="04ab" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在这一点上，你的游戏应该是功能性的，所以这是一个测试的好时机。下面是一个代码笔，供你比较你的工作。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="pd ol l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The completed phase 2 where rooms can connect with straight lines.</figcaption></figure></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="aa20" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">建议的后续步骤</h1><p id="3232" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">要微调您的路径，使它们不能彼此相邻，请尝试下面的教程。</p><div class="pe pf gp gr pg ph"><a href="https://nevkatz.medium.com/tuning-passage-placement-algorithm-in-a-javascript-roguelike-ae6273d9366f" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">调整JavaScript脚本中的段落位置</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">让我们用更好的算法来减少混乱。</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">nevkatz.medium.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv jw ph"/></div></div></a></div><p id="ca87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的玩家可能无法到达每个房间，但不要担心——在下面的文章中，我们将通过连接彼此对角的房间来创建一个更加统一的地牢。</p><div class="pe pf gp gr pg ph"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-roguelikes-connecting-diagonal-dungeon-rooms-using-corners-79f460f96615"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">用JavaScript的Roguelike构建带角的段落</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">让我们用两条在拐角处相交的小路把对角交叉的房间连接起来。</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pq l"><div class="pw l ps pt pu pq pv jw ph"/></div></div></a></div><p id="ee08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论你是通读了这篇文章，还是正在构建游戏，我希望这篇文章能增强你对JavaScript、算法以及roguelike游戏如何工作的理解。日安！</p><p id="9e01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ni">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ni">说白了就是</em> </strong> </a> <em class="ni">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ni">免费周报</em> </strong> </a> <em class="ni">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="ni">Twitter</em></strong></a><em class="ni">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="ni">LinkedIn</em></strong></a><em class="ni">。加入我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ni">社区</em> </strong> </a> <em class="ni">。</em></p><p id="8d92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ni">并考虑注册</em><a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"><strong class="kf ir"><em class="ni">Medium</em></strong></a><em class="ni">无限制访问我以及其他作家的文章。</em></p></div></div>    
</body>
</html>