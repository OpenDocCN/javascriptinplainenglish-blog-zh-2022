<html>
<head>
<title>Bundle React Apps with esbuild and Bash Script</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将React应用与esbuild和Bash脚本捆绑在一起</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/bundle-react-apps-with-esbuild-and-bash-script-d11877ae1985?source=collection_archive---------9-----------------------#2022-05-24">https://javascript.plainenglish.io/bundle-react-apps-with-esbuild-and-bash-script-d11877ae1985?source=collection_archive---------9-----------------------#2022-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3d9a59320d5a1b9aea8e9c9e37693bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpVl2PTuGIFm6vUFQA3odw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A Custom Build Setup for React Apps with esbuild and Bash</figcaption></figure><p id="f734" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇简短而实用的文章中，让我们快速了解一下构建React应用程序的另一种方法，使用一个更高效、更现代的构建工具，该工具依赖于ES模块，名为<a class="ae la" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> esbuild </a>和一个手工编码的定制bash脚本。</p><h1 id="ca34" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">背景和意图:</h1><p id="2a59" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">本文中提出的想法和步骤来自于我最近做的一些研究，这些研究旨在找出webpack构建工具的一些替代方法，这将加快构建时间。</p><p id="7e7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在穿越那个兔子洞的时候，我探索了一个叫做<a class="ae la" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank"> Vite </a>的工具。在简要查看该工具的开源代码库时，我注意到该工具使用了一种巧妙的技术作为特定限制的变通方法。</p><h2 id="13e0" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">局限性:</h2><p id="5f3f" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">因此，高度简化的限制描述如下:</p><p id="a155" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">浏览器对它们可以同时执行的并行网络请求的最大数量有限制。</p><p id="0b04" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在一个相当大的项目中，这些模块可以达到数百个的规模。由于浏览器的并行网络调用执行，这将减慢开发模式下的应用程序重新加载时间，并且随着模块数量超过浏览器允许的并行调用阈值，情况会变得更糟。</p><h2 id="fcef" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">解决方案是:</h2><p id="430a" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">Vite工具使用另一个名为esvuild的工具在内部处理这个场景。它的方式是捆绑所有相关的模块(例如，来自同一个库)，然后输出一个组合的模块，而不是多个模块，这样就减少了开发过程中构建系统产生的模块数量。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/4a63e557bc19f0de11ffe31b56a713a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QkTtwEcOsa8qdWbOXjvFiA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source code of Vite, illustrating the use of esBuild within the tool</figcaption></figure><h2 id="f7ef" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">意图:</h2><p id="6559" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">因此，上述发现引发了《修补匠在我》的思考。我想为什么不尝试使用esBuild工具和一些定制的bash脚本来构建一个基本的构建系统呢？</p><p id="0849" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这更像是一个有趣的实验，以了解构建一个构建和捆绑系统背后的真正原因。因此，这里给出的解决方案是一个非常原始的解决方案，虽然它可能适用于小规模项目，但我不建议将其用于任何生产系统。</p><p id="4905" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你也是一个好奇的人，并且在弄清楚某些东西是如何工作的之前不能停止思考，那么把这篇文章当作一个书呆子伙伴，分享他在一个慵懒的周日晚上，在几个小时内完成的东西，试图了解一个工具的工作机制。仅此而已。</p><p id="cb0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也就是说，来吧，让我们戴上我们的maker帽子，开始创建一个工作构建系统来捆绑和发布React应用程序。</p><h1 id="7a36" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">应用代码:</h1><p id="6938" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">嗯，要从源代码构建react应用程序，显然首先需要一个应用程序源代码:)。因此，让我们快速创建一个简单的演示应用程序，类似于<code class="fe mv mw mx my b">create-react-app</code> scaffolder附带的程序。</p><p id="2df3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> app.js: </strong></p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="3018" class="me lc iq my b gy nd ne l nf ng">// src/app/app.js</span><span id="dd1f" class="me lc iq my b gy nh ne l nf ng">import style from "../styles/app.module.css";<br/>import CustomLogo from '../assets/img/logo.svg';<br/><br/>export default function () {<br/>  return (<br/>    &lt;div className={style.appContainer}&gt;<br/>      &lt;CustomLogo/&gt;<br/>      &lt;h1&gt;React Quick Build Template&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="2e23" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> index.js: </strong></p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="0c45" class="me lc iq my b gy nd ne l nf ng">// src/app/index.js</span><span id="8b23" class="me lc iq my b gy nh ne l nf ng">import * as ReactDOM from 'react-dom';<br/>import App  from "./app";<br/><br/>const appRootElement = document.getElementById('app-root');<br/>const root = ReactDOM.createRoot(appRootElement);<br/><br/>root.render(&lt;App/&gt;);</span></pre><p id="78db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我们所看到的，我们保持了应用程序代码的最小化和简单，这样我们就可以有足够的空间来关注我们想要的主题，即构建系统。</p><p id="87da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们添加一些基本的风格，这样演示看起来就不会乏味了:</p><p id="2283" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">应用程序模块css: </strong></p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="13b4" class="me lc iq my b gy nd ne l nf ng">/* src/styles/app.module.css */</span><span id="9b1e" class="me lc iq my b gy nh ne l nf ng">body {<br/>  background: rgb(246, 82, 82);<br/>  background: linear-gradient(<br/>    90deg,<br/>    rgba(246, 82, 82, 1) 0%,<br/>    rgba(244, 183, 22, 1) 100%<br/>  );<br/>  color: #fefefe;<br/>  font-family: monospace;<br/>}<br/><br/>.appContainer {<br/>  display: flex;<br/>  flex-direction: column;<br/>  align-items: center;<br/>  justify-content: center;<br/>  height: 100vh;<br/>}</span></pre><p id="a22f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另外，请注意我们在<code class="fe mv mw mx my b">app.js</code>文件中使用的是SVG图像。我们将需要适当的加载器来处理这个和<code class="fe mv mw mx my b">CSS module file</code>,同时创建构建。让我们在下一步看看。</p><h1 id="fa30" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Package.json文件:</h1><p id="7205" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">所以我们有我们的应用程序代码，但是我们没有诸如React和React-DOM这样的依赖关系。像往常一样，让我们从这个项目的根开始启动一个npm或yarn项目:</p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="93b2" class="me lc iq my b gy nd ne l nf ng">yarn init -y</span></pre><p id="a6cb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">执行上面的命令会在项目的根目录下创建<code class="fe mv mw mx my b">package.json</code>文件。让我们修改它，使它看起来像下面这样:</p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="664a" class="me lc iq my b gy nd ne l nf ng">// package.json</span><span id="a7fb" class="me lc iq my b gy nh ne l nf ng">{<br/>  "name": "esbuild_demo",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "build": "chmod +X ./scripts/build.sh &amp;&amp; ./scripts/build.sh"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  "devDependencies": {<br/>    "@svgr/core": "^6.2.1",<br/>    "css-tree": "^2.1.0",<br/>    "esbuild": "^0.14.36",<br/>    "esbuild-css-modules-plugin": "^2.2.15",<br/>    "esbuild-plugin-svgr": "^1.0.1"<br/>  },<br/>  "dependencies": {<br/>    "react": "^18.0.0",<br/>    "react-dom": "^18.0.0"<br/>  }<br/>}</span></pre><p id="fc7f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，我们有一个运行shell脚本的build命令，该脚本将在下一步中创建。此外，还有一些开发依赖项，用于以下目的:</p><ol class=""><li id="0963" class="ni nj iq ke b kf kg kj kk kn nk kr nl kv nm kz nn no np nq bi translated"><code class="fe mv mw mx my b">esbuild</code>:基于ES模块的工具，我们将使用它来构建、缩小和捆绑我们的应用。</li><li id="d473" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated"><code class="fe mv mw mx my b">@svgr/core</code>和<code class="fe mv mw mx my b">esbuild-plugin-svgr</code>:esbuild-plugin-svgr插件使我们能够使用SVG图像作为React组件，并使它们能够被正确构建。这个插件依赖于svgr核心库。</li><li id="c484" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated"><code class="fe mv mw mx my b">css-tree</code>和<code class="fe mv mw mx my b">esbuild-css-modules-plugin</code>:插件使我们能够在应用程序中正确地使用和构建CSS模块。它对css树库有一个内部依赖。</li></ol><p id="38d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可能已经注意到，esBuild工具有一个丰富的插件系统。如果你有兴趣使用一个或者自己写一个<a class="ae la" href="https://esbuild.github.io/plugins/" rel="noopener ugc nofollow" target="_blank">这个文档</a>可能是一个起点。</p><p id="65c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这一步结束时，不要忘记运行<code class="fe mv mw mx my b">yarn</code>或<code class="fe mv mw mx my b">npm i</code>来安装依赖项。</p><h1 id="122c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构建脚本:</h1><p id="86fc" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">如果您已经使用基于UNIX的操作系统有一段时间了，那么很有可能您已经对使用<code class="fe mv mw mx my b">Bash</code>脚本可以做的事情有所了解。</p><p id="14cd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它既简单又强大。此外，如果您熟悉一般的语法和命令，在几分钟内编写一个像样的脚本会更容易。因此，用bash编写构建脚本是我个人的选择。您可以随意用您选择的任何其他脚本语言替换它，但是请记住在package.json文件中相应地更新构建脚本。</p><p id="9bf6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> build.sh : </strong></p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="7248" class="me lc iq my b gy nd ne l nf ng">#!/bin/bash</span><span id="db93" class="me lc iq my b gy nh ne l nf ng"><em class="nw"># </em>scripts/build.sh</span><span id="ff2d" class="me lc iq my b gy nh ne l nf ng">rm -rf dist<br/>mkdir dist<br/><br/>cp src/public/index.html dist<br/><br/>esbuild=$(<br/>  node scripts/bundle.js \<br/>    2&gt;&amp;1<br/>)<br/><br/>jsfile=$(echo $esbuild | tr '\n' '\r' | sed -r "s/^.*(app-.*js).*$/\1/")<br/><br/><br/>sed -i -r "s/&lt;\/body&gt;/&lt;script src=\".\/$jsfile\"&gt;&lt;\/script&gt;&lt;\/body&gt;/" dist/index.html<br/><br/>rm dist/index.html-r<br/><br/>echo "Build completed"</span></pre><p id="d1f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，这个脚本不做太多的错误处理。正如我上面提到的，这是一个概念验证，快速旋转。但是，如果你感兴趣并且有足够的带宽，这可能是一个可以改进的地方。</p><p id="da55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该脚本只执行以下操作:</p><ol class=""><li id="a8fc" class="ni nj iq ke b kf kg kj kk kn nk kr nl kv nm kz nn no np nq bi translated">删除已经存在的目录，这样我们每次都会创建一个干净的构建。</li><li id="8709" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated">创建<code class="fe mv mw mx my b">dist</code>目录。</li><li id="1269" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated">将基本HTML模板复制到创建的目录中。</li><li id="72e9" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated">基于一个包配置文件运行esbuild命令，我们将在下一节中看到。</li><li id="fd35" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated">使用流编辑器以<code class="fe mv mw mx my b">app-&lt;hash&gt;.js</code>的格式获取带有附加哈希值的js包文件名</li><li id="a5f1" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated">我们再次使用流编辑器读取复制到<code class="fe mv mw mx my b">dist</code>文件夹中的HTML文件，并用构建工具生成的文件替换<code class="fe mv mw mx my b">script</code>标签的<code class="fe mv mw mx my b">src</code>属性的值。</li></ol><h1 id="ba47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">捆绑包配置:</h1><p id="3d81" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">正如您在构建脚本中注意到的那样，捆绑是由一个名为<code class="fe mv mw mx my b">bundle.js</code>的文件处理的。让我们快速看一下它包含的内容:</p><p id="0a5d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> bundle.js : </strong></p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="21ae" class="me lc iq my b gy nd ne l nf ng">#!/usr/bin/env node</span><span id="6bca" class="me lc iq my b gy nh ne l nf ng">// scripts/bundle.js</span><span id="5e6b" class="me lc iq my b gy nh ne l nf ng">const cssModulesPlugin = require("esbuild-css-modules-plugin");<br/>const svgrPlugin = require('esbuild-plugin-svgr');<br/><br/>require("esbuild")<br/>  .build({<br/>    logLevel: "info",<br/>    entryPoints: ["src/app/index.js"],<br/>    inject:["scripts/react-shim.js"],<br/>    treeShaking: true,<br/>    bundle: true,<br/>    outfile: "dist/app.js",<br/>    plugins: [svgrPlugin(), cssModulesPlugin()],<br/>    loader: {<br/>        ".js": "jsx",<br/>    },<br/>    minify: true,<br/>    target: "es2015",<br/>    entryNames: "[name]-[hash]",<br/>    color: true,<br/>  })<br/>  .catch(() =&gt; process.exit(1))<br/>  .then(() =&gt; {});</span></pre><p id="d238" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个包配置可以作为bash shell中的节点脚本运行，这正是我们正在做的。</p><p id="48e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">包配置基本上是不言自明的，类似于您过去可能使用过的其他构建工具配置。</p><p id="d5bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里值得一提的一件有趣的事情是<code class="fe mv mw mx my b">inject</code>属性。它加载一个<code class="fe mv mw mx my b">react-shim.js</code>文件。让我们在下一节看看这意味着什么。</p><h1 id="c16a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React垫片注射:</h1><p id="8b5b" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">您可能已经注意到，我们没有在任何应用程序代码中导入React。如果你使用最新版本的<code class="fe mv mw mx my b">create-react-app</code> scaffolder，你可能会对此习以为常。</p><p id="dd6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mv mw mx my b">create-react-app</code>通过webpack设置实现了这种便利。我们在这里用esBuild注入来模拟同样的情况。</p><p id="66a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> react-shim.js: </strong></p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="f9a0" class="me lc iq my b gy nd ne l nf ng">// scripts/react-shim.js</span><span id="92da" class="me lc iq my b gy nh ne l nf ng">import * as React from 'react'<br/>export { React }</span></pre><h1 id="04b1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们的定制构建设置正在运行:</h1><p id="e6c5" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">既然我们已经完成了工作，让我们来测试一下。从项目的根开始，让我们运行<code class="fe mv mw mx my b">yarn build</code>或<code class="fe mv mw mx my b">npm run build</code>:</p><p id="96a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输出的gif:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/553988c0ab74750f74204291e57a7564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lgRFwbpOJK3CQopjF_bQCw.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Our Custom Build System in Action</figcaption></figure><h1 id="58fe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">局限性和进一步改进:</h1><p id="25b2" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我们的定制构建设置更多的是概念验证，缺乏某些细节，导致一些限制:</p><ol class=""><li id="b92b" class="ni nj iq ke b kf kg kj kk kn nk kr nl kv nm kz nn no np nq bi translated">我们还没有设置任何开发服务器。这可能是当前设置中需要探索和改进的地方。</li><li id="6738" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated">该脚本假设构建命令是从项目根目录运行的，我们可以给它增加一些灵活性并去掉这个假设。</li><li id="8000" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated">构建脚本可以被改进以优雅地处理错误。</li><li id="c6ec" class="ni nj iq ke b kf nr kj ns kn nt kr nu kv nv kz nn no np nq bi translated">这种设置对于基于<code class="fe mv mw mx my b">Jest</code>的单元测试的代码库来说效果不好，因为Jest还不支持es模块。</li></ol><h1 id="5f2c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论:</h1><p id="c2a4" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">因此，我们有了自己的构建设置，这很有效，通过设置过程，我们已经了解了相当多的内部信息，这在解决下一个棘手的部署问题时可能会派上用场，也可能不会派上用场；)</p><p id="4d6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想亲自尝试这个设置，请随意克隆这个<a class="ae la" href="https://github.com/Parthipan-Natkunam/React-ESbuild" rel="noopener ugc nofollow" target="_blank"> Github库</a>。</p><p id="29f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢你的时间，我希望你能把这些新发现的知识用在好的地方。让我们在下一篇文章中赶上。</p><p id="a5c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">干杯。:)</p><p id="fc09" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nw">更多内容尽在</em> <a class="ae la" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nw">说白了. io </em> </strong> </a> <em class="nw">。报名参加我们的</em> <a class="ae la" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nw">免费周报</em> </strong> </a> <em class="nw">。关注我们关于</em> <a class="ae la" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nw">推特</em> </strong> </a> <em class="nw">和</em><a class="ae la" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="nw">LinkedIn</em></strong></a><em class="nw">。查看我们的</em> <a class="ae la" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nw">社区不和谐</em> </strong> </a> <em class="nw">加入我们的</em> <a class="ae la" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nw">人才集体</em> </strong> </a> <em class="nw">。</em></p></div></div>    
</body>
</html>