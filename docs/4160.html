<html>
<head>
<title>How Does the useDeferredValue Hook Work in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">useDeferredValue挂钩在React中是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-usedeferredvalue-b510b375bb1d?source=collection_archive---------9-----------------------#2022-11-01">https://javascript.plainenglish.io/react-usedeferredvalue-b510b375bb1d?source=collection_archive---------9-----------------------#2022-11-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="adab" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用“useDeferredValue”挂钩，通过推迟耗时的更新以允许关键更新快速发生来提高性能。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9ff85c687f1cf6c2f2c26674a7acb93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huJ25OvBShRsyQPwkC4wgg.png"/></div></div></figure><p id="8e06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React now在版本18中提供了并发支持。现在有许多功能可以帮助更好地利用系统资源和提升应用程序性能。一个这样的特性是<code class="fe lk ll lm ln b">useDefferedValue</code>钩子，在本文中我们将学习<code class="fe lk ll lm ln b">useDeferredValue</code>并理解我们可以使用它的场景。</p><h1 id="7966" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">我们为什么需要<code class="fe lk ll lm ln b">useDefferedValue</code>？</h1><p id="a490" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">在我们看到这个钩子的运行之前，我们需要了解React如何管理状态和更新DOM。</p><p id="715d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我们有以下代码:</p><p id="8f00" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">App.js</code></p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="859b" class="mp lp in ln b gy mq mr l ms mt">export default function App() {<br/>  const [name, setName] = useState('');</span><span id="927e" class="mp lp in ln b gy mu mr l ms mt">  const computedValue = useMemo(() =&gt; {<br/>    return getComputedValue(name);<br/>  }, [name]);</span><span id="17b7" class="mp lp in ln b gy mu mr l ms mt">  const handleChange = (event) =&gt; {<br/>    setName(event.target.value);<br/>  };</span><span id="3487" class="mp lp in ln b gy mu mr l ms mt">  return (<br/>    &lt;input<br/>      type="text"<br/>      placeholder="Username"<br/>      value={name}<br/>      onChange={handleChange}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="7fdf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们用<code class="fe lk ll lm ln b"><a class="ae mv" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code>钩子创建了一个状态变量，并从状态中导出了一个计算值(<code class="fe lk ll lm ln b">computedValue</code>)。只有当状态改变时，我们才使用<code class="fe lk ll lm ln b"><a class="ae mv" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code>钩子来重新计算计算值。</p><p id="5b9f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，当输入字段的值改变时，<code class="fe lk ll lm ln b">name</code>状态变量被更新，并且在DOM被更新之前重新计算计算出的值。</p><p id="7d6a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这通常不是问题，但有时这种重新计算过程涉及大量计算，需要很长时间才能完成。这可能会降低性能和用户体验。</p><p id="aad5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，我们可以开发一个功能，让用户在一个巨大的列表中搜索一个项目:</p><p id="1362" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">App.js</code></p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="b40c" class="mp lp in ln b gy mq mr l ms mt">function App() {<br/>  const [query, setQuery] = useState('');</span><span id="0db5" class="mp lp in ln b gy mu mr l ms mt">  const list = useMemo(() =&gt; {<br/>    // 👇 Filtering through large list impacts performance<br/>    return largeList.filter((item) =&gt; item.name.includes(query));<br/>  }, [query]);</span><span id="bfae" class="mp lp in ln b gy mu mr l ms mt">  const handleChange = (event) =&gt; {<br/>    setQuery(event.target.value);<br/>  };</span><span id="aa2c" class="mp lp in ln b gy mu mr l ms mt">  return (<br/>    &lt;&gt;<br/>      &lt;input type="text" value={query} onChange={handleChange} placeholder="Search"/&gt;<br/>      {list.map((item) =&gt; (<br/>        &lt;SearchResultItem key={item.id} item={item} /&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="1368" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个例子中，我们有一个查询状态变量用于过滤一个巨大的条目列表。列表越长，完成过滤和更新<code class="fe lk ll lm ln b">list</code>变量以完成DOM更新所需的时间就越长。</p><p id="d6c5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，当用户在输入字段中键入内容时，过滤将导致DOM更新延迟，输入中的文本需要一段时间才能立即反映用户键入的内容。这种缓慢的反馈会对你的应用对用户的反应产生负面影响。</p><p id="9c16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我在下面的演示中模拟了缓慢，这样你可以更好地理解这个问题。只有几个搜索结果供您正确地可视化，它们都是输入到输入字段中的内容的大写字母。</p><p id="0285" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个演示中，我尽可能快地一个接一个地输入每个字符，但是由于人为的缓慢，我的击键需要大约一秒钟来改变输入的文本。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ebd95a45d7152859ca3dfb159f927fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/0*crdwyIAkxbHWGWwX.gif"/></div></figure><h1 id="9727" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated"><code class="fe lk ll lm ln b">useDeferredValue</code>在行动</h1><p id="daba" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">在这种情况下，<code class="fe lk ll lm ln b">useDeferredValue</code>挂钩非常方便。<code class="fe lk ll lm ln b">useDeferredValue()</code>接受一个状态值作为参数，并返回该值的副本，该副本将被延迟，即，当状态值被更新时，该副本不会相应地更新，直到DOM被更新以反映状态变化。这确保了紧急更新的发生，而不会被不太关键、耗时的更新所延迟。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="d241" class="mp lp in ln b gy mq mr l ms mt">function App() {<br/>  const [query, setQuery] = useState('');</span><span id="2303" class="mp lp in ln b gy mu mr l ms mt">  // 👇 useDefferedValue<br/>  const deferredQuery = useDefferedValue(query);</span><span id="9c29" class="mp lp in ln b gy mu mr l ms mt">  const list = useMemo(() =&gt; {<br/>    return largeList.filter((item) =&gt; item.name.includes(query));<br/>  }, [deferredQuery]);</span><span id="38ac" class="mp lp in ln b gy mu mr l ms mt">  const handleChange = (event) =&gt; {<br/>    setQuery(event.target.value);<br/>  };</span><span id="06dc" class="mp lp in ln b gy mu mr l ms mt">  return (<br/>    &lt;&gt;<br/>      &lt;input type="text" value={query} onChange={handleChange} placeholder="Search" /&gt;<br/>      {list.map((item) =&gt; (<br/>        &lt;SearchResultItem key={item.id} item={item} /&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="40a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，我们之前的代码被修改成使用<code class="fe lk ll lm ln b">useDeferredValue</code>钩子。和以前一样，当用户键入时，<code class="fe lk ll lm ln b">query</code>状态变量将被更新，但是这一次，<code class="fe lk ll lm ln b">useMemo</code>不会被立即调用来过滤大列表，因为现在<code class="fe lk ll lm ln b">deferredQuery</code>是依赖关系<code class="fe lk ll lm ln b">useMemo</code>正在监视变化，并且<code class="fe lk ll lm ln b">useDeferredValue</code>确保在<code class="fe lk ll lm ln b">query</code>被更新并且组件被重新呈现之前<code class="fe lk ll lm ln b">deferredQuery</code>不会被更新。</p><p id="df68" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于<code class="fe lk ll lm ln b">useMemo</code>不会被调用，并且不会因为<code class="fe lk ll lm ln b">query</code>状态的改变而阻止DOM更新，所以UI会及时更新，并且一旦用户输入，输入文本也会改变。这解决了响应问题。</p><p id="7524" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe lk ll lm ln b">query</code>状态更新后，<em class="mx">然后</em> <code class="fe lk ll lm ln b">deferredQuery</code>将被更新，导致<code class="fe lk ll lm ln b">useMemo</code>过滤大列表并重新计算<code class="fe lk ll lm ln b">list</code>变量的值，更新显示在输入字段下方的项目列表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/87461d7396c8b1b0aea206c87bd9bd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/0*igt-HhT7Db7DRb67.gif"/></div></figure><p id="01c7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如你在演示中看到的，当我输入时，文本会立即改变，但是列表会滞后，过一段时间会更新。</p><p id="890e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们在短时间内不断改变输入字段的文本(例如，通过快速输入)，那么<code class="fe lk ll lm ln b">deferredQuery</code>状态将保持不变，列表也不会更新。这是因为在<code class="fe lk ll lm ln b">useDeferredValue</code>能够被更新之前<code class="fe lk ll lm ln b">query</code>状态将保持变化，所以<code class="fe lk ll lm ln b">useDeferredValue</code>将继续延迟更新，直到它有时间将<code class="fe lk ll lm ln b">deferredQuery</code>设置为<code class="fe lk ll lm ln b">query</code>的最新值并更新列表。</p><p id="1f9e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我的意思是:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/6c68716b727472218fbc7ff91482fbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/0*KcBehHDUd_YsbnZJ.gif"/></div></figure><p id="b76c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这非常类似于去抖动，因为列表直到输入停止一段时间后才更新。</p><h2 id="eeb9" class="mp lp in bd lq my mz dn lu na nb dp ly kx nc nd ma lb ne nf mc lf ng nh me ni bi translated">小费</h2><p id="3f28" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">有时在我们的应用程序中，当事件发生时，我们会想要执行一个昂贵的动作。如果此事件在短时间内发生多次，该操作将重复多次，从而降低性能。为了解决这个问题，我们可以设置一个要求，即从事件最近一次发生起，动作只执行“X”次。这叫做<strong class="kq io">去抖</strong>。</p><p id="2718" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，在注册表单中，我们可以让请求在用户最后一次在用户名输入字段中键入用户名后500毫秒才被发送，而不是在用户输入时发送请求来检查数据库中的重复用户名(当然，我们可以在用户提交表单后执行重复检查，而不是近乎实时地执行)。</p><p id="8e10" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于<code class="fe lk ll lm ln b">useDeferredValue</code>钩子会延迟更新并导致额外的重新渲染，所以不要过度使用它是很重要的，因为这实际上会导致我们试图避免的性能问题，因为它会迫使React在你的应用中进行额外的重新渲染。只有当您有重要更新时才使用它，这些更新应该尽快进行，而不会被较低优先级的更新拖慢。</p><h1 id="0ea7" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">结论</h1><p id="abfb" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated"><code class="fe lk ll lm ln b">useDeferred</code>值接受一个状态变量并返回它的一个副本，该副本直到组件从原始状态的更新中重新呈现后才会被更新。这提高了应用程序的性能和响应能力，因为耗时的更新被推迟到以后进行，以便为那些应该在DOM中毫不延迟地显示给用户的关键更新让路。</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><p id="84a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">【codingbeautydev.com】原载于<a class="ae mv" href="https://cbdev.link/96f1b6" rel="noopener ugc nofollow" target="_blank"><em class="mx"/></a></p><h1 id="0e60" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">JavaScript做的每一件疯狂的事情</h1><p id="e18c" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">一本关于JavaScript微妙的警告和鲜为人知的部分的迷人指南。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/143ee152ba78025ea8643ba5b9726a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*YS5Oub8REWy8vnOEqBnsyQ.png"/></div></figure><p id="7d6e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae mv" href="https://cbdev.link/d3c4eb" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">报名</strong> </a>立即免费领取一份。</p></div></div>    
</body>
</html>