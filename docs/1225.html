<html>
<head>
<title>How to Create a Dynamic React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建动态的React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-dynamic-react-app-49e02d303436?source=collection_archive---------3-----------------------#2022-03-10">https://javascript.plainenglish.io/how-to-create-a-dynamic-react-app-49e02d303436?source=collection_archive---------3-----------------------#2022-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3094" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">创建动态React应用程序的指南。</h2></div><p id="958b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以…你想构建一个用户和开发者都可以轻松导航的应用程序，它的元素可以在你代码中的任何地方重用，并且更容易编写和理解？似乎不可能，对吧？也许我们真的永远注定要手工选择DOM上的每一个元素，并无休止地修改它，直到完美为止。或者，我们可以试着反应一下。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="ba95" class="lf lg in bd lh li lj lk ll lm ln lo lp jt lq ju lr jw ls jx lt jz lu ka lv lw bi translated">什么是反应？</h1><p id="1866" class="pw-post-body-paragraph kc kd in ke b kf lx jo kh ki ly jr kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">很高兴你问了！React是脸书创建的一个开发库，它允许开发人员将他们的代码分解成小块的、可重用的组件。组件是单独创建的，然后放在一起创建一个动态的、功能齐全的应用程序。以下是React组件以及它们如何一起构建应用程序的可视化效果:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/77814aea1d8e1bc80a270ac34811aa55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdI0YTnpoB3mb6S-7NJrMw.jpeg"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">React Components Visualization. Source: <a class="ae mp" href="https://www.techdiagonal.com/" rel="noopener ugc nofollow" target="_blank">https://www.techdiagonal.com/</a></figcaption></figure><p id="8ea9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里展示了四个组件，然后将它们放在一起创建一个完整的应用程序。请注意，有些组件在我们的应用程序中使用了不止一次。这就是React如此有用的原因！我们可以在应用程序中多次使用每个组件，而无需重写代码。</p><p id="f0b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个组件都是通过使用一个返回JSX的大写函数创建的，该函数看起来很像HTML:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="9f8e" class="mv lg in mr b gy mw mx l my mz">function Component(){<br/>  return(<br/>    &lt;h2&gt;Hello World&lt;/h2&gt;<br/>  )<br/>}</span></pre><p id="4eb4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想在应用程序的其他地方声明我们的组件，我们应该写:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="2117" class="mv lg in mr b gy mw mx l my mz">&lt;Component /&gt;</span></pre><p id="beb8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React允许我们返回与HTML (JSX)几乎相同的代码，使我们的代码更容易编写，也更容易被其他开发人员阅读和理解。在我最近使用React创建的应用程序中，我有几个组件，它们一起工作来创建最终形式的应用程序。让我们确定一下我添加到应用程序中的一些组件:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/6f3589a1898b50dfad8166fbe6466580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYOUJbB3IeFR1xP4TEGjkA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">A screenshot of my React application</figcaption></figure><p id="70c3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你能数出在我的动画应用程序的这个片段中显示了多少组件吗？我数了4个。导航栏、搜索栏、排序栏和标题卡都是独立的组件，都有各自的代码。将我的应用程序分解成独立的组件，让我更容易专注于应用程序每个部分的独立功能。使用React语法将组件组合成一个单独的应用程序，如下所示:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="69a3" class="mv lg in mr b gy mw mx l my mz">function App(){<br/>  return(<br/>    &lt;div&gt;<br/>      &lt;NavBar /&gt;<br/>      &lt;Search Bar /&gt;<br/>      &lt;SortBar /&gt;<br/>      &lt;TitleCard /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="cf73" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们将所有的组件组合成一个单一的应用程序组件来创建一个完整的应用程序！</p><p id="a727" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经了解了React和组件，以及为什么它们非常有用，但是我们还遗漏了一大块拼图！现在我们知道React组件<em class="mc">返回</em> JSX，看起来与HTML非常相似，我们想知道React组件<em class="mc">接受什么</em>作为参数，使这些组件如此动态。</p><h1 id="1fa5" class="lf lg in bd lh li nf lk ll lm ng lo lp jt nh ju lr jw ni jx lt jz nj ka lv lw bi translated">小道具</h1><p id="20ee" class="pw-post-body-paragraph kc kd in ke b kf lx jo kh ki ly jr kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">什么是道具，它们在React中有什么用？简单地说，props是传递给React组件的参数。道具作为属性传递，很像HTML中的。它们允许我们将不同的值传递给同一个组件，并得到不同的结果。让我们看一个来自我的React应用程序的例子:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="a0aa" class="mv lg in mr b gy mw mx l my mz">function AnimeCard({ <strong class="mr io">anime </strong>}){<br/>   return(<br/>        &lt;div &gt;<br/>            &lt;h2&gt;{anime.title}&lt;/h2&gt;<br/>            &lt;img src={<strong class="mr io">anime</strong>.<strong class="mr io">image</strong>} alt={<strong class="mr io">anime</strong>.<strong class="mr io">title</strong>}/&gt;<br/>            &lt;button&gt;'🤍 Favorite'&lt;/button&gt;<br/>            &lt;button&gt;'More Info...'&lt;/button&gt;<br/>        &lt;/div&gt;<br/>}</span></pre><p id="0065" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里传下来的道具叫动漫，在一个父组件中声明。您可能会注意到，每当我们在返回函数中使用{anime.title}时，它周围都有括号。当我们希望在React组件中返回Javascript而不是JSX时，我们需要指明它是Javascript，以便React可以为我们将它转换为JSX。请注意，我们可以将任何想要的动画对象传递给这段代码，只要它有标题和图像键。因此，我们可以在代码中的任何地方使用这个组件，传递一个带有标题和图像键的动画对象，一张卡片将在页面上呈现，显示我们传递的数据。下面是传递道具的样子:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="925a" class="mv lg in mr b gy mw mx l my mz">const anime1 = {<br/>  title: 'Attack on Titan',<br/>  image: "AOT.jpeg"<br/>}</span><span id="cb30" class="mv lg in mr b gy nk mx l my mz">const anime2 = {<br/>  title: 'Demon Slayer',<br/>  image: "DS.jpeg"<br/>}</span><span id="0e3b" class="mv lg in mr b gy nk mx l my mz">&lt;AnimeCard <strong class="mr io">anime={anime1}</strong>/&gt;<br/>&lt;AnimeCard <strong class="mr io">anime={anime2}</strong>/&gt;</span></pre><p id="c015" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，我们在这里还将声明的动画变量括起来，因为我们将Javascript传递给了JSX组件。这段代码将显示如下内容:</p><div class="me mf mg mh gt ab cb"><figure class="nl mi nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><img src="../Images/6adaf3fd67af047ad8f86bffe4340dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*LK63I3vBgJcsdX4TSvW1_w.png"/></div></figure><figure class="nl mi nr nn no np nq paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><img src="../Images/cfa2f88e8dd9291746762777c6d3063c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*Qjna2Q2xCFnRNBVYuSLK5A.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk ns di nt nu">Card Components from my react application</figcaption></figure></div><p id="e963" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们可以看到，由于使用了道具，同一个卡片组件可以在我的应用程序中多次使用，而且每张卡片上的数据不同。道具在我们的组件中非常有用，因为我们可以将几乎任何东西作为道具传递下去，甚至是函数！</p><h1 id="8d4f" class="lf lg in bd lh li nf lk ll lm ng lo lp jt nh ju lr jw ni jx lt jz nj ka lv lw bi translated">事件</h1><p id="4d8e" class="pw-post-body-paragraph kc kd in ke b kf lx jo kh ki ly jr kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">现在，我们知道如何用React创建一个基本的应用程序，但正如我们从我的上一篇帖子中所知，一个应用程序的交互性越强越好！我们应该关注几个事件，以增加用户的体验和参与度！但是我们如何做到这一点呢？我们知道如何在普通的Javascript中监听事件，通过定位DOM元素并向该元素添加事件监听器，但是如果我告诉您所有这些定位都是过去的事情了呢？要在React中检测一个事件，我们需要做的就是在我们要寻找的事件前面添加一个简单的关键字:'<em class="mc"> on </em>'。如果我们使用onClick侦听器，我们知道我们的JSX元素应该在被单击时做出反应；如果我们使用onChange侦听器，那么它应该在发生变化时做出反应；这同样适用于onSubmit、onLoad和页面上发生的任何其他事件。让我们来看看我在react应用程序中添加到搜索栏的变更事件监听器:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="d3da" class="mv lg in mr b gy mw mx l my mz">&lt;input className="search" type="text" placeholder="Search..." value={input} <strong class="mr io">onChange={handleChange}</strong>&gt;&lt;/input&gt;</span></pre><p id="220c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我将一个<em class="mc"> onChange </em>事件添加到我的&lt; input &gt;标签中，这样每当字段被更改时(即另一个字母被键入或删除)，函数handleChange就会被调用。我们在这里看到，react为我们向JSX元素添加事件侦听器提供了一个非常简单的方法。</p><p id="5055" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，在为我们的应用程序添加动态和变化方面，这并不是React为我们做的全部。React还为我们提供了一个奇妙的功能，叫做<em class="mc">状态</em>。</p><h1 id="0ce5" class="lf lg in bd lh li nf lk ll lm ng lo lp jt nh ju lr jw ni jx lt jz nj ka lv lw bi translated">状态</h1><p id="5b33" class="pw-post-body-paragraph kc kd in ke b kf lx jo kh ki ly jr kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated"><em class="mc">状态</em>是随着用户与你的应用程序交互而不断变化的数据。在上面的例子中，我们希望输入值是一个状态值，因为每次有人在表单中输入时它都会改变。让我们看一个深入的例子来更好地理解这个状态。为了访问状态，我们需要从react导入它，并在React组件中声明它:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="a5bf" class="mv lg in mr b gy mw mx l my mz">import React, <strong class="mr io">{ useState }</strong> from 'react';</span><span id="202c" class="mv lg in mr b gy nk mx l my mz">function Search({ animes }){<br/>  <strong class="mr io">const [input, setInput] = useState('');</strong></span><span id="0f50" class="mv lg in mr b gy nk mx l my mz">// ...<br/>}</span></pre><p id="96d5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们把这段代码分解一下。我们可以看到{ useState }正在从reaction导入。我们必须导入它，以便在代码中使用state。接下来，让我们看看我们的变量声明。我们看到有一个数组，其中一个变量叫做<em class="mc"> input </em>，另一个变量叫做<em class="mc"> setInput </em>。这是因为State返回一个值(这是您在use State括号中声明的值，在我们的例子中是一个空字符串)和一个函数，该函数只是用来重置调用时给定的值。所以现在我们已经将<em class="mc">输入</em>变量设置为一个空字符串，但是如果我们调用<em class="mc">设置输入</em>，那么我们作为参数传入的任何内容都将成为我们新的<em class="mc">输入</em>变量。让我们继续:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="b666" class="mv lg in mr b gy mw mx l my mz">function Search({ animes }){<br/>  const [input, setInput] = useState('');</span><span id="36da" class="mv lg in mr b gy nk mx l my mz">  <strong class="mr io">const animeList = animes.filter((anime)=&gt;{<br/>    return anime.title.toLowerCase().includes(input.toLowerCase())<br/>   })</strong></span><span id="f158" class="mv lg in mr b gy nk mx l my mz">   //...</span><span id="3dff" class="mv lg in mr b gy nk mx l my mz">}</span></pre><p id="55a7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们可以看到我们使用<em class="mc">输入</em>变量的目的。我们想创建一个过滤的动画列表，只包含我们的标题包含<em class="mc">输入</em>变量的动画，即用户正在输入的内容。接下来的大问题是，我们怎样才能根据用户类型来改变动画列表？这就是<em class="mc">设置状态</em>的地方！</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="bea0" class="mv lg in mr b gy mw mx l my mz">function Search({animes}){<br/>  const [input, setInput] = useState('');</span><span id="8ad1" class="mv lg in mr b gy nk mx l my mz">  const animeList = animes.filter((anime)=&gt;{<br/>      return anime.title.toLowerCase().includes(input.toLowerCase())<br/>   })</span><span id="6904" class="mv lg in mr b gy nk mx l my mz">   console.log(animeList);</span><span id="6b79" class="mv lg in mr b gy nk mx l my mz">   <strong class="mr io">function handleChange(e){<br/>      setInput(e.target.value);<br/>    }</strong></span><span id="ca59" class="mv lg in mr b gy nk mx l my mz">   return(  <br/>       &lt;input className="search" type="text" placeholder="Search..."<br/>        <strong class="mr io">value={input}</strong> <strong class="mr io">onChange={handleChange}</strong>&gt;&lt;/input&gt;<br/>}</span></pre><p id="9373" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们可以看到，每次用户键入时，我们都在重置输入变量。State不可思议的一点是，每次它重置时，整个组件都会重新渲染，因此每次用户键入时都会重新运行动画列表，每键入一个字母就会显示一个最新的动画列表！在我们的react应用程序中使用State和Event Listeners，我们拥有了创建一个动态的、用户交互的应用程序所需的一切！</p><p id="4cbf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是我使用反应状态能够实现的几个函数:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="7d4d" class="lf lg in bd lh li nf lk ll lm ng lo lp jt nh ju lr jw ni jx lt jz nj ka lv lw bi translated">客户端路由</h1><p id="d234" class="pw-post-body-paragraph kc kd in ke b kf lx jo kh ki ly jr kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">令人惊讶的是，我们已经学会了如何用反应组件、道具、事件和状态来创建一个完善的web应用程序。现在，我们需要担心的只是那个讨厌的小网址。你知道你放在浏览器中的小文本，它引导人们找到你的确切网站和站点页面吗？React应用程序是为了允许单页应用程序而创建的。这意味着我们的应用程序只需要使用初始的GET请求以及初始的HTML、CSS和JS。这使得很多事情变得更简单，但是我们需要一种方法来确保我们的URL反映我们想要显示的页面(或组件),而不必刷新页面。幸运的是，和其他所有事情一样，React让我们很容易做到这一点！</p><p id="b111" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React给了我们3个主要的钩子，我们可以用来让我们的URL对我们的使用有效:Route、Switch和NavLink。让我们先讨论路由和交换。</p><h2 id="1f77" class="mv lg in bd lh nx ny dn ll nz oa dp lp kl ob oc lr kp od oe lt kt of og lv oh bi translated">路由和交换机</h2><p id="7436" class="pw-post-body-paragraph kc kd in ke b kf lx jo kh ki ly jr kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">假设我们有一个叫www.anime-app.com的网站。我们有3个主要组件:主页、动画和收藏夹。这些组件中的每一个都包含非常不同的元素，我们希望它们能够被单独描述。反应给了我们一种导航到特定URL的方式，该URL只显示我们想要显示的组件:反应挂钩<em class="mc">路由</em>。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="440e" class="mv lg in mr b gy mw mx l my mz"><strong class="mr io">import { Route, Switch } from 'react-router-dom';</strong></span><span id="3b64" class="mv lg in mr b gy nk mx l my mz">. . . . .</span><span id="5ee9" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">&lt;Switch&gt;<br/>    &lt;Route path='/submit'&gt;</strong></span><span id="147c" class="mv lg in mr b gy nk mx l my mz">        &lt;AnimeForm /&gt;</span><span id="609d" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;/Route&gt;</strong></span><span id="5213" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;Route path='/favorites'&gt;</strong></span><span id="665d" class="mv lg in mr b gy nk mx l my mz">        &lt;Favorites /&gt;</span><span id="14ea" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;/Route&gt;</strong></span><span id="e876" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;Route path='/'&gt;</strong></span><span id="746b" class="mv lg in mr b gy nk mx l my mz">        &lt;Home /&gt;</span><span id="1446" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;/Route&gt;<br/>&lt;/Switch&gt;</strong></span></pre><p id="5f6b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在这里看到，为了使用<em class="mc"> Route </em>钩子，我们必须从‘react-router-DOM’中导入它。然后，我们需要将我们想要显示在单独页面上的组件包装在&lt; Route <em class="mc"> &gt; </em>标签中。在这个例子中，URL www.anime-app.com/<em class="mc">提交</em>将只显示<strong class="ke io">aniform</strong>组件。类似地，如果我们使用URL www.anime-app.com/<em class="mc">收藏夹</em>，只有<strong class="ke io">收藏夹</strong>组件会显示。如果我们使用URL www.anime-app.com<strong class="ke io">/</strong>，我们将被带到应用程序的<strong class="ke io"> Home </strong>组件。这确保了如果我们的用户特别想提交一个表单，他们可以通过表单的URL直接进入表单，而不必从主页开始。但是我们还没有完成。</p><p id="20e5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还需要用<switch>标签包装我们的路由，这些标签也是从“react-router-dom”导入的。在<switch class="mc"> &gt; 标签中包装我们的所有路线将确保这些组件不会同时呈现，如果它们具有相同的字符(即，如果在我们的URL中有'/list '，则不会同时调用'/list2 ')。React的开关钩子检查给定的第一个路径，并继续下去，直到找到与当前URL的任何部分匹配的路径。例如，如果我们将Home路径<em class="mc">移动到提交路径</em>之前，那么无论如何Home组件都会显示；这是因为它的路径('/')可以在我们给定的所有路径的<em class="mc">中找到。“/submit”和“/favorites”都包含“/”字符。因此，一旦Switch看到这个路径是我们的URL的一部分，它就停止寻找其他要显示的组件。因此，我们将Home组件<em class="mc">放在最后</em>，这样一来，只有当URL中既没有“/submit”也没有“/favorites”时，才会显示“/”路径。我们也可以通过使用属性<strong class="ke io"> exact </strong>来解决这个问题:</em></switch></switch></p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="0310" class="mv lg in mr b gy mw mx l my mz">&lt;Route <strong class="mr io">exact </strong>path='/'&gt;</span><span id="f527" class="mv lg in mr b gy nk mx l my mz">    &lt;Home /&gt;</span><span id="7776" class="mv lg in mr b gy nk mx l my mz">&lt;/Route&gt;</span></pre><p id="7998" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">精确</strong>属性使得组件仅在<em class="mc">精确</em>路径在URL中时才显示，而不仅仅是路径的<em class="mc">任何部分</em>匹配URL的<em class="mc"> </em>。</p><h2 id="1127" class="mv lg in bd lh nx ny dn ll nz oa dp lp kl ob oc lr kp od oe lt kt of og lv oh bi translated">NavLink</h2><p id="f881" class="pw-post-body-paragraph kc kd in ke b kf lx jo kh ki ly jr kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">现在，我们所需要的是一种方法，让我们的用户能够访问我们的其他组件，而不必在浏览器中手动键入URL。这就是NavLink的用武之地！以我的动漫app为例，让我们来看看NavLink及其在运行中的功能:</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="e5d5" class="mv lg in mr b gy mw mx l my mz"><strong class="mr io">import { NavLink } from 'react-router-dom'; </strong>//imports NavLink</span><span id="4b79" class="mv lg in mr b gy nk mx l my mz">. . .</span><span id="421b" class="mv lg in mr b gy nk mx l my mz">&lt;nav&gt;</span><span id="6849" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;NavLink  to='/'exact&gt;</strong></span><span id="8b1e" class="mv lg in mr b gy nk mx l my mz">        &lt;li&gt;&lt;a&gt;Home&lt;/a&gt;&lt;/li&gt;</span><span id="5056" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;/NavLink&gt;</strong></span><span id="4592" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;NavLink to='/favorites'&gt;</strong></span><span id="83d4" class="mv lg in mr b gy nk mx l my mz">        &lt;li&gt;&lt;a&gt;Favorites&lt;/a&gt;&lt;/li&gt;</span><span id="4343" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;/NavLink&gt;</strong></span><span id="75ef" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;NavLink to='/submit'exact&gt;</strong></span><span id="575a" class="mv lg in mr b gy nk mx l my mz">        &lt;li&gt;&lt;a&gt;Submit&lt;/a&gt;&lt;/li&gt;</span><span id="8d5f" class="mv lg in mr b gy nk mx l my mz"><strong class="mr io">    &lt;/NavLink&gt;</strong></span><span id="df58" class="mv lg in mr b gy nk mx l my mz">&lt;/nav&gt;</span></pre><p id="351d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<nav>标签中是在NavBar组件中返回的JSX。看一下导航链接标签，我们可以看到每个导航链接都有一个名为<em class="mc">到</em>的属性。这个属性指向当我们的导航栏上的一个&lt;一个&gt;标签被点击时我们应该导航到的路径。例如，一旦点击了“Favorites”&lt;a&gt;标签，根据我们的&lt; NavLink &gt;，我们应该在浏览器中导航到“/favorites”。我们知道，通过前面使用的路由和交换，这个URL将我们带到我们的收藏夹组件:</nav></p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b868" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们可以看到NavLink是React应用程序中非常有用的工具，因为它允许我们指定哪些页面将我们带到哪些URL。</p><p id="cae1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们已经了解了如何使用Route、Switch和NavLink来提供一种使用不同URL在我们的应用程序中导航的方法，为我们的应用程序提供了更多的维度！</p><h1 id="0e34" class="lf lg in bd lh li nf lk ll lm ng lo lp jt nh ju lr jw ni jx lt jz nj ka lv lw bi translated">为什么应该使用React</h1><p id="4b2e" class="pw-post-body-paragraph kc kd in ke b kf lx jo kh ki ly jr kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">React是创建有趣的、动态的、互动的网站的一种不可思议的方式，同时也是组织和改变的一种很好的方式！如果你不喜欢你的生活变得更容易，那么就不要选择React。如果你知道什么对你有好处，那就迈出这一步，今天就开始学习反应吧！你不会后悔的！</p><p id="9f63" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc">更多内容尽在</em> <a class="ae mp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mc">说白了. io </em> </strong> </a> <em class="mc">。报名参加我们的</em> <a class="ae mp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mc">免费周报</em> </strong> </a> <em class="mc">。关注我们关于</em> <a class="ae mp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mc">推特</em> </strong> </a> <em class="mc">和</em><a class="ae mp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mc">LinkedIn</em></strong></a><em class="mc">。加入我们的</em> <a class="ae mp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mc">社区</em> </strong> </a> <em class="mc">。</em></p></div></div>    
</body>
</html>