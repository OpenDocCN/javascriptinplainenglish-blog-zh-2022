<html>
<head>
<title>Regular Expressions—a Rite of Passage for Web Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式Web开发人员的必经之路</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/regular-expressions-a-rite-of-passage-for-web-developers-b24181465096?source=collection_archive---------14-----------------------#2022-05-16">https://javascript.plainenglish.io/regular-expressions-a-rite-of-passage-for-web-developers-b24181465096?source=collection_archive---------14-----------------------#2022-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="534a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:正则表达式速成班——解释正则表达式背后的理论。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ff358fa193e9a2bc9b45a506d81ee351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*904Fxn2XJtBrit17viAjAg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by ThisIsEngineering (pexels.com)</figcaption></figure><p id="8550" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">目标受众:中级开发人员——需要对HTML有很强的掌握，对CSS有一些了解，对JavaScript语言有很强的中级掌握。</strong></p><h1 id="45e6" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">介绍</h1><p id="0ae5" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">整个软件工程职业，不管是什么学科，最终都会面临学习道路上的挑战。当一个初露头角甚至经验丰富的开发人员遇到这种挑战时，它会呈现出一个巨大的障碍。那一瞬间就好像是发现了一个新的具有威胁性的四个字母的单词(尽管它实际上是五个字母)——<strong class="ku io">regex。</strong></p><p id="0a37" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当我第一次遇到<strong class="ku io">正则表达式</strong>(或<strong class="ku io">正则表达式</strong>)时，我的经历是一场令人沮丧的学习似乎是一种神秘语言的斗争，尽管它有着显而易见的力量，却没有显示出它的效用。</p><p id="5da0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，每当我们使用网络浏览器搜索一个项目时，无论是在谷歌上搜索还是在网站内容中搜索，它的效用都是显而易见的。当我们填写在线表格并点击<strong class="ku io">提交</strong>按钮时，它的效用也很明显。</p><p id="813c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在提交表单中的数据之前，会对其进行验证，以确保其格式正确和/或经过处理(去掉错误的内容)。</p><h1 id="d7ff" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">在这个教程中我们要做什么？</h1><p id="8276" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">我们将构建一个简单的演示<strong class="ku io">单页应用程序(SPA) </strong>，但是具有相当复杂的基础。</p><p id="e274" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">本教程是一个三部分系列的第一部分，在这个系列中，我们将从理论到实践再到实现一个完整的演示<strong class="ku io">单页面应用程序(SPA)。</strong></p><h1 id="eac8" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">与理论搏斗</h1><p id="c773" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">如果您对正则表达式完全陌生，那么本教程的第一部分将适合您。如果你对它们相当有经验，那么你可以跳到本系列的第二篇文章— <strong class="ku io"> <em class="ml">正则表达式—一个通过的仪式:从理论到实践。</em> </strong></p><p id="e7c3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，因为这部分教程使用我们的web应用程序中的数据来给出一个关于<strong class="ku io">正则表达式</strong>的快速速成课程，您可能仍然会发现它很有用。</p><p id="5fd1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本系列的第三篇教程结束时，我们将构建一个小型web应用程序，其目的是从一串文本中提取有效的邮政编码，并将它们显示在一个结果框中，单击<strong class="ku io"> Validate Zip Codes </strong>按钮就会填充该结果框。</p><p id="57ab" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">图1 </strong>显示了我们完成的应用程序的开始屏幕:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mm"><img src="../Images/02d3a04918ef94c8ce2108ac9fcd7b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szrHN_cYlWtVtdMJp42i5A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd mn">Fig. 1 Application Landing Page</strong></figcaption></figure><p id="1055" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">简而言之，测试数据框滚动显示一个多行字符串，其中包含有效的邮政编码。当用户点击<strong class="ku io"> Validate Zip Codes </strong>按钮时，使用显示在测试数据下方的正则表达式，应用程序将用一个滚动的已验证的邮政编码匹配列表替换显示在其右侧框架中的<strong class="ku io"> NO MATCH </strong>消息。</p><p id="e721" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">复位</strong>按钮将屏幕恢复到初始状态。</p><p id="7bf8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了实现这个项目，我们需要深入研究一下<br/> <strong class="ku io">正则表达式的理论。</strong></p><p id="bb7f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="ml">但是这个app看起来足够简单。为什么要用一整篇文章来讨论理论基础呢？我们不应该边做边学吗？</em>T12】</strong></p><p id="c584" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">嗯，是的…但不尽然。我们<em class="ml">将</em>在实践中学习，但是没有一些起码的理解基础的实践将是一个痛苦的追求。在编写这个应用程序时，我们将迎头撞上<strong class="ku io">正则表达式</strong>的障碍，至少在最初，可能感觉像撞上了<strong class="ku io"> <em class="ml">暴龙正则表达式。</em> </strong></p><p id="4df7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">玩笑归玩笑，如果没有这个成年礼，任何想出一个与我们将要创建的应用程序相似的应用程序的尝试都需要编写代码，而这些代码很可能不会像包含了<strong class="ku io">正则表达式</strong>的代码那样有效。</p><p id="bf50" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对正则表达式及其在JavaScript中的实现的深入探究超出了本文的范围。这样的探索很容易需要一个自己的过程。</p><p id="c02f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，为了便于理解它将如何在我们的演示web应用程序中发挥作用，我将给出一个快速速成课程，仅仅是实现这个项目所必需的<strong class="ku io">正则表达式</strong>的概念。</p><h1 id="3679" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">足够的正则表达式</h1><p id="4ec7" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">首先，我们需要定义我们的术语。到目前为止，我们只将我们的概念命名为<strong class="ku io">正则表达式</strong>。但是它们是什么呢？</p><h2 id="78d0" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">什么是正则表达式？</h2><p id="ffcb" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">根据Mozilla开发者网络的定义—</p><blockquote class="na nb nc"><p id="7588" class="ks kt ml ku b kv kw jo kx ky kz jr la nd lc ld le ne lg lh li nf lk ll lm ln ig bi translated"><strong class="ku io">“正则表达式是用来匹配字符串中字符组合的模式”</strong> <em class="in">(正则表达式— JavaScript，</em><a class="ae ng" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank"><em class="in">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Regular _ Expressions</em></a><em class="in">)</em>。</p></blockquote><p id="1a25" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="ml">这是什么意思？</em> </strong>这是一个很抽象的说法。让我们再退一步来设置<strong class="ku io">正则表达式</strong>的理论背景。</p><h2 id="903a" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">正则表达式的历史梗概</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/34467271c28169399732ae95aa799401.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*Obs0HNMJuB8_qYI0AfWvHA.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd mn">Mathematician Stephen Cole Kleene</strong></figcaption></figure><p id="94bb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">正则表达式</strong>的词根在1951年数学家斯蒂芬·科尔·克莱尼<strong class="ku io"> <em class="ml">的一篇题为《神经网络和有限自动机中事件的<strong class="ku io"> <em class="ml">表示法</em> </strong> <em class="ml">、</em> <strong class="ku io"> <em class="ml"> </em> </strong>的论文中。</em> </strong>本文定义的理论远远超出了本教程的范围，但如果你有兴趣探究他要说的话，可以在这里下载论文<a class="ae ng" href="https://www.rand.org/content/dam/rand/pubs/research_memoranda/2008/RM704.pdf" rel="noopener ugc nofollow" target="_blank"/>(<em class="ml">“事件的表象”)</em>。</p><p id="f2a1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">克莱尼理论的实际应用在1968年左右得到了认可，当时它们被用来促进文本编辑器中的模式匹配，并被编译器用于源代码的词法分析。关于这方面的更多信息，你可能想参考这篇文章 ( <em class="ml">“正则表达式”</em>)。</p><p id="62fa" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">可以说，在接下来的几年里，<strong class="ku io">正则表达式</strong>的许多不同实现<br/>被开发出来，所有这些实现都源于UNIX操作系统中这些概念的出现。<strong class="ku io">下面的表1</strong><br/>是在维基百科上找到的<strong class="ku io">正则表达式</strong><br/>(<em class="ml">“正则表达式引擎的比较】</em>)的一些不同风味的样本:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/2119d15d26d15d1b8d011b4af888c257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mt3_EIMcoVK8iPL-TeP65A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd mn">Table 1. Some Well Known Flavors of Regex</strong></figcaption></figure><h2 id="3ad1" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">JavaScript中正则表达式的基本要素</h2><p id="7868" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">在JavaScript中，正则表达式有两种表示方式:</p><p id="8d33" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">1.一个对象文本。<br/> 2。用构造函数声明的对象。</p><p id="d6d5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">对象文字符号</strong>是我们在上面的<strong class="ku io">图1 </strong>中看到的减去它的声明。事实上，您即将编写的代码使用了如下所示的符号:</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="0076" class="mo lp in nk b gy no np l nq nr"><strong class="nk io">const</strong> regex = /<strong class="nk io">[a-z]</strong>/<strong class="nk io">g</strong>;</span></pre><p id="1487" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">该表达式将在指定的测试字符串中搜索并匹配小写字母<strong class="ku io"> a </strong>到<strong class="ku io"> z </strong>的任何实例。稍后将详细介绍。</p><p id="eb55" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">使用其对象构造函数声明的同一个<strong class="ku io">正则表达式</strong>具有以下语法:</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="08e4" class="mo lp in nk b gy no np l nq nr"><strong class="nk io">const</strong> regex = <strong class="nk io">new</strong> <strong class="nk io">RegExp(</strong><br/> '<strong class="nk io">[a-z]</strong>', '<strong class="nk io">g</strong>'<br/><strong class="nk io">)</strong>;</span></pre><p id="d021" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这两种语法的工作原理相同。<strong class="ku io"> <em class="ml">有没有一个时间应该用这个或者那个？</em> </strong>有，有。根据Mozilla开发者网络:</p><blockquote class="na nb nc"><p id="3cd6" class="ks kt ml ku b kv kw jo kx ky kz jr la nd lc ld le ne lg lh li nf lk ll lm ln ig bi translated">" T <!-- -->当对表达式求值时，文字符号导致正则表达式的编译。当正则表达式<br/>保持不变时，使用文字符号。例如，如果您使用文字符号来构造循环中使用的正则表达式，则正则表达式不会在每次迭代中重新编译<br/>(“RegExp—JavaScript | MDN”)。</p></blockquote><p id="c50d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">关于这方面的更多信息，你可以咨询这个<a class="ae ng" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#literal_notation_and_constructor" rel="noopener ugc nofollow" target="_blank">帖子</a>。</p><h2 id="0b4d" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">正则表达式的剖析</h2><p id="f381" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">我们将从更复杂的<strong class="ku io">正则表达式</strong>开始，这是我们将在本教程的第2部分和第3部分构建的应用程序中有效邮政编码匹配的基础:</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="575e" class="mo lp in nk b gy no np l nq nr"><strong class="nk io">/^[0-9]{5}(-[0-9]{4})?/gm</strong></span></pre><p id="e791" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">看着这一行神秘的代码，您可能会问自己，<strong class="ku io"> <em class="ml">“这是什么天书？”我向你保证，几分钟后，这看起来不会像现在这样令人生畏。</em></strong></p><p id="b6fb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果我们将<strong class="ku io"> Regex </strong>视为我们希望匹配的字符模式的符号表示，我们就可以开始对不同种类的符号字符进行分类。</p><p id="1022" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将快速浏览一下上面的<strong class="ku io">正则表达式</strong>，一点一点地把它拆开，然后再把它放回一起，以理解<strong class="ku io">正则表达式引擎需要什么。</strong></p><p id="7ce2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们的<strong class="ku io">正则表达式</strong>的组成部分可以分解为<br/>如下:</p><ol class=""><li id="adb0" class="ns nt in ku b kv kw ky kz lb nu lf nv lj nw ln nx ny nz oa bi translated"><strong class="ku io">分隔符</strong></li><li id="019a" class="ns nt in ku b kv ob ky oc lb od lf oe lj of ln nx ny nz oa bi translated"><strong class="ku io">锚</strong></li><li id="b493" class="ns nt in ku b kv ob ky oc lb od lf oe lj of ln nx ny nz oa bi translated"><strong class="ku io">字符集和范围</strong></li><li id="34bf" class="ns nt in ku b kv ob ky oc lb od lf oe lj of ln nx ny nz oa bi translated"><strong class="ku io">量词</strong></li><li id="f3f3" class="ns nt in ku b kv ob ky oc lb od lf oe lj of ln nx ny nz oa bi translated"><strong class="ku io">捕捉组</strong></li><li id="2dd3" class="ns nt in ku b kv ob ky oc lb od lf oe lj of ln nx ny nz oa bi translated"><strong class="ku io">标志</strong></li></ol><p id="a79d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所有这六个组件都在我们的<strong class="ku io">正则表达式</strong>中发挥作用。让我们一个一个来。</p><p id="c900" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">分隔符<br/> </strong>在<strong class="ku io"> JavaScript </strong> <strong class="ku io">对象文字符号中，</strong> <strong class="ku io">正则表达式</strong>两边用正斜杠分隔<br/>。出现在这些斜线之间的所有内容都代表了我们希望在测试字符串中找到匹配<br/>的模式。</p><p id="581c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">锚点<br/> </strong>一个<strong class="ku io">锚点</strong>不匹配测试字符串中的任何特定字符。相反，它定义了我们希望看到的由<strong class="ku io"> regex引擎返回的匹配的起点或终点。</strong></p><p id="a040" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">插入符号(</strong> <code class="fe og oh oi nk b"><strong class="ku io">^</strong></code> <strong class="ku io"> ) </strong>代表我们正在搜索的匹配的开始。例如，如果我们想匹配模式开头字母<code class="fe og oh oi nk b">J</code>的任何实例，语法应该是<code class="fe og oh oi nk b">^J</code>。</p><p id="04c9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">另一方面，<strong class="ku io">美元符号</strong> ( <code class="fe og oh oi nk b">$</code>)表示我们正在搜索的匹配的结束。这个符号用在字符串模式的末尾，影响紧接在它前面的字符或字符集。</p><p id="3f6a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">字符集<br/></strong><strong class="ku io">字符集</strong>是一个指定的字符集合，它可以是字符文字或指定的字符序列，我们要根据它来测试一个特定的测试字符串。<strong class="ku io">字符集</strong>用<strong class="ku io">方括号括起来。</strong></p><p id="ad1a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">范围</strong>T25】当一系列字符定义了一个字符范围，我们就有了一个<strong class="ku io">范围。范围</strong>由一组连续的数字或字母字符组成。例如，<strong class="ku io"> 0 </strong>到<strong class="ku io"> 9 </strong>是我们所认为的(至少在十进制中)一个数字可能的完整数字范围。这也将在<strong class="ku io">方括号</strong>中注明，如下所示:</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="a7f8" class="mo lp in nk b gy no np l nq nr">[0-9]</span></pre><p id="6b27" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于字母字符，我们也有范围<code class="fe og oh oi nk b">[a-z]</code>和<code class="fe og oh oi nk b">[A-Z]</code>。但是我们也可以很容易地指定一个数字范围，比如<code class="fe og oh oi nk b">[1-5]</code>或者字母范围，比如<code class="fe og oh oi nk b">[a-g]</code>或者<code class="fe og oh oi nk b">[A-G]</code>。</p><p id="e979" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">数量词<br/> </strong>一个<strong class="ku io">数量词</strong>指定一个给定字符(或一个字符集中的字符)在匹配中所需的最小或最大实例。它还可以指定模式匹配中所需的确切字符数。</p><p id="dbd0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下面的表2显示了这些量词的一些用法:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/b58c34d1259b84853c4bfa95630fedbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFdPMzGT8MW4gZDoltCvpw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd mn">Table 2: Regex Quantifiers</strong></figcaption></figure><p id="4e06" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">捕捉组<br/> </strong>用括号表示，<strong class="ku io">捕捉组</strong>设置一个图案序列，作为一个整体，而不是其组成部分。换句话说，如果我们有一个这样的捕捉组…</p><p id="8ab9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe og oh oi nk b">([A-G]-0[0–9]{3})</code></p><p id="23bd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">…我们所说的是<strong class="ku io">匹配任何完整的模式</strong>，该模式以<code class="fe og oh oi nk b">A</code>和<code class="fe og oh oi nk b">G</code>之间的任何大写字母开始，然后是<strong class="ku io">连字符</strong>和<code class="fe og oh oi nk b">0</code>，最后是<code class="fe og oh oi nk b">0</code>和<code class="fe og oh oi nk b">9</code>之间的3位数。</p><p id="9ab7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="ml">这和普通字符集有什么区别？</em> </strong>在一个字符集中，除非一个量词紧随其后，如上面的序列<code class="fe og oh oi nk b">[0–9]{3}</code>，否则<strong class="ku io">正则表达式引擎</strong>将只匹配1个在指定范围内的字符。</p><p id="73bd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">另一方面，利用<strong class="ku io">捕获组，</strong>序列被作为一个整体来分析，并且必须作为一个整体来匹配。正如您将看到的，这在我们的迷你应用程序中非常有用。</p><p id="2eda" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有了标志，我们可能达到了迄今为止描述的所有语法中最容易理解的程度。标志对<strong class="ku io">正则表达式引擎</strong>解析传递给它的测试字符串的方式有影响。</p><p id="4715" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正则表达式的JavaScript风格有六个标志，但是我们将把我们的检查限制在你可能最经常遇到的三个。这些标志出现在右正斜杠后的<strong class="ku io">正则表达式</strong>的末尾。它们是:</p><ol class=""><li id="08ef" class="ns nt in ku b kv kw ky kz lb nu lf nv lj nw ln nx ny nz oa bi translated"><code class="fe og oh oi nk b">i</code>—不区分大小写标志指定将匹配字母字符，无论它们是大写还是小写。</li><li id="2051" class="ns nt in ku b kv ob ky oc lb od lf oe lj of ln nx ny nz oa bi translated"><code class="fe og oh oi nk b">g</code>—全局标志指定将返回从测试字符串开始到结束的所有匹配。默认情况下，<strong class="ku io"> regex引擎</strong>从左到右读取测试字符串，一旦返回第一个匹配，就退出，忽略第一个匹配之后的任何匹配。</li><li id="c874" class="ns nt in ku b kv ob ky oc lb od lf oe lj of ln nx ny nz oa bi translated"><code class="fe og oh oi nk b">m</code> —Judas Stefan澄清“多行标志改变了上面提到的<code class="fe og oh oi nk b">^</code>和<code class="fe og oh oi nk b">$</code>锚点的含义……”(Judis，<em class="ml">JavaScript正则表达式中的多行模式</em>)。默认情况下，<strong class="ku io"> regex引擎</strong>将一个测试字符串视为一个要搜索的不间断的长字符串。</li></ol><p id="51f4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">该字符串的边界由表示字符串开始的<code class="fe og oh oi nk b">^</code>锚和表示字符串结束的<code class="fe og oh oi nk b">$</code>锚定义。将<code class="fe og oh oi nk b">m</code> (multiline)标志附加到表达式的末尾，这两个锚点定义了一行的开始和结束，而不是整个字符串。</p></div><div class="ab cl ok ol hr om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ig ih ii ij ik"><p id="46ed" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">好的。我知道那是一大堆东西，有些甚至可能有点令人困惑。这种情况即将改变。</p><h2 id="5968" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">正则表达式的拆除</h2><p id="d693" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">我们现在准备分析我们将要构建的web应用程序中使用的<strong class="ku io">正则表达式</strong>。让我们再来看看它的辉煌:</p><p id="5eaf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe og oh oi nk b">/^[0–9]{5}(-[0–9]{4})?$/gm</code></p><p id="1b29" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">拆开<br/> </strong>让我们从检查这个表达式最外层的部分开始。我们的<strong class="ku io">正则表达式</strong>的外壳是这样的:</p><p id="f2d1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe og oh oi nk b">//gm</code></p><p id="e1e8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="ml">这个小片段本身说明了什么？</em> </strong>不多，因为还没有指定模式。尽管如此，这个片段为如何处理出现在正斜杠分隔符之间的任何模式奠定了基础。</p><p id="2f25" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">使用上面的<strong class="ku io"> regex标志</strong>的定义，这个片段告诉<strong class="ku io"> regex引擎</strong> <em class="ml">“匹配分隔符</em> ( <strong class="ku io">全局匹配</strong> ) <em class="ml">之间指定的模式的所有实例，并分别考虑测试字符串的每一行</em> ( <strong class="ku io">多行匹配</strong> ) <em class="ml">。”</em> <strong class="ku io">还不多，</strong>但是引擎现在知道如何处理在分隔符之间为它定义的任何模式。</p><p id="bfdd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">模式的前半部分<br/> </strong>这个模式的第一部分使用了我们之前学过的<code class="fe og oh oi nk b">^</code>锚，有所不同。考虑到这一点，我们来看看模式的前半部分:</p><p id="5cb4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe og oh oi nk b">^[0–9]{5}</code></p><p id="bd1d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">首先我们有字符串锚的<code class="fe og oh oi nk b">^</code> <strong class="ku io">开头，它声明了我们的模式的开始<br/>。接下来我们有一个用方括号括起来的<strong class="ku io">字符集</strong>。这个<strong class="ku io">字符集</strong>完全由从<strong class="ku io"> 0 </strong>到<strong class="ku io"> 9 </strong>的数字<strong class="ku io">范围</strong>组成。</strong></p><p id="d581" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个<strong class="ku io">范围</strong>后面紧跟着一个<code class="fe og oh oi nk b">{5}</code>的<strong class="ku io">量词</strong>。总之，<strong class="ku io">范围</strong>和<strong class="ku io">限定符</strong>指定在<strong class="ku io"> 0 </strong>到<strong class="ku io"> 9 </strong>范围内的任何一组正好5个数字将作为匹配返回。</p><p id="7fee" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在我们有了<strong class="ku io">正则表达式的完整前半部分:</strong></p><p id="66da" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe og oh oi nk b">/^[0–9]{5}/gm</code></p><p id="dbb8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这对<strong class="ku io"> regex引擎</strong>说的是<em class="ml">“搜索并返回测试字符串中所有行的所有匹配项，这些匹配项以5位数的任意组合开始。”</em></p><p id="df5f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就其本身而言，我们的<strong class="ku io">正则表达式</strong>的前半部分是完整的，它将返回在我们的测试字符串中找到的任何有效的5位邮政编码。</p><p id="dc57" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是还有一个问题。到目前为止，我们将绕过文本中嵌入的任何有效的+4邮政编码。我们的<strong class="ku io">正则表达式</strong>的后半部分将解决这个问题。</p><p id="ee20" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">模式的后半部分<br/> </strong>现在让我们接近<strong class="ku io">正则表达式的后半部分</strong>:</p><p id="0b47" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe og oh oi nk b">(-[0–9]{4})?$</code></p><p id="3153" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里我们遇到一个<strong class="ku io">捕捉组</strong>，前面已经解释过了。在<strong class="ku io">连字符</strong>、<strong class="ku io">范围、</strong>和<strong class="ku io">量词</strong>周围出现的括号表示<strong class="ku io">组</strong>只能作为一个整体来分析。<strong class="ku io">不会单独考虑<strong class="ku io">捕捉组</strong>的</strong>组成部分。</p><p id="30ab" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">首先让我们看看<strong class="ku io">捕捉组的内容。</strong></p><p id="49ba" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">有时候连字符就是连字符</strong> <br/>我们从<strong class="ku io">连字符</strong>开始。当<strong class="ku io">连字符</strong>出现在限定<strong class="ku io">字符集</strong>的方括号内时，表示<strong class="ku io">范围</strong>，例如<code class="fe og oh oi nk b">[0–9]</code>。当它作为<strong class="ku io">捕获组</strong>的第一个字符出现在方括号外时，它是一个<strong class="ku io">字符文字</strong>。因此<strong class="ku io">连字符</strong>是<strong class="ku io">捕获组</strong>中要匹配的模式开头的必需字符。</p><p id="be24" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接下来是<strong class="ku io">靶场</strong>T2。到目前为止，我们的<strong class="ku io">组</strong>将只返回一个以<strong class="ku io">连字符</strong>开头，后跟<code class="fe og oh oi nk b">0</code>和<code class="fe og oh oi nk b">9</code>之间的4位数的匹配。</p><p id="006e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在<strong class="ku io">捕获组</strong>的括号之外是<code class="fe og oh oi nk b">?</code> <strong class="ku io">量词</strong>，它指定紧接在它前面的可以有<code class="fe og oh oi nk b">0</code>或<code class="fe og oh oi nk b">1</code>实例。需要注意的是，这个<code class="fe og oh oi nk b">?</code> <strong class="ku io">量词</strong>适用于整个<strong class="ku io">捕获组</strong>，而不仅仅是它左边的单个字符。</p><p id="c6e2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这就是<strong class="ku io">捕捉群体</strong>的力量。<strong class="ku io"> </strong>它们使得要求匹配一组指定的字符或<strong class="ku io">字符集成为可能。</strong>因为<code class="fe og oh oi nk b">?</code> <strong class="ku io">量词</strong>接受其前面的<code class="fe og oh oi nk b">0</code>或<code class="fe og oh oi nk b">1</code>匹配，所以有时被称为<strong class="ku io">可选</strong>。换句话说，将返回指定字符或模式的<code class="fe og oh oi nk b">0</code>或<code class="fe og oh oi nk b">1</code>实例的匹配。</p><p id="83c7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这种行为使得<strong class="ku io"> regex引擎</strong>能够返回5位邮政编码或+4邮政编码的匹配。</p><p id="03e1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最后，我们有<code class="fe og oh oi nk b">$</code> <strong class="ku io">锚</strong>，它定义了作为匹配返回的字符串的结尾。这非常明确地规定了一个有效的邮政编码匹配将以一个5位数字的序列开始，并有一个可选的连字符，后跟正好4位数字，但这个序列后面绝对没有任何内容。</p><p id="8ab6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们把正则表达式的整个序列放回一起。</p><p id="cae4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe og oh oi nk b">/^[0–9]{5}(-[0–9]{4})?$/gm</code></p><p id="3b1f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个顺序现在对我们来说应该更清楚了。从左向右读，下面是完整的<strong class="ku io">正则表达式的含义:</strong></p><blockquote class="na nb nc"><p id="6433" class="ks kt ml ku b kv kw jo kx ky kz jr la nd lc ld le ne lg lh li nf lk ll lm ln ig bi translated">在测试字符串的所有行中搜索并返回所有匹配项，这些匹配项以恰好5位数字的任意组合开始，并可选地以连字符和从<code class="fe og oh oi nk b"><em class="in">0</em></code>到<code class="fe og oh oi nk b"><em class="in">9</em></code>范围内的恰好4位数字结束</p></blockquote><p id="39a8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们找到了。</p><h2 id="015b" class="mo lp in bd lq mp mq dn lu mr ms dp ly lb mt mu ma lf mv mw mc lj mx my me mz bi translated">举个真实世界的例子怎么样？</h2><p id="bd38" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">下面是一个非常简单的示例，展示了我们将为<br/>应用程序实现的内容:</p><p id="0991" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">测试管柱<br/>10003<br/>asdf 10003<br/>10003 asdf<br/>10003–8924</p><p id="5f5c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">回顾一下…</p><p id="5c4c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">我们的正则表达式</strong></p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="36e4" class="mo lp in nk b gy no np l nq nr">/^[0-9]{5}(-[0-9]{4})?$/gm</span></pre><p id="595d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你认为这个<strong class="ku io">搜索字符串</strong>会返回多少个匹配？1，2，3，还是4？</p><p id="b4c9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">使用名为<a class="ae ng" href="https://www.regexpal.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> Regex Pal </strong> </a>的非常有用的在线工具，我们获得了下面的<strong class="ku io">图2 </strong>中的结果:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi or"><img src="../Images/3a834bf6b984dab77de3d263bbf3779f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmAiMcdHHPHErewIYw5J7g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="bd mn">Fig. 2 Test Results Returned from RegexPal.com</strong></figcaption></figure><p id="6c55" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">图2 </strong>显示了<strong class="ku io">正则表达式引擎</strong>返回的两个有效匹配。</p><p id="cd45" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">在第一行，</strong> <code class="fe og oh oi nk b">10003</code>高亮显示为匹配。这是因为它符合5位数邮政编码的标准。</p><p id="02d8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">第二行</strong>，<code class="fe og oh oi nk b">asdf10003</code>没有高亮显示。这是因为即使这一行有5个数字，它们前面都有<code class="fe og oh oi nk b">asdf</code>。因此，它不符合标准，因为匹配字符串的开头不是所需的5位数字序列。</p><p id="453a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">在第三行，</strong> <code class="fe og oh oi nk b">10003asdf</code>也没有被突出显示。这是因为，即使行首有5个数字，<code class="fe og oh oi nk b">asdf</code>也遵循这个顺序。因此，它不符合标准，因为匹配字符串的结尾必须是开头的5位数字序列的最后一位数字，或者是可选的连字符，后跟正好4位数字。其他什么都不会发生。</p><p id="46ec" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最后，<strong class="ku io">的第四行，</strong> <code class="fe og oh oi nk b">10003-8924</code> <strong class="ku io"> <em class="ml">被</em> </strong>高亮显示。这是因为它符合字符串的标准，该字符串恰好以5位数字开始，并以后跟4位数字的可选连字符序列结束。</p><p id="f605" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">因此有两个匹配。</p><p id="aadf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">虽然这个例子确实比我们将在最终应用程序中使用的例子简单一点，但是原理是一样的。</p><h1 id="2d77" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">下一步是什么？</h1><p id="064b" class="pw-post-body-paragraph ks kt in ku b kv mg jo kx ky mh jr la lb mi ld le lf mj lh li lj mk ll lm ln ig bi translated">一旦你有了喘息的机会，请继续本系列教程的第二部分，我们将开始构建我们的应用程序— <a class="ae ng" href="https://rhieger-98255.medium.com/regular-expressions-a-rite-of-passage-from-theory-to-practice-f4f23bec6044" rel="noopener"> <strong class="ku io"> <em class="ml">正则表达式—成年礼:从理论到实践</em> </strong> </a> <strong class="ku io"> <em class="ml">。</em>T24】</strong></p><p id="a87d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="ml">更多内容请看</em><a class="ae ng" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ml">plain English . io</em></strong></a><em class="ml">。报名参加我们的</em> <a class="ae ng" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="ml">免费周报</em> </strong> </a> <em class="ml">。关注我们关于</em><a class="ae ng" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ml">Twitter</em></strong></a><em class="ml">和</em><a class="ae ng" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ml">LinkedIn</em></strong></a><em class="ml">。查看我们的</em> <a class="ae ng" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="ml">社区不和谐</em> </strong> </a> <em class="ml">加入我们的</em> <a class="ae ng" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="ml">人才集体</em> </strong> </a> <em class="ml">。</em></p></div></div>    
</body>
</html>