<html>
<head>
<title>The Shortest Tutorial to Learn React For a Backend Developer in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年后端开发者学习React的最短教程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-shortest-tutorial-to-learn-reactjs-for-a-backend-developer-in-2022-part-1-bd7aa96182ed?source=collection_archive---------3-----------------------#2022-09-15">https://javascript.plainenglish.io/the-shortest-tutorial-to-learn-reactjs-for-a-backend-developer-in-2022-part-1-bd7aa96182ed?source=collection_archive---------3-----------------------#2022-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c77" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:React的3个核心维度——<code class="fe kf kg kh ki b">basic concepts</code>、<code class="fe kf kg kh ki b">components</code>、<code class="fe kf kg kh ki b">Hooks — </code>帮助你快速掌握React</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/51028ef8cea8787bc4b6cc918049533c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BLmukwxp0kwGpWpk"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/es/@juanjodev02?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Juanjo Jaramillo</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="92ea" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">作为开发人员，我们总是想学习新的东西。作为后端开发人员，我们只需要扩展视野，不要只关注我们已经熟悉的小领域。</p><p id="b4e8" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">React，世界上最流行的UI框架非常庞大，需要很长时间才能学会。如果你是一个React老手，你也可以检查一下缺口，留着以后用。我相信阅读这篇文章会比浏览React文档或搜索来解决问题要快得多。</p><p id="fc52" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">本文试图从初学者的角度，围绕React的三个核心维度:<code class="fe kf kg kh ki b">basic concepts</code>、<code class="fe kf kg kh ki b">components</code>、<code class="fe kf kg kh ki b">Hooks</code>，讲解React中90%以上的实用特性和常用概念，帮助你快速掌握React。</p><p id="f596" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们开始最短的旅程。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8b35" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak"> 1。初始化项目</strong></h1><h2 id="58eb" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 1.1安装</strong></h2><p id="5b21" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">开发web应用时，<code class="fe kf kg kh ki b">React</code>通常需要与<code class="fe kf kg kh ki b">ReactDOM</code>配合使用，下面是使用<code class="fe kf kg kh ki b">npm</code>安装<code class="fe kf kg kh ki b">React</code>的命令。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="b6a3" class="mv me iq ki b gy nq nr l ns nt">npm i react react-dom</span></pre><h2 id="c9d5" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 1.2使用</strong> <code class="fe kf kg kh ki b"><strong class="ak">CRA</strong></code>创建项目</h2><p id="6e6d" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">创建React项目的最快方法是使用Create-React-App(简称CRA)。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="2d91" class="mv me iq ki b gy nq nr l ns nt">npx create-react-app APP_NAME</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="5699" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak"> 2。基本概念</strong></h1><h2 id="e0df" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.1元素</strong></h2><p id="7932" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">React元素的编写方式与普通HTML元素相同，您可以使用HTML语法在React中创建任何元素。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="b9d5" class="mv me iq ki b gy nq nr l ns nt">&lt;div&gt;I'm JSX&lt;/div&gt;</span></pre><p id="87b7" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这个语法叫做<code class="fe kf kg kh ki b">JSX</code>。实际上，<code class="fe kf kg kh ki b">JSX</code>语法只是JavaScript的语法糖，所以仍然需要使用像<code class="fe kf kg kh ki b">babel</code>这样的工具来编译。与HTML不同，JSX的自结束标签必须用斜线结束。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="5f26" class="mv me iq ki b gy nq nr l ns nt">&lt;img src="/img.png" /&gt;</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="b0a3" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.2元素属性</strong></h2><p id="3955" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">除了元素的语法略有不同之外，JSX和HTML在元素属性方面也有细微的区别。<br/>由于JSX是JavaScript，JavaScript中的命名约定是使用camel命名，所以JXS中的所有元素属性都要改用camel命名(事件也一样)。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="5253" class="mv me iq ki b gy nq nr l ns nt">&lt;input defaultChecked defaultValue="o" onInput={()=&gt;{}} /&gt;</span></pre><p id="77cb" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">除了正常属性之外，还有一个特殊属性需要注意。</p><p id="cca5" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这个特殊的属性是class，因为在JavaScript中，class是一个关键字，所以需要使用className来代替。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="2331" class="mv me iq ki b gy nq nr l ns nt">&lt;div className="class"&gt;&lt;/div&gt;</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="38d8" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.3元素样式</strong></h2><p id="0dd7" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">在JSX使用内联样式时，我们不应该使用字符串，而应该使用对象。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="2ea1" class="mv me iq ki b gy nq nr l ns nt">&lt;div style={{ fontSize: '1.25rem', textAlign: 'center' }}&gt;<strong class="ki ir">Hello</strong>, JSX&lt;/div&gt;</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="98ab" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.4组件</strong></h2><p id="775b" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">我们可以将多个元素组合成一个React组件。<br/>以前编写组件的React方式是使用类，现在更推荐的方式是使用函数。函数组件类似于普通函数，但有两个不同之处:</p><p id="31ad" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="nu"> A .组件名称以大写字母开头。组件需要返回JSX元素。</em></p><p id="d028" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是最简单的组件之一。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="21e9" class="mv me iq ki b gy nq nr l ns nt">function MyComponent() {<br/>  return &lt;div&gt;Hello Component!&lt;/div&gt;<br/>}</span></pre><h2 id="1761" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.5片段</strong></h2><p id="4763" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">React要求所有组件都应该有一个根元素，这意味着一个组件不能同时包含多个同级元素。<br/>下面是一个反例，它会认为是语法错误:</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="7a0b" class="mv me iq ki b gy nq nr l ns nt">function Sign() {<br/>  return (<br/>    &lt;input /&gt;<br/>    &lt;input /&gt;<br/>    &lt;button /&gt;<br/>  )<br/>}</span></pre><p id="55eb" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在React 16.2.0之后，JSX提供了片段组件来处理这种情况。</p><p id="f289" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可以这样写:</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="6729" class="mv me iq ki b gy nq nr l ns nt">function Sign() {<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;input /&gt;<br/>      &lt;input /&gt;<br/>      &lt;button /&gt;<br/>    &lt;/React.Fragment&gt;<br/>  )<br/>}</span></pre><p id="1faa" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe kf kg kh ki b">Fragment</code>也可以缩写为<code class="fe kf kg kh ki b">&lt;&gt;&lt;/&gt;</code>，所以我们一般是这样写的。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="ccee" class="mv me iq ki b gy nq nr l ns nt">function Sign() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;input /&gt;<br/>      &lt;input /&gt;<br/>      &lt;button /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><h2 id="89ad" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.6道具</strong></h2><p id="3206" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">组件可以相互环绕，从而形成父子关系。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="5fd9" class="mv me iq ki b gy nq nr l ns nt">&lt;Parent&gt;<br/>  &lt;Child /&gt;<br/>&lt;/Parent&gt;</span></pre><p id="b6f9" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可以将数据传递给父组件中的子组件，我们称之为<code class="fe kf kg kh ki b">props</code>。传递属性的语法与普通属性相似，但不同之处在于可以传递对象。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="e4c0" class="mv me iq ki b gy nq nr l ns nt">&lt;<strong class="ki ir">Child</strong> name='Mary', age={19} /&gt;</span></pre><p id="20fd" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">属性是通过函数的参数在子组件中接收的。JavaScript中的变量在组件中使用时是用括号括起来的。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="2e13" class="mv me iq ki b gy nq nr l ns nt">function Child(props) {<br/>  return &lt;div&gt;<br/>    &lt;span&gt;{props.name}&lt;/span&gt;<br/>    &lt;span&gt;{props.age}&lt;/span&gt;<br/>  &lt;/div&gt;<br/>}</span></pre><p id="677b" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们还可以用对象解构的语法使代码更简单。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="6166" class="mv me iq ki b gy nq nr l ns nt">function Child({ name, age }) {<br/>  return &lt;div&gt;<br/>    &lt;span&gt;{name}&lt;/span&gt;<br/>    &lt;span&gt;{age}&lt;/span&gt;<br/>  &lt;/div&gt;<br/>}</span></pre><p id="a576" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果你想把当前所有的道具传递给子组件，有一个简单的方法。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="30da" class="mv me iq ki b gy nq nr l ns nt">function Parent(props) {<br/>  return &lt;Child {...props} /&gt;<br/>}</span></pre><p id="366b" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这将把父对象的所有道具传递给子对象。</p><h2 id="3ada" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.7儿童</strong></h2><p id="4a2f" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">我们可以在组件内部放置其他元素或组件。<br/>以这种方式放在中间的元素或组件称为子元素。</p><p id="14cc" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">嵌入的元素或组件安装在props对象上，我们可以通过props.children访问子组件。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="7064" class="mv me iq ki b gy nq nr l ns nt">&lt;Parent&gt;<br/>  &lt;Child /&gt;<br/>&lt;/Parent&gt;</span><span id="8c9f" class="mv me iq ki b gy nv nr l ns nt">function Parent({children}) {<br/>  return children // children equals to &lt;Child /&gt;<br/>}</span></pre><h2 id="14db" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.8条件渲染</strong></h2><p id="9b91" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">React可以根据特定条件选择显示或隐藏哪些内容。</p><p id="2d70" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最简单的方法是使用if语句。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="37c7" class="mv me iq ki b gy nq nr l ns nt">function App() {<br/>  const { isLoading, isError, data } = fetchData()  <br/>  if(isError) {<br/>    return &lt;Error /&gt;<br/>  }<br/>  if(isLoading) {<br/>    return &lt;Loading /&gt;<br/>  }<br/>  return &lt;div&gt;{data}&lt;/div&gt;<br/>}</span></pre><p id="57e1" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果您在组件嵌套中使用条件，您将需要使用三元运算符，这些运算符需要包含在括号中。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="b8f0" class="mv me iq ki b gy nq nr l ns nt">function App() {<br/>  const { isLoading, isError, data } = fetchData()<br/>  return (&lt;Layout&gt;<br/>      {<br/>        isError ? &lt;Error /&gt;:<br/>        isLoading ? &lt;Loading /&gt;:<br/>          &lt;div&gt;{data}&lt;/div&gt;<br/>      }<br/>    &lt;/Layout&gt;)<br/>}</span></pre><p id="66ff" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">除了三元运算符之外，短路运算符在某些情况下也可用于提高可读性。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="f678" class="mv me iq ki b gy nq nr l ns nt">function App() {<br/>  const { isLoading, isError, data } = fetchData()<br/>  return (&lt;Layout&gt;<br/>      {isError &amp;&amp; &lt;Error /&gt;}<br/>      {isLoading &amp;&amp; &lt;Loading /&gt;}<br/>      &lt;div&gt;{data}&lt;/div&gt;<br/>    &lt;/Layout&gt;)<br/>}</span></pre><h2 id="17cc" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.9列表效果图</strong></h2><p id="ddb5" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">我们还可以将数据列表呈现到组件中。</p><p id="d9a2" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">渲染React组件最常见的方式是通过数组的map方法。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="b1ec" class="mv me iq ki b gy nq nr l ns nt">const users = ['Mary', 'Lucy', 'Jack']</span><span id="1e92" class="mv me iq ki b gy nv nr l ns nt">function App() {<br/>  return (<br/>    &lt;&gt;<br/>      {users.map(user =&gt; &lt;div key={user}&gt;{user}&lt;/div&gt;)}<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="a3b3" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注意，当我们进行列表呈现时，我们需要为每个元素设置一个键，并且这个键必须保持唯一。</p><h2 id="0516" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.10 HTML字符串渲染</strong></h2><p id="d805" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">当我们已经有一个HTML字符串时，我们需要将它直接呈现到页面上。</p><p id="c8c5" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在React中实现这一点的方法是使用<code class="fe kf kg kh ki b">dangerouslySetInnerHTML</code>属性，该属性接受一个对象的值，该对象的<code class="fe kf kg kh ki b">__html </code>属性被设置为HTML字符串。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="de96" class="mv me iq ki b gy nq nr l ns nt">const htmlString = '&lt;p&gt;I'm HTML String&lt;/p&gt;'</span><span id="21b2" class="mv me iq ki b gy nv nr l ns nt">&lt;div dangerouslySetInnerHTML={{ __html: htmlString }}&gt;&lt;/div&gt;</span></pre><h2 id="c1d1" class="mv me iq bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated"><strong class="ak"> 2.11上下文</strong></h2><p id="1a00" class="pw-post-body-paragraph la lb iq lc b ld nh jr lf lg ni ju li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">当我们的组件嵌套层次太深时，在相距太远的两个组件之间传递道具可能会很麻烦，我们需要让中间的所有组件都接收它们一开始就不使用的道具。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="59ef" class="mv me iq ki b gy nq nr l ns nt">function App() {<br/>  const username = 'Mary'<br/>  return &lt;Layout username={username}&gt;<br/>    &lt;div&gt;Hello&lt;/div&gt;<br/>  &lt;/Layout&gt;<br/>}</span><span id="96fa" class="mv me iq ki b gy nv nr l ns nt">// Layout receiving username is redundant<br/>function Layout({ username }) {<br/>  return &lt;User username={username}&gt;&lt;/User&gt;<br/>}</span><span id="edb2" class="mv me iq ki b gy nv nr l ns nt">function User({ username }) {<br/>  return &lt;h1&gt;{username}&lt;/h1&gt;<br/>}</span></pre><p id="9653" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了解决这个问题，React提供了上下文来允许我们的组件在props之外共享数据。上下文是使用React的createContext函数创建的，该函数返回一个具有两个属性的上下文对象，<code class="fe kf kg kh ki b">Provider</code>和<code class="fe kf kg kh ki b">Consumer</code>，这两个属性都是组件。</p><p id="aef6" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们使用<code class="fe kf kg kh ki b">Provider</code>组件包装需要传递数据的根组件，然后在需要使用数据的位置用<code class="fe kf kg kh ki b">Consumer</code>组件包装它以获取数据。</p><pre class="kk kl km kn gt nm ki nn no aw np bi"><span id="180e" class="mv me iq ki b gy nq nr l ns nt">const UserNameContext = React.createContext('')</span><span id="4129" class="mv me iq ki b gy nv nr l ns nt">function App() {<br/>  const username = 'Mary'<br/>  return &lt;UserNameContext.Provider value={username}&gt;<br/>    &lt;Layout&gt;<br/>    &lt;div&gt;Hello&lt;/div&gt;<br/>  &lt;/UserNameContext.Provider&gt;<br/>}</span><span id="911d" class="mv me iq ki b gy nv nr l ns nt">function Layout() {<br/>  return &lt;User /&gt;<br/>}</span><span id="5230" class="mv me iq ki b gy nv nr l ns nt">function User() {<br/>  return &lt;UserNameContext.Consumer&gt;<br/>    {username =&gt; &lt;h1&gt;{username}&lt;/h1&gt;}<br/>  &lt;/UserNameContext.Consumer&gt;<br/>}</span></pre><p id="545a" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在使用上下文之前，我们需要考虑组件的设计是否正确。</p><p id="5103" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">今天，我们只讨论React的基本概念。在我们的下一篇文章中，我们将开始讨论React的<code class="fe kf kg kh ki b">components</code>。让我们期待吧。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="bfc4" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="nu">更多内容看</em> <a class="ae kz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="nu">说白了。报名参加我们的</em> <a class="ae kz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="nu">免费周报</em> </strong> </a> <em class="nu">。关注我们关于</em> <a class="ae kz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="nu">推特</em> </strong> </a>，<a class="ae kz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="nu">LinkedIn</em></strong></a><em class="nu">，</em><a class="ae kz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="nu">YouTube</em></strong></a><em class="nu">，</em> <a class="ae kz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="nu">不和</em> </strong> </a> <em class="nu">。对增长黑客感兴趣？检查</em> <a class="ae kz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="nu">电路</em> </strong> </a> <em class="nu">。</em></strong></a></p></div></div>    
</body>
</html>