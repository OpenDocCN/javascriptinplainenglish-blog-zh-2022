<html>
<head>
<title>Build a Solid and Secure Login Workflow in Next.js with Strapi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Strapi在Next.js中构建一个可靠且安全的登录工作流</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-solid-and-secure-login-workflow-in-next-js-with-strapi-part-3-social-login-and-password-7409bfad28fb?source=collection_archive---------5-----------------------#2022-03-04">https://javascript.plainenglish.io/build-a-solid-and-secure-login-workflow-in-next-js-with-strapi-part-3-social-login-and-password-7409bfad28fb?source=collection_archive---------5-----------------------#2022-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8077" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分:社交登录和密码重置</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cef10969f9afd5df5cfc74cd1fbddd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ISUgpk3QcaDZy6V6gVK7g.png"/></div></div></figure><p id="2f6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在过去的3个月里，我们使用<a class="ln lo ep" href="https://medium.com/u/ace2e82e28e6?source=post_page-----7409bfad28fb--------------------------------" rel="noopener" target="_blank">Strapi</a>(【https://strapi.io/】T3)作为后端，在Next.js中从头开始构建了一个完整的电子商务应用。</p><p id="d48a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个开发过程中，我们面临一些问题，我们需要大量的试验和错误来实现我们所寻找的行为，因为Strapi(尤其是v. 4)并不总是被很好地和正确地记录。无论如何，我们能够克服困难，并且我们记录了我们的发展道路。和我们的项目一样，我们从最烦人的任务开始:<strong class="kt ir">构建一个可靠、安全、可伸缩、可靠和可重用的登录工作流</strong></p><p id="86f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Strapi 提供了一个内置的用户管理和登录系统，可以通过社交登录进行扩展。不幸的是，大部分教程都涉及了这个系统与外部库的使用(例如<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/passwordless-authentication-in-next-js-with-nextauth-js-and-mongodb-19760c79184"> next-auth </a>)，并且文档并不总是与v. 4保持同步，所以我们决定在本教程中分享我们的经验。</p><p id="6cd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于构建生产就绪的登录系统是一项漫长而复杂的任务，我们将本教程分为3个部分:</p><ul class=""><li id="d5ef" class="lq lr iq kt b ku kv kx ky la ls le lt li lu lm lv lw lx ly bi translated"><a class="ae lp" href="https://popeating.medium.com/build-a-solid-and-secure-login-workflow-in-next-js-with-strapi-part-1-concept-and-setup-5155ebe622bb" rel="noopener">第1部分:概念和设置</a></li><li id="9dce" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated"><a class="ae lp" href="https://popeating.medium.com/build-a-solid-and-secure-login-workflow-in-next-js-with-strapi-part-2-register-and-login-4971cc7176f5" rel="noopener">第二部分:注册和登录</a></li><li id="ae12" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">第3部分:社交登录和密码重置</li></ul><p id="b839" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还可以下载或克隆这个项目的存储库，以便跟进:</p><div class="me mf gp gr mg mh"><a href="https://github.com/popeating/fullcomm" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd ir gy z fp mm fr fs mn fu fw ip bi translated">GitHub — popeating/fullcomm</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">github.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv kp mh"/></div></div></a></div><h2 id="c0b0" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated">社交登录</h2><p id="8cdf" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">在这一部分中，我们将只使用Strapi内置功能，将社交登录添加到我们的web应用程序中。作为一个例子，我们添加了谷歌和脸书，但它可以扩展到添加更多的提供商，Strapi提供了超过15个现成的集成，包括像Auth0和Cognito这样的第三方服务，以达到更多的提供商。接下来，我们假设您已经为Google和脸书配置了环境，如第1部分所述。</p><h2 id="b6d1" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated"><strong class="ak">基本工作流程</strong></h2><p id="f4d2" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">社交认证工作流如下工作(这包括我们的实现层):</p><ul class=""><li id="955a" class="lq lr iq kt b ku kv kx ky la ls le lt li lu lm lv lw lx ly bi translated">用户单击指向Strapi API端点的按钮/链接。</li><li id="645e" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">用户被重定向到提供商身份验证页面。</li><li id="554c" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">一旦用户在提供者上通过身份验证，提供者就将用户发送回Strapi API，向它传递一些数据(包括access_token)。</li><li id="cb97" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">Strapi API将access_token传递给指定的前端URL。</li><li id="eb1b" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">前端URL调用一个连接到Next.js API路由的函数，传递access_token <strong class="kt ir">我们的实现。</strong></li><li id="67af" class="lq lr iq kt b ku lz kx ma la mb le mc li md lm lv lw lx ly bi translated">Next.js API路由调用一个Strapi API端点<code class="fe nu nv nw nx b">api/auth/google/callback</code>仍然传递access_token，这个端点创建用户，如果用户已经存在它检查它是否可以登录，如果用户可以登录我们设置登录cookies(就像我们在正常登录中做的一样)<strong class="kt ir">我们的实现。</strong></li></ul><p id="822f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个工作流非常复杂(也许可以通过删除一些步骤来缩小范围)，但是我们发现它是一个很好的工作流，可以使事情保持有序，并与模式的其余部分保持一致。</p><blockquote class="ny nz oa"><p id="d813" class="kr ks ob kt b ku kv jr kw kx ky ju kz oc lb lc ld od lf lg lh oe lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong>:如果一个用户已经存在于用户群中，但是它是由不同的提供者创建的(例如，我们正在尝试使用Google登录，但是用户的电子邮件已经注册为普通登录)，Strapi会发回一个普通的<strong class="kt ir"> 405(不允许使用方法)，</strong>没有更多的细节。我们假设所有405意味着“已经向另一个提供商注册了”,并通知用户。</p></blockquote><h2 id="d99d" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated">谷歌登录</h2><p id="dcbf" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">首先，我们创建回调页面<code class="fe nu nv nw nx b">pages/user/googleCallback.js</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3dee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果通过一个访问令牌访问这个页面，我们调用一个<em class="ob"> doGoogleCallback() </em>函数(我们将在我们的UserContext中创建下一个函数)，如果这个函数返回一个‘alert ’,我们将警报消息添加到一个错误状态，我们重定向到<code class="fe nu nv nw nx b">user?msg={error}</code>,否则，我们设置用户状态，我们仍然重定向到<code class="fe nu nv nw nx b">user</code>。而登录页面会显示一个“登录谷歌”的通知。</p><p id="6a84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将<em class="ob"> doGoogleCallback() </em>添加到我们的用户上下文:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="49f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们只需将页面中收到的access_token传递给本地API。本地API <code class="fe nu nv nw nx b">pages/api/auth/google/callback.js </code>将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="44da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">API将获得Strapi的google回调端点(仍然传递access_token)，如果Strapi创建了用户(或登录了用户)，我们设置cookie(就像我们在正常登录中所做的那样)并返回到我们的页面，带有一个用户对象或带有一个错误。</p><p id="a4fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们修改了<code class="fe nu nv nw nx b">pages/user/index.js</code>，这样我们可以添加一个Google登录按钮并处理错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e80e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是完整的索引页面，已经包括了用于登录的谷歌和脸书组件，让我们在<code class="fe nu nv nw nx b">components/GoogleLogin.js</code>中添加谷歌组件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4a01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个标准的按钮，一旦点击就会重定向到<code class="fe nu nv nw nx b">http://localhost:1337/api/connect/google</code>,它是启动社交登录过程的Strapi端点；您还可以让按钮连接到一个函数，并让该函数执行重定向。</p><p id="d430" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您现在连接到<code class="fe nu nv nw nx b">http://localhost:3000/user</code>，您将看到一个带有社交登录按钮的页面。请注意，只有当您尝试使用已经向另一个提供商注册的电子邮件进行社交登录时，才会出现已经向另一个提供商注册的<em class="ob">。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/78ae47f1500444401b86f2f1efe362d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*qkef1ztgDrVrAzpKuql2NQ.png"/></div></figure><p id="3136" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您点击“通过谷歌登录”按钮，您将通过谷歌登录过程，如果您使用尚未在Strapi上注册的电子邮件，在最后您将登录，在Strapi管理面板上您将看到一个新用户已经确认了来自社交提供商的数据(用户名和电子邮件)。</p><h2 id="dc09" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated">脸书登录</h2><p id="e6fa" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">脸书登录的工作方式与谷歌登录相同，所以我们有相同的工作流程和相同的文件，但是我们将它们指向不同的API</p><blockquote class="ny nz oa"><p id="c844" class="kr ks ob kt b ku kv jr kw kx ky ju kz oc lb lc ld od lf lg lh oe lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong>:出于组织目的，我们将所有的社交登录保存在不同的文件中(即使它看起来像是重复的)，以便我们可以处理单个提供商，而不会触及其他提供商(提供商可能会不时地改变他们发送数据的方式或修改他们工作流程的某些内容</p></blockquote><p id="ae21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">至于谷歌，我们有<code class="fe nu nv nw nx b">pages/user/facebookCallback.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9421" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户上下文中的一个<em class="ob"> doFacebookCallback() </em>函数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0369" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将发布到本地的<code class="fe nu nv nw nx b">pages/api/aut/facebook/callback.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4974" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一块是<code class="fe nu nv nw nx b">components/FacebookLogin.js</code>中的FacebookLogin组件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2827" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此时，所有的登录方法都在工作(凭据、谷歌、脸书)，我们有一个页面进行注册，主页面<code class="fe nu nv nw nx b">user/index.js</code>正在显示已登录用户的用户数据(用户id —用户名—电子邮件)，还有一个注销按钮:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/5c48740adc7972a92a10e78d7a3b5173.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*Uxhhvs89bc3jMuT3vEbuQQ.png"/></div></figure><h2 id="fcfa" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated">密码丢失和密码重置</h2><p id="d095" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">对于使用电子邮件注册的用户，Strapi提供了一种重置密码的方法。有两个端点(<code class="fe nu nv nw nx b">api/auth/forgot-password</code>和<code class="fe nu nv nw nx b">api/auth/reset-passord</code>)，第一个允许用户请求带有重置密码链接的电子邮件，第二个允许用户保存新密码。</p><p id="5fdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实现这一点，我们将一如既往地使用相同的模式(UserContext中的函数，Next.js API路由中间件)，我们还需要几个页面:用户通过输入电子邮件地址请求链接的表单和用户设置新密码的页面(该页面地址在第1部分中进行了配置)。</p><p id="4098" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个页面是<code class="fe nu nv nw nx b">pages/user/forgotpassword.js</code>，该页面只能由未登录的用户访问，并显示ForgotForm组件，这是一个请求电子邮件的基本表单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7c31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">前表格组件<code class="fe nu nv nw nx b">components/ForgotForm.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="aa37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将使用<em class="ob"> react-hook-form </em>处理和验证表单，提交时将执行我们添加到用户上下文的<em class="ob"> doRemind() </em>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4980" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ob"> doRemind() </em>函数将发布到我们的本地API <code class="fe nu nv nw nx b">pages/api/auth/reminder.js</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9119" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果该电子邮件存在于系统中，则会向用户的电子邮件地址发送一条消息，其中包含重置密码的链接(在我们的例子中是<code class="fe nu nv nw nx b">http://localhost:3000/user/resetpassword</code>)。这个URL包含一个应该传递给我们的API请求的代码，以及新的密码。</p><p id="6621" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">页面<code class="fe nu nv nw nx b">pages/user/resetpassword.js</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="31d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">仅对未登录的用户可用，它包含一个位于<code class="fe nu nv nw nx b">components/ResetForm.js</code>的ResetForm组件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="21fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">表单将密码和代码(来自查询字符串)发送给另一个UserContext函数:<em class="ob"> doReset() </em>。如果密码更改正确，用户将被重定向登录。这是添加到用户上下文的<em class="ob"> doReset() </em>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="907b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该函数将新密码和代码发布到本地API端点<code class="fe nu nv nw nx b">pages/api/auth/reset.js</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4bd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后将其发送给Strapi，后者对用户执行更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7b511030ceb897ec44322939379fc9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*6_YuImr9H5MSJkCVN9gkew.png"/></div></figure><p id="e5ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一切正确，用户现在可以使用新密码登录。</p><h2 id="a087" class="mw mx iq bd my mz na dn nb nc nd dp ne la nf ng nh le ni nj nk li nl nm nn no bi translated">下一步是什么</h2><p id="143c" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">即使这个例子可以被认为是非常安全和完整的，它还可以在许多方面进行改进，例如，更复杂的错误管理可能是有用的，在localStorage中存储非敏感数据(如用户名)在某些情况下可能是有用的。</p><p id="d8eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ob">更多内容请看</em> <a class="ae lp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ob">说白了就是</em> </strong> </a> <em class="ob">。报名参加我们的</em> <a class="ae lp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ob">免费每周简讯</em> </strong> </a> <em class="ob">。关注我们</em><a class="ae lp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ob">Twitter</em></strong></a><em class="ob">和</em><a class="ae lp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ob">LinkedIn</em></strong></a><em class="ob">。加入我们的</em> <a class="ae lp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ob">社区不和谐</em> </strong> </a> <em class="ob">。</em></p></div></div>    
</body>
</html>