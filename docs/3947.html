<html>
<head>
<title>Execution Context in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的执行上下文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/execution-context-in-javascript-abe424d000b?source=collection_archive---------7-----------------------#2022-10-12">https://javascript.plainenglish.io/execution-context-in-javascript-abe424d000b?source=collection_archive---------7-----------------------#2022-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5e0c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中的执行上下文是什么？执行上下文(EC)是一段代码执行的环境。</h2></div><p id="f222" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要理解JavaScript的工作原理，首先需要理解执行上下文，因为JavaScript中发生的所有事情都发生在执行上下文中。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/82e746c7959276827ba20ac03bb1b631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibwAT_WhKgoMm8OnUAWEyA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">The above image is created by Divyojyoti Ghosh(me) on <a class="ae lo" href="http://www.canva.com/" rel="noopener ugc nofollow" target="_blank">www.canva.com</a> using different elements available for making designs.</figcaption></figure><h1 id="a5fd" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">基本概述</h1><p id="6779" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">执行上下文(EC)是一段代码执行的环境，它保存这段代码执行的所有必要信息。</p><p id="012f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">执行上下文包含三个要素—</p><ol class=""><li id="8337" class="mm mn in ke b kf kg ki kj kl mo kp mp kt mq kx mr ms mt mu bi translated">变量环境- let、const和var声明、函数和参数对象</li><li id="c934" class="mm mn in ke b kf mv ki mw kl mx kp my kt mz kx mr ms mt mu bi translated">范围链</li><li id="eee1" class="mm mn in ke b kf mv ki mw kl mx kp my kt mz kx mr ms mt mu bi translated">这个关键字</li></ol><p id="f2e7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码编译完成后，JavaScript引擎会为顶层代码(不在任何函数中的代码)创建一个全局执行上下文(GEC)。顶层代码的执行从GEC内部开始，每当一行代码调用一个函数时，就会创建该函数的执行代码。只有一个全局执行上下文，但是每个函数调用都有自己的执行上下文。</p><h1 id="35cb" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">执行上下文中的阶段</h1><p id="fd83" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">在执行环境中基本上有两个阶段——</p><ol class=""><li id="c69f" class="mm mn in ke b kf kg ki kj kl mo kp mp kt mq kx mr ms mt mu bi translated">创建阶段</li><li id="fcfc" class="mm mn in ke b kf mv ki mw kl mx kp my kt mz kx mr ms mt mu bi translated">执行阶段</li></ol><p id="f1a0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也可以这样理解，执行上下文有两个部分:内存(可变环境)和代码(执行线程)。</p><p id="92d8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一阶段，即创建阶段，所有变量都存储在变量环境或内存中。函数之外的变量被赋予一个未定义的<strong class="ke io"/>，而函数的变量保存各自函数的文字代码<strong class="ke io"/>。</p><p id="5942" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一个阶段，开始执行代码。由于Javascript是一种同步单线程语言，代码的执行是以特定的顺序一次执行一条语句。</p><p id="ca04" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将使用下面的代码片段来进一步解释执行上下文中的各个阶段。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8094" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在编译完上面的代码后，全局执行上下文将被创建，如上所述，执行上下文有两个阶段创建和线程执行。</p><h2 id="68d0" class="nc lq in bd lr nd ne dn lv nf ng dp lz kl nh ni mb kp nj nk md kt nl nm mf nn bi translated">创建阶段</h2><p id="87c7" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">在<strong class="ke io">创建阶段</strong>，顶层代码中的所有变量都将存储在变量环境中。函数以外的变量，即<code class="fe no np nq nr b">name</code>、<code class="fe no np nq nr b">marksInMaths</code>、<code class="fe no np nq nr b">marksInScience</code>、<code class="fe no np nq nr b">marksInEnglish</code>、<code class="fe no np nq nr b">marksInArts</code>、<code class="fe no np nq nr b">averageMarks</code>被赋予一个<strong class="ke io">未定义的</strong>，而函数的变量，即<code class="fe no np nq nr b">calculateAverageMarks</code>、<code class="fe no np nq nr b">calculateTotalMarks</code>保存各自的函数。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ns"><img src="../Images/9a98d4b4ee28937b1033af78ecb15720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCKIVDiyxGQBnu8TDThB8A.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">The variable environment in the Creation Phase</figcaption></figure><h2 id="b66d" class="nc lq in bd lr nd ne dn lv nf ng dp lz kl nh ni mb kp nj nk md kt nl nm mf nn bi translated">执行阶段</h2><p id="14d1" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">在下一阶段，代码开始从上到下一次执行一条语句，只有函数不被执行，因为函数只有在任何语句调用它们时才被执行。所以，如果我们再次看到代码，第18行直接在第5行之后执行。</p><p id="e1c0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在执行过程中，变量的值会根据代码中的语句在变量环境中发生变化。因此，对于第1行，即<code class="fe no np nq nr b">const name = "Joy"</code>，名称的值从未定义变为<code class="fe no np nq nr b">"Joy"</code>，类似地，所有的值都变了。</p><h2 id="1746" class="nc lq in bd lr nd ne dn lv nf ng dp lz kl nh ni mb kp nj nk md kt nl nm mf nn bi translated">执行线程—为被调用的函数创建新的执行上下文</h2><p id="e4e3" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">当第18行被执行时，即<code class="fe no np nq nr b">const averageMarks = calculateAverageMarks(marksInMaths, marksInScience,... );</code>，为被调用的函数<code class="fe no np nq nr b">calculateAverageMarks()</code>创建一个新的执行上下文。由于JavaScript只有一个执行线程，一次只能执行一个执行上下文(EC ),因此前一个EC(即GEC)的执行会停止，而新EC的执行会开始。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nt"><img src="../Images/3ad43da45fc726dcf127faaa6086e01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFcqEfihskbshkkqwOe8hA.png"/></div></div></figure><p id="c0b2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">新的执行上下文也有与GEC相同的两个阶段。在这个函数的执行阶段，当行<code class="fe no np nq nr b">const totalMarks = calculateTotalMarks(maths, science, english, arts);</code>被执行时，一个新的执行上下文被创建。一旦calculatTotalMarks()阶段的两个阶段结束，<strong class="ke io">该函数的返回值被发送到调用它的执行上下文</strong>，即calculateAverageMarks()，并且该值被保存在该执行上下文的变量环境中(<strong class="ke io"> totalMarks </strong>的值从未定义的初始值变为返回值),并且该EC的执行继续返回该值。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nu"><img src="../Images/063a9d78596b7ddfeabdce6b2aa9f4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYSlZi_Q2ExUOKIDaQK6Ow.png"/></div></div></figure><p id="d497" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类似地，一旦calculateAverageMarks()函数的所有行的执行完成，返回值将替换全局执行上下文的变量环境中的AverageMarks变量的值，并且GEC的执行将从之前停止的位置继续。</p><h1 id="d6a8" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">调用栈</h1><p id="3596" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">对于上面有两个调用函数的代码片段，创建了两个执行上下文(每个上下文一个)以及一个全局执行上下文。这意味着对于现实生活中的应用程序，每个应用程序都有数百个执行上下文(EC)。但是如何管理执行上下文的顺序呢？这由JavaScript引擎中的调用堆栈来管理。</p><p id="186e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">调用堆栈跟踪执行上下文。一旦调用了一个函数，就会为它创建一个新的EC，并将其推到调用堆栈的顶部，位于顶部的EC控制着执行，它的执行首先发生。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nv"><img src="../Images/44ab03b97c7494bef4c287e12bb39bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j02TG832jLiL0uGlCoMhRg.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">The sequence of execution in the call stack</figcaption></figure><p id="3960" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并且一旦该EC的执行结束，就从堆栈中移除该EC，并且控制返回到前一个EC。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nw"><img src="../Images/3f88fe87a409644a4f978bc6d1be645b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cS9Y3zOJxK2NmO7qEesn0Q.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">EC that gets executed is removed from the call stack</figcaption></figure><p id="aded" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">调用栈通过管理整个执行线程，在JavaScript引擎中扮演着重要的角色。</p><h1 id="27c8" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">摘要</h1><p id="102e" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">执行上下文(EC)是一段代码执行的环境。为应用程序创建单个全局执行上下文，并创建多个执行上下文(每个函数调用一个)。在执行上下文中基本上有两个阶段，创建阶段和执行阶段。对于每个函数调用，都会创建一个新的EC，并且控制转移到新的EC，一旦该EC的执行结束，控制就转移到前一个EC。这种控制和执行的转换顺序是由调用堆栈管理的。</p><h1 id="6d03" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">资源</h1><p id="65b9" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated"><a class="ae lo" href="https://www.udemy.com/course/the-complete-javascript-course" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/the-complete-javascript-course</a></p><div class="nx ny gp gr nz oa"><a href="https://gist.github.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">发现要点</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">你好。在本文档中，我们将介绍如何在一个…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">gist.github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo li oa"/></div></div></a></div><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="op nb l"/></div></figure></div><div class="ab cl oq or hr os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ig ih ii ij ik"><p id="a82d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ox">更多内容看</em> <a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ox">说白了。报名参加我们的</em> <a class="ae lo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ox">免费周报</em> </strong> </a> <em class="ox">。关注我们关于</em> <a class="ae lo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ox">推特</em></strong></a><a class="ae lo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ox">LinkedIn</em></strong></a><em class="ox"/><a class="ae lo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ox">YouTube</em></strong></a><em class="ox"/><a class="ae lo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ox">不和</em> </strong> </a> <em class="ox">。对增长黑客感兴趣？检查</em> <a class="ae lo" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ox">电路</em> </strong> </a> <em class="ox">。</em></strong></a></p></div></div>    
</body>
</html>