<html>
<head>
<title>React Interview Questions — MCQs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回应面试问题— MCQs</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-interview-questions-mcqs-69be6132af33?source=collection_archive---------1-----------------------#2022-09-19">https://javascript.plainenglish.io/react-interview-questions-mcqs-69be6132af33?source=collection_archive---------1-----------------------#2022-09-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e26f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">技术能力倾向测验中常见选择题列表。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f2c256edab15053f129436f5355d87f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BxG-zKdS_aN16V6D"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@nguyendhn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nguyen Dang Hoang Nhu</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="afcc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React是一个<strong class="kv io">开源JavaScript库</strong>，主要用于设计和开发<strong class="kv io">可重用组件</strong>。具有JavaScript背景的开发人员可以很容易地学习React并动手操作。React是web开发人员和组织正在使用的最流行的前端技术。如果你正在准备React面试，下面是你必须知道的问题列表。</p><p id="a71a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面列出了在不同平台上最常被问到的React问题，这些问题用于进行第一轮筛选。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="cee0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 1。React使用真实的DOM吗？</strong></p><p id="fa23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.真<br/> B .假</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="ac37" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 2。以下哪一项不是React生命周期方法？</strong></p><p id="6c45" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.<code class="fe lw lx ly lz b">static getDerivedStateFromProps() </code><br/>b .<code class="fe lw lx ly lz b">shouldComponentUpdate()</code><br/>c .<code class="fe lw lx ly lz b">getSnapshotBeforeUpdate()</code><br/>d .<code class="fe lw lx ly lz b">gethandleChange()</code></p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="edb7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 3。纯组件内部使用哪种生命周期方法？</strong></p><p id="1db1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.<code class="fe lw lx ly lz b">shouldComponentUpdate()</code><br/>b .<code class="fe lw lx ly lz b"> getSnapshotBeforeUpdate()</code><br/>c .<code class="fe lw lx ly lz b">static getDerivedStateFromProps()</code><br/>d .<code class="fe lw lx ly lz b">componentDidMount()</code></p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="eb43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 4。React钩子是在哪个React版本中引入的？</strong></p><p id="5955" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.16.2<br/>b . 16.4<br/>c . 16.6<br/>d . 16.8</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="e0e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 5。借助钩子，无需编写类就可以使用状态和反应生命周期。</strong></p><p id="1d27" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.真<br/> B .假</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="20be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 6。useState钩子的返回值是什么？</strong></p><p id="8211" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.当前状态<br/> B .函数更新当前状态<br/> C .当前状态和函数更新当前状态的配对<br/> D. UseState返回nothing</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="b73b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了方便起见，我在这里给出了前6个选择题的答案:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ma"><img src="../Images/689ae80dd453683667f61f6cb15e34f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NsDZ7XcNJE3SAvRP"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@michalmatlon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michal Matlon</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><ol class=""><li id="7ee6" class="mb mc in kv b kw kx kz la lc md lg me lk mf lo mg mh mi mj bi translated"><strong class="kv io"> B </strong> <br/> React内部使用虚拟DOM。它是真实DOM的内存虚拟表示。计算当前和先前虚拟DOM表示之间的差异，并且将唯一的差异更新到真实DOM，这有助于增强应用程序的性能。</li><li id="c982" class="mb mc in kv b kw mk kz ml lc mm lg mn lk mo lo mg mh mi mj bi translated"><strong class="kv io"> D </strong> <br/> <code class="fe lw lx ly lz b">gethandleChange()</code>不是React生命周期方法。下面是React生命周期方法的列表:<br/> <br/> 1。<code class="fe lw lx ly lz b">static getDerivedStateFromProps()<br/></code> 2。<code class="fe lw lx ly lz b">render()<br/></code> 3。<code class="fe lw lx ly lz b">componentDidMount()<br/></code> 4。<code class="fe lw lx ly lz b">static getDerivedStateFromProps()</code> <br/> 5。<code class="fe lw lx ly lz b">shouldComponentUpdate()</code> <br/> 6。<code class="fe lw lx ly lz b">getSnapshotBeforeUpdate()</code> <br/> 7。<code class="fe lw lx ly lz b">componentDidUpdate()</code> <br/> 8。<code class="fe lw lx ly lz b">componentWillUnmount()</code></li><li id="b9ed" class="mb mc in kv b kw mk kz ml lc mm lg mn lk mo lo mg mh mi mj bi translated"><strong class="kv io">A</strong>T24<code class="fe lw lx ly lz b">shouldComponentUpdate()</code>方法由纯组件在内部处理。说明:根据应用程序的状态或道具是否改变，纯组件确定是否重新渲染。它通过在内部处理前一个和下一个状态的浅层比较来提高性能。</li><li id="bb54" class="mb mc in kv b kw mk kz ml lc mm lg mn lk mo lo mg mh mi mj bi translated"><strong class="kv io">D</strong>T27】16.8<br/>说明:16.8版本增加了React钩子。通过使用React钩子，我们可以在功能组件中拥有状态和生命周期方法。在16.8版之前，我们无法在功能组件中使用状态和生命周期方法。为此，我们必须使用类组件。</li><li id="d46a" class="mb mc in kv b kw mk kz ml lc mm lg mn lk mo lo mg mh mi mj bi translated"><strong class="kv io">一</strong>一<br/>真</li><li id="d586" class="mb mc in kv b kw mk kz ml lc mm lg mn lk mo lo mg mh mi mj bi translated"><strong class="kv io"> C </strong> <br/>对当前状态和功能进行更新。<br/>解释:我们可以使用<code class="fe lw lx ly lz b">useState()</code>钩子在函数组件内部设置状态。<code class="fe lw lx ly lz b">useState()</code>接受初始状态值作为默认值，并返回当前状态和更新当前状态的方法。</li></ol></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="821f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我将继续回答其余的问题。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/7869a7043d6c5e291cf8d9f4c232f585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rCK7pSLT293cMXBT"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@turkomarketing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Remi Turcotte</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="faf8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 7。哪种说法更适合下面的代码片段？</strong></p><pre class="kd ke kf kg gt mq lz mr ms aw mt bi"><span id="b366" class="mu mv in lz b gy mw mx l my mz">useEffect(() =&gt; {<br/>         //Code logic <br/>        }, [TnS_user]);</span></pre><p id="c397" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.效果仅在挂载<br/>时运行b .如果TnS _用户值为真<br/>效果重新运行c .当且仅当TnS _用户变量的值发生变化<br/> D .以上所有</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="d865" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 8。以下哪一项不是网格断点？</strong></p><p id="6006" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.xs <br/> B. sm <br/> C. md <br/> D. xd</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="18c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 9。在React中，组件名应该总是以大写字母开头，因为React将以小写字母开头的组件视为DOM标签。</strong></p><p id="ef61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.真<br/> B .假</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="6970" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 10。关于</strong> <code class="fe lw lx ly lz b"><strong class="kv io">React.lazy</strong></code> <strong class="kv io">，以下哪一项是正确的？</strong></p><p id="bdd9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.它有助于大数据的动态渲染。<br/> B .用于处理异步函数。c .它将动态导入作为常规组件呈现。<br/> D .它限制组件重新渲染。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="4c0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 11。以下哪种方法用于在React错误边界中呈现回退UI？</strong></p><p id="b004" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.<code class="fe lw lx ly lz b">static getDerivedStateFromProps()</code><br/>b .<code class="fe lw lx ly lz b">static getDerivedStateFromError()</code><br/>c .<code class="fe lw lx ly lz b">componentWillCatch()</code><br/>d .<code class="fe lw lx ly lz b">shouldComponentCatch()</code></p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="9f47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 12。错误边界不会捕捉以下哪种错误？</strong></p><p id="b809" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.<code class="fe lw lx ly lz b">setTimeout()</code> <br/> B .事件处理程序<br/> C .服务器端渲染<br/> D .以上全部</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="9da0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 13。在React中，我们可以通过使用？</strong></p><p id="a220" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.<code class="fe lw lx ly lz b">preventDefault()</code><br/>b .<code class="fe lw lx ly lz b">DefaultPrevent()</code><br/>c .<code class="fe lw lx ly lz b">stopDefault()</code><br/>D . A和D</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="a52b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">14。Comp1、Comp2和Comp3是三个react组件。考虑到在父组件的渲染中调用了以下代码片段，哪一个是正确的？</p><pre class="kd ke kf kg gt mq lz mr ms aw mt bi"><span id="3017" class="mu mv in lz b gy mw mx l my mz">1. <!-- -->return (<br/>    &lt;div&gt;<br/>      &lt;<!-- -->Comp1<!-- -->/&gt;<br/>      &lt;<!-- -->Comp2<!-- -->/&gt;<br/>      &lt;<!-- -->Comp3<!-- -->/&gt;<br/>    &lt;/div&gt;<br/>  );<br/> <br/>2. <!-- -->return (<br/>      &lt;<!-- -->Comp1<!-- -->/&gt;<br/>      &lt;<!-- -->Comp2<!-- -->/&gt;<br/>      &lt;<!-- -->Comp3<!-- -->/&gt;<br/>  );</span><span id="4156" class="mu mv in lz b gy na mx l my mz">3. <!-- -->return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;<!-- -->Comp1<!-- -->/&gt;<br/>      &lt;<!-- -->Comp2<!-- -->/&gt;<br/>      &lt;<!-- -->Comp3<!-- -->/&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );</span><span id="1a72" class="mu mv in lz b gy na mx l my mz">4. <!-- -->return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;<!-- -->Comp1<!-- -->/&gt;<br/>      &lt;<!-- -->Comp2<!-- -->/&gt;<br/>    &lt;/React.Fragment&gt;<br/>    &lt;<!-- -->Comp3<!-- -->/&gt;<br/>  );</span><span id="dee6" class="mu mv in lz b gy na mx l my mz">5. <!-- -->return (<br/>   &lt;div&gt;<br/>      &lt;div&gt;<br/>         &lt;<!-- -->Comp1<!-- -->/&gt;<br/>         &lt;<!-- -->Comp2<!-- -->/&gt;<br/>      &lt;/div&gt;<br/>         &lt;<!-- -->Comp3<!-- -->/&gt;<br/>   &lt;/div&gt;<br/>  );</span></pre><p id="1d44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">A.1，2，5 <br/> B. 1，3，5 <br/> C. 2，3，5 <br/> D. 4，5</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="b6fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以下是问题7-12的答案列表。请检查上述问题1-6的答案。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/7aa3ccdb811271cf952095f5e30b3110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HQ8LV3KcC5RGGymv"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@fotonium?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Akhilesh Sharma</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ae12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">7.当且仅当TnS _用户变量的值改变时，效果才重新运行。<br/>解释:问题中给出的代码片段具有useEffect钩子，其功能类似于<code class="fe lw lx ly lz b">shouldComponentUpdate()</code>方法。作为第二个参数传递给<code class="fe lw lx ly lz b">useEffect()</code>的数组可以是空的<strong class="kv io">或者可能有一些状态变量。<br/>如果数组为空，它将像<code class="fe lw lx ly lz b"><strong class="kv io">componentDidMount()</strong></code>一样运行，并且在渲染组件时只被调用一次。根据给定的例子，如果它有任何状态变量，它将只在<strong class="kv io">状态变量的值更新</strong>时被调用。</strong></p><p id="4b85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">8.<strong class="kv io"> D </strong> <br/>下面是网格断点及其分辨率的列表。<br/> 1。sm —用于屏幕分辨率<strong class="kv io"> ≥ 576px </strong>的小屏幕设备。<br/> 2。md —适用于屏幕分辨率<strong class="kv io"> ≥ 768px </strong>的平板设备。<br/> 3。lg —适用于屏幕分辨率<strong class="kv io"> ≥ 992px </strong>的笔记本电脑等较大设备。<br/> 4。xl —用于超大设备，如屏幕分辨率<strong class="kv io"> ≥1200px </strong>的台式机。</p><p id="4e23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">9.A  <br/>真<br/>解释:在React中我们用JSX。在JSX，所有小写标签都被认为是HTML标签。因此，为了避免这种冲突，react组件名称应该以大写字母开头。</p><p id="f3b8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">10.<strong class="kv io"> C </strong> <br/>它将动态导入渲染为常规组件。<br/>解释:<code class="fe lw lx ly lz b">React.lazy</code>函数让您将动态导入渲染为常规组件。</p><pre class="kd ke kf kg gt mq lz mr ms aw mt bi"><span id="4bc8" class="mu mv in lz b gy mw mx l my mz">//Without React.lazy()<br/>import LazyComponent from './LazyComponent';</span><span id="ebfb" class="mu mv in lz b gy na mx l my mz">//with React.lazy()<br/>const LazyComponent = React.lazy(() =&gt; import('./LazyComponent'));</span></pre><p id="5921" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当这个组件第一次被渲染时，它将自动加载包含<code class="fe lw lx ly lz b">LazyComponent. React.lazy</code>的包，这个包采用一个必须调用动态<code class="fe lw lx ly lz b">import()</code>的函数。这必须返回一个<code class="fe lw lx ly lz b">Promise</code>，它解析为一个带有包含React组件的<code class="fe lw lx ly lz b">default</code>导出的模块。</p><p id="859c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">11.<strong class="kv io"> B </strong>早先在JavaScript中没有办法处理这个问题，但是react在v-16中提供了错误边界。<br/>错误边界不过是react组件，它将捕捉任何子组件中的错误，记录该错误，并显示回退UI，而不是显示空白的崩溃页面，该UI将向用户提供一些有意义的消息，而不是显示崩溃的应用程序。<br/>错误边界不捕捉<code class="fe lw lx ly lz b">setTimeout()</code>的错误、事件处理程序以及错误边界本身发生的错误。</p><p id="bbb1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">12.<strong class="kv io"> D </strong></p><p id="dd4d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">13.<strong class="kv io"> A </strong> <br/> <code class="fe lw lx ly lz b">preventDefault()</code> <br/>解释:为了防止事件处理程序的默认行为，我们可以使用<strong class="kv io"> event.preventDefault() </strong>。它将阻止浏览器发出默认行为。</p><p id="a874" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">14.<strong class="kv io">B<br/>T30】1，3，5 <br/>说明:React render应该总是返回单个对象。我们可以有嵌套的封闭标签，这些标签必须被一个父标签所封闭。在选项3中，我们有React <strong class="kv io">片段</strong>，这些片段<strong class="kv io">没有向DOM添加额外的节点</strong>，因此被认为比div更好。</strong></p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="5e9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我碰到的React的几个选择题的列表。我试图根据我的理解和知识来解释。就这样，我们到了这篇文章的结尾。如果你觉得这篇文章有帮助，请不要忘记检查其他文章！</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="b547" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nc">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">plain English . io</em></strong></a><em class="nc">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">LinkedIn</em></strong></a><em class="nc"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">YouTube</em></strong></a><em class="nc"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">不和</em> </strong> </a> <em class="nc">。对增长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">电路</em> </strong> </a> <em class="nc">。</em></p></div></div>    
</body>
</html>