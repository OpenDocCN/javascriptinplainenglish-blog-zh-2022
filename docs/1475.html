<html>
<head>
<title>Cache Website Assets in “Offline Mode”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在“离线模式”下缓存网站资产</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/cache-website-assets-in-offline-mode-fb843c58feef?source=collection_archive---------1-----------------------#2022-03-27">https://javascript.plainenglish.io/cache-website-assets-in-offline-mode-fb843c58feef?source=collection_archive---------1-----------------------#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6558" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用JavaScript服务工作者</h2></div><p id="d0e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你正在开发一个普通的网络应用程序，那么“离线模式”可能是一个额外的好处，或者如果你正在开发一个<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps" rel="noopener ugc nofollow" target="_blank">渐进式网络应用程序</a>，那么它可能是一个必需的特性。离线模式的最基本版本是静态资产的缓存和离线时访问它们的方法。</p><p id="c636" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将编写一个服务人员，并为一个JS应用程序构建一个离线模式，这里有一个<a class="ae lb" href="https://www.tinycode.dev/service-worker/" rel="noopener ugc nofollow" target="_blank">实时演示</a>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/60c4f0372dfc28c4f7e62339a3190925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aEdaGgEV4P2wPvmX"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">credit: <a class="ae lb" href="https://unsplash.com/@daveherring" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@daveherring</a></figcaption></figure><h1 id="4f85" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">服务人员</h1><p id="119a" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">一个<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" rel="noopener ugc nofollow" target="_blank">服务工作者</a>是一个Javascript进程，作为你的应用程序的中间件，处理从你的网页到互联网的传出和传入请求。</p><p id="7aea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它类似于<a class="ae lb" href="https://alexzitowolf.medium.com/javascript-web-workers-15fe903a5774" rel="noopener"> Web Worker </a>，因为它运行在浏览器中一个独立的非阻塞线程上，不访问DOM。与Web Worker不同，它有一组特定的自定义方法和属性，允许它处理和缓存来自应用程序的所有网络请求。如果你想深入了解服务人员的特征，我建议你阅读<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" rel="noopener ugc nofollow" target="_blank"> MDN规范</a>。</p><p id="aded" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">拦截和缓存来自给定网页的网络请求的能力使服务人员成为实现离线模式的完美工具！</p><h1 id="fb8d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">启动服务人员</h1><p id="5df0" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们启动服务人员的方式如下。我们需要将这一行添加到主脚本(<code class="fe mp mq mr ms b">index.js</code>)中。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4cea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一行将运行服务工作者脚本，并启动在您的浏览器中运行的软件。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/871b375888b42ef7deab8c7726df1991.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/0*ueL4VSIgRZrVBUrt"/></div></figure><p id="5517" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然这是行不通的，因为我们实际上还没有编写web worker脚本，当我们调用<code class="fe mp mq mr ms b">serviceWorker.register()</code>时，它将由浏览器运行。</p><p id="975c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从下面的代码开始，插入到另一个名为<code class="fe mp mq mr ms b">sw.js</code>的文件中:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="76a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务工作器代码将简单地读取浏览器发送的每个请求，并在将其传递回浏览器之前将其记录到控制台。</p><blockquote class="mw mx my"><p id="1ea7" class="kf kg mz kh b ki kj jr kk kl km ju kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated">请注意，我们确实需要克隆请求，而不是将相同的响应对象发送回浏览器。</p></blockquote><h1 id="8ba0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">贮藏</h1><p id="7a7f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">创建离线模式的下一步是实现一些文件缓存。因此，我们将在下面创建一个名为<code class="fe mp mq mr ms b">cacheAndRespond</code>的方法，在自定义缓存中缓存浏览器发出的每个请求。</p><p id="2589" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务人员有自己的内置缓存<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank"/>，存储在长期内存中，还有一个API来制定响应，并将它们发送回您正在运行的应用程序。您可以使用<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/add'" rel="noopener ugc nofollow" target="_blank"> Cache.add() </a>或<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete" rel="noopener ugc nofollow" target="_blank"> Cache.delete() </a>在缓存中添加和删除记录。</p><blockquote class="nd"><p id="973d" class="ne nf iq bd ng nh ni nj nk nl nm la dk translated">服务工作器缓存有50MB，大约是localStorage和sessionStorage最大容量的10倍。</p></blockquote><figure class="nn no np nq nr lh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4e1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当页面第一次加载时，服务人员将处理来自web页面的所有请求，并在处理它们时将它们插入到自定义缓存中。如果你使用chrome开发者工具检查缓存，你会看到用户访问网页时加载的所有缓存资产。这是因为服务人员在浏览器触发请求时拦截了每一个请求，对其进行处理，然后将其发送回用户。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ns"><img src="../Images/8f0ba727d26a3da9ebb84bb584c8554e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dy1OLH9V25mlsrqw"/></div></div></figure><blockquote class="mw mx my"><p id="aa59" class="kf kg mz kh b ki kj jr kk kl km ju kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated">注意:静态资产的缓存也由浏览器处理，但不是以这种微调和可定制的方式。例如，默认浏览器缓存不能创建离线模式。</p></blockquote><h1 id="f5c7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">离线页面</h1><p id="f122" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">最后一步是创建一个充当“离线模式”的页面，反映服务人员已经缓存在他们的浏览器中的所有资产(换句话说，就是那些可以离线使用的资产)。下面是该页面的外观:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/595a66fb350362de7715db2e1424ea9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/0*H1G5K8kyCxjCNWrm"/></div></figure><p id="0e52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要实现这一点，我们只需要一个简单的名为<code class="fe mp mq mr ms b">offline.html</code>的html页面，用这样的代码获取缓存，然后将结果作为链接列表打印出来。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="44c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我创建了一个<a class="ae lb" href="https://www.tinycode.dev/service-worker/" rel="noopener ugc nofollow" target="_blank">演示站点</a>，它实现了如上所述的基本缓存，以及一个离线页面，它允许您查看存储在缓存中的所有资产，即使您无法访问互联网。打开页面，用你的浏览器开发工具检查它，看看我们上面写的所有脚本是如何一起工作的。</p><h1 id="2f0e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">去月球</h1><p id="545f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">除了离线存储之外，这种技术还能给你带来很多好处，并且是简洁的web开发领域中的一位后起之秀推荐的工具之一，<a class="ae lb" href="https://gomakethings.com/the-amazing-power-of-service-workers/" rel="noopener ugc nofollow" target="_blank"> Chris Ferdinandi </a>。以下是一些最佳使用案例:</p><ol class=""><li id="10ae" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated">提供应用程序的脱机版本。如果用户过去访问过您的站点或在那里保存过数据，您可以允许他们继续使用您的站点和缓存的内容</li><li id="1f2a" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">高速缓存。如果你想让你的网站更快，缓存可能是实现这一目标的最佳方式之一。</li><li id="b6b0" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">模仿API响应。对于一个轻量级的模拟API，您可以使用一个服务工作者来映射一些HTTP路由("/api/items ")和浏览器接收到的响应。这比为了测试而竖起服务器要快得多。</li></ol><h2 id="d881" class="oi lt iq bd lu oj ok dn ly ol om dp mc ko on oo me ks op oq mg kw or os mi ot bi translated">编码快乐！</h2><p id="fb7a" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">~亚历克斯</p><p id="2dbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">来源:</strong></p><ol class=""><li id="25ce" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated">https://developer.mozilla.org/en-US/docs/Web/API/Cache<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank"/></li><li id="ccc8" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Service _ Worker _ API/Using _ Service _ Workers</a></li><li id="1b48" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated"><a class="ae lb" href="https://gomakethings.com/the-amazing-power-of-service-workers/" rel="noopener ugc nofollow" target="_blank">https://gomake things . com/the-amazing-power-of-service-workers/</a></li><li id="a37f" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated"><a class="ae lb" href="https://gomakethings.com/saving-recently-viewed-pages-offline-with-service-workers-and-vanilla-js/" rel="noopener ugc nofollow" target="_blank">https://gomake things . com/saving-recent-viewed-pages-offline-with-service-workers-and-vanilla-js/</a></li><li id="3b14" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated"><a class="ae lb" href="https://developer.chrome.com/docs/workbox/service-worker-overview/" rel="noopener ugc nofollow" target="_blank">https://developer . chrome . com/docs/work box/service-worker-overview/</a></li></ol></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><p id="9740" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">更多内容看</em> <a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mz">说白了。报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mz">免费周报</em> </strong> </a> <em class="mz">。关注我们关于</em><a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mz">Twitter</em></strong></a>，<a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mz">LinkedIn</em></strong></a><em class="mz">，</em><a class="ae lb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mz">YouTube</em></strong></a><em class="mz">，以及</em> <a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mz">不和</em> </strong> </a> <em class="mz">。对增长黑客感兴趣？检查出</em> <a class="ae lb" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mz">电路</em> </strong> </a> <em class="mz">。</em></strong></a></p></div></div>    
</body>
</html>