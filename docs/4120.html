<html>
<head>
<title>There’s No Magic in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应没有魔力</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/theres-no-magic-in-react-52d8d91a92a3?source=collection_archive---------0-----------------------#2022-10-27">https://javascript.plainenglish.io/theres-no-magic-in-react-52d8d91a92a3?source=collection_archive---------0-----------------------#2022-10-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/cf3507632b1d78dc409103145c0ac7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YlUldTKa8fXkesa-"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/es/@almosbech?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Almos Bechtold</a> on <a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="fe0d" class="pw-subtitle-paragraph ka jc jd bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">每个React开发人员都应该知道的JavaScript基础，以揭示其背后的技巧！</h2></div><p id="e40e" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个标题听起来可能很明显，但是自从我开始教编码，我看到一些开发人员，当他们不明白发生了什么时，会认为有某种魔法在发生。</p><figure class="lp lq lr ls gt ip gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/76027e435d7d3883ea6529cc17d13ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*c_aYBrJj7kJAjRQwhp-Kpg.gif"/></div></figure><p id="afb5" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这几行代码的目的是通过回顾“<strong class="ku je">普通JavaScript </strong>”的一些基本概念，并了解这如何应用于React流，来理解每次我们更新状态时组件内部发生了什么。</p><h2 id="5d34" class="lt lu jd bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">议程</h2><ul class=""><li id="93a6" class="mm mn jd ku b kv mo ky mp lb mq lf mr lj ms ln mt mu mv mw bi translated">回顾一下JavaScript中的作用域和闭包。</li><li id="7062" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">这两个概念如何影响我们在React(使用状态)中的流程。</li><li id="44f2" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">用值更新状态和用updater函数更新状态的区别。</li><li id="d817" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">概述JavaScript中对象的引用。</li><li id="0d99" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">如何处理React中的引用？</li></ul></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h2 id="1fd3" class="lt lu jd bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">你还记得什么是范围吗？</h2><p id="3e30" class="pw-post-body-paragraph ks kt jd ku b kv mo ke kx ky mp kh la lb nj ld le lf nk lh li lj nl ll lm ln ig bi translated">作用域是一组<strong class="ku je">环境</strong>。Kyle Simpson将它们描述为桶的集合，我们可以在那里存储我们的声明和价值观。然后，在执行时，我们将能够从同一个桶中访问它们。</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">JavaScipt scope</figcaption></figure><p id="e9e7" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上面的例子是这样工作的:JS运行时引擎将从“全局范围”开始遍历我们的代码，这里我们只有一个声明，就是<code class="fe no np nq nr b">count</code>。然后，当我们第一次调用count时，JS引擎初始化一个新的作用域，我们可以称之为“count的作用域”。对于JavaScript，这是一个全新的维度。这里我们有<strong class="ku je">不同的变量和声明</strong>，只能从作用域内部访问，不能从外部访问。一旦我们完成并且函数返回，这个环境将被废弃。这里我们声明<code class="fe no np nq nr b">n</code>等于<code class="fe no np nq nr b">0</code>，并对其求和<code class="fe no np nq nr b">1</code>，最后记录其值。</p><p id="6da7" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果我们再次调用count会发生什么？显然，又要打印<code class="fe no np nq nr b">1</code>了，因为新的调用总是会设置一个新的范围并再次声明<code class="fe no np nq nr b">let n = 0</code>。</p><p id="8fcb" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">坚持这个作用域的概念，如果我们尝试在最后一行记录<code class="fe no np nq nr b">n</code>，我们会得到<code class="fe no np nq nr b">undefined</code>，因为<code class="fe no np nq nr b">n</code> <strong class="ku je">正好存在于【计数的作用域】</strong>中，我们无法访问。</p><p id="d55a" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">那么，我们如何得到一个每次调用函数都会更新的变量呢？</p><p id="dccd" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">遵循这个概念:<em class="ns">“每个作用域可以访问它的外部作用域”</em>，我们可以上移一个作用域的<code class="fe no np nq nr b">n</code>，这样当我们调用count时，我们将总是引用同一个声明，并且我们不断更新它的值，所以在最后一行，我们将打印<code class="fe no np nq nr b">2</code>。</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">JavaScipt scope 2</figcaption></figure><p id="60f4" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是污染了几个变量的全局范围就很不方便了，不是吗？</p><h2 id="0baf" class="lt lu jd bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">那么闭包呢？</h2><p id="8c79" class="pw-post-body-paragraph ks kt jd ku b kv mo ke kx ky mp kh la lb nj ld le lf nk lh li lj nl ll lm ln ig bi translated">闭包可以完美地解决这个问题。在这里，您可以找到闭包的定义:</p><blockquote class="nt"><p id="ab48" class="nu nv jd bd nw nx ny nz oa ob oc ln dk translated">“一个<!-- -->闭包就是一个函数能够记住并访问它的词法范围，即使这个函数是在它的词法范围之外执行的。”</p></blockquote><p id="6096" class="pw-post-body-paragraph ks kt jd ku b kv od ke kx ky oe kh la lb of ld le lf og lh li lj oh ll lm ln ig bi translated">在下面的代码中，我们能够调用函数<code class="fe no np nq nr b">counter</code>，该函数将返回另一个函数，我们将该函数赋值给<code class="fe no np nq nr b">count</code>。每次我们调用<code class="fe no np nq nr b">count</code>时，我们从外部作用域(第2行)访问<code class="fe no np nq nr b">n</code>,并不断更新它的值，所有事情都将孤立地发生，不会污染全局作用域。</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Example of Closure</figcaption></figure><h2 id="a9f4" class="lt lu jd bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">状态在哪里更新？</h2><p id="70ae" class="pw-post-body-paragraph ks kt jd ku b kv mo ke kx ky mp kh la lb nj ld le lf nk lh li lj nl ll lm ln ig bi translated">往前走动动反应，但是要记住我们之前说的:<em class="ns">一个声明存在</em> <strong class="ku je"> <em class="ns">只有</em> </strong> <em class="ns">在其作用域</em>内。为什么我们惊讶地发现在这段代码中它仍然记录了<code class="fe no np nq nr b">0</code>？</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Pseudo code for useState Hook</figcaption></figure><p id="ba52" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个<code class="fe no np nq nr b">useState</code>钩子的伪实现中，我们看到我们创建了<code class="fe no np nq nr b">state</code>,我们将它和一个更新它的函数一起返回。这个概念和我们刚才看到的差不多。每当我们调用<code class="fe no np nq nr b">setState</code>函数来更新状态时，我们实际上是在改变<strong class="ku je">使用范围State </strong>内变量的值，这与组件的<strong class="ku je">范围完全不同。当我们在最后一行记录<code class="fe no np nq nr b">state</code>时，我们仍然引用在<code class="fe no np nq nr b">Component</code>内部分配的值，它仍然是<code class="fe no np nq nr b">0</code>。</strong></p><p id="38d6" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我现在想问一个问题:<em class="ns">有钩子的主要区别是什么？</em></p><p id="b1ef" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">以前，functions组件被用来呈现表象，这些组件没有状态，但是使用它们的传入道具来呈现。所以他们是无国籍的，对吗？</p><p id="c160" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在我看来，与having的主要区别在于:现在<strong class="ku je">，</strong>我们可以<strong class="ku je">在函数调用</strong>之间保持状态。正如我们在开始时所说的，每个函数调用都初始化一个新的作用域，并且只保存自己的值。在下面的代码中，我们可以看到我们将如何再次调用<code class="fe no np nq nr b">Component</code>，它将从<code class="fe no np nq nr b">useState</code>钩子接收最新的值，钩子总是访问相同的声明，这次将是<code class="fe no np nq nr b">1</code>。</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Multiple Component function calls</figcaption></figure><p id="45a0" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">理解每个渲染都是一个新的函数调用是至关重要的，每个函数调用都用声明和值来设置它的新范围。</p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h2 id="0249" class="lt lu jd bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">用值或更新程序更新状态</h2><p id="ecc6" class="pw-post-body-paragraph ks kt jd ku b kv mo ke kx ky mp kh la lb nj ld le lf nk lh li lj nl ll lm ln ig bi translated">现在，你能告诉我这段代码会在屏幕上显示什么吗？</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Counter component with setInterval</figcaption></figure><p id="e51f" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你的猜测是什么？<em class="ns">(前方剧透…) </em></p><p id="9ba4" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">一旦你给出了你的答案，打开这个<a class="ae ja" href="https://codesandbox.io/s/counter-with-interval-im0sxb?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">沙盒</a>看看你是否是正确的，并尝试为你的计数器实现一个解决方案。如果你需要提示，请继续阅读。</p><p id="0c08" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">看一看这个<strong class="ku je">伪</strong>版本的<code class="fe no np nq nr b">useState</code>钩子(你可以在沙箱的<code class="fe no np nq nr b">useState.js</code>文件中找到代码),记住我们到目前为止所说的关于闭包的内容，试着一行一行地跟随流程。</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Pseudo useState implementation</figcaption></figure><p id="ec4d" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以让我来指导你扔这个。首先，它调用<code class="fe no np nq nr b">useState</code>并将状态初始化为<code class="fe no np nq nr b">0</code>，该状态以元组的形式返回，并带有更新它的函数。现在，在“使用范围状态”和“计数器范围”中，<code class="fe no np nq nr b">_state</code>和<code class="fe no np nq nr b">count</code>都是<code class="fe no np nq nr b">0</code>。<br/>然后我们调用<code class="fe no np nq nr b">useEffect</code>一次，因为空数组的依赖关系。这将设置一个间隔，每秒将调用<code class="fe no np nq nr b">setCount</code>通过<code class="fe no np nq nr b">count</code>。这里是<strong class="ku je">重要的部分</strong>。设置间隔我们在第一个“计数器范围”中声明一个新的匿名函数作为回调。每次我们调用这个回调函数时，它都会在同一个范围内寻找<code class="fe no np nq nr b">count</code>的值，其中<code class="fe no np nq nr b">count</code>总是<code class="fe no np nq nr b">0</code>。调用<code class="fe no np nq nr b">setCount</code>时，我们实际上在做以下事情:</p><pre class="lp lq lr ls gt oi nr oj ok aw ol bi"><span id="9d19" class="lt lu jd nr b gy om on l oo op">setCount(0 + 1) // =&gt; 1</span></pre><p id="4b25" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这就是为什么我们总是在屏幕上看到<code class="fe no np nq nr b">1</code>，即使间隔正在运行。</p><p id="9e62" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">怎么才能解决呢？我们应该能够访问count的最新值，即包含在useState范围内的值，以便不依赖于“counter范围”中的值。幸运的是,<code class="fe no np nq nr b">useState</code>钩子给了我们传递一个更新函数的可能性，该函数将最后一次计算的值作为参数。</p><pre class="lp lq lr ls gt oi nr oj ok aw ol bi"><span id="7064" class="lt lu jd nr b gy om on l oo op">setCount((count) =&gt; count + 1)</span></pre><p id="760c" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这保证了我们将把1加到最新的值上，并且我们的计数器现在将正常工作。</p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h2 id="7c5d" class="lt lu jd bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">原语和引用</h2><p id="211a" class="pw-post-body-paragraph ks kt jd ku b kv mo ke kx ky mp kh la lb nj ld le lf nk lh li lj nl ll lm ln ig bi translated">JS开发人员的另一个困惑来源是<strong class="ku je">原语和对象</strong>的概念以及由此衍生的所有后果。在React中，我们应该很好地理解这个主题，以确保我们不会陷入令人讨厌的错误，比如无限循环。我想每个人都能猜到我要说什么。</p><p id="33bc" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">简单回顾一下。尽管JS不是严格类型化的，但它确实有不同的元素，允许我们进行特定的操作，这些是由它们的类型定义的。</p><p id="cfcb" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们有原语，它是除了对象、数组和函数之外的所有东西。这最后三个属于<strong class="ku je">“对象”</strong>的名称。对象有一个特点，当我们初始化一个对象时，我们在内存中分配空间来保存值，并在当前范围内保存对该空间的引用。我们可以传递引用，但是我们总是在内存中引用同一个对象。</p><p id="4c89" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">也就是说，当我们在对象之间进行比较时，我们会比较它们的引用，这意味着它们在内存中是完全相同的空间，而不是它们具有相同的属性和值。</p><p id="e4a0" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下面是一些比较的例子:</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Values comparison</figcaption></figure><h2 id="b9e0" class="lt lu jd bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">React中的引用</h2><p id="ffbc" class="pw-post-body-paragraph ks kt jd ku b kv mo ke kx ky mp kh la lb nj ld le lf nk lh li lj nl ll lm ln ig bi translated">说到React，实际上，当我们有了，例如，一个返回函数或对象的自定义钩子时，我们需要小心，确保我们正确地使用它们，以避免无用的渲染，甚至无限循环。</p><p id="f341" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">看看下一个例子。在组件<code class="fe no np nq nr b">SessionTime</code>中，我们利用<code class="fe no np nq nr b">useCounter</code>钩子来获取从会话开始以来经过的时间，并使用函数来重置它。每秒钟我们都调用<code class="fe no np nq nr b">useCounter</code>，并且每次都用新的引用重新声明<code class="fe no np nq nr b">resrt</code>和<code class="fe no np nq nr b">time</code>。这将导致<code class="fe no np nq nr b">SessionTime</code>内部出现无限循环，因为<code class="fe no np nq nr b">useEffect</code>在依赖数组中有<code class="fe no np nq nr b">resert</code>。</p><blockquote class="oq or os"><p id="f221" class="ks kt ns ku b kv kw ke kx ky kz kh la ot lc ld le ou lg lh li ov lk ll lm ln ig bi translated">重要提示:<em class="jd">依赖关系数组是React钩子用来理解它们何时需要再次运行的元素列表。在内部他们做一个燕子比较</em> <code class="fe no np nq nr b"><em class="jd">deps[i] === deps[i]</em></code> <em class="jd">，如果是假的就运行钩子。<br/>如果我们回到上面的比较代码，我们可以看到，对于基元来说，这没问题，但是对于对象来说，我们需要小心，因为它们看起来相同是不够的，</em> <strong class="ku je"> <em class="jd">它们需要相同</em> </strong> <em class="jd">。</em></p></blockquote><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">useCounter hook returns always new references</figcaption></figure><p id="4476" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里的解决方案是使用记忆化，因此，除非我们需要更新它们，否则我们将始终保持相同的引用。在这种情况下，我们可以将<code class="fe no np nq nr b">reset</code>包装到<code class="fe no np nq nr b">useCallback</code>中，这样就可以解决问题了。</p><figure class="lp lq lr ls gt ip"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Keep the same references memoizing the values where possible</figcaption></figure><p id="5f8f" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">注意到<code class="fe no np nq nr b">time</code>仍然在创建一个新的引用吗？当我们使用记忆时，我们需要一个一个地考虑。在这里，<code class="fe no np nq nr b">time</code>使用每秒更新一次的<code class="fe no np nq nr b">count</code>，因此将其封装到<code class="fe no np nq nr b">useMemo</code>中不会改变实现，但只会占用更多的内存空间，而没有任何回报。假设在这种情况下这是意料之中的。</p><p id="c40d" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">回到我们的闭包，请记住，在我们使用回调的地方使用这些类型的钩子，我们总是创建一个使用其作用域内的<strong class="ku je">值的闭包，所以我们需要确保传递正确的依赖关系。在任何情况下，React都很好地指出了我们应该在什么时候向linter错误的依赖数组中添加什么。</strong></p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h2 id="3b8f" class="lt lu jd bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">外卖食品</h2><p id="ce2f" class="pw-post-body-paragraph ks kt jd ku b kv mo ke kx ky mp kh la lb nj ld le lf nk lh li lj nl ll lm ln ig bi translated">这篇文章的主要目标是理解在我们的组件和钩子内部发生的一切都只是JavaScript，一旦我们理解了这一点，就不再有魔法了。</p><p id="7170" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们回顾一下:</p><ul class=""><li id="4626" class="mm mn jd ku b kv kw ky kz lb ow lf ox lj oy ln mt mu mv mw bi translated">作用域是我们保存变量和声明的环境的集合，这些变量和声明只能由同一个作用域或内部作用域访问。</li><li id="9326" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">闭包是使这些作用域可访问的函数，并允许我们保存这些值的记忆。</li><li id="fd70" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">在React中，<strong class="ku je">每个渲染都是一个新的函数调用</strong>，每个函数调用都用新的变量和声明来设置它的新作用域。</li><li id="9774" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">当我们用<code class="fe no np nq nr b">setState</code>更新状态时，我们实际上是在更新<code class="fe no np nq nr b">useState</code>钩子内部的值，而不是组件内部的值。该组件将在下一次调用中接收新的更新值。</li><li id="3b35" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">当我们调用<code class="fe no np nq nr b">setState</code>时，如果我们想确保使用最新的值，我们可以使用更新器<code class="fe no np nq nr b">setState(last =&gt; last + new)</code></li><li id="a65e" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">当我们比较对象、函数和数组时，我们比较的是它们的引用(内存中保存元素的地址)，而不是它们是否有相同的属性和值。</li><li id="801b" class="mm mn jd ku b kv mx ky my lb mz lf na lj nb ln mt mu mv mw bi translated">当我们将依赖项传递给钩子时，我们需要确保每次都不会通过记住它们的声明来传递新的引用。</li></ul></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><p id="fa1c" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="ns">更多内容请看</em><a class="ae ja" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku je"><em class="ns">plain English . io</em></strong></a><em class="ns">。报名参加我们的</em> <a class="ae ja" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku je"> <em class="ns">免费周报</em> </strong> </a> <em class="ns">。关注我们关于</em><a class="ae ja" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku je"><em class="ns">Twitter</em></strong></a><a class="ae ja" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku je"><em class="ns">LinkedIn</em></strong></a><em class="ns"/><a class="ae ja" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ku je"><em class="ns">YouTube</em></strong></a><em class="ns"/><a class="ae ja" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ku je"><em class="ns">不和</em> </strong> </a> <em class="ns">。对增长黑客感兴趣？检查</em> <a class="ae ja" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku je"> <em class="ns">电路</em> </strong> </a> <em class="ns">。</em></p></div></div>    
</body>
</html>