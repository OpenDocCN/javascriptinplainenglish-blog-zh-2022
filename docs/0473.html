<html>
<head>
<title>MutationObserver in JavaScript Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的MutationObserver解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mutation-observer-in-javascript-21a85a4ceb24?source=collection_archive---------7-----------------------#2022-01-27">https://javascript.plainenglish.io/mutation-observer-in-javascript-21a85a4ceb24?source=collection_archive---------7-----------------------#2022-01-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="29d1" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是变异观察者？</h1><p id="af5e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">MutationObserver是现代浏览器提供的一个Web API，用于检测DOM中的变化。使用MutationObserver，当DOM中的某些内容发生变化时，我们可以调用回调函数来对这些变化做出反应。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/534fc324fcc93e144df2c50bfb35b7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UL72khflMdsAeGEfc-xdjQ.gif"/></div></div></figure><p id="e0ab" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">我们为什么要这么做？</p><p id="b09b" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">在相当多的情况下，MutationObserver API可以派上用场。例如，我们想通知用户他当前所在的网页发生了一些变化。另一个用例可能是我们正在使用一个我们无法控制的库。</p><h1 id="baa5" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">投票</h1><p id="587a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">然而，变异观测者并不总是存在。那么在MutationObserver之前开发者用的是什么呢？最简单和最常见的方式是投票。轮询是一种技术，在这种技术中，我们在给定的时间间隔内一次又一次地寻找新数据。</p><p id="57c5" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">使用browser setInterval WebAPI的轮询，我们可以设置一个任务来定期检查DOM中是否发生了任何变化。下面是一个非常简单的JS轮询的例子。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="25d0" class="mc jl in ly b gy md me l mf mg">const poller = setInterval(function () {<br/>  const node = document.querySelector('.any-dom-element')<br/>  if (node) {<br/>    console.log(node)<br/>    clearInterval(poller)<br/>  }<br/>}, 1000)</span></pre><p id="cd7d" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">在上面的代码中，setInterval函数将保持每秒运行一次，直到节点在DOM中可用。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/3354f1e7d8f4b726f966335040db1890.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*tAeFWJPxRNrBGMx5SG1F2w.gif"/></div></figure><p id="2774" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">这种方法的问题是它大大降低了web应用程序/网站的性能。</p><h1 id="f45f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">如何使用MutationObserver</h1><p id="b39c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">将MutationObserver实现到您的应用程序中非常容易。首先，我们需要创建一个MutationObserver实例，方法是向它传递一个函数，每次发生突变时都会调用这个函数。该函数的第一个自变量(即“突变”)是在单个批次中发生的所有突变的集合。每个突变都提供了关于其类型和已经发生的变化的信息。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="eb24" class="mc jl in ly b gy md me l mf mg">var mutationObserver = new MutationObserver(function(mutations) {<br/>    mutations.forEach(function(mutation) {<br/>        console.log(mutation);<br/>    });<br/>});</span></pre><p id="f26d" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">我们需要做的第二件事是使用observe()方法开始观察DOM的变化。targetNode是要监视更改的节点子树的根。observerOptions参数包含我们想要观察的属性，例如子列表、属性..等等。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="1618" class="mc jl in ly b gy md me l mf mg">mutationObserver.observe(targetNode, observerOptions);</span></pre><p id="9aaf" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">我们可以随时使用disconnect()方法来停止观察指定的DOM变化。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="abb9" class="mc jl in ly b gy md me l mf mg">mutationObserver.disconnect();</span></pre><h1 id="f46f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">示例:</h1><p id="6f48" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">假设我们正在使用一个库，它将随机地在dom中插入或删除一个动画名字。我们现在想知道它到底添加/删除了什么动漫名称。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ae45" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">现在，如果我们正常尝试访问这个添加的动画名称，我们将得到null作为输出。</p><pre class="lh li lj lk gt lx ly lz ma aw mb bi"><span id="24e2" class="mc jl in ly b gy md me l mf mg">import './animes.js'<br/>console.log(document.querySelector('ul.animes li')); //output-&gt; null</span></pre><p id="7991" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">这是因为我们的库可能需要2秒钟才能将这个动漫名称添加到DOM中。在这里，我们可以创建一个MutationObserver，每当在DOM中添加或删除动画名称时，它都会通知我们。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c426" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">这里，我们提供{ childList: true}作为观察选项，仅用于监视子节点的变化。输出将如下面的GIF所示。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/10ce3784c299c39ace615877c936a086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oqeMyAA7r0wic3iYwiGomg.gif"/></div></div></figure><h2 id="98a4" class="mc jl in bd jm mk ml dn jq mm mn dp ju kt mo mp jy kx mq mr kc lb ms mt kg mu bi translated">视频解释:</h2><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mj l"/></div></figure><p id="d5da" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><em class="mw">更多内容请看</em><a class="ae mx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="mw">plain English . io</em></strong></a><em class="mw">。报名参加我们的</em> <a class="ae mx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。在我们的</em> <a class="ae mx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io"> <em class="mw">社区</em> </strong> </a> <em class="mw">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>