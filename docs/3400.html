<html>
<head>
<title>How to Make a Morphing 3D Sphere in JavaScript with Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Three.js在JavaScript中制作变形3D球体</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-a-morphing-3d-sphere-in-javascript-with-three-js-faad09e84876?source=collection_archive---------18-----------------------#2022-08-24">https://javascript.plainenglish.io/how-to-make-a-morphing-3d-sphere-in-javascript-with-three-js-faad09e84876?source=collection_archive---------18-----------------------#2022-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d50f267436da9c9fb22ef87e6fa3ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6VsOVoioQy8rajFMxlOzw.png"/></div></div></figure><p id="9d53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢互联网上的3d效果，而且它们越来越普及。他们可以给网站增加一个额外的维度，帮助吸引用户的注意力。<a class="ae kw" href="https://fjolt.com/article/apple-cards-webl-gl-javascript" rel="noopener ugc nofollow" target="_blank">我之前已经介绍过我制作的WebGL卡的3d效果</a>，但是在本指南中，我想创建一个具有酷酷的线框背景的变形球体。</p><p id="b1fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这篇教程，我也将帮助你理解3d效果如何在网络上工作的基础知识。让我们开始吧。</p><p id="91f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">下面是演示:</strong></p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="02b9" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">创建3D变形球体</h1><p id="3957" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我用来在浏览器中访问WebGL功能的工具叫做three.js。这是一个简化在浏览器中进行3d工作的过程的包——为此，它使用了<code class="fe mg mh mi mj b">canvas</code>。稍后我们将通过代码追加这一点。</p><p id="7160" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是要理解three.js只是给了我们一个使用WebGL的接口，web GL是一个用于在web上渲染2d和3d对象的API。这也是我们接下来要导入three.js的原因。你可以通过<code class="fe mg mh mi mj b">npm</code>做到这一点。我们要在这里安装的两个东西如下:</p><pre class="kx ky kz la gt mk mj ml mm aw mn bi"><span id="dccf" class="mo le iq mj b gy mp mq l mr ms">npm i three<br/>npm i open-simplex-noise<br/>npm install three-orbitcontrols</span></pre><p id="185d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装完成后，将它们导入到您的代码中。因为我是在codepen上做的演示，所以我用skypack导入了它们。这三个函数将让我们做三件事(不是双关语):</p><ul class=""><li id="b863" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">在web上使用三维形状(三个)</li><li id="9ad0" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">控制摄像机(三轨道控制)</li><li id="74ed" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">创建噪声和随机性(开放单工噪声)</li></ul><pre class="kx ky kz la gt mk mj ml mm aw mn bi"><span id="66d5" class="mo le iq mj b gy mp mq l mr ms">import * as THREE from "https://cdn.skypack.dev/three@0.133.1";<br/>import { OrbitControls } from "https://cdn.skypack.dev/three@0.133.1/examples/jsm/controls/OrbitControls.js";<br/>import openSimplexNoise from 'https://cdn.skypack.dev/open-simplex-noise';</span></pre><h1 id="545a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">在three.js中为3d对象设置场景</h1><p id="17fe" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">导入包后，我们想做几件事:</p><ul class=""><li id="7fb4" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">创建一个新的场景，让我们的3d物体坐在上面</li><li id="66fb" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><strong class="ka ir">创建一个摄像机</strong>，这样我们就可以看到我们的场景</li><li id="2573" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">创建一个渲染器，设置它的大小，这样我们就不会得到奇怪的模糊形状</li><li id="81fc" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><strong class="ka ir">添加我们的轨道控制</strong>，这样我们就可以点击并拖动我们的物体，并移动它</li></ul><pre class="kx ky kz la gt mk mj ml mm aw mn bi"><span id="b0e9" class="mo le iq mj b gy mp mq l mr ms">// Scene<br/>let scene = new THREE.Scene();<br/>// Camera<br/>let camera = new THREE.PerspectiveCamera( 75, innerWidth / innerHeight, 0.1, 1000 );<br/>camera.position.set(1.5, -0.5, 6);<br/>// Renderer<br/>let renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});<br/>renderer.setSize( innerWidth, innerHeight );<br/>// Append our renderer to the webpage. Basically, this appends the `canvas` to our webpage.<br/>document.body.appendChild( renderer.domElement );</span><span id="8284" class="mo le iq mj b gy nh mq l mr ms">new OrbitControls(camera, renderer.domElement);</span></pre><p id="d60a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，乐趣可以开始了，我们可以开始添加我们的3d形状。</p><h1 id="a97c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">用three.js为我们的场景添加3d形状</h1><p id="1a0a" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">首先，是我们的领域。three.js中的每个对象都由两部分组成——<strong class="ka ir">几何体</strong>,即组成球体的顶点和三角形，以及<strong class="ka ir">网格</strong>,即这些顶点的颜色、图案和特征。</p><p id="2846" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们最终想要操作我们所有的顶点，所以我也将它们分别存储在一个<code class="fe mg mh mi mj b">positionData</code>数组中。我们将使用bult in <code class="fe mg mh mi mj b">Vector3</code>函数在three.js中存储3d坐标集。</p><pre class="kx ky kz la gt mk mj ml mm aw mn bi"><span id="7f86" class="mo le iq mj b gy mp mq l mr ms">// Create our geometry<br/>let sphereGeometry = new THREE.SphereGeometry(1.5, 100, 100);</span><span id="b11d" class="mo le iq mj b gy nh mq l mr ms">// This section is about accessing our geometry vertices and their locations<br/>sphereGeometry.positionData = [];<br/>let v3 = new THREE.Vector3();<br/>for (let i = 0; i &lt; sphereGeometry.attributes.position.count; i++){<br/>    v3.fromBufferAttribute(sphereGeometry.attributes.position, i);<br/>    sphereGeometry.positionData.push(v3.clone());<br/>}</span><span id="8ccb" class="mo le iq mj b gy nh mq l mr ms">// A `normal` material uses the coordinates of an object to calculate its color<br/>let sphereMesh = new THREE.MeshNormalMaterial();</span><span id="fc7a" class="mo le iq mj b gy nh mq l mr ms">// Combine both, and add it to the scene.<br/>let sphere = new THREE.Mesh(sphereGeometry, sphereMesh);<br/>scene.add(sphere);</span></pre><h1 id="b745" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">改为使用自定义着色器</h1><p id="682c" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">现在，<strong class="ka ir">这里有一个</strong>警告，我决定让我的球体更加可定制，为此，我使用了<strong class="ka ir">着色器</strong>。所以，当我们调用<code class="fe mg mh mi mj b">MeshNormalMaterial</code>时，它实际上做了一些对网络来说有点不寻常的事情。它使用称为着色器的东西来计算每个顶点的颜色。</p><p id="1e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有两种类型的着色器，<code class="fe mg mh mi mj b">fragment</code>，它本质上是对象的颜色，以及<code class="fe mg mh mi mj b">vertex</code>，它是该形状上顶点的位置。这些着色器是用<strong class="ka ir"> GLSL </strong>或<strong class="ka ir"> OpenGL着色语言</strong>编写的——所以不是JavaScript。我不打算详细介绍这种语言是如何工作的，但它更像C而不是JavaScript。</p><p id="2071" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本原则是:</p><ul class=""><li id="a6bf" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">不使用<code class="fe mg mh mi mj b">MeshNormalMaterial</code>，我们可以使用<code class="fe mg mh mi mj b">ShaderMaterial</code>，并建立我们自己的着色器。</li><li id="674d" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">我们将使用<strong class="ka ir">普通材质</strong>着色器——因此会出现相同的效果，但是在我们的代码中使用它们意味着我们可以在以后更新它——例如，改变颜色。</li><li id="cb24" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">我们可以使用<code class="fe mg mh mi mj b">uniforms</code>将JavaScript变量实时传递给着色器，T5是GLSL中的一种特殊类型的变量。</li></ul><p id="45a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们在HTML中定义我们的GLSL，并用一个JavaScript选择器把它拉进来。<strong class="ka ir">注意</strong>:与<code class="fe mg mh mi mj b">MeshNormalMaterial</code>相比，我没有对这些着色器做任何真正的改变——唯一的不同是我将一种颜色作为<strong class="ka ir">制服</strong>传入。这意味着，如果我们愿意，我们可以从JavaScript中更改这个值。这里我只展示片段着色器，但是两者都可以在codepen 的<a class="ae kw" href="https://codepen.io/smpnjn/pen/MWVLqZa" rel="noopener ugc nofollow" target="_blank"> HTML部分找到。注意我定义了<code class="fe mg mh mi mj b">uniform vec3 colorA</code>——这是我们将在JavaScript中使用的变量！</a></p><p id="dc6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，着色器会根据我们的指示对3D对象的每个像素进行操作。它们计算量很大，但是可以创造一些非常酷的效果。</p><pre class="kx ky kz la gt mk mj ml mm aw mn bi"><span id="001c" class="mo le iq mj b gy mp mq l mr ms">&lt;script id="fragment" type="text/glsl"&gt;<br/>uniform vec3 colorA;<br/>#define NORMAL<br/>#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )<br/>    varying vec3 vViewPosition;<br/>#endif</span><span id="6c79" class="mo le iq mj b gy nh mq l mr ms">#include &lt;packing&gt;<br/>#include &lt;uv_pars_fragment&gt;<br/>#include &lt;normal_pars_fragment&gt;<br/>#include &lt;bumpmap_pars_fragment&gt;<br/>#include &lt;normalmap_pars_fragment&gt;<br/>#include &lt;logdepthbuf_pars_fragment&gt;<br/>#include &lt;clipping_planes_pars_fragment&gt;</span><span id="f6e8" class="mo le iq mj b gy nh mq l mr ms">void main() {<br/>    #include &lt;clipping_planes_fragment&gt;<br/>    #include &lt;logdepthbuf_fragment&gt;<br/>    #include &lt;normal_fragment_begin&gt;<br/>    #include &lt;normal_fragment_maps&gt;</span><span id="519c" class="mo le iq mj b gy nh mq l mr ms">    gl_FragColor = vec4( normalize( normal ) * colorA + 0.5, 1.0 );</span><span id="9fe0" class="mo le iq mj b gy nh mq l mr ms">    #ifdef OPAQUE<br/>        gl_FragColor.a = 1.0;<br/>    #endif <br/>}<br/>&lt;/script&gt;</span></pre><h1 id="372c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">普通着色器的工作原理</h1><p id="77e1" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">普通着色器通过计算<code class="fe mg mh mi mj b">normalize( normal ) * 0.5 + 0.5</code>来计算像素的颜色。因此，我们可以将第一个<code class="fe mg mh mi mj b">0.5</code>替换为自定义颜色，这就是我们的<strong class="ka ir">制服</strong> <code class="fe mg mh mi mj b">colorA</code>。然后，我们可以将这两个顶点和片段着色器添加到JavaScript中，如下所示:</p><pre class="kx ky kz la gt mk mj ml mm aw mn bi"><span id="d39d" class="mo le iq mj b gy mp mq l mr ms">let sphereMesh = new THREE.ShaderMaterial({<br/>    uniforms: {      <br/>        colorA: {type: 'vec3', value: new THREE.Vector3(0.5, 0.5, 0.5)},</span><span id="f025" class="mo le iq mj b gy nh mq l mr ms">    },<br/>    vertexShader: document.getElementById('vertex').textContent,<br/>    fragmentShader: document.getElementById('fragment').textContent,<br/>});</span></pre><p id="90cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">学习WebGL时，了解它是如何工作的非常重要。着色器对于在3d中做事情非常重要，所以知道如何定义和操纵它们是很好的。</p><h1 id="b00d" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">操纵我们球体的几何形状</h1><p id="80ae" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">然后我们可以创建一个three.js时钟来跟踪时间。我们利用这段时间来创建噪声，使用我们导入的噪声函数。噪波只是随机性，有助于创建随机变形球体的效果。之后，three.js还为我们提供了添加动画关键帧的功能，我们可以使用前面提到的three.js时钟来制作那个球体的动画。</p><pre class="kx ky kz la gt mk mj ml mm aw mn bi"><span id="3598" class="mo le iq mj b gy mp mq l mr ms">let noise = openSimplexNoise.makeNoise4D(Date.now());<br/>let clock = new THREE.Clock();</span><span id="0a1b" class="mo le iq mj b gy nh mq l mr ms">renderer.setAnimationLoop( () =&gt; {<br/>    // Get the time<br/>    let t = clock.getElapsedTime();<br/>    sphereGeometry.positionData.forEach((p, idx) =&gt; {<br/>        // Create noise for each point in our sphere<br/>        let setNoise = noise(p.x, p.y, p.z, t * 1.05);<br/>        // Using our Vector3 function, copy the point data, and multiply it by the noise<br/>        // this looks confusing - but it's just multiplying noise by the position at each vertice<br/>        v3.copy(p).addScaledVector(p, setNoise);<br/>        // Update the positions<br/>        sphereGeometry.attributes.position.setXYZ(idx, v3.x, v3.y, v3.z);<br/>    })<br/>    // Some housekeeping so that the sphere looks "right"<br/>    sphereGeometry.computeVertexNormals();<br/>    sphereGeometry.attributes.position.needsUpdate = true;<br/>    // Render the sphere onto the page again.<br/>    renderer.render(scene, camera);<br/>})</span></pre><p id="8c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的球体将开始变形！我对球体后面的平面也重复了这个步骤。我在这里用了一个<code class="fe mg mh mi mj b">BoxGeometry</code>，只有一个基本的网格，这使它看起来像一个线框。这个位的代码，以及其他所有东西，<a class="ae kw" href="https://codepen.io/smpnjn/pen/MWVLqZa" rel="noopener ugc nofollow" target="_blank">都可以在CodePen </a>上找到。</p><h1 id="6228" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="3f6e" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在网络上制作3d图形是一项非常好的前端技能。虽然很多事情可以用CSS和HTML来完成，但有些效果只能通过3d来实现，而three.js提供了一个完美的平台来实现这一点。我希望你喜欢这个用three.js和JavaScript创建3d变形球体的快速指南。如果你想要更多的<a class="ae kw" href="https://fjolt.com/category/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript内容</a>，<a class="ae kw" href="https://fjolt.com/category/javascript" rel="noopener ugc nofollow" target="_blank">你可以在这里阅读我所有的其他东西</a>。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="2ee1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="np">更多内容看</em> <a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="np">说白了。报名参加我们的</em> <a class="ae kw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="np">免费周报</em> </strong> </a> <em class="np">。关注我们关于</em> <a class="ae kw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="np">推特</em> </strong> </a>，<a class="ae kw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="np">LinkedIn</em></strong></a><em class="np">，</em><a class="ae kw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="np">YouTube</em></strong></a><em class="np">，</em> <a class="ae kw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="np">不和</em> </strong> </a> <em class="np">。</em></strong></a></p></div></div>    
</body>
</html>