<html>
<head>
<title>Goodbye HTML. Hello Canvas!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再见HTML。你好画布！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/goodbye-html-hello-canvas-956cc7d0770f?source=collection_archive---------9-----------------------#2022-03-21">https://javascript.plainenglish.io/goodbye-html-hello-canvas-956cc7d0770f?source=collection_archive---------9-----------------------#2022-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="326a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第5部分:动态架构和初始化</h2></div><p id="243f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里可以看之前的文章<a class="ae ky" href="https://joanaborgeslate.medium.com/goodbye-html-hello-canvas-f3935aec3a05" rel="noopener">。</a></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/85f6491da359e88cd34f7a434a79b5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHqcaQU_Ab4vskVv-ZLQyw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Explaining The Last Demo</figcaption></figure><h2 id="18b2" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">回顾</h2><p id="3421" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">嗯，在上一篇文章的演示中，我们通过改变<em class="mn">小部件</em>的颜色和改变<em class="mn">虚拟层</em>的顺序(这意味着改变每个画布的<em class="mn"> </em> CSS <em class="mn"> z-Index </em>来对<em class="mn">小部件</em>上的鼠标按下事件做出反应——画布是心脏，是<em class="mn">面板的实质)</em>。</p><p id="f67d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">CSS <em class="mn"> z向索引</em>？<em class="mn"> </em>我们是否正在告别HTML/CSS？除了标签<em class="mn"> html </em>和<em class="mn">正文</em>之外，库使用的<strong class="ke io">头罩下的</strong>，只有两种html元素:</p><ul class=""><li id="4e20" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated"><em class="mn"> div </em> : <em class="mn"> </em>刚好一次，为<em class="mn">阶段</em></li><li id="6607" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><em class="mn">画布</em>:每个面板一张</li></ul><p id="3913" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并且，对于这两种HTML元素，该库使用基本的CSS属性，如<em class="mn"> left，top，</em>和<em class="mn"> z-Index </em>。只是你不直接和他们打交道。</p><p id="2c99" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只有画布(在<em class="mn">面板</em>内)接收浏览器提供的鼠标事件<strong class="ke io">。<em class="mn">小部件</em>接收由库</strong>创建的鼠标事件<strong class="ke io">。</strong></p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="3287" class="lp lq in nd b gy nh ni l nj nk">myWidget.onmousedown = function (e) { <br/>    console.log("mouse down") <br/>}</span></pre><p id="00fc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">myWidget 不是一个HTML元素，但是你可以像对待它一样对待它。小菜一碟；)</p><h1 id="9a56" class="nl lq in bd lr nm nn no lu np nq nr lx jt ns ju ma jw nt jx md jz nu ka mg nv bi translated">动态建筑</h1><p id="3493" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">当我们考虑静态架构和动态架构这两个名称时，我们不应该忘记我们在谈论一个运行在浏览器内部的<em class="mn">引擎，它具有动态的性质。一个真正的静态架构不可能产生上一个演示中的那两个简单的动画。</em></p><h2 id="6d4f" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">直接的回应</h2><p id="b7fd" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我们制作了这些动画，通过<strong class="ke io">直接响应</strong>鼠标事件。这个简单又好。但这还不够，随着应用程序的增长，这可能会成为一个问题。</p><p id="f53a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们需要定时动画，比如闪烁的光标时，直接响应是不够的。</p><p id="e656" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">直接回应是<strong class="ke io">一个问题</strong>当……嗯，最好的解释方式是使用真实案例(但要简化内部细节)。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c4d8b870c9336a97d700219e1d754764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*gr3r0mNXhVozS9PGufWQCg.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Pixel Monitoring In BobSprite</figcaption></figure><p id="426f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">BobSprite的一个特性是总是给出关于鼠标下的像素(光标中心)的反馈:位置(X，Y)，颜色样本和RGBA值(“不透明”意味着alpha值为255)。此信息出现在应用程序的左下角。</p><p id="c138" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用直接响应，我们会这样做:</p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="d874" class="lp lq in nd b gy nh ni l nj nk">// simplified code</span><span id="cfdb" class="lp lq in nd b gy nx ni l nj nk">picture.onmousemove = updatePixelInfo</span><span id="b5d8" class="lp lq in nd b gy nx ni l nj nk">function updatePixelInfo(e) {<br/>    const x = e.offsetX<br/>    const y = e.offsetY<br/>    const rgba = getPicturePixel(x, y)<br/>    printPixelInfo(x, y, rgba)<br/>}</span></pre><p id="15c0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很好，但我们还需要重新绘制应用程序，因为光标(黑白框)会随着鼠标移动:</p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="0a8d" class="lp lq in nd b gy nh ni l nj nk">// simplified code</span><span id="8f32" class="lp lq in nd b gy nx ni l nj nk">picture.onmousemove = mouseMoveHandler</span><span id="3b68" class="lp lq in nd b gy nx ni l nj nk">function mouseMoveHandler(e) {<br/>    const x = e.offsetX<br/>    const y = e.offsetY<br/>    //<br/>    repaintApp()<br/>    updatePixelInfo(x, y)<br/>}</span><span id="c8be" class="lp lq in nd b gy nx ni l nj nk">function updatePixelInfo(x, y) {<br/>    const rgba = getPicturePixel(x, y)<br/>    printPixelInfo(x, y, rgba)<br/>}</span></pre><p id="638e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的。但现在我们有一个问题，因为<em class="mn"> repaintApp </em>很慢(实际上<em class="mn"> repaintApp </em>是BobSprite中最慢的功能)，用户可能会非常快速地移动鼠标，<strong class="ke io">过载</strong> <em class="mn"> repaintApp </em>，使应用程序响应速度变慢，甚至出现小的冻结。</p><p id="2ce2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还没有绘画(这涉及到更多的处理，包括记忆)，只是移动鼠标。</p><p id="f111" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除此之外，还有很多改变画面的键盘命令(比如“R”代表旋转)。每个都必须调用<em class="mn"> repaintApp </em>和<em class="mn"> updatePixelInfo </em>。但是<em class="mn"> updatePixelInfo </em>期望接收一个<strong class="ke io">鼠标事件</strong>，<strong class="ke io"> </strong>并且我们有一个<strong class="ke io">键盘事件</strong>。</p><p id="7151" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">直接响应的最大问题是它会引发一连串的函数调用。</p><p id="94b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn">当函数链为</em> <strong class="ke io"> <em class="mn">线性</em></strong><em class="mn">(A&gt;B&gt;C&gt;D)且不与另一个函数链</em>冲突时，没什么大不了的。</p><p id="dbc8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于绘图工具来说，冲突是存在的，函数链变得错综复杂。在应用程序中引入新特性意味着打破并重新创建旧的功能链(大重构)。此外，还有一个非常重要的冗余问题:例如，我们可以很容易地调用<em class="mn"> repaintApp </em>，次数超过了必要的次数。</p><p id="c6ff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，<strong class="ke io">依赖于</strong>你的应用程序的种类，使用鼠标和键盘事件的直接响应意味着，在<strong class="ke io">最好的场景</strong>中，创建变通办法并使我们的代码变得一团糟，<strong class="ke io">很难维护</strong>。</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><h2 id="3f6f" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">间接反应</h2><p id="3d49" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">解决方案是采用<strong class="ke io">间接响应</strong>模式，它也处理像闪烁光标这样的动画。</p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="4e2a" class="lp lq in nd b gy nh ni l nj nk">// simplified code</span><span id="6050" class="lp lq in nd b gy nx ni l nj nk">var mouseX = -1<br/>var mouseY = -1</span><span id="dece" class="lp lq in nd b gy nx ni l nj nk">var shallRepaint = false<br/>var shallUpdatePixelInfo = false</span><span id="5677" class="lp lq in nd b gy nx ni l nj nk">picture.onmousemove = mouseMoveHandler</span><span id="afce" class="lp lq in nd b gy nx ni l nj nk">function mouseMoveHandler(e) { <br/>    mouseX = e.offsetX<br/>    mouseY = e.offsetY<br/>    //<br/>    shallRepaint = true<br/>    shallUpdatePixelInfo = true<br/>}</span><span id="2eab" class="lp lq in nd b gy nx ni l nj nk">function updatePixelInfo() { // no parameters!<br/>    //<br/>    const rgba = getPicturePixel(mouseX, mouseY)<br/>    printPixelInfo(mouseX, mouseY, rgba)<br/>}</span><span id="9fde" class="lp lq in nd b gy nx ni l nj nk">function mainLoop() { <br/>    //<br/>    manageBlinkingWidgets()<br/>    //<br/>    if (shallRepaint) { <br/>        repaintApp()<br/>        shallRepaint = false<br/>        shallUpdatePixelInfo = true <br/>    }<br/>    //<br/>    if (shallUpdatePixelInfo) {<br/>        updatePixelInfo() // no arguments!<br/>        shallUpdatePixelInfo = false<br/>    }<br/>    // the browser provides this timer<br/>    requestAnimationFrame(mainLoop) <br/>}</span></pre><p id="0347" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于新代码风格的一些说明:</p><ul class=""><li id="dcc1" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated">只有一个函数调用昂贵的<em class="mn"> repaintAPP </em></li><li id="7a4a" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">冗余不再是<strong class="ke io">的问题；任何地方的任何函数都可以标记出<em class="mn"> repaintApp </em>应该被调用而不用担心，因为它只是设置一个布尔值(<em class="mn"> shallRepaint = true </em>)，这是世界上最便宜的过程</strong></li><li id="068c" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">此外，<em class="mn"> updatePixelInfo </em>没有冗余问题；它是基于标志的，如<em class="mn"> repaintApp </em></li><li id="a314" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">一个键盘事件仍然不知道鼠标的位置；并且它不需要知道，因为它将<strong class="ke io">不调用函数</strong> ( <em class="mn"> updatePixelInfo </em>)，它将<strong class="ke io">设置标志</strong>(<em class="mn">shall updatePixelInfo = true</em>)</li><li id="30d7" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><em class="mn"> mouseMoveHandler </em>结束，不调用任何函数；我们处理鼠标事件<strong class="ke io">，而不需要</strong>启动函数调用的<strong class="ke io">链</strong>！</li><li id="772a" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">虽然<em class="mn"> requestAnimationFrame </em>使循环运行，在<strong class="ke io"> general </strong>中，每秒60次，应用程序是经济的，因为标志的使用跳过了此刻不需要的过程</li></ul><p id="9ea5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个笼统的概念。该库使用<em class="mn"> requestAnimationFrame </em>并给出句柄来连接你的回调。在另一篇文章中有更多关于这方面的内容。</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><h1 id="ddd8" class="nl lq in bd lr nm of no lu np og nr lx jt oh ju ma jw oi jx md jz oj ka mg nv bi translated">初始化</h1><p id="4fb2" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">当我们创建一个HTML/CSS页面时，我们不需要太在意加载资源。我们只需<strong class="ke io">声明</strong>“将这张照片放在这里”、“使用ABC字体”、“用这个CSS表单设计按钮的样式”…</p><p id="695c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">浏览器为我们打理一切。虽然没有加载ABC字体，但它使用了一些占位符字体。加载ABC字体后，它会用ABC字体替换占位符字体。</p><p id="6c14" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种策略有时对用户来说有点奇怪。几秒钟后，当有人正在阅读页面时，字体(甚至布局)发生了变化。我没有抱怨。这是事实。其实我觉得这是正确的策略。糟糕的策略是在所有资源加载完毕后才显示页面。</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="9804" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们基于画布的应用程序的初始化是不同的。为了打印文本，我们需要首先加载字体表。图标也是如此。这是一个要么全有要么全无的策略:</p><ul class=""><li id="17f1" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated">我们在显示东西之前加载所有东西，我们不关心填补空白(立即显示内容，使用临时资源)</li><li id="53f9" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">我们可以改变<em class="mn">舞台</em>的背景颜色，向用户证明有事情正在发生</li><li id="4c74" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">我们非常注意要加载的文件数量和每个文件的大小；我们将图像打包在一张纸上，并将所有JavaScript代码打包在一个文件中</li></ul><p id="6f3c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住，我们正在创建一个特殊的应用程序。新来的人不应该首先访问这个页面。他应该登陆网站的主页。他可以等两秒钟。</p><p id="f6f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">加载图像后:</p><ol class=""><li id="dc7f" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx ok mu mv mw bi translated">字体和图标被打开</li><li id="dc13" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx ok mu mv mw bi translated">接口已安装</li><li id="0858" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx ok mu mv mw bi translated">鼠标/键盘事件监听器被激活</li><li id="dae2" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx ok mu mv mw bi translated">主循环开始运行</li></ol><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="d544" class="lp lq in nd b gy nh ni l nj nk">var numberOfResourcesToLoad = 0</span><span id="ba24" class="lp lq in nd b gy nx ni l nj nk">function main() {<br/>    //<br/>    loadImages() // manages numberOfResourcesToLoad<br/>    //<br/>    recoverDataFromLocalStorage() <br/>    //<br/>    main2()<br/>}</span><span id="079a" class="lp lq in nd b gy nx ni l nj nk">function main2() {<br/>    //<br/>    if (numberOfResourcesToLoad == 0) { afterLoadResources(); return }<br/>    //<br/>    setTimeout(main2, 30)<br/>}</span><span id="9f73" class="lp lq in nd b gy nx ni l nj nk">function afterLoadResources() {<br/>    //<br/>    initFonts()<br/>    initIcons()<br/>    initInterface() <br/>    //    <br/>    initMouseListening()<br/>    initKeyboardListening()<br/>    mainLoop()<br/>}</span></pre></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><h2 id="c7f2" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">下一步是什么</h2><p id="ee09" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">今天，我们学习了基于画布的页面的更多基本概念。关于<strong class="ke io">键盘事件处理</strong>我们还没有谈(足够多)。此外，我们没有演示。</p><p id="87fe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在讨论键盘事件处理和运行演示之前，我们需要用于文本输入的小部件；因为键盘事件处理都是关于<strong class="ke io">焦点</strong>(哪个小部件是击键的目标)。用于文本输入及其操作(包括闪烁光标)的小部件是引擎中最复杂/最难的部分。简单的演示是不够的。</p><p id="88c5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我决定下一个演示/文章:</p><ul class=""><li id="d09c" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated">将演示焦点和键盘事件处理</li><li id="5306" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">将是一个完整的应用程序，具有一些<strong class="ke io">有用的</strong>功能</li><li id="f78c" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">将<strong class="ke io">发布</strong>库的第一个版本，准备使用</li></ul></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="2653" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是本系列下一篇文章 的<a class="ae ky" href="https://joanaborgeslate.medium.com/goodbye-html-hello-canvas-3cc1b2e7b096" rel="noopener"> <strong class="ke io">链接。</strong></a></p><p id="e11c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn">更多内容看</em> <a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mn">说白了。报名参加我们的</em> <a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mn">免费周报</em> </strong> </a> <em class="mn">。关注我们关于</em><a class="ae ky" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mn">Twitter</em></strong></a><em class="mn">和</em><strong class="ke io"><em class="mn"/></strong><a class="ae ky" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mn">LinkedIn</em></strong></a><em class="mn">。加入我们的</em> <a class="ae ky" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mn">社区</em> </strong> </a> <em class="mn">。</em></strong></a></p></div></div>    
</body>
</html>