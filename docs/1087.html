<html>
<head>
<title>Angular Practices in 2022 that No One Talks About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没人谈论的2022年的棱角练习</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-practices-2022-that-no-one-talks-about-3fe483bf4bfc?source=collection_archive---------0-----------------------#2022-03-03">https://javascript.plainenglish.io/angular-practices-2022-that-no-one-talks-about-3fe483bf4bfc?source=collection_archive---------0-----------------------#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="266f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不要忽视这些人们很少谈论的关于棱角分明的事情。上车出发吧！🏃🏼🏃🏼‍♀️🏃🏼‍♂️</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7b252567ba31bf895d972c7312f86130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eo9loH6iEkuDxgjLxGI5Sg.png"/></div></div></figure><h1 id="8553" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">1.使用管道而不是函数来防止不必要的重新渲染</h1><p id="74e9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Angular模板绑定太棒了，你可以绑定变量，也可以绑定它的模板。你们中的许多人和我一样，使用函数调用来转换数据，因为它方便且易于实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/6fde17b7ccef312db3c81257a10c5373.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*5WiMu_FznGyNmEXfGA_1lA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/933ce6ef2b2b855671e2a3f4d76f3729.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*_4h7DWCFGay_eaZASzDk7g.png"/></div></figure><p id="ee0c" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">看上面这个简单的例子，你不会注意到任何不同。但是您知道吗，每次检测到变化时都会调用函数调用，但是只有当输入值发生变化时才会调用管道。我不会过多地谈论这个问题。下面的链接是Angular拥有的生命周期钩子的数量，想象你的函数在每个生命周期钩子被调用，那将是一个完全的噩梦。所以，除非你知道你真正在做什么，否则请避免在你的模板中调用函数，相反，总是选择创建你自己的定制的纯管道来处理数据转换。</p><div class="mm mn gp gr mo mp"><a href="https://angular.io/guide/lifecycle-hooks" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">有角的</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">Angular是一个构建移动和桌面web应用程序的平台。加入数百万开发者的社区…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">angular.io</p></div></div></div></a></div><h1 id="bf2a" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">2.基于您的应用程序在不同的级别注入服务</h1><p id="002d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">默认情况下，当我们使用<code class="fe my mz na nb b">Angular CLI</code>为我们的应用程序创建服务时，所创建的服务是在根级别提供的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0ce25edd477842999e01a85950bc79c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*-e4A_aJMWx2idzTniuelCg.png"/></div></figure><p id="e71c" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">注意到<strong class="ll ir">@ injectible</strong>decorator拥有<strong class="ll ir">提供的对象:“root”。</strong>这意味着Angular为您创建了该服务的一个实例，供您在整个应用程序中使用。您可以将它注入到任何需要使用该服务的类组件中。</p><p id="3ef0" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">但是，如果您希望应用程序的不同模块中该服务的一个单独实例拥有不同的状态和逻辑，您可以选择移除提供的<strong class="ll ir">:' root '</strong>并在模块级别注册该服务(例如main.module.ts，feature.module.ts)，这样每个模块都拥有该服务的一个新实例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/b1b3d5d9398d973521d437ba9e180594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVTqh6V8ScrnTWA0KoWQmw.png"/></div></div></figure><p id="14e2" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">此外，如果您真的需要将它分离到组件级，这样每个组件都使用服务的一个新实例，您可以选择在组件级注册它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/dd00127921be7e91413bd884faf6aafa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*J2t-lWyuRiAPDvfcUxuPFQ.png"/></div></figure><h1 id="a8ae" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">3.避免嵌套订阅—改用switchMap</h1><p id="3187" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在开发过程中，我们经常需要第一个API的响应来调用下一个API，以获取一些需要在应用程序中显示的其他数据。许多人通常采用的方法如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/517e2ceb5531b567b92d774e345b76f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*r8Rxv-PXND7mXXil-9JhfA.png"/></div></figure><p id="07e2" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">这个实现并没有什么问题。但这实际上会带回过去的好时光😈如果您有许多相互依赖的订阅结果。这也产生了订阅管理问题。</p><p id="a25d" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">更好的方法是使用RxJS switchMap方法。😎</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c4e9ac516118f7b89383d1a16a988625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*xkYTa0Qtbs0kbqOmJQzO2A.png"/></div></figure><p id="39a7" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">这种方法防止了<code class="fe my mz na nb b">callback hell</code>，你可以实现多个switchMap并将它们链接在一起。使用这个实现的另一个好处是switchMap将自动取消订阅以前的内部可观察对象。我会留下下面的链接，让你探索更多。</p><div class="mm mn gp gr mo mp"><a href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">开关图</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">switchMap一次只维护一个内部订阅，这在</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.learnrxjs.io</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm kp mp"/></div></div></a></div><h1 id="d7b5" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">4.避免使用any类型，使用接口并声明变量类型</h1><p id="4493" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Angular使用TypeScript而不是传统的JavaScript有一个明显的原因。不要因为没有对变量、对象和数组进行强类型化而让Angular团队失望。此外，为变量创建强类型接口有助于IDE为您提供静态类型检查和智能感知支持。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/2101eabe269e2cb3edf0a3f69ea83fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRWEeOPFW9NTcY2fI13dwQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">No IntelliSense support</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/2ff0496c8fd1414074a21f31f550c162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7sgy1b6HYkEBa6BoR7Rxg.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">IntelliSense support</figcaption></figure><p id="fa04" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">您可以通过在类外部的组件文件中创建一个接口来轻松地强类型化您的对象，或者您可以创建一个<code class="fe my mz na nb b">model.ts</code>文件来保存您的所有接口并分别导出它们，然后将它们导入到您的组件文件中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/bf630f121e431d7dede1878b0d728676.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*rCAgZC40DPqsgTXoiR4nEQ.png"/></div></figure><h1 id="5b43" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">5.缓存API调用不经常改变的响应</h1><p id="69cc" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在我们的应用程序中，总有一些API在第一次加载后不会经常改变，但是这些信息在不同的模块和组件中使用。您可以使用RxJS ShareReplay实现缓存，而不是将其存储在变量中或多次调用同一个API。</p><p id="d2b9" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">而不是多次调用这个API。❌</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ea873a7d66e839f7b45005b540bdd761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*234OPNmiQPwGHy5CoA_h2g.png"/></div></figure><p id="adb9" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">您可以这样做，并在您的服务中缓存这个可观察值。✅</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/f486fda147d1bdd3389820b3be8548f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMTN5GQgVDFN9vfglbk4lg.png"/></div></div></figure><p id="e216" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">在您的服务中创建一个<code class="fe my mz na nb b">getStaticData</code>基本函数，在您的构造函数中调用它一次以获取一次信息，您的组件可以继续多次调用函数<code class="fe my mz na nb b">getCustomerInfoWithCache</code>，它不会触发对您的服务器的任何API调用，但会获得您在服务类中的构造函数中调用的缓存可见性。我将把下面的链接留给你去阅读更多的相关内容。</p><div class="mm mn gp gr mo mp"><a href="https://www.learnrxjs.io/learn-rxjs/operators/multicasting/sharereplay" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">共享重播</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">当你有副作用或繁重的计算，你不希望在多个…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.learnrxjs.io</p></div></div><div class="nh l"><div class="nw l nj nk nl nh nm kp mp"/></div></div></a></div><h1 id="10b4" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">摘要</h1><p id="1110" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">希望这篇文章能让你更好地构建更好、更优化的角度应用。我真的相信，只要我们持之以恒，小小的改变总会产生巨大的影响。这同样适用于这里，当我们一次一点点地重构我们的应用程序时，随着时间的推移，你的应用程序将会加速并变得更有性能。</p><p id="1f93" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated">如果你有其他没有人谈论的关于Angular的建议，请在下面的评论中告诉我。我很想谈谈这件事。干杯。</p><div class="mm mn gp gr mo mp"><a href="https://medium.com/@devjo/membership" rel="noopener follow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">用我的推荐链接- DevJo加入媒体</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">medium.com</p></div></div><div class="nh l"><div class="nx l nj nk nl nh nm kp mp"/></div></div></a></div><p id="9d01" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mj lu lv lw mk ly lz ma ml mc md me ij bi translated"><em class="ny">更多内容请看</em><a class="ae nz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="ny">plain English . io</em></strong></a><em class="ny">。报名参加我们的</em> <a class="ae nz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em><a class="ae nz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="ny">Twitter</em></strong></a><em class="ny">和</em><a class="ae nz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir"><em class="ny">LinkedIn</em></strong></a><em class="ny">。加入我们的</em> <a class="ae nz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> <em class="ny">社区不和谐</em> </strong> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>