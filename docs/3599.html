<html>
<head>
<title>How to Build a Plugin System with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用类型脚本构建插件系统</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-plugin-system-with-typescript-e7efb9f7e1ab?source=collection_archive---------5-----------------------#2022-09-10">https://javascript.plainenglish.io/how-to-build-a-plugin-system-with-typescript-e7efb9f7e1ab?source=collection_archive---------5-----------------------#2022-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d307b1a22476e56357d67d1ba68dd20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_uu-kFnCT4GN5dFF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dbdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在构建一个极简主义应用程序，您可以允许人们扩展您的应用程序的方法之一是使用插件。插件通常是小的代码包，使用公开的API或库来修改和添加应用程序的特性。通常在运行时加载，它们使应用程序更加灵活。</p><p id="c7c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将创建一个简单的类型安全插件系统，可以在任何应用程序中使用。</p><h1 id="91b6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">开始</strong></h1><p id="2fe0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们从创建一个新的Node.js项目开始。在本教程中，我将使用<code class="fe me mf mg mh b">npm</code>作为我的包管理器，但是请随意使用<code class="fe me mf mg mh b">yarn</code>。</p><p id="01f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.<code class="fe me mf mg mh b">mkdir my-plugin-manager</code></p><p id="a27b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<code class="fe me mf mg mh b">cd my-plugin-manager</code></p><p id="0425" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<code class="fe me mf mg mh b">npm init -y</code></p><p id="5bbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.<code class="fe me mf mg mh b">npm i -D typescript</code></p><h1 id="a3d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">定义插件</strong></h1><p id="b65c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将使用一个由每个插件实现的<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members" rel="noopener ugc nofollow" target="_blank">抽象类</a>来定义我们的插件。我们需要提供名称和版本，以及加载和卸载插件的开始和停止方法。</p><p id="c103" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用一个接口来实现这个，然后为每个插件实现这个接口，但是我们也想提供一种访问其他API的方法。否则，插件在它自己的范围之外不能做很多事情。因此，我们将使插件成为一个抽象类，并需要一个泛型类型的输入“应用程序”(“t”)。这可能是你的应用程序的主类，一个包含对多个有用的API的访问的对象，或者你的插件想要访问的任何其他方法或值。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fb42" class="mq lc iq mh b gy mr ms l mt mu">export abstract class PluginTemplate&lt;T&gt; {<br/>  abstract name: string;<br/>  abstract version: string;</span><span id="9561" class="mq lc iq mh b gy mv ms l mt mu">  app: T;</span><span id="994c" class="mq lc iq mh b gy mv ms l mt mu">  constructor(app: T) {<br/>    this.app = app;<br/>  }</span><span id="bc5f" class="mq lc iq mh b gy mv ms l mt mu">  abstract start(): Promise&lt;void&gt;;<br/>  abstract stop():  Promise&lt;void&gt;;<br/>}</span></pre><p id="d05c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现类时，名称、版本、开始和停止方法都必须由插件提供。一个使用例如<code class="fe me mf mg mh b">App</code>类的插件的例子是…</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fc8f" class="mq lc iq mh b gy mr ms l mt mu">export default class MyPlugin extends PluginTemplate&lt;App&gt; {<br/>  name = "my-plugin";<br/>  version = "1.0.0";</span><span id="a6ba" class="mq lc iq mh b gy mv ms l mt mu">  async start() {<br/>    console.log("My plugin started");<br/>  }</span><span id="28a1" class="mq lc iq mh b gy mv ms l mt mu">  async stop() {<br/>    console.log("My plugin stopped");<br/>  }<br/>}</span></pre><h1 id="dc00" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">管理多个插件</strong></h1><p id="79d3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了帮助加载和卸载插件，我们可以创建一个插件管理器类。这个类将被实例化一次，通常由应用程序的主类实例化。</p><p id="1db4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们用泛型类型<code class="fe me mf mg mh b">T</code>创建一个新的类。像<code class="fe me mf mg mh b">PluginTemplate</code>类中的泛型一样，这代表了要暴露给插件的对象。活动插件将存储在<code class="fe me mf mg mh b">private _plugins</code>字段中，由类自己的方法(如unload方法)使用。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a42e" class="mq lc iq mh b gy mr ms l mt mu">export class PluginManager&lt;T&gt; {<br/>  private _plugins: PluginTemplate&lt;T&gt;[] = [];</span><span id="ccf1" class="mq lc iq mh b gy mv ms l mt mu">  async load(plugin: PluginTemplate&lt;T&gt;) {<br/>    this._plugins.push(plugin);<br/>    await plugin.start();<br/>  }</span><span id="fa9e" class="mq lc iq mh b gy mv ms l mt mu">  async unload(pluginName: string) {<br/>    let plugin = this._plugins.find(plugin =&gt; plugin.name === pluginName);<br/>    if (!plugin) return false;<br/>    await plugin.stop();<br/>    return true;<br/>  }<br/>}</span></pre><p id="12c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使从文件系统加载插件更容易，我们可以创建一个从目录中读取所有文件的方法，并将该目录中的任何文件作为插件加载。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="beb7" class="mq lc iq mh b gy mr ms l mt mu">  async loadDir(app: T, dir: string) {<br/>    let files = await fs.readdir(dir);<br/>    for (let file of files) {<br/>      // The current working is used to resolve the path to the plugins directory.<br/>      let Plugin = await import(path.join(process.cwd(), dir, file));<br/>      let plugin = new Plugin(app);<br/>      await this.load(plugin as PluginTemplate&lt;T&gt;);<br/>    }<br/>  }</span></pre><p id="6305" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了帮助卸载插件，例如当一个应用程序停止时，我们将创建一个方法从<code class="fe me mf mg mh b">_plugins</code>字段中卸载每个函数。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5a48" class="mq lc iq mh b gy mr ms l mt mu">  async unloadAll() {<br/>    for (let plugin of this._plugins) {<br/>      await plugin.stop();<br/>    }<br/>  }</span></pre><h1 id="0e55" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">添加应用</strong></h1><p id="a57b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将任何我们希望的泛型作为<code class="fe me mf mg mh b">T</code>传递，但最有可能的类型是应用程序的主类。该类也可能包含插件管理器实例。为了一举两得，让我们用一个<code class="fe me mf mg mh b">pluginManager</code>模拟一个<code class="fe me mf mg mh b">App</code>类。我们可以从当前工作目录(你启动应用的目录)中的<code class="fe me mf mg mh b">./plugins</code>目录中加载插件。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="40b5" class="mq lc iq mh b gy mr ms l mt mu">export class App {<br/>  pluginManager = new PluginManager&lt;App&gt;();</span><span id="28d3" class="mq lc iq mh b gy mv ms l mt mu">  constructor() {}</span><span id="03aa" class="mq lc iq mh b gy mv ms l mt mu">  start() {<br/>    this.pluginManager.loadDir(this, './plugins')<br/>  }</span><span id="3547" class="mq lc iq mh b gy mv ms l mt mu">  stop() {<br/>    this.pluginManager.unloadAll();<br/>  }<br/>}</span></pre><h1 id="d845" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">便捷的打字快捷键</strong></h1><p id="37b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以定义一个简化用法的快捷方式类型，而不是每次创建插件时都传递类型作为泛型。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5ce1" class="mq lc iq mh b gy mr ms l mt mu">export type AppPlugin = PluginTemplate&lt;App&gt;;</span><span id="9161" class="mq lc iq mh b gy mv ms l mt mu">// old<br/>export default class MyPlugin extends PluginTemplate&lt;App&gt; {...}<br/>// new<br/>export default class MyPlugin extends AppPlugin {...}</span></pre><h1 id="417e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">结论</strong></h1><p id="f977" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为插件系统添加类型安全使得开发过程更加快速和安全。但是不要忘记暴露正确的类型，比如你的app/plugin api和任何快捷方式类型。如果你准备好迎接挑战，尝试将它与你现有的应用程序集成。</p><p id="5bcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">说白了。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">免费周报</em> </strong> </a> <em class="mw">。关注我们关于</em> <a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">推特</em> </strong> </a>，<a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">领英</em> </strong> </a> <strong class="kf ir"> <em class="mw">，</em></strong><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">YouTube</em></strong></a><strong class="kf ir"><em class="mw">和</em></strong><em class="mw"><a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">不和</em> </strong></a></em> </strong> <em class="mw">对成长黑客感兴趣？检查出</em> </a><a class="ae kc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">电路</em> </strong> </a> <strong class="kf ir"> <em class="mw">。</em>T78】</strong></p></div></div>    
</body>
</html>