<html>
<head>
<title>Revise Key JavaScript Concepts for 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修订2022年的关键JavaScript概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/revise-key-javascript-concepts-for-2022-91ea149004f1?source=collection_archive---------4-----------------------#2022-03-30">https://javascript.plainenglish.io/revise-key-javascript-concepts-for-2022-91ea149004f1?source=collection_archive---------4-----------------------#2022-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/74fa5ebd2529c089c514dffa0d40a2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6FcL2bQkmmFQ09Xz"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pankaj Patel</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5ddd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗨，伙计们！现在是2022年，我写这个故事仍然没有任何犹豫。每当我开始修改JavaScript时，我每次都能学到新的东西。</p><p id="59f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以希望如此，我又开始修改了，非常欢迎你加入我！在这个简明扼要的故事中，我的重点是这门语言中一些最常用但又最重要的部分。</p><h1 id="7de4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript是如何工作的？—发动机</h1><p id="2ed3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">JavaScript遵循JIT(即时)编译，也就是说，代码在执行时或执行前进行编译。这由一个JS引擎负责(比如chrome的V8)。</p><p id="bc8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">典型的JS引擎有两个主要组件[参见JS 中的<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">事件循环]:</a></p><p id="716e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1.堆内存，内存分配是自动完成的。</p><p id="d50c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.调用堆栈，在那里代码执行，告诉哪一行代码正在执行。</p><p id="0f26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript可以一次处理一个任务(单线程)，但是我们可以利用JS的异步特性以非阻塞的方式执行并发任务。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/d86afc3bdd77366e38b0b30f361660ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GXoHZiIUhlKuKGT22gHmA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">for goosebumps :)</figcaption></figure><p id="8134" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该引擎有两个主要阶段:编译和执行。</p><p id="3628" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编译阶段包括创建作用域，解析程序的语法结构；创建抽象语法树(AST ),并最终将AST转换为可执行代码。</p><p id="39ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目前，虽然从程序上讲，我们不能在JS中触发垃圾收集，但是JS中有一个垃圾收集机制，当不再需要时，它会自动释放分配的内存。</p><h1 id="7e2d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript中的范围</h1><p id="fbca" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">JS<strong class="kc io">T3中声明的范围可以是词法的，也可以是动态的。词法范围由声明函数/代码的位置定义(作者时)。动态范围是在运行时确定的，它涉及函数/代码在哪里被调用来执行。</strong></p><p id="eb94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JS中的词法默认作用域是窗口/全局作用域。当一个变量被定义在某些边界之间时，一个局部作用域就被创建了。</p><p id="3ab6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JS中，声明被移动到它们作用域的顶部，从而确保我们可以在它们的声明之前使用变量/函数。JS的这种行为叫做<strong class="kc io">吊装</strong>。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9458" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">function getName() { <br/> name = 'JS';<br/> var name;<br/>}</em></span><span id="6479" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">console.log(name); </em><br/>// Reference Error as 'name' is not declared in global scope</span></pre><h1 id="1ba0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript中的闭包</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a17d" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">function outer() { <br/> var m = 5;<br/> function inner() { <br/>  console.log(m);<br/>  }<br/> return inner;<br/>}</em></span><span id="d345" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">var myClosure = outer();<br/>myClosure(); // 5</em></span></pre><p id="0fef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们把下一行读2-3遍，以便更好地复习闭包。当一个函数能够记住并访问它的词法作用域(写它的时间和位置)时，即使这个函数在它的词法作用域之外执行，闭包也会被创建。在上面的例子中，inner()能够做到这一点。<br/> JavaScript闭包可以用来实现<a class="ae jz" href="https://dev.to/iyashsoni/javascript-debounce-vs-throttle-392i" rel="noopener ugc nofollow" target="_blank">节流和去抖</a>功能。</p><h1 id="7941" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><em class="ms">JavaScript中的‘this’</em></h1><p id="6441" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"> <em class="mq">这个</em> </a> <em class="mq"> </em>关键字是指它所绑定的对象/范围。<em class="mq">这个</em>告诉一个对象的上下文。因此，了解对象的绑定变得很重要。值得注意的是<em class="mq">这个</em>指的不是词法而是运行时绑定。这意味着，我们所指的实际上下文是在运行时为<em class="mq"> this决定的执行上下文。&lt;对象&gt;。</em></p><p id="d3eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在非严格模式下，这个的默认绑定是窗口/全局上下文。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ac97" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">var n = 10;<br/>console.log(this.n);</em> // 10</span></pre><p id="a2f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们来看看<em class="mq">这个</em>是怎么指执行范围的:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3248" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">function getName() { <br/>  console.log(this.name); <br/>}<br/><br/>const obj = {  <br/>  name: 'name one',<br/>  getName: getName,<br/>  innerObj: {<br/>    name: 'name two',<br/>    getName: getName<br/>  }<br/>}</em></span><span id="c1dd" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">obj.getName();</em> // name one<br/><em class="mq">obj.innerObj.getName(); </em>// name two</span></pre><h1 id="415f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在JavaScript中绑定、调用和应用方法</h1><p id="9ede" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><em class="mq">绑定</em>方法用于将<em class="mq"> this </em>关键字设置为提供的值。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8768" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">this.name = 'Hundred';   <br/>const obj = {<br/>  name: 'One',<br/>  getName: function() { return this.name; }<br/>};<br/><br/>obj.getName();</em><br/>//  returns 'One'<br/><br/><em class="mq">const retrieveName = obj.getName;<br/>retrieveName();</em><br/>//  returns 'Hundred'; the function gets invoked at the global scope<br/><br/><em class="mq">const boundGetName = retrieveName.bind(obj);<br/>boundGetName();</em><br/>//  returns 'One'</span></pre><p id="bfa6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<em class="mq">调用</em>方法，我们可以编写一次方法，然后在另一个对象中继承它，而不必为新对象重写它。</p><p id="0d37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq">调用</em>方法使用给定的<em class="mq"> this </em>值和单独提供的参数调用函数。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5ca6" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">var n = 10;<br/>function numb() { <br/> console.log(this.n)<br/>}<br/>var obj = { n: 77 }</em></span><span id="609a" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">numb(); </em>// 10<br/><em class="mq">numb.call(obj);</em> // 77</span></pre><p id="c9da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq"> apply </em>方法使用给定的<em class="mq"> this </em>值和作为数组或类数组对象提供的参数调用函数。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="cbd8" class="ml kz in mh b gy mm mn l mo mp">// conventionally<br/><em class="mq">console.log(Math.max(5, 6, 1, 9, 2))</em> // 9;</span><span id="e536" class="ml kz in mh b gy mr mn l mo mp">// using apply<br/><em class="mq">var numbs = [5, 6, 1, 9, 2];<br/>var max = Math.max.apply(null, numbs);<br/>console.log(max); </em>// 9</span></pre><h1 id="1122" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript中的生活</h1><p id="76db" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">JS中的立即调用函数表达式(IIFE)是一个匿名函数，一旦被定义就被调用。使用IIFE的主要目的是数据隐私，因为它内部的声明不能在全局范围内使用。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="89d3" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">(function(a, b){         <br/>     console.log(a+b); <br/>})(5,10);</em></span><span id="02e0" class="ml kz in mh b gy mr mn l mo mp">// 15</span></pre><p id="201d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想在浏览器加载JS文件时立即执行一些代码，我们也可以这样做。</p><h1 id="b2b8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript中的Currying</h1><p id="688a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">curry函数的结果是一个包装函数。下面是JS中一个基本的currying示例:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e14b" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">const sumCurryFunc =(a) =&gt; {<br/>    return (b)=&gt;{<br/>        return (c)=&gt;{<br/>            return a+b+c;<br/>        }<br/>    }<br/>}</em></span><span id="a5f0" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">console.log(sumCurryFunc(2)(3)(5)); </em>// 10</span></pre><p id="0867" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个例子展示了操纵DOM的currying用法。</p><h1 id="c1a7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript中的记忆化</h1><p id="8a9f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">记忆是一种记忆/存储先前计算结果的优化技术。我们也可以称之为缓存，它可以确保函数不会因为相同的计算而被再次执行，从而提高性能。高阶函数(接受另一个函数作为自变量或返回一个函数的函数)和闭包是实现记忆化的基础。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="34dd" class="ml kz in mh b gy mm mn l mo mp">// factorial of a number<br/><em class="mq">const factorial = num =&gt; {<br/>  if (!factorial.cache) factorial.cache = {};<br/><br/>  if (factorial.cache[num] !== undefined) {<br/>    console.log(num + 'is cached')<br/>    return factorial.cache[num];<br/>  } else console.log(num + ' is not cached');<br/>  <br/>  factorial.cache[num] = num === 0 ? 1 : num * factorial(num - 1)<br/>  return factorial.cache[num]<br/>}</em></span><span id="73da" class="ml kz in mh b gy mr mn l mo mp">console.log(fact(5));<br/>console.log(fact(2));<br/>console.log(fact(5)); // 5 is cached; 120</span></pre><h1 id="50cd" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">ES6功能</h1><p id="9fd1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为了提醒我们，下面列出了ES6的一些重要功能:</p><ul class=""><li id="da25" class="mt mu in kc b kd ke kh ki kl mv kp mw kt mx kx my mz na nb bi translated">let和const:块级范围；<code class="fe nc nd ne mh b">function() {const name='JS'; let greet; greet='good morning';}</code></li><li id="dff6" class="mt mu in kc b kd nf kh ng kl nh kp ni kt nj kx my mz na nb bi translated"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头功能</a></li><li id="f675" class="mt mu in kc b kd nf kh ng kl nh kp ni kt nj kx my mz na nb bi translated">模板文字:<code class="fe nc nd ne mh b">const name="JS”; `Hello ${name}`</code></li><li id="836e" class="mt mu in kc b kd nf kh ng kl nh kp ni kt nj kx my mz na nb bi translated">默认参数:<code class="fe nc nd ne mh b">function(name='') {}</code></li><li id="dbc9" class="mt mu in kc b kd nf kh ng kl nh kp ni kt nj kx my mz na nb bi translated">对象分解:<code class="fe nc nd ne mh b">const obj={ name: 'JS'}; const { name } = obj; console.log(name);</code></li><li id="295d" class="mt mu in kc b kd nf kh ng kl nh kp ni kt nj kx my mz na nb bi translated"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">班级</a></li><li id="1121" class="mt mu in kc b kd nf kh ng kl nh kp ni kt nj kx my mz na nb bi translated"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noopener ugc nofollow" target="_blank">模块</a></li></ul><h1 id="959e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript中的承诺</h1><p id="4389" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在JavaScript中，还可以将函数作为参数传递给函数。作为参数传递的函数称为<strong class="kc io">回调</strong>函数。回调函数在前一个函数完成执行后执行。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="782c" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">function hasCallback(text, callback) {<br/>  setTimeout(function() {<br/>    callback(text);<br/>  }, 2000);<br/>}</em></span><span id="5396" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">hasCallback('hello', function(v){ console.log(v) });</em><br/>// after 2 seconds, 'hello' is printed</span></pre><p id="8c84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JS中，承诺用于处理异步逻辑。一旦承诺得到回应，它要么<em class="mq">解决</em>(成功)，要么<em class="mq">拒绝</em>(错误)<em class="mq">。</em>这两种情况我们都可以分别用<em class="mq"> then </em>或者<em class="mq"> catch </em>来处理，同时调用一个承诺。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ab6f" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">var promise = new Promise(function(resolve, reject){<br/>     if (condition) { resolve('success'); }<br/>     else { reject(''fails); }<br/>});</em></span><span id="afd8" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">promise<br/>  .then(function() {<br/>    </em>// handle success<em class="mq"><br/>  })<br/>  .catch(function(error)) { <br/>   </em>// handle failure<em class="mq"><br/> }</em></span><span id="0210" class="ml kz in mh b gy mr mn l mo mp">// using async await<em class="mq"><br/> try {<br/>    const response = await promise;<br/>    console.log(response)<br/> }<br/> catch(error) {<br/>    console.log(error)<br/> }</em></span></pre><h1 id="ee34" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript数组方法</h1><p id="1323" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们来看看开发人员日常生活中常用的一些数组方法:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ae1b" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">const res=['tax', 'limit', 'elite'].</em><strong class="mh io"><em class="mq">filter</em></strong><em class="mq">(word =&gt; word.length &lt; 4);<br/>console.log(res);</em><br/>// ["tax"]</span><span id="081b" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">const mapArr = [1, 4, 9, 16].</em><strong class="mh io"><em class="mq">map</em></strong><em class="mq">(x =&gt; x * 2);<br/>console.log(mapArr);</em><br/>// [2, 8, 18, 32]</span><span id="a3e2" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">['a', 'b', 'c'].</em><strong class="mh io"><em class="mq">forEach</em></strong><em class="mq">(element =&gt; console.log(element));<br/></em>// "a" "b" "c"</span><span id="342d" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">console.log([2, 1, 4].</em><strong class="mh io"><em class="mq">includes</em></strong><em class="mq">(1));</em><br/>// true</span><span id="a91f" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">const sumWithInitial = [1, 2, 3, 4].</em><strong class="mh io"><em class="mq">reduce</em></strong><em class="mq">(<br/>  (previousValue, currentValue) =&gt; previousValue + currentValue,<br/>  0<br/>);<br/>console.log(sumWithInitial);</em><br/>// 10</span><span id="b8ea" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">console.log(['camel', 'duck', 'elephant'].</em><strong class="mh io"><em class="mq">slice</em></strong><em class="mq">(1));</em><br/>// ["duck", "elephant"]</span><span id="8b40" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">console.log(['camel', 'duck', 'elephant'].</em><strong class="mh io"><em class="mq">splice</em></strong><em class="mq">(1, 0, 'ant'));</em><br/>// ['camel', 'ant', 'duck', 'elephant']</span><span id="3fd2" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">console.log([0, 1, 2, [3, 4]].</em><strong class="mh io"><em class="mq">flat</em></strong><em class="mq">());</em><br/>// [0, 1, 2, 3, 4]</span></pre><h1 id="b9a6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JS中的生成器</h1><p id="bfef" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">生成器</a>的帮助下，(使用*声明为生成器)我们可以暂停一个函数的执行，并且可以从它停止的地方继续。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="47cc" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">function * fun() {<br/>    yield 10;<br/>    yield 20;<br/>    yield 30;    <br/> }<br/>  <br/>var gen = fun();</em><br/><em class="mq">console.log(gen.next().value); </em>// 10<em class="mq"><br/>console.log(gen.next().value); </em>// 20<em class="mq"><br/>console.log(gen.next().value); </em>// 30</span></pre><h1 id="6528" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript中最新最酷的特性</h1><ol class=""><li id="2aff" class="mt mu in kc b kd lw kh lx kl nk kp nl kt nm kx nn mz na nb bi translated">可选链接:帮助访问深度嵌套的对象属性，而不用担心属性是否存在。</li></ol><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c671" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">const obj = { name: 'JS', level: 7 }</em><br/><em class="mq">console.log(obj?.name);</em> // JS<br/><em class="mq">console.log(obj?.age);</em> // undefined<br/><em class="mq">console.log(obj?.name?.firstName);</em> // undefined</span></pre><p id="0597" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.<strong class="kc io">无效合并:</strong>检查一个变量是否是真正意义上的无效:)</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="cd8c" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">console.log(false ?? '');</em><br/>// false</span><span id="1b10" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">console.log(false || '');</em><br/>// ''</span></pre><p id="5edb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.<strong class="kc io"> Promise.allSettled: </strong>接受一组承诺，只有当所有承诺都被结算时才进行结算。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5884" class="ml kz in mh b gy mm mn l mo mp"><em class="mq">const promise1 = Promise.resolve(3);<br/>const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'example'));</em></span><span id="a606" class="ml kz in mh b gy mr mn l mo mp"><em class="mq">Promise.allSettled([promise1, promise2]).<br/>  then((res) =&gt; res.forEach((r) =&gt; console.log(r.status)));</em></span><span id="4def" class="ml kz in mh b gy mr mn l mo mp">// fulfilled<br/>// rejected</span></pre><p id="b704" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript一直在发展，是最流行的编程语言之一。让我们看看它接下来会有什么。到那时，快乐的编码和感谢阅读！</p><p id="1479" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">plain English . io</em></strong></a><em class="mq">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mq">免费周报</em> </strong> </a> <em class="mq">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">Twitter</em></strong></a><em class="mq">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">LinkedIn</em></strong></a><em class="mq">。加入我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mq">社区不和谐</em> </strong> </a> <em class="mq">。</em></p></div></div>    
</body>
</html>