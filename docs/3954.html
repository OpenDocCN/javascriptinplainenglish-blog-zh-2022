<html>
<head>
<title>Most Useful Angular Features You’ve Probably Never Used</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能从未用过的最有用的角度特征</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/most-useful-angular-features-youve-probably-never-used-a64522e747a9?source=collection_archive---------0-----------------------#2022-10-13">https://javascript.plainenglish.io/most-useful-angular-features-youve-probably-never-used-a64522e747a9?source=collection_archive---------0-----------------------#2022-10-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d90f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在本文中，我们将重点介绍一些你可能从未听说过的最有用的角度特征。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d05a45a8882bb2939f79c6bfd431d5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znUTFQE2vObp4KcxBc8HUQ.png"/></div></div></figure><p id="3f6e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Angular是最好的现代web开发人员平台之一，它允许您跨平台开发，重用您的代码，通过使用Web Workers和服务器端呈现获得尽可能快的速度，并通过在RxJS、Immutable.js上构建数据模型以及使用简单的声明性模板快速创建功能，让您更好地控制可伸缩性。</p><p id="4bda" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你花了相当多的时间<a class="ae lk" href="https://angular.io/tutorial/toh-pt0" rel="noopener ugc nofollow" target="_blank">构建角度应用</a>，你可能知道它是如何工作的。但是如果我们告诉你这些角度特征有更多的含义，而你可能已经错过了呢？</p><p id="0a28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们弄清楚这是怎么回事！</p><h2 id="bad2" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> 1。标题</strong></h2><p id="f3b2" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">title标签是一个HTML元素，表示网页的标题是什么。标题标签在搜索引擎结果页面上显示为搜索结果的可点击标题。它们对于可用性、SEO和社交媒体上的分享都很重要。</p><p id="56f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Angular应用程序从index.html文件中的<em class="mj">标题&gt;…/标题&gt; </em>标签获取浏览器窗口的标题。在Angular中，当您移动到一个组件时，标题不会改变。</p><p id="6823" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mj">你知道组件可以改变浏览器的标题吗？</em>T9】</strong></p><p id="db22" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在@angular/platform-browser中，有一个服务叫Title for Angular。我们只是给我们的组件标题服务，并使用<em class="mj"> setTitle </em>方法来更改标题。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="bc13" class="ll lm in ml b gy mp mq l mr ms">import { Title } from “@angular/platform-browser”@Component({ <br/> … <br/> }) <br/> export class LoginComponent implements OnInit { <br/> constructor(private title: Title) {} ngOnInit() { <br/> title.setTitle(“Login”) <br/> } <br/> }</span></pre><p id="1236" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们转到LoginComponent时，“Login”将被设置为浏览器的标题。</p><p id="32c3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以对项目的所有组件都这样做，这样当组件被导航时，组件的标题就会出现在浏览器窗口中。</p><h2 id="d1ab" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> 2。元</strong></h2><p id="9b8a" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我们的Angular应用程序显示的大部分内容来自index.html文件。我们的应用程序将在index.html文件中设置元标签。angular中的@angular/platform-browser有一个元服务，允许我们从组件中设置元标签。</p><p id="8534" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这对SEO和在社交媒体上分享组件持有的页面非常有帮助。</p><p id="4cab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">元元素给出了关于网页的信息，搜索引擎可以使用这些信息来帮助将网页放在正确的类别中。</p><p id="eaf5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">非常好用；只需从@angular/platform-browser导入Meta，并将其注入到我们的组件中。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="764b" class="ll lm in ml b gy mp mq l mr ms">import { Meta } from “@angular/platform-browser”@Component({ <br/> … <br/>}) <br/>export class BlogComponent implements OnInit { <br/> constructor(private meta: Meta) {} ngOnInit() { <br/> meta.updateTag({name: “title”, content: “”}) <br/> meta.updateTag({name: “description”, content: “Lorem ipsum dolor”}) <br/> meta.updateTag({name: “image”, content: “./assets/blog-image.jpg”}) <br/> meta.updateTag({name: “site”, content: “My Site”}) <br/> } <br/>}</span></pre><p id="d06c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了这个，我们的博客组件可以在脸书、推特等网站上展示。，带有标题、图片和功能描述。</p><p id="183a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你也听过这个吗？</p><h2 id="1789" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> 3。覆盖模板插值</strong></h2><p id="3df3" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我们都在模板中使用默认的模板插值器来显示组件中的属性。</p><p id="85aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">开始是，结束是。如果我们在它们之间放置一个属性成员，它将显示在浏览器的DOM上。你知道我们可以用自己的符号代替默认符号来表示封装的开始和结束吗？很容易；只要在插值属性中告诉组件装饰器。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="2e13" class="ll lm in ml b gy mp mq l mr ms">@Component({ <br/> interpolation: [“((“,”))”] <br/>}) <br/>export class AppComponent {}</span><span id="68c7" class="ll lm in ml b gy mt mq l mr ms">In the AppComponent’s template, “” will no longer be used as an interpolation. Instead, “(())” will be used.</span><span id="d4fa" class="ll lm in ml b gy mt mq l mr ms">@Component({ <br/> template: ` <br/> &lt;div&gt; <br/> ((data)) <br/> &lt;/div&gt; <br/> `, <br/> interpolation: [“((“,”))”] <br/> }) <br/> export class AppComponent { <br/> data: any = “dataVar” <br/> }</span></pre><p id="3c89" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">页面渲染时将显示<em class="mj">【数据变量】</em>而不是<em class="mj">“((数据)”)</em>。</p><h2 id="0549" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> 4。位置</strong></h2><p id="061b" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">使用定位服务，我们可以找到我们正在看的窗口的URL。根据使用的LocationStrategy，Location将遵循URL的路径或散列段。</p><p id="67c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了位置，我们可以转到一个URL，在平台的历史中前进，在平台的历史中后退，更改浏览器的URL，并替换平台历史堆栈中的顶部项目。</p><p id="b123" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们通过从CommonModule注入位置服务来使用它。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="a57b" class="ll lm in ml b gy mp mq l mr ms">import { Location } from “@angular/common”@Component({ <br/> … <br/>}) <br/>export class AppComponent { <br/> constructor(private location: Location) {} navigateTo(url) { <br/> this.location.go(url) <br/> } goBack() { <br/> location.back() <br/> } goForward() { <br/> location.forward() <br/> } <br/>}</span></pre><h2 id="cd06" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> 5。文件</strong></h2><p id="7c9c" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">有时候，我们希望获得文档模型，以便我们的Angular app可以进行DOM操作。</p><p id="b804" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是文件给出的内容。文档是阿迪令牌，代表呈现的主上下文。这就是浏览器的DOM文档。它提供了适用于任何环境的DOM操作。</p><p id="0264" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注意:</strong>如果应用程序上下文和呈现上下文不同，文档可能在应用程序上下文中不可用(例如，当在Web Worker中运行应用程序时)。</p><p id="6eb9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我们的HTML有这个元素:</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="ff99" class="ll lm in ml b gy mp mq l mr ms">&lt;canvas id=”canvas”&gt;&lt;/canvas&gt;</span><span id="1e96" class="ll lm in ml b gy mt mq l mr ms">We can get the canvas HTMLElement by putting DOCUMENT: in front of it.</span><span id="08ef" class="ll lm in ml b gy mt mq l mr ms">@Component({}) <br/>export class CanvasElement { <br/> constructor(@Inject(DOCUMENT) _doc: Document) {} <br/>}</span></pre><p id="208b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们可以通过调用getElementById()来获取canvas的HTMLElement</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="c0b7" class="ll lm in ml b gy mp mq l mr ms">@Component({}) <br/> <br/>export class CanvasElement { <br/> <br/> constructor(@Inject(DOCUMENT) _doc: Document) {} renderCanvas() { <br/> <br/> this._doc.getElementById(“canvas”) <br/> <br/> } <br/> <br/>}</span></pre><p id="2d44" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以使用ElementRef和模板引用安全地做到这一点，但是你明白了。</p><p id="7f4d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mj">注意:</em> </strong> <em class="mj">小心脚下！直接与DOM交互是有风险的，可能会导致XSS风险。</em></p><h2 id="38b9" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> 6。属性装饰器</strong></h2><p id="a5ba" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">组件、模块和指令装饰器是我们在Angular应用中使用最多的。</p><p id="5d87" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们有这个属性修饰器，它允许我们传递一个静态字符串，而不会因为不检查它是否改变而减慢速度。</p><p id="16b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">attribute decorator的值只被检查一次，不会再被检查。它们的用法与@Input相同:</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="7f9f" class="ll lm in ml b gy mp mq l mr ms">@Component({ <br/> … <br/> }) <br/> export class BlogComponent { <br/> constructor(@Attribute(“type”) private type: string ) {} <br/> }</span></pre><h2 id="85f8" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> 7。http接收器</strong></h2><p id="86cb" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">这是Angular非常强大的一部分。它的工作方式很像美国的拦截战斗机。它停止HttpRequests并处理它们。</p><p id="a72d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过调用<em class="mj">next . handle(transformed req)</em>，大多数拦截器在将请求发送给链中的下一个拦截器之前，都会更改发出的请求。</p><p id="8086" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">句柄(transformedReq)。</p><p id="3296" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在极少数情况下，拦截器可能希望自己处理一个请求，而不是将它传递给整个链。这种行为没问题。</p><p id="49a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">HttpInterceptor可用于:</p><ul class=""><li id="9b6e" class="mu mv in kq b kr ks ku kv kx mw lb mx lf my lj mz na nb nc bi translated">证明</li><li id="7005" class="mu mv in kq b kr nd ku ne kx nf lb ng lf nh lj mz na nb nc bi translated">缓存，</li><li id="cd64" class="mu mv in kq b kr nd ku ne kx nf lb ng lf nh lj mz na nb nc bi translated">假后端</li><li id="87e4" class="mu mv in kq b kr nd ku ne kx nf lb ng lf nh lj mz na nb nc bi translated">更改URL</li><li id="914d" class="mu mv in kq b kr nd ku ne kx nf lb ng lf nh lj mz na nb nc bi translated">更改标题</li></ul><p id="997b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它很容易使用。首先，创建一个服务并实现HttpInterceptor接口。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="f9a0" class="ll lm in ml b gy mp mq l mr ms">@Injectable() <br/>export class MockBackendInterceptor implements HttpInterceptor { <br/> constructor() {} intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { <br/> … <br/> } <br/>}</span></pre><p id="ce3d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">之后，将其添加到您的主模块中:</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="dec1" class="ll lm in ml b gy mp mq l mr ms">@NgModule({ <br/> …</span><span id="8097" class="ll lm in ml b gy mt mq l mr ms">providers: [ <br/> { <br/> provide: HTTP_INTERCEPTORS, <br/> useClass: MockBackendInterceptor, <br/> multi: true <br/> } <br/> ] <br/> … <br/> }) <br/> export class AppModule {}</span></pre><h2 id="c9ab" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak"> 8。AppInitializer </strong></h2><p id="3844" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">有时候，我们希望在Angular应用程序启动时运行一段代码。例如，我们可能想要加载一些设置、缓存、配置或签入。AppInitializer标记使这变得更容易。</p><p id="50d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">APP INITIALIZER是第一次启动应用程序时运行的函数。</p><p id="bf3f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">用起来很简单。假设我们希望我们的Angular应用程序在启动时运行这个<em class="mj"> runSettings </em>函数:</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="3ee5" class="ll lm in ml b gy mp mq l mr ms">function runSettingsOnInit() { <br/> … <br/> }</span></pre><p id="7593" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将它添加到主模块AppModule的NgModule装饰器中，位于提供者部分:</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="a737" class="ll lm in ml b gy mp mq l mr ms">@NgModule({ <br/> providers: [ <br/> { provide: APP_INITIALIZER, useFactory: runSettingsOnInit } <br/> ] <br/> })</span></pre><h2 id="dd65" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak">结论</strong></h2><p id="0dcc" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">今天，我们希望你对<a class="ae lk" href="https://jumpgrowth.com/angular-js-development/" rel="noopener ugc nofollow" target="_blank"> Angular app开发</a>有了一些新的认识。如果不是，那么不要担心；我们在知识上都有差距，上面的列表并不完整。棱角很大，很复杂。查看角源，看看是否能找到以前从未被写过或听说过的特征。我会等着看你发现什么。</p></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="ee35" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mj">更多内容看</em> <a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mj">说白了。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mj">免费周报</em> </strong> </a> <em class="mj">。关注我们关于</em> <a class="ae lk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mj">推特</em> </strong> </a>，<a class="ae lk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mj">LinkedIn</em></strong></a><em class="mj">，</em><a class="ae lk" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mj">YouTube</em></strong></a><em class="mj">，以及</em> <a class="ae lk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mj">不和</em> </strong> </a> <em class="mj">。对增长黑客感兴趣？检查</em> <a class="ae lk" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mj">电路</em> </strong> </a> <em class="mj">。</em></strong></a></p></div></div>    
</body>
</html>