<html>
<head>
<title>Terrible JavaScript Advice: Debunking Stupid Suggestions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可怕的JavaScript建议:揭穿愚蠢的建议</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/terrible-javascript-advice-debunking-stupid-advice-8be0f4724005?source=collection_archive---------2-----------------------#2022-06-28">https://javascript.plainenglish.io/terrible-javascript-advice-debunking-stupid-advice-8be0f4724005?source=collection_archive---------2-----------------------#2022-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c67f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">然而，另一位程序员给出了糟糕的建议。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/db1c22cbe68e6805481646f1e6eafd8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Izvhkzj0e_2ebx0gmA18iw.png"/></div></div></figure><p id="2c95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天早些时候，我读了一篇名为<a class="ae ln" href="https://medium.com/javascript-in-plain-english/10-javascript-hacks-every-programmer-should-know-9b79efbabc4d" rel="noopener"> <em class="lo">的文章，作者是Ruhul Amin</em></a><em class="lo">。这位作者似乎对编程一无所知。</em></p><p id="a08d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我厌倦了媒体作家在简单的英语出版物中用可怕的文章和可怕的信息来滥发JavaScript。在这篇文章中，我将揭穿鲁胡尔·阿明的每一个主张，并解释为什么你不应该听他的建议。</p><p id="33dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他相信他的建议会优化你的JavaScript，减少内存使用，提高运行效率。这不是真的；<strong class="kt ir">如果你听从他的建议</strong>，你的代码库将<strong class="kt ir">更难维护</strong>，<strong class="kt ir">低效</strong>，并且<strong class="kt ir">使用更多内存</strong>。</p><p id="9e41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，很明显，在他的清单的第6或第7项，他用完了“黑客”，所以他用废话填充它。很抱歉我的消极，但请继续读下去。</p><h1 id="cd5f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">1.使用array.length()调整数组大小或清空数组</h1><p id="57e8" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">好吧…所以呢？这就是调整数组大小的方法！这不是一个JavaScript黑客，而是你应该如何缩小一个集合。</p><p id="d827" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Ruhul的第一点就像是说，“嘿，看看这个JavaScript黑客”:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="a51c" class="mr lq iq mn b gy ms mt l mu mv">const x = "Hi";</span></pre><p id="c27a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇！看看这个很酷的JavaScript代码。你可以用<code class="fe mw mx my mn b">const</code>在JavaScript中赋值一个常量！</p><p id="086d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不是很有趣，也不是JavaScript黑客。</p><h1 id="6634" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">2.展平多维数组</h1><blockquote class="mz na nb"><p id="faa0" class="kr ks lo kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated">"我们可以使用spread运算符来展平多维数组。"——鲁胡尔·阿明。</p></blockquote><p id="3f2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他提供了以下JavaScript代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/a620d002ac2493833e0e8e78929dc146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bz8X3Lv32Pf1bK6fZQiaVA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Code that only flattens a 2D array — not all multidimensional arrays</figcaption></figure><p id="fb37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你不能用这种方式展平多维数组！多维是什么意思？它的意思不仅仅是一维的。这包括2D、3D和4D阵列等。</p><p id="86f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这段代码甚至不能用于3D数组:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/9b34a64f3c06b4d167f2dd00708637ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xP5Yb8LDbdKgj1k1VLN_aQ.gif"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Demonstration of the flaws in Ruhul’s code</figcaption></figure><p id="924c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">那么正确的方法是什么呢？</strong>使用<code class="fe mw mx my mn b">Array.flat(n)</code>原型函数，其中<code class="fe mw mx my mn b">n</code>是维度的数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/9a6ab939b73668daece2e446ac9b9f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LJl46NDQZPtBnPbgeMUAw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">The correct way to flatten an multi-dimensional array in JavaScript</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/5de454596bea7af93b78ddd6fab46b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5XQFfpQsdhhlAcVd-00KfA.gif"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Demonstration of the flat array prototype function</figcaption></figure><h1 id="7388" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">3.获取数组中的最后一项</h1><blockquote class="mz na nb"><p id="11ab" class="kr ks lo kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated"><em class="iq">“另一个聪明的技巧是，我们可以通过使用负数作为参数来获取数组中的最后一个元素。”——鲁胡尔·阿明。</em></p></blockquote><p id="dbeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他使用<code class="fe mw mx my mn b">slice</code>方法来完成这个任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/05f27fd922b3dd49b3f661f8fa3049d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wVY_MjJBWNWouAkmyffBcA.png"/></div></div></figure><p id="7097" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯…这不是黑客。同样，这是使用切片方法的正确方法。字面意思是在<code class="fe mw mx my mn b">Array.prototype.splice</code>的<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">文档</a>中。虽然，如果你想知道:<strong class="kt ir">这是一个获取最后一个元素</strong>的低效方法。</p><p id="42db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单的解决方案可能是最好的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/a7aa4aed9bcce56c0f7df4c0364964db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORXxNEHql1h2-VeRHj5dag.png"/></div></div></figure><p id="886a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，您不需要析构数组来访问最后一个元素。</p><h1 id="450b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">4.交换两个变量，不交换第三个变量</h1><blockquote class="mz na nb"><p id="0a31" class="kr ks lo kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated"><em class="iq">“我们可以使用第三个变量轻松交换两个变量。但是使用额外的变量意味着使用额外的内存。我们可以只用两个变量来优化内存。”——鲁胡尔·阿明。</em></p></blockquote><p id="612d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我一生中从未听过比这更错误的说法。作者提供了这个代码示例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/e41290c0165adbaa8f1d182ef356fc0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKpf0D6W7RiYjknmK8fpHg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Inefficient swap — Ruhul, you’re wrong again</figcaption></figure><p id="cfd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个代码是有效的。这是一个巧妙的把戏，但作者显然错了。这位作者显然从未上过计算机科学入门课程。使用一个额外的变量确实意味着更多的内存… <strong class="kt ir">但是初始化一个新的数组会使用更多的内存！</strong></p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="2935" class="mr lq iq mn b gy ms mt l mu mv">let x = 1;      // + 8 bytes<br/>let y = 2;      // + 8 bytes<br/>[x, y] = [y, x] // + 48 bytes</span></pre><p id="76f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第三行代码在赋值操作符的右边初始化一个新数组。空数组消耗V8中的<code class="fe mw mx my mn b">32 bytes</code>。每增加一个号至少消耗<em class="lo"/><code class="fe mw mx my mn b">8 bytes</code>。这种方法总共消耗<code class="fe mw mx my mn b">64 bytes</code>。</p><p id="35fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">交换两个数组的常规方法要高效得多</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="d5d0" class="mr lq iq mn b gy ms mt l mu mv">let x = 1;    // + 8 bytes<br/>let y = 2;    // + 8 bytes<br/>const z = x;  // + 8 bytes<br/>x = y;        // + 0 bytes<br/>y = z;        // + 0 bytes</span></pre><p id="1863" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一方面，使用临时变量只消耗<code class="fe mw mx my mn b">24 bytes</code>总量，而使用额外变量只消耗<code class="fe mw mx my mn b">8 bytes</code>。</p><p id="5aaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这不是Ruhul交换变量方法的唯一缺陷。他的方法在所有JavaScript运行时也慢得多。以下面的执行为例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/6c9d695f44c3709f0d9d73f1f6f12d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yr8lfJIUz0iDG-B2M9Vxmw.gif"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Demonstration showing that regular variable swapping is more efficient than Ruhul Amin’s method</figcaption></figure><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="a9f8" class="mr lq iq mn b gy ms mt l mu mv">array destructuring: 0.12ms</span><span id="64a9" class="mr lq iq mn b gy nl mt l mu mv">regular swap: 0.01ms</span></pre><p id="3162" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数组析构方法始终比临时变量花费至少12倍的时间。为什么？因为，在幕后，JavaScript正在做以下事情:</p><ol class=""><li id="6b02" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">初始化数组(分配48字节)</li><li id="76a7" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">访问<code class="fe mw mx my mn b">array[0]</code></li><li id="d6a0" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">将值分配给<code class="fe mw mx my mn b">y</code></li><li id="f4ff" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">访问<code class="fe mw mx my mn b">array[1]</code></li><li id="2d6c" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">将值分配给<code class="fe mw mx my mn b">x</code></li><li id="bb21" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">检查要析构的另一个值</li></ol><p id="04df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在做出如此明显错误的声明之前，鲁胡尔应该为他的代码计时或者做一些研究。</p><h1 id="067d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">5.通过优化内存合并两个数组</h1><p id="55b7" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">好吧，这个其实挺好的。他建议使用<code class="fe mw mx my mn b">Array.prototype.push.apply</code>而不是<code class="fe mw mx my mn b">Array.prototype.concat</code>。我对这种选择的唯一问题是，这两个原型函数不做同样的事情。</p><p id="b4e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mw mx my mn b">Array.prototype.concat(a, b)</code>将用来自<code class="fe mw mx my mn b">a</code>的元素创建一个<code class="fe mw mx my mn b">new</code>数组，后跟来自<code class="fe mw mx my mn b">b</code>的元素。</p><p id="0fdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mw mx my mn b">Array.prototype.push.apply</code>将元素从<code class="fe mw mx my mn b">b</code>推到现有的数组<code class="fe mw mx my mn b">a</code>。虽然这减少了内存占用，但这会频繁调用<code class="fe mw mx my mn b">push</code>，这会花费稍长的时间。</p><p id="a585" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">—呃。不是可怕的建议，但也不是好建议。</p><h1 id="af62" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">6.使用拼接代替简单删除</h1><blockquote class="mz na nb"><p id="983f" class="kr ks lo kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated">“这可能是优化JavaScript代码的最佳方法。它也加快了你的代码。为什么不应该使用<strong class="kt ir"> delete？</strong>因为它只是删除对象属性，而没有<strong class="kt ir">重新索引数组</strong>或更新其长度，留下未定义的值。基本上，它在执行中消耗了大量的时间。”——鲁胡尔·阿明。</p></blockquote><p id="1be4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他是正确的——从数组中删除元素时不应该使用<code class="fe mw mx my mn b">delete</code>关键字。不过还是那句话，<strong class="kt ir">这不是黑客</strong>。这只是另一个数组原型方法。它在数组的文档中。简单的谷歌搜索就会告诉你这些。</p><p id="5e16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还没有见过一个JavaScript开发人员，甚至是入门级的开发人员，使用<code class="fe mw mx my mn b">delete</code>关键字从数组中移除元素。</p><h1 id="93e0" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">7.我们应该使用开关…格而不是if/else</h1><blockquote class="mz na nb"><p id="e9fa" class="kr ks lo kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated">“<code class="fe mw mx my mn b">switch…case</code>总是被低估。<code class="fe mw mx my mn b">Switch…case</code>和<code class="fe mw mx my mn b">if/else</code>执行几乎相同的任务，但是<code class="fe mw mx my mn b">switch…case</code>的<strong class="kt ir">执行时间比<code class="fe mw mx my mn b">if/else</code>语句的</strong>快！这是为什么呢？在<code class="fe mw mx my mn b">if/else</code>语句中，您需要进行平均比较，以获得正确的子句。另一方面，switch语句基本上是一个查找表，其中包含已知的选项。”——鲁胡尔·阿明。</p></blockquote><p id="1771" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯……不完全是。我同意switch语句比if-else语句更快，但是只有当条件语句的数量非常大时，它才会明显更快。</p><p id="90ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…但是当您有大量的条件或开关语句时，使用对象映射会更好。这使得你的代码更快，更容易维护。</p><p id="b3b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下面的if语句为例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/9d916f6ecfdd2a9834d3649b25611193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H31y1fQxSZjfYNs_iAsuHg.png"/></div></div></figure><p id="a02f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以把它改写成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/65d4cb953656e3a1d93d9a754d7959bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqCYJv6aWlun2WTo610hDg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Slightly better</figcaption></figure><p id="9331" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是这段代码太长，效率低，而且不太容易维护。取而代之的是一个对象，将值映射到函数会更加有效和易于维护:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/ec802d693f2286377e234973387b7060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2MalnYmL4GhZNXhWGxHDg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">✅ Even better</figcaption></figure><h1 id="3930" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">8.尽快打破这个循环</h1><blockquote class="mz na nb"><p id="ebc1" class="kr ks lo kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated">“查找没有必要在一个循环中完成每个迭代的情况。例如，如果我们正在搜索一个特定的值，并且找到了那个值，那么后续的迭代是不必要的。因此，我们应该使用一个<code class="fe mw mx my mn b">break</code>语句来终止循环的执行。</p></blockquote><p id="3bf3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，他用冒号结束了这个陈述，但是没有提供例子。除此之外，<strong class="kt ir">这不是一个JavaScript黑客！这甚至不是更好的做事方式。这是编写代码的标准方式。这只是这种语言的一个特征，也是许多其他语言的一个特征。</strong></p><p id="d705" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">执行查找的函数不应该使用<code class="fe mw mx my mn b">break</code>语句，而应该使用<code class="fe mw mx my mn b">return</code>语句:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/2f09ce913aa1e587d35b2ed86e8f4925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCHrOYTPzN_TAuU1LPeq1A.png"/></div></div></figure><p id="df69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很明显，他已经没有“黑客”可写了，但是他想达到10个，所以他提供了这条建议。</p><h1 id="6668" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">9.减少内存泄漏的机会</h1><blockquote class="mz na nb"><p id="ebb6" class="kr ks lo kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated">“内存管理在JavaScript中很重要。如果你不能正确地管理内存，那么内存就会泄漏，这将是你的程序崩溃的原因。内存泄漏背后有一些原因。一些原因是:<strong class="kt ir">意外使用全局变量，忘记定时器或回调，不必要的缓存等。”</strong> —鲁胡尔·阿明。</p></blockquote><p id="2991" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，他可能已经没有“黑客”可写了，但他想达到“10个黑客”，所以他选择写“内存泄漏”。</p><p id="1ca9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这怎么是黑客呢？当然，每个开发人员都应该知道这一点。除非必要，否则避免全局变量是良好的编程实践。不再需要时，定时器(从<code class="fe mw mx my mn b">setInterval</code>开始)应被清除。这些只是JavaScript的基本实践，而不是黑客。</p><h1 id="5519" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">10.理解大O符号</h1><blockquote class="mz na nb"><p id="8005" class="kr ks lo kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated">“这是一个非常基本但被低估的话题😥。如果你学习了大O符号，那么你会很容易理解为什么你的一些函数运行得更快，为什么你的一些函数占用更少的内存。所以在钻研框架和其他高级东西之前，先学习这个基本的东西。”——鲁胡尔·阿明。</p></blockquote><p id="6499" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">什么！说真的！这根本不算是黑客。这甚至与JavaScript无关。首先，Big-O表示法只是一种表示<strong class="kt ir">时间复杂度</strong>的表示法。它们不是一回事。Big-O符号不会教你任何关于函数运行时的东西；它只是教导如何描述一个算法的运行时间。他的意思是<strong class="kt ir">时间复杂度</strong>。</p><p id="8162" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，任何上过数据结构或算法入门课的人都会知道时间复杂性；这同样适用于任何对算法研究很少的人。</p><p id="a8c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果我是一个自学成才的程序员呢？也许他应该教读者什么是Big-O和时间复杂性，而不是仅仅说要学习它们。此外，任何人都可以从逻辑上得出结论，将for循环放在for循环中会比使用单个for循环花费更长的时间。</p><p id="0085" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他只想完成“清单”上的第十项。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="3aa5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lo">如果你想要更多这样的内容，可以看看我的其他文章。</em></p><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-really-implement-the-sleep-function-in-javascript-621b4ed1e618"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">如何在JavaScript中真正实现sleep()函数</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">如何用JavaScript实现sleep()函数的指南(正确方法)。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kp ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://medium.com/@thesoggywaffle/no-the-end-of-javascript-is-not-here-776a0c92c501" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">不，JavaScript还没有结束</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">一个媒体作家如何因为自己一无所知的东西而毁掉自己的可信度。揭露谎言。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy kp ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/responding-to-the-hate-stop-using-for-loops-use-iterators-instead-eb2139c8ce51"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">回应仇恨:停止使用For循环，使用迭代器</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">一位评论者在评论中猛烈抨击了我在Medium上表现最好的文章。我会分解为什么我是对的，然后…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy kp ok"/></div></div></a></div><p id="08d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lo">更多内容看</em> <a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lo">说白了就是</em> </strong> </a> <em class="lo">。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lo">免费周报</em> </strong> </a> <em class="lo">。关注我们关于</em><a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lo">Twitter</em></strong></a><em class="lo">和</em><a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lo">LinkedIn</em></strong></a><em class="lo">。查看我们的</em> <a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lo">社区不和谐</em> </strong> </a> <em class="lo">加入我们的</em> <a class="ae ln" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lo">人才集体</em> </strong> </a> <em class="lo">。</em></p></div></div>    
</body>
</html>