<html>
<head>
<title>The Difference between Import, Export, and Require in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中导入、导出和要求的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-difference-between-import-export-and-require-in-javascript-e2680f553f5e?source=collection_archive---------6-----------------------#2022-05-03">https://javascript.plainenglish.io/the-difference-between-import-export-and-require-in-javascript-e2680f553f5e?source=collection_archive---------6-----------------------#2022-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9669b0fa6319661e339c41697eceffb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8v6HAyPLI_viWmyIOCnCw.png"/></div></div></figure><p id="f0a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能在JavaScript中看到过下面一行:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="18de" class="lc ld in ky b gy le lf l lg lh">const fs = <em class="li">require</em>('fs');</span></pre><p id="6525" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能已经看过这个了。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ba1e" class="lc ld in ky b gy le lf l lg lh">import fs from 'fs'</span></pre><p id="32a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更糟糕的是，你可能已经看到了这个:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="05a6" class="lc ld in ky b gy le lf l lg lh">import { promises as fs } from 'fs'</span></pre><p id="b655" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有这些意味着什么？！还有为什么JavaScript里看似导入包的方法那么多？为什么我不能在Node.js服务器上使用import？让我们探索一下这一切意味着什么。</p><h1 id="b98c" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">JavaScript中的导入、导出和要求</h1><p id="ee30" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">开箱即用，当您在Node.js中用JavaScript编写时，<code class="fe ml mm mn ky b">require()</code>非常好用。那是因为<code class="fe ml mm mn ky b">require</code>是专门为Node.js打造的。如果一个文件导出一些东西，那么require将会导入这个导出。假设我们有一个名为“general”的包，其中有一个<code class="fe ml mm mn ky b">index.js</code>文件，如下所示:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="dd50" class="lc ld in ky b gy le lf l lg lh">export.<em class="li">consoller</em> = function(msg) {<br/>    <em class="li">console</em>.<em class="li">log</em>(msg);<br/>}<br/>export.<em class="li">adder</em> = function(x, y) {<br/>    return x + y;<br/>}<br/>export.name = 'Some Name';</span></pre><p id="3005" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe ml mm mn ky b">export.[function]</code>的这种格式是NPM特有的。它是为了与NPM一起工作而构建的，也是Node.js的定制部分，不符合任何特定的标准。为了导入这些函数，我们可以很容易地使用require:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e5fe" class="lc ld in ky b gy le lf l lg lh">const general = <em class="li">require</em>('./general.js');</span></pre><p id="62df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在可以访问任何出口。在上面使用<code class="fe ml mm mn ky b">export.name</code>的例子中，我们现在可以通过代码中的<code class="fe ml mm mn ky b">general.name</code>来访问它。这是用Node.js添加包的最直接的方法之一。</p><p id="2a08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要记住的重要一点是，require和import是两个完全独立的功能。不要被我们用require导出代码的方式弄糊涂了！</p><h1 id="77f6" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用JavaScript导入</h1><p id="7a28" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">import和require的区别在于require是针对Node.js的，import是一个JavaScript/ECMAScript标准。Import使用稍微不同的符号，但是允许我们做与require大致相同的事情。</p><p id="dce0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">导入标准给了我们更多的灵活性，并且我们可以导入特定的功能。当与Webpack这样的捆绑器结合使用时，这被称为树抖动，允许我们只加载我们想要的JavaScript，而不是整个文件。首先，让我们看一个如何导出和导入函数的简单例子。</p><p id="208b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，假设我们有一个名为general.js的文件，这是我们的导出文件。让我们使用<code class="fe ml mm mn ky b">export</code>关键字导出一些函数。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a2f8" class="lc ld in ky b gy le lf l lg lh">const <em class="li">consoller</em> = function(msg) {<br/>    <em class="li">console</em>.<em class="li">log</em>(msg);<br/>}<br/>const <em class="li">adder</em> = function(x, y) {<br/>    return x + y;<br/>}<br/>const name = 'Some Name';</span><span id="fe16" class="lc ld in ky b gy mo lf l lg lh">export { consoller, adder, name }</span></pre><p id="5c04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在当我们导入时，我们只能导入这个模块的一部分。例如:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="dcbe" class="lc ld in ky b gy le lf l lg lh">import { consoller } from './general.js'</span></pre><p id="78a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们只需要引用<code class="fe ml mm mn ky b">consoller</code>，就可以引用为<code class="fe ml mm mn ky b">consoller()</code>。如果我们不希望这样，我们可以将consoller作为其他内容导入，例如:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ea79" class="lc ld in ky b gy le lf l lg lh">import { consoller as myFunction } from './general.js'<br/><em class="li">myFunction</em>() // Runs 'consoller'</span></pre><h1 id="9913" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在JavaScript中导入默认值</h1><p id="c8f5" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">如果在我们的导出文件中，我们命名了一个默认的导出，那么这个导出将会包含我们想要的任何内容。例如，假设我们做了以下事情:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="871a" class="lc ld in ky b gy le lf l lg lh">let functionList = {}</span><span id="dda2" class="lc ld in ky b gy mo lf l lg lh">functionList.<em class="li">consoller</em> = function(msg) {<br/>    <em class="li">console</em>.<em class="li">log</em>(msg);<br/>}<br/>functionList.<em class="li">adder</em> = function(x, y) {<br/>    return x + y;<br/>}<br/>functionList.name = 'Some Name';<br/>    <br/>export default functionList;</span></pre><p id="1ab6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我们导入时，我们可以导入functionList，并按照以下格式将其命名为我们喜欢的任何名称:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4c56" class="lc ld in ky b gy le lf l lg lh">javascript Copy</span><span id="096c" class="lc ld in ky b gy mo lf l lg lh">import myStuff from './general.js';<br/>myStuff.<em class="li">consoller</em>() // Our consoller function</span></pre><h1 id="da75" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">JavaScript中的Import *</h1><p id="7d57" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们可以做的另一件事是导入所有内容，并给它命名为其他内容。例如，我们可以这样做:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="5514" class="lc ld in ky b gy le lf l lg lh">import * as functionSet from './general.js';<br/>functionSet.<em class="li">consoller</em>(); // Runs our consoller function</span></pre><h1 id="82b0" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">为什么在Node.js中导入对我不起作用？</h1><p id="3f93" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">默认情况下没有启用导入，所以我们必须让Node.js知道我们正在使用它。确保至少安装了Node.js版本12。然后，我们需要更新我们的package.json。如果你没有，在命令行上运行你所在的文件夹中的<code class="fe ml mm mn ky b">npm init</code>。</p><p id="d529" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将package.json更改为具有行<code class="fe ml mm mn ky b">"module":"true"</code>，如下所示:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1d39" class="lc ld in ky b gy le lf l lg lh">// .....<br/>"name": "Fjolt",<br/>"type": "module", /* This is the line you need to add */<br/>"repository": {<br/>    "type": "git",<br/>    "url": "..."<br/>},<br/>"author": "",<br/>"license": "ISC",<br/>// .....</span></pre><p id="b0ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，默认情况下，模块将在Node.js目录中工作。不过有一个问题——那就是现在<code class="fe ml mm mn ky b">require()</code>不能工作了——所以在做这个改变之前，确保你已经完全转换到了<code class="fe ml mm mn ky b">import</code>。</p><h1 id="a80a" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="f33b" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">所以，require是一个定制的解决方案，而import/export是一个JavaScript标准。最初编写Require是因为import不存在，Node.js需要一种方法来轻松插入包。后来，负责JavaScript开发的小组提出了引进的建议。换句话说，Node.js想快速做一些事情，所以他们发明了自己的方法。</p><p id="e877" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了import(比要求更好、更充实)，如果可以的话，我会推荐使用它。因为它是一个标准，这意味着您可以在前端和后端开发中使用它，并且它将为您导入和导出您的包提供更多的选择。如果你在前端做任何事情，它也会限制文件大小，只导入你需要的东西！</p><p id="453b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="li">更多内容看</em> <a class="ae mp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="li">说白了就是</em> </strong> </a> <em class="li">。报名参加我们的</em> <a class="ae mp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="li">免费周报</em> </strong> </a> <em class="li">。关注我们关于</em><a class="ae mp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="li">Twitter</em></strong></a><em class="li">和</em><a class="ae mp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="li">LinkedIn</em></strong></a><em class="li">。加入我们的</em> <a class="ae mp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="li">社区</em> </strong> </a> <em class="li">。</em></p></div></div>    
</body>
</html>