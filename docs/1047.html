<html>
<head>
<title>Call by Value and Call by Reference in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按值调用和按角度引用调用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/call-by-value-and-call-by-reference-in-angular-59980f005e3e?source=collection_archive---------2-----------------------#2022-03-01">https://javascript.plainenglish.io/call-by-value-and-call-by-reference-in-angular-59980f005e3e?source=collection_archive---------2-----------------------#2022-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="de04" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用实际例子理解这些概念。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5d5b74d247c4e9d7ca4147b04a076883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QQG_IUnKcG42UE0X"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@magnetme?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Magnet.me</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="673e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将快速理解JavaScript中的流行概念<strong class="kv io">通过值调用</strong>和<strong class="kv io">通过引用调用</strong>。然后，我们将通过做一个练习，在角度框架中理解这个概念。</p><p id="bc47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，让我们了解一下原始数据类型和非原始数据类型的区别。根据<a class="ae ks" href="https://www.geeksforgeeks.org/primitive-and-non-primitive-data-types-in-javascript/" rel="noopener ugc nofollow" target="_blank"> GeeksforGeeks </a> -</p><p id="b5bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">原始数据类型</strong>—JavaScript语言提供的预定义数据类型称为原始数据类型。以下是JavaScript提供的基本数据类型——布尔、数字、字符串、符号、BigInt、null和undefined。</p><p id="daba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">非原始数据类型— </strong>源自JavaScript语言的原始数据类型的数据类型被称为非原始数据类型。它也称为派生数据类型或引用数据类型。非原始数据类型的例子有数组和对象。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="053c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们快速浏览一下JavaScript中通过值调用和通过引用调用的概念。</p><h2 id="779b" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak">通过JavaScript中的值调用</strong></h2><p id="f345" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">在函数调用期间，如果原始数据类型作为参数传递，则传递原始值的副本，该副本不引用原始值的内存位置。让我们用一个例子来理解这一点——</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="6af2" class="lw lx in mv b gy mz na l nb nc">let numOne = 5;</span><span id="8f56" class="lw lx in mv b gy nd na l nb nc">function modify(arg) {<br/>    arg = arg + 10<br/>}</span><span id="3da2" class="lw lx in mv b gy nd na l nb nc">modify(numOne);</span><span id="2125" class="lw lx in mv b gy nd na l nb nc">console.log(numOne);</span></pre><p id="c85a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="5d0b" class="lw lx in mv b gy mz na l nb nc">5</span></pre><p id="f843" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，我们可以看到变量<code class="fe ne nf ng mv b">numOne</code>在作为参数传递给函数<code class="fe ne nf ng mv b">modify</code>时没有被修改。</p><h2 id="569b" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak">在JavaScript中通过引用调用</strong></h2><p id="1bfb" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">在函数调用过程中，如果将非原始数据类型作为参数传递，则传递对该变量的引用。函数内部参数的任何修改都会反映在函数外部的变量中。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="c02b" class="lw lx in mv b gy mz na l nb nc">let arr = [0,1,2,3];</span><span id="edd1" class="lw lx in mv b gy nd na l nb nc">function modify(arg) {<br/>    arg[0] = 500;<br/>}</span><span id="d132" class="lw lx in mv b gy nd na l nb nc">modify(arr);</span><span id="c828" class="lw lx in mv b gy nd na l nb nc">console.log(arr);</span></pre><p id="fd2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="89d0" class="lw lx in mv b gy mz na l nb nc">[500,1,2,3]</span></pre></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="4c90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，是时候用Angular中的一个例子来理解这个概念了。</p><p id="c171" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们将通过值来理解<strong class="kv io">调用。为此，我们需要创建一个角度项目。我们将转到<strong class="kv io"><em class="nh">app . component . ts</em></strong>文件，并将编写以下内容-</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d523" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们运行这个应用程序时，我们将在控制台中看到以下输出。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="7eb4" class="lw lx in mv b gy mz na l nb nc">I am a primitive data.</span></pre><p id="e3d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们可以得出结论，即使原始数据类型的参数在方法内部被修改，原始属性(即<code class="fe ne nf ng mv b">primitiveData</code>)也不会被修改。</p><p id="0dcb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们通过引用来理解<strong class="kv io">调用。为此，我们将在<strong class="kv io"><em class="nh">app . component . ts</em></strong>和<strong class="kv io"><em class="nh">app.component.html</em></strong>文件中编写以下代码。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="919c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">运行应用程序后，我们将在浏览器中看到以下内容—</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/05a73b04afa722a9f51e73ab0d0344e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vV0_WmvcDfmLS_skgiO7CQ.png"/></div></div></figure><p id="1d3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">点击按钮后，“火星”将被添加到列表中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/dd3ec335a0b9c966e09d9bbb6f0c5f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*R6zmN7I_36BcuYeKfu1u2g.png"/></div></figure><p id="efdd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在代码中，<code class="fe ne nf ng mv b">modifyNonPrimativeData</code>方法通过将一个元素推入数组来修改其参数<code class="fe ne nf ng mv b">arg</code>，这反映在原始属性<code class="fe ne nf ng mv b">nonPrimitiveData</code>中。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="10cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们理解当使用<code class="fe ne nf ng mv b">@Input()</code> decorator将来自父组件的对象/数组传递给子组件时，如果我们在子组件中修改该对象/数组，会发生什么。为此，我们的角度项目结构如下—</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/896c13127acb0a2e7b24968f748ef41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*uLnGyO9AWV-2GuWxZNUDww.png"/></div></figure><p id="6a60" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将在<strong class="kv io"> <em class="nh"> app.component.ts </em> </strong>和<strong class="kv io"><em class="nh">app.component.html</em></strong>文件中编写以下代码，这是我们的父组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8a45" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">子组件将包含以下代码—</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="03af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">运行应用程序后，我们将在浏览器中看到以下内容—</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/937243060a4c9341d2a4f04375dde4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*B5PtvgPAjbt87uwySMyZ1Q.png"/></div></div></figure><p id="f36e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">点击<code class="fe ne nf ng mv b">Modify Hobby</code>按钮，我们会看到<code class="fe ne nf ng mv b"><strong class="kv io">Hobby</strong></code>在子组件和父组件中都发生了变化。这是因为我们将非原始数据的引用传递给了子组件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/0909dc28db577129af8d55531f93d347.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*oG1PFCOt6Cj1XTmHoyk8ng.png"/></div></figure><p id="0e47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，如果我们将原始数据从父组件传递到子组件，并且如果我们在子组件中修改该数据，那么它将只在子组件中得到反映，而不会在父组件中得到反映。这是因为我们将原始数据的副本传递给了子组件。</p><h2 id="0e58" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">参考</h2><ol class=""><li id="0043" class="np nq in kv b kw mp kz mq lc nr lg ns lk nt lo nu nv nw nx bi translated">JavaScript中的原始和非原始数据类型(GeeksforGeeks)</li></ol><div class="ny nz gp gr oa ob"><a href="https://www.geeksforgeeks.org/primitive-and-non-primitive-data-types-in-javascript/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">JavaScript中的原始和非原始数据类型</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">极客的计算机科学门户。它包含写得很好，很好的思想和很好的解释计算机科学和…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ok l"><div class="ol l om on oo ok op km ob"/></div></div></a></div><p id="e576" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nh">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">plain English . io</em></strong></a><em class="nh">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nh">免费周报</em> </strong> </a> <em class="nh">。关注我们关于</em><strong class="kv io"><em class="nh"/></strong><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">推特</em> </strong> </a> <em class="nh">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">LinkedIn</em></strong></a><em class="nh">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nh">社区</em> </strong> </a> <em class="nh">。</em></p></div></div>    
</body>
</html>