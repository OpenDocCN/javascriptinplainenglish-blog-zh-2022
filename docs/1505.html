<html>
<head>
<title>An Introduction to Next.js for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的Next.js介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-to-know-next-js-c52cc4df5a08?source=collection_archive---------12-----------------------#2022-03-29">https://javascript.plainenglish.io/getting-to-know-next-js-c52cc4df5a08?source=collection_archive---------12-----------------------#2022-03-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c835" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">熟悉Next.js</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fbc70ebd2d76bc2e68e24fbfe0b5c0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kce1FVhfqyiUF1JY.png"/></div></div></figure><p id="7ebb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您使用React已经有一段时间了，那么您会知道在创建由搜索引擎索引的项目时存在困难。在这种情况下出现了Next.js，它是一个框架，与Node.js中前端和后端之间的中间层一起工作。</p><h2 id="ef81" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">React + Node.js = Next.js</h2><p id="6986" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">如果你已经编程很长时间了，你可能还记得我们用PHP或者。Net中，每个页面都是在服务器端构建并返回给客户端的。Next.js以类似的方式工作，页面通过运行在中间层的Node.js服务器呈现并传递给已经组装好的前端。这种功能被称为SSR(服务器端呈现)，它允许我们将页面中的所有数据一次返回到前端(React ),搜索引擎将能够读取包含所有内容的页面。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/458dbcd84ec36220264ae9dcfe95ba61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/0*D5yRD11lNbL1msJx.png"/></div></figure><p id="723a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">除了SSR之外，Next.js还允许您使用SSG(静态站点生成)创建项目，这是可以随时更新的静态页面。</p><p id="9c2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">值得指出的是，Next.js并没有消除任何灵活性，也没有添加更多我们已经知道的东西来进行反应，因此它的使用不会影响您现有的项目，您仍然可以继续构建您的SPA项目(单页应用程序)，但是您将拥有SSR和SSG的优势。</p><h2 id="0939" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">Next.js为React添加的特性</h2><p id="f330" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在进入SSR和SSG的细节之前，我们应该注意到Next.js有一些其他的功能被添加到React中。</p><ul class=""><li id="1c6f" class="mj mk in kq b kr ks ku kv kx ml lb mm lf mn lj mo mp mq mr bi translated">热代码重新加载:正在开发的项目中的代码变化被实时地自动传输到本地应用程序。</li><li id="8988" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">自动代码分割:该功能只允许页面的某些部分根据它们需要的包来呈现。</li><li id="0723" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">自动路由:我们不需要配置来路由应用程序中的页面，URL是基于pages文件夹进行映射的，因此该文件夹中的一个文件将成为一个路由，如果需要的话，可以对其进行定制。</li><li id="5de4" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">国际化:您可以使用国际化将页面实时翻译成不同的语言。</li><li id="7bf4" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">TypeScript支持:Next.js支持TypeScript，如果您不知道它是什么，请单击此处查看有关该主题的文章。</li><li id="bba2" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">CSS模块:我们可以模块化我们的CSS，这样一个页面的CSS就不会干扰另一个页面。</li><li id="12ff" class="mj mk in kq b kr ms ku mt kx mu lb mv lf mw lj mo mp mq mr bi translated">图像优化:Next有一个用于图像优化的组件。</li></ul><h2 id="78a7" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">服务器端渲染</h2><p id="570d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">SSR提供了一种不同的策略，不同于通常使用的从API消费数据的策略，我们通常使用useEffect。这里的要点是，当使用useEffect时，数据不会在页面呈现给浏览器的那一刻被加载，因此搜索引擎将无法索引API返回的信息。</p><p id="d98c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种策略被称为客户端获取，并且应该在不需要搜索引擎对数据进行索引时使用。您可以通过在浏览器中禁用javascript来验证这一点，您会看到来自API的内容将不会被加载。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="597e" class="lk ll in my b gy nc nd l ne nf">import React, { useEffect, useState } from 'react';<br/> <br/>import api from '../service/api';<br/> <br/>interface ICategories {<br/>    id: number;<br/>    name: string;<br/>}<br/> <br/>export default function Categories() {<br/>    const [categories, setCategories] = useState&lt;ICategories[]&gt;([]);<br/> <br/>    // Chamada à API com Client Side Fetching<br/>    useEffect(() =&gt; {<br/>        api.get('&lt;http://localhost:3333/categories&gt;').then(response =&gt; {<br/>          setCategories(response.data);<br/>        })<br/>    }, []);<br/> <br/>    return (<br/>        &lt;div&gt;<br/>          &lt;h1&gt;Categories&lt;/h1&gt;<br/>        <br/>          &lt;section&gt;<br/>            &lt;ul&gt;<br/>              {categories.map(category =&gt; {<br/>                  return (<br/>                      &lt;li key={category.id}&gt;<br/>                        {category.name}<br/>                      &lt;/li&gt;<br/>                    )<br/>                })}<br/>            &lt;/ul&gt;<br/>          &lt;/section&gt;<br/>        &lt;/div&gt;<br/>      )<br/>}</span></pre><p id="b93d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了解决这个问题，我们使用了SSR，这是使Next.js如此出名的特性。在这里，我们将useEffect放在一边，使用一个名为getserverseadprops的函数，该函数的类型为getserverseadprops。接下来，js将返回带有该函数结果的预先呈现的页面，可以通过必须预先键入以便于访问的属性来访问该函数的返回。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="6ee2" class="lk ll in my b gy nc nd l ne nf">import { GetServerSideProps } from 'next';<br/>interface ICategories {<br/>    id: number;<br/>    name: string;<br/>}<br/>interface CategoryProps {<br/>  categories: ICategories[];<br/>}<br/>export const getServerSideProps: GetServerSideProps&lt;CategoryProps&gt; = async() =&gt; {<br/>  const response = await api.get('&lt;http://localhost:3333/categories&gt;');<br/>  const categories = await response.data;<br/> <br/>  return {<br/>    props: {<br/>      categories<br/>    }<br/>  }<br/>}<br/>export default function Home({ categories }: CategoryProps) {<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Categories&lt;/h1&gt;<br/>      <br/>        &lt;section&gt;<br/>          &lt;ul&gt;<br/>              {categories.map(category =&gt; {<br/>                  return(<br/>                      &lt;li key={category.id}&gt;<br/>                        {category.name}<br/>                      &lt;/li&gt;<br/>                    )<br/>                })}<br/>            &lt;/ul&gt;<br/>        &lt;/section&gt;<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="5e87" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过服务器端渲染，我们解决了搜索引擎索引的问题，但我必须指出，这是有成本的，并且只有当搜索引擎索引信息时，才应该使用该资源。</p><h2 id="440d" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">静态站点生成</h2><p id="5a49" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">以博客或电子商务为例，这些页面总是向用户呈现相同的内容，并且更新频率很低。在这种情况下，Next.js引入了静态站点生成，在这里我们有一个静态页面，它不会不断更新，而且当以这种方式提供页面时，我们有非常高的性能增益。</p><p id="9b6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了创建一个具有这种功能的页面，我们使用了GetStaticProps，这与在SSR中使用的GetServerSideProps非常相似，但是这里有一个重要的细节。我们必须通过一个名为<strong class="kq io">重新验证</strong>的属性，在几秒钟内向函数指示内容何时应该更新。</p><p id="fc12" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的代码中可以看到如何在相同的类别示例中使用GetStaticProps，更新时间为60秒:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="82bb" class="lk ll in my b gy nc nd l ne nf">import { GetStaticProps } from 'next';<br/>interface ICategories {<br/>    id: number;<br/>    name: string;<br/>}<br/>interface CategoryProps {<br/>  categories: ICategories[];<br/>}<br/>export const getStaticProps: GetStaticProps&lt;CategoryProps&gt; = async () =&gt; {<br/>  const response = await api.get('&lt;http://localhost:3333/categories&gt;');<br/>  const categories = await response.data;<br/>	 <br/>  return {<br/>    props: {<br/>      categories<br/>    },<br/>		revalidate: 60,<br/>  }<br/>}<br/>export default function Home({ categories }: CategoryProps) {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Categories&lt;/h1&gt;<br/>      <br/>        &lt;section&gt;<br/>          &lt;ul&gt;<br/>              {categories.map(category =&gt; {<br/>                  return (<br/>                      &lt;li key={category.id}&gt;<br/>                        {category.name}<br/>                      &lt;/li&gt;<br/>                    )<br/>                })}<br/>            &lt;/ul&gt;<br/>        &lt;/section&gt;<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><h2 id="e990" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">结论</h2><p id="eb35" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">因此，Next.js是一个集合，允许我们同时拥有SPA、SSR和SSG项目。但是，我们必须仔细评估在我们的项目中使用每个函数的位置，因为它用途广泛且易于学习，因为它被用于许多项目中。</p><p id="2547" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我希望这篇文章对你有用，如果你喜欢它，和你的朋友分享它，不要忘记访问博客上的其他内容。</p><p id="bf08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">参考文献:</p><div class="ng nh gp gr ni nj"><a href="https://nextjs.org/docs/getting-started" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">开始|下一步. js</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">欢迎使用Next.js文档！如果您刚接触Next.js，我们建议您从学习课程开始。…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">nextjs.org</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx km nj"/></div></div></a></div><p id="6a15" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ny">更多内容请看</em><a class="ae nz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ny">plain English . io</em></strong></a><em class="ny">。报名参加我们的</em> <a class="ae nz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em><a class="ae nz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ny">Twitter</em></strong></a><em class="ny">和</em><strong class="kq io"><em class="ny"/></strong><a class="ae nz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ny">LinkedIn</em></strong></a><em class="ny">。加入我们的</em> <a class="ae nz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ny">社区</em> </strong> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>