<html>
<head>
<title>Next.js Server-Side Rendering Practical Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js服务器端渲染实例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-server-side-rendering-practical-example-23f9345722c6?source=collection_archive---------5-----------------------#2022-06-27">https://javascript.plainenglish.io/next-js-server-side-rendering-practical-example-23f9345722c6?source=collection_archive---------5-----------------------#2022-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f643" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用一个实际例子探索Next.js服务器端呈现。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b363b688bc83ce6d4f0e6c5132af13d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3s7PBH-LGaIglfPhFOAeig.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Server-Side Rendering</figcaption></figure><p id="f2f8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">你好，我的名字是Igor，如果你碰巧喜欢我写的东西，你可能也喜欢我在</em> <a class="ae lp" href="https://www.twitter.com/igorasilveira" rel="noopener ugc nofollow" target="_blank"> <em class="lo">我的Twitter个人资料</em> </a> <em class="lo">上说的话，来打个招呼吧！👋。</em></p><p id="498d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">本文是我整理的整个Next.js系列文章的一部分，旨在帮助您成为Next.js专业人士，并构建速度极快的React应用程序。</p><p id="8bc3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">💡如果你不想错过任何教程，请点击<a class="ae lp" href="https://www.getrevue.co/profile/igorasilveira" rel="noopener ugc nofollow" target="_blank">此处</a>注册我的时事通讯，或前往<a class="ae lp" href="https://dailydev.io/" rel="noopener ugc nofollow" target="_blank"> DailyDev.io </a>获取更多信息。</p><p id="91b6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个问题上，我们将讨论Next.js服务器端渲染，补充上一个关于预渲染主题的视频。</p><p id="943e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">💡你可以在这里找到这个项目<a class="ae lp" href="https://github.com/igorasilveira/blog-examples/tree/main/nextjs-server-side-rendering" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><p id="5dfc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以让我们开始吧！</p><p id="aec9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在继续更好地理解我们将在这里做什么之前，请务必查看我以前在<em class="lo"> Next.js pages </em>、<em class="lo">动态路由、</em>和<em class="lo">静态站点生成</em>上的文章。</p><h1 id="d270" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">快速回顾</h1><p id="989c" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">上一次我们在这里介绍了预呈现的概念，这是Next.js用来呈现页面的默认方法，通过为客户端提供预构建的HTML文件和必要的JavaScript文件，从而为客户端带来更好的性能和更少的工作量。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/315182d7ae69aa9e9651c2ce430a67d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FKIHA7q8Rm9Yrwkq"/></div></div></figure><p id="b69e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们讨论了Next.js提出了两种主要的预呈现方式:静态站点生成和服务器端呈现。那一次，我们讨论了前者，并更新了我们即将推出的狗搜索应用程序，以获得Next.js功能的好处，在这一次，我们将学习一些新的东西。</p><h1 id="47bc" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">服务器端渲染</h1><p id="6ab8" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">服务器端呈现与静态站点生成的工作原理相同，其目标是为客户端提供一个预先构建的静态HTML页面，该页面由服务器预先呈现，然后由捆绑的JavaScript文件进行处理，将页面恢复到其真正的交互状态。</p><p id="25e4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">Next.js附带的这两种预呈现方法的主要区别在于页面的HTML是何时预呈现的。</p><p id="9cf5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">运行<code class="fe mo mp mq mr b">next build</code>命令时，静态站点生成的页面会在构建时预先呈现。这是一个生成并遗忘它们的例子，直到需要一个新的构建来反映新的变化。</p><p id="7ad0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是，在服务器端生成的页面上，页面的HTML是在每次请求服务器时生成的。这意味着在应用程序的生命周期中，同一个页面会呈现多次。请求多少就有多少(除非我们使用<em class="lo">缓存</em>，稍后会详细介绍)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/3d34d114007394af6b9d4448ee2d4931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jhuRloqTcqdcZV-b"/></div></div></figure><p id="9959" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如您所见，服务器端呈现的页面性能不如静态生成的页面，并且不能存储在CDN上以实现更快的全局访问。</p><p id="b157" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，有时服务器端呈现可能是唯一的选择。在创建页面时，您可能会考虑使用服务器端呈现而不是静态站点生成，主要原因是该页面需要预先呈现频繁更新的数据，这些数据必须从一些外部数据源获取，因此不能在构建时静态生成，因为它需要始终保持最新。</p><h1 id="173e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">如何使用它</h1><p id="9116" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">除非我们指定一个页面要么在服务器端呈现，要么用数据静态呈现(查看上一篇文章)，否则Next.js将无法区分这两者。</p><p id="d162" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了做到这一点，Next.js允许我们在页面的组件中定义特定的方法，然后评估每个页面是在构建时还是在每次请求时预呈现。</p><p id="cbc8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">之前，我们讨论了特定于静态站点生成的方法，这与服务器端呈现没有什么不同。</p><p id="c659" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了对页面使用服务器端呈现，我们从页面的React组件中导出一个名为<code class="fe mo mp mq mr b">getServerSideProps</code>的<code class="fe mo mp mq mr b">async</code>函数。这是Next.js服务器在每次请求该页面时将调用的函数。</p><p id="5a7e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个函数将通过它的<code class="fe mo mp mq mr b">props</code>把我们想要的任何数据输入到我们的页面组件中，通过一个非常具体的返回类型。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c434" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就这样，我们的页面变成了服务器端呈现的，并且每次被请求时都会更新！😎</p><h1 id="a8dc" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">更新我们的狗应用程序</h1><p id="ee17" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">现在让我们在Doggo应用程序中创建一个服务器端渲染页面来看看它的运行。</p><p id="eb0a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">出于本教程的目的，我们将创建一个页面，该页面将显示一个dog carousel，每次我们请求该页面时，它的数据都将来自服务器。</p><p id="7796" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">💡注意:如果你没有关注Doggo应用的创建，你可以检查这个GitHub库并修改它。</p><h1 id="34ce" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">创建我们的新页面</h1><p id="5f30" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">让我们在<code class="fe mo mp mq mr b">/pages/dogs</code>目录下创建一个名为<code class="fe mo mp mq mr b">carousel.tsx</code>的新文件。</p><p id="988b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">导出一个名为<code class="fe mo mp mq mr b">Carousel</code>的新React组件，它将接收一个<code class="fe mo mp mq mr b">data</code>对象作为组件<code class="fe mo mp mq mr b">props</code>，这些组件是用上一篇文章中创建的狗<code class="fe mo mp mq mr b">interface</code>的<code class="fe mo mp mq mr b">array</code>类型化的(检查<code class="fe mo mp mq mr b">/definitions/dogs.d.ts</code>)。</p><p id="505d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在其中呈现一些HTML，您的组件应该如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="601d" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">使其在服务器端呈现</h1><p id="d1e5" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">现在让我们添加一个神奇的函数，让它成为一个服务器端呈现的页面，<code class="fe mo mp mq mr b">getServerSideProps</code>函数。</p><p id="eba1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个函数将获取我们的内存数据库中的所有狗，这些狗是我们作为导出<code class="fe mo mp mq mr b">array</code>的类型脚本文件创建的(检查<code class="fe mo mp mq mr b">/db/dogs.ts</code>，我们还为本教程添加了一些条目)，并将它们作为随机排序的列表返回，以便我们新创建的组件可以使用它来创建“频繁”更新的carousel。</p><p id="0e40" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">💡请记住，在真实的场景中，这将是一个外部API调用，可能会处理更多的逻辑来生成所需的数据。但是出于本教程的目的，我们将简化这个过程，以便专注于手头的主题，服务器端渲染。</p><p id="f6f2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们的函数应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="3cf3" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">呈现数据</h1><p id="4505" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">既然我们的组件已经接收了数据，我们就可以接受它并对它做任何我们想做的事情。</p><p id="0f7b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我将创建一个两列的<code class="fe mo mp mq mr b">grid</code>，在里面，我们遍历我们的<code class="fe mo mp mq mr b">data</code>道具(我们知道是一个<code class="fe mo mp mq mr b">Dog</code>)上的每一个物品，并在屏幕上呈现它们的名称和描述。当然，我们也添加了一些CSS，这样就不会变成HTML的混乱。😉</p><p id="8481" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">也许是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="2d97" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">决赛成绩</h1><p id="d5df" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">所以到最后，可以在<code class="fe mo mp mq mr b">/dogs/carousel</code>下找到的页面应该看起来像这样，并且每次我们请求它时都用服务器获取的数据进行更新。酷！😎</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/6ea366472f3e7194c3f4499f0ae85138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wppGGkSEiA3SDFV1"/></div></div></figure><h1 id="c929" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">结束语</h1><p id="5b1c" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">要体验静态站点生成和服务器端呈现之间的差异，不要忘记运行build命令(<code class="fe mo mp mq mr b">npm run build</code>)，然后运行serving ( <code class="fe mo mp mq mr b">npm run start</code>)生成的文件。这就是页面在生产环境中的服务方式，并由某个CDN进行缓存。</p><p id="fe01" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">以<code class="fe mo mp mq mr b">npm run dev</code>模式运行项目将总是在每个请求上构建所有页面，在所有请求上运行所有特定的预渲染功能。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/f518c3a9b29fc986ba3ea1c0b5bdbf89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2-bkWNmKBPp1o6Db"/></div></div></figure><p id="2007" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">注意Next.js是如何检测哪些页面是静态的或服务器端呈现的。</p><p id="6141" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你遇到任何麻烦，请随时在Twitter上联系我，我的DMs永远是开放的。</p><p id="394b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下一步:请关注我接下来的Next.js教程，我们将在Next.js领域进行更多的讨论！如果你不想错过任何教程，点击这里注册我的时事通讯。</p><p id="4bb5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">更多内容看</em> <a class="ae lp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lo">说白了。报名参加我们的</em> <a class="ae lp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lo">免费周报</em> </strong> </a> <em class="lo">。关注我们关于</em><a class="ae lp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">Twitter</em></strong></a><em class="lo">和</em><a class="ae lp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">LinkedIn</em></strong></a><em class="lo">。查看我们的</em> <a class="ae lp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lo">社区不和谐</em> </strong> </a> <em class="lo">，加入我们的</em> <a class="ae lp" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lo">人才集体</em> </strong> </a> <em class="lo">。</em></strong></a></p></div></div>    
</body>
</html>