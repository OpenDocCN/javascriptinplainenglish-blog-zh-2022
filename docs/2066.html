<html>
<head>
<title>How the TypeScript ReturnType Type works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript ReturnType类型如何工作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-the-typescript-returntype-type-works-238a6e201806?source=collection_archive---------5-----------------------#2022-05-11">https://javascript.plainenglish.io/how-the-typescript-returntype-type-works-238a6e201806?source=collection_archive---------5-----------------------#2022-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f492e48f9bfa2ff385e220e9642dc5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPEU8KicPgMsbxtf20pB-A.png"/></div></div></figure><p id="fca2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TypeScript中的<code class="fe kt ku kv kw b">ReturnType</code>是一个实用程序类型，与<a class="ae kx" href="https://fjolt.com/article/typescript-parameters-utility-type" rel="noopener ugc nofollow" target="_blank">参数类型</a>非常相似。它让你获取一个函数的返回输出，并基于它构造一个类型。</p><h1 id="0809" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">ReturnType实用程序类型</h1><p id="8aa7" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">在特定函数的输出需要被另一个函数接收的情况下,<code class="fe kt ku kv kw b">ReturnType</code>实用程序类型非常有用。在这种情况下，您可能会创建一个新的自定义类型，函数的输出会将其自身约束到该类型。</p><p id="b07f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看一个愚蠢的例子。下面，我们定义一个新的类型，它有两个属性，<code class="fe kt ku kv kw b">a</code>和<code class="fe kt ku kv kw b">b</code>，都是数字。然后一个函数将这个对象上的所有数字转换成字符串，并返回一个新的类型。我们定义了一个自定义类型，叫做<code class="fe kt ku kv kw b">Data</code>，它期望<code class="fe kt ku kv kw b">a</code>和<code class="fe kt ku kv kw b">b</code>是字符串。</p><pre class="mb mc md me gt mf kw mg mh aw mi bi"><span id="dd64" class="mj kz in kw b gy mk ml l mm mn">function sendData(a: number, b: number) {<br/>    return {<br/>        a: `${a}`,<br/>        b: `${b}`<br/>    }<br/>}</span><span id="9de9" class="mj kz in kw b gy mo ml l mm mn">type Data = {<br/>    a: string,<br/>    b: string<br/>}</span><span id="72b8" class="mj kz in kw b gy mo ml l mm mn">function consoleData(data:Data) {<br/>    console.log(JSON.stringify(data));<br/>}</span><span id="2fe0" class="mj kz in kw b gy mo ml l mm mn">let stringifyNumbers = sendData(1, 2);<br/>consoleData(stringifyNumbers);</span></pre><p id="cdd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<code class="fe kt ku kv kw b">consoleData</code>期望数据的格式为<code class="fe kt ku kv kw b">Data</code>，如果<code class="fe kt ku kv kw b">a</code>或<code class="fe kt ku kv kw b">b</code>为数字，TypeScript将抛出错误。我们的<code class="fe kt ku kv kw b">sendData</code>函数通过将<code class="fe kt ku kv kw b">a</code>和<code class="fe kt ku kv kw b">b</code>转换成字符串来解决这个问题。</p><p id="a7be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种设置的问题是，如果我们添加或更改了<code class="fe kt ku kv kw b">sendData</code>或我们的输入数据，那么<code class="fe kt ku kv kw b">Data</code>也需要更新。这没什么大不了的，但是很容易产生bug。因此，我们可以使用<code class="fe kt ku kv kw b">ReturnType</code>来简化我们的类型声明。我们的<code class="fe kt ku kv kw b">Data</code>型可以这样写:</p><pre class="mb mc md me gt mf kw mg mh aw mi bi"><span id="7c14" class="mj kz in kw b gy mk ml l mm mn">function sendData(a: number, b: number) {<br/>    return {<br/>        a: `${a}`,<br/>        b: `${b}`<br/>    }<br/>}<br/>type Data = ReturnType&lt;typeof sendData&gt;<br/>// The same as writing:<br/>// type Data = {<br/>//     a: string,<br/>//     b: string<br/>// }</span></pre><p id="2768" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<code class="fe kt ku kv kw b">sendData</code>返回类型<code class="fe kt ku kv kw b">{ a: string, b: string }</code>中的数据，<code class="fe kt ku kv kw b">Data</code>成为该类型。这意味着我们不必维护来自<code class="fe kt ku kv kw b">sendData</code>的输出的两个副本——相反，我们有一个，在函数内部，和一个符合那个的类型，简化了我们的代码。</p><p id="3f00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mp">更多内容请看</em><a class="ae kx" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mp">plain English . io</em></strong></a><em class="mp">。报名参加我们的</em> <a class="ae kx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mp">免费周报</em> </strong> </a> <em class="mp">。关注我们关于</em><a class="ae kx" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mp">Twitter</em></strong></a><em class="mp">和</em><a class="ae kx" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mp">LinkedIn</em></strong></a><em class="mp">。加入我们的</em> <a class="ae kx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mp">社区不和谐</em> </strong> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>