<html>
<head>
<title>Correcting Medium Writers: Some Basic Coding Challenges in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更正媒体作者:JavaScript中的一些基本编码挑战</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/correcting-medium-writers-some-basic-coding-challenges-in-javascript-ba86aab5c8f2?source=collection_archive---------8-----------------------#2022-07-03">https://javascript.plainenglish.io/correcting-medium-writers-some-basic-coding-challenges-in-javascript-ba86aab5c8f2?source=collection_archive---------8-----------------------#2022-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="88ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当一个作者创作了一篇没有“挑战”的文章，却不能解决它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1ae18ac0115b81560ede618d3e749395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrAQENJZsyqHHCTTUgKu6A.png"/></div></div></figure><p id="718d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">刚看完一篇文章，<a class="ae ln" href="https://medium.com/javascript-in-plain-english/some-basic-coding-challenges-in-javascript-1270492687e7" rel="noopener"><em class="lo">JavaScript中的一些基本编码挑战</em> </a> <em class="lo">，</em>作者Ravi Sharma。我想纠正他清单上的每一项。本文涵盖了基本的JavaScript“挑战”——甚至不是挑战。然而，代码示例是有缺陷的。不过别担心，我是来纠正拉维的。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="6409" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你读了我在Medium上的文章，你会知道我发布了三种类型的文章:</p><ol class=""><li id="e629" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm mb mc md me bi translated">编程指南、提示和技巧、建议和教程</li><li id="928d" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm mb mc md me bi translated">新闻和新的JavaScript内容</li><li id="2048" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm mb mc md me bi translated"><strong class="kt ir">我最喜欢的:纠正媒体上的其他作者，并指出他们为什么错了</strong></li></ol><p id="eccf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我最喜欢的文章是我指出其他作家文章中的缺陷的地方。这通常是因为他们要么对所写的主题一无所知(糟糕的程序员)，要么就是大错特错……但有时，他们只是没有在写作中投入足够的思考。</p><p id="ebd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我正在创作一个系列，名为<em class="lo">纠正媒体作者</em>。开始了。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="a166" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated"><strong class="ak"> 1。创建自定义映射函数的程序。</strong></h1><h2 id="65e5" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🧐·拉维的密码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e28db39b15f573fffd905e0bee32a5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjTXc1mktUx-lqXkPFcT5w.png"/></div></div></figure><h2 id="a3c8" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🧇我的代码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/b4cac95a7af217b01e38dfdf0944f6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-D_4-esb74UHCQbTT1CZKA.png"/></div></div></figure><h2 id="4a2a" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">👀运行时演示</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/717bf51ee3db45824ccc2492c04027ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WHJj69w8Ofxo-rWVhVtwzw.gif"/></div></div></figure><h2 id="1d3d" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🙋‍♂️问题？</h2><ul class=""><li id="ec60" class="lw lx iq kt b ku nq kx nr la ns le nt li nu lm nv mc md me bi translated"><strong class="kt ir">第2行</strong> : <em class="lo">拉维的</em> <em class="lo">代码</em>初始化一个空数组。每次添加新元素时，JavaScript都必须重新分配数组。我的代码初始化一个正确长度的数组，并预分配所有的内存。</li><li id="56dc" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">4号线(我的5号线):</strong> <em class="lo">拉维的代码</em>反复调用<code class="fe nw nx ny nz b">push</code>。调用函数会增加不必要的开销(增加调用堆栈并重新分配数组)。我的代码把值赋给一个已经被分配的索引。</li></ul><p id="a887" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">但是华夫方式对100万个元素只节省40毫秒！嗯，在这个演示中，我们正在执行一个简单的算术运算。计算机用简单的乘法运算非常快，尤其是用2的幂。假设您想将一个整数数组转换成一个对象集合(反之亦然)。这将转化为秒，有时是分钟。</strong></p><h1 id="9e63" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated"><strong class="ak"> 2。创建自定义过滤函数的程序。</strong></h1><h2 id="f640" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🧐·拉维的密码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/65d8a7348a2d9c5952427ca37edae13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JG526CUEXMOHxvLYYLnVlw.png"/></div></div></figure><h2 id="1396" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🧇我的代码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e0227533471b5feb7cf55661d09ad1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xB9zYKy0DJlTrCKzYoPqxA.png"/></div></div></figure><h2 id="a7fe" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">👀运行时演示</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/132b3181f9a7922155d50dcb1214a468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8IOo1ZAoYPbSc0nAw2yhpQ.gif"/></div></div></figure><h2 id="aa2a" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🙋‍♂️问题？</h2><ul class=""><li id="8461" class="lw lx iq kt b ku nq kx nr la ns le nt li nu lm nv mc md me bi translated"><strong class="kt ir">第2行</strong> : <em class="lo"> Ravi的代码</em>初始化一个空数组——同样，这需要大量的重新分配。我的代码用最大可能的索引初始化一个数组。这在<code class="fe nw nx ny nz b">for</code>循环中节省了时间。</li><li id="9772" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">第3/4行(我的代码):</strong>因为我不使用<code class="fe nw nx ny nz b">push</code>，所以跟踪索引是必要的。另外，我创建了一个<code class="fe nw nx ny nz b">val</code>变量来存储当前值。</li><li id="46a3" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">第6行(我的代码)</strong>:我把当前值赋给<code class="fe nw nx ny nz b">val</code>。为什么？因为我们要引用<code class="fe nw nx ny nz b">this[index]</code>。在幕后，JavaScript使用本机<code class="fe nw nx ny nz b">getters</code>执行一些额外的代码来检索这个值。⚠️这种方法的效果很小，也无所谓。</li><li id="5e0f" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">第4行(我的第7行):</strong> <em class="lo">拉维的代码</em>用了一个巧妙的JS招数。<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/the-7-false-like-values-of-javascript-and-typescript-93df73bda44">我写过一篇关于JavaScript/TypeScript中“falsy”值的文章</a>。<code class="fe nw nx ny nz b">null</code>、<code class="fe nw nx ny nz b">undefined</code>、<code class="fe nw nx ny nz b">''</code>(空串)、<code class="fe nw nx ny nz b">0</code>、<code class="fe nw nx ny nz b">void</code>、<code class="fe nw nx ny nz b">NaN</code>为falsy值。如果回调返回一个falsy值，<em class="lo"> Ravi的代码</em>使用<code class="fe nw nx ny nz b">!</code>将其转换为相反的布尔值。然后再次使用求反运算符将其转换回原始值(但作为布尔值)。所以<code class="fe nw nx ny nz b">!!0 = false</code>和<code class="fe nw nx ny nz b">!!true = true</code>和<code class="fe nw nx ny nz b">!!undefined = false</code>。<em class="lo">我的代码</em>不会浪费时间将假值或真值转换成布尔值，因为<code class="fe nw nx ny nz b">if</code>语句已经将它们视为布尔值。</li><li id="bd3d" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">第5行(我的第8行):</strong>还是那句话，我直接把值赋给正确的索引，而不是调用一个浪费时间的函数。在这个操作中，我还在递增当前索引时添加了增量<code class="fe nw nx ny nz b">curr</code>后缀以节省时间。</li><li id="bce5" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">第11行(我的代码):</strong>我通过改变集合的<code class="fe nw nx ny nz b">length</code>来截断数组中没有被填充的部分。这将自动删除以下所有索引。</li></ul><p id="5e2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">但是5.5毫秒跨越100万个元素不算什么！</strong>这再次展示了<code class="fe nw nx ny nz b">filter</code>在立即返回的箭头函数中使用基本算术。想象一下使用字符串操作过滤大型对象、字符串或大多数其他情况。您通常不会只过滤整数。</p><h1 id="cd2f" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated"><strong class="ak"> 3。创建自定义reduce函数的程序。</strong></h1><h2 id="4d89" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">✅·拉维的密码</h2><p id="4528" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">这个很好。如果你知道更有效的方法，请在评论或私信中告诉我。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/8f894ec0ff8c6df8404194cd9304f703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i67KxYc2qnfZhCy8HL2ivA.png"/></div></div></figure><h1 id="e2cb" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated"><strong class="ak"> 4。如何析构嵌套对象</strong></h1><p id="d1e9" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">他的意思是:“如何解构嵌套的对象”——一个不应该指复数的“对象”。</p><h2 id="523f" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">✅·拉维的密码</h2><p id="fa03" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">这个也可以。如果你知道更有效的方法，请在评论或私信中告诉我。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/170456b6403991e14c6292871525f720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWQ1fAIC8iPLauuIkRgMhA.png"/></div></div></figure><h1 id="5fe1" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated"><strong class="ak"> 5。检查一个数是否是质数的程序？</strong></h1><p id="9c41" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">不不不为什么？？这是如此简单；拉维怎么可能搞砸这个！</p><h2 id="c705" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🧐·拉维的密码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/62c3659f0f3db193dbff549c3decd2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bn8CMeShP-H9TT9dWE1wbw.png"/></div></div></figure><h2 id="89d6" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🧇我的代码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/7f54a7aba8fdde95a6c59519d84dd58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_RRPKTTPGCo9St20sjeSw.png"/></div></div></figure><h2 id="a98d" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">👀运行时演示</h2><pre class="kg kh ki kj gt oi nz oj ok aw ol bi"><span id="b81a" class="nc ml iq nz b gy om on l oo op">node waffleIsPrime.js<br/>Waffle's Way: 32.69ms</span><span id="8a1c" class="nc ml iq nz b gy oq on l oo op">node raviIsPrime.js<br/>Ravis Way: 3.845s</span></pre><p id="9d16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Ravi的方法需要100多倍的时间…这只是在检查前100，000个素数的素性时——想象一下在使用大量数字的加密软件中使用这种算法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/2bf9c0dce0bf2fc68d7595721b20158f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CWyQHj6nFshhnzlBE4lc6g.gif"/></div></div></figure><h2 id="db3f" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🙋‍♂️问题</h2><p id="e32f" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">以下内容适用于我的代码:</p><ul class=""><li id="8ceb" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm nv mc md me bi translated"><strong class="kt ir">第2–4行:</strong>我更改了Ravi的代码，以检查一个数字是否为<code class="fe nw nx ny nz b">less than or equal to 2</code>。然后如果数字等于<code class="fe nw nx ny nz b">2</code>，则返回<code class="fe nw nx ny nz b">true</code>，否则返回<code class="fe nw nx ny nz b">false</code>。(<code class="fe nw nx ny nz b">0</code>和<code class="fe nw nx ny nz b">1</code>不是质数，但<code class="fe nw nx ny nz b">2</code>是)。</li><li id="a27a" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">第6–8行:</strong>检查一个数字是否是<code class="fe nw nx ny nz b">2</code>的倍数。如果是，你知道这个数是<strong class="kt ir">不是</strong>质数(因为它能被2整除)。</li><li id="1978" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">第10行:</strong>你只需要检查这个数是否能被<code class="fe nw nx ny nz b">3</code>和这个数的平方根之间的数整除。为什么？想想36。倍数为<code class="fe nw nx ny nz b">1 * 36</code>、<code class="fe nw nx ny nz b">2 * 18</code>、<code class="fe nw nx ny nz b">3 * 12</code>、<code class="fe nw nx ny nz b">4 * 9</code>、<code class="fe nw nx ny nz b">6 * 6</code>。那么如果继续下去，我们得到<code class="fe nw nx ny nz b">6 * 6</code>、<code class="fe nw nx ny nz b">9 * 4</code>、<code class="fe nw nx ny nz b">12 * 3</code>。如果你没有注意到这个模式:一旦你到达<code class="fe nw nx ny nz b">n</code>的平方根，这些数字就会重复。</li><li id="8967" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm nv mc md me bi translated"><strong class="kt ir">第12行:</strong>我没有从<code class="fe nw nx ny nz b">2</code>开始递增<code class="fe nw nx ny nz b">1</code>，而是从<code class="fe nw nx ny nz b">3</code>开始递增<code class="fe nw nx ny nz b">2</code>。为什么？我们已经检查过了，以确保数字不是偶数。所以我们可以跳过检查<code class="fe nw nx ny nz b">num</code>是否能被偶数整除。</li></ul><p id="43d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">时间复杂度？</strong>拉维代码的<a class="ae ln" href="https://www.wikiwand.com/en/Time_complexity" rel="noopener ugc nofollow" target="_blank">运行时复杂度</a>为<code class="fe nw nx ny nz b">O(n)</code>。我的代码的运行时复杂度是<code class="fe nw nx ny nz b">O(sqrt(n/2))</code>。我的代码会以指数速度运行<strong class="kt ir"/>。</p><h1 id="822b" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated">6。打印前n个质数的程序</h1><p id="cbbc" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">这个太蠢了。我甚至不知道他这么说是什么意思——在他的代码示例中，他将自己的函数命名为<code class="fe nw nx ny nz b">isPrime</code>，该函数执行相同的行为。</p><h1 id="c7f9" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated">7。打印斐波纳契数列的程序</h1><h2 id="1387" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">✅·拉维的密码</h2><p id="2418" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">这个正好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/589828bdf2071e6eead9b4e7ec2ceacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfmjShU5a-1yfVffLwJq7g.png"/></div></div></figure><h1 id="596c" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated">8。反转没有任何内置方法的字符串</h1><h2 id="9766" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">✅·拉维的密码</h2><p id="0437" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">这个很好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/7b25882c75d25975dd7ae619f7f6ce80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZ6z0KSB9qWNQdPILrph7A.png"/></div></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="2b7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我甚至不打算深入下面的三个例子。以下两个示例反转了一个字符串，但对其添加了愚蠢的限制:</p><p id="5412" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">9。使用内置方法反转句子及其字符: —他的代码示例展示了使用内置方法反转字符串。“以及它的性格”是什么意思？？？这和上一个挑战是一样的。</p><p id="f08c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 10。使用内置方法反转一个句子中的所有单词:</strong></p><p id="e442" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 11。仅反转(原地字符串)字符，而不是内置方法的句子</strong></p><blockquote class="os"><p id="ca09" class="ot ou iq bd ov ow ox oy oz pa pb lm dk translated">正如你所看到的，他只是想在他的文章中填满空间，以获得更多的阅读时间。但我不会浪费你宝贵的时间</p></blockquote></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="c249" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated"><strong class="ak"> 12。程序执行嵌套对象的深度复制</strong></h1><p id="3161" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">他的意思是“一个嵌套对象的”</p><h2 id="7e4f" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">❌·拉维的密码</h2><p id="1d41" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">这段代码甚至不会像预期的那样工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e4ac24b9e65621641cfd4252f6fc4286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iA8MWGawz4_1LBi6bKB3kQ.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk">Ravi’s code example — with whack indentation</figcaption></figure><h2 id="375e" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🧇我的代码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/70dd601485165851679c1f064d21196c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdFQIydghDKrNECuDENvsA.png"/></div></div></figure><h2 id="25c6" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🙋‍♂️问题</h2><p id="1cc8" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">Ravi的代码示例是完全错误的。起初它可能看起来有效。仔细看看有什么变化。</p><p id="2e49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<strong class="kt ir">第11 </strong>行，Ravi使用<code class="fe nw nx ny nz b">typeof i</code>检查对象的类型。如果<code class="fe nw nx ny nz b">i</code>的值是<code class="fe nw nx ny nz b">string</code>或<code class="fe nw nx ny nz b">number</code>，那么<code class="fe nw nx ny nz b">typeof i</code>分别评估为<code class="fe nw nx ny nz b">"string"</code>或<code class="fe nw nx ny nz b">"number"</code>。如果<code class="fe nw nx ny nz b">i</code>的值是一个对象，那么<code class="fe nw nx ny nz b">typeof i</code>的值就是<code class="fe nw nx ny nz b">"object"</code>。Ravi使用带有大写字母“O”的字符串文字<code class="fe nw nx ny nz b">"Object"</code>。</p><p id="1774" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是正如我们从前面的例子中了解到的，拼写不是Ravi的强项。</p><h1 id="b665" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated"><strong class="ak"> 13。添加通用的Add函数(能够接受任意数量的参数)并承诺</strong></h1><p id="2363" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">在这个例子中，Ravi缺少代码风格、JavaScript承诺、带参数的spread语法以及一般的编程。</p><h2 id="f57e" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">❌·拉维的密码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e5ea895a1c31147f36863f9a02544a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5ZaJaW8MyXSbty66_kLOA.png"/></div></div></figure><h2 id="edc3" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🧇我的代码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/43db1b0a3b8a294b547621a0b829d199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdE_CiqRWSnEF_SeSdNFBQ.png"/></div></div></figure><h2 id="c182" class="nc ml iq bd mm nd ne dn mq nf ng dp mu la nh ni mw le nj nk my li nl nm na nn bi translated">🙋‍♂️问题</h2><p id="4290" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">首先，这个人不知道承诺意味着什么。他们应该等待事件的发生。用<code class="fe nw nx ny nz b">setTimeout</code>来解决一个加两个数的承诺是愚蠢的。除此之外，他的代码绝对是垃圾——缩进和花括号的格式非常糟糕。</p><p id="5285" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，他的<code class="fe nw nx ny nz b">add</code>函数不接受任何数量的参数。他在自己的“编码挑战”中失败了只需要四个自变量:<code class="fe nw nx ny nz b">x</code>、<code class="fe nw nx ny nz b">y</code>、<code class="fe nw nx ny nz b">z</code>、<code class="fe nw nx ny nz b">m</code>；和回调函数。</p><p id="1bdb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他的代码将花费2秒钟返回一个响应，而在其他情况下可能不到1毫秒。此外，他还增加了五个额外的步骤来定义承诺函数。它应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/ca1616fb9f3b17fe72d9187398aba4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKMVT9wxNns3kHDHJXdIUg.png"/></div></div></figure><h1 id="9d26" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated"><strong class="ak"> 14。举一个例子，用let和不用let关键字</strong>的循环中的闭包</h1><p id="5366" class="pw-post-body-paragraph kr ks iq kt b ku nq jr kw kx nr ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">这甚至不是一个编码的例子…停止浪费我们的时间。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="1475" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你喜欢这篇文章，可以看看我的其他文章。</p><div class="pg ph gp gr pi pj"><a rel="noopener  ugc nofollow" target="_blank" href="/terrible-javascript-advice-debunking-stupid-advice-8be0f4724005"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd ir gy z fp po fr fs pp fu fw ip bi translated">可怕的JavaScript建议:揭穿愚蠢的建议</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">然而，另一位程序员给出了糟糕的建议。</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px kp pj"/></div></div></a></div><div class="pg ph gp gr pi pj"><a rel="noopener  ugc nofollow" target="_blank" href="/advice-from-a-seasoned-dev-keep-using-the-implicit-else-3e1b7c4695ec"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd ir gy z fp po fr fs pp fu fw ip bi translated">来自经验丰富的开发人员的建议:继续使用隐含的Else</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">不要接受媒体上任何人的编程建议。即使是经验丰富的专业人士有时也会给出糟糕的建议…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ps l"><div class="py l pu pv pw ps px kp pj"/></div></div></a></div><div class="pg ph gp gr pi pj"><a href="https://medium.com/@thesoggywaffle/no-the-end-of-javascript-is-not-here-776a0c92c501" rel="noopener follow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd ir gy z fp po fr fs pp fu fw ip bi translated">不，JavaScript还没有结束</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">一个媒体作家如何因为自己一无所知的东西而毁掉自己的可信度。揭露谎言。</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">medium.com</p></div></div><div class="ps l"><div class="pz l pu pv pw ps px kp pj"/></div></div></a></div><p id="8fe6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lo">更多内容请看</em><a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lo">plain English . io</em></strong></a><em class="lo">。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lo">免费周报</em> </strong> </a> <em class="lo">。关注我们关于</em><a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lo">Twitter</em></strong></a><em class="lo">和</em><a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lo">LinkedIn</em></strong></a><em class="lo">。查看我们的</em> <a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lo">社区不和谐</em> </strong> </a> <em class="lo">加入我们的</em> <a class="ae ln" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lo">人才集体</em> </strong> </a> <em class="lo">。</em></p></div></div>    
</body>
</html>