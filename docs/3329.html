<html>
<head>
<title>Using TypeScript Template Literal Types Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专家一样使用TypeScript模板文本类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac?source=collection_archive---------2-----------------------#2022-08-19">https://javascript.plainenglish.io/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac?source=collection_archive---------2-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af77" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过学习如何使用模板文本类型来编写更优雅的TypeScript代码。用动画解释。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0cd2d491c6fd3d593e1622752eedf3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ticmXLUHULvlbtGtXHlSew.jpeg"/></div></div></figure><p id="b710" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎来到<strong class="kt ir">掌握打字稿</strong>系列。本系列将以动画的形式介绍打字稿<strong class="kt ir">的核心知识和技巧。让我们一起学习吧！以前的文章如下:</strong></p><ul class=""><li id="ee50" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener"><strong class="kt ir">TypeScript泛型中的K，T，V是什么？</strong> </a></li><li id="257c" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-mapped-types-like-a-pro-be10aef5511a"> <strong class="kt ir">使用TypeScript像Pro一样映射类型</strong> </a></li><li id="3b5a" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-conditional-types-like-a-pro-7baea0ad05c5"> <strong class="kt ir">使用TypeScript条件类型像亲</strong> </a></li><li id="5fd2" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7"> <strong class="kt ir">使用TypeScript交集类型像亲</strong> </a></li><li id="5d29" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://levelup.gitconnected.com/using-typescript-infer-like-a-pro-f30ab8ab41c7" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">利用打字稿像专家一样推断</strong> </a></li><li id="d056" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/javascript-in-plain-english/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac" rel="noopener"> <strong class="kt ir">使用TypeScript模板字面类型像亲</strong> </a></li><li id="f23a" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/15-utility-types-that-every-typescript-developer-should-know-6cf121d4047c"> <strong class="kt ir">可视化打字稿:15种最常用的实用类型</strong> </a></li><li id="847f" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://levelup.gitconnected.com/10-things-you-need-to-know-about-typescript-classes-f58c57869266" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">关于类型脚本类你需要知道的10件事</strong> </a></li><li id="54ed" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/purpose-of-declare-keyword-in-typescript-8431d9db2b10"><strong class="kt ir"/></a>中‘declare’关键字的用途</li></ul><p id="5136" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你听说过TypeScript的模板文字类型吗？您想知道如何使用模板文字类型来编写更优雅的TypeScript代码吗？如果你愿意，看完这篇文章，也许你会。</p><p id="ceeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在开发网页时，我们通常会使用Tooltip或Popover组件来显示一些提示信息或说明性信息。为了满足不同的使用场景，Tooltip或Popover组件将允许用户设置其放置位置。例如，顶部、底部、左侧、右侧等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/e9e7fc8cbf9947617f3aed014083b184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*_LSddQh4MkY_apNMVyKLMA.jpeg"/></div></figure><p id="b459" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为字符串文字类型基本上可以对我们的字符串值进行拼写检查，所以我们使用TypeScript的类型别名定义了一个<code class="fe md me mf mg b">Side</code>类型。</p><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="402a" class="ml mm iq mg b gy mn mo l mp mq">type Side = 'top' | 'right' | 'bottom' | 'left';</span><span id="a734" class="ml mm iq mg b gy mr mo l mp mq">let side: Side = "rigth"; // Error<br/>// Type '"rigth"' is not assignable to type 'Side'. <br/>// Did you mean '"right"'?ts(2820)</span></pre><p id="aa40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于以上4个位置，已经可以满足大部分场景。但是如果您想要更精确地设置工具提示的放置位置，例如，让工具提示显示在指定元素的左上角区域:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/30cce9729b4b33d23aca493ab381e070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*R9fmvJsnj8EZ_LXp0978GQ.jpeg"/></div></figure><p id="c6f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么现有的边类型不能满足要求，那么我们定义一个新的<code class="fe md me mf mg b">Placement</code>类型:</p><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="0e83" class="ml mm iq mg b gy mn mo l mp mq">type Placement = Side<br/>  | "left-start" | "left-end" <br/>  | "right-start" | "right-end" <br/>  | "top-start" | "top-end" <br/>  | "bottom-start" | "bottom-end"</span></pre><p id="6f78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在放置类型中，除了原来的4个位置，我们增加了“左开始”、“左端”和“右端”等8个新位置，分别对应8个字符串文字类型。查看这些字符串类型，我们发现一些重复的代码"-start "和"-end "。另外，在定义这些字符串文字类型时，一不小心就可能出现拼写错误。</p><p id="4d0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么如何更好的解决以上问题呢？这就是我们可以使用TypeScript 4.1中引入的新模板文字类型的地方，其使用方式如下。</p><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="56b7" class="ml mm iq mg b gy mn mo l mp mq">type Alignment = 'start' | 'end';<br/>type Side = 'top' | 'right' | 'bottom' | 'left';</span><span id="1c1d" class="ml mm iq mg b gy mr mo l mp mq">type AlignedPlacement = `${Side}-${Alignment}`;<br/>type Placement = Side | AlignedPlacement;</span></pre><p id="6176" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看了上面的代码，是不是觉得简单多了？类似于JavaScript中的模板字符串，模板文字类型包含在反斜杠中，可以包含形式为<code class="fe md me mf mg b">${T}</code>的占位符。类型变量T的实际类型可以是<strong class="kt ir"> string、number、boolean或bigint </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2fb38530a0597a64c869aa0f2a54c3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8xVC_oIzraNZ-ZGDFgpxw.jpeg"/></div></div></figure><p id="d61d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模板文字类型为我们提供了连接字符串文字和将非字符串原始类型的文字转换为相应的字符串文字类型的能力。以下是一些例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/08c5d1b37ad42e39cf0de7dea30f7490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OX247Vk3-CGHdVQGaz_OWQ.jpeg"/></div></div></figure><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="b4d7" class="ml mm iq mg b gy mn mo l mp mq">type EventName&lt;T extends string&gt; = `${T}Changed`;<br/>type Concat&lt;S1 extends string, S2 extends string&gt; = `${S1}-${S2}`;<br/>type ToString&lt;T extends string | number | boolean | bigint&gt; = `${T}`;</span><span id="ad5d" class="ml mm iq mg b gy mr mo l mp mq">type T0 = EventName&lt;"foo"&gt;; // 'fooChanged'<br/>type T1 = Concat&lt;"Hello", "World"&gt;; // 'Hello-World'<br/>type T2 = ToString&lt;"bytefer" | 666 | true | -1234n&gt;; <br/>// "bytefer" | "true" | "666" | "-1234"</span></pre><p id="338e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于上面的例子，它并没有那么复杂。但是现在问题来了，如果传入的<code class="fe md me mf mg b">EventName</code>或<code class="fe md me mf mg b">Concat</code>实用程序类型的实际类型是联合类型，会有什么结果呢？接下来，让我们验证一下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e483a4e02979f445dc2829b7504437f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nIPJprf55W0EkesYC6q4w.jpeg"/></div></div></figure><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="7e99" class="ml mm iq mg b gy mn mo l mp mq">type T3 = EventName&lt;"foo" | "bar" | "baz"&gt;; <br/>// "fooChanged" | "barChanged" | "bazChanged"</span><span id="c57f" class="ml mm iq mg b gy mr mo l mp mq">type T4 = Concat&lt;"top" | "bottom", "left" | "right"&gt;;<br/>// "top-left" | "top-right" | "bottom-left" | "bottom-right"</span></pre><p id="8ebb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么会产生这样的类型？这是因为，对于模板文字类型，占位符中的联合类型分布在整个模板文字类型中。</p><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="df7f" class="ml mm iq mg b gy mn mo l mp mq">`[${A|B|C}]` =&gt; `[${A}]` | `[${B}]` | `[${C}]`</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/b5e27a55f10871b25886eccce9bfe3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Cj7tVoFhC9ISwn_kM08NBA.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/898c8563d0bd786a339cb1c887127fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHiwB56RULqunowZTEZShQ.jpeg"/></div></div></figure><p id="ed21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于带有多个类型占位符的情况，如<code class="fe md me mf mg b">Concat</code>实用程序类型。多个占位符中的联合类型解析为叉积。</p><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="1c10" class="ml mm iq mg b gy mn mo l mp mq">`${A|B}-${C|D}` =&gt; `${A}-${C}` | `${A}-${D}` <br/>  | `${B}-${C}` | `${B}-${D}`</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/f18647e7c924fb4d3880d9b5f6d8bf89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vWW4BKCvWgs1cEGwRyUFeQ.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1746b621fa4cc1d27e9ba598ee389cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJaEaLA6AhJJa8Dp9qEEpQ.jpeg"/></div></div></figure><p id="f2ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理解了上面的操作规则，应该就能理解生成的T3和T4类型了。</p><p id="ff57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在处理模板文字类型时，我们还可以使用TypeScript提供的内置实用程序类型来处理字符串类型，如<strong class="kt ir">大写、小写、大写和非大写</strong>，如下所示。</p><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="4e4a" class="ml mm iq mg b gy mn mo l mp mq">type GetterName&lt;T extends string&gt; = `get${Capitalize&lt;T&gt;}`;<br/>type Cases&lt;T extends string&gt; = `${Uppercase&lt;T&gt;} ${Lowercase&lt;T&gt;} <br/>  ${Capitalize&lt;T&gt;} ${Uncapitalize&lt;T&gt;}`;</span><span id="fb94" class="ml mm iq mg b gy mr mo l mp mq">type T5 = GetterName&lt;'name'&gt;;  // "getName"<br/>type T6 = Cases&lt;'ts'&gt;;  // "TS ts Ts ts"</span></pre><p id="69e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，模板文字类型的能力是非常强大的。结合TypeScript的条件类型和infer关键字，我们还可以实现类型推断。</p><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="f5a0" class="ml mm iq mg b gy mn mo l mp mq">type InferSide&lt;T&gt; = T extends `${infer R}-${Alignment}` ? R : T;</span><span id="5ed8" class="ml mm iq mg b gy mr mo l mp mq">type T7 = InferSide&lt;"left-start"&gt;; // "left"<br/>type T8 = InferSide&lt;"right-end"&gt;; // "right"</span></pre><p id="832c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，<code class="fe md me mf mg b">InferSide</code>实用程序类型除了使用模板文字类型之外，还使用了TypeScript条件类型和infer。如果你不熟悉这个内容，你可以像亲一样使用TypeScript条件类型阅读<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-conditional-types-like-a-pro-7baea0ad05c5">，像亲</a>一样使用TypeScript推断阅读<a class="ae lw" href="https://levelup.gitconnected.com/using-typescript-infer-like-a-pro-f30ab8ab41c7" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="212e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> TypeScript 4.1也允许我们使用as子句来重新映射映射类型中的键</strong>。其语法如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca40b0036e229d9f04d46833186c9c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHeeLwwy2b8qjSsobBfySg.jpeg"/></div></div></figure><p id="f74a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中NewKeyType的类型必须是<strong class="kt ir">字符串|数字|符号</strong>联合类型的子类型。在重映射的过程中，结合模板文字类型提供的能力，我们可以实现一些有用的实用工具类型。</p><p id="f8fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我们可以定义一个<code class="fe md me mf mg b">Getters</code>实用程序类型来为对象类型生成相应的Getter类型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/7fe98c48a59b0adac96d4e994776afa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*g-2VHlZmfLDzejw2opbRBQ.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fa6a0710a1392fb74e54e98430be7874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxV19uzEyl9RlKf-wSN2Nw.jpeg"/></div></div></figure><p id="56c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，由于<code class="fe md me mf mg b">keyof T</code>返回的类型可能包含符号类型，而大写实用程序类型要求要处理的类型需要是字符串类型的子类型，所以需要用<code class="fe md me mf mg b">&amp;</code>运算符对其进行类型过滤。</p><p id="cfba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了实现简单的实用程序类型，我们还可以实现更复杂的实用程序类型。例如，获取具有任意层次属性的对象类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/17aef01a687bfac320a35efe6da79bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEuIDXuFFnGjHeF9-zpRQA.jpeg"/></div></div></figure><pre class="kg kh ki kj gt mh mg mi mj aw mk bi"><span id="bc4c" class="ml mm iq mg b gy mn mo l mp mq">type PropType&lt;T, Path extends string&gt; = string extends Path<br/>  ? unknown<br/>  : Path extends keyof T<br/>  ? T[Path]<br/>  : Path extends `${infer K}.${infer R}`<br/>  ? K extends keyof T<br/>    ? PropType&lt;T[K], R&gt;<br/>    : unknown<br/>  : unknown;</span><span id="e196" class="ml mm iq mg b gy mr mo l mp mq">declare function getPropValue&lt;T, P extends string&gt;(<br/>  obj: T,<br/>  path: P<br/>): PropType&lt;T, P&gt;;</span></pre><p id="0c9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，PropType实用工具类型涉及到TypeScript中的几个核心知识。除了递归类型之外，条件类型、条件链和推断类型推断都在我以前的文章中讨论过。</p><p id="a1eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将在以后关于递归类型的文章中介绍它。如果你想学习打字稿，那么就不要错过<strong class="kt ir">掌握打字稿</strong>系列。</p><p id="7204" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae lw" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或<a class="ae lw" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，阅读更多关于TS和JS的内容！</p><div class="mt mu gp gr mv"><div role="button" tabindex="0" class="ab bv gv cb fp mw mx bn my kp ex"><div class="mz l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw na nb fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l na nb fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----2e02a7db0bac--------------------------------" rel="noopener follow" target="_top"> Bytefer </a></p></div></div><div class="ne nf gw l"><h2 class="bd ir ua ln fp ub fr fs ou fu fw ip bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi uc au ud ue uf ql ug an eh ei uh ui uj el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----2e02a7db0bac--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uk l fo"><span class="bd b dl z dk">47 stories</span></div></div></div><div class="nr dh ns fp ab nt fo di"><div class="di nj bv nk nl"><div class="dh l"><img alt="" class="dh" src="../Images/8fba4cad7ae795f6abed5234e33e0356.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*l87u8lL_MzD5n4z_"/></div></div><div class="di nj bv nm nn no"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di bv np nq no"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div></div></div></div><h1 id="256e" class="nx mm iq bd ny nz oa ob oc od oe of og jw oh jx oi jz oj ka ok kc ol kd om on bi translated">资源</h1><div class="mt mu gp gr mv oo"><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">发布TypeScript 4.1</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">今天，我们自豪地发布了TypeScript 4.1！如果您不熟悉TypeScript，这是一种建立在…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">devblogs.microsoft.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div></div><div class="ab cl pd pe hu pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="ij ik il im in"><p id="6408" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="pk">更多内容请看</em><a class="ae lw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pk">plain English . io</em></strong></a><em class="pk">。报名参加我们的</em> <a class="ae lw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="pk">免费周报</em> </strong> </a> <em class="pk">。关注我们关于</em><a class="ae lw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pk">Twitter</em></strong></a><a class="ae lw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pk">LinkedIn</em></strong></a><em class="pk"/><a class="ae lw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pk">YouTube</em></strong></a><em class="pk"/><a class="ae lw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="pk">不和</em> </strong> </a> <em class="pk">。</em></p></div></div>    
</body>
</html>