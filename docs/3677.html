<html>
<head>
<title>Find the Parent Element with CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CSS找到父元素</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/find-the-parent-node-via-css-e3b4baed1d94?source=collection_archive---------5-----------------------#2022-09-16">https://javascript.plainenglish.io/find-the-parent-node-via-css-e3b4baed1d94?source=collection_archive---------5-----------------------#2022-09-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1eca" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">CSS ': <code class="fe kc kd ke kf b">has'</code>添加了一个定制逻辑来基于其他选择器(而不是它自己的选择器)查找元素。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/265171c2e775d27289fbee53c8235c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OZQOByYlQYGJtjTQ"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@viniciusamano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vinicius "amnx" Amano</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4a7e" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我必须承认最强大的机器之一是<em class="lt"> CSS </em>引擎，但有时仅使用CSS很难完成某些事情，甚至只是改变一些颜色。例如，如果我让你在CSS中从一个子元素中找到一个父元素，通常你会被卡住。</p><p id="fbf3" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">CSS的设计方式是，给定一个元素，你可以指定它的子元素的可视属性。所以它或多或少是按照自顶向下的方法设计的，就像HTML DOM树一样。首先从作为根的元素开始，然后通过选择器深入到它的分支和叶子。</p><h2 id="1525" class="lu lv in bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">Java Script语言</h2><p id="6f55" class="pw-post-body-paragraph kx ky in kz b la mn jo lc ld mo jr lf lg mp li lj lk mq lm ln lo mr lq lr ls ig bi translated">我是一名JavaScript开发人员，所以在过去，当这些问题出现时，我只需编写几行JS代码，例如:</p><pre class="kh ki kj kk gt ms kf mt mu aw mv bi"><span id="c5f6" class="lu lv in kf b gy mw mx l my mz">Document.getElementById('root')</span></pre><p id="05f3" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">有时是更复杂的版本，但或多或少我能找到元素，即使它在很远的DOM分支中。这里没有什么新的东西，我们在近二十年前就已经这样做了。但坦白说，JavaScript很重；如果不是必须要做，我尽量不要用JavaScript来做。没错，我是一名JavaScript开发人员，但是最近我把CSS作为我解决UI问题的第一个工具，仅仅是因为它更便宜。</p><h2 id="b0e1" class="lu lv in bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h2><p id="ecdf" class="pw-post-body-paragraph kx ky in kz b la mn jo lc ld mo jr lf lg mp li lj lk mq lm ln lo mr lq lr ls ig bi translated">信不信由你，CSS每天都在增加新的功能。我们之所以觉得它变化很快，是因为没有人跟踪CSS规范，更不用说所有的浏览器兼容性了。似乎为我们打开了与父节点相关的大门的特性之一叫做<code class="fe kc kd ke kf b">:has</code>。还不知道的可以看看视频。我会一直等到你回来。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b448" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们不是直接找到一个元素，而是通过询问它是否有或包含另一个选择器来找到它。让我们回顾一下选择器:</p><pre class="kh ki kj kk gt ms kf mt mu aw mv bi"><span id="b048" class="lu lv in kf b gy mw mx l my mz">a img {} </span></pre><p id="3ebf" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">上面的选择器要求<code class="fe kc kd ke kf b">a</code>里面的<code class="fe kc kd ke kf b">img</code>。这很简单，但这也是我们找不到家长的原因，因为我们对<code class="fe kc kd ke kf b">img</code>不感兴趣，我们真正想做的是:</p><pre class="kh ki kj kk gt ms kf mt mu aw mv bi"><span id="a79c" class="lu lv in kf b gy mw mx l my mz">a:has(img) {}</span></pre><p id="cf46" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">啊，如果<code class="fe kc kd ke kf b">a</code>包含一个<code class="fe kc kd ke kf b">img</code>，那么那就是我们要找的<code class="fe kc kd ke kf b">a</code>。就这样？你可能会说。是的，这真的是把不可能变成了可能。</p><blockquote class="nc nd ne"><p id="6134" class="kx ky lt kz b la lb jo lc ld le jr lf nf lh li lj ng ll lm ln nh lp lq lr ls ig bi translated">检查<code class="fe kc kd ke kf b">:has</code>、<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:has" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/CSS/:has</a>的规格</p></blockquote><h2 id="e60d" class="lu lv in bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">正文:有()</h2><p id="f0c2" class="pw-post-body-paragraph kx ky in kz b la mn jo lc ld mo jr lf lg mp li lj lk mq lm ln lo mr lq lr ls ig bi translated">所以很多时候我在做网站的时候，当一个模态弹出来的时候，我就想改变<code class="fe kc kd ke kf b">body</code>的样式。现在在我看来，我只需要做到以下几点:</p><pre class="kh ki kj kk gt ms kf mt mu aw mv bi"><span id="6f10" class="lu lv in kf b gy mw mx l my mz">body:has(.Modal) {}   // if modal is inside<br/>body:has(+ .Modal) {} // if modal is sibling</span></pre><p id="6ff6" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">一行代码？让我们试着用JavaScript做上面的事情，祝你好运。此外，如果您可以在前端框架中集成少于五行代码的JavaScript版本。你赢了！</p><p id="4884" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">所以现在的问题不再是找到父节点，而是找到拥有某些东西的节点。在某种程度上，这为需要寻找远处元素的问题提供了另一种途径。<strong class="kz io">最重要的是，我们可以马上对找到的元素进行操作。</strong></p><h1 id="ee1c" class="ni lv in bd lw nj nk nl lz nm nn no mc jt np ju mf jw nq jx mi jz nr ka ml ns bi translated">摘要</h1><p id="bd5e" class="pw-post-body-paragraph kx ky in kz b la mn jo lc ld mo jr lf lg mp li lj lk mq lm ln lo mr lq lr ls ig bi translated">CSS <code class="fe kc kd ke kf b">:has</code>添加了一个定制逻辑来基于其他选择器(而不是它自己的选择器)查找元素。这将使寻找父节点的不可能任务从现在开始成为可能。</p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="8eca" class="pw-post-body-paragraph kx ky in kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><em class="lt">更多内容尽在</em> <a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> <em class="lt">说白了. io </em> </strong> </a> <em class="lt">。报名参加我们的</em> <a class="ae kw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> <em class="lt">免费周报</em> </strong> </a> <em class="lt">。关注我们关于</em> <a class="ae kw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> <em class="lt">推特</em> </strong> </a>，<a class="ae kw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kz io"><em class="lt">LinkedIn</em></strong></a><em class="lt">，</em><a class="ae kw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kz io"><em class="lt">YouTube</em></strong></a><em class="lt">，</em> <a class="ae kw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> <em class="lt">不和</em> </strong> </a> <em class="lt">。对增长黑客感兴趣？检查</em> <a class="ae kw" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> <em class="lt">电路</em> </strong> </a> <em class="lt">。</em></p></div></div>    
</body>
</html>