<html>
<head>
<title>How to Upload Large Files Using Plain JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用纯JavaScript上传大文件？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-upload-large-files-using-plain-javascript-1ca551e43950?source=collection_archive---------1-----------------------#2022-05-16">https://javascript.plainenglish.io/how-to-upload-large-files-using-plain-javascript-1ca551e43950?source=collection_archive---------1-----------------------#2022-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cd4b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">实现大文件上传和断点续传指南——解决面试问题。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ad945607c136022267ceab248295f811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f44YIvw_uiVbeH9S"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sigmund</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6dc7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如何用纯JavaScript上传大文件？</p><h1 id="c270" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">序</h1><p id="bc2c" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">面试的时候被问到这个问题，是一个在线编码编程问题。虽然当时的想法是正确的，但遗憾的是，并不完全正确。</p><p id="4292" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后花了一段时间整理思路，那么如何实现一个大文件上传，如何实现上传中恢复上传的功能？</p><p id="ee88" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将从头构建前端和后端，并实现一个上传大文件和从断点恢复上传的演示。</p><p id="4d9b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">frontend:vue . js @ 2+<a class="ae ks" href="https://element.eleme.io/#/en-US" rel="noopener ugc nofollow" target="_blank">Element-ui</a></p><p id="0742" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">后端:Node.js@14 + <a class="ae ks" href="https://www.npmjs.com/package/multiparty" rel="noopener ugc nofollow" target="_blank">多方</a></p><h1 id="fbe4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">大型文件上传</h1><h1 id="0b48" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">整个想法(前端)</h1><p id="b3e2" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">大部分关于前端大文件上传在线的文章都给出了解决方案。核心是使用Blob.prototype.slice方法。类似于数组的slice方法，文件的slice方法可以返回原始文件的一大块。</p><p id="46ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">预先定义单个块的大小，将文件划分成块，借助HTTP的并发性同时上传多个块。这样，原来上传一个大文件就变成了多个小文件块的并发上传，可以大大减少上传时间。</p><p id="2fcd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，由于并发性，传输到服务器的顺序可能会改变，因此我们还需要记录每个块的顺序。</p><h1 id="6fd2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">整个想法(后端)</h1><p id="5f51" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在接收它们之后合并所有的块。</p><p id="f746" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里还有两个问题:</p><p id="5295" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.何时合并块，即何时传输块？</p><p id="a1a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.怎么合并组块？</p><p id="11e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一个问题需要前端的配合。前端携带每个组块的最大组块数的信息，当服务器接收到这个数目的组块时，自动合并组块。或者您可以发送一个额外的请求，主动通知服务器合并块。</p><p id="6071" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二个问题是如何合并组块？在这里，您可以使用Nodejs的读写流(readStream/writeStream)将所有块的流传输到最终文件的流。</p><p id="744b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">空谈不值钱，给我看代码，然后我们用代码实现上面的思路。</p><h1 id="0dd7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">前端实现</h1><p id="4547" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">前端使用Vue.js作为开发框架，对界面没有太多要求。可以是原生的。考虑到美观，采用Element-UI作为UI框架。</p><h2 id="2eda" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">上传控件</h2><p id="e29a" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">首先，创建一个用于选择文件和监听更改事件的控件，另一个是上传按钮:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/8cead3c8d84ef62b5f71c9b91c31dd54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*YefpXIseAxFfW2KVnU1qqg.png"/></div></div></figure><h2 id="a30d" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">请求逻辑</h2><p id="3cae" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">考虑到通用性，没有第三方请求库，而是简单封装了原生XMLHttpRequest来发送请求:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="a7a5" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">上传区块</h2><p id="a26f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">然后要实现更重要的上传功能，上传需要做两件事:</p><p id="f4aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将文件切片</p><p id="37b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将块传输到服务器</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="657a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">单击上传按钮时，将调用createFileChunk对文件进行切片。块的数量由文件大小控制。这里设置了10MB，这意味着一个100MB的文件将被分成10个10MB的块。</p><p id="ef70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用createFileChunk中的while循环和slice方法将块放入fileChunkList数组并返回。</p><p id="66f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当生成文件块时，您需要给每个块一个作为散列的标识符。这里临时使用文件名+下标，这样服务器就可以知道当前的组块是哪个组块，哪个组块会用于后续合并的组块。</p><p id="edad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后调用uploadChunks上传所有文件块，将文件块、切片哈希、文件名放入formData，然后调用上一步的request函数返回一个promise，最后调用Promise.all并发上传所有块。</p><h2 id="1797" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">发送合并请求</h2><p id="2534" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">使用总体思路中提到的第二种合并组块的方法，即前端主动通知服务器进行合并。</p><p id="49b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">前端发送一个额外的合并请求，后端在收到请求时合并块。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="77b4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">后端实现</h1><p id="9b15" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">使用HTTP模块构建一个简单的服务器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="1e45" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">接受块</h2><p id="3da1" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">使用<a class="ae ks" href="https://www.npmjs.com/package/multiparty" rel="noopener ugc nofollow" target="_blank">多方</a>从前端处理表单数据。</p><p id="6a02" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在multiparty.parse的回调中，files参数将文件保存在formData中，fields参数将非文件字段保存在formData中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/2119643f0a71ea07edfb4b2a9eaf52f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b4WPSQMy_dU34E9G"/></div></div></figure><p id="e71c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">查看多方处理的chunk对象，“path”是存放临时文件的路径，“size”是临时文件的大小，多方文档中提到可以使用fs.rename(此处替换为fs.remove，因为fs-extra的重命名方法在<a class="ae ks" href="https://github.com/meteor/meteor/issues/7852#issuecomment-255767835" rel="noopener ugc nofollow" target="_blank">T3、T5】Windows平台上存在权限问题)。</a></p><p id="b54f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当接受文件块时，您需要创建一个临时存储块的文件夹，前缀为chunkDir，后缀为filename。</p><p id="092d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于前端在发送每个块时额外携带一个唯一值散列，所以散列被用作文件名，并且块被从临时路径移动到块文件夹。最终结果如下:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/3d67c6659696c3b73df6598e5bbe6885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1KpoN3yROiuEXrvY.jpg"/></div></div></figure><h2 id="27e0" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">合并块</h2><p id="2e74" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">服务器收到前端发送的合并请求后，合并文件夹下的所有组块:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="356d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于前端在发送合并请求时会携带文件名，所以服务器可以根据文件名找到上一步创建的chunk文件夹。</p><p id="8fea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后用fs.createWriteStream创建一个可写的流，可写的流文件名就是上传时的文件名。</p><p id="015f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后遍历整个chunk文件夹，通过fs.createReadStream创建一个可读的流，将传输合并到目标文件中。</p><p id="64cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">值得注意的是，每次可读流都会被传输到可写流的指定位置，这是由createWriteStream的第二个参数start控制的，目的是能够将多个可读流并发合并到可写流中，这样即使并发时流的顺序不同，也可以传输到正确的位置。</p><p id="9a39" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，还需要让前端在请求时向服务器提供预先设置的大小，服务器根据大小指定可读流的起始位置。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/53dfe3945e551534e43c526b71388c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NzzKuenoGrLGsKeZ.jpg"/></div></div></figure><p id="a167" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其实也可以等前一个组块合并后再合并下一个组块这样就不需要指定位置了，但是传输速度会降低，所以使用并发合并的方法。</p><p id="f9dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后只需确保在每次合并后删除块，并在所有块合并后删除块文件夹。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/c7312b20dec5da8523e001ec64bc21b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/0*th9F-DZMVT5yJPYb.jpg"/></div></figure><p id="56b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">至此，一个简单的大文件上传完成，接下来我们会在此基础上扩展一些附加功能。</p><h1 id="11e0" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">显示上传进度条</h1><p id="aa15" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">上传进度有两种，一种是每个组块的上传进度，一种是整个文件的上传进度，整个文件的上传进度是根据每个组块的上传进度计算出来的，所以我们先实现单个组块的进度条。</p><h2 id="3d79" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">单个块的进度条</h2><p id="922d" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">XMLHttpRequest原生支持上传进度的监控，只需要监控upload.onprogress，我们在原请求的基础上传入onprogress参数，为XMLHttpRequest注册监控事件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c923" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为每个块都需要触发一个独立的侦听器事件，所以需要一个工厂函数来根据传入的块返回不同的侦听器函数。</p><p id="780b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将监听器功能部分添加到原来的前端上传逻辑中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="239e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当上传每个块时，数据数组的相应元素的百分比属性将通过监听器函数更新。然后数据数组将显示在视图中。</p><h2 id="14d9" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">总进度条</h2><p id="229d" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">当前文件的上传进度可以通过累加每个chunk的上传部分，除以整个文件的大小得到，所以我们这里用Vue的computed属性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3dd6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最终显示如下</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/60861438fb346cca1e6f22d0b05732ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Znpi35KtGTLc7ANh.jpg"/></div></div></figure><h1 id="eb51" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">从断点恢复</h1><p id="1e84" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">从断点恢复上传的原理是前端/后端需要记住上传的块，以便在下一次上传中可以跳过之前上传的部分。有两种方案来实现存储器的功能。</p><p id="9e65" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">前端使用localStorage记录上传的区块哈希。</p><p id="c4cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">服务器保存上传的块哈希，前端在每次上传前从服务器获取上传的块。</p><p id="9185" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一个是前端方案，第二个是服务器，前端方案有一个瑕疵。换一个浏览器就会失去记忆效果，所以我这里选择后者。</p><h2 id="789a" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">生成哈希</h2><p id="fa3e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">无论是前端还是服务器，都必须生成文件和组块的哈希。之前，我们使用文件名+块下标作为块散列。一旦文件名被修改，它将失去作用。其实只要文件内容不变，hash就不应该变，所以正确的做法是基于文件内容生成hash，那么我们来修改一下hash生成规则。</p><blockquote class="nh ni nj"><p id="83c0" class="kt ku nc kv b kw kx jo ky kz la jr lb nk ld le lf nl lh li lj nm ll lm ln lo ig bi translated">webpack contenthash也是基于这个思路。</p></blockquote><p id="7afb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里使用了另一个库<a class="ae ks" href="https://www.npmjs.com/package/spark-md5" rel="noopener ugc nofollow" target="_blank">spark-MD5</a>，可以根据文件的内容计算出文件的哈希值。</p><p id="8985" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另外，考虑到如果上传一个大文件，读取文件内容和计算hash是非常耗时的，而且会造成UI阻塞，导致页面的挂起状态，所以我们使用web-worker在worker线程中计算hash，这样用户仍然可以正常的交互主界面。</p><p id="66fc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在实例化web-worker时，参数是一个js文件路径，不能跨域，所以我们创建一个单独的hash.js文件，放在public目录下。此外，不允许访问worker中的dom，但它提供了importScripts函数用于导入外部脚本，通过该函数导入spark-md5。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1083" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在worker线程中，接受文件切片fileChunkList，用fileReader读取每个组块的ArrayBuffer，不断传入spark-md5，每个组块计算完后，通过postMessage向主线程发送一个progress事件，全部发送到主线程后完成最终的hash。</p><blockquote class="nh ni nj"><p id="6b4e" class="kt ku nc kv b kw kx jo ky kz la jr lb nk ld le lf nl lh li lj nm ll lm ln lo ig bi translated">在spark-md5文档中，需要传入所有块并计算哈希值。您不能直接将整个文件放入计算中，否则，即使不同的文件也会有相同的散列。</p></blockquote><p id="c1fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后编写主线程和工作线程之间的通信逻辑。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="30b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">主线程使用postMessage将所有块fileChunkList传递给工作线程，并侦听工作线程发送的postMessage事件以获取文件哈希。</p><p id="57ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">加上一个进度条，显示计算的散列，如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/4331d50572ca14df5d17052fc74771cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5T1liUH39ULJzTWr.jpg"/></div></div></figure><p id="c8a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此时，前端需要将之前使用的文件名作为hash重写为worker返回的hash。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/caf25ceda4e2403a18e36d1cbdf3b7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PcLlckr5EJ1bHlvn.jpg"/></div></div></figure><p id="8263" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">服务器使用固定前缀+哈希作为块文件夹名称，哈希+下标作为块名称，哈希+扩展名作为文件名。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/9506f02d396a35c3f20441b0e65d41b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V3b-4gpd68J7gUhL.jpg"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/5065150d51b87a7456c6a9fa0e505374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cQAujwgZtfw38cAL.jpg"/></div></div></figure><h2 id="15d5" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">文件传输只需几秒钟</h2><p id="637c" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在实现断点续传之前，我们先简单介绍一下第二个文件传输。</p><p id="bdc6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所谓文件秒上传，是指上传的资源已经存在于服务器端，所以当用户再次上传时，会直接提示上传成功。</p><p id="bde1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二次文件传输需要依靠上一步生成的hash，即在上传之前，先计算文件hash，将hash发送到服务器进行验证。由于哈希的唯一性，一旦服务器可以找到具有相同哈希的文件，那么只需返回成功上传的信息。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c325" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这其实只是一个让用户看到的把戏，本质上根本没有上传。</p><p id="4c43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi">:)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/191d666b10658e567a080046676106b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/0*HGl9iZnXis7auHDb.jpg"/></div></figure><p id="e457" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">服务器的逻辑非常简单。增加一个验证界面，验证文件是否存在。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="f829" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">暂停上传</h2><p id="91a6" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在谈论了几秒钟内生成散列和文件传输之后，回到断点继续传输。</p><p id="f1ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">断点续传，顾名思义就是断点+续传，所以我们第一步就是实现“断点”，也就是暂停上传。</p><p id="a13c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">XMLHttpRequest的abort方法取消发送XHR请求。出于这个原因，我们需要保存上传每个块的XHR对象。让我们重塑请求方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3ad6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样，在上传块时，将requestList数组作为参数传入，请求方法将保存数组中的所有XHR。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/2b9896728a42c4f209175754c5f38c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PYWwBZ8yFwvdt29k"/></div></div></figure><p id="0bfb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每当成功上传块时，从请求列表中删除相应的XHR，这样只有上传块的XHR保存在请求列表中。</p><p id="43e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后创建一个新的暂停按钮，当按钮被点击时，在requestList中调用保存在XHR的abort方法，即取消并清除所有上传的组块。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/f3b7a4acf8ba803f1faa6e0743e8691b.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*uku7zuYsrsJc5X_N.jpg"/></div></figure><p id="bd02" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">单击“暂停”按钮可以看到XHR已被取消。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/9062d1d6e9ac7d4b525ad31c5a378b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zzlqjZlin0eK0Zl2"/></div></div></figure><h2 id="c6f8" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">继续上传</h2><p id="6ede" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">当我介绍从断点恢复上传时，我提到了使用第二种服务器端存储方法来实现恢复上传。</p><p id="161d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上传文件组块后，服务器会创建一个文件夹来存储所有上传的组块，所以每次前端上传前都可以调用一个接口，服务器会返回上传组块的组块名称，前端会跳过这些上传的组块。切片，从而达到“延续”的效果。</p><p id="a83d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并且该接口可以与之前第二次上传的验证接口结合，前端在每次上传前发送验证请求并返回两个结果:</p><p id="29ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">文件已经存在于服务器上，不需要再次上传</p><p id="3490" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果服务器上不存在该文件或者已经上传了一些文件块，通知前端上传并将<strong class="kv io">上传的</strong>文件块返回给前端</p><p id="24a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我们来秒变之前文件传输的服务器端验证接口。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="638b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后回到前端，前端有两个地方需要调用验证接口:</p><p id="fae7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">点击上传时，检查是否需要上传以及已经上传的块</p><p id="c7ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">暂停后点击继续上传，返回上传的区块</p><p id="93f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">增加了一个恢复按钮，修改了原来上传组块的逻辑。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fa30bd8d3dcb76595f954c19d41d4a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/0*MR030yWoNn8V3iJW.jpg"/></div></figure><p id="d229" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里上传列表参数是在上传组块的原有功能上增加的，也就是上图中服务器返回的组块名称列表。上传的组块被filter过滤掉，由于添加了上传的部分，对之前合并接口的触发条件做了一些改变。</p><p id="b1fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">至此，断点续传功能基本完成。</p><h1 id="10e9" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">进度条改进</h1><p id="f81d" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">虽然实现了断点续传，但是进度条的显示规则需要修改，否则当上传暂停/收到上传的组块时进度条会偏离。</p><h2 id="130a" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">单块进度条</h2><p id="9a42" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">由于当点击上传/恢复上传时，会调用验证接口返回上传的组块，所以上传组块的进度需要改为100%。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="aaf2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上传列表将返回上传的块。遍历所有组块时，可以判断当前组块是否在上传列表中。</p><h2 id="b73e" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">总进度条</h2><p id="0712" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">前面提到总进度条是一个计算属性，是根据所有组块的上传进度计算的，这就导致了一个问题。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/8fa8e77fb817a01af9546a24893f5860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*43XnnD_qeeCBSER2.jpg"/></div></div></figure><p id="6fc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">点击暂停将取消和清除块的XHR请求。如果此时已经上传了一个零件，你会发现文件的进度条已经退步了。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/a68a5eb1c9890475852c450760912410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uwCpjeTXul48lOA4.jpg"/></div></div></figure><p id="8ec3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">单击“resume”时，由于重新创建XHR，总进度条将向后移动，这将导致区块进度被清除。</p><p id="eedb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">解决方案是创建一个“假的”进度条，它基于文件进度条，但是只停止和增加，然后向用户显示这个假的进度条。</p><p id="fb87" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们使用Vue.js的listener属性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="29f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当uploadPercentage增加真实文件进度条时，fakeUploadPercentage也增加，一旦文件进度条退回，假进度条只需停止。</p><p id="bbb3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">至此，一个大文件上传+断点续传的解决方案完成。</p><h1 id="4517" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">总结</h1><p id="9505" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">大文件上传:</p><p id="52da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当前端上传大文件时，使用Blob.prototype.slice对文件进行切片，并发上传多个块，最后发送合并请求通知服务器合并块</p><p id="1b7a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">服务器接收块并存储它，并在接收到合并请求后使用流将块合并到最终文件中</p><p id="8682" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本机XMLHttpRequest的upload.onprogress监控块的上传进度</p><p id="b574" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用Vue计算属性根据每个块的进度计算整个文件的上传进度</p><p id="ce72" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从断点恢复:</p><p id="a337" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用spark-md5根据文件内容计算文件哈希</p><p id="5e59" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过hash可以判断服务器是否上传了文件，从而直接提示用户上传成功(第二次上传)</p><p id="e05c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过XMLHttpRequest的abort方法暂停上传块</p><p id="4d16" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上传前，服务器返回上传的组块名称，前端跳过这些组块的上传。</p><h1 id="1458" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">源代码</h1><p id="94ac" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">源码增加了一些按钮状态，交互更加友好，文章表达更加晦涩，可以跳转源码查看。</p><p id="f857" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://github.com/yeyan1996/file-upload" rel="noopener ugc nofollow" target="_blank"><em class="nc">-文件上传</em> </a></p><p id="f682" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读:)</p><p id="3672" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nc">更多内容看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">说白了就是</em> </strong> </a> <em class="nc">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">Twitter</em></strong></a><em class="nc">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nc">LinkedIn</em></strong></a><em class="nc">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">社区不和谐</em> </strong> </a> <em class="nc">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nc">人才集体</em> </strong> </a> <em class="nc">。</em></p></div></div>    
</body>
</html>