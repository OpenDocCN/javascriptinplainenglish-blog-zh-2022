<html>
<head>
<title>Depth-First Search in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的深度优先搜索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/depth-first-search-in-javascript-89b13fdc2d21?source=collection_archive---------7-----------------------#2022-09-26">https://javascript.plainenglish.io/depth-first-search-in-javascript-89b13fdc2d21?source=collection_archive---------7-----------------------#2022-09-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8085" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">深度优先搜索的工作原理以及如何用JavaScript实现它</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/bc873cd3cc8f58fc5c200c39a549b52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOYJZ07npQzv4HhHBzDPcA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/es/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Fotis Fotopoulos</a> on <a class="ae ks" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bea1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">图搜索算法是竞争性编程和面试中常见问题的基础，并且经常在应用程序本身中使用。程序员可以使用几种算法来解决他们的特定问题，每种算法都有自己的实现和优点。本文将介绍深度优先搜索，也称为DFS。DFS是一种遍历图(或树)的递归算法。</p><p id="da00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">深度优先搜索包括以下步骤:</p><ol class=""><li id="112c" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">首先，当前节点被建立为已访问。可以使用各种数据结构，比如HashMap或二维数组，但是最常见和最直接的方法是使用一维数组。这是为了确保在循环图中，节点不会被重新访问。如果要重新访问节点，那么递归将永远继续下去。</li><li id="690d" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">第二，遍历与当前节点相邻的每个点，只要它们以前没有被访问过。可以通过检查存储节点是否被访问过的数据结构来检查它们之前是否被访问过。有许多方法可以找到下一个要遍历的点。例如，可以迭代邻接矩阵，或者，如果图形是网格的形式，可以识别和遍历当前点周围的点。</li></ol><p id="3de7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">运行深度优先搜索的时间复杂度是O(节点+边)。时间复杂度是O(节点+边)，因为每个顶点迭代一次，每个边迭代两次(尽管根据实现可以更少)。</p><p id="2724" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据Brilliant.org的说法，深度优先搜索的用途从拓扑排序到图中的循环检测，再到用单一解决方案解决难题。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi md"><img src="../Images/c296d0f52f5989d07e7d0fe9f74eafc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tx3BRmfSE5baKMjyhz__2A.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@maplerockdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Richard Bell</a> on <a class="ae ks" href="https://unsplash.com/s/photos/sudoku?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c60f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当在树上实现深度优先搜索时，只要邻接数组不包括当前节点的父节点，就可以在不使用已访问数组的情况下实现，因为每个元素只能被访问一次。</p><p id="a76e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看这个例子是如何在一个样本图上工作的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi me"><img src="../Images/a9f5f17a04f994ec434e28f0bd693b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*0yWmqrUjyK04FMLAofFiOQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Courtesy of visualgo.net</figcaption></figure><p id="4330" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">深度优先搜索和广度优先搜索一样，必须从单个节点开始。在这种情况下，节点将是节点0。</p><ol class=""><li id="296a" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">将visited[0]设置为true，因为当前正在访问节点0</li><li id="a757" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">穿过边缘。由于节点1没有被访问过，我们转到节点1。</li><li id="34d0" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">我们将节点1设置为已访问。</li><li id="fe44" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">穿过边缘。这是一个有向图，下一条边是从1到3，所以我们访问3。</li><li id="5de4" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">我们将节点3设置为已访问。</li><li id="b4fb" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">穿过边，我们访问节点2和节点4</li><li id="bda9" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">我们将节点2设置为visited，并遍历边，检查是否要转到节点1，但是因为它已经被访问过了，所以无法访问</li><li id="16d7" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">我们访问节点4并将其设置为访问。</li></ol><p id="078b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这在图表的其余部分继续进行。</p><p id="e039" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要在JavaScript中实现这一点，首先需要定义一个被访问的数组。</p><pre class="kd ke kf kg gt mf mg mh mi aw mj bi"><span id="b6d1" class="mk ml in mg b gy mm mn l mo mp">var visited = new Array(nodeCount).fill(false);</span></pre><p id="5367" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，您需要为DFS定义一个函数，该函数将遍历一个点的边，检查连接到这些边的节点是否被访问，如果没有，则遍历它们。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/fb20179e5d589a095fd2df3cf31488e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vJy1TYLY1xAaYonAQepGw.png"/></div></div></figure><p id="8e60" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，你必须在初始点上运行函数。</p><pre class="kd ke kf kg gt mf mg mh mi aw mj bi"><span id="4f98" class="mk ml in mg b gy mm mn l mo mp">dfs(0);</span></pre><p id="4fd9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">总之，深度优先搜索是一种有用的算法，在竞争性编程问题中很流行，在现实生活中也有应用。在本教程中，我们回顾了深度优先搜索的步骤，并完成了一个JavaScript实现。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="796d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="my">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="my">免费周报</em> </strong> </a> <em class="my">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="my">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="my">LinkedIn</em></strong></a><em class="my"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="my">YouTube</em></strong></a><em class="my"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="my">不和</em> </strong> </a> <em class="my">。对增长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="my">电路</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>