<html>
<head>
<title>New Year, New JavaScript Features from ES2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新的一年，ES2022的新JavaScript特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/new-year-new-javascript-features-from-es2022-2638f456647f?source=collection_archive---------8-----------------------#2022-01-09">https://javascript.plainenglish.io/new-year-new-javascript-features-from-es2022-2638f456647f?source=collection_archive---------8-----------------------#2022-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/51d539185c9486a8761a8a74bf6423ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfkSTd2EWWzFgGELNJuNwQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="5cc8" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">顶级等候。私人#。在()&amp; more。ES2022即将推出的产品。</h2></div><p id="e640" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每年，ES团队都会收到许多关于改进辉煌的JavaScript生态系统的建议，其中一些最终被正式实施。为了被接受，一个特性需要经历<a class="ae lm" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank"> TC39 </a>中提到的4个阶段(同时查看<a class="ae lm" href="https://github.com/tc39" rel="noopener ugc nofollow" target="_blank"> TC39回购</a>)。</p><p id="2098" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以下部分将在即将到来的更新中增加:</p><ul class=""><li id="1cdb" class="ln lo jb ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">对于令人敬畏的<strong class="ks jc">异步/等待</strong>风扇，我们有<strong class="ks jc">:模块加载</strong></li><li id="85fb" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">对于精明的OOP爱好者，我们有<strong class="ks jc">类</strong></li><li id="7c3b" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">对于出色的<strong class="ks jc">函数式</strong>程序员，我们有:<strong class="ks jc">内置对象</strong></li></ul><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mb"><img src="../Images/ec1ce13df8b45c06201126348ef77c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8F9XnDVOXuC6i3jXjpaxw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">ES2022 &gt; ES2021</figcaption></figure><h1 id="3af8" class="mk ml jb bd mm mn mo mp mq mr ms mt mu kh mv ki mw kk mx kl my kn mz ko na nb bi translated">1.模块加载</h1><blockquote class="nc nd ne"><p id="ee57" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">厌倦了在文件根等待时出错？升级传入。</p></blockquote><p id="236e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每个人都喜欢<strong class="ks jc"> <em class="nf">异步</em> </strong>函数和<strong class="ks jc"> <em class="nf"> await </em> </strong>关键字，因为它将我们从嵌套承诺的地狱中拯救了出来，但是它将await的使用限制为只能使用异步函数，而不能在文件的根目录下使用，作为程序员，我们讨厌(或喜欢)编写变通办法🤓。</p><p id="c938" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在ES2022中，我们可以使用顶级await来动态导入资源，这在CLI脚本中非常有用。</p><p id="d655" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以这样使用它:</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="6c2b" class="no ml jb nk b gy np nq l nr ns">// load-resources.mjs <br/>// with top-level await<br/>const data = await (await fetch("https://resources")).text();<br/>export const resource = JSON.parse(data).resource;</span></pre><p id="4026" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">截至2022年1月，<a class="ae lm" href="https://caniuse.com/mdn-javascript_operators_await_top_level" rel="noopener ugc nofollow" target="_blank"> 81%的设备</a>和Node.js 14.8+都支持它。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="2867" class="mk ml jb bd mm mn oa mp mq mr ob mt mu kh oc ki mw kk od kl my kn oe ko na nb bi translated">2.班级</h1><h2 id="dff8" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">私有一切</h2><blockquote class="nc nd ne"><p id="d458" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">俗话说，保持你的变量私人，但你的关系公开。</p></blockquote><p id="986e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">大多数面向OOP的语言使用private和public来限制或扩展字段、方法或访问器的可见性。但是JavaScript在这方面没有限制。现在，它们通过前缀#包含在JavaScript中。</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="2740" class="no ml jb nk b gy np nq l nr ns">class LikeCounter {<br/>  #likes;</span><span id="d52d" class="no ml jb nk b gy oq nq l nr ns">constructor(likes) {<br/>    this.#likes = likes;    <br/>  }</span><span id="78da" class="no ml jb nk b gy oq nq l nr ns">  #increment () {<br/>    return this.#likes + 1;<br/>  }</span><span id="cbfb" class="no ml jb nk b gy oq nq l nr ns">#decrement () {<br/>    return this.#likes - 1;<br/>  }</span><span id="eb8a" class="no ml jb nk b gy oq nq l nr ns">doSomethingWithIt() {<br/>    this.#decrement()<br/>  }<br/>}</span><span id="af20" class="no ml jb nk b gy oq nq l nr ns">const obj = new LikeCounter(123);<br/>console.log(object.#doSomethingWithIt());    // SyntaxError<br/>console.log(object.#likes);   // SyntaxError<br/>object.doSomethingWithIt();</span></pre><p id="753a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://caniuse.com/mdn-javascript_classes_private_class_fields" rel="noopener ugc nofollow" target="_blank">大部分浏览器</a>(2022年1月使用率88%左右)和Node.js 12+都支持私有实例字段。</p><p id="5292" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">关于<a class="ae lm" href="https://caniuse.com/mdn-javascript_classes_private_class_methods" rel="noopener ugc nofollow" target="_blank">私有方法和访问器</a>对大多数浏览器的支持大约是82 %, node . js从14.6版本开始支持这个特性。</p><h2 id="680a" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">公共静态类字段</h2><blockquote class="nc nd ne"><p id="181f" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">想让你的班级更时尚吗？添加全新的静态字段。</p></blockquote><p id="8eb2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://github.com/tc39/proposal-static-class-features#static-public-fields" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc">静态类字段</strong> </a>是一种方便的向类对象追加属性的新符号。</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="3ed8" class="no ml jb nk b gy np nq l nr ns">// no static class fields:<br/>class Product {<br/>  // ...<br/>}<br/>Product.id = 1;</span><span id="8157" class="no ml jb nk b gy oq nq l nr ns">// now static class fields:<br/>class Product {<br/>  static id = 1;<br/>  // ...<br/>}</span></pre><p id="2973" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://caniuse.com/mdn-javascript_classes_static_class_fields" rel="noopener ugc nofollow" target="_blank">大部分浏览器</a>(2022年1月使用率:~89%)和Node.js 12+都支持公共类字段。</p><h2 id="8795" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">私有字段的存在性检查</h2><blockquote class="nc nd ne"><p id="d983" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">存在或不存在，或者更好地说，存在或不存在是一种该死的财产。</p></blockquote><p id="e74a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为试图访问一个对象上不存在的私有字段会抛出一个不幸的异常，所以需要<strong class="ks jc"> exist </strong>一个方法来检查一个对象是否有给定的私有字段。运算符 中的<a class="ae lm" href="https://github.com/tc39/proposal-private-fields-in-in" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc">来了。</strong></a></p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="c0e9" class="no ml jb nk b gy np nq l nr ns">class Dog {<br/>  #name</span><span id="182a" class="no ml jb nk b gy oq nq l nr ns">static isDogInstance(object) {<br/>    return #name in object;<br/>  }<br/>}</span></pre><p id="1e99" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于在私有字段上使用 <code class="fe or os ot nk b"><a class="ae lm" href="https://caniuse.com/mdn-javascript_classes_private_class_fields_in" rel="noopener ugc nofollow" target="_blank">in</a></code> <a class="ae lm" href="https://caniuse.com/mdn-javascript_classes_private_class_fields_in" rel="noopener ugc nofollow" target="_blank">操作符的</a><a class="ae lm" href="https://caniuse.com/mdn-javascript_classes_private_class_fields_in" rel="noopener ugc nofollow" target="_blank">浏览器支持是有限的(2022年1月使用率约为70%)。Node.js从16.4版开始支持该功能。</a></p><h2 id="a0f3" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">私有静态类字段和方法</h2><blockquote class="nc nd ne"><p id="0c70" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">静态变量总是公共的？只是将他们私有化(糟糕的苏联笑话)。</p></blockquote><p id="9792" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">作为私有字段和方法，封装限制在类级别上是有用的。<a class="ae lm" href="https://github.com/tc39/proposal-static-class-features" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc">私有静态方法和字段特性</strong> </a>使用<code class="fe or os ot nk b">#</code>前缀为类级别的字段和方法添加了硬可见性限制。</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="866c" class="no ml jb nk b gy np nq l nr ns">class Customer {<br/>  static #idCounter = 1; // static private</span><span id="d83c" class="no ml jb nk b gy oq nq l nr ns">static #getNextId() { // static private<br/>    return Customer.#idCounter++;<br/>  }</span><span id="76db" class="no ml jb nk b gy oq nq l nr ns">#id; // instance private</span><span id="ab99" class="no ml jb nk b gy oq nq l nr ns">constructor() {<br/>    this.#id = Customer.#getNextId();<br/>  }</span><span id="da2a" class="no ml jb nk b gy oq nq l nr ns">toString() {<br/>    return `c${this.#id}`;<br/>  }<br/>}</span><span id="d16a" class="no ml jb nk b gy oq nq l nr ns">const customers = [new Customer(), new Customer()];<br/>console.log(customers.join(' ')); // c1 c2</span></pre><p id="42d6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">支持百分比类似于前面描述的私有实例字段和方法。</p><h2 id="4851" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">静态类初始化块</h2><blockquote class="nc nd ne"><p id="9238" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">想把静态变量复杂化吗？好了，我们开始吧…</p></blockquote><p id="7730" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有时对静态类字段进行更复杂的初始化工作是必要的或方便的。使用前面的私有静态字段特性，这种初始化必须发生在类内部，因为私有字段是不可访问的。</p><p id="f6c0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://github.com/tc39/proposal-class-static-block" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc">静态初始化程序块特性</strong> </a>提供了一种在类定义评估期间执行代码的机制。</p><p id="135f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">只需创建一个以<code class="fe or os ot nk b">static</code>关键字为前缀的代码块，它将在类初始化时执行:</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="b43d" class="no ml jb nk b gy np nq l nr ns">class Example {<br/>  static propertyA;<br/>  static #propertyB; // private</span><span id="6936" class="no ml jb nk b gy oq nq l nr ns">static { // static initializer block<br/>    try {<br/>      const json = JSON.parse(fs.readFileSync('example.json', 'utf8'));<br/>      this.propertyA = json.someProperty;<br/>      this.#propertyB = json.anotherProperty;<br/>    } catch (error) {<br/>      this.propertyA = 'default1';<br/>      this.#propertyB = 'default2';<br/>    }<br/>  }</span><span id="1f98" class="no ml jb nk b gy oq nq l nr ns">static print() {<br/>    console.log(Example.propertyA);<br/>    console.log(Example.#propertyB);<br/>  }<br/>}</span><span id="94a6" class="no ml jb nk b gy oq nq l nr ns">Example.print();</span></pre><p id="eed5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://caniuse.com/mdn-javascript_classes_static_initialization_blocks" rel="noopener ugc nofollow" target="_blank">浏览器对静态类初始化块</a>的支持有限(2022年1月正好<strong class="ks jc"> 69.69%) </strong>。Node.js从16.4版开始支持该功能。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="773b" class="mk ml jb bd mm mn oa mp mq mr ob mt mu kh oc ki mw kk od kl my kn oe ko na nb bi translated">3.内置对象</h1><h2 id="3972" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">错误:。原因</h2><blockquote class="nc nd ne"><p id="e1f5" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">有意义的信息不够有意义？给你的错误添加原因。</p></blockquote><p id="1db0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">错误通常被包装以附加有意义的消息并记录错误上下文。然而，这意味着原始错误可能会丢失。出于日志记录和调试目的，将原始错误附加到包装错误是可取的。</p><p id="3a65" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://github.com/tc39/proposal-error-cause" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc">错误原因特性</strong> </a>提供了一种将原始错误附加到包装错误的标准化方法。它向<code class="fe or os ot nk b">Error</code>构造函数添加了<code class="fe or os ot nk b">cause</code>选项，并添加了一个用于检索原始错误的<code class="fe or os ot nk b">cause</code>字段。</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="7e68" class="no ml jb nk b gy np nq l nr ns">const getProduct = async (productId) =&gt; {<br/>  try {<br/>    return await fetch(`https://server/api/products/${productId}`);<br/>  } catch (error) {<br/>    throw new Error(<br/>      `Loading product data with id ${productId} failed`, <br/>      { cause: error }<br/>    );<br/>  }<br/>}</span><span id="5331" class="no ml jb nk b gy oq nq l nr ns">try {<br/>  const productData = await load(69420);<br/>  // do something<br/>} catch (error) {<br/>  console.log(error); // Error: Loading data for product with id 69420 failed<br/>  console.log(error.cause); // TypeError: Failed to fetch<br/>}</span></pre><p id="047a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当前浏览器对错误子句功能的支持是有限的(2022年1月使用率:~75%)。Node.js从16.9版本开始支持该功能。</p><h2 id="f265" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">数组、字符串和类型数组:。在()</h2><blockquote class="nc nd ne"><p id="cc74" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">用at(-1)python化您的JavaScript代码</p></blockquote><p id="cf15" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从数组或字符串的末尾获取元素是一件麻烦的事情，经常会导致冗长的重复代码，就像<code class="fe or os ot nk b">let last = arr[arr.length - 1]</code>。这要求数组存储在临时变量中，并防止无缝链接。</p><p id="0298" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://github.com/tc39/proposal-relative-indexing-method" rel="noopener ugc nofollow" target="_blank">。at()特性</a>提供了一种更短、更优雅的方式来从字符串或数组的开头或结尾获取元素，而不需要临时变量。</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="40af" class="no ml jb nk b gy np nq l nr ns">const someString = "JSiscool";</span><span id="5f1d" class="no ml jb nk b gy oq nq l nr ns">console.log(someString.at(3));    // i<br/>console.log(someString[3]);       // i</span><span id="977c" class="no ml jb nk b gy oq nq l nr ns">const temp = someString;<br/>console.log(temp[temp.length - 1]);      // l<br/>console.log(temp.at(-1));   // l - no temporary variable required</span></pre><p id="c727" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://caniuse.com/mdn-javascript_builtins_array_at" rel="noopener ugc nofollow" target="_blank">浏览器对。at特性</a>目前受限(2022年1月使用率70%左右)，仅在Node.js 16.6+中可用。</p><h2 id="0adb" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">对象:。hasOwn()</h2><blockquote class="nc nd ne"><p id="baf0" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">如果hasOwn是IRL父母测试将被淘汰</p></blockquote><p id="08db" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noopener ugc nofollow" target="_blank"><strong class="ks jc">object . has own feature</strong></a>是检查一个属性是否直接出现在一个对象上的强大而健壮的方法。这是使用<code class="fe or os ot nk b">hasOwnProperty</code>的首选替代方案:</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="1876" class="no ml jb nk b gy np nq l nr ns">const dog = {<br/>  name: "Olaf" // who would name his dog Olaf<br/>};</span><span id="2772" class="no ml jb nk b gy oq nq l nr ns">console.log(Object.prototype.hasOwnProperty.call(dog, 'name'));<br/>console.log(Object.hasOwn(dog, 'name')); // better</span></pre><p id="8b77" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://caniuse.com/mdn-javascript_builtins_object_hasown" rel="noopener ugc nofollow" target="_blank">浏览器支持目前有限</a>(2022年1月使用率70%左右)，需要Node 16.9+才能直接使用<code class="fe or os ot nk b">hasOwn</code>。</p><h2 id="1ca7" class="no ml jb bd mm of og dn mq oh oi dp mu kz oj ok mw ld ol om my lh on oo na op bi translated">RegExp:匹配索引(' d '标志)</h2><blockquote class="nc nd ne"><p id="b3f3" class="kq kr nf ks b kt ku kc kv kw kx kf ky ng la lb lc nh le lf lg ni li lj lk ll ij bi translated">如果你说正则表达式，这是为你疯狂的人</p></blockquote><p id="325c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">默认情况下，正则表达式匹配记录匹配文本的开始索引，但不记录其结束索引，也不记录其捕获组的开始和结束索引。</p><p id="0e25" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在涉及文本编辑器语法或搜索结果突出显示的用例中，将捕获组匹配索引作为正则表达式匹配的一部分会非常有用。</p><p id="65b6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用<a class="ae lm" href="https://github.com/tc39/proposal-regexp-match-indices" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> regexp匹配索引功能(‘d’flag)</strong></a>，匹配和捕获组索引在表达式结果的<code class="fe or os ot nk b">indices</code>数组属性中可用。匹配文本位置和匹配索引位置是相同的，例如，完全匹配的文本是匹配数组和索引数组中的第一个值。</p><p id="6340" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在<code class="fe or os ot nk b">indices.groups</code>中记录了被命名的捕获组的索引。</p><p id="1387" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我真的不是正则表达式或古鲁，所以不要破坏我的语法。</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="daf4" class="no ml jb nk b gy np nq l nr ns">const regexpr = /match\s(?&lt;word&gt;\w+):(?&lt;digit&gt;\d)/gd;<br/>const someString = "Game three:3.";</span><span id="bbac" class="no ml jb nk b gy oq nq l nr ns">for (const match of someString.matchAll(regexpr)) {<br/>    console.log(match);<br/>}©</span></pre><p id="bb93" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的示例代码有以下输出:</p><pre class="mc md me mf gt nj nk nl nm aw nn bi"><span id="07c3" class="no ml jb nk b gy np nq l nr ns">[<br/>  'Game three one:3',<br/>  'three',<br/>  '3',<br/>  index: 5,<br/>  input: "Game three one:3.",<br/>  groups: { word: 'three', digit: '3' },<br/>  indices: {<br/>    0: [6,17],<br/>    1: [12,15],<br/>    2: [16,17],<br/>    groups: { <br/>      digit: [16, 17],<br/>      word: [12, 15]<br/>    }<br/>  }<br/>]</span></pre><p id="a621" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://caniuse.com/mdn-javascript_builtins_regexp_hasindices" rel="noopener ugc nofollow" target="_blank">浏览器对RegExp匹配索引特性的支持目前是有限的</a>(2021年1月使用率约为79%)。在Node.js中，您可以使用<code class="fe or os ot nk b">--harmony-regexp-match-indices</code>标志来启用该特性，但是默认情况下它是禁用的。</p><h1 id="9bfa" class="mk ml jb bd mm mn mo mp mq mr ms mt mu kh mv ki mw kk mx kl my kn mz ko na nb bi translated">全部的</h1><p id="d570" class="pw-post-body-paragraph kq kr jb ks b kt ou kc kv kw ov kf ky kz ow lb lc ld ox lf lg lh oy lj lk ll ij bi translated">多亏了TC39团队，已经辉煌的JavaScript生态系统又增添了新的一年的精彩特性。</p><p id="a521" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">希望你喜欢这篇关于2022年JavaScript和<strong class="ks jc">新事物的介绍，请点击</strong>阅读更多编程文章🦄。</p><p id="40e4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="nf">更多内容看</em> <a class="ae lm" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> <em class="nf">说白了就是</em> </strong> </a> <em class="nf">。报名参加我们的</em> <a class="ae lm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> <em class="nf">免费周报</em> </strong> </a> <em class="nf">。在我们的</em> <a class="ae lm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> <em class="nf">社区不和谐</em> </strong> </a> <em class="nf">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>