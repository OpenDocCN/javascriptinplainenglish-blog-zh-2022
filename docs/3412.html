<html>
<head>
<title>Angular: Use APP_INITIALIZER DI Token with Observables &amp; Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度:使用可观察和可承诺的APP_INITIALIZER DI令牌</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-using-app-initializer-di-token-with-observables-and-promises-d089c3127de0?source=collection_archive---------5-----------------------#2022-08-25">https://javascript.plainenglish.io/angular-using-app-initializer-di-token-with-observables-and-promises-d089c3127de0?source=collection_archive---------5-----------------------#2022-08-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6e79" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><strong class="ak"> APP_INITIALIZER </strong>如何与<strong class="ak">可观察和承诺</strong>一起使用。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/65ab04b371e3f56be216008b1e01bbd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W4gaK2PIx467LJ5P"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="532a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用和理解<strong class="kv io"> APP_INITIALIZER DI令牌</strong>非常耗时，但值得。在应用程序完成初始化之前获取数据或执行操作是一个非常有用的工具。</p><p id="67ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它的工作非常简单。</p><ol class=""><li id="5d28" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">DI令牌接受将在应用程序初始化期间执行的工厂函数。</li><li id="8d85" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">工厂函数可以返回一个可观察到的或一个承诺。</li><li id="e12a" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">除非返回的承诺没有解决，或者返回的可观察到的没有完成，否则应用程序初始化将不会完成。</li></ol><p id="bf04" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的<strong class="kv io">目标</strong>是:</p><ol class=""><li id="1b03" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">演示如何将<strong class="kv io"> APP_INITIALIZER </strong>与<strong class="kv io">可观察到的和承诺</strong>一起使用。最后一个选项在较低版本的Angular中很有用，在该版本中，服务返回可观察值，但是DI令牌不支持可观察值。</li><li id="900b" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">如何使用此DI令牌向用户显示警报消息，以防承诺或可观察到的抛出错误。</li><li id="9261" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">最后，演示如何在应用程序仍在初始化时显示加载微调器。</li></ol><p id="91e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们开始吧。我们的应用程序只有<strong class="kv io"> AppComponent </strong>和<strong class="kv io"> DataService </strong>。</p><p id="ae30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们从<strong class="kv io"> AppComponent Class </strong>开始。为了向用户显示任何错误消息，我们创建了一个<strong class="kv io">消息$ </strong>可观察到。<strong class="kv io">在<strong class="kv io">数据服务</strong>中定义的alertObservable </strong>每当初始化过程中执行的任何任务抛出错误时都会发出数据。</p><p id="8d0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们正在抓住这个错误，并显示给用户查看。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1f0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> AppComponent Template: </strong>我们刚刚订阅了使用<strong class="kv io">异步管道</strong>可观察到的<strong class="kv io">消息$ </strong>并显示错误消息:</p><pre class="kd ke kf kg gt mf mg mh bn mi mj bi"><span id="f907" class="mk ml in mg b be mm mn l mo mp">&lt;p style=”color:red” *ngIf=”message$ | async as mess”&gt;{{ mess.message }}&lt;/p&gt;</span></pre><p id="31ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">移至<strong class="kv io"> AppModule。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e84a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在应用程序模块中，</p><p id="f36c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;我们已经定义了两个工厂函数<strong class="kv io">appinitializer using Promises()</strong>和<strong class="kv io">appinitializer using Observables()</strong>来演示如何使用Observables和Promises来使用DI令牌。</p><p id="5abf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;我们已经使用下面的代码注册了<strong class="kv io"> APP_INITIALIZER </strong> DI令牌。</p><p id="aaa6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">使用工厂</strong>包含工厂函数，该函数将作为该DI令牌的值。我们将把<strong class="kv io">appinitializer using promises()</strong>传递给<strong class="kv io"> useFactory </strong>以首先测试Promise方法。</p><p id="6882" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> deps </strong>包含一个令牌数组，其值将作为参数传递给factory函数。</p><pre class="kd ke kf kg gt mf mg mq mr aw ms bi"><span id="60bf" class="mt ml in mg b gy mu mv l mw mp">providers: [{<br/>provide: <strong class="mg io">APP_INITIALIZER</strong>,<br/>// useFactory: appInitializerUsingObservables,<br/>useFactory: appInitializerUsingPromises,<br/><strong class="mg io">deps: [DataService]</strong>,<br/>multi: true,<br/>},<br/>],</span></pre><p id="a800" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">转到工厂函数，让我们从<strong class="kv io"> appInitializerUsingPromises()开始。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="c7de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们已经传递了一个对<strong class="kv io">数据服务</strong>的引用作为工厂函数的参数。使用这个引用，我们在数据服务中调用了一个方法<strong class="kv io">initialiappusingpromises</strong>()。这个方法将在应用程序加载之前获取我们需要的数据。我们将在某个时候讨论这个问题。</p><p id="66a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">DataService中的这个方法返回一个承诺。不管承诺是成功还是抛出错误，我们在<strong class="kv io"> then和catch块</strong>中调用了<strong class="kv io"> resolve(true) </strong>。这是因为我们真的不希望应用程序因为错误而停止加载。如果我们这样做，用户只能在浏览器上看到一个空白屏幕。这会让用户感到困惑，因为他不知道幕后发生了什么。更好的方法是抓住错误，让应用程序加载，并向用户显示错误。</p><p id="a710" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，下一个工厂函数，<strong class="kv io">appInitializerUsingObservables()</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="db47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该函数再次将<strong class="kv io">数据服务</strong>引用作为参数，并调用在<strong class="kv io">数据服务</strong>中定义的方法<strong class="kv io">初始化应用观察值()</strong>。这个方法返回一个可观察的。</p><p id="936c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们进入<strong class="kv io">数据服务</strong>来理解这些方法实际上是做什么的。这可能看起来令人不知所措，但它非常简单。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ec1b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们定义了<strong class="kv io">行为主体</strong> <strong class="kv io">报警主体</strong>及其<strong class="kv io"> </strong>对应的<strong class="kv io">可观察报警对象。</strong>我们正在<strong class="kv io"> </strong>订阅AppComponent中的这个可观察对象，以显示获取ToDos或用户数据时遇到的任何错误。</p><p id="ce8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里需要注意的是，我们使用了一个<strong class="kv io">行为主体</strong>，而不是一个普通主体。原因是AppComponent只有在应用程序初始化之后才能订阅subject，但是在初始化过程中错误数据会传递给subject。因此有必要使用<strong class="kv io">behavior subject/replay subject/async subject</strong>，它甚至可以向后期订阅者发送数据。</p><pre class="kd ke kf kg gt mf mg mq mr aw ms bi"><span id="b25e" class="mt ml in mg b gy mu mv l mw mp">public alertSubject = new BehaviorSubject&lt;any&gt;(null);<br/>public alertObservable = this.alertSubject.asObservable();</span></pre><p id="3c61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们定义了<strong class="kv io"> getUser() </strong>来获取与用户相关的数据，定义了<strong class="kv io"> getToDos() </strong>来获取与用户相关的所有待办事项数据。</p><p id="9617" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<strong class="kv io"> setUser() </strong>和<strong class="kv io"> setToDos() </strong>中，我们存储了在DataService中提取的用户和ToDos数据。</p><p id="43b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们定义了<strong class="kv io">initialiappusingobservables()</strong>和<strong class="kv io">initialiappusingpromises()</strong>。这是在AppModule的工厂函数中调用的两个方法。</p><p id="8fca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们从<strong class="kv io">初始化应用承诺()开始。</strong>这是在AppModule的<strong class="kv io">appInitializerUsingPromises()</strong>工厂函数中被调用的方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="18c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">initialiappusingpromises()</strong>只是调用<strong class="kv io">initialiappusingobservables()</strong>将后者返回的可观测值转换成一个承诺，返回给AppModule中的工厂函数<strong class="kv io">appInitializerUsingPromises()</strong>。</p><p id="5cf2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我们只需要检查<strong class="kv io">initialiappusingobservables()</strong>来了解数据是如何获取的，错误是如何处理的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="fb6c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们一步一步来:</p><ol class=""><li id="80ce" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io">调用getUser() </strong>传递5作为参数，取userId为5的用户的数据。获取数据时的任何错误都将被下面的<strong class="kv io"> catchError </strong>操作符捕获，以执行两个任务:</li></ol><p id="077d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;将错误传递给<strong class="kv io"> alertSubject </strong>以便在应用程序初始化完成后在AppComponent中显示错误。</p><p id="4eb5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">= &gt;用操作符的<strong class="kv io">创建的成功可观察值替换错误可观察值并返回。</strong></p><pre class="kd ke kf kg gt mf mg mq mr aw ms bi"><span id="318b" class="mt ml in mg b gy mu mv l mw mp">catchError((err) =&gt; {<br/><strong class="mg io">this.alertSubject.next(err);<br/>return of(err);</strong><br/>})</span></pre><p id="b38b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Promise方法中，我们也可以选择重新抛出错误，并且可以在AppModule的工厂函数<strong class="kv io">appInitializerUsingPromises()</strong>的catch块中捕获错误。</p><p id="b9d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在可观察方法中，我们不应该重新抛出错误，因为在AppModule的工厂函数<strong class="kv io">appInitializerUsingObservables()</strong>中没有捕捉错误的规定。</p><p id="86d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个例子中，我想在两种方法中使用一个通用的错误处理逻辑来避免混淆。</p><p id="a5f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意<strong class="kv io">initialiappusingpromises()</strong>的最后一行，这里我们使用了<strong class="kv io"> lastValueFrom() </strong>运算符将<strong class="kv io">initialiappusingobservables()</strong>返回的可观测的<strong class="kv io"> obsv$ </strong>转换为一个承诺。该操作符用于替代<strong class="kv io"> toPromise() </strong>操作符，后者现已被弃用。</p><p id="fcf1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">返回的承诺将会成功，因为我们已经用成功的可观察值替换了错误可观察值，因此<strong class="kv io">然后<strong class="kv io">appInitializerUsingPromises()</strong>工厂函数中的块</strong>将会执行以解析承诺并恢复初始化过程。</p><p id="3c63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了演示这一点，如果我尝试使用<strong class="kv io"> userId 50 </strong>获取一个不存在的用户的数据，而不是使用<strong class="kv io"> userId 5 </strong>，那么从<strong class="kv io"> getUser() </strong>返回的可观察数据将出错，但是应用程序将加载并显示如下错误消息:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/0a69d7342eccca22d5aac290b88b9edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6_YiXp0l3xaRmQqbl-1uQ.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/0474bfdf2ce5ef2e14ff5a8669a20a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0YV0bP1NO4MBCg5AifbOTQ.png"/></div></div></figure><p id="e3b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.如果<strong class="kv io"> getUser() </strong>成功，则<strong class="kv io"> switchMap </strong>操作符执行，其中我们使用<strong class="kv io"> setUser() </strong>将用户数据存储在DataService中，并调用<strong class="kv io"> getToDos() </strong>来获取该用户的所有ToDos数据。</p><pre class="kd ke kf kg gt mf mg mq mr aw ms bi"><span id="c3c6" class="mt ml in mg b gy mu mv l mw mp"><strong class="mg io">this.setUser(x);</strong><br/>return <strong class="mg io">this.getToDos</strong>(x.id).pipe(tap((y) =&gt;<strong class="mg io"> this.setToDos(y)</strong>));</span></pre><p id="65dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.在<strong class="kv io"> getToDos() </strong>中遇到的任何错误都将在下面的同一个<strong class="kv io"> catchError </strong>操作符中被捕获:</p><pre class="kd ke kf kg gt mf mg mq mr aw ms bi"><span id="568a" class="mt ml in mg b gy mu mv l mw mp">catchError((err) =&gt; {<br/><strong class="mg io">this.alertSubject.next(err);<br/>return of(err);<br/></strong>})</span></pre><p id="ef62" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果<strong class="kv io"> getToDos() </strong>成功，首先使用<strong class="kv io"> setToDos() </strong>将ToDos数据存储在DataService中，然后将成功的承诺返回给AppModule中的工厂函数。然后，工厂函数中的<strong class="kv io">块</strong>执行，承诺被解析，应用程序初始化继续。</p><p id="147e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你想使用可观察的方法而不是承诺，在AppModule中，你可以注释掉语句:<strong class="kv io">use factory:appInitializerUsingPromises</strong>并取消注释<strong class="kv io">use factory:appInitializerUsingObservables。</strong>因此<strong class="kv io">appInitializerUsingObservables()</strong>工厂函数将被执行，进而调用<strong class="kv io">数据服务</strong>中定义的<strong class="kv io">初始化AppUsingObservables() </strong>。</p><pre class="kd ke kf kg gt mf mg mq mr aw ms bi"><span id="6f41" class="mt ml in mg b gy mu mv l mw mp">providers: [{<br/>provide: <strong class="mg io">APP_INITIALIZER</strong>,<br/><strong class="mg io">useFactory: appInitializerUsingObservables</strong>,<br/>//useFactory: appInitializerUsingPromises,<br/><strong class="mg io">deps: [DataService]</strong>,<br/>multi: true,<br/>},<br/>],</span></pre><p id="a979" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们看看如何在应用程序初始化过程中显示一个加载微调器。一旦初始化过程完成(失败/成功)，它将隐藏。</p><p id="70c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<strong class="kv io">index.html</strong>中，我在&lt;app-root&gt;&lt;/app-root&gt;中添加了一个&lt; div &gt;元素，如下图。</p><pre class="kd ke kf kg gt mf mg mh bn mi mj bi"><span id="6d6d" class="mk ml in mg b be mm mn l mo mp">&lt;body&gt;<br/>&lt;my-app&gt;<br/>&lt;div class=”loading”&gt;&lt;/div&gt;<br/>&lt;/my-app&gt;<br/>&lt;/body&gt;</span></pre><p id="73a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你现在需要做的就是给<strong class="kv io">&lt;div class = " loading "&gt;</strong>元素添加一些css，这样它就像一个旋转器。为此，我在&lt;样式&gt;内的&lt;头部&gt;内添加了下面的css。</p><pre class="kd ke kf kg gt mf mg mh bn mi mj bi"><span id="1b7b" class="mk ml in mg b be mm mn l mo mp">&lt;head&gt;<br/>&lt;style&gt;<br/>.loading {<br/>border: 16px solid #f3f3f3; /* Light grey */<br/>border-top: 16px solid #3498db; /* Blue */<br/>border-radius: 50%;<br/>width: 50px;<br/>height: 50px;<br/>margin: 0 auto;<br/>animation: spin 2s linear infinite;<br/>}<br/><br/>@keyframes spin {<br/>0% {<br/>transform: rotate(0deg);<br/>}<br/>100% {<br/>transform: rotate(360deg);<br/>}<br/>}<br/>&lt;/style&gt;<br/>&lt;/head&gt;</span></pre><p id="5e84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以查看下面的完整工作示例:</p><div class="mz na gp gr nb nc"><a href="https://stackblitz.com/edit/angular-pqbygh?file=src/app/data.service.ts" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">角形(叉形)堆叠</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">stackblitz.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq km nc"/></div></div></a></div></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="86b8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ny">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ny">plain English . io</em></strong></a><em class="ny">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ny">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ny">LinkedIn</em></strong></a><em class="ny"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ny">YouTube</em></strong></a><em class="ny"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ny">不和</em> </strong> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>