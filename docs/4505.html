<html>
<head>
<title>50 shades of ES6 modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">50种色调的ES6模块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/50-shades-of-es6-modules-95cd0b016156?source=collection_archive---------4-----------------------#2022-12-09">https://javascript.plainenglish.io/50-shades-of-es6-modules-95cd0b016156?source=collection_archive---------4-----------------------#2022-12-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4bac" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">对开发人员来说，最难的JavaScript主题的最大挑战。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f4a5aec2350fe402f996180843a326ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahrhFHocDpxTHdFfRqsUag.png"/></div></div></figure><p id="d149" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你问一个开发者:“对你来说最难的JS题目是什么？”，你绝不会听说是ES6模块。但是统计更懂！我们统计了电报频道各种主题测验的错误答案数量，发现ES6模块是反领导者模块。对于开发者来说，其他5个最棘手的话题可以在<a class="ae lk" href="https://medium.com/@intspirit/top-of-js-topics-mostly-failed-by-developers-53397f13eb78" rel="noopener">这里</a>查看。</p><p id="154a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">似乎很多开发者认为ES6模块只不过是<em class="ll">导出-导入</em>关键词。事实上，它要多样化得多。它有强大的功能和鲜为人知的陷阱。在这篇文章中，我们将看看所有这些，使用我们的电报频道的测验作为例子。这一次，我们不会根据正确答案的数量将任务排在前面，因为一些任务的解释可能是基于以前的解释，但是，为了更有趣，我们将指出正确回答测验的开发人员的百分比。走吧。</p><h2 id="5e98" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">测验#1。53%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs</figcaption></figure><p id="6852" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/461" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="b7e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们记住各种各样的导入和导出语法:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c6c41327d17f5f752f9f8e12645c438f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7Vh6K-REoI-ni3PiZ4jLA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Export syntax</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f42dd855280d4a9f4b0edd34f1dc338c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UubIE6RFvgPUOiaMQ2I13g.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Import syntax</figcaption></figure><p id="d582" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您使用导入语法检查该表，您将看到没有与我们的代码匹配的语法:</p><p id="7310" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">import { default } from ‘./module.mjs’;</code></p><p id="be28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为这种语法是被禁止的。测验代码会引发以下错误:</p><p id="e70c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">语法错误:意外的保留字</em></p><p id="62c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第<code class="fe ml mm mn mo b">import { default } from ‘./module.mjs’;</code>行中，<code class="fe ml mm mn mo b">default</code>是导出的名称，也是这个作用域中的一个变量的名称，这是被禁止的，因为<code class="fe ml mm mn mo b">default</code>是一个保留字。修复非常简单:</p><p id="018c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">import { default as foo } from ‘./module.mjs’;</code></p><p id="45f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，<code class="fe ml mm mn mo b">default</code>是导出的名称，<code class="fe ml mm mn mo b">foo</code>是变量的名称。换句话说，如果您想对默认导出使用命名导入语法，您必须重命名它。就是这样，这么简单！</p><h2 id="73ba" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated"><strong class="ak">测验2。35%的正确答案</strong></h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">helper.js</figcaption></figure><p id="1a82" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/447" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="86d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">许多开发人员不知道的一个重要的细微差别是，导入被挂起。也就是说，它们在引擎解析代码时上升。所有依赖项将在代码运行前加载。</p><p id="862d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是为什么我们将按以下顺序查看日志:</p><p id="e41f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">helper.js, index.js, 3</code></p><p id="6bd5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您希望某些代码在导入声明之前执行，请考虑将其移动到单独的文件中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">new index.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">logs.js</figcaption></figure><p id="c1b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在有了预期的输出:</p><p id="d4d7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">index.js, helper.js, 3</code></p><h2 id="bdaa" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">测验三。42%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">counter.mjs</figcaption></figure><p id="b55c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/459" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="9732" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">模块是<em class="ll">单线</em>。</p><p id="2ef3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">无论你从同一个位置或者不同的地方导入一个模块多少次，这个模块都只会被执行和加载一次。换句话说，只有一个模块实例。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/bfb63da818cb908ba21f1c1bc9cb3e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*8pDv7TVmWP4p2_viyxB2yg.jpeg"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Creds: <a class="ae lk" href="https://imgflip.com/i/3mol6q" rel="noopener ugc nofollow" target="_blank">https://imgflip.com/i/3mol6q</a></figcaption></figure><h2 id="6987" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">测验四。34%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs</figcaption></figure><p id="f322" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/412" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="c1a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在对我们之前的<a class="ae lk" href="https://medium.com/@intspirit/only-10-of-developers-can-solve-these-javascript-challenges-f4804c7c54eb" rel="noopener">文章</a>的评论中，我们收集了来自我们频道的最难的测验，一些人写道他们认为没有必要如此彻底地了解这门语言。嗯，不同意。我们相信你知道的越多，你的效率就越高(其他条件不变)。这个说法在我们公司的实践中被反复证明。</p><p id="974d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也许这个特性是将要被写到的特性之一——“为什么我们需要知道这个。”而且真的不太可能天天用。但是，总有一天，它会派上用场，节省你在谷歌上花费的时间是多么美妙。</p><p id="e73d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以根据<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta" rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><blockquote class="mq mr ms"><p id="dc87" class="ko kp ll kq b kr ks jo kt ku kv jr kw mt ky kz la mu lc ld le mv lg lh li lj ig bi translated">import.meta对象向JavaScript模块公开特定于上下文的元数据。它包含关于模块的信息。</p><p id="c1c6" class="ko kp ll kq b kr ks jo kt ku kv jr kw mt ky kz la mu lc ld le mv lg lh li lj ig bi translated">它返回一个带有url属性的对象，该属性指示模块的基URL。对于外部脚本，这将是从中获取脚本的URL；对于内联脚本，这将是包含文档的文档基URL。</p></blockquote><p id="0dc4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意，这将包括查询参数和/或哈希(即，在？或者#)。</p><h2 id="b6a0" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">测验五。45%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">counter.js</figcaption></figure><p id="23ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/449" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="2466" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">大多数开发人员忽略的另一个极其重要的时刻是，在导入模块的范围内，导入变量的行为类似于常量。</p><p id="6e0b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，要使代码工作，可以导出一个对象并更改其属性。</p><h2 id="f66d" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">测验6。11%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs</figcaption></figure><p id="4d7a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/463" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="79c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个测验的正确答案似乎是最少的。一方面，这是意料之中的，因为这是一个死角。另一方面，如果你再集中一点注意力，你会发现这个任务实际上是基于每个人都应该知道的基本事情(可能知道，只是没有意识到)。</p><p id="0115" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，这个</p><p id="8874" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">export default function foo() {}</code></p><p id="2966" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">等于</p><p id="7dd4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">function foo() {}<br/> export { foo as default }</code></p><p id="7082" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们想说这也相当于</p><p id="49bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">function foo() {}<br/> export default foo</code></p><p id="0a02" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但事实并非如此..不要惊讶，继续读下去。我们将在下一次测验中回到这个问题。</p><p id="5034" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在是时候记住函数是提升的，变量的初始化总是在函数/变量声明之后。这难道不是基础中的基础吗？</p><p id="874f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">引擎处理完模块代码后，它看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs as the engine sees it</figcaption></figure><p id="8da0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，测验结果就是<code class="fe ml mm mn mo b">number</code>。</p><h2 id="255b" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">测验#7。17%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs</figcaption></figure><p id="ba1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/465" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="453f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在大多数情况下，导入数据是实时的。也就是说，如果导出的值发生了变化，这种变化会反映在导入的变量中。</p><p id="0ab8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是对于默认导出，情况并非如此:</p><p id="d823" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">export default foo;</code></p><p id="2cc4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用这种语法时，导出的不是变量，而是它的值。您可以像这样完全不使用变量导出默认值:</p><p id="621d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">export default ‘hello’;</code><br/>T5】</p><p id="4070" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您查看测验#1中带有导出语法的表格，您会看到<code class="fe ml mm mn mo b">export default function () {}</code>与<code class="fe ml mm mn mo b">export default foo</code> ( <code class="fe ml mm mn mo b">Export of values</code>)位于不同的列(<code class="fe ml mm mn mo b">Default export</code>)。</p><p id="b64d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是因为它们的行为不同，函数仍然作为活动引用传递:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><p id="a33a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们再看一下出口表。</p><p id="27d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">export { foo as default };</code>在<code class="fe ml mm mn mo b">Named Export</code>列，和两者都不一样。但对我们来说，唯一重要的是它不在<code class="fe ml mm mn mo b">Export of values</code>一栏。因此，这意味着当您以这种方式导出数据时，它将是导入值的动态绑定。</p><h2 id="52f3" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">测验8。40%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module1.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module2.mjs</figcaption></figure><p id="b182" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/406" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="b7bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">行<code class="fe ml mm mn mo b">import { num } from ‘./module2.mjs’;</code>将抛出一个错误，因为导入构造必须在脚本的顶层:</p><p id="e780" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">语法错误:意外的标记' {' </em></p><p id="0b0e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个重要的限制，加上在文件路径中使用变量的限制，使得ES6模块成为静态的。这意味着您不必像Node.js中使用的Common.js模块那样执行代码来找出模块之间的所有依赖关系。</p><p id="46fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个使用Common.js模块的示例中，为了确定哪个模块<code class="fe ml mm mn mo b">a</code>或<code class="fe ml mm mn mo b">b</code>将被加载，需要运行以下代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">CommonJS example.</figcaption></figure><p id="cbbf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">模块的静态特性有很多好处。以下是其中的一些:</p><ol class=""><li id="12a2" class="mw mx in kq b kr ks ku kv kx my lb mz lf na lj nb nc nd ne bi translated">您总是知道导入数据的确切结构。这有助于linters在执行代码之前找到错别字。</li><li id="f96d" class="mw mx in kq b kr nf ku ng kx nh lb ni lf nj lj nb nc nd ne bi translated">异步加载。因为模块是静态的，所以可以在执行模块体之前加载导入。</li><li id="1341" class="mw mx in kq b kr nf ku ng kx nh lb ni lf nj lj nb nc nd ne bi translated">支持循环依赖。我们将在下一次测验中更详细地探讨这种可能性。</li><li id="c2bb" class="mw mx in kq b kr nf ku ng kx nh lb ni lf nj lj nb nc nd ne bi translated">高效捆绑。这个话题就不多说了，你可以在<a class="ae lk" href="https://blog.developer.adobe.com/optimizing-javascript-through-scope-hoisting-2259ef7f5994" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中自己看看<a class="ae lk" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> Rollup </a> bundler是如何有效构建ES6模块的。</li></ol><p id="fa09" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在ES6中，如果你需要有条件地加载一个模块，你可以使用类似于<code class="fe ml mm mn mo b">import()</code>函数的结构，这将在接下来的测验中强调。</p><h2 id="abb6" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">测验9。33%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs</figcaption></figure><p id="1a0d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/467" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="d9f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的代码中，我们可以看到循环依赖:<code class="fe ml mm mn mo b">index.mjs</code>从<code class="fe ml mm mn mo b">module.mjs</code>导入<code class="fe ml mm mn mo b">double</code>和<code class="fe ml mm mn mo b">square</code>函数，而<code class="fe ml mm mn mo b">module.mjs</code>从<code class="fe ml mm mn mo b">index.mjs</code>导入<code class="fe ml mm mn mo b">calculation</code>函数。</p><p id="72af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这段代码可以工作，因为ES6模块本质上很好地支持循环依赖。例如，如果我们重写这段代码以使用Common.js模块，它将不再工作:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.js in Common.js style</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.js in Common.js style</figcaption></figure><p id="bbb6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是Node.js中常见的“痛苦”。让我们看看这段代码实际上是如何工作的:</p><ol class=""><li id="a47b" class="mw mx in kq b kr ks ku kv kx my lb mz lf na lj nb nc nd ne bi translated"><code class="fe ml mm mn mo b">index.js</code>开始加载</li><li id="13d6" class="mw mx in kq b kr nf ku ng kx nh lb ni lf nj lj nb nc nd ne bi translated">加载中断在第一行加载<code class="fe ml mm mn mo b">module.js</code>:</li></ol><p id="b2a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">const helpers = require(‘./module.js’);</code></p><p id="aed3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3.<code class="fe ml mm mn mo b">module.js</code>开始加载</p><p id="77ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">4.在第<code class="fe ml mm mn mo b">console.log(actions.calculate(3));</code>行，代码抛出一个错误，因为<code class="fe ml mm mn mo b">actions.calculate</code>没有定义。这是因为Common.js同步加载模块。<code class="fe ml mm mn mo b">index.js</code>尚未加载，其导出对象当前为空。</p><p id="b716" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果延迟调用导入的函数，<code class="fe ml mm mn mo b">index.js</code>模块将有时间加载，代码将相应地工作:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.js in Common.js style v2</figcaption></figure><p id="8cb9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如您在前面的测验中所知道的，ES6模块支持循环依赖关系，因为它们是静态的，模块的依赖关系是在代码执行之前加载的。</p><p id="eee5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让上面的代码工作的另一件事是提升。当调用<code class="fe ml mm mn mo b">calculate</code>函数时，我们还没有和它的定义在一起。</p><p id="1390" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是捆绑模块后的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">bundle.js</figcaption></figure><p id="dc08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不吊就不行。</p><p id="6ee9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们将计算声明函数更改为函数表达式:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">calcualate function as a function expression.</figcaption></figure><p id="852e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它将抛出以下错误:</p><p id="bdff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll"> ReferenceError:初始化前无法访问“计算”</em></p><h2 id="31d8" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated"><strong class="ak">第十题。31%的正确答案</strong></h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.mjs</figcaption></figure><p id="5517" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/404" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="c315" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">顶级等待</em>是一个非常有用的特性，许多开发人员并不知道，也许是因为它是最近才在ECMAScript 2022中引入的。啊，真好！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/dfe3d104d10bfff12336b60681aeaa36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*LouJosfcctd3i_5dPKQnOQ.png"/></div></figure><p id="e7aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据<a class="ae lk" href="https://github.com/tc39/proposal-top-level-await" rel="noopener ugc nofollow" target="_blank"> tc39顶层待处理方案</a>:</p><blockquote class="mq mr ms"><p id="2164" class="ko kp ll kq b kr ks jo kt ku kv jr kw mt ky kz la mu lc ld le mv lg lh li lj ig bi translated">顶级await使模块能够充当大型异步函数:通过顶级await，ECMAScript模块(ESM)可以等待资源，导致导入它们的其他模块在开始评估它们的主体之前等待。</p></blockquote><p id="13c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">模块的标准行为是，在它导入的所有模块都被加载并且它们的代码被执行之前，模块中的代码不会被执行(请看测验#2)。事实上，随着顶级await的出现，一切都没有改变。模块中的代码直到导入的模块中的所有代码都被执行后才被执行，只是现在这包括等待模块中所有等待的承诺被解析。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module.js</figcaption></figure><p id="c3f6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">输出:</p><p id="8d8a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">module.js</code><br/><code class="fe ml mm mn mo b">module.js: promise 1</code><br/><code class="fe ml mm mn mo b">module.js: promise 2</code><br/><code class="fe ml mm mn mo b">index.js</code><br/></p><p id="4640" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们从第5行和第13行的<code class="fe ml mm mn mo b">module.js</code>中删除等待，并在文件<code class="fe ml mm mn mo b">index.js</code>中添加超时，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.js</figcaption></figure><p id="28b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">输出将是:</p><p id="865b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">module.js</code><br/><code class="fe ml mm mn mo b">index.js</code><br/><code class="fe ml mm mn mo b">num = 5</code><br/><code class="fe ml mm mn mo b">module.js: promise 1</code><br/><br/><code class="fe ml mm mn mo b">module.js: promise 2</code><br/><code class="fe ml mm mn mo b">timeout num = 20</code></p><p id="a6fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将在未来的测验中返回到顶级的等待功能。</p><h2 id="e3bd" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated">第11题。16%的正确答案</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module1.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module2.mjs</figcaption></figure><p id="1a41" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/408" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="009e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><blockquote class="mq mr ms"><p id="cbd7" class="ko kp ll kq b kr ks jo kt ku kv jr kw mt ky kz la mu lc ld le mv lg lh li lj ig bi translated">import()调用通常称为动态导入，是一个类似函数的表达式，允许异步和动态地加载ECMAScript模块。它允许人们绕过导入声明的语法限制，有条件地或按需加载模块。</p></blockquote><p id="27b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">ES2020中引入了该功能。</p><p id="7940" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">返回一个承诺，该承诺实现了一个包含模块所有导出的对象。</p><p id="2fa4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于<code class="fe ml mm mn mo b">import(module)</code>返回一个承诺，为了修复测试代码，我们必须在导入调用之前添加<code class="fe ml mm mn mo b">await</code>关键字:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><p id="eac1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们再次使用顶级的await，这让我们想起了这个特性的酷。</p><p id="dfaa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我相信至少有一次你的应用程序出错崩溃了:</p><p id="5625" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">语法错误:await仅在异步函数中有效</em></p><p id="eb19" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当试图从全局范围调用异步函数时，经常会发生这种情况。为了解决这个问题，我们不得不回避丑陋:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f4d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不仅难看，而且在使用这种模式异步加载模块时可能会导致错误。例如:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module1.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module2.mjs</figcaption></figure><p id="63bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">导入<code class="fe ml mm mn mo b">module1.mjs</code>时，<code class="fe ml mm mn mo b">num</code>的结果会是什么——来自<code class="fe ml mm mn mo b">module2</code>或<code class="fe ml mm mn mo b">undefined</code>的值？这将取决于何时访问变量:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><p id="9515" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当你访问从<code class="fe ml mm mn mo b">module1</code>导入的<code class="fe ml mm mn mo b">num</code>时，使用顶级await，它永远不会是<code class="fe ml mm mn mo b">undefined</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module1.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><h2 id="3859" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated"><strong class="ak">第12题。21%的正确答案</strong></h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module1.mjs</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module2.mjs</figcaption></figure><p id="0ff5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/410" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="0592" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">上面的代码会抛出一个错误:</p><p id="ff16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">类型错误:无法将对象转换为原始值</em></p><p id="75bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同意，一个相当意外的错误措辞。让我们弄清楚这个错误是从哪里来的。</p><p id="836b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这段代码中，我们使用了一个在前面的例子中已经遇到过的动态导入。为了理解这段代码中的问题，我们需要仔细看看<code class="fe ml mm mn mo b">import()</code>的返回值。</p><p id="0abf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">变量<code class="fe ml mm mn mo b">module1</code>和<code class="fe ml mm mn mo b">module2</code>的值不是我们所期望的。<code class="fe ml mm mn mo b">import()</code>返回一个承诺，该承诺实现一个与名称空间导入具有相同形状的对象:</p><p id="d13c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">import * as name from moduleName</code></p><p id="e665" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">default</code>导出可作为名为<code class="fe ml mm mn mo b">default</code>的键使用。</p><p id="46be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，在变量<code class="fe ml mm mn mo b">module1</code>和<code class="fe ml mm mn mo b">module2</code>中，我们分别有了对象<code class="fe ml mm mn mo b">{ default: 1 }</code>和<code class="fe ml mm mn mo b">{ default: 2 }</code>，而不是值<code class="fe ml mm mn mo b">1</code>和<code class="fe ml mm mn mo b">2</code>。</p><p id="72e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么，为什么我们在将两个对象相乘时会得到如此奇怪的错误，而不是我们习惯的<code class="fe ml mm mn mo b">NaN</code>？</p><p id="4f35" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是因为返回的对象有一个<code class="fe ml mm mn mo b">null</code>原型。因此，它没有一个<code class="fe ml mm mn mo b">toString()</code>方法，用于将对象转换为图元。如果这个对象有一个<code class="fe ml mm mn mo b">Object</code>原型，我们会在控制台中看到<code class="fe ml mm mn mo b">NaN</code>。</p><p id="1c37" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要修复测验代码，我们需要进行以下更改:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs changes v1</figcaption></figure><p id="f0be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.mjs changes v2</figcaption></figure><p id="65cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">阅读更多关于import()的内容:<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" rel="noopener ugc nofollow" target="_blank"> MDN </a>。</p><h2 id="993c" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated"><strong class="ak">第13题。17%的正确答案</strong></h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">index.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module1.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">module2.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">intermediate.js</figcaption></figure><p id="f332" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://t.me/intspirit/380" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="89b3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">export * from ‘module’</code>语法将来自<em class="ll">‘模块’</em>文件的所有命名导出重新导出为当前文件的命名导出。如果有几个<strong class="kq io">名称相同的出口，则没有一个出口被重新出口。</strong></p><p id="574c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以运行这段代码，我们会在控制台中看到<code class="fe ml mm mn mo b">undefined</code>。只有17%的应答者正确回答了这个问题，大多数应答者(59%)认为这个代码会抛出一个错误。事实上，这种无声的失败似乎不是严格模式的典型特征。(正如我们所记得的，JavaScript模块自动处于严格模式。)如果你知道这种行为的原因，请在评论中告诉我。</p><p id="3986" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">顺便说一句，如果在同样的情况下我们<em class="ll">显式地</em>导入<code class="fe ml mm mn mo b">x</code>，我们会有一个预期的错误:</p><p id="8c65" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ml mm mn mo b">import { x } from ‘./intermediate.js’;</code></p><p id="7ea5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">语法错误:请求的模块。“/intermediate.js”包含名称“x”的冲突星形导出</p><h2 id="b9e8" class="lm ln in bd lo lp lq dn lr ls lt dp lu kx lv lw lx lb ly lz ma lf mb mc md me bi translated"><strong class="ak">总之。</strong></h2><p id="5cc1" class="pw-post-body-paragraph ko kp in kq b kr nl jo kt ku nm jr kw kx nn kz la lb no ld le lf np lh li lj ig bi translated">一如既往，我们想鼓励你继续学习你每天写的语言，让我们做得更好！</p><blockquote class="mq mr ms"><p id="b788" class="ko kp ll kq b kr ks jo kt ku kv jr kw mt ky kz la mu lc ld le mv lg lh li lj ig bi translated"><em class="in">订阅</em> <a class="ae lk" href="https://t.me/intspirit" rel="noopener ugc nofollow" target="_blank">电报频道</a> <em class="in">成为办公室里的“百事通”。</em></p><p id="ef39" class="ko kp ll kq b kr ks jo kt ku kv jr kw mt ky kz la mu lc ld le mv lg lh li lj ig bi translated"><em class="in">关注我们的</em> <a class="ae lk" href="https://intspirit.medium.com/" rel="noopener">中型</a> <em class="in">不要错过新东西。</em></p><p id="7e51" class="ko kp ll kq b kr ks jo kt ku kv jr kw mt ky kz la mu lc ld le mv lg lh li lj ig bi translated"><em class="in">在</em> <a class="ae lk" href="https://www.linkedin.com/company/intspirit" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> <em class="in">上关注我们做的其他酷事。</em></p></blockquote><p id="b23b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在评论中分享——在JavaScript的哪个主题中，你认为你理解得最差？也许下一次我们会专门为此写一篇文章。</p></div></div>    
</body>
</html>