<html>
<head>
<title>New React Documentation: Do Not Abuse Ref</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新React文档:不要滥用引用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/new-react-documentation-do-not-abuse-ref-8e96dbec6bfc?source=collection_archive---------5-----------------------#2022-09-08">https://javascript.plainenglish.io/new-react-documentation-do-not-abuse-ref-8e96dbec6bfc?source=collection_archive---------5-----------------------#2022-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="65f9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用useRef的正确场景</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8ac090b82b80a066bbe72d89e4e9b5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gh3aHq5CbbNw0slr"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@deko_photo4?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Valdemaras D.</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e719" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React的新文档有一个有趣的细节:在文档中称为Escape Hatches的部分引入了两个钩子API，useRef和useEffect。显然，逃生舱口在正常航行中并不需要，只会在危险的情况下使用。如果开发人员过于依赖这两个API，他们可能会误用它们。</p><p id="22e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在“新的React文档:不要滥用效果中，我们讨论了如何正确使用use Effect场景。今天，我们来谈谈useRef的使用场景。</p><h2 id="20ba" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">为什么要逃生舱？</h2><p id="263d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先思考一个问题:为什么useRef和useEffect被归为逃生舱？这是因为两者都在React控制之外的因素上运行。效果处理副作用。例如:<em class="mq"> document.title </em>在useEffect中修改。<em class="mq"> document.title </em>不属于React中的状态，React无法感知它的变化，所以被归类为生效。同样，使DOM成为焦点需要调用<em class="mq"> element.focus </em>()，DOM API的直接执行不受React控制。虽然它们是React无法控制的因素，但React也想尽可能防止它们失控，以保证应用的健壮性。</p><h2 id="023c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">失控参考</h2><p id="d2b9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对于Ref来说，失控是什么意思？首先，看看它没有失控的情况。</p><ul class=""><li id="80b2" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">执行ref.current的对焦、模糊等。方法。</li><li id="3b7a" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">执行ref.current.scrollIntoView将元素滚动到视图中。</li><li id="1715" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">执行ref . current . getboundingclientrect来测量DOM大小。</li></ul><p id="3e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我们操纵DOM，但它们涉及React控制之外的因素，因此它们不被视为失控。但是在下面的例子中，</p><ul class=""><li id="1860" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">执行ref.current.remove以删除DOM</li><li id="ed46" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">执行ref.current.appendChild以插入子节点</li></ul><p id="16ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些也是DOM操作，但是它们在React的控制之内，所以通过ref执行这些操作是不受控制的。</p><p id="30d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，下面的内容来自React文档。单击按钮1将插入/删除P节点，单击按钮2将调用DOM API删除P节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6fb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按钮1通过反应控制移除P节点。按钮2通过直接操作DOM来删除P节点。如果这两种删除P节点的方法混合使用，那么单击按钮1和按钮2将会报告错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/092b8d59478e9f2572bdf87dcce0ebed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFPHkIawko6guPyQLCtXkA.png"/></div></div></figure><p id="4a03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是使用Ref操作DOM导致失控的结果。</p><h2 id="94cf" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">如何限制失控</h2><p id="cfa5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在问题来了，既然叫失控，那就是React无法控制的东西。React不能限制开发者使用DOM API吧？如何限制失控？在React中，组件可以分为:</p><ul class=""><li id="e786" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">高阶组件</li><li id="14bc" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">低阶组件</li></ul><p id="92f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">低阶组件是那些基于DOM包装的组件，比如下面的组件，它直接基于输入节点包装。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="da67" class="ls lt iq nj b gy nn no l np nq">function MyInput(props) {<br/>  return &lt;input {.. .props} /&gt;;<br/>}</span></pre><p id="e6be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在低级组件中，可以将ref直接指向DOM，例如</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="0b8d" class="ls lt iq nj b gy nn no l np nq">function MyInput(props) {<br/>  const ref = useRef(null);<br/>  return &lt;input ref={ref} {.. .props} /&gt;;<br/>}</span></pre><p id="cbb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高阶组件是那些基于低阶组件包装的组件，例如下面的表单组件，它基于输入组件包装。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="cff6" class="ls lt iq nj b gy nn no l np nq">function Form() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;MyInput/&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="b791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高阶组件不能将引用直接指向DOM，这种限制将引用失控的范围保持在单个组件内，因此没有跨组件的引用失控。使用文档中的例子，如果我们想在表单组件中单击一个按钮来操作输入焦点。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="6508" class="ls lt iq nj b gy nn no l np nq">function MyInput(props) {<br/>  return &lt;input {.. .props} /&gt;;<br/>}</span><span id="306f" class="ls lt iq nj b gy nr no l np nq">function Form() {<br/>  const inputRef = useRef(null);</span><span id="483a" class="ls lt iq nj b gy nr no l np nq">function handleClick() {<br/>    inputRef.current.focus();<br/>  }</span><span id="8c59" class="ls lt iq nj b gy nr no l np nq">return (<br/>    &lt;&gt;<br/>      &lt;MyInput ref={inputRef} /&gt;<br/>      &lt;button onClick={handleClick}&gt;<br/>        input聚焦<br/>      &lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="c391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单击时，会报告一个错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/df42363f2b922958dee482543c06f4da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ohqadB2N08zXmmxkZVzWA.png"/></div></div></figure><p id="e2ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为在表单组件中向MyInput传递ref失败；inputRef.current不指向输入节点。原因是，如上所述，React默认情况下不支持跨组件传递refs，以便在单个组件内保持refs的范围不受控制。</p><h2 id="af56" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">人为地消除限制</h2><p id="e0a0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果必须取消这一限制，可以使用forwardRef API显式传递引用。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="6e16" class="ls lt iq nj b gy nn no l np nq">const MyInput = forwardRef((props, ref) =&gt; {<br/>  return &lt;input {.. .props} ref={ref} /&gt;;<br/>});</span><span id="6fda" class="ls lt iq nj b gy nr no l np nq">function Form() {<br/>  const inputRef = useRef(null);</span><span id="be45" class="ls lt iq nj b gy nr no l np nq">function handleClick() {<br/>    inputRef.current.focus();<br/>  }</span><span id="063c" class="ls lt iq nj b gy nr no l np nq">return (<br/>    &lt;&gt;<br/>      &lt;MyInput ref={inputRef} /&gt;<br/>      &lt;button onClick={handleClick}&gt;<br/>        Focus the input<br/>      &lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="0ad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用forwardRef，可以跨组件传递Ref。在示例中，我们将InputRef从表单跨组件传递到MyInput，并将其与input关联起来。在实践中，一些学生可能会发现forwardRef API有点多余。但从一个失控Ref的角度来看，forwardRef的意图是明确的:既然开发人员手动调用forwardRef来打破阻止一个失控ref的限制，那么他就应该知道自己在做什么，应该自己承担相应的风险。同时，forwardRef的存在使得在发生与Ref相关的错误后更容易定位错误。</p><h2 id="7367" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">useImperativeHandle</h2><p id="972a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">除了限制refs跨组件传递，还有一个防止refs失控的措施，那就是useImperativeHandle，其逻辑如下。由于引用因为使用了不应该使用的DOM方法(比如appendChild)而失去控制，所以我可以限制引用中只存在那些可以使用的方法。</p><p id="f518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用useImperativeHandle修改我们的MyInput组件。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="f236" class="ls lt iq nj b gy nn no l np nq">const MyInput = forwardRef((props, ref) =&gt; {<br/>  const realInputRef = useRef(null);<br/>  useImperativeHandle(ref, () =&gt; ({<br/>    focus() {<br/>      realInputRef.current.focus();<br/>    },<br/>  }));<br/>  return &lt;input {...props} ref={realInputRef} /&gt;;<br/>});</span></pre><p id="b706" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，表单组件只能通过inputRef.current获取以下数据结构。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="31a0" class="ls lt iq nj b gy nn no l np nq">{<br/>  focus() {<br/>    realInputRef.current.focus();<br/>  },<br/>}</span></pre><p id="230b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这消除了这样的情况，即开发人员通过ref获得DOM，然后执行不应该使用的API，ref失去控制。</p><h2 id="92cc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">摘要</h2><p id="fd27" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">通常情况下，ref的使用相对较少，它是作为一个逃生出口而存在的。</p><ul class=""><li id="ba9e" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">为了防止误用/滥用导致ref失控，React限制ref在默认情况下不能跨组件传递。</li><li id="60f9" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">要打破这种限制，可以使用forwardRef。</li><li id="9b7a" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">为了减少对DOM上ref的误用，可以使用useImperativeHandle来限制ref传递的数据结构。</li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="d0ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">欢迎关注我上</em></strong><a class="ae kv" href="https://twitter.com/yanghui0324" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">Twitter</em></strong></a><strong class="ky ir"><em class="mq"/></strong><a class="ae kv" href="https://www.linkedin.com/in/hui-yang-075076245/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">LinkedIn</em></strong></a><strong class="ky ir"><em class="mq">，以及</em></strong><a class="ae kv" href="https://github.com/guchen-yh" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">GitHub</em></strong><strong class="ky ir"><em class="mq">！</em> </strong></a></p><p id="9eec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写作一直是我的激情所在，它给了我帮助和激励他人的快乐。如果您有任何问题，请随时联系我们！ </p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="9653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">说白了就是</em> </strong> </a> <em class="mq">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">免费周报</em> </strong> </a> <em class="mq">。关注我们关于</em> <a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">推特</em> </strong> </a>，<a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">LinkedIn</em></strong></a><em class="mq">，</em><a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mq">YouTube</em></strong></a><em class="mq">，以及</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">不和</em> </strong></a></p></div></div>    
</body>
</html>