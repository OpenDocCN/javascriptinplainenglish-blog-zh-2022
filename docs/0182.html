<html>
<head>
<title>Angular Material Menu: Nested Menu Using Dynamic Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度材质菜单:使用动态数据的嵌套菜单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-material-menu-nested-menu-using-dynamic-data-5d97e23c0693?source=collection_archive---------16-----------------------#2022-01-11">https://javascript.plainenglish.io/angular-material-menu-nested-menu-using-dynamic-data-5d97e23c0693?source=collection_archive---------16-----------------------#2022-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f1ec" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何从动态数据创建嵌套菜单</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6e4d68cc2ead9348805bea0dfc7c4f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9_K-wCLs2OQaoDcplUHvQ.jpeg"/></div></div></figure><blockquote class="ko"><p id="f52d" class="kp kq in bd kr ks kt ku kv kw kx ky dk translated">“角度材质”菜单是一个包含选项列表的浮动面板。在本教程中，我们将学习如何从动态数据中创建嵌套菜单。</p></blockquote><p id="8a23" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt ky ig bi translated">我们将首先学习Angular Material菜单的基础知识，以及如何使用静态HTML模板渲染嵌套菜单。</p><p id="8b4d" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">然后我们将理解为什么以及需要什么样的改变来从数据中动态地呈现嵌套菜单。</p><h2 id="bc3a" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">角度材料菜单</h2><p id="4773" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated"><code class="fe mx my mz na b"><a class="ae nb" href="https://material.angular.io/components/menu/overview" rel="noopener ugc nofollow" target="_blank">&lt;mat-menu&gt;</a></code>是一个包含选项列表的浮动面板。元素本身并不呈现任何东西。菜单通过应用<code class="fe mx my mz na b">matMenuTriggerFor</code>指令来附加和打开:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="137f" class="lz ma in na b gy ng nh l ni nj">&lt;button mat-button [matMenuTriggerFor]="menu"&gt;Menu&lt;/button&gt;<br/>&lt;mat-menu #menu="matMenu"&gt;<br/>  &lt;button mat-menu-item&gt;Item 1&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Item 2&lt;/button&gt;<br/>&lt;/mat-menu&gt;</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/b071258d22e1e0b196435971e0b8d338.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/0*s5yd9fv519jXIyFH.gif"/></div></figure><h2 id="d649" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">静态嵌套菜单</h2><p id="7273" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">为了用静态数据或简单地从HTML模板中呈现嵌套菜单，除了在触发子菜单的<code class="fe mx my mz na b">mat-menu-item</code>上设置<code class="fe mx my mz na b">[matMenuTriggerFor]</code>之外，我们还必须定义根菜单和子菜单:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="9676" class="lz ma in na b gy ng nh l ni nj">&lt;button mat-button [matMenuTriggerFor]="animals"&gt;Animal index&lt;/button&gt;<br/><br/>&lt;mat-menu #animals="matMenu"&gt;<br/>  &lt;button mat-menu-item [matMenuTriggerFor]="vertebrates"&gt;Vertebrates&lt;/button&gt;<br/>&lt;/mat-menu&gt;<br/><br/>&lt;mat-menu #vertebrates="matMenu"&gt;<br/>  &lt;button mat-menu-item [matMenuTriggerFor]="fish"&gt;Fishes&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Amphibians&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Reptiles&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Birds&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Mammals&lt;/button&gt;<br/>&lt;/mat-menu&gt;<br/><br/>&lt;mat-menu #fish="matMenu"&gt;<br/>  &lt;button mat-menu-item&gt;Baikal oilfish&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Bala shark&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Ballan wrasse&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Bamboo shark&lt;/button&gt;<br/>  &lt;button mat-menu-item&gt;Banded killifish&lt;/button&gt;<br/>&lt;/mat-menu&gt;</span></pre><p id="d4a9" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">输出如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d8b8d31375c2592e1cbee59bf2bbb682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*iDNAA8vkzc9yoLWL.gif"/></div></figure><h2 id="7f03" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">动态嵌套菜单</h2><p id="9e47" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">经常需要从动态数据构建菜单，尤其是在商业或企业应用程序中。例如，根据登录用户的权限加载特性。数据可能来自REST API。</p><p id="d2c3" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">我们将举一个例子，从数据库中加载条目及其子条目。我们将为每一个有孩子的项目呈现一个嵌套菜单。</p><h2 id="9c2a" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">数据库ˌ资料库</h2><p id="b790" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">对于数据库，我们将假设以下服务。您也可以将实际的REST API与该服务连接起来:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="50ea" class="lz ma in na b gy ng nh l ni nj">import { Injectable } from "@angular/core";<br/>import { delay, of } from "rxjs";<br/><br/>@Injectable({ providedIn: "root" })<br/>export class DynamicDatabase {<br/>  dataMap = new Map&lt;string, string[]&gt;([<br/>    ["Fruits", ["Apple", "Orange", "Banana"]],<br/>    ["Vegetables", ["Tomato", "Potato", "Onion"]],<br/>    ["Apple", ["Fuji", "Macintosh"]],<br/>    ["Onion", ["Yellow", "White", "Purple"]],<br/>    ["Macintosh", ["Yellow", "White", "Purple"]],<br/>  ]);<br/><br/>  rootLevelNodes: string[] = ["Fruits", "Vegetables"];<br/><br/>  getChildren(node: string) {<br/>    // adding delay to mock a REST API call<br/>    return of(this.dataMap.get(node)).pipe(delay(1000));<br/>  }<br/><br/>  isExpandable(node: string): boolean {<br/>    return this.dataMap.has(node);<br/>  }<br/>}</span></pre><p id="6420" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">上述服务的代码很简单:</p><ul class=""><li id="38cb" class="nm nn in lb b lc lu lf lv li no lm np lq nq ky nr ns nt nu bi translated"><code class="fe mx my mz na b">dataMap</code>代表数据，这可能是实际的数据库</li><li id="554f" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky nr ns nt nu bi translated"><code class="fe mx my mz na b">rootLevelNodes</code>表示要呈现的第一个节点</li><li id="1e29" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky nr ns nt nu bi translated"><code class="fe mx my mz na b">getChildren</code>将返回特定节点的项目。我们将使用它来呈现子菜单项</li><li id="5f6f" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky nr ns nt nu bi translated"><code class="fe mx my mz na b">isExpandable</code>将返回是否有孩子。我们将用它来确定是否需要一个子菜单</li></ul><h2 id="2918" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">嵌套菜单</h2><p id="d3ab" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">现在明白了，动态数据不能简单的按照<code class="fe mx my mz na b">MatMenu</code>的标准HTML模板。以下是原因:</p><ol class=""><li id="b0f6" class="nm nn in lb b lc lu lf lv li no lm np lq nq ky oa ns nt nu bi translated">我们不能加载<code class="fe mx my mz na b">&lt;mat-menu&gt;</code>，直到我们知道这个项目有子项目</li><li id="90d3" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky oa ns nt nu bi translated">直到<code class="fe mx my mz na b">&lt;mat-menu&gt;</code>被加载到DOM中，我们才能将<code class="fe mx my mz na b">[matMenuTrigger]</code>附加到<code class="fe mx my mz na b">mat-menu-item</code></li></ol><p id="5b54" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">因此，为了处理上述问题，我们将依次遵循以下方法:</p><ol class=""><li id="59c1" class="nm nn in lb b lc lu lf lv li no lm np lq nq ky oa ns nt nu bi translated">从节点列表中读取节点</li><li id="acc7" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky oa ns nt nu bi translated">检查是否有任何节点可扩展</li><li id="9340" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky oa ns nt nu bi translated">如果是，那么用loader创建一个子菜单<code class="fe mx my mz na b">&lt;mat-menu&gt;</code>，并在渲染节点的<code class="fe mx my mz na b">mat-menu-item</code>中用<code class="fe mx my mz na b">[matMenuTrigger]</code>附加它</li><li id="85c4" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky oa ns nt nu bi translated">一旦用户单击节点，获取并呈现子菜单中的子节点</li><li id="454f" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky oa ns nt nu bi translated">对于子菜单的子节点，同样遵循相同的方法，从步骤2开始</li><li id="4621" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky oa ns nt nu bi translated">如果没有，那么只需创建节点的<code class="fe mx my mz na b">mat-menu-item</code></li></ol><h2 id="a7a8" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">根组件</h2><p id="b6b4" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">为了实现上述方法，我们将创建一个<code class="fe mx my mz na b">app-menu</code>组件，并在<code class="fe mx my mz na b">app-root</code>中使用它:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="452e" class="lz ma in na b gy ng nh l ni nj">&lt;!-- src/app/app.component.html --&gt;<br/><br/>&lt;app-menu<br/>  [trigger]="'Food'"<br/>  [data]="initialData"<br/>  [isRootNode]="true"<br/>&gt;&lt;/app-menu&gt;</span><span id="d85c" class="lz ma in na b gy ob nh l ni nj">// src/app/app.component.ts<br/><br/>import { Component } from "@angular/core";<br/>import { DynamicDatabase } from "./dynamic-database.service";<br/><br/>@Component({<br/>  selector: "app-root",<br/>  templateUrl: "app.component.html",<br/>})<br/>export class AppComponent {<br/>  title = "mat-menu-dynamic-data";<br/>  initialData: string[] = [];<br/>  constructor(private database: DynamicDatabase) {<br/>    this.initialData = this.database.rootLevelNodes.slice();<br/>  }<br/>}</span></pre><p id="c2b4" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">我们正在读取<code class="fe mx my mz na b">rootLevelNodes</code>，并在<code class="fe mx my mz na b">app-menu</code>中将其作为<code class="fe mx my mz na b">data</code>传递。</p><h2 id="ee22" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">菜单组件</h2><p id="90ae" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">对于菜单，最初，我们希望显示一个按钮，它将触发一个菜单:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="92c1" class="lz ma in na b gy ng nh l ni nj">&lt;!-- src/app/menu/menu.component.html --&gt;<br/><br/>&lt;button mat-button [matMenuTriggerFor]="menu"&gt;<br/>  {{ trigger }}<br/>&lt;/button&gt;<br/>&lt;mat-menu #menu="matMenu"&gt;<br/>  &lt;button mat-menu-item *ngFor="let node of data"&gt;{{ node }}&lt;/button&gt;<br/>&lt;/mat-menu&gt;</span></pre><p id="83e0" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">这个类看起来是这样的:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="3887" class="lz ma in na b gy ng nh l ni nj">// src/app/menu/menu.component.ts<br/><br/>export class MenuComponent {<br/>  @Input() data: string[] = [];<br/>  @Input() trigger = "Trigger";<br/>  @Input() isRootNode = false;<br/>}</span></pre><h2 id="27ad" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">递归</h2><p id="a167" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">现在，要呈现一个嵌套菜单，我们只需要在这段代码中处理递归。并为每个嵌套菜单生成相同的DOM结构。</p><p id="31af" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">因此，首先，我们将更改<code class="fe mx my mz na b">&lt;mat-menu&gt;</code>中的代码:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="ee49" class="lz ma in na b gy ng nh l ni nj">&lt;!-- src/app/menu/menu.component.html --&gt;<br/><br/>&lt;button mat-button [matMenuTriggerFor]="menu"&gt;<br/>  {{ trigger }}<br/>&lt;/button&gt;<br/>&lt;mat-menu #menu="matMenu"&gt;<br/>  &lt;ng-container *ngFor="let node of data; let i = index"&gt;<br/>    &lt;button mat-menu-item&gt;<br/>      &lt;app-menu<br/>        [trigger]="node"<br/>        *ngIf="isExpandable(node); else menuItem"<br/>      &gt;&lt;/app-menu&gt;<br/>    &lt;/button&gt;<br/>    &lt;ng-template #menuItem&gt;<br/>      &lt;button mat-menu-item&gt;{{ node }}&lt;/button&gt;<br/>    &lt;/ng-template&gt;<br/>  &lt;/ng-container&gt;<br/>&lt;/mat-menu&gt;</span></pre><p id="79f1" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">现在，在菜单内部，我们正在检查每个节点，如果<code class="fe mx my mz na b">isExpandable</code>方法返回<code class="fe mx my mz na b">true</code>，我们将在其中再次呈现<code class="fe mx my mz na b">app-menu</code>。</p><p id="efe9" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated"><code class="fe mx my mz na b">isExpandable</code>方法将简单地从<code class="fe mx my mz na b">DynamicDatabase</code>服务中调用<code class="fe mx my mz na b">isExpandable</code>:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="b69d" class="lz ma in na b gy ng nh l ni nj">// src/app/menu/menu.component.ts<br/><br/>// ...<br/><br/>export class MenuComponent {<br/><br/>  // ...<br/><br/>  isExpandable(node: string): boolean {<br/>    return this.database.isExpandable(node);<br/>  }<br/>}</span></pre><p id="f33e" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">让我们看看输出:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/636717cdba6bb4e05fb6fca919477ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/0*7LCUqjsKEQTrWKZ0.gif"/></div></figure><p id="69f6" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">请注意，文本也可以在<code class="fe mx my mz na b">mat-menu-item</code>中悬停。那是因为<code class="fe mx my mz na b">mat-button</code>。当<code class="fe mx my mz na b">app-menu</code>在内部渲染时，我们必须将按钮的指令从<code class="fe mx my mz na b">mat-button</code>更改为<code class="fe mx my mz na b">mat-menu-item</code>，让我们这样做:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="9ee7" class="lz ma in na b gy ng nh l ni nj">&lt;!-- src/app/menu/menu.component.html --&gt;<br/><br/>&lt;button *ngIf="isRootNode" mat-button [matMenuTriggerFor]="menu"&gt;<br/>  {{ trigger }}<br/>&lt;/button&gt;<br/>&lt;button *ngIf="!isRootNode" mat-menu-item [matMenuTriggerFor]="menu"&gt;<br/>  {{ trigger }}<br/>&lt;/button&gt;<br/>&lt;mat-menu #menu="matMenu"&gt;<br/>  &lt;ng-container *ngFor="let node of data; let i = index"&gt;<br/>    &lt;button mat-menu-item&gt;<br/>      &lt;app-menu<br/>        [trigger]="node"<br/>        *ngIf="isExpandable(node); else menuItem"<br/>      &gt;&lt;/app-menu&gt;<br/>    &lt;/button&gt;<br/>    &lt;ng-template #menuItem&gt;<br/>      &lt;button mat-menu-item&gt;{{ node }}&lt;/button&gt;<br/>    &lt;/ng-template&gt;<br/>  &lt;/ng-container&gt;<br/>&lt;/mat-menu&gt;</span></pre><p id="9ef1" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">现在让我们看看输出:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b6597df610069a80b03ad7c666e4d33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/0*6ppQ3OZEr5olYHZz.gif"/></div></figure><p id="9e3f" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">它现在很好地呈现了根项目，但是子菜单是空白的。让我们给它添加数据。</p><h2 id="bc60" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">数据</h2><p id="1b43" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">我们希望在呈现并打开菜单后加载数据。所以，我们将使用<code class="fe mx my mz na b">(menuOpened)</code>事件来加载<code class="fe mx my mz na b">data</code>。<code class="fe mx my mz na b">menuOpened</code>当相关菜单打开时发出事件。</p><p id="aeb1" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">我们只想为非根项目加载<code class="fe mx my mz na b">data</code>，因为对于根项目，<code class="fe mx my mz na b">data</code>来自父组件。</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="d9b1" class="lz ma in na b gy ng nh l ni nj">&lt;!-- src/app/menu/menu.component.html --&gt;<br/><br/>&lt;button *ngIf="isRootNode" mat-button [matMenuTriggerFor]="menu"&gt;<br/>  {{ trigger }}<br/>&lt;/button&gt;<br/>&lt;button<br/>  *ngIf="!isRootNode"<br/>  mat-menu-item<br/>  [matMenuTriggerFor]="menu"<br/>  (menuOpened)="getData(trigger)"<br/>&gt;<br/>  {{ trigger }}<br/>&lt;/button&gt;<br/><br/>&lt;!-- rest remains same --&gt;</span></pre><p id="86c7" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">让我们在<code class="fe mx my mz na b">menu.component.ts</code>中创建一个<code class="fe mx my mz na b">getData</code>方法:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="c316" class="lz ma in na b gy ng nh l ni nj">// src/app/menu/menu.component.ts<br/><br/>// ...<br/>export class MenuComponent {<br/>  // ...<br/><br/>  isLoading = false;<br/>  dataLoaded = false;<br/><br/>  getData(node: string) {<br/>    if (!this.dataLoaded) {<br/>      this.isLoading = true;<br/>      this.database.getChildren(node).subscribe((d) =&gt; {<br/>        this.data = d?.slice() || [];<br/>        this.isLoading = false;<br/>        this.dataLoaded = true;<br/>      });<br/>    }<br/>  }<br/>}</span></pre><p id="dfdd" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">通过<code class="fe mx my mz na b">getData</code>，我们又创建了2个标志:</p><ol class=""><li id="8ba0" class="nm nn in lb b lc lu lf lv li no lm np lq nq ky oa ns nt nu bi translated"><code class="fe mx my mz na b">isLoading</code> -指示是否正在获取<code class="fe mx my mz na b">data</code></li><li id="7afc" class="nm nn in lb b lc nv lf nw li nx lm ny lq nz ky oa ns nt nu bi translated"><code class="fe mx my mz na b">dataLoaded</code> -指示<code class="fe mx my mz na b">data</code>是否已经加载并阻止进一步的提取</li></ol><p id="e0ef" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">现在让我们看看输出:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ea5f5134641720e44a7c8781b213dda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*J_WpBszzqogIKdwD.gif"/></div></figure><p id="e80f" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">请注意，数据在特定时间后被加载，这是因为我们在<code class="fe mx my mz na b">DynamicDatabase.getChildren</code>中添加了一个<code class="fe mx my mz na b">delay</code>来模拟一个API调用。如果数据已经加载，并且在这种情况下菜单项被立即呈现，它就不会再次获取数据。</p><h2 id="4db5" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">装货设备</h2><p id="996b" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">最后剩下的事情是当<code class="fe mx my mz na b">data</code>被获取时显示一个加载器。我们已经有了<code class="fe mx my mz na b">isLoading</code>标志，让我们用它来显示<code class="fe mx my mz na b"><a class="ae nb" href="https://material.angular.io/components/progress-spinner/overview" rel="noopener ugc nofollow" target="_blank">&lt;mat-spinner&gt;</a></code>:</p><pre class="kd ke kf kg gt nc na nd ne aw nf bi"><span id="aa3e" class="lz ma in na b gy ng nh l ni nj">&lt;!-- src/app/menu/menu.component.html --&gt;<br/><br/>&lt;!-- rest remains same --&gt;<br/><br/>&lt;mat-menu #menu="matMenu"&gt;<br/>  &lt;button<br/>    mat-menu-item<br/>    *ngIf="isLoading"<br/>    style="display: flex; justify-content: center; align-items: center"<br/>  &gt;<br/>    &lt;mat-spinner mode="indeterminate" diameter="24"&gt;&lt;/mat-spinner&gt;<br/>  &lt;/button&gt;<br/>  &lt;ng-container *ngFor="let node of data; let i = index"&gt;<br/>    &lt;!-- rest remains same --&gt;<br/>  &lt;/ng-container&gt;<br/>&lt;/mat-menu&gt;</span></pre><p id="c19f" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">请注意，我添加了一些内嵌样式，以便<code class="fe mx my mz na b">&lt;mat-spinner&gt;</code>显示在<code class="fe mx my mz na b">mat-menu-item</code>的中心。</p><p id="2104" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">现在让我们看看输出:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5cc96cdcad968ca756961949aa6e3090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*aTM8QTrTxig-t9Ul.gif"/></div></figure><h2 id="ca91" class="lz ma in bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">摘要</h2><p id="60a1" class="pw-post-body-paragraph kz la in lb b lc ms jo le lf mt jr lh li mu lk ll lm mv lo lp lq mw ls lt ky ig bi translated">我们从一个简单的菜单示例开始，使用静态HTML模板呈现嵌套菜单。</p><p id="618c" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">然后，我们理解了嵌套菜单中动态数据的需要，以及用简单的HTML模板实现动态性的问题。</p><p id="b57a" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">然后我们创建了一个<code class="fe mx my mz na b">app-menu</code>组件。首先，我们加载了一个带有根项目的菜单，作为来自父组件的<code class="fe mx my mz na b">data</code>输入。</p><p id="715a" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">然后我们处理递归，基于<code class="fe mx my mz na b">isExpandable</code>标志在<code class="fe mx my mz na b">app-menu</code>内部渲染<code class="fe mx my mz na b">app-menu</code>。接下来我们实现了基于<code class="fe mx my mz na b">menuOpened</code>事件获取数据，最后我们在获取数据时显示了一个加载器。</p><p id="d503" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated">所有上述代码可在GitHub repo上找到:<a class="ae nb" href="https://github.com/shhdharmen/mat-menu-dynamic-data" rel="noopener ugc nofollow" target="_blank"> mat-menu-dynamic-data </a>。</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><p id="5055" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated"><em class="ok">原为发表于</em> <a class="ae nb" href="https://indepth.dev/tutorials/angular/angular-material-nested-menu-dynamic-data" rel="noopener ugc nofollow" target="_blank"> <em class="ok">的深度文章</em> </a> <em class="ok">。</em></p><p id="f94d" class="pw-post-body-paragraph kz la in lb b lc lu jo le lf lv jr lh li lw lk ll lm lx lo lp lq ly ls lt ky ig bi translated"><em class="ok">更多内容请看</em><a class="ae nb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="ok">plain English . io</em></strong></a><em class="ok">。报名参加我们的</em> <a class="ae nb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="ok">免费周报</em> </strong> </a> <em class="ok">。在我们的</em> <a class="ae nb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lb io"> <em class="ok">社区</em> </strong> </a> <em class="ok">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>