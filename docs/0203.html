<html>
<head>
<title>React Re-Reselect: Better Memoization and Cache Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React重选:更好的内存化和缓存管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-re-reselect-better-memoization-and-cache-management-56f1fea4d3f7?source=collection_archive---------10-----------------------#2022-01-12">https://javascript.plainenglish.io/react-re-reselect-better-memoization-and-cache-management-56f1fea4d3f7?source=collection_archive---------10-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4bd5ee57eefd3040485e156f2255cd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OZc8u2fCXkWUZZAQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://www.uxpin.com/" rel="noopener ugc nofollow" target="_blank">https://www.uxpin.com/</a></figcaption></figure><p id="7ab9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管React的组件具有快速的生命周期，但它们<a class="ae kc" href="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/" rel="noopener ugc nofollow" target="_blank">会因为过度的重新渲染</a>而受损，从而影响制作时间和整体性能。而在较小的应用程序中，这些不必要的重新渲染通常不会被注意到，因为UI随着组件树上更重的组件渲染而增长，开发人员和用户都会感受到负面的副作用。</p><p id="f081" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，开发人员引入了第三方性能优化库，如<a class="ae kc" href="https://github.com/toomuchdesign/re-reselect" rel="noopener ugc nofollow" target="_blank"> re-reselect </a>，这是一个流行库<a class="ae kc" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">re-select</a>的包装器，它主要与Redux一起使用，通过编写记忆化的选择器来增强性能。在本教程中，我们将通过创建一个简单的待办事项列表应用程序来探索重新选择。</p><p id="de56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要跟随本教程，您应该熟悉反应和重新选择。我们开始吧！</p><h1 id="95a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">选择器</h1><p id="ed12" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">本质上，选择器是将Redux状态作为输入并返回从该状态派生的值的函数。在React Redux中，当调度<code class="fe me mf mg mh b">useSelector()</code>钩子的reducer动作时，它为每个挂载的组件运行，每次调度都要重新计算选择器，导致性能问题。</p><p id="a6ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们经常在选择函数中执行昂贵的计算。有些情况下，尽管调度了reducer的动作或者重新呈现了组件，但是我们的选择器看不到任何值的变化。理想情况下，选择器应该不经过任何计算就返回相同的值。</p><p id="0268" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，在React中重新渲染一个组件后，所有内容都是用新的引用创建的。因此，选择器函数必须再次执行昂贵的计算。</p><h1 id="774c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构建我们的待办事项列表应用程序</h1><p id="eba2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们用代码来看一个例子；假设我们有一个待办事项列表应用程序，其中心状态在reducer中，文件夹结构如下:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/948830992da0343d26e80cd274b14e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*xWqSN74ViT3H-SfH.png"/></div></figure><p id="05fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在项目中安装以下依赖项:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/14a68f2aba0a8abd8f208259d8928999.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/0*k99mPFjPcpOj60wL.png"/></div></figure><p id="4fee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建应用程序商店并设置入口点元素节点<code class="fe me mf mg mh b">root</code>，向<code class="fe me mf mg mh b">index.js</code>添加以下代码:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="28d3" class="ms lc iq mh b gy mt mu l mv mw">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import './index.css';<br/>import { Provider } from 'react-redux';<br/>import { createStore } from 'redux';<br/>import rootReducer from './reducers/rootReducer';<br/>import App from './App';<br/>import * as serviceWorker from './serviceWorker';</span><span id="b285" class="ms lc iq mh b gy mx mu l mv mw">const store = createStore(rootReducer)<br/></span><span id="ec59" class="ms lc iq mh b gy mx mu l mv mw">ReactDOM.render(<br/>&lt;Provider store={store}&gt;&lt;App /&gt;&lt;/Provider&gt;, document.getElementById('root'));<br/></span><span id="e7e2" class="ms lc iq mh b gy mx mu l mv mw">serviceWorker.unregister();</span></pre><p id="2704" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将生成用于呈现应用程序布局的主要表示组件。将下面的代码添加到<code class="fe me mf mg mh b">app.js</code>:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="ad6c" class="ms lc iq mh b gy mt mu l mv mw">import React from 'react';<br/>import TodoList from './views/TodoList';</span><span id="61f7" class="ms lc iq mh b gy mx mu l mv mw">function App() {</span><span id="bb84" class="ms lc iq mh b gy mx mu l mv mw">   return (<br/>       &lt;div className="App"&gt;<br/>           &lt;main className="container"&gt;<br/>               &lt;div className="divider"&gt;&lt;/div&gt;<br/>               &lt;TodoList/&gt;<br/>           &lt;/main&gt;<br/>       &lt;/div&gt;<br/>   );<br/>}</span><span id="da40" class="ms lc iq mh b gy mx mu l mv mw">export default App;</span></pre><p id="5fa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">todoReducer.js</code>包含我们的应用程序的中央状态，它是由选择器函数提取的:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="f6c3" class="ms lc iq mh b gy mt mu l mv mw">const initState = {<br/>   todoList: [<br/>       {<br/>           id: 1,<br/>           content: 'Play video game',<br/>           weight:1<br/>       }, {<br/>           id: 2,<br/>           content: 'Learn nodejs &amp; python',<br/>           weight:2</span><span id="b9a9" class="ms lc iq mh b gy mx mu l mv mw">       }, {<br/>           id: 3,<br/>           content: 'Join meetup event',<br/>           weight:3</span><span id="d3ad" class="ms lc iq mh b gy mx mu l mv mw">       }<br/>   ]<br/>}</span><span id="bd5d" class="ms lc iq mh b gy mx mu l mv mw">const todoReducer = (state = initState, action) =&gt; {<br/>   switch (action.type) {<br/>       case 'ADD_TODO':<br/>           return {<br/>               ...state,<br/>               todoList: [<br/>                   ...state.todoList,<br/>                   action.payload<br/>               ]<br/>           }<br/>       case 'REMOVE_TODO':<br/>           return {<br/>               ...state,<br/>               todoList: action.payload<br/>           }<br/>       default:<br/>           return state<br/>   }<br/>}</span><span id="b083" class="ms lc iq mh b gy mx mu l mv mw">export default todoReducer;</span></pre><p id="c993" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">rootReducer.js</code>中，我们将结合应用中的所有减速器:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="4be8" class="ms lc iq mh b gy mt mu l mv mw">import todoReducer from './todoReducer';<br/>import {combineReducers} from 'redux';</span><span id="9011" class="ms lc iq mh b gy mx mu l mv mw">//Combine all the sub reducers<br/>const rootReducer = combineReducers({<br/>   todos:todoReducer<br/>})</span><span id="52b4" class="ms lc iq mh b gy mx mu l mv mw">export default rootReducer</span></pre><p id="2f93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe me mf mg mh b">TodoItem</code>来呈现减速器的<code class="fe me mf mg mh b">todo</code>状态。每个项目都有一个十字图标，该图标将调度一个事件，根据其ID删除该特定项目:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="6629" class="ms lc iq mh b gy mt mu l mv mw">import React from 'react';<br/>import {useSelector, useDispatch} from 'react-redux';</span><span id="5b1b" class="ms lc iq mh b gy mx mu l mv mw">//Single todo item component<br/>const TodoItem = (props) =&gt; {<br/>   const todoList = useSelector(state =&gt; state.todos.todoList)<br/>   const dispatch = useDispatch();</span><span id="cd79" class="ms lc iq mh b gy mx mu l mv mw">   const removeTodoItem = (todoId) =&gt; {<br/>       let newTodoList = todoList.filter(item =&gt; item.id !== todoId);<br/>       dispatch({type: 'REMOVE_TODO', payload: newTodoList})</span><span id="09e4" class="ms lc iq mh b gy mx mu l mv mw">   }</span><span id="0efa" class="ms lc iq mh b gy mx mu l mv mw">   return (<br/>       &lt;li className="collection-item" key={props.item.id}&gt;{props.item.content}<br/>           &lt;span<br/>               onClick={() =&gt; {<br/>               removeTodoItem(props.item.id)<br/>           }}<br/>               className="secondary-content"&gt;<br/>               &lt;i className="remove-btn material-icons blue-text"&gt;clear&lt;/i&gt;<br/>           &lt;/span&gt;<br/>       &lt;/li&gt;<br/>   );<br/>}</span><span id="9d0b" class="ms lc iq mh b gy mx mu l mv mw">export default TodoItem;</span></pre><p id="2000" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将创建一个名为<code class="fe me mf mg mh b">TodoList.js</code>的组件，在这里我们调用我们的选择器以及一个空节点列表，使得该组件可以扩展到DOM:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="73ed" class="ms lc iq mh b gy mt mu l mv mw">import React,{useState} from 'react';<br/>import { useSelector,useDispatch } from 'react-redux';<br/>import TodoItem from '../components/TodoItem';<br/></span><span id="6709" class="ms lc iq mh b gy mx mu l mv mw">const TodoList = () =&gt; {<br/></span><span id="0744" class="ms lc iq mh b gy mx mu l mv mw"> const todoList = useSelector(state =&gt; state.todos.todoList.filter(todo =&gt; todo.content.includes('a')));<br/></span><span id="f3bc" class="ms lc iq mh b gy mx mu l mv mw"> const dispatch = useDispatch();</span><span id="6178" class="ms lc iq mh b gy mx mu l mv mw"> const [inputTodo,setInputTodo] =  useState('');</span><span id="2b67" class="ms lc iq mh b gy mx mu l mv mw"> const handleInput = (e)=&gt;{<br/>   setInputTodo(e.target.value);<br/> }</span><span id="063a" class="ms lc iq mh b gy mx mu l mv mw"> //Handle onClick event<br/> const addNewTodo = ()=&gt;{<br/>   //Valid input value<br/>        let newTodoObject={<br/>           id: Math.random(),<br/>           content:inputTodo,<br/>           weight:Math.random(),</span><span id="18d2" class="ms lc iq mh b gy mx mu l mv mw">       }<br/>        //Add new todo item into List with the action<br/>       dispatch({type:'ADD_TODO',payload:newTodoObject});<br/>       setInputTodo('');<br/>         function returnBlankNodes(){<br/>           let nodes = [];<br/>                   for (let i=0;i&lt;10000;i++) {<br/>                   nodes.push(&lt;p&gt;&lt;/p&gt;)<br/>   }<br/>                   return nodes<br/> }<br/> }</span><span id="fed5" class="ms lc iq mh b gy mx mu l mv mw">   return (   <br/>       &lt;section id="section-todo"&gt;<br/>       &lt;h3 className="center-align white-text blue"&gt;Todo List&lt;/h3&gt;<br/>       {<br/>           todoList.length&gt;0?<br/>           (&lt;ul className="collection"&gt;<br/>           {<br/>             todoList.map(item =&gt; {<br/>               return &lt;TodoItem key={item.id} item={item} /&gt;<br/>             })<br/>           }<br/>         &lt;/ul&gt;):<br/>         (&lt;p className="center-align"&gt;You don't have anything to do! Awesome!&lt;/p&gt;)<br/>       }</span><span id="89df" class="ms lc iq mh b gy mx mu l mv mw">       &lt;div className="row"&gt;<br/>       &lt;p className="red-text err-msg col s12 center-align"&gt;<br/>       &lt;/p&gt;<br/>       &lt;div className="input-field col s10"&gt;<br/>       &lt;input onChange={handleInput} value={inputTodo} placeholder="Add todo..." id="todo-input" type="text" /&gt;<br/>       &lt;label htmlFor="todo-input" className="active"&gt;New Todo&lt;/label&gt;<br/>       &lt;/div&gt;</span><span id="1310" class="ms lc iq mh b gy mx mu l mv mw">       &lt;button className="btn col s2 blue" onClick={addNewTodo} &gt;Add&lt;/button&gt;<br/>       &lt;/div&gt;<br/>       {returnBlankNodes()}</span><span id="6cb3" class="ms lc iq mh b gy mx mu l mv mw">     &lt;/section&gt;<br/>     );<br/>}<br/>export default TodoList;</span></pre><p id="c4bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从我们的商店中取出<code class="fe me mf mg mh b">todoList</code>，并在浏览器上呈现组件。然后由<code class="fe me mf mg mh b">todoList</code>选择器提取列表，并对其进行过滤。</p><p id="d8c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，<code class="fe me mf mg mh b">todoList</code>会在每次渲染时重新计算。每当我们在文本字段中输入任何内容时，组件的状态都会改变。理想情况下，选择器应该只在我们对Redux存储进行更改时运行，例如，当我们添加一个新的待办事项时。</p><p id="75c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的Redux store中有数百个商品，那么<code class="fe me mf mg mh b">todoList</code>选择器将会占用大量CPU资源。在这些情况下，我们必须使用memoization，只有当我们的存储中的<code class="fe me mf mg mh b">todoList</code>的值发生变化时，它才会运行选择器。</p><h1 id="5cb0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么要重新选择？</h1><p id="5799" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用重选来创建记忆选择器。结果将被存储在内存中，只有在值不变的情况下才会被提取。每个选择器都有自己的内存，这意味着它不能缓存多个选择器。</p><h1 id="52a6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重新选择示例</h1><p id="f217" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了更好地理解这一点，让我们考虑下面的另一个例子:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="8bbb" class="ms lc iq mh b gy mt mu l mv mw">import { createSelector } from 'reselect'</span><span id="62e6" class="ms lc iq mh b gy mx mu l mv mw">const getTodosSelector = state =&gt; state.todos.todoList</span><span id="0eff" class="ms lc iq mh b gy mx mu l mv mw">const getTodosWithLetter = createSelector(<br/>   getTodosSelector,<br/>   (state,Letter)=&gt;Letter,<br/>   (toDos,Letter) =&gt; toDos.filter(todo.content.includes(Letter))<br/>)<br/>const a=getTodosWithLetter(state,’a’) //cache created<br/>const e=getTodosWithLetter(state,’e’)  //cache invalidated<br/>const a_again=getTodosWithLetter(state,’a’) //cache created again.</span><span id="9cc8" class="ms lc iq mh b gy mx mu l mv mw">a!===a_again.</span></pre><p id="4d41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码片段中，我们使用Reselect创建了一个选择器，它接受一个字母表并基于它过滤结果。目前，所有英文字母共享一个选择器，但是，选择器只能缓存一个字母。</p><p id="d7db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以为每个字母创建选择器，但是这种方法很繁琐。正如我们在上面看到的，我们有<code class="fe me mf mg mh b">a</code>、<code class="fe me mf mg mh b">e</code>和<code class="fe me mf mg mh b">a_again</code>。首先，选择器为字母<code class="fe me mf mg mh b">a</code>创建一个缓存，但是在提供了一个不同的字母之后，缓存失效，并为字母<code class="fe me mf mg mh b">e</code>创建一个新的缓存。理想情况下，用不同的字母创建一个选择器应该会添加一个新的缓存，而不会覆盖以前的缓存。</p><h1 id="2685" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重新选择示例</h1><p id="8132" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">相反，让我们用重新选择重写上面的代码，如下所示:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="6142" class="ms lc iq mh b gy mt mu l mv mw">import {createCachedSelector} from 're-reselect';</span><span id="363e" class="ms lc iq mh b gy mx mu l mv mw">const getTodosSelector = state =&gt; state.todos.todoList</span><span id="14f7" class="ms lc iq mh b gy mx mu l mv mw">const getTodosWithLetter = createCachedSelector(<br/>   getTodosSelector,<br/>   (state,Letter)=&gt;Letter,<br/>   (toDos,Letter) =&gt; toDos.filter(todo.content.includes(Letter))<br/>)(<br/> (state, Letter) =&gt; Letter // Cache selectors by Letter name<br/>);</span><span id="9408" class="ms lc iq mh b gy mx mu l mv mw">const a=getTodosWithLetter(state,'a') //cache created<br/>const e=getTodosWithLetter(state,'e')  //new cache created<br/>const a_again=getTodosWithLetter(state,'a') //fetched from cache<br/>// memoization is preserved among different components</span></pre><p id="df77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用上面的代码，我们必须简单地导入<code class="fe me mf mg mh b">createCachedSelector</code>。请注意，语法几乎类似于Reselect。</p><p id="a088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们必须告诉选择器关于缓存的标准。在上面的代码中，我们用字母名称指定了它。不是销毁以前的缓存，而是为单个选择器创建一个新的缓存。</p><p id="fee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重选已经很有性能了，但是重选通过引入深度缓存管理更进了一步。在上面的例子中，我们创建了三个选择器。</p><p id="55f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们之前使用Reselect时，我们的过滤器运行了三次，因为新的缓存不断被重新创建。然而，使用重选，我们的过滤器只运行了两次。使用<code class="fe me mf mg mh b">a_again</code>，它从我们的缓存中根据信件获取数据。</p><h1 id="6edf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将重新选择添加到我们的待办事项列表应用程序</h1><p id="0d30" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了将重新选择与React Redux集成，让我们创建一个名为<code class="fe me mf mg mh b">todoSelector.js</code>的新文件，并添加以下代码:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="6b9d" class="ms lc iq mh b gy mt mu l mv mw">// todoSelector.js</span><span id="0539" class="ms lc iq mh b gy mx mu l mv mw">import {createCachedSelector} from 're-reselect';</span><span id="d4c8" class="ms lc iq mh b gy mx mu l mv mw">export const getTodosSelector = state =&gt; state.todos.todoList</span><span id="2951" class="ms lc iq mh b gy mx mu l mv mw">export const  getTodosWithLetter = createCachedSelector(</span><span id="504a" class="ms lc iq mh b gy mx mu l mv mw">    getTodosSelector,<br/>    (state,Letter)=&gt;Letter,<br/>    (todoList,Letter) =&gt; todoList.filter(todo=&gt;todo.content.includes(Letter))<br/> )(<br/>  (state, Letter) =&gt; Letter // Cache selectors by Letter name<br/> );</span></pre><p id="10ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">TodoList.js</code>导入如下:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="1e9b" class="ms lc iq mh b gy mt mu l mv mw">import { getTodosWithLetter } from './todoSelector';<br/>const todoList = useSelector(state=&gt;getTodosWithLetter(state,'a'));</span></pre><h1 id="d5d7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">输出</h1><p id="0b71" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们在浏览器中运行该项目以查看结果。通过运行以下命令启动项目:</p><pre class="mj mk ml mm gt mo mh mp mq aw mr bi"><span id="5670" class="ms lc iq mh b gy mt mu l mv mw">yarn start</span></pre><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/92e749c4191ab4d2886efe3bae5d832f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*aH1yjamesri9NDn5.gif"/></div></figure><p id="7c3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧，我们已经成功地添加了一个带有重选功能的缓存选择器！</p><h1 id="1aab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="32bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本文中，我们学习了如何创建具有深度管理缓存的选择器。我们构建了一个示例待办事项列表应用程序，其中包含一个在每次重新呈现时都会重新计算的组件。在集成了re-reselect之后，只有当我们在Redux存储中进行更改时，选择器才会运行。</p><p id="a861" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的项目中有昂贵的选择器，重新选择可以极大地提高您的应用程序的性能，特别是如果您有一个更大的应用程序。我希望你喜欢这个教程。</p><blockquote class="mz na nb"><p id="0a41" class="kd ke nc kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">帖子最初发表在<a class="ae kc" href="https://blog.logrocket.com/why-you-should-use-swc/" rel="noopener ugc nofollow" target="_blank"> LogRocket博客</a></p></blockquote><p id="c69d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nc">更多内容看</em> <a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nc">说白了就是io </em> </strong> </a> <em class="nc">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。在我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nc">社区不和谐</em> </strong> </a> <em class="nc">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>