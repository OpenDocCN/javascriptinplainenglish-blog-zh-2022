<html>
<head>
<title>Identify JavaScript Data Types: Two Methods are Enough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">识别JavaScript数据类型:两种方法就足够了</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/identify-javascript-data-types-two-methods-are-enough-882e2c238e6b?source=collection_archive---------9-----------------------#2022-06-24">https://javascript.plainenglish.io/identify-javascript-data-types-two-methods-are-enough-882e2c238e6b?source=collection_archive---------9-----------------------#2022-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7831" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我们知道，JavaScript数据类型包括原语类型和对象类型。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2c253caf27919f041b464d2bba20d226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_ZDRMLFUVaIO38p9Qkzvw.jpeg"/></div></div></figure><ul class=""><li id="7497" class="ko kp in kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="kq io">原始类型</strong>:空、未定义、数字、字符串、布尔、符号、BigInt</li><li id="e32e" class="ko kp in kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated"><strong class="kq io">对象类型:</strong>对象</li></ul><p id="6122" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">对象类型有很多特殊类型，如<code class="fe ly lz ma mb b"> Function</code>、<code class="fe ly lz ma mb b">Array</code>、<code class="fe ly lz ma mb b">RegExp</code>、<code class="fe ly lz ma mb b">Math</code>、<code class="fe ly lz ma mb b">Date</code>、<code class="fe ly lz ma mb b">Error</code>、<code class="fe ly lz ma mb b">Set</code>、<code class="fe ly lz ma mb b">Map</code>，各种定型数组、<code class="fe ly lz ma mb b">TypedArray</code>等。本文的目标是识别对象类型的基本类型和特殊类型。</p><p id="a176" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">你知道JavaScript中有多少种检测数据类型的方法吗？大多数人会告诉你以下4种方法。</p><ul class=""><li id="7b0a" class="ko kp in kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">类型of</li><li id="f60e" class="ko kp in kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">实例of</li><li id="15f3" class="ko kp in kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">构造器</li><li id="2364" class="ko kp in kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">Object.prototype.toString.call()</li></ul><p id="9f2f" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">但是深入研究之后，你会发现它们每一个都可以用来识别数据类型，但是每一个都不能完全识别正确的数据类型。今天我要告诉你，你可以掌握<code class="fe ly lz ma mb b">typeof</code>和<code class="fe ly lz ma mb b">Object.prototype.toString.call()</code> <strong class="kq io"> </strong>这两种数据类型，这样你就可以把后面的其他方法提升了。</p><p id="5f4d" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">首先，我们来看看<code class="fe ly lz ma mb b">typeof</code>方法。</p><h1 id="34e5" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">类型of</h1><pre class="kd ke kf kg gt mu mb mv mw aw mx bi"><span id="b317" class="my md in mb b gy mz na l nb nc">typeof 'a'           // 'string'<br/>typeof 1             // 'number' <br/>typeof NaN           // 'number'<br/>typeof Infinity      // 'number'           <br/><br/>typeof true          // 'boolean'<br/>typeof undefined     // 'undefined'<br/>typeof Symbol('a')   // 'symbol'<br/>typeof 1n            // 'bigint'<br/>typeof null          // 'object'<br/><br/>typeof function() {} // 'function'<br/>typeof []            // 'object'<br/>typeof {}            // 'object'<br/>typeof /a/           // 'object'<br/>typeof new Date()    // 'object'<br/>typeof new Error()   // 'object'<br/>typeof new Map()     // 'object'<br/>typeof new Set()     // 'object'</span></pre><p id="fd6e" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">上面的代码显示了两件事:</p><ul class=""><li id="b275" class="ko kp in kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><code class="fe ly lz ma mb b">typeof</code>可以检测基本数据类型，除了<code class="fe ly lz ma mb b"><strong class="kq io">Nan</strong></code>和<code class="fe ly lz ma mb b"><strong class="kq io">Infinity</strong></code></li><li id="799f" class="ko kp in kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated"><code class="fe ly lz ma mb b">typeof</code>将所有对象视为Object类型，即使<code class="fe ly lz ma mb b"><strong class="kq io">NULL</strong></code>在语义上不是对象</li></ul><p id="4d47" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated"><code class="fe ly lz ma mb b">typeof</code>无法准确检测到<code class="fe ly lz ma mb b"><strong class="kq io">Infinity</strong></code>和<code class="fe ly lz ma mb b"><strong class="kq io">NaN</strong></code>，所以需要分别处理这两个。幸运的是，从ES3开始，Window对象提供了两种方法来检测这两个特殊值——分别是<code class="fe ly lz ma mb b"><strong class="kq io">Window.isNaN</strong></code>和<code class="fe ly lz ma mb b"><strong class="kq io">Window.isFinite</strong></code>，检测一个变量是否“不是值”和一个变量是否有限。所以我们只需要把这两个分开处理，封装一个<code class="fe ly lz ma mb b">getType</code>函数就可以了。</p><pre class="kd ke kf kg gt mu mb mv mw aw mx bi"><span id="273c" class="my md in mb b gy mz na l nb nc">getType = function(arg) {<br/>    var type = typeof arg;<br/>    if (type === 'number') {<br/>        if(isNaN(arg)) return 'NaN';<br/>        if(!isFinite(arg)) return 'Infinity';<br/>        return type;<br/>    }<br/>}</span></pre><p id="5c0e" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">到目前为止，基本类型都能正确判断。如果只需要判断基本的数据类型，看到这里就够了。如果你想正确识别对象类型，那么请看下面的<code class="fe ly lz ma mb b">toString()</code>方法。</p><h1 id="65f9" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">Object.prototype.toString.call()</h1><p id="65a0" class="pw-post-body-paragraph ll lm in kq b kr nd jo ln kt ne jr lo kv nf lq lr kx ng lt lu kz nh lw lx lb ig bi translated"><code class="fe ly lz ma mb b">toString()</code>方法返回一个表示对象的字符串，我们可以把<code class="fe ly lz ma mb b">this</code>改为指向要检测的值，然后返回当前检测值的信息。</p><pre class="kd ke kf kg gt mu mb mv mw aw mx bi"><span id="6cae" class="my md in mb b gy mz na l nb nc">Object.prototype.toString.call({})            // '[object Object]'<br/>Object.prototype.toString.call(null)          // '[object Null]'<br/>Object.prototype.toString.call(Symbol('a'))   // '[object Symbol]'<br/>Object.prototype.toString.call(/a/)           // '[object RegExp]'<br/>Object.prototype.toString.call(new Date())    // '[object Date]'<br/>Object.prototype.toString.call([0, 1, 2])     // '[object Array]'<br/>Object.prototype.toString.call(function() {}) // '[object Function]'<br/>Object.prototype.toString.call(new Error())   // '[object Error]'<br/>Object.prototype.toString.call(new Set())     // '[object Set]'<br/>Object.prototype.toString.call(new Map())     // '[object Map]'</span></pre><p id="3626" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">可见<code class="fe ly lz ma mb b">toString()</code>方法可以很好的判断正确的对象类型，所以可以把它们结合在一起帮助我们。</p><pre class="kd ke kf kg gt mu mb mv mw aw mx bi"><span id="daa1" class="my md in mb b gy mz na l nb nc">const getType = function(arg){<br/>    var type = typeof arg;<br/>    if (type === 'number') {<br/>        if(isNaN(arg)) return 'NaN';<br/>        if(!isFinite(arg)) return 'Infinity';<br/>        return type;<br/>    } else {<br/>        return Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();<br/>    }<br/>}</span></pre><p id="69a2" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">使用<code class="fe ly lz ma mb b">getType</code>功能，你可以看到所有结果完全匹配。</p><pre class="kd ke kf kg gt mu mb mv mw aw mx bi"><span id="b967" class="my md in mb b gy mz na l nb nc">getType('a')          // 'string'<br/>getType(1)            // 'number' <br/>getType(NaN)          // 'Nan'<br/>getType(Infinity)     // 'Infinity'           <br/><br/>getType(true)         // 'boolean'<br/>getType(undefined)    // 'undefined'<br/>getType(Symbol('a'))  // 'symbol'<br/>getType(1n)           // 'bigint'<br/>typeof null           // 'object'<br/><br/>getType(function() {}) // 'function'<br/>getType([])            // 'array'<br/>getType({})            // 'object'<br/>getType(/a/)           // 'regexp'<br/>getType(new Date())    // 'date'<br/>getType(new Error())   // 'error'<br/>getType(new Map())     // 'map'<br/>getType(new Set())     // 'set'<br/>getType({})            // 'object'<br/>getType(null)          // 'null'<br/>getType(Symbol('a'))   // 'symbol</span></pre><h1 id="4374" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">最后</h1><p id="5892" class="pw-post-body-paragraph ll lm in kq b kr nd jo ln kt ne jr lo kv nf lq lr kx ng lt lu kz nh lw lx lb ig bi translated">让我们来谈谈<code class="fe ly lz ma mb b">instaceof</code>和<code class="fe ly lz ma mb b">constructor</code>方法。</p><p id="65d6" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated"><code class="fe ly lz ma mb b"><strong class="kq io">instanceof</strong></code>是检查构造函数的prototype属性是否出现在实例对象的原型链上。即利用<code class="fe ly lz ma mb b">B</code>的<code class="fe ly lz ma mb b">A</code>实例来判断<code class="fe ly lz ma mb b">A</code>是否是<code class="fe ly lz ma mb b">B</code>的实例，即<code class="fe ly lz ma mb b">A</code>的原型链上是否有<code class="fe ly lz ma mb b">B</code>的构造函数。但由于我们可以任意修改原型的朝向，导致检测结果不准确，所以这种方法就是<code class="fe ly lz ma mb b"><strong class="kq io">not safe</strong></code>。</p><p id="a869" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated"><code class="fe ly lz ma mb b"><strong class="kq io">constructor</strong></code>也是不准确的因为我们可以随意修改构造函数，所以这个方法也是<code class="fe ly lz ma mb b"><strong class="kq io">not</strong> <strong class="kq io">safe</strong></code>。</p><p id="d98d" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated">你有什么看法？大家说说吧。</p><p id="1797" class="pw-post-body-paragraph ll lm in kq b kr ks jo ln kt ku jr lo kv lp lq lr kx ls lt lu kz lv lw lx lb ig bi translated"><em class="ni">更多内容请看</em><a class="ae nj" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ni">plain English . io</em></strong></a><em class="ni">。报名参加我们的</em> <a class="ae nj" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ni">免费周报</em> </strong> </a> <em class="ni">。关注我们关于</em><a class="ae nj" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ni">Twitter</em></strong></a><em class="ni">和</em><a class="ae nj" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ni">LinkedIn</em></strong></a><em class="ni">。查看我们的</em> <a class="ae nj" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ni">社区不和谐</em> </strong> </a> <em class="ni">加入我们的</em> <a class="ae nj" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="ni">人才集体</em> </strong> </a> <em class="ni">。</em></p></div></div>    
</body>
</html>