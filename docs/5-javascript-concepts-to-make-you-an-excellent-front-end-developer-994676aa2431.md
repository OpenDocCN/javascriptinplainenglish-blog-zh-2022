# 让你成为优秀前端开发人员的 5 个 JavaScript 概念

> 原文：<https://javascript.plainenglish.io/5-javascript-concepts-to-make-you-an-excellent-front-end-developer-994676aa2431?source=collection_archive---------2----------------------->

## 第 5 部分:了解 JavaScript 中的这些概念可以帮助您成为一名优秀的前端开发人员。

![](img/4a0c07bd951a567ecd585444ef1218a7.png)

是不是有很多朋友会发现，嗯嗯，改了标题？没错，标题确实是改了，但是分享的内容在之前的内容之后继续分享。第四次分享文章后，有朋友私信说标题能不能改一下，增加一些新鲜感。和这些伙伴沟通后，我觉得可以试试。

嗯，希望新标题也能被大家喜欢，也希望新分享的内容能被更多的朋友讨论。

这次我们继续分享 JavaScript 的知识点:

***1。先说传承***

下面将讨论几种继承方式，包括它们的特征:

(1)原型链继承:覆盖对象。

它有两个缺点:1)对象实例共享所有继承的属性和方法。2)不能传递参数

(2)构造函数继承:在子类构造函数内部调用超类型构造函数。使用 apply()和 call()方法

其缺点是:(a)功能复用性不高。每个实例都是一个重新实例化的构造函数，没有共享属性。(b)只能继承实例上的属性，原型上的方法不可见。

(3)复合继承:原型链+构造函数父调用(this) new parent()避免了上述缺点。

优点:可以传递参数，不会与父类引用属性共享

缺点:继承父类的函数时，调用父类的构造函数，导致子类原型上没有必要的父类属性，浪费内存。

(4)原型继承:object()函数执行传入对象的浅层复制

(5)寄生继承:使用构造函数继承属性，通过原型链的混合形式继承方法

(6)寄生复合只调用构造函数一次，结合了寄生继承和复合继承的优点。它是实现基于类型的继承的最有效的方法。就是将父类的原型赋给子类，并将构造函数设置为子类，解决了无用的父属性问题，parent call + Object.create()

**2*。先来简单了解一下这个关键词***

**这有五个场景:**

(1)绑定事件指向事件本身

(2)普通函数，指向方法体

(3)新函数指向当前类

(4)箭头功能，指向父上下文

(5)调用/应用/绑定

***3。你对类型判断了解多少？***

说到 js 类型判断，我们可以想到 typeof，instanceof，constructor，Object.prototype.toString.call()。

那我们来对比一下它的门的功能和区别。

typeof 显示除 null 之外的基元类型的正确类型。但是对于对象来说，除了函数之外，对象都会被显示出来，所以它的功能只是判断原始类型，而不是判断对象。

instanceof 用于判断变量是否是对象的实例，通过原型链判断内部机制。他确实能判断出类型是否正确。但值得注意的是，instanceof 检测原型，原型链上的每个类型都会返回 true。所以只能用来判断两个对象是否属于一个实例关系，而不能判断一个对象实例属于哪种类型。

构造函数是原型的一个属性。定义函数时，js 引擎会给函数添加原型，这个原型中的构造函数属性指向函数引用，所以重写原型会丢失原来的构造函数。

但它也有明显的缺陷:

(null 和 undefined 没有构造函数，这个方法无法判断。

(2)如果在开发人员重写原型后定制对象，那么原来的构造函数就会丢失。因此，为了规范开发，在重写对象原型时，一般需要重新分配构造函数，以保证对象实例的类型不被改变。篡改。

toString 是几个方案中比较好的一个。推荐使用。toString()是 Object 的原型方法，调用这个方法默认返回当前对象的[[Class]]。这是一个格式为[对象 Xxx]的内部属性，其中 Xxx 是对象的类型。

***4。下面我们一起来了解一下*** 的转换

***js 类型转换可分为三种情况:***

转换为布尔值

转换成数字

转换为字符串

其中，转换为 boolean，除了 undefined，null，false，NaN，''，0，-0，其他所有值都转换为 true。我们可以每天使用它来确定一个对象是否未被赋值

***5。比较运算符，我们对*** 了解多少

比较运算符是常用的。如果它们都是数字类型，并且比较值的大小，那么当然就简单了。如果是非数字值呢？

顺序如下:将值转换为原语(to primitive 方法)转换为数字(valueOf 方法)转换为字符串(to string 方法)

这里都解释了，我再补充一下我提到的。关于 top primitive 过程，top primitive 有两种情况，一种是数字，一种是字符串。

如果是一个数字，执行如下:

(1)如果输入的是原值，直接返回这个值；

(2)否则，如果输入是对象，则调用 input.valueOf()，如果结果是基元值，则返回结果；

(3)否则，调用 input.toString()。如果结果是原始值，则返回结果；

(4)否则，抛出一个错误。

如果是字符串，则步骤 2 和 3 交换。

所以当原始类型是字符串，类型是数字时

**好了，这次分享到此结束，我们下次继续分享，欢迎大家一起讨论。**

***感谢您的阅读，期待您的关注，让我们共同进步。***

*更多内容看* [***说白了就是 io***](https://plainenglish.io/) *。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。关注我们关于*[***Twitter***](https://twitter.com/inPlainEngHQ)*和*[***LinkedIn***](https://www.linkedin.com/company/inplainenglish/)*。查看我们的* [***社区不和谐***](https://discord.gg/GtDtUAvyhW) *加入我们的* [***人才集体***](https://inplainenglish.pallet.com/talent/welcome) *。*