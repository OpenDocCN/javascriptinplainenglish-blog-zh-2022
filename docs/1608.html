<html>
<head>
<title>8 Little-Known “Weird” Signs that are the Hallmarks of a Great Programmer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">8个鲜为人知的“奇怪”标志是伟大程序员的标志</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/8-little-known-weird-signs-that-are-the-hallmarks-of-a-great-programmer-9dde163b067f?source=collection_archive---------0-----------------------#2022-04-06">https://javascript.plainenglish.io/8-little-known-weird-signs-that-are-the-hallmarks-of-a-great-programmer-9dde163b067f?source=collection_archive---------0-----------------------#2022-04-06</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="287b" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">99%的人不知道这些迹象。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/bd99b0e4afde1948b2f94fa26889b5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_T33xaecHb28jZrjNGZjQ.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Photo by <a class="ae kw" href="https://www.pexels.com/@emmali?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Emma Li</a> from <a class="ae kw" href="https://www.pexels.com/photo/black-surfer-practicing-extreme-sport-above-ocean-wave-6381482/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="3f6d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">出色的程序员很少见。通常很难区分伟大的程序员和平庸的程序员。</p><p id="995e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可以试着根据他们的沟通技巧和快速学习的能力来区分他们。但是你永远不能根据一个程序员的软技能来评价他。程序员与同事的互动较少，因为他们的工作需要与机器更多的互动。99%的程序员都是快速学习者。</p><p id="67f3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你只能根据他们写代码的效率和时间管理技巧来区分他们。</p><p id="246d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里有八个“奇怪”的迹象，实际上表明某人是一个伟大的程序员。</p><h1 id="a882" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">1.他们工作不太努力</h1><p id="f581" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">有效的开发者不相信努力。长时间的工作并不意味着你做得很好。</p><p id="4c20" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">高效的开发人员相信每天做4个小时的深度工作，而不是做10个小时分心的工作。</p><p id="83f9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对他们来说，每周40-45小时是一个不错的工作时间。如果你是一个每周工作超过40-45个小时的开发人员，那你是在努力工作。</p><p id="9331" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你需要减少你的工作时间。你需要专注于做深层次的工作，而不是分心的工作。</p><p id="f5d3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">软件开发更多的是持续学习，而不仅仅是写代码。</p><p id="2f25" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了在工作中创建可靠的软件，你必须每天处理新的问题。为了解决新问题，你需要反思你的思维过程，阅读新事物，并从中获得乐趣。</p><p id="80ee" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">开心能确保你过上美好的生活，并有跳出框框思考的空间。</p><p id="1336" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你需要不断学习，你需要空闲时间。读书、参加会议和与其他工程师交谈都需要时间。你需要在假期和晚上自学，以便跟上时代。</p><p id="ff43" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这就是优秀的程序员不努力工作，投入更多时间工作的原因。相反，他们专注于自我教育或娱乐。</p><h1 id="3efd" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">2.他们写了一个只做一件事的函数</h1><p id="3a97" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">在《干净的代码》一书中，作者R.Martin指出:</p><blockquote class="mq mr ms"><p id="1455" class="kx ky mt kz b la lb js lc ld le jv lf mu lh li lj mv ll lm ln mw lp lq lr ls ik bi translated">“功能应该做一件事。他们应该做好这件事。他们只应该这样做。”</p></blockquote><p id="9655" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有效的开发人员坚持这个原则。</p><p id="049c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们编写一个一次只做一件事的函数。它们确保函数中的语句具有相同的抽象级别。</p><p id="d6d1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">无论他们的代码是面向对象的、过程的还是函数式的。他们从不写同时做多件事的函数。</p><p id="b5df" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果一个功能同时做多件事，就会造成混乱。执行多项任务的大型函数很难修改和测试。</p><p id="9ddd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当开发人员编写只做一件事的函数时，整个代码库看起来更整洁。其他开发人员会自动阅读你的代码。</p><h2 id="772b" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">一个例子</h2><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="85ec" class="mx lu ir nk b gz no np l nq nr">function payEmployees(employees){<br/>    employees.forEach(employee =&gt; {<br/>        const employeeRecord  = database.lookup(employee);<br/>        if(employeeRecord.isActive()) {<br/>            pay(employee);<br/>        }<br/>    });<br/>}</span></pre><p id="a613" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上面的功能是同时做几件事。</p><p id="86f5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果把上面的功能拆分成两个更小的功能会更好。</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="99bd" class="mx lu ir nk b gz no np l nq nr">function payActiveEmployees(employees){<br/>    employees.filter(isActiveEmployee).forEach(pay);<br/>}</span><span id="886c" class="mx lu ir nk b gz ns np l nq nr">function isActiveEmployee(employee){<br/>    const employeeRecord = database.lookup(employee);<br/>    return employeeRecord.isActive();<br/>}</span></pre><p id="e16f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">隔离一个函数，一次执行一个任务，这样容易折射。</p><p id="9348" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你写的代码看起来干净多了。阅读您的代码变得很容易。</p><h1 id="3ef3" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">3.他们相信“代码越少越好”</h1><p id="ace4" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">不必要的代码会降低产品某些任务的执行速度。</p><p id="5fbe" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不必要的代码会增加调试代码的难度。</p><p id="9053" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在一个组织中，如果有成千上万的开发人员。如果他们每个人都增加一行额外的代码，那么代码库的长度就会增加数千行。</p><p id="b095" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">随着时间的推移，这数千行额外的代码会给组织带来很多问题。这些额外的代码行将需要被管理和记录。</p><p id="33bc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">将投入数百个工程小时来管理额外的代码。</p><p id="b929" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可能会开始思考为什么一个组织会允许额外的代码行。</p><h2 id="f2eb" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">为什么在代码评审过程中没有删除多余的代码</h2><p id="bbc5" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">额外的代码有时会逗乐审查代码的开发人员，而审查人员会故意留下这些代码。编写代码的开发人员可以编写将来需要的附加代码。</p><p id="4409" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有时候这些额外的代码看起来并不像是不必要的代码。感觉他们在为某种目的服务。事实上，他们什么都不做。</p><p id="4c0b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">好几次，编写代码的程序员想出了一些他们自己的附加特性。</p><h2 id="c266" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">有效的开发人员从不编写不必要的代码</h2><p id="b57d" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">最有效的开发人员从不写代码来取悦读者。</p><p id="a6d3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们不写未来需要的代码。如果应用程序现在不需要代码，他们就不会写那些额外的代码行。</p><p id="f2b7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们明白所有这些额外的代码行都需要管理和记录。这种管理和文档在将来是没有用的。</p><p id="e92a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有了额外的代码，时间和精力都浪费了。</p><p id="440c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们不想向评论者展示他们的聪明才智。</p><p id="6f62" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们认为，如果他们在一个组织中工作，他们已经很聪明了。如果他们不聪明，这个组织永远不会雇用他们。</p><p id="00cb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们不会尝试自己发明功能。如果他们需要任何关于需求的澄清，他们会问管理层。</p><h1 id="d1cc" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">4.他们避免编写重复的代码</h1><p id="8c8b" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">重复代码是同一文件中多行代码的重复。</p><p id="05cf" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">大多数低效的开发人员认为，如果代码工作正常，就没有必要修复重复的代码。他们忘记了重复的代码会使代码库变得庞大。</p><p id="29fd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在运行你的软件时，甚至一毫秒的延迟都可能导致数百万用户的损失。由于软件代码要被执行成千上万次，即使一毫秒的延迟也会导致用户放弃该软件。</p><p id="70b7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">代码重复降低了代码的整体质量。如果一个组织在编写代码时不关心代码的重复，他们将不得不在以后付钱给工程师来删除它。</p><p id="2c56" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有一些自动化工具可以捕获重复代码。尽管如此，所有这些工具都无法捕捉到100%的重复代码。</p><p id="998d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">只有所有工作的开发人员都努力避免代码重复，零重复代码才能实现。</p><h2 id="0cde" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">合并重复代码以简化代码库</h2><p id="6e3e" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">代码库中有重复的代码很糟糕。</p><p id="3688" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果开发人员编写重复的代码，他们必须在多个地方进行相同的更改。</p><p id="e5e3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">高效的开发人员总是合并所有的副本以保持简单。维护代码库变得很容易，也有助于减少安全问题。</p><h2 id="a012" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">包含重复代码的函数</h2><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="0965" class="mx lu ir nk b gz no np l nq nr">function contentWriter(writers) {<br/>    writers.forEach(writer =&gt; {<br/>        const desiredSalary = writer.calculateSalary();<br/>        const experience = writer.reqExperience();<br/>        const contentLink = writer.reqContentLink();<br/>        const data = {<br/>            desiredSalary,<br/>            experience,<br/>            contentLink<br/>        };</span><span id="2fe5" class="mx lu ir nk b gz ns np l nq nr">        render(data);<br/>    });<br/>}<br/></span><span id="1afa" class="mx lu ir nk b gz ns np l nq nr">function softwareDeveloper(developers) {<br/>    developers.forEach(developer =&gt; {<br/>        const desiredSalary = developer.calculateSalary();<br/>        const experience = developer.reqExperience();<br/>        const githubLink = developer.reqGithubLink();<br/>        const data = {<br/>            desiredSalary,<br/>            experience,<br/>            githubLink<br/>        };</span><span id="97b1" class="mx lu ir nk b gz ns np l nq nr">        render(data);<br/>    });<br/>}</span></pre><p id="c16b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在上面的两个函数中，代码被复制。</p><p id="21c3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nt nu nv nk b">contentWriter()</code>和<code class="fe nt nu nv nk b">softwareDeveloper()</code>包含相同的代码行。这些相似的代码行使得整个代码库看起来很庞大。</p><p id="53bb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">重复的代码做着同样的工作。</p><p id="4daa" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">面对这种类型的代码时，一个高效的开发人员。他们通常会要求开发人员删除重复的代码。</p><h2 id="bda8" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">这就是好的开发人员代码的样子</h2><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="5491" class="mx lu ir nk b gz no np l nq nr">function workerList(workers) {<br/>    workers.forEach(worker =&gt; {<br/>        const desiredSalary = worker.calculateSalary();<br/>        const experience = worker.reqExperience();<br/>    <br/>        const data = {<br/>            desiredSalary,<br/>            experience<br/>        };</span><span id="9ee2" class="mx lu ir nk b gz ns np l nq nr">        switch(worker.type){<br/>            case "writer" :<br/>                data.contentLink = worker.reqContentLink();<br/>                break;<br/>            case "developer" :<br/>                data.githubLink = worker.reqGithubLink();<br/>                break;<br/>        }<br/>        <br/>        render(data);</span><span id="81c5" class="mx lu ir nk b gz ns np l nq nr">    });  <br/>}  </span></pre><p id="02b3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在上面的函数中，已经删除了重复的代码行。</p><h1 id="b84c" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">5.尽可能使用函数式编程</h1><p id="9cea" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">编程很简单。</p><p id="2bd6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">面向对象编程很难做到。</p><p id="25f2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">开发人员花更多的时间思考“设计模式”和“抽象”，而不是解决真正的问题。</p><p id="ee7c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">OOP没有保持代码库的简单，而是让整个代码库看起来很复杂。</p><p id="b374" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当代码库中的行数由于OOP的使用而显著增长时，管理和维护就变得更加困难。</p><p id="d4d5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不保证状态隔离。通过使用OOP代码来鼓励共享的可变状态。</p><p id="6ab2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">OOP并没有解决它被发明出来的问题。</p><h2 id="0c61" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">面向对象的替代方案</h2><p id="e8ea" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">函数式编程是面向对象编程的替代品。</p><p id="13bc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当你只借助函数来编写程序的时候，就叫做函数式编程。只有通过函数才能表达和定义你的逻辑。</p><p id="2429" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">函数式编程有助于保持并发安全，测试代码变得容易，重构变得有趣。</p><h2 id="ad59" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">功能不纯的缺点</h2><p id="10c3" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">假设您编写了以下函数:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="9a53" class="mx lu ir nk b gz no np l nq nr">let abc= 0 </span><span id="d2f3" class="mx lu ir nk b gz ns np l nq nr">function addNumber(num){<br/>    abc = abc+num;<br/>    return abc;<br/>}</span></pre><p id="2a1b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当多次调用上述<code class="fe nt nu nv nk b">addNumber()</code>时，上述函数不会给出相同的结果。</p><p id="eb37" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们看看如何:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="071f" class="mx lu ir nk b gz no np l nq nr">addNumber(8);<br/>console.log(addNumber(8));</span></pre><p id="1b08" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们已经叫了两次<code class="fe nt nu nv nk b">addNumber()</code>。产生的输出将是:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="6d24" class="mx lu ir nk b gz no np l nq nr">//Here is the output<br/>16</span></pre><p id="f946" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在让我们再一次呼叫上面的<code class="fe nt nu nv nk b">addNumber()</code>。</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="fb80" class="mx lu ir nk b gz no np l nq nr">addNumber(8);<br/>addNumber(8);<br/>console.log(addNumber(8));</span></pre><p id="d377" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上面的代码产生的输出将会不同:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="9186" class="mx lu ir nk b gz no np l nq nr">//This is the output<br/>24</span></pre><p id="b071" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上面的<code class="fe nt nu nv nk b"> addNumber()</code>被称为不纯函数。</p><p id="cdbf" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因为上面的函数是在它的作用域之外改变一个变量。由<code class="fe nt nu nv nk b">addNumber()</code>产生的输出每次都会改变，即使输入保持不变。</p><h2 id="b086" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">纯函数</h2><p id="4433" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">纯函数的工作方式类似于数学函数。</p><p id="efa0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">数学函数可以执行计算。同样，纯函数可以根据需要进行计算。</p><p id="54c5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们看一个纯函数的例子:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="6f9e" class="mx lu ir nk b gz no np l nq nr">function pureAdd(num1, num2){</span><span id="fe25" class="mx lu ir nk b gz ns np l nq nr">    return num1 + num2;<br/>}</span></pre><p id="5d5e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上面的<code class="fe nt nu nv nk b">pureAdd()</code>永远不会根据它被调用的次数来改变它的输出。</p><p id="cd37" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可以调用一个纯函数任意次。没关系，会给出一样的结果。</p><p id="d918" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们调用上面的函数五次。</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="d25a" class="mx lu ir nk b gz no np l nq nr">pureAdd(0,8);<br/>pureAdd(0,8);<br/>pureAdd(0,8);<br/>pureAdd(0,8);<br/>console.log(pureAdd(0,8));</span></pre><p id="2d4a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">输出保持不变。不管你调用上面的函数一次，两次，三次，或者任何次数。</p><p id="c093" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下是输出:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="e746" class="mx lu ir nk b gz no np l nq nr">// This is the output<br/>8</span></pre><p id="f2b0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">纯函数通常被称为确定性函数。</p><h2 id="7a9d" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">使用函数式编程的优势</h2><ol class=""><li id="1ccf" class="nw nx ir kz b la ml ld mm lg ny lk nz lo oa ls ob oc od oe bi translated">纯函数确保外部程序的状态不会改变。</li><li id="ad42" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">不执行任何局部状态变量的突变。</li><li id="b0f8" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">测试纯函数很容易，因为输出只取决于输入。</li><li id="bf57" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">调试只能使用print语句来完成。</li></ol><h1 id="f855" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">6.他们不添加不必要的上下文</h1><p id="630a" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">正如我们之前讨论的，高效的开发人员不会编写额外的代码。</p><p id="30e1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可以称不添加不必要的上下文为不编写额外代码的一部分。高效的开发人员不会添加不必要的上下文。</p><p id="29c2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里有一个例子来说明:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="01bc" class="mx lu ir nk b gz no np l nq nr">const Fruit = {</span><span id="a005" class="mx lu ir nk b gz ns np l nq nr">    fruitSize: "Small",<br/>    fruitColor: "Yellow",<br/>    fruitTaste: "Sweet"</span><span id="98ca" class="mx lu ir nk b gz ns np l nq nr">};</span></pre><p id="88a3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果类/对象的名字已经给了你信息。为什么写变量名需要写一样的东西？</p><p id="3488" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">它应该是这样的:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="bd40" class="mx lu ir nk b gz no np l nq nr">const Fruit = {</span><span id="a13e" class="mx lu ir nk b gz ns np l nq nr">    size: "Small",<br/>    color: "Yellow",<br/>    taste: "Sweet"<br/>};</span></pre><p id="80c6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">无用的上下文使整个代码库变得很大。</p><h1 id="80b7" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">7.他们对要求非常清楚</h1><p id="0551" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">假设我们的开发人员朋友Bob在美国为任何组织工作。</p><p id="974c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他的任务是编写一个具有以下要求的函数:</p><ul class=""><li id="614c" class="nw nx ir kz b la lb ld le lg ok lk ol lo om ls on oc od oe bi translated">当有效的邮政编码作为参数传递时，该函数必须进行身份验证。</li></ul><p id="8dca" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Bob不太清楚需求，写了下面的函数:</p><pre class="kh ki kj kk gu nj nk nl nm aw nn bi"><span id="9d7e" class="mx lu ir nk b gz no np l nq nr">function authenticatePostalCode(givenCode){    <br/>    <br/>    return /^[0-9]{5}(?:-[0-9]{4})?$/.test(givenCode);</span><span id="bb17" class="mx lu ir nk b gz ns np l nq nr">}</span></pre><p id="33c2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这段代码已经发布，数百万用户正在下载这款应用。</p><p id="3ecc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">几天后，用户开始抱怨该应用程序无法验证他们的邮政编码。</p><p id="94db" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">鲍勃评论这件事。</p><p id="72f3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他发现他编写的authenticatePostalCode()只检查美国邮政编码。</p><p id="9209" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">该函数无法验证其他国家的邮政编码。</p><h2 id="3c54" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">这就是高效的开发人员处理它的方式</h2><p id="1528" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">当向他们提出以下要求时:</p><ul class=""><li id="96f8" class="nw nx ir kz b la lb ld le lg ok lk ol lo om ls on oc od oe bi translated">编写一个函数，当有效的邮政编码作为参数传递时，该函数应该进行身份验证。</li></ul><p id="b7db" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">而不是直接编写函数并自己承担需求。</p><p id="d8aa" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">高效的开发人员会要求需求更加清晰。他们会问管理层，该功能是否会实际验证美国邮政编码或其他国家的邮政编码。</p><p id="9cce" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">只有当管理层对他们的问题给出明确的答案时，他们才会继续编写函数。</p><p id="8d26" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">高效的开发人员总是从最清晰的用户需求开始。清晰的需求允许开发人员正确地测试他们的代码。</p><p id="a663" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过适当的测试，所有期望的要求都得到满足。为了满足所有的需求，我们需要清楚地了解我们的期望。</p><h1 id="e197" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">8.不要从头开始写所有的东西</h1><p id="3694" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">99%的开发者认为他们可以比现有系统做得更好。</p><p id="ec75" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当开发人员阅读新的代码库时，他们经常会发现代码库很乱。</p><p id="5473" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们对自己说:</p><blockquote class="mq mr ms"><p id="5ba7" class="kx ky mt kz b la lb js lc ld le jv lf mu lh li lj mv ll lm ln mw lp lq lr ls ik bi translated">“如果我参与了这个项目的代码编写，我会做出不同的事情。”</p></blockquote><p id="5ed0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当他们读取预先存在的代码时，他们想要删除它。他们想从头开始写。</p><p id="1b2d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们准备抛弃旧代码。他们准备放弃几个月来为写这本书所做的艰苦工作。</p><p id="a5f0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">即使预先存在的代码正在生产中。他们仍然认为他们可以在不理解为什么选择特定的数据结构和设计模式的情况下编写代码。</p><p id="d38e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们倾向于丢弃经过测试和审查的代码。</p><h2 id="9e7b" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated">杀手级程序员如何前进</h2><p id="10fb" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">最初，即使是杀手级程序员也有扔掉旧代码的相同倾向。</p><p id="32b2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是他们从来没有。</p><p id="3209" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们避免了从头开始写所有东西的倾向。</p><p id="5947" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们明白旧代码可以教会你很多东西。预先存在的代码有助于挑战已经做出的各种假设。</p><p id="daa4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们会问这样的问题:</p><ul class=""><li id="68b9" class="nw nx ir kz b la lb ld le lg ok lk ol lo om ls on oc od oe bi translated">"为什么选择了一种特殊的设计模式？"</li><li id="04c3" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls on oc od oe bi translated">“之前从事这项工作的团队是否考虑过另一种设计模式？他们为什么不能这样做呢？”</li><li id="02dd" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls on oc od oe bi translated">"其他的数据结构也会被考虑."</li></ul><p id="e643" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当他们问这些问题时，他们可以更好地了解现有的制度。</p><p id="ef42" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有时候，在看完代码库后，他们得出结论，现有的代码真的很糟糕。即使这样，他们也不会扔掉旧代码。他们尽可能地使用它。</p><p id="b105" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这有助于他们有一个更快的重写速度。没有错过最后期限。</p><p id="95bf" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">遗留测试用例帮助他们简化整个开发过程。有了旧的测试用例，他们可以避免犯前一个开发人员犯的同样的错误。</p><p id="ba28" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果您是一名已经在产品中审查和测试过代码的开发人员。马上扔出去可能是灾难性的。</p><p id="4845" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">用它让你的生活更轻松。</p><h1 id="b713" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">回顾一下你的记忆:杀手程序员的标志</h1><ol class=""><li id="c70a" class="nw nx ir kz b la ml ld mm lg ny lk nz lo oa ls ob oc od oe bi translated">避免长时间工作。</li><li id="2e54" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">编写只做一件事的函数。</li><li id="9ec5" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">更少的代码就是更多的代码。</li><li id="86be" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">合并重复的代码。</li><li id="c002" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">函数式编程是OOP的一个很好的替代品。</li><li id="532b" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">不要添加不必要的上下文。</li><li id="2c4a" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">需求的清晰性。</li><li id="d076" class="nw nx ir kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">避免从头开始写所有东西的诱惑。</li></ol></div><div class="ab cl oo op hv oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ik il im in io"><h2 id="c70e" class="mx lu ir bd lv my mz dn lz na nb dp md lg nc nd mf lk ne nf mh lo ng nh mj ni bi translated"><a class="ae kw" href="https://codertoentrepreneurs.substack.com/" rel="noopener ugc nofollow" target="_blank">点击这里</a>加入一个由热爱编程和技术的人组成的社区。</h2></div></div>    
</body>
</html>