<html>
<head>
<title>Under the Hood: How Jest Finds Related Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下:Jest如何找到相关测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/under-the-hood-how-jest-finds-related-tests-the-same-tech-37dc964e1766?source=collection_archive---------18-----------------------#2022-12-22">https://javascript.plainenglish.io/under-the-hood-how-jest-finds-related-tests-the-same-tech-37dc964e1766?source=collection_archive---------18-----------------------#2022-12-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cb9dabead359c1d8a856d5f16d4ea659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2-3gAOSLDDrcwesq.jpg"/></div></div></figure><p id="6a8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我之前的一篇<a class="ae kt" href="https://medium.com/@i.sharafeev89/algorithms-around-us-binary-search-the-same-tech-111ecfef8686" rel="noopener">文章</a>中，我已经谈到有时我们甚至没有注意到我们周围的算法。当使用一个工具或库时，我们把它当作一个给定的东西来使用，甚至不了解它在幕后是如何工作的。今天我将对Jest在运行<code class="fe ku kv kw kx b">jest --findRelatedTests</code>时用来寻找相关测试的算法进行逆向工程。</p><h1 id="aa1f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是Jest，我如何使用它？</h1><p id="dc4a" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">Jest 是一个流行的JavaScript测试框架，现在几乎每个项目都在使用。您可以简单地通过创建任何扩展名为<code class="fe ku kv kw kx b">test.js</code>的测试文件并在您的终端中运行<code class="fe ku kv kw kx b">jest</code>命令来开始。Jest还提供了广泛的配置选项，开发者可以使用这些选项来定义包含/排除什么测试，以什么格式生成什么覆盖输出，如何传输源文件等。-你可以在<a class="ae kt" href="https://jestjs.io/docs/configuration" rel="noopener ugc nofollow" target="_blank">官方文件</a>中找到所有这些。最激动人心的选择是用<code class="fe ku kv kw kx b">--findRelatedTests</code>运行<code class="fe ku kv kw kx b">jest</code>，并传递您想要测试的文件列表:</p><pre class="mb mc md me gt mf kx mg bn mh mi bi"><span id="7983" class="mj kz in kx b be mk ml l mm mn">jest --findRelatedTests /path/to/file1, /path/to/file2</span></pre><p id="7cc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样Jest不仅可以运行与这些文件相关的直接测试，还可以运行传递依赖的测试。在优化git预提交命令执行时，它变得非常方便。Jest将只运行一组实际上受相应变更影响的测试，而不是每次提交新变更时都运行一整套测试，从而节省开发人员的大量时间，同时确保结果的准确性。</p><h1 id="f6fe" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Jest文件系统</h1><p id="2621" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">Jest使用一个定制的<a class="ae kt" href="https://github.com/facebook/jest/blob/90995dfddbd51d6885d646dece3d37a1e3ad7fef/packages/jest-haste-map/src/index.ts#L138-L215" rel="noopener ugc nofollow" target="_blank"> haste模块系统</a>来以一种优化的方式构建关于文件和它们之间依赖关系的元数据。这个组件绝对值得自己的“引擎盖下”的文章。现在，让我们简化一下，它提供API来获取项目中所有文件及其依赖项的集合，如下所示:</p><pre class="mb mc md me gt mf kx mg bn mh mi bi"><span id="4b3f" class="mj kz in kx b be mk ml l mm mn">Array&lt;{ <br/>// absolute file path <br/>file: string; <br/><br/>// list of depedencies (modules imported in current file)<br/>dependencies: Array&lt;string&gt;; <br/>}&gt;</span></pre><h1 id="6de6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在引擎盖下寻找</h1><p id="ac59" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">我们知道什么:</p><ul class=""><li id="6109" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">在Git中添加/修改/删除和暂存的一组文件</li><li id="4a15" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">和整个文件系统元数据</li></ul><p id="1349" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要找到一种算法来检测和运行受这种变化影响的测试文件。</p><p id="332e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而Jest提供了<code class="fe ku kv kw kx b"><a class="ae kt" href="https://github.com/facebook/jest/blob/e865fbd66e3dc4adf9d35a35ce91de1bee48bc93/packages/jest-resolve-dependencies/src/index.ts#L164-L172" rel="noopener ugc nofollow" target="_blank">resolveInverse</a></code> API来解决这个问题:</p><pre class="mb mc md me gt mf kx mg bn mh mi bi"><span id="170c" class="mj kz in kx b be mk ml l mm mn">resolveInverse(<br/>paths: Set&lt;string&gt;, <br/>filter: (file: string) =&gt; boolean, <br/>options?: ResolveModuleConfig, ): Array&lt;string&gt; { <br/>   return this.resolveInverseModuleMap(paths, filter, options)<br/>          .map( module =&gt; module.file, ); <br/>}</span></pre><p id="bcbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其中:</p><ul class=""><li id="3086" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated"><code class="fe ku kv kw kx b">paths</code>是一组已更改的文件路径</li><li id="0d21" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated"><code class="fe ku kv kw kx b">filter</code>是一个谓词<a class="ae kt" href="https://github.com/facebook/jest/blob/b546fd866819118b41055a9722181150d383ffe8/packages/jest-cli/src/SearchSource.js#L140-L144" rel="noopener ugc nofollow" target="_blank">函数</a>来检测当前文件是否是一个测试文件</li><li id="96ae" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated"><code class="fe ku kv kw kx b">options</code>对象(与算法无关，现在忽略)</li></ul><p id="c465" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ku kv kw kx b">resolveInverseModuleMap</code>使用一种非常简单的方法来解决这个问题，这种方法基于<a class="ae kt" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度优先搜索</a> (BFS)。首先，它初始化以下集合:</p><ul class=""><li id="12cd" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated"><code class="fe ku kv kw kx b">changed</code> -受到影响的文件集。基本上，它是一个临时集合，在BFS的每次迭代后都会发生变异，并作为终止指示器——当它为空时，算法就会停止。在第一次迭代中，该集合从作为输入提供的<code class="fe ku kv kw kx b">paths</code>开始填充。</li><li id="b97b" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated"><code class="fe ku kv kw kx b">relatedPaths</code> -受影响的一组<em class="nc">测试</em>文件。默认情况下，该设置由<code class="fe ku kv kw kx b">paths</code>输入填充，但条件是该文件实际上是一个测试文件。在BFS的每一次迭代中，每一个匹配的测试文件都会从这个文件中删除。在算法结束时，这个集合中剩余的文件路径与BFS执行的结果连接在一起。这是为了处理一个简单的用例，当变更发生在测试文件中，而不是在源代码中。</li><li id="f53b" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated"><code class="fe ku kv kw kx b">visitedModules</code> -已经遍历过的文件，可以跳过进一步处理。</li></ul><p id="5867" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来想象一下我们的算法。首先，让我们定义我们的示例文件系统:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/eb423e73ec322e4b2bb7d0f6cd582743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5H83aMiVeeJabb9i.jpg"/></div></div></figure><p id="8bd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">红色的块代表改变的模块(矩形是测试文件，圆形是源文件)。箭头从父开始指向子(表示<code class="fe ku kv kw kx b">a</code>模块由<code class="fe ku kv kw kx b">a.test</code>和<code class="fe ku kv kw kx b">a1</code>导入)。最初，我们的数据结构看起来像这样:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/498764e571fd88bf58bb72ab63ba4325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l8BbG-HaBJ9IVIPa.jpg"/></div></div></figure><p id="9b29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们改变的集合不是空的。这意味着我们需要遍历文件系统中的所有文件，以获得<code class="fe ku kv kw kx b">changed</code>集合中每个模块的依赖关系列表。在第一次迭代之后，我们已经发现至少<code class="fe ku kv kw kx b">b.test</code>和<code class="fe ku kv kw kx b">a1.test</code>需要分别作为<code class="fe ku kv kw kx b">a.test</code>和<code class="fe ku kv kw kx b">a1</code>的依赖来运行:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/08e36fddb0b8b681ab42fe59857e7a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HvDNOMs0wHAJx9VF.jpg"/></div></div></figure><p id="6637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">进行另一次遍历。现在我们看到<code class="fe ku kv kw kx b">b2</code>被导入到了a.test和b2.test中，但是在我们最初更改的文件中已经有了一个a.test。在这种情况下，我们需要将其从<code class="fe ku kv kw kx b">relatedPaths</code>集合中移除，并将其添加到结果中。如果<code class="fe ku kv kw kx b">a.test</code>没有任何依赖关系，Jest在将结果返回给上游调用者时会简单地将其合并到结果中。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/304cd8856a0dcc9823fee30749baa5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gTlx-KR2q6v4Mdwl.jpg"/></div></div></figure><p id="a56a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们的<code class="fe ku kv kw kx b">changed</code>集合中只有2个测试模块，我们已经看到<code class="fe ku kv kw kx b">a.test</code>在我们访问过的集合中，b2.test没有任何依赖项。基本上，这里没有操作——在这个迭代之后<code class="fe ku kv kw kx b">changed</code>集合将变空，我们将跳出我们的BFS循环。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/10d86f07cee5e23e57a57172c1e296d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KUdgkdrO-h8zkoEX.jpg"/></div></div></figure><p id="5cd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们可以将测试范围从5个测试文件缩小到4个。这并不令人印象深刻，但请记住，为了简单起见，我为这个示例选择了一个非常小的数据集——在现实世界的项目中，会有成千上万个文件，改进可能会非常显著。</p><p id="60ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nc">你可以在这里</em>  <em class="nc">找到原来的实现</em> <a class="ae kt" href="https://github.com/facebook/jest/blob/e865fbd66e3dc4adf9d35a35ce91de1bee48bc93/packages/jest-resolve-dependencies/src/index.ts#L99" rel="noopener ugc nofollow" target="_blank"> <em class="nc">。</em></a></p><h1 id="3971" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h1><p id="60f2" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">你觉得这个算法可以改进吗？如果我们可以将依赖模块的反向链接作为文件元数据的一部分(类似于引用父模块的DOM元素)会怎么样？在这种情况下，我们不必遍历整个文件系统，而只关注它的一个子集。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="386e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nc">原载于2022年12月22日https://thesametech.com</em><em class="nc">的</em> <a class="ae kt" href="https://thesametech.com/under-the-hood-jest-related-tests/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4eb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nc">你也可以在Twitter上</em> <a class="ae kt" href="https://twitter.com/mastershifu89" rel="noopener ugc nofollow" target="_blank"> <em class="nc">关注我</em> </a> <em class="nc">和</em> <a class="ae kt" href="https://www.linkedin.com/in/isharafeev/" rel="noopener ugc nofollow" target="_blank"> <em class="nc">在LinkedIn上连接</em> </a> <em class="nc">获取新帖通知！</em></p><p id="a5f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nc">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nc">plain English . io</em></strong></a><em class="nc">。</em></p><p id="d35d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nc">报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nc">免费每周简讯</em> </strong> </a> <em class="nc">。关注我们关于</em> <a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nc">推特</em></strong></a><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nc">LinkedIn</em></strong></a><em class="nc"/><a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nc">YouTube</em></strong></a><em class="nc"/><a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nc">不和</em> </strong> </a> <strong class="jx io"> <em class="nc">。</em>T51】</strong></p><p id="6e82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="nc">对缩放您的软件启动感兴趣</em> </strong> <em class="nc">？检查</em> <a class="ae kt" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nc">电路</em> </strong> </a> <em class="nc">。</em></p></div></div>    
</body>
</html>