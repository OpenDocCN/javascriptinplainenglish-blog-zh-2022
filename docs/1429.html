<html>
<head>
<title>The Alchemy of JavaScript Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript生成器的魔力</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-alchemy-of-javascript-generators-f58e81c9f269?source=collection_archive---------12-----------------------#2022-03-23">https://javascript.plainenglish.io/the-alchemy-of-javascript-generators-f58e81c9f269?source=collection_archive---------12-----------------------#2022-03-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7452" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript函数第3部分:理解生成器</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/02bfefe4ac350844510926b2a8920807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jArD9EoAVYCOo4MzxnGOHA.jpeg"/></div></div></figure><p id="5293" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是JavaScript函数第2部分的继续:</p><div class="lk ll gp gr lm ln"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-functions-part-2-function-invocation-bb51407b81b8"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd io gy z fp ls fr fs lt fu fw im bi translated">通过精确的函数调用展现您的JavaScript开发能力</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">JavaScript函数第2部分:函数隐式参数和调用函数</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb km ln"/></div></div></a></div><p id="07da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">生成器是一种独特的函数形式。标准函数在从头到尾运行代码时只能创建一个值，而生成器可以为每个请求输出多个值。它能够在请求之间暂停执行。</p><p id="c0e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">大多数普通程序员不使用它，因为他们认为它是一个非必要的语言特性。但这就是我们在这里的原因:帮助编码器和生成器解决他们的差异。</p><pre class="kd ke kf kg gt mc md me mf aw mg bi"><span id="e806" class="mh mi in md b gy mj mk l ml mm">function<strong class="md io">*</strong> ironManMovies() {<br/> <strong class="md io">yield</strong> "IronMan 1"<br/> <strong class="md io">yield</strong> "Iron Man 2"<br/> <strong class="md io">yield</strong> "Iron Man 3"<br/>}</span><span id="5579" class="mh mi in md b gy mn mk l ml mm">const movieProducer = ironManMovies()</span><span id="4b64" class="mh mi in md b gy mn mk l ml mm">for(let produce of movieProducer) {<br/> console.log(produce)<br/>}</span><span id="00ce" class="mh mi in md b gy mn mk l ml mm">//output<br/>IronMan 1<br/>Iron Man 2<br/>Iron Man 3</span></pre><p id="3b88" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们首先定义一个将生成一系列<code class="fe mo mp mq md b">IronMan</code>影片的生成器。<br/>很容易做一个生成器函数。在function关键字之后，我们添加一个星号(<code class="fe mo mp mq md b">*</code>)。这允许我们在生成器主体中使用新的<code class="fe mo mp mq md b">yield</code>关键字来生成唯一的值。</p><p id="150a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了消耗来自生成器函数的值，我们使用了一个<code class="fe mo mp mq md b">for-of-loop</code>。运行<code class="fe mo mp mq md b">ironmanMovies()</code>的结果用在了<code class="fe mo mp mq md b">for-of-loop</code>的右侧。没有使用退货单。如前所述，生成器不是典型的函数。首先，调用生成器不会运行生成器函数；相反，它创建一个迭代器对象。</p><h2 id="ed8c" class="mh mi in bd mr ms mt dn mu mv mw dp mx kx my mz na lb nb nc nd lf ne nf ng nh bi translated">1.使用迭代器对象理解生成器</h2><p id="aa0b" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">让我们制造一些噪音；调用生成器并不意味着将执行生成器函数的主体。相反，创建了一个迭代器对象。这让我们可以和发电机交流。为了更好地理解，我们可以使用迭代器来请求更多的值。让我们改进一下前面的例子。</p><pre class="kd ke kf kg gt mc md me mf aw mg bi"><span id="a2ed" class="mh mi in md b gy mj mk l ml mm">function* ironManMovies() {<br/> yield "IronMan 1"<br/> yield "Iron Man 2"<br/> yield "Iron Man 3"<br/>}</span><span id="3d29" class="mh mi in md b gy mn mk l ml mm">const movieProducer = ironManMovies()<br/><br/>const movie1 = movieProducer.next()<br/>console.log(movie1)<br/>const movie2 = movieProducer.next()<br/>console.log(movie2)<br/>const movie3 = movieProducer.next()<br/>console.log(movie3)<br/>const movie4 = movieProducer.next()<br/>console.log(movie4)<br/>const movie5 = movieProducer.next()<br/>console.log(movie5)</span><span id="df14" class="mh mi in md b gy mn mk l ml mm">// output<br/>{ value: 'IronMan 1', done: false }<br/>{ value: 'Iron Man 2', done: false }<br/>{ value: 'Iron Man 3', done: false }<br/>{ value: undefined, done: true }<br/>{ value: undefined, done: true }<br/></span></pre><p id="bbd9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如您所见，调用生成器会导致创建一个新的迭代器，用于控制生成器的执行。迭代器对象公开的最基本的东西之一是<code class="fe mo mp mq md b">next</code>函数，它可以通过向生成器请求一个值来控制生成器。</p><p id="4f99" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当moment值返回时，生成器的执行被挂起而没有阻塞，它等待另一个调用。这是一个标准功能中没有的便利特性。</p><p id="2edf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过在迭代器上使用<code class="fe mo mp mq md b">next</code>,生成器从休眠中醒来，并从它停止的地方继续。它一直运行，直到到达下一个yield语句，然后挂起以进行更多的调用。当我们第四次调用next时，不再有代码要执行，因此生成器返回一个对象，将<code class="fe mo mp mq md b">values</code>设置为<code class="fe mo mp mq md b">undefined</code>，将<code class="fe mo mp mq md b">done</code>设置为<code class="fe mo mp mq md b">true</code>。</p><pre class="kd ke kf kg gt mc md me mf aw mg bi"><span id="7203" class="mh mi in md b gy mj mk l ml mm">// <strong class="md io">Iterating over generator using while loop</strong></span><span id="825a" class="mh mi in md b gy mn mk l ml mm">function* ironManMovies() {<br/> yield "Iron Man 1"<br/> yield "Iron Man 2"<br/> yield "Iron Man 3"<br/> const a = 'Have many things to do in lfe'<br/>}</span><span id="f6ff" class="mh mi in md b gy mn mk l ml mm">const movieProducer = ironManMovies()</span><span id="0094" class="mh mi in md b gy mn mk l ml mm">let movie;<br/>while(!(item = movieProducer.next()).done) {<br/> console.log(item.value)<br/>}</span><span id="b291" class="mh mi in md b gy mn mk l ml mm">//output<br/>Iron Man 1<br/>Iron Man 2<br/>Iron Man 3</span></pre><h2 id="9fcc" class="mh mi in bd mr ms mt dn mu mv mw dp mx kx my mz na lb nb nc nd lf ne nf ng nh bi translated">2.屈服于另一个发电机</h2><p id="d63a" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">从一个生成器函数调用另一个生成器函数被称为嵌套函数调用。让我们看一个例子。</p><pre class="kd ke kf kg gt mc md me mf aw mg bi"><span id="0fe7" class="mh mi in md b gy mj mk l ml mm">function* MarvelMovies() {<br/> yield "The Avengers"<br/> yield "Avengers: The Age of Ultron"<br/> yield "And many more"<br/>}</span><span id="86f1" class="mh mi in md b gy mn mk l ml mm">function* ironManMovies() {<br/> yield "IronMan 1"<br/> yield "Iron Man 2"<br/> yield "Iron Man 3"<br/> <strong class="md io">yield* MarvelMovies()</strong><br/>}</span><span id="c1c8" class="mh mi in md b gy mn mk l ml mm">const movieProducer = ironManMovies()</span><span id="f9f9" class="mh mi in md b gy mn mk l ml mm">let movie;<br/>while(!(item = movieProducer.next()).done) {<br/> console.log(item.value)<br/>}</span><span id="7ff1" class="mh mi in md b gy mn mk l ml mm">// output<br/>IronMan 1<br/>Iron Man 2<br/>Iron Man 3<br/>The Avengers<br/>Avengers: The Age of Ultron<br/>And many more</span></pre><p id="c998" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在迭代器上使用<code class="fe mo mp mq md b">yield*</code>操作符，我们可以使用另一个生成器。在这个例子中，我们从一个<code class="fe mo mp mq md b">ironManMovies</code>让位于一个新的<code class="fe mo mp mq md b">MarvelMovies</code>；对当前<code class="fe mo mp mq md b">ironManMovies</code>迭代器的下一个方法的所有调用都转到<code class="fe mo mp mq md b">MarvelMovies</code>生成器。这将一直持续到<code class="fe mo mp mq md b">MarvelMovies</code>生成器用完了要处理的项目。</p><h2 id="af14" class="mh mi in bd mr ms mt dn mu mv mw dp mx kx my mz na lb nb nc nd lf ne nf ng nh bi translated">3.与发电机互动</h2><p id="b48c" class="pw-post-body-paragraph ko kp in kq b kr ni jo kt ku nj jr kw kx nk kz la lb nl ld le lf nm lh li lj ig bi translated">到目前为止，我们已经看到了如何使用<code class="fe mo mp mq md b">yield</code>从生成器接收几个值。我们现在将关注与生成器的双向通信，也就是说，发送和接收来自它们的数据。</p><p id="7076" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 3.1使用值作为生成器函数的参数:</strong></p><p id="1b84" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">向生成器提交数据的最简单方法是像对待任何其他函数一样对待它，并像对待任何其他函数一样使用函数调用参数。</p><pre class="kd ke kf kg gt mc md me mf aw mg bi"><span id="a825" class="mh mi in md b gy mj mk l ml mm">function* ironManMovies(actor) {<br/> const featured = yield "Iron Man 1"<br/> yield (`Iron Man 2, ${actor}, ${featured}`)<br/>}</span><span id="5a18" class="mh mi in md b gy mn mk l ml mm">const <!-- -->movieProducer<!-- --> = ironManMovies('Tony')<br/>const mov1 = <!-- -->movieProducer<!-- -->.next()<br/>console.log(mov1)</span><span id="17f2" class="mh mi in md b gy mn mk l ml mm">const mov2 = <!-- -->movieProducer<!-- -->.next('Happy')<br/>console.log(mov2)</span><span id="9fb7" class="mh mi in md b gy mn mk l ml mm">//output<br/>{ value: 'Iron Man 1', done: false }<br/>{ value: 'Iron Man 2, Tony, Happy', done: false }</span></pre><p id="ccf8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个例子中，我们有两个对<code class="fe mo mp mq md b">ironManMovies's</code> next方法的调用。<br/>第一种方法<code class="fe mo mp mq md b">movieProducer.next()</code>，向生成器询问初始值。这个调用启动生成器，它计算短语“<em class="nn">钢铁侠1”</em>的值，然后暂停生成器的执行，因为它还没有启动。</p><p id="804a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第二次调用<code class="fe mo mp mq md b">ironManMovies's</code>下一个方法<code class="fe mo mp mq md b">movieProducer.next('Happy')</code>时，有趣的事情开始了。Next用于将数据发送回生成器。我们的生成器正在耐心等待，在表达式yield "I <em class="nn"> ron Man 1 </em>处暂停，因此整个yield表达式的值是作为参数提供给<code class="fe mo mp mq md b">next()</code>的'<em class="nn"> Happy </em>。这表示<code class="fe mo mp mq md b">featured = yield 'Iron Man 1'</code>中的变量的值将为“<em class="nn">快乐</em>”</p><p id="1b37" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是我们能够与发电机双向通信的方式。<br/>要从生成器返回数据，请使用yield，要将数据反馈给生成器，请使用迭代器的<code class="fe mo mp mq md b">next()</code>方法。</p><p id="e928" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 3.2使用异常:</strong></p><p id="02ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">抛出异常是另一种向生成器提供值的技术，这种技术稍逊一筹。每个迭代器都有一个<code class="fe mo mp mq md b">next</code>函数，以及一个用于向生成器返回异常的<code class="fe mo mp mq md b">throw</code>方法。</p><pre class="kd ke kf kg gt mc md me mf aw mg bi"><span id="9e95" class="mh mi in md b gy mj mk l ml mm">function* ironmanMovies() {<br/> try {<br/>  yield "Iron Man"<br/>  fail("The villian did cause issue")<br/> }catch(e) {<br/>  console.log(e)<br/> }<br/>}</span><span id="772f" class="mh mi in md b gy mn mk l ml mm">const movies = ironmanMovies()</span><span id="50f2" class="mh mi in md b gy mn mk l ml mm">const result = movies.next()<br/>console.log(result)</span><span id="1556" class="mh mi in md b gy mn mk l ml mm">movies.throw('Caught the villina')</span><span id="891d" class="mh mi in md b gy mn mk l ml mm">//output<br/>{ value: 'Iron Man', done: false }<br/>Caught the villina</span></pre><p id="71ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了更好地理解<code class="fe mo mp mq md b">throw</code>，请参考以下内容:</p><div class="lk ll gp gr lm ln"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd io gy z fp ls fr fs lt fu fw im bi translated">generator . prototype . throw()-JavaScript | MDN</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">该方法通过向生成器抛出一个错误来恢复生成器的执行，并返回一个具有两个属性的对象…</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">developer.mozilla.org</p></div></div><div class="lw l"><div class="no l ly lz ma lw mb km ln"/></div></div></a></div><p id="c4cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是JavaScript函数的全部进展。我希望你已经发现这是有用的。感谢您的阅读。</p><p id="47b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nn">更多内容看</em> <a class="ae np" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nn">说白了。报名参加我们的</em> <a class="ae np" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="nn">免费周报</em> </strong> </a> <em class="nn">。关注我们关于</em><a class="ae np" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nn">Twitter</em></strong></a><em class="nn">和</em><a class="ae np" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nn">LinkedIn</em></strong></a><em class="nn">。加入我们的</em><strong class="kq io"><em class="nn"/></strong><a class="ae np" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nn">社区不和谐</em> </strong> </a> <em class="nn">。</em></strong></a></p></div></div>    
</body>
</html>