<html>
<head>
<title>What is Recursion?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是递归？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/and-were-back-recursion-92cf7ac829c1?source=collection_archive---------16-----------------------#2022-06-20">https://javascript.plainenglish.io/and-were-back-recursion-92cf7ac829c1?source=collection_archive---------16-----------------------#2022-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c3de" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于递归你需要知道的一切。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4021b1bd49569c75fa7094f96f7b2db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbWy5v24HhSSAHPFbOziIg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@seimesa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mario Mesaglio</a> on <a class="ae ks" href="https://unsplash.com/s/photos/recursivity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b52a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">嘿，伙计们，愿每个人都拥有精神、身体和灵魂的力量。在过去的几个星期里，我一头扎进了递归，不可否认的是，最初我并不喜欢它，但是在花了一些时间并完成了一些练习之后，我开始欣赏这种方法，因为在某些情况下，它证明了比迭代更好的方法。但是什么是递归呢？</p><p id="38fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简单地说，递归是一个不断重复的过程，直到满足某种条件。在CS方面，这个过程是由一个函数提供的。所以一个递归函数会反复调用自己，直到到达某个边界，然后返回，停止执行。这个<em class="lp">边缘情况</em>通常被称为<strong class="kv io">基础情况</strong>和<strong class="kv io"> </strong>作为递归函数的停止点。</p><p id="6a77" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一点很重要，因为与压入调用堆栈并在完成执行后弹出的普通函数调用不同，递归函数不断地将函数压入调用堆栈。因此，如果没有提供基本情况，函数将永远执行自己，这可能导致浏览器抛出一个错误<strong class="kv io">“超出最大调用堆栈大小】，</strong>意味着堆栈已经因重复的函数调用而过载。<strong class="kv io"> </strong>这也称为<strong class="kv io">堆栈溢出。</strong></p><p id="73f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">除了基本情况，递归函数还需要调用自身，但是使用不同的输入，这导致了一些基本情况。这确保了会有一个停止点。这将更有意义，因为我举例说明了字符串反转练习的递归解决方案。但是首先我想给那些不熟悉或者对JavaScript调用栈以及同样重要的<em class="lp">栈</em>数据结构了解有限的人一些背景知识。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="3230" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">JavaScript的调用堆栈</h2><p id="e411" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">调用栈(高层)是JavaScript引擎的一个组件，它管理程序中的函数调用——它检查当前正在运行什么函数，以及从该函数内部调用了什么函数(如果有)。当一个函数被调用时，它被<em class="lp">推入</em>堆栈，一旦该函数执行完毕，它就被<em class="lp">弹出</em>堆栈。</p><h2 id="8bb9" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">堆栈</h2><p id="a100" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">更具体地说，<em class="lp">堆栈</em>是一种线性数据结构，其中数据元素按顺序组合在一起——因此函数调用按调用顺序放入堆栈。堆栈遵循<strong class="kv io">后进先出(LIFO) </strong>原则，这意味着最后一个被推入堆栈的元素将首先弹出。一个臭名昭著的类比指向一堆互相堆叠的盘子<em class="lp">。每个板块代表一个函数调用。最上面的盘子将最先脱落，因为它是最后添加的。类似地，当函数完成执行时，推入调用堆栈的最后一个函数调用是第一个弹出的。</em></p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="1231" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这个心理模型，让我们使用递归方法来完成<em class="lp">字符串反转</em>练习。本练习摘自柯尔特·斯蒂尔的<a class="ae ks" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> JS算法&amp; DS教程</em> </a>。</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="8e66" class="lx ly in mw b gy na nb l nc nd">Write a recursive function called <strong class="mw io"><em class="lp">reverse</em></strong><em class="lp"> </em>which accepts a string and returns a new string in reverse.</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><pre class="mv mw mx my aw mz bi"><span id="25de" class="lx ly in mw b gy ne nf ng nh ni nb l nc nd">function reverse(str){<br/> let reversedWord = "";<br/>  if (str.length &lt;= 0) {<br/>    return "";<br/>  }</span><span id="095b" class="lx ly in mw b gy nj nb l nc nd">const helper = function (strInput) {<br/>    reversedWord = reversedWord.concat(<br/>      strInput[strInput.length - 1],<br/>      reverse(strInput.slice(0, -1))<br/>    );<br/>  };</span><span id="2ad6" class="lx ly in mw b gy nj nb l nc nd">  helper(str);<br/>  return reversedWord;<br/>}</span></pre><p id="bc64" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以上是我在潜意识中尝试形成解决方案几个小时后想出来的一个解决方案。从第一行开始，需要返回一个反转的字符串，所以我们初始化一个空字符串<strong class="kv io"> <em class="lp"> reversedWord。</em> </strong>移动<strong class="kv io"> <em class="lp"> </em> </strong>到下一行是我们的条件，将停止函数递归执行。在这种情况下，如果传入的字符串长度过时，我们将返回一个空字符串。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="c878" class="lx ly in mw b gy na nb l nc nd">const helper = function (strInput) {<br/>    reversedWord = reversedWord.concat(<br/>      strInput[strInput.length - 1],<br/>      reverse(strInput.slice(0, -1))<br/>    );<br/>  };</span></pre><p id="a00e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们达到函数递归性质的地方。我们创建一个<strong class="kv io"> <em class="lp">助手</em> </strong>函数，其唯一目的是操纵<strong class="kv io"> <em class="lp">反转字</em> </strong>字符串。它将传入的字符串的最后一个字母和下一个<em class="lp"> reverse </em>函数调用的最后一个字母连接起来，直到传入的字符串为空。所以对于每个函数调用，我们都在处理传入的原始字符串的一个更小的子集，直到我们满足基本情况，是一个空字符串。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="dc9b" class="lx ly in mw b gy na nb l nc nd">"lmth" ---&gt; "html"<br/>1st call – reversedWord("tml") returns "h" --&gt; concat("h", "tml")<br/>2nd call – reversedWord("ml") returns "t" --&gt; concat("t", "ml")<br/>3rd call – reversedWord("l") returns "m" --&gt; concat("m", "l")<br/>4th call – reversedWord("") returns "l" --&gt; concat("l", "")<br/>5th call - returns "" --&gt; strings length is 0</span></pre><p id="b471" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是用传入的字符串调用的<em class="lp">助手</em>函数的可视化模型。如图所示，最后一个<strong class="kv io"> <em class="lp">反向</em> </strong>调用根据我们的基本情况返回一个空字符串。从这一点开始，我们向后移动到第一个<strong class="kv io"> <em class="lp">反向</em> </strong>调用。</p><p id="f666" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从返回一个空字符串开始，我们将这个空字符串连接到前一个函数的当前字母<code class="fe nk nl nm mw b">'l'</code>。一旦完成，函数<em class="lp">从堆栈中弹出</em>并调用该函数，这次使用原始字符串的一个较小的子集。因此，对于我们的字符串<code class="fe nk nl nm mw b">'l'</code>，我们执行同样的事情，并将它与前一个函数的当前字母<code class="fe nk nl nm mw b">m</code>连接起来，因此<code class="fe nk nl nm mw b">reversedWord.concat('m', 'l')</code>将导致<code class="fe nk nl nm mw b">'ml’</code>——直到我们得到一个完全反转的字符串。如果您注意到，每个递归调用都等待下一个返回一个<em class="lp">字符串</em>，这样它就可以将自己的字符串连接到它上面，最终得到一个反转的单词。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="fa36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在很快，我想分享一个使用<em class="lp">纯递归</em>的替代解决方案。我最初的解决方案是使用<em class="lp">助手方法递归</em>实现的，使用嵌套函数来操作<em class="lp"> reversedWord </em>字符串并在最后返回它。使用纯递归，函数本身是独立的，这意味着它不会对任何外部代码产生任何副作用。我计划在以后的文章中更深入地讨论这两种方法。但是现在，我想实现一个解决方案，使用这两种方法来巩固每一种方法。以下是解决方案:</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="6994" class="lx ly in mw b gy na nb l nc nd">const reverse = function (string) {</span><span id="651a" class="lx ly in mw b gy nj nb l nc nd"> let reversedStr = "";</span><span id="aae2" class="lx ly in mw b gy nj nb l nc nd"> if (string.length &lt;= 0) {</span><span id="af25" class="lx ly in mw b gy nj nb l nc nd"> return "";</span><span id="5764" class="lx ly in mw b gy nj nb l nc nd"> }</span><span id="15c6" class="lx ly in mw b gy nj nb l nc nd"> return reversedStr.concat(</span><span id="01cc" class="lx ly in mw b gy nj nb l nc nd"> string[string.length - 1],</span><span id="b95b" class="lx ly in mw b gy nj nb l nc nd"> reverse(string.slice(0, -1))</span><span id="f41a" class="lx ly in mw b gy nj nb l nc nd"> );</span><span id="7d75" class="lx ly in mw b gy nj nb l nc nd">};</span></pre><p id="3261" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">本文到此结束，感谢您花时间阅读本文。虽然有点冗长，但我希望你们能学到一两件事。一如既往，我渴望听到关于如何改进我的代码解决方案或写作的建议。如果你想陪伴我成为一名前端开发人员，请关注</em><em class="lp">my</em><a class="ae ks" href="https://twitter.com/thedetroitdev" rel="noopener ugc nofollow" target="_blank"><em class="lp">Twitter</em></a><em class="lp">和</em><a class="ae ks" href="https://www.linkedin.com/in/erick-walker-0433981ab/" rel="noopener ugc nofollow" target="_blank"><em class="lp">LinkedIn</em></a><em class="lp">。愿和平与祝福带给每一个人。</em></p><p id="1eca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">plain English . io</em></strong></a><em class="lp">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">免费周报</em> </strong> </a> <em class="lp">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">Twitter</em></strong></a><em class="lp">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">LinkedIn</em></strong></a><em class="lp">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">社区不和谐</em> </strong> </a> <em class="lp">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lp">人才集体</em> </strong> </a> <em class="lp">。</em></p></div></div>    
</body>
</html>