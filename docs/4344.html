<html>
<head>
<title>10 Ways To Check If A String Contains Substring In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中检查字符串是否包含子串的10种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-ways-to-check-if-a-string-contains-substring-in-javascript-91639d81b7?source=collection_archive---------10-----------------------#2022-11-22">https://javascript.plainenglish.io/10-ways-to-check-if-a-string-contains-substring-in-javascript-91639d81b7?source=collection_archive---------10-----------------------#2022-11-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/0ea95e39bc09f5bee599c104bda52659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UATcfQjNEqd99siB2D9kQ.jpeg"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Image by <a class="ae kd" href="https://medium.com/@el3um4s" rel="noopener">Samuele</a></figcaption></figure><p id="69e6" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">编程最有趣的事情之一是找到所有可用的方法来解决问题。今天我想找10个方法来检查JavaScript中一个字符串是否包含子串。</p><h1 id="22e2" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">String.prototype.includes()</h1><p id="cf24" class="pw-post-body-paragraph ke kf ir kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">让我们从最佳解决方案开始，即<code class="fe mf mg mh mi b"><a class="ae kd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes" rel="noopener ugc nofollow" target="_blank">String.prototype.includes()</a></code>方法。此方法允许您检查字符串是否包含子字符串，并返回一个布尔值。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="2984" class="mr ld ir mi b be ms mt l mu mv">const string = "Hello World!";<br/><br/>console.log(string.includes("Hello")); // true<br/>console.log(string.includes("!")); // true<br/>console.log(string.includes("Hello World!")); // true<br/><br/>console.log(string.includes("Hello World!!")); // false</span></pre><p id="11a6" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">它的主要限制是区分大小写，所以它不能处理包含大写和小写字符的字符串。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="4075" class="mr ld ir mi b be ms mt l mu mv">const string = "Hello World!";<br/><br/>console.log(string.includes("hello")); // false</span></pre><p id="d5ad" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们可以通过在执行检查之前将字符串变成小写来解决这个问题。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="da81" class="mr ld ir mi b be ms mt l mu mv">const string = "Hello World!";<br/>const substring = "HeLLo";<br/><br/>console.log(string.toLowerCase().includes(substring.toLowerCase())); // true</span></pre><h1 id="b39a" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">String.prototype.indexOf()</h1><p id="eefd" class="pw-post-body-paragraph ke kf ir kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">第二种方法使用<code class="fe mf mg mh mi b"><a class="ae kd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf" rel="noopener ugc nofollow" target="_blank">String.prototype.indexOf()</a></code>。此方法返回子字符串在字符串中第一个匹配项的索引，如果没有找到，则返回-1。然后，我可以将索引转换为布尔值。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="d8bd" class="mr ld ir mi b be ms mt l mu mv">const string = "Hello World!";<br/><br/>console.log(string.indexOf("Hello") !== -1); // true<br/>console.log(!string.indexOf("Hello")); // true</span></pre><p id="2fca" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">同样，该方法区分大小写。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="857f" class="mr ld ir mi b be ms mt l mu mv">const string = "Hello World!";<br/>const substring = "HeLLo";<br/><br/>console.log(!string.indexOf(substring)); // false<br/><br/>console.log(!string.toLowerCase().indexOf(substring.toLowerCase())); // true</span></pre><h1 id="dd8f" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">聚合填料</h1><p id="fbf9" class="pw-post-body-paragraph ke kf ir kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">如果我必须使用一个遗留浏览器(我有时会这样做)，仍然可以创建一个polyfill来添加<code class="fe mf mg mh mi b">String.prototype.includes()</code>方法。为此，我再次使用了<code class="fe mf mg mh mi b">String.prototype.indexOf()</code>,但是用<code class="fe mf mg mh mi b">includes()</code>方法隐藏了它。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="3362" class="mr ld ir mi b be ms mt l mu mv">if (!String.prototype.includes) {<br/>  String.prototype.includes = function (search, start) {<br/>    "use strict";<br/>    if (typeof start !== "number") {<br/>      start = 0;<br/>    }<br/><br/>    if (start + search.length &gt; this.length) {<br/>      return false;<br/>    } else {<br/>      return this.indexOf(search, start) !== -1;<br/>    }<br/>  };<br/>}</span></pre><h1 id="20b6" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">knuth–Morris–Pratt算法</h1><p id="f13d" class="pw-post-body-paragraph ke kf ir kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">另一个解决方案是使用<a class="ae kd" href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" rel="noopener ugc nofollow" target="_blank">Knuth–Morris–Pratt</a>。该算法始于20世纪70年代，允许非常快速的搜索，并且经常被用作其他字符串搜索算法的基础。这是Nayuki的版本</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="80a9" class="mr ld ir mi b be ms mt l mu mv">function kmpSearch(pattern, text) {<br/>  if (pattern.length == 0) return 0; // Immediate match<br/><br/>  // Compute longest suffix-prefix table<br/>  var lsp = [0]; // Base case<br/>  for (var i = 1; i &lt; pattern.length; i++) {<br/>    var j = lsp[i - 1]; // Start by assuming we're extending the previous LSP<br/>    while (j &gt; 0 &amp;&amp; pattern[i] !== pattern[j]) j = lsp[j - 1];<br/>    if (pattern[i] === pattern[j]) j++;<br/>    lsp.push(j);<br/>  }<br/><br/>  // Walk through text string<br/>  var j = 0; // Number of chars matched in pattern<br/>  for (var i = 0; i &lt; text.length; i++) {<br/>    while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) j = lsp[j - 1]; // Fall back in the pattern<br/>    if (text[i] == pattern[j]) {<br/>      j++; // Next char matched, increment position<br/>      if (j == pattern.length) return i - (j - 1);<br/>    }<br/>  }<br/>  return -1; // Not found<br/>}<br/><br/>console.log(kmpSearch("ays", "haystack") != -1); // true<br/>console.log(kmpSearch("asdf", "haystack") != -1); // false</span></pre><h1 id="a3ed" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">其他解决方案</h1><figure class="mj mk ml mm gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/dd33e17af4f771408633f76f57da1e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elsYofiGNP5Cc-Vtfi636Q.jpeg"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Image by <a class="ae kd" href="https://medium.com/@el3um4s" rel="noopener">Samuele</a></figcaption></figure><p id="94a3" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">但这不是我们唯一可以走的路。还有其他的可能性，只要你稍微推动一下JavaScript。我不推荐使用它们，但是它们对于理解JavaScript如何工作很有意思。</p><p id="9515" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">在接下来的例子中，我将使用两个变量，<code class="fe mf mg mh mi b">string</code>和<code class="fe mf mg mh mi b">substring</code>，它们将分别包含要搜索的字符串和子字符串。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="5585" class="mr ld ir mi b be ms mt l mu mv">const string = "Hello World!";<br/>const substring = "Hello";</span></pre><p id="da18" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我可以使用<code class="fe mf mg mh mi b"><a class="ae kd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" rel="noopener ugc nofollow" target="_blank">String.prototype.match()</a></code>来匹配正则表达式搜索的结果。如果搜索一无所获，则返回<code class="fe mf mg mh mi b">null</code>。然后，我将结果转换成一个布尔值。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="e7e9" class="mr ld ir mi b be ms mt l mu mv">console.log(!!string.match(substring)); // true</span></pre><p id="dc20" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">类似地，如果搜索一无所获,<code class="fe mf mg mh mi b"><a class="ae kd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search" rel="noopener ugc nofollow" target="_blank">String.prototype.search()</a></code>将返回<code class="fe mf mg mh mi b">-1</code>。所以我只检查结果是否大于等于零。</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="9212" class="mr ld ir mi b be ms mt l mu mv">console.log(string.search(substring) &gt;= 0); // true</span></pre><p id="71a2" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">另一种方法是用空值替换子字符串，并检查字符串的长度是否发生了变化。或者我也可以简单地验证它不等于它本身。为此，我使用了<code class="fe mf mg mh mi b"><a class="ae kd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace" rel="noopener ugc nofollow" target="_blank">String.prototype.replace()</a></code>方法</p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="2e3c" class="mr ld ir mi b be ms mt l mu mv">console.log(string.replace(substring, "") != string); // true<br/>console.log(string.replace(substring, "").length != string.length); // true</span></pre><h1 id="1b1e" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">startWith()和endsWith()</h1><p id="a64e" class="pw-post-body-paragraph ke kf ir kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">最后，如果我只想检查开始或结束，我可以使用<code class="fe mf mg mh mi b"><a class="ae kd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith" rel="noopener ugc nofollow" target="_blank">String.prototype.startsWith()</a></code>和<code class="fe mf mg mh mi b"><a class="ae kd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith" rel="noopener ugc nofollow" target="_blank">String.prototype.endsWith()</a></code></p><pre class="mj mk ml mm gu mn mi mo bn mp mq bi"><span id="f980" class="mr ld ir mi b be ms mt l mu mv">const string = "Hello World!";<br/><br/>console.log(string.startsWith("Hello")); // true<br/>console.log(string.endsWith("!")); // true</span></pre><p id="e1a3" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这两种方法在特定的情况下会很有用，而且可能会比你想象的更多。但如果你想做一个通用的搜索，最好使用另一种解决方案。</p><h1 id="ac2c" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="dd0d" class="pw-post-body-paragraph ke kf ir kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">好吧，我要说这十个解决方案就够了。除了与这个具体案例相关的娱乐之外，花点时间探索各种可用的解决方案总是值得的。第一个想法并不总是最好的。而且，总的来说，这是一个更好地了解一个话题和提高技能的方法。</p><p id="8ebf" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">感谢阅读！敬请关注更多内容。</p></div><div class="ab cl mw mx hv my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ik il im in io"><p id="9ef0" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><strong class="kg is"> <em class="nd">不要错过我的下一篇文章—报名参加我的</em> </strong> <a class="ae kd" href="https://medium.com/subscribe/@el3um4s" rel="noopener"> <strong class="kg is"> <em class="nd">中邮箱列表</em> </strong> </a></p><div class="ne nf gq gs ng nh"><a href="https://el3um4s.medium.com/membership" rel="noopener follow" target="_blank"><div class="ni ab fp"><div class="nj ab nk cl cj nl"><h2 class="bd is gz z fq nm fs ft nn fv fx iq bi translated">通过我的推荐链接加入Medium—Samuele</h2><div class="no l"><h3 class="bd b gz z fq nm fs ft nn fv fx dk translated">阅读萨缪尔的每一个故事(以及媒体上成千上万的其他作家)。不是中等会员？在这里加入一块…</h3></div><div class="np l"><p class="bd b dl z fq nm fs ft nn fv fx dk translated">el3um4s.medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jx nh"/></div></div></a></div><p id="862f" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><em class="nd">更多内容请看</em><a class="ae kd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kg is"><em class="nd">plain English . io</em></strong></a><em class="nd">。报名参加我们的</em> <a class="ae kd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kg is"> <em class="nd">免费周报</em> </strong> </a> <em class="nd">。关注我们上</em><a class="ae kd" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kg is"><em class="nd">Twitter</em></strong></a><a class="ae kd" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kg is"><em class="nd">LinkedIn</em></strong></a><strong class="kg is"><em class="nd"/></strong><a class="ae kd" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kg is"><em class="nd">YouTube</em></strong></a><strong class="kg is"><em class="nd"/></strong><em class="nd">和</em> <a class="ae kd" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kg is"> <em class="nd">不和</em> </strong> </a>  <em class="nd">对成长黑客感兴趣？检查</em> <a class="ae kd" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kg is"> <em class="nd">电路</em> </strong> </a> <strong class="kg is"> <em class="nd">。</em> </strong></p></div></div>    
</body>
</html>