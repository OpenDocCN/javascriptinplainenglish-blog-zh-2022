<html>
<head>
<title>React Navigation v6 with TypeScript: Nested Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用类型脚本反应导航版本6:嵌套导航</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-navigation-v6-with-typescript-nested-navigation-part-2-87844f643e37?source=collection_archive---------1-----------------------#2022-08-18">https://javascript.plainenglish.io/react-navigation-v6-with-typescript-nested-navigation-part-2-87844f643e37?source=collection_archive---------1-----------------------#2022-08-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0f14" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:关于如何使用TypeScript为React应用程序设置带有完整类型检查的嵌套导航的教程。</h2></div><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div class="ab gu cl kh"><img src="../Images/ea41d4a6efa19ede40f6cfa670639004.png" data-original-src="https://miro.medium.com/v2/0*qaSKyDhk-eJnN9-C"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Photo by <a class="ae ko" href="https://unsplash.com/es/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="829a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在我们已经熟悉了设置您的<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/react-navigation-v6-with-typescript-5c9c065d45a5">React Native mobile application navigation with type script</a>。让我们通过设置带有完整类型检查的嵌套导航来更进一步。</p><p id="f1ed" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">让我们在不同的导航器中使用另一个名为Feeds的屏幕来扩展3个屏幕(主页、个人资料和设置)。在我们继续之前，我对前一个系列的源代码做了一些修改，从堆栈导航切换到底部选项卡导航。除了以下几点，没有太大的区别:</p><pre class="kc kd ke kf gt ll lm ln lo aw lp bi"><span id="ee10" class="lq lr in lm b gy ls lt l lu lv">// from <br/>const Stack = createNativeStackNavigator&lt;RootStackParamList&gt;();</span><span id="98d9" class="lq lr in lm b gy lw lt l lu lv"><em class="lx">// to<br/>const BottomTab = createBottomTabNavigator&lt;RootStackParamList&gt;()</em>;</span></pre><p id="91f6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">下面是公共gist的链接，看看改动:<a class="ae ko" href="https://gist.github.com/cremirdevio/519a2ac54be0b601a63cb330ce0596a2.js" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/cremirdevio/519 a2 AC 54 be 0 b 601 a 63 CB 30 ce 0596 a 2 . js</a></p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="c07f" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这是我们将在本文中实现的导航结构。我们将看到如何使用下面的结构对嵌套导航进行类型检查。底部选项卡导航将嵌套到堆栈导航中。</p><p id="3440" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们的根导航将是一个堆栈导航，其中一个堆栈导航屏幕(主导航)将包含一个底部选项卡导航。</p><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/f3b964303ab61b18def11b12c7d919a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7xuf-NqCxgX9uOHaxGpMQ.png"/></div></div></figure><p id="e6b0" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们开始吧🚀🚀🚀</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="b4d3" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">记住所涉及的两(2)个步骤:<strong class="kr io">类型检查导航器</strong>和<strong class="kr io">类型检查单个屏幕:</strong></p><ol class=""><li id="1ab5" class="mk ml in kr b ks kt kv kw ky mm lc mn lg mo lk mp mq mr ms bi translated"><strong class="kr io">类型检查导航仪</strong></li></ol><p id="f010" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">注意:</strong>您可以通过传递嵌套屏幕的<code class="fe mt mu mv lm b">screen</code>和<code class="fe mt mu mv lm b">params</code>属性来<a class="ae ko" href="https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator" rel="noopener ugc nofollow" target="_blank">导航到嵌套导航器</a>中的一个屏幕，如下所示:</p><pre class="kc kd ke kf gt ll lm ln lo aw lp bi"><span id="f0b2" class="lq lr in lm b gy ls lt l lu lv">// This is an example where the <strong class="lm io">Feed</strong> Screen is nested in another<br/>// Navigator named <strong class="lm io">Home</strong></span><span id="157e" class="lq lr in lm b gy lw lt l lu lv">navigation.navigate('Home', {<br/>  screen: 'Feed',<br/>  params: { sort: 'latest' },<br/>});</span></pre><p id="26cd" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在，让我们看看如何对它进行类型检查。</p><p id="1d35" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">因为我们的根导航将只包含2个屏幕，所以让我们根据需要调整<strong class="kr io"><em class="lx">RootStackParamList</em></strong>。</p><pre class="kc kd ke kf gt ll lm ln lo aw lp bi"><span id="02ea" class="lq lr in lm b gy ls lt l lu lv"><em class="lx">export</em> <em class="lx">type</em> <strong class="lm io">RootStackParamList</strong> <em class="lx">=</em> {<br/>  <em class="lx">MainNav:</em> undefined;<br/>  <em class="lx">Feed:</em> undefined;<br/>};</span></pre><p id="0add" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们还将创建另一个对象来定义底部选项卡屏幕(我们称之为<strong class="kr io"> BottomTabParamList </strong>)。</p><pre class="kc kd ke kf gt ll lm ln lo aw lp bi"><span id="13f3" class="lq lr in lm b gy ls lt l lu lv"><em class="lx">export</em> <em class="lx">type</em> <strong class="lm io">BottomTabParamList</strong> <em class="lx">=</em> {<br/>  <em class="lx">Home:</em> undefined;<br/>  <em class="lx">Profile:</em> undefined;<br/>  <em class="lx">Settings:</em> undefined;<br/>};</span></pre><p id="9347" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们做以下操作来声明<em class="lx">底部选项卡屏幕</em>为<em class="lx">根堆栈</em>中<strong class="kr io"> <em class="lx"> MainNav </em> </strong>屏幕的子。</p><pre class="kc kd ke kf gt ll lm ln lo aw lp bi"><span id="578e" class="lq lr in lm b gy ls lt l lu lv"><em class="lx">export</em> <em class="lx">type</em> RootStackParamList <em class="lx">=</em> {<br/>  <em class="lx">MainNav</em><strong class="lm io"><em class="lx">: </em>NavigatorScreenParams&lt;BottomTabParamList&gt;;</strong><br/>  <em class="lx">Feed:</em> undefined;<br/>};</span></pre><p id="9b3d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">事情是这样的:我们需要提取底部选项卡屏幕的参数(<em class="lx">主页、配置文件和设置</em>)，并将它们分配为<strong class="kr io"> <em class="lx">主导航</em> </strong>路线的<em class="lx">参数</em>。这可以通过使用<code class="fe mt mu mv lm b"><strong class="kr io">NavigatorScreenParams</strong></code>实用程序，将我们的<em class="lx">BottomTabParamList</em><strong class="kr io"/>作为参数来完成。</p><p id="4a1c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">仅仅这样做就使<strong class="kr io"> Feeds屏幕</strong>能够导航到<strong class="kr io"> MainNav </strong>路线内的嵌套屏幕。见下图:</p><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mw"><img src="../Images/386924e0ce5d03baffe2d04c91b9d3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTlG6Fat45Q0uwtAp1E6Ug.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">When <strong class="bd mx"><em class="my">MainNav: undefined, </em></strong><em class="my">FeedScreen has no access to the nested navigation screens.</em></figcaption></figure><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mz"><img src="../Images/9835143a65ec1747859245c576942c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*186g0Qrlzz36TmxrHWrgeA.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk"><em class="my">Now, when </em><strong class="bd mx"><em class="my">MainNav: </em>NavigatorScreenParams&lt;BottomTabParamList&gt;<em class="my">, </em></strong><em class="my">FeedScreen has access to the nested navigation screens.</em></figcaption></figure><p id="2c84" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">2.<strong class="kr io">检查单个屏幕的类型</strong></p><p id="cf0e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">最初，我们了解到React Navigation中的导航器包导出了一个<strong class="kr io">通用类型</strong>来定义来自相应导航器的<code class="fe mt mu mv lm b">navigation</code>和<code class="fe mt mu mv lm b">route</code>道具的类型。</p><p id="0493" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">例如，您可以将<code class="fe mt mu mv lm b"><strong class="kr io">NativeStackScreenProps</strong></code>用于本机堆栈导航器(<code class="fe mt mu mv lm b">@react-navigation/native</code>)；将<code class="fe mt mu mv lm b"><strong class="kr io">StackScreenProps</strong></code>用于堆栈导航器(<code class="fe mt mu mv lm b">@react-navigation/stack</code>)；将<code class="fe mt mu mv lm b"><strong class="kr io">DrawerScreenProps</strong></code>用于抽屉导航器(<code class="fe mt mu mv lm b">@react-navigation/drawer</code>)；将<code class="fe mt mu mv lm b"><strong class="kr io">BottomTabScreenProps</strong></code>用于底部标签导航器(<code class="fe mt mu mv lm b">@react-navigation/bottom-tabs</code>)等等。</p><p id="6f0d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">当您嵌套导航器时，屏幕的导航属性是多个导航属性的组合。例如，如果我们在堆栈中有一个选项卡(就像我们的例子一样)，那么<code class="fe mt mu mv lm b">navigation</code> prop将同时有<code class="fe mt mu mv lm b">jumpTo</code>(来自选项卡导航器)和<code class="fe mt mu mv lm b">push</code>(来自堆栈导航器)。为了更容易地组合来自多个导航器的类型，您可以使用<code class="fe mt mu mv lm b"><strong class="kr io">CompositeScreenProps</strong></code>类型。</p><p id="4cc1" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们的主屏幕的道具类型应该是这样的:</p><pre class="kc kd ke kf gt ll lm ln lo aw lp bi"><span id="d94c" class="lq lr in lm b gy ls lt l lu lv"><em class="lx">import</em> <em class="lx">type</em> { <em class="lx">CompositeScreenProps</em> } <em class="lx">from</em> '@react-navigation/native';<br/><em class="lx">import</em> <em class="lx">type</em> { <em class="lx">BottomTabScreenProps</em> } <em class="lx">from</em> '@react-navigation/bottom-tabs';<br/><em class="lx">import</em> <em class="lx">type</em> { NativeStackScreenProps } <em class="lx">from</em> '@react-navigation/stack';</span><span id="e317" class="lq lr in lm b gy lw lt l lu lv"><em class="lx">type</em> <strong class="lm io">HomeScreenNavigationProp</strong> <em class="lx">=</em> <strong class="lm io">CompositeScreenProps</strong>&lt;<br/>  BottomTabScreenProps&lt;BottomTabParamList, 'Home'&gt;,<br/>  NativeStackScreenProps&lt;RootStackParamList&gt;<br/>&gt;;</span></pre><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi na"><img src="../Images/a8a45d66b077faada7746b536f8760dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8quj5H07H26obrBirqs6uw.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">All is looking good 🥳</figcaption></figure><p id="4de6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">先来了解一下<code class="fe mt mu mv lm b"><strong class="kr io">CompositeScreenProps</strong></code> <strong class="kr io"> </strong>的效用。</p><p id="76d8" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><code class="fe mt mu mv lm b">CompositeScreenProps</code>类型有两个参数，第一个参数是<strong class="kr io">主导航</strong>的属性类型(拥有这个屏幕的导航器的类型，在我们的例子中是包含<code class="fe mt mu mv lm b">Home</code>屏幕的底部选项卡导航器)，第二个参数是辅助导航的属性类型(父导航器的类型，在我们的例子中是本地堆栈导航器)。<strong class="kr io">主要类型</strong>应始终将<em class="lx">屏幕的路线名称作为其第二个参数</em>。</p><p id="b626" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">组成2个屏幕道具的主要重要性是什么？</strong></p><pre class="kc kd ke kf gt ll lm ln lo aw lp bi"><span id="4502" class="lq lr in lm b gy ls lt l lu lv"><strong class="lm io">CompositeScreenProps</strong>&lt;<br/>  BottomTabScreenProps&lt;BottomTabParamList, '<strong class="lm io">&lt;Screen Route Name&gt;</strong>'&gt;,<br/>  NativeStackScreenProps&lt;RootStackParamList&gt;<br/>&gt;;</span></pre><p id="ce0e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">完成以上操作后，我们底部选项卡屏幕中的导航属性可以直接导航到FeedScreen。</p><p id="7e17" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">默认情况下，底部选项卡导航器中的导航属性只能导航到其导航器中的屏幕/路线。请参见下面的示例:</p><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nb"><img src="../Images/2621f261f4c2eff73f80310c3d18db74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5F66BiRLfI00buzXKHk53A.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Feeds route is not available to the navigate function. 𐄂</figcaption></figure><p id="759e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">让我们看看当我们使用<code class="fe mt mu mv lm b"><strong class="kr io">CompositeScreenProps</strong></code>工具合成屏幕道具时是什么样子的。</p><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nc"><img src="../Images/fa2ad139da782c848724ae4226b1b03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nuojTIR8hVnry5zH7hqhg.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Feeds route is available to the navigate function. ☑️</figcaption></figure><p id="5295" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在这里了解更多关于React Navigation with TypeScript的信息:<a class="ae ko" href="https://reactnavigation.org/docs/typescript/#nesting-navigators" rel="noopener ugc nofollow" target="_blank">https://React Navigation . org/docs/TypeScript/# nesting-navigators</a></p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="f31f" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><em class="lx">更多内容请看</em> <a class="ae ko" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="lx">说白了。报名参加我们的</em> <a class="ae ko" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="lx">免费周报</em> </strong> </a> <em class="lx">。关注我们</em> <a class="ae ko" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="lx">推特</em> </strong> </a>，<a class="ae ko" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="lx">LinkedIn</em></strong></a><em class="lx">，</em><a class="ae ko" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="lx">YouTube</em></strong></a><em class="lx">，以及</em> <a class="ae ko" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="lx">不和</em> </strong> </a> <em class="lx">。</em></strong></a></p></div></div>    
</body>
</html>