<html>
<head>
<title>How to Destructure Data in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中析构数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/destructuring-data-in-javascript-314efe817641?source=collection_archive---------10-----------------------#2022-02-17">https://javascript.plainenglish.io/destructuring-data-in-javascript-314efe817641?source=collection_archive---------10-----------------------#2022-02-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="76cf" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是解构数据，如何使用它？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/76db4454ccbd9cd70204b7108ccfc009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rxlvmQK8geacfpbx"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@iurte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Iker Urteaga</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b90c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你读过我的关于spread和rest语法的故事，你会记得它是用来“扩展”变量或参数的，参数的个数是不确定的。在某种程度上，解构是相反的。它允许您通过分解数据，只提取需要的数据来创建特定的数据集合。析构可用于数组、对象或两者的某种组合。</p><h1 id="6325" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">解构数组</h1><p id="9ab8" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">析构数组最基本的用途是将数组的单个值赋给它们自己的变量。考虑下面的例子:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="bea9" class="mr lq in mn b gy ms mt l mu mv">let colors = ['green', 'orange', 'yellow'];<br/>const [colorA, colorB, colorC] = colors;<br/>console.log(colorA); // 'green'<br/>console.log(colorB); // 'orange'<br/>console.log(colorC); // 'yellow'</span></pre><p id="1e97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从包含三个字符串的原始数组<code class="fe mw mx my mn b">colors</code>中，我们可以对其进行析构，以便将这三个项目分配给它们自己的变量<code class="fe mw mx my mn b">colorA</code>、<code class="fe mw mx my mn b">colorB</code>和<code class="fe mw mx my mn b">colorC</code>。这也可以用比数组值更多或更少的变量来实现，任何没有被赋予数组值的变量都将是<code class="fe mw mx my mn b">undefined</code>:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="313e" class="mr lq in mn b gy ms mt l mu mv">let colors = ['green', 'orange', 'yellow'];<br/>const [colorA, colorB, colorC, colorD] = colors;<br/>console.log(colorA); // 'green'<br/>console.log(colorB); // 'orange'<br/>console.log(colorC); // 'yellow'<br/>console.log(colorD); // undefined</span></pre><p id="622d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您想防止未定义的变量，您也可以为它们分配一个默认值:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="4e69" class="mr lq in mn b gy ms mt l mu mv">let colors = ['green', 'orange', 'yellow'];<br/>const [colorA='blue', colorB, colorC, colorD='purple'] = colors;<br/>console.log(colorA); // 'green'<br/>console.log(colorB); // 'orange'<br/>console.log(colorC); // 'yellow'<br/>console.log(colorD); // 'purple'</span></pre><p id="1289" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">析构也可以应用于从函数返回的数组，它们甚至可以被格式化为忽略某些索引:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="2bdc" class="mr lq in mn b gy ms mt l mu mv">function giveColors() {<br/>    return ['green', 'orange', 'yellow'];<br/>}</span><span id="e70c" class="mr lq in mn b gy mz mt l mu mv">const [colorA, , colorB] = giveColors();<br/>console.log(colorA); // 'green'<br/>console.log(colorB); // 'yellow'</span></pre><p id="62b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用析构时容易犯的一个错误是忘记了<code class="fe mw mx my mn b">const [colors] = giveColors()</code>将只捕获返回的数组中的第一个元素，而<code class="fe mw mx my mn b">const colors = giveColors()</code>将捕获整个数组。</p><p id="c32f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">析构也可以与rest语法结合使用来捕获数组的剩余部分:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="53a3" class="mr lq in mn b gy ms mt l mu mv">function giveColors() {<br/>    return ['green', 'orange', 'yellow'];<br/>}</span><span id="bf07" class="mr lq in mn b gy mz mt l mu mv">const [colorA, ...colors] = giveColors();<br/>console.log(colorA); // 'green'<br/>console.log(colors); // ['orange', 'yellow']</span></pre><h1 id="a7ca" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">解构对象</h1><p id="3277" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">可以通过析构来操作对象，方法与数组非常相似:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="43b0" class="mr lq in mn b gy ms mt l mu mv">const color = {<br/>    name: 'Orange',<br/>    isPrimary: false<br/>};<br/><br/>let {name, isPrimary} = color;<br/><br/>console.log(name); // 'Orange'<br/>console.log(isPrimary); // false</span></pre><p id="a47b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它还可以用于重新分配属性名称:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="22f6" class="mr lq in mn b gy ms mt l mu mv">let coord = {x: 60, y: 12};<br/>const {x: a, y: b} = coord;</span><span id="1c42" class="mr lq in mn b gy mz mt l mu mv">console.log(a); // 60<br/>console.log(b); // 12</span></pre><p id="3ed6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用重新分配并提供默认值，我们可以做到以下几点:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="83cd" class="mr lq in mn b gy ms mt l mu mv">let coord = {x: 60, y: 12};<br/>const {x: a=1, y: b=1, z: c=1} = coord;</span><span id="b0c5" class="mr lq in mn b gy mz mt l mu mv">console.log(a); // 60<br/>console.log(b); // 12<br/>console.log(c); // 1</span></pre><p id="2460" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对象甚至可以解包到函数参数中，允许它们被重命名或按原样传递:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="d801" class="mr lq in mn b gy ms mt l mu mv">function outputCoords({x, y, z:height}){<br/>    console.log("Located at "+x+", "+y+" at a height of "+height);<br/>}</span><span id="edc3" class="mr lq in mn b gy mz mt l mu mv">const loc = {x: 12, y: 15, z: 4};<br/>outputCoords(loc); // Located at 12, 15 at a height of 4;</span></pre><p id="0358" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，您可以如上所示为这些参数提供默认值，甚至可以嵌套对象和数组以增加复杂性。与数组一样，rest操作符可用于捕获一组属性:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="7692" class="mr lq in mn b gy ms mt l mu mv">let loc = {x: 60, y: 12, z: 4, time: '0850', duration: 0.42};<br/>let {x, y, z:height, ...extras} = loc;<br/>console.log(x); // 60<br/>console.log(y); // 12<br/>console.log(height); // 4<br/>console.log(extras); // {time: '0850', duration: 0.42}</span></pre><p id="ebd2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的例子中，<code class="fe mw mx my mn b">x</code>和<code class="fe mw mx my mn b">y</code>被原样捕获，<code class="fe mw mx my mn b">z</code>被重命名为<code class="fe mw mx my mn b">height</code>，其余的属性使用rest操作符存储在<code class="fe mw mx my mn b">extras</code>中。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="c1b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">析构的应用是无限的。我希望你和我一样，掌握这些新知识，并将其应用到未来的项目中。</p><h2 id="4b26" class="mr lq in bd lr nh ni dn lv nj nk dp lz lc nl nm mb lg nn no md lk np nq mf nr bi translated"><strong class="ak">延伸阅读:</strong></h2><div class="ns nt gp gr nu nv"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">析构赋值- JavaScript | MDN</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">析构赋值语法是一个JavaScript表达式，它使得从数组中解包值成为可能，或者…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">developer.mozilla.org</p></div></div><div class="oe l"><div class="of l og oh oi oe oj km nv"/></div></div></a></div><p id="91cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ok">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ok">plain English . io</em></strong></a><em class="ok">。报名参加我们的</em><strong class="kv io"><em class="ok"/></strong><a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ok">免费周报</em> </strong> </a> <em class="ok">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="ok">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="ok">。</em></p></div></div>    
</body>
</html>