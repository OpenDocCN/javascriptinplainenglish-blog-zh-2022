<html>
<head>
<title>7 Super Useful Utility Functions I Learned from Vue3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我从Vue3学到的7个超级有用的实用函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-super-useful-utility-functions-i-learned-from-vue3-adc6c93067b?source=collection_archive---------11-----------------------#2022-03-28">https://javascript.plainenglish.io/7-super-useful-utility-functions-i-learned-from-vue3-adc6c93067b?source=collection_archive---------11-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d565" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">像专家一样编写可重用的函数。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/51c5ba75d8a1d8ca064e7d6ee6ec7b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bj49EwIOXR8YbgXyztMB_Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><p id="0af4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将向您展示Vue3中一些令人惊叹的实用函数，它们的源代码是<a class="ae lr" href="https://github.com/vuejs/core/blob/main/packages/shared/src/index.ts" rel="noopener ugc nofollow" target="_blank">这里是</a>。这些函数高度可重用，对于日常开发非常有用，所以让我们开始吧！</p><h1 id="7dc0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.确定字符串是否以on开头</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/182faa38dbd0ebfdd85009c53a3d0b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1Crn9KLI0O41lUrZ2kkRA.png"/></div></div></figure><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="706c" class="mq lt iq mm b gy mr ms l mt mu"><strong class="mm ir">const onRE = /^on[^a-z]/;<br/>const isOn = (key: string) =&gt; onRE.test(key);</strong></span><span id="00de" class="mq lt iq mm b gy mv ms l mt mu">console.log(isOn('onClick')); // true<br/>console.log(isOn('onclick')); // false</span></pre><p id="7722" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以看到它使用了常规匹配。它将匹配以<code class="fe mw mx my mm b">on</code>开头并且下一个字符不是<code class="fe mw mx my mm b">a</code>到<code class="fe mw mx my mm b">z</code>的字母。</p><h1 id="1737" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.确定p <strong class="ak">属性</strong>是否是自己的</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/3f902da412cf998c0c7366a1785ef91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LN1NyiDjhJlyWXPgQOjYxg.png"/></div></div></figure><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="16a6" class="mq lt iq mm b gy mr ms l mt mu"><strong class="mm ir">const hasOwnProperty = Object.prototype.hasOwnProperty;<br/>const hasOwn = (val: object, key: string | symbol): key is keyof typeof val =&gt;<br/>  hasOwnProperty.call(val, key);</strong></span><span id="7b89" class="mq lt iq mm b gy mv ms l mt mu">const testObj = { name: 1 };<br/>console.log(hasOwn(testObj, 'name')); // true</span><span id="52e0" class="mq lt iq mm b gy mv ms l mt mu">Object.getPrototypeOf(testObj).age = 2;<br/>console.log(hasOwn(testObj, 'age')); // false</span></pre><p id="628e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个方法使用<code class="fe mw mx my mm b">Object.prototype.hasOwnProperty</code>来确定一个键是否是对象本身的属性。</p><p id="f25b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们使用<code class="fe mw mx my mm b">Object.getPrototypeOf()</code>获取testObj的原型并在其上设置age属性时，hasOwn将返回false。</p><p id="24ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中，它在这里使用了TypeScript的<code class="fe mw mx my mm b">is</code>关键字，这创建了一个用户定义的类型保护，它在运行时检查以确保它是我们在特定范围内期望的类型。如果你不确定，可以看看我之前的文章。</p><h1 id="7231" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.确定它是否是一个承诺</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/c93ee9bd3893447d890264c4390374fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZGdvmHM0i9mWuvY4tq7ig.png"/></div></div></figure><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="b495" class="mq lt iq mm b gy mr ms l mt mu">const isObject = (val: unknown): val is Record&lt;any, any&gt; =&gt;<br/>  val !== null &amp;&amp; typeof val === 'object';<br/>const isFunction = (val: unknown): val is Function =&gt; typeof val === 'function';</span><span id="94fc" class="mq lt iq mm b gy mv ms l mt mu"><strong class="mm ir">const isPromise = &lt;T = any&gt;(val: unknown): val is Promise&lt;T&gt; =&gt; {<br/>  return isObject(val) &amp;&amp; isFunction(val.then) &amp;&amp;      isFunction(val.catch);<br/>};</strong></span><span id="a3ba" class="mq lt iq mm b gy mv ms l mt mu">console.log(isPromise(new Promise(() =&gt; {}))); // true<br/>console.log(isPromise(async function () {})); // false<br/>console.log(isPromise(function* () {})); // false</span></pre><p id="22a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个方法借用<code class="fe mw mx my mm b">isObject</code>来确定当前值是一个对象，借用<code class="fe mw mx my mm b">isFunction</code>来确定当前值的<code class="fe mw mx my mm b">then</code>和<code class="fe mw mx my mm b">catch</code>属性是函数。</p><p id="468b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">他们三个也都使用了<code class="fe mw mx my mm b">is</code>关键字。此外，<code class="fe mw mx my mm b">isPromise</code>还使用泛型来传递Promise的结果类型。</p><h1 id="4ec9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.确定它是否是整数字符串</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/5128de33ab92a177823c5dc03145aeff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_308YqYzuxRWqVRhzQoOkg.png"/></div></div></figure><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="001b" class="mq lt iq mm b gy mr ms l mt mu">const isString = (val: unknown): val is string =&gt; typeof val === 'string';<br/><strong class="mm ir">const isIntegerKey = (key: unknown) =&gt;<br/>  isString(key) &amp;&amp;<br/>  key !== 'NaN' &amp;&amp;<br/>  key[0] !== '-' &amp;&amp;<br/>  '' + parseInt(key, 10) === key;</strong></span><span id="48bb" class="mq lt iq mm b gy mv ms l mt mu">console.log(isIntegerKey('10')); // true<br/>console.log(isIntegerKey('010')); // false<br/>console.log(isIntegerKey('3.0')); // false<br/>console.log(isIntegerKey('Vue')); // false</span></pre><p id="fb9f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">先用<code class="fe mw mx my mm b">isString</code>判断是否为字符串类型，再判断是否为<code class="fe mw mx my mm b">'NaN'</code>且第一个字符不是<code class="fe mw mx my mm b">-</code>，最后用空字符串将<code class="fe mw mx my mm b">parseInt</code>转换的十进制数转换为字符串，判断是否等于原字符串。</p><h1 id="fa19" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.缓存字符串计算结果</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/0abca1c038b90cf94b0c5f715cbe7cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ip4YJrmgMmFnHpu3N1reQ.png"/></div></div></figure><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="df22" class="mq lt iq mm b gy mr ms l mt mu"><strong class="mm ir">const cacheStringFunction = &lt;T extends (str: string) =&gt; string&gt;(fn: T): T =&gt; {<br/>  const cache: Record&lt;string, string&gt; = Object.create(null);<br/>  return ((str: string) =&gt; {<br/>    const hit = cache[str];<br/>    return hit || (cache[str] = fn(str));<br/>  }) as any;<br/>};</strong></span><span id="7210" class="mq lt iq mm b gy mv ms l mt mu">const getUpperCase = cacheStringFunction((str: string): string =&gt;<br/>  str.toUpperCase(),<br/>);</span><span id="ff77" class="mq lt iq mm b gy mv ms l mt mu">console.log(getUpperCase('a')); // A<br/>console.log(getUpperCase('a')); // A</span></pre><p id="eb6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个高阶函数，它在内部使用一个闭包来缓存以前的计算结果，如果再次调用时发现已经计算过了，就返回以前的结果。</p><h1 id="960b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.连字符到驼峰/驼峰到连字符</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/b0141b9ce423341def67924a256b894a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFFtTSMqUFGpsit-fq3ArQ.png"/></div></div></figure><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="7ffa" class="mq lt iq mm b gy mr ms l mt mu">const cacheStringFunction = &lt;T extends (str: string) =&gt; string&gt;(fn: T): T =&gt; {<br/>  const cache: Record&lt;string, string&gt; = Object.create(null);<br/>  return ((str: string) =&gt; {<br/>    const hit = cache[str];<br/>    return hit || (cache[str] = fn(str));<br/>  }) as any;<br/>};</span><span id="3766" class="mq lt iq mm b gy mv ms l mt mu">const camelizeRE = /-(\w)/g;<br/>const camelize = cacheStringFunction((str: string): string =&gt; {<br/>  return str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : ''));<br/>});</span><span id="afc1" class="mq lt iq mm b gy mv ms l mt mu">const hyphenateRE = /\B([A-Z])/g;<br/>const hyphenate = cacheStringFunction((str: string) =&gt;<br/>  str.replace(hyphenateRE, '-$1').toLowerCase(),<br/>);</span><span id="83fa" class="mq lt iq mm b gy mv ms l mt mu">console.log(camelize('on-click')); // onClick<br/>console.log(camelize('test-a-click')); // testAClick</span><span id="29f5" class="mq lt iq mm b gy mv ms l mt mu">console.log(hyphenate('onClick')); // on-click<br/>console.log(hyphenate('testAClick')); // test-a-click</span></pre><p id="e1f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以上两种方法都是用正则表达式匹配，用<code class="fe mw mx my mm b">String.prototype.replace()</code>替换字符，都是用上一节介绍的缓存函数包装的，也就是说一旦需要处理同一个字符串，会直接返回缓存结果。</p><h1 id="94d5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.获取当前环境的全局对象</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/4225db2884fe4cf9283db8ee676426b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKKshEftVkVVeL9rPwEytw.png"/></div></div></figure><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="5678" class="mq lt iq mm b gy mr ms l mt mu"><strong class="mm ir">let _globalThis: any;<br/>const getGlobalThis = (): any =&gt; {<br/>  return (<br/>    _globalThis ||<br/>    (_globalThis =<br/>      typeof globalThis !== 'undefined'<br/>        ? globalThis<br/>        : typeof self !== 'undefined'<br/>        ? self<br/>        : typeof window !== 'undefined'<br/>        ? window<br/>        : typeof global !== 'undefined'<br/>        ? global<br/>        : {})<br/>  );<br/>};</strong></span><span id="2cd7" class="mq lt iq mm b gy mv ms l mt mu">console.log(getGlobalThis());<br/>console.log(getGlobalThis());</span></pre><p id="28ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里也使用了闭包，但是这次闭包存储的<code class="fe mw mx my mm b">_globalThis</code>是在当前加载的<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noopener ugc nofollow" target="_blank">模块</a>中，这样只需要调用一次，判断一次，不需要后续的判断。</p><p id="8688" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看函数内部的逻辑，它的优先级是:</p><ol class=""><li id="c6ab" class="ne nf iq kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated">使用<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis" rel="noopener ugc nofollow" target="_blank"> globalThis </a>，它提供了跨环境访问全局对象的标准方式。</li><li id="e9ce" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">判断<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/self" rel="noopener ugc nofollow" target="_blank"> self </a>，这是因为在<a class="ae lr" href="https://developer.mozilla.org%20/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank"> Web Workers </a>中，不能访问窗口对象，只能通过<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/self" rel="noopener ugc nofollow" target="_blank"> self </a>访问当前全局对象。</li><li id="7673" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">公共窗口对象。</li><li id="578f" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">Node.js中的全局<a class="ae lr" href="https://nodejs.org/api/globals.html#globals_global" rel="noopener ugc nofollow" target="_blank">对象。</a></li></ol></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="741f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nz">今天就到这里。我是Zachary，我会继续输出与web开发相关的故事，如果你喜欢这样的故事并想支持我，请考虑成为</em> <a class="ae lr" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nz">中级会员</em> </a> <em class="nz">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae lr" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nz">我的链接</em> </a> <em class="nz">报名，我会得到一点佣金。</em></p><p id="39e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你的支持对我来说很重要——谢谢。</p><p id="a52e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nz">更多内容请看</em><a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nz">plain English . io</em></strong></a><em class="nz">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="nz">免费周报</em> </strong> </a> <em class="nz">。关注我们关于</em><a class="ae lr" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nz">Twitter</em></strong></a><em class="nz">和</em><a class="ae lr" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nz">LinkedIn</em></strong></a><em class="nz">。加入我们的</em> <a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="nz">社区不和谐</em> </strong> </a> <em class="nz">。</em></p></div></div>    
</body>
</html>