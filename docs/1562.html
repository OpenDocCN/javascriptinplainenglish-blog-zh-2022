<html>
<head>
<title>Goodbye HTML. Hello Canvas!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再见HTML。你好画布！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/goodbye-html-hello-canvas-3cc1b2e7b096?source=collection_archive---------3-----------------------#2022-04-02">https://javascript.plainenglish.io/goodbye-html-hello-canvas-3cc1b2e7b096?source=collection_archive---------3-----------------------#2022-04-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a78a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第6部分:盒子&amp;开始真正的应用程序</h2></div><p id="943d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里可以看之前的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/goodbye-html-hello-canvas-956cc7d0770f">。</a></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/b325e61c9a27165ec14287d4f32382ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9dzwq0SZYi3awTyPAKiJw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Real App Partial Demo</figcaption></figure><h2 id="f374" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">介绍</h2><p id="6c31" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我承诺的这篇文章的内容变得太大了。我只好把<strong class="ke io">和</strong>分开了。此外，我花了比预期更多的时间来编写代码。我做了很多重构，寻找最好的设计/最大的效用。</p><p id="bc12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经完成了整页引擎的代码，比如BobSprite。然后我意识到，如果我能把引擎转换成模块化的格式，对我们会更有用:一个盒子；你可以把它作为一个特殊网页时代的唯一元素，或者作为一个普通网页的特殊部分(比如视频标签)；实际上，你可以在每个网页上使用很多框。</p><p id="b8d9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我复活了把所有东西都做成纯帆布风格的想法…而且成功了！使用独立的盒子比服从整体引擎的规则更容易(我已经放弃了)。</p><p id="1c34" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">眼下，<em class="mn"> I </em> <strong class="ke io"> <em class="mn">还得创造更多的小工具</em> </strong>。无论如何，它足以成为今天文章的基础。</p><h2 id="e98e" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">真正的应用</h2><p id="57d3" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我为我们的实际应用程序选择了一个带有简单图像版本的马赛克生成器，因为它有用且不常见，并且它的代码不会误导我们对盒子本身的研究。真正的app是<strong class="ke io">还没完成</strong>。</p><h2 id="afc0" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">图书馆</h2><p id="4765" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我尽了最大努力让这个库的使用变得极其友好/直观/安全/不啰嗦。这些目标导致</p><ul class=""><li id="f110" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated">几个功能，有清晰的名称</li><li id="5ff0" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">一个清晰简单的应用程序结构</li><li id="a11e" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">没有可选的函数参数(多种编码方式会造成混乱)</li><li id="fe06" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">这个盒子封装了它能封装的所有东西，(几乎)不给你造成内部错误的机会</li><li id="05b8" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">这个库试图<strong class="ke io">捕捉你可能发生的每一个错误</strong>——它立即停止运行，并在控制台中写入一个<strong class="ke io">清除消息；该消息总是以“未捕获”开头，后跟2个跟踪(“—”)</strong></li><li id="87c6" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">很少，你必须遵守的简单规则</li></ul><p id="851f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:这个库与以前文章中的描述有些不同。</p><h2 id="6639" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">(部分)演示</h2><p id="7df7" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我喜欢单页应用程序。但是我喜欢<strong class="ke io">单文件</strong>应用；尤其是对于简单的演示。这种格式不利于研究代码，我将在文章的最后解决这个问题。</p><p id="dc67" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个演示是一个170.1 kB的单文件应用程序——未压缩；没什么大不了的。除了库和应用程序代码，它还包括嵌入的图像和字体。</p><p id="e75a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是<a class="ae ky" href="https://storage.googleapis.com/jblate/medium/mosaic-partial-demo.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">为演示</strong> </a>的链接。</p><p id="c145" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个演示是使用传统的HTML元素(<h1>、<div>、<br/>)加上两个GoodbyeHtml框和一个GoodbyeHtml <strong class="ke io">标签</strong>构建的。目的是表明现在我们可以在以下两者之间选择<strong class="ke io">和</strong>:</div></h1></p><ul class=""><li id="674d" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated">一个纯粹的GoodbyeHtml应用(就一个大盒子，像BobSprite)</li><li id="850b" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">一个传统的HTML页面，包括尽可能多的GoodbyeHtml框</li></ul><p id="5070" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个盒子仅使用canvas元素构建。浏览器只能看到一个画布。但是在内部，有更多的画布来存储和操作图像。它们都被绘制到盒子的主画布上。</p><p id="11c2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天我们不看库的代码。我们的重点是学习如何使用图书馆。</p><p id="ebc7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些读者担心很难编写基于画布的网页。我希望你会发现使用这个库非常容易。</p><p id="e1b9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们研究一个真正的(不完整的)应用程序的代码的简化版本。</p><h2 id="521b" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">应用程序代码</h2><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="b814" class="lp lq in nd b gy nh ni l nj nk">// (embedded fonts here)<br/>// (embedded images here)</span><span id="bf4b" class="lp lq in nd b gy nl ni l nj nk">"use strict"</span><span id="f696" class="lp lq in nd b gy nl ni l nj nk">var goodbye</span><span id="6ecd" class="lp lq in nd b gy nl ni l nj nk">function main() {<br/>    //<br/>    goodbye = createGoodbyeHtmlLibrary()<br/>    loadResources()<br/>}</span></pre><p id="07c1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们开始创建这个库，并把它赋给一个全局变量，这样它就可以在我们代码的任何地方使用了。</p><p id="6074" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们需要加载资源。</p><h2 id="6760" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">加载资源</h2><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c103df0d048e939b3f62141ce0e62e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*TLC1VoCPlZ9q94QcjxrNhQ.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Loading</figcaption></figure><p id="bf53" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们基于画布的网页就像视频游戏的软件:它需要预先加载所有资源。计算机视频游戏只是从计算机磁盘加载资源。</p><p id="0883" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们的应用程序通过web加载资源时，我们必须有一种方法在继续之前检查资源是否被加载。</p><p id="a460" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">浏览器异步加载资源<em class="mn"/>，<strong class="ke io">甚至是嵌入式资源</strong>。</p><p id="d759" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么我们有一个名为<strong class="ke io"> <em class="mn"> loader </em> </strong> <em class="mn">的库实用程序。</em></p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="335a" class="lp lq in nd b gy nh ni l nj nk">function loadResources() {<br/>    //<br/>    const loader = goodbye.createLoader()<br/>    //<br/>    loader.loadFont("black", fontSourceProSansBlack) <br/>    loader.loadFont("white", fontSourceProSansWhite)<br/>    //<br/>    loader.loadImage("help-black", embededImages["help-black"]) }<br/>    loader.loadImage("load-black", embededImages["load-black"]) }<br/>    //<br/>    loader.ready(resourcesLoaded) // must send a callback<br/>}  <br/>  <br/>function resourcesLoaded() { // the callback <br/>    //<br/>    // processing the images, if needed<br/>    // (more code here)</span></pre><p id="a05c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，使用加载程序需要3个步骤:</p><ul class=""><li id="b265" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated">创建加载程序</li><li id="b3bc" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">要求加载所有资源</li><li id="3883" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">告诉加载器没有更多的资源要加载，哪个是回调函数(在我们的代码中，加载器将在所有资源加载后调用这个函数)</li></ul><p id="e613" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">加载的资源存储在名为<strong class="ke io"> <em class="mn"> allFonts </em> </strong>和<strong class="ke io"> <em class="mn"> allImages </em> </strong>的库变量中。</p><p id="10c6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:本系列的第二篇文章讲述了如何创建字体。</p><h2 id="2f79" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">其他库实用程序</h2><p id="4ca8" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">目前，除了<em class="mn"> createLoader </em>之外，GoodbyeHtml库还有这些实用函数:<em class="mn"> cloneImage </em>、<em class="mn"> createCanvas </em>、<em class="mn"> fadeImage </em>、<em class="mn"> createCheckerboard </em>、<em class="mn"> negativeFromImage </em>、<em class="mn"> createLabel </em>、<em class="mn"> calcTextLength </em>和<strong class="ke io"> <em class="mn"> createBox </em>、</strong>。</p><p id="244a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，使用<em class="mn"> fadeImage </em>我们可以从一个正常的按钮图像创建一个禁用的按钮图像:</p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="ea9f" class="lp lq in nd b gy nh ni l nj nk">const disabled = goodbye.fadeImage(original, "black", 0.40)</span></pre><p id="90df" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个例子:有时我们有白底黑字的图标；点击时会变成白底黑字的图标——反之亦然。当一组和另一组完全相反时，我们不需要加载两组图标。我们可以使用<em class="mn">negative romimage</em>，它同样适用于字体表的<em class="mn"> </em>。</p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="e6cd" class="lp lq in nd b gy nh ni l nj nk">const whiteIcon = goodbye.negativeFromImage(blackIcon)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d190f580f3ba3c1ba0c41e61088fad9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*qxbLwdpzOJ5Dub8UmVjllg.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Original, Negative, and Faded</figcaption></figure><h2 id="2779" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">GoodbyeHtml标签</h2><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="6a2c" class="lp lq in nd b gy nh ni l nj nk">const label = goodbye.createLabel("white", "black", 10,10,5,5, "My label")</span></pre><p id="f7a1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GoodbyeHtml标签是一个图像(更准确地说，是一个画布)，您可以将其视为任何其他图像。其参数是:</p><ul class=""><li id="785b" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated">要使用的字体的id(字符串)</li><li id="4810" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">背景颜色(字符串)</li><li id="61b9" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">左填充(整数)</li><li id="9d26" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">右填充(整数)</li><li id="5a16" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">顶部填充(整数)</li><li id="c74f" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">底部填充(整数)</li><li id="b907" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">文本(字符串)</li></ul><p id="0c27" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你不直接选择宽度和高度。宽度和高度是所选字体和填充的结果。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi no"><img src="../Images/5b2b2cf53132ab63b0e75b3060649895.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*cWDRITTxgaaMCRK-tfK5qg.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">A GoodbyeHtml Label</figcaption></figure><h2 id="9463" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">函数的参数</h2><p id="37e4" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">没有可选参数:没有调用函数的替代方法。这种设计让你轻松掌握本库。</p><p id="9f14" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我试图使库中的参数结构非常标准，并与常见模式兼容。</p><p id="3790" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有坐标/尺寸格式为<strong class="ke io"> <em class="mn">左、上、宽、</em> </strong>和<strong class="ke io"> <em class="mn">高</em> </strong>。</p><p id="7578" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有一个例外；有一种情况下，参数的工作方式与您想象的一样:标签的填充:它们与可怕的CSS模式不匹配。</p><p id="f5e8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于填充的GoodbyeHtml模式<em class="mn">开始</em>喜欢通用模式。</p><p id="9b68" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从左边的<strong class="ke io"> <em class="mn">到左边的</em> </strong>开始。然后它期望<strong class="ke io"> <em class="mn">对</em></strong>；因此很容易将文本<em class="mn">水平放置/居中</em>。</p><p id="cc5f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来是<strong class="ke io"> <em class="mn">顶部</em> </strong>填充，接着是<strong class="ke io"> <em class="mn">底部</em> </strong>填充；使文本<em class="mn">垂直</em>定位/居中变得容易。</p><h2 id="86c5" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">CSS疯狂和虐待狂一瞥</h2><p id="d3d8" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我们为什么去上学？我们上学是为了学习对我们以后的生活非常有用的模式；因为其他人都在学习同样的模式。</p><p id="2478" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，绿色标志表示<em class="mn">前进，</em>红色标志表示<em class="mn">停止</em>。</p><p id="dae7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个例子是笛卡尔坐标:X和Y；通常被翻译为左和上。这是普遍的模式。</p><p id="44af" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">x坐标总是在最前面，然后是y坐标。</strong></p><p id="e01f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以定义一个矩形，告诉它的左上角和右下角:<strong class="ke io"> <em class="mn">左</em> </strong>，<strong class="ke io"> <em class="mn">上</em> </strong>，<strong class="ke io"> <em class="mn">右</em> </strong>，<strong class="ke io"> <em class="mn">下</em> </strong>(或<em class="mn">左、上、宽、高</em>)。</p><p id="739c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们到处都能看到这种情况，这不仅仅是一个编程问题。是数学！</p><p id="8bd0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，进入CSS并说，“<em class="mn">忘记你所学的一切。真正的坐标系是</em> <strong class="ke io"> <em class="mn">上</em> </strong> <em class="mn">，</em> <strong class="ke io"> <em class="mn">右</em> </strong> <em class="mn">，</em> <strong class="ke io"> <em class="mn">下</em> </strong> <em class="mn">，</em> <strong class="ke io"> <em class="mn">左</em> </strong></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4d87ce8717db44d25c8ac01d94a9fb44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*JnWOE0cIELUh_bN-FqCjTQ.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Iron Maiden — The Number Of The Beast</figcaption></figure><p id="0fcd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面我们看到了一张CSS创作者的照片，当时他2岁，正在玩他最心爱的木偶:一个快乐而天真的web开发者。</p><p id="3e7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了与宇宙模式相冲突之外，它还是一派胡言。它不像水平-先-垂直-后，这是有意义的，并尽可能遵循普遍模式。</p><p id="63d2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在那个曾经折磨自己(学习CSS)的年纪，我已经记不住那个愚蠢的“模式”了。然后有一天，看了一本CSS的书，发现了一个帮助我记忆“模式”的窍门。</p><p id="edca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是啊！CSS不是一种语言；这是一个又臭又粘的模糊技巧包。</p><p id="0da5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">骗术就是字<strong class="ke io"> TR </strong> ou <strong class="ke io"> BL </strong> e .不得不承认这是我这辈子见过的最老实的骗术。</p><h2 id="303c" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">创建一个盒子</h2><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="8f1d" class="lp lq in nd b gy nh ni l nj nk">const parent = document.getElementById("first-box")</span><span id="ba56" class="lp lq in nd b gy nl ni l nj nk">const box = goodbye.createBox(1000, 600, parent)</span></pre><p id="d64a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建一个框需要3个参数:宽度、高度和放置框的HTML容器。</p><p id="d361" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你没有附加盒子。<strong class="ke io">框追加自身</strong>。一个更简单的例子:</p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="f4c0" class="lp lq in nd b gy nh ni l nj nk">const box = goodbye.createBox(1000, 600, document.body)</span><span id="59f9" class="lp lq in nd b gy nl ni l nj nk">box.setBgColor("#084d6e")</span></pre><p id="0379" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个盒子公开了4个方法:<em class="mn"> setBgColor </em>，<em class="mn"> initLayers </em>，<em class="mn"> exchangeLayers，</em>和<em class="mn"> getLayer </em>。</p><h2 id="3618" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">创建层</h2><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="ed2a" class="lp lq in nd b gy nh ni l nj nk">// initLayers returns nothing</span><span id="67db" class="lp lq in nd b gy nl ni l nj nk">box.initLayers(["base", "over", "help", "alert"])</span></pre><p id="4526" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，盒子的所有层都被定义了。图层会自动附加到框中。</p><p id="e05c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您不能更改或添加层。你只能改变两件事:</p><ol class=""><li id="5bd8" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx nq mu mv mw bi translated">每层的可见性</li><li id="6c19" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx nq mu mv mw bi translated">各层的顺序</li></ol><p id="a116" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">允许您删除和添加层将会降低代码的可读性和可维护性，因为您可以在代码中的任何地方这样做。此外，这些功能不是必需的。</p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="3a6f" class="lp lq in nd b gy nh ni l nj nk">box.exchangeLayers(["help", "over", "base", "alert"]) // OK</span><span id="15fc" class="lp lq in nd b gy nl ni l nj nk">box.exchangeLayers(["help", "over", "help", "alert"]) // error</span><span id="2242" class="lp lq in nd b gy nl ni l nj nk">// message in console:</span><span id="887f" class="lp lq in nd b gy nl ni l nj nk">Uncaught -- wrong argument ids for function box.exchangeLayers: duplicated item: help</span></pre><p id="189d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数名为<em class="mn"> initLayer </em>，而不是<em class="mn"> createLayer </em>是有原因的:它不返回“layers”对象。你必须使用每一层的<strong class="ke io"> id </strong>(字符串)。</p><p id="e0e8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图层对象有5种方法:<em class="mn"> createPanel </em>、<em class="mn"> show </em>、<em class="mn"> hide </em>、<em class="mn"> visible、</em>log。</p><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="d167" class="lp lq in nd b gy nh ni l nj nk">const a = box.getLayer("alert") // returns a layer object</span><span id="a08d" class="lp lq in nd b gy nl ni l nj nk">a.hide()<br/>a.show()</span><span id="3898" class="lp lq in nd b gy nl ni l nj nk">a.log()</span><span id="8b0a" class="lp lq in nd b gy nl ni l nj nk">let visible = a.visible()</span></pre><p id="318d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:层没有左/上坐标、宽度、高度或背景颜色。其实是虚拟层。</p><h2 id="7a7a" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">创建面板</h2><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="c1dd" class="lp lq in nd b gy nh ni l nj nk">const layer = box.getLayer("base")</span><span id="047a" class="lp lq in nd b gy nl ni l nj nk">const panel = layer.createPanel(0, 0, 1000, 50, "black")<br/>    <br/>panel.paintRect(0, 0, 250, 50, "white")</span><span id="9283" class="lp lq in nd b gy nl ni l nj nk">panel.setFont("black")</span><span id="8e7b" class="lp lq in nd b gy nl ni l nj nk">panel.write(30, 10, "Mosaic Generator")</span></pre><p id="4d91" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn"> createPanel </em>的参数是<strong class="ke io">经典</strong>T58】左、<em class="mn">顶</em>、<em class="mn">宽</em>、<em class="mn">高</em>——和<em class="mn">背景颜色</em>。</p><p id="71f1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在创建过程中，面板会自动附加到其图层上。并且检查两次:</p><ol class=""><li id="46c6" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx nq mu mv mw bi translated">如果它完全适合放在盒子里</li><li id="2903" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx nq mu mv mw bi translated">为了与同一层中的其他面板碰撞</li></ol><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="efd4" class="lp lq in nd b gy nh ni l nj nk">const layer = box.getLayer("base")</span><span id="4c08" class="lp lq in nd b gy nl ni l nj nk">const panelA = layer.createPanel(0, 0, 100, 50, "black")</span><span id="1a12" class="lp lq in nd b gy nl ni l nj nk">const panelB = layer.createPanel(99, 0, 100, 50, "red") // error</span><span id="7f9e" class="lp lq in nd b gy nl ni l nj nk">// message in console:</span><span id="4356" class="lp lq in nd b gy nl ni l nj nk">Uncaught -- panel 2 clashes with panel 1 in layer base</span></pre><p id="af4e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">面板对象有一些方法(后面还会有更多):<em class="mn">隐藏</em>，<em class="mn">显示</em>，<em class="mn">设置字体</em>，<em class="mn">写入</em>，<em class="mn">清除</em>，<em class="mn">绘制</em>，<em class="mn">绘制图像</em>，<em class="mn">设置颜色</em>，<em class="mn">创建按钮</em>，<em class="mn">创建表面，</em>和<em class="mn">记录</em>。</p><p id="9e2e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:在面板上书写和绘画不会创建小部件；因此，没有关于装配和碰撞的检查。</p><h2 id="02e4" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">创建按钮</h2><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="c8cc" class="lp lq in nd b gy nh ni l nj nk">const buttonOk = panel.createButton(460, 350, 68, 50, "dimgrey")</span><span id="e33c" class="lp lq in nd b gy nl ni l nj nk">const img = goodbye.createLabel("white", "black", 20, 20, 10, 10, "OK")</span><span id="aa0c" class="lp lq in nd b gy nl ni l nj nk">buttonOk.setImageNormal(img)</span><span id="489a" class="lp lq in nd b gy nl ni l nj nk">buttonOk.setOnClick(function () { box.getLayer("alert").hide() })</span></pre><p id="7829" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建按钮几乎是创建面板的翻版。</p><p id="dacd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn"> createButotn </em>的参数为<strong class="ke io">经典</strong>T26】左、<em class="mn">顶</em>、<em class="mn">宽</em>、<em class="mn">高</em>—<em class="mn">bgColor</em>。按钮的位置相对于它的父节点:面板(而不是盒子)。</p><p id="0495" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在创建过程中，按钮会自动附加到其面板上。并且检查两次:</p><ol class=""><li id="f3eb" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx nq mu mv mw bi translated">如果它完全适合面板内部</li><li id="c9a5" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx nq mu mv mw bi translated">对于同一个面板中的其他部件的碰撞</li></ol><pre class="la lb lc ld gt nc nd ne nf aw ng bi"><span id="f7cc" class="lp lq in nd b gy nh ni l nj nk">const b = panel.createButton(460, "black", 68, 50, "grey") // error</span><span id="aaf2" class="lp lq in nd b gy nl ni l nj nk">// message in console:</span><span id="bb3c" class="lp lq in nd b gy nl ni l nj nk">-- wrong argument top for function panel.createButton: expecting integer &gt;= 0, got string: black</span></pre><p id="5eed" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在当前阶段，库不会自动在按钮中插入文本；我们必须手动进行。</p><p id="8d38" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按钮对象有这些方法:<em class="mn">隐藏</em>，<em class="mn">显示</em>，<em class="mn"> setImageNormal </em>，<em class="mn"> setImageActive </em>，<em class="mn"> setImagePressed </em>，<em class="mn"> setImageDisabled </em>，<em class="mn"> disable </em>，<em class="mn"> activate </em>，<em class="mn"> normalize </em>，<em class="mn"> setBgColor </em>，<em class="mn"> setOnClick 【T57</em></p><h2 id="2147" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">该按钮声明</h2><p id="a866" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">GoodbyeHtml按钮有4种状态，您可以为每种状态设置一个图像:</p><ul class=""><li id="29c6" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated">常态</li><li id="cc8e" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">禁用(不做任何事情)</li><li id="b3c0" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">active(必须调用button . activate)——表示已经被点击，某些状态已经改变；再次单击它会使按钮变为正常状态，并且状态会变为先前的值</li><li id="6797" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">按下—表示它收到了鼠标按下事件，并且正在等待鼠标抬起事件产生单击事件</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5f6ce643d2bc63d09dee1d0ae67ad37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*h5EmUCoZIsVk4OYfv9it3Q.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Normal, Active, Disabled, and Pressed</figcaption></figure><p id="2246" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果在按钮被按下时鼠标离开按钮，则按下状态被取消，并且未来的点击事件被中止，以避免接受伪点击。您应该在演示中尝试一下。</p><p id="eee8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于按钮，您只能侦听click事件。所有其他鼠标事件仅在内部处理。</p><h2 id="7ffe" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">创建表面小部件</h2><p id="a792" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">创建曲面就像创建按钮一样。表面是一个原始的小部件，非常可定制。它的目的是给你自由去做你通常不能做的事情，因为盒子的刚性/安全结构。</p><p id="eba4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在没有时间讨论表面。想象一下，一个特殊的层包含一个面板，透明的背景，覆盖整个盒子。这个面板只有一个小部件，一个透明的背景表面，也完全覆盖了盒子。在这种情况下，你可以在任何地方画任何东西…你可以有更多像那样的特殊图层。</p><p id="dcc0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于surface，您必须直接侦听所有鼠标事件，click事件除外，该事件不可用。您已经听到了鼠标按下和鼠标抬起事件。我们不要多此一举。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h2 id="2406" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">等级制度</h2><p id="b301" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">库&gt;框&gt;层&gt;面板&gt;小部件</p><p id="62a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就这么简单。</p><ol class=""><li id="b60a" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx nq mu mv mw bi translated">你创建了图书馆。</li><li id="8ec2" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx nq mu mv mw bi translated">您使用库实用程序，包括<em class="mn"> createBox </em>。</li><li id="e1b2" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx nq mu mv mw bi translated">从盒子中，你创建层。</li><li id="353d" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx nq mu mv mw bi translated">从每一层创建面板。</li><li id="a16f" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx nq mu mv mw bi translated">您可以在每个面板中创建小部件。</li></ol><p id="b65b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这不像在JavaScript中创建HTML对象，首先创建它，然后将它附加到某个容器中。或者忘了做。或者做两次(同一个容器与否)。</p><p id="c48e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GooodbyeHtml中没有丢失的小部件。</p><p id="91b9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不知道你是什么感受；但是，对我来说，没有比这更简单/健壮/容易/直观/快速/可读/可维护的了。</p><h2 id="38cd" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">接下来会发生什么</h2><p id="78f4" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我要在库中包含更多的特性(包括键盘处理)，发布到GitHub上，文档化，完成马赛克生成器。</p><p id="2256" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一个演示的应用程序代码将与库和嵌入式资源分开，适合学习体验。</p><p id="ccd4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是<a class="ae ky" href="https://joanaborgeslate.medium.com/goodbye-html-hello-canvas-bccba5601085" rel="noopener"> <strong class="ke io">系列</strong> </a>下一篇的链接。</p><p id="8245" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn">更多内容看</em> <a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mn">说白了就是io </em> </strong> </a> <em class="mn">。报名参加我们的</em> <a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mn">免费周报</em> </strong> </a> <em class="mn">。关注我们关于</em><a class="ae ky" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mn">Twitter</em></strong></a><em class="mn">和</em><strong class="ke io"><em class="mn"/></strong><a class="ae ky" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mn">LinkedIn</em></strong></a><em class="mn">。加入我们的</em> <a class="ae ky" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="mn">社区不和谐</em> </strong> </a> <em class="mn">。</em></p></div></div>    
</body>
</html>