<html>
<head>
<title>4 Micro-Frontend Anti-Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4个微前端反模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/four-micro-frontend-anti-patterns-58aaa9fe19d5?source=collection_archive---------1-----------------------#2022-07-29">https://javascript.plainenglish.io/four-micro-frontend-anti-patterns-58aaa9fe19d5?source=collection_archive---------1-----------------------#2022-07-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e2bc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在基于微前端的应用中造成混乱的4种常见方式。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b8f80fdee6127db394dce937d69a680b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*We0XSUB_KdrZdVaw"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@joshuaryanphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Reddekopp</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8657" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">介绍</h1><p id="8d79" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">众所周知，微前端并不是开发前端应用的新方案，它或直接或间接地来源于微服务架构。</p><p id="50a0" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们知道在JavaScript世界中有许多不同的工具、库和框架，但是也有很多困惑。</p><p id="0e3f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们主要考虑微前端架构来解决这个问题，因为我们知道它给了我们选择前端库和框架的自由。是的，这是真的，但它会给我们带来应用程序性能的问题，并带来许多其他困难。</p><p id="6d16" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">尼尔·福特在他的书《持续交付的工程实践》中写道。</p><h2 id="5510" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">"昨天的最佳实践是明天的反模式."</h2><h2 id="b45a" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">什么是反模式？</h2><p id="ee10" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="http://en.wikipedia.org/wiki/Anti-pattern" rel="noopener ugc nofollow" target="_blank">反模式</a>是软件开发中被认为是糟糕的编程实践的特定模式。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/8df7316b5d019558056f5599f33092ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bjp9RWp5V788CZadhrcGxQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Four Micro-frontend Anti-patterns</figcaption></figure><h2 id="1ac6" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated"><strong class="ak"> 1。微前端Vs组件</strong></h2><blockquote class="mz"><p id="cff3" class="na nb in bd nc nd ne nf ng nh ni mg dk translated"><em class="nj">定义来自本书</em> <a class="ae ks" href="https://www.buildingmicrofrontends.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nj">构建微前端</em> </a> <em class="nj">由</em> <a class="ae ks" href="https://medium.com/u/9119c54d607d?source=post_page-----43aefd0af062--------------------------------" rel="noopener"> <em class="nj">卢卡·梅扎拉</em> </a></p></blockquote><p id="39ae" class="pw-post-body-paragraph ll lm in ln b lo nk jo lq lr nl jr lt lu nm lw lx ly nn ma mb mc no me mf mg ig bi translated">微前端是业务子域的技术表示，它们允许使用相同和不同的技术独立实现。</p><p id="e46c" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">微前端背后的原则是:</p><ol class=""><li id="1db8" class="np nq in ln b lo mh lr mi lu nr ly ns mc nt mg nu nv nw nx bi translated">业务领域表示</li><li id="3362" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated">自主代码库</li><li id="fad3" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated">独立部署</li><li id="3043" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated">单一团队所有权</li></ol><p id="91f7" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">然而，我们经常混合组件和微前端，因为我们不确定它们的区别，这将是我们的第一个反模式。所以我们的第一个挑战是设置微前端边界和识别业务子域。</p><p id="79ce" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因此，根据业务子域设置微前端的边界，找出哪些子域在用户流中相互交互，并避免使用组件作为微前端，因为根据定义，微前端代表业务域。</p><p id="acb1" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">更多信息请参考我之前的帖子，<a class="ae ks" href="https://blog.santoshshinde.com/whats-the-difference-between-a-component-and-a-micro-frontend-43aefd0af062" rel="noopener ugc nofollow" target="_blank">组件和微前端有什么区别？</a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi od"><img src="../Images/c55315ef938888aad681831689cf634b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-08wik9nIrVLfzgBHYP9w.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Micro-Frontend Vs Component</figcaption></figure><h2 id="49f4" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">2.多框架方法</h2><p id="3ce3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">一旦确定了域，下一步就是建立微前端和应用程序外壳。</p><p id="df21" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">有了从多个微前端web应用程序创建统一UI的能力，我们可以进一步改善客户的价值流以及业务变化压力流。</p><p id="0326" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">由于微前端给了我们选择任何开发框架的自由，我们必须首先确定它是否是真正需要的。如果你正在开发一个新的应用程序，并且你可以为所有的微前端选择一个框架，那么最好的选择就是使用一个框架。</p><p id="2018" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">当您组织中的不同团队使用多种技术时，一个领域的不一致可能会导致其他团队陷入类似的困境，从而导致总体的负面用户体验。</p><p id="295e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在一些用例中，微前端具有多框架方法的好处，一个例子是当我们可以为开发人员创建一个健康的飞轮时，这加快了他们的业务逻辑的上市时间，而不影响生产流量。</p><p id="6a90" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">以下是由此可能导致的一些潜在问题:</p><ol class=""><li id="2909" class="np nq in ln b lo mh lr mi lu nr ly ns mc nt mg nu nv nw nx bi translated">表演</li><li id="56ee" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated">依赖性冲突</li><li id="cc7c" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated">捆绑包的大小将得到提升。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/1dd7c44e8ea132fac47532e5bfbadcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgDBe3ZvC7qdHRnp9fCfAg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Multi-Framework Approach</figcaption></figure><h2 id="bcf9" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">3.依赖地狱</h2><p id="396e" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">根据维基百科的说法，<a class="ae ks" href="https://en.wikipedia.org/wiki/Dependency_hell" rel="noopener ugc nofollow" target="_blank">依赖地狱</a>是，</p><blockquote class="mz"><p id="cce6" class="na nb in bd nc nd ne nf ng nh ni mg dk translated">依赖地狱是一个通俗的术语，指的是一些软件用户的挫折感，他们安装的软件包依赖于其他软件包的特定版本</p></blockquote><p id="a289" class="pw-post-body-paragraph ll lm in ln b lo nk jo lq lr nl jr lt lu nm lw lx ly nn ma mb mc no me mf mg ig bi translated">众所周知，独立性是微服务的特性，微前端也是如此。因此，为了实现这一点，我们需要额外的应用程序开发依赖项(实用程序和模块)，这将使我们能够加速和利用现有的功能。然而，问题是一个依赖项也依赖于另一个依赖项，这导致我们在向后和向前兼容性方面存在问题。</p><p id="3698" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">让我们通过一个例子来理解这一点，</p><p id="6047" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们用的是核心库，每个微前端用的都是1.1.0版本。一段时间后，该库发布了版本1.2.0的新特性。幸运的是，我们的一个微前端(mfa-c)对实现新特性感兴趣，并且想要那个功能。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/3736f26dd1d1099e77776b6679fa5912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okF0Rr1bmV03BuwVHHlKwg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Core Library conflicts</figcaption></figure><p id="cec9" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">同时，另一个微前端(mfa-b)想要扩展其中的一些功能，所以它通过在其上编写代码来扩展。然而，核心库在主要版本2.1.0中发布了一个新特性，这导致了扩展特性中的冲突，需要为它创建一个新的扩展版本。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/f9baf2ea629f58f021ea5fe05f9b2246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k68lOI56IyqkbR_EEWLURw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Core Library Extended</figcaption></figure><p id="08a7" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">为了避免这个问题，通过使用与核心库的功能不冲突的包装器，将库从它们支持的任何特性扩展中分离出来。此外，确保所有微前端都使用相同版本的库。</p><ol class=""><li id="7f3d" class="np nq in ln b lo mh lr mi lu nr ly ns mc nt mg nu nv nw nx bi translated">这种外部依赖真的有必要吗？如果没有，就避开。</li><li id="0025" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated">解耦您的库</li><li id="abc0" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated">准确的文档</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/c7080a78c124ab80742384ab566f9a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_w6nxBTcs84JBiIY4IIqg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Decouple your libraries</figcaption></figure><h2 id="36f0" class="mm ku in bd kv mn mo dn kz mp mq dp ld lu mr ms lf ly mt mu lh mc mv mw lj mx bi translated">4.全局状态通信</h2><p id="9d43" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">有时候会有属于不同团队的UI片段需要交互或者交流。当用户通过点击购买按钮将商品添加到购物篮时，其他微前端(如迷你购物篮)希望得到通知以相应地更新它们的内容，并且有各种方法来这样做。</p><ol class=""><li id="bfed" class="np nq in ln b lo mh lr mi lu nr ly ns mc nt mg nu nv nw nx bi translated">用户界面通信</li><li id="dc41" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated">共享状态</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/6fe0b752750074fae54c5d252c182aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_Yguffgj2OZsTHsTCi4Jg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Micro-Frontends Communication</figcaption></figure><p id="6449" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">大多数时候，我们认为全局状态是在所有应用程序之间建立通信的最佳选择。作为微前端的一个基本原则，应该是独立的，就像微服务一样，但上面的例子违背了这个原则。因此，不要使用共享状态，因为这会违反隔离的概念。</p><p id="bcf5" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">很多时候我们并不需要它，例如，来自服务器的每一个信息/状态(例如:“用户”信息)都可以在每个MFE需要时被单独请求。</p><p id="a816" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">这种模式存在于所有微服务架构中，因为它应该消除单点故障和维护大型商店的其他复杂性。常见的方法是让每个“微前端”拥有自己的存储(即Redux)。</p><p id="daba" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">为了解决这个问题，您可以使用基于事件发射器的通信方法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/912ce1a7320f80137784d4094c4df041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmgvZ_BhHVEy7CnbSrXCGw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Global State VS Event Emitter</figcaption></figure><p id="a09b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我知道还有其他的反模式，但是本文主要关注四种主要的反模式。请分享您的想法，我们应该关注哪些其他反模式来减少微前端架构中的挑战。</p><p id="eaf7" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">感谢阅读，请分享你的评论，如果这个博客增加了你的学习价值，请鼓掌。</p><h1 id="e78a" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">参考</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Micro frontends anti-patterns — Luca Mezzalira</figcaption></figure><div class="om on gp gr oo op"><a href="https://github.com/santoshshinde2012/micro-frontends-mindmaps" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd io gy z fp ou fr fs ov fu fw im bi translated">GitHub-Santosh shinde 2012/微前端-思维导图:总结微前端概念的思维导图</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">总结微前端概念的思维导图。为Santosh shinde 2012/微前端-思维导图开发做出贡献…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd km op"/></div></div></a></div><p id="021d" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="pe">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="pe">plain English . io</em></strong></a><em class="pe">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="pe">免费周报</em> </strong> </a> <em class="pe">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="pe">Twitter</em></strong></a><em class="pe">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="pe">LinkedIn</em></strong></a><em class="pe">。查看我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="pe">社区不和谐</em> </strong> </a> <em class="pe">加入我们的</em> <a class="ae ks" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="pe">人才集体</em> </strong> </a> <em class="pe">。</em></p></div></div>    
</body>
</html>