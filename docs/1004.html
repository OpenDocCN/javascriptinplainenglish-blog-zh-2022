<html>
<head>
<title>A Deep Introduction to Method Decorators in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对TypeScript中的方法修饰符的深入介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6?source=collection_archive---------12-----------------------#2022-02-25">https://javascript.plainenglish.io/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6?source=collection_archive---------12-----------------------#2022-02-25</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/1991042877946ae1f47aa5aaeb3fdcf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wu5nulCh6UgAvhph.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Image by Author using corresponding project logos</figcaption></figure><p id="74df" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">Decorators允许我们在TypeScript中向类或方法添加额外的信息，类似于Java中的注释。方法修饰符应用于TypeScript中的类中定义的方法。有了它们，我们可以记录关于方法的信息，或者修改方法的执行。</p><p id="b039" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">在本文中，我们将探索如何使用和创建方法装饰器。方法当然是我们附加在类上的函数，或者是从超类继承来的。</p><p id="992d" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">要使用decorator，必须在TypeScript中启用它们，所以请务必<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">阅读本系列的decorator介绍文章</a>。</p><p id="0e09" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">在实践中，方法装饰者看起来像这样:</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="43ee" class="ll lm ir lh b gz ln lo l lp lq">class A {<br/>     @MethodDecorator()<br/>     fly(meters: number) {<br/>         // code<br/>     }<br/>}</span></pre><p id="cb34" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">方法修饰符应用于方法，而不是函数的参数。<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-parameter-decorators-in-typescript-b0042b5474ed">参数装饰器是一个不同的东西</a>，我们在别处讨论过。</p><p id="31af" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">本文是系列文章的一部分:</p><ul class=""><li id="3429" class="lr ls ir kf b kg kh kk kl ko lt ks lu kw lv la lw lx ly lz bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43">装修工简介</a></li><li id="888a" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><a class="ae lb" href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035" rel="noopener ugc nofollow" target="_blank">类装修工</a></li><li id="08a5" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec">物业装修工</a></li><li id="9657" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9">访问器装饰器</a></li><li id="ca74" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-parameter-decorators-in-typescript-b0042b5474ed">参数装饰器</a></li><li id="4262" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><strong class="kf is">法条装饰者</strong> <em class="mf">法条装饰者</em></li><li id="2ad5" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0">混合装修工</a></li><li id="78f9" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7">用装饰器使用反射和反射API</a></li><li id="40cf" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5">运行时使用装饰器进行数据验证</a></li></ul><p id="df92" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">要使用decorator，必须在TypeScript中启用两个特性，所以请务必阅读本系列的decorator介绍文章。</p><h1 id="3212" class="mg lm ir bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">TypeScript中的方法装饰函数</h1><p id="5afa" class="pw-post-body-paragraph kd ke ir kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ik bi translated">方法装饰器就在方法实例化之前被调用。传递给这些函数的参数是:</p><ol class=""><li id="2e51" class="lr ls ir kf b kg kh kk kl ko lt ks lu kw lv la ni lx ly lz bi translated">静态成员的类的构造函数，或者实例成员的类的原型。</li><li id="7b37" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la ni lx ly lz bi translated">给出属性名称的字符串</li><li id="bd4b" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la ni lx ly lz bi translated">成员的<em class="mf"> PropertyDescriptor </em>函数</li></ol><p id="92df" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">前两个decorator函数参数与其他几种decorator类型的参数相同。PropertyDescriptor是一些其他装饰器类型中使用的相同对象，但用法略有不同。JavaScript填充该对象的方式与填充访问器的方式不同。</p><h1 id="f8d9" class="mg lm ir bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">探索TypeScript中的方法修饰符</h1><p id="6f89" class="pw-post-body-paragraph kd ke ir kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ik bi translated">第一步，让我们创建一个装饰器来打印参数值。</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="beaa" class="ll lm ir lh b gz ln lo l lp lq">import * as util from 'util';  </span><span id="8704" class="ll lm ir lh b gz nj lo l lp lq">function logMethod(target: Object, propertyKey: string,<br/>                    descriptor: PropertyDescriptor) {<br/>     console.log(`logMethod`, {<br/>         target, propertyKey, descriptor,<br/>          targetKeys: Object.getOwnPropertyNames(target),<br/>         function: descriptor.value,<br/>         funcText: descriptor.value.toString()<br/>     });<br/>}</span><span id="2dd4" class="ll lm ir lh b gz nj lo l lp lq">class MethodExample {<br/>     @logMethod<br/>     method(x: number) {<br/>         return x * 2;<br/>     } <br/>}</span></pre><p id="ed50" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">这将打印出关于目标、描述符和描述符中的<code class="fe nk nl nm lh b">value</code>字段的可用数据。对于<code class="fe nk nl nm lh b">targetKeys</code>,我们感兴趣的是验证<code class="fe nk nl nm lh b">target</code>是包含该方法的类。对于<code class="fe nk nl nm lh b">function</code>，我们了解到<code class="fe nk nl nm lh b">value</code>字段包含函数，使用<code class="fe nk nl nm lh b">toString</code>可以让我们看到函数的文本。</p><p id="74f3" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">要查看输出:</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="56f3" class="ll lm ir lh b gz ln lo l lp lq">$ npx ts-node lib/methods/methods.ts<br/>logMethod {<br/>   target: {},<br/>   propertyKey: 'method',<br/>   descriptor: {<br/>     value: [Function: method],<br/>     writable: true,<br/>     enumerable: false,<br/>     configurable: true<br/>   },<br/>   targetKeys: [ 'constructor', 'method' ],<br/>   function: [Function: method],<br/>   funcText: 'method(x) {\n        return x * 2;\n    }' <br/>}</span></pre><p id="0ca4" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">是的，<code class="fe nk nl nm lh b">target</code>显然是包含这个方法的类，<code class="fe nk nl nm lh b">value</code>字段是实际的函数。</p><h1 id="ab71" class="mg lm ir bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">窥探方法调用</h1><p id="b655" class="pw-post-body-paragraph kd ke ir kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ik bi translated">因为该方法有一个PropertyDescriptor，所以我们可以尝试重写该函数。就像我们对<a class="ae lb" href="https://techsparx.com/nodejs/typescript/decorators/accessors.html" rel="noopener ugc nofollow" target="_blank">访问器</a>所做的一样，让我们尝试一个新的装饰器，它可以让我们窥探函数的输入和输出值。</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="c837" class="ll lm ir lh b gz ln lo l lp lq">function MethodSpy(target: Object,<br/>          propertyKey: string, descriptor: PropertyDescriptor) {<br/>     const originalMethod = descriptor.value;<br/>     descriptor.value = function (...args: any[]) {<br/>         console.log(`MethodSpy before ${propertyKey}`, args);<br/>         const result = originalMethod.apply(this, args);<br/>         console.log(`MethodSpy after ${propertyKey}`, result);<br/>         return result;<br/>     } <br/>}  </span><span id="948c" class="ll lm ir lh b gz nj lo l lp lq">class SpiedOn {<br/>     @MethodSpy<br/>     area(width: number, height: number) {<br/>         return width * height;<br/>     }</span><span id="cab5" class="ll lm ir lh b gz nj lo l lp lq">     @MethodSpy<br/>     areaCircle(diameter: number) {<br/>         return Math.PI * ((diameter / 2) ** 2);<br/>     } <br/>}  </span><span id="3776" class="ll lm ir lh b gz nj lo l lp lq">const spyon = new SpiedOn();  </span><span id="ecf5" class="ll lm ir lh b gz nj lo l lp lq">console.log(spyon.area(6, 10)); <br/>console.log(spyon.area(16, 20));  </span><span id="cf46" class="ll lm ir lh b gz nj lo l lp lq">console.log(spyon.areaCircle(10)); console.log(spyon.areaCircle(20));</span></pre><p id="ea52" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">在函数内部，我们保存了<code class="fe nk nl nm lh b">descriptor.value</code>的初始值，因为那是实际的成员函数。我们用另一个接受任意数量参数的函数来代替它。记住<code class="fe nk nl nm lh b">...args</code>成为一个数组，包含传递给函数的参数。我们首先打印函数名和提供的参数。然后，我们调用原始方法，提供参数，并捕获结果。然后我们打印函数名和结果，最后返回结果。</p><p id="b8a0" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">然后运行脚本:</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="03df" class="ll lm ir lh b gz ln lo l lp lq">$ npx ts-node lib/methods/spy.ts  <br/>MethodSpy before area [ 6, 10 ] <br/>MethodSpy after area 60 60 <br/>MethodSpy before area [ 16, 20 ] <br/>MethodSpy after area 320 320 <br/>MethodSpy before areaCircle [ 10 ] <br/>MethodSpy after areaCircle 78.53981633974483 <br/>78.53981633974483 <br/>MethodSpy before areaCircle [ 20 ] <br/>MethodSpy after areaCircle 314.1592653589793 <br/>314.1592653589793</span></pre><p id="bd70" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">在每种情况下，在阶段之前的<em class="mf">中打印的值是一个数组，在</em>阶段之后的<em class="mf">中打印的值是每种方法的预期结果。</em></p><p id="5f1e" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">由于它是如何编写的，我们可以很容易地将它应用于任何方法的任何装饰器。它甚至会自动选择方法名。</p><h1 id="8923" class="mg lm ir bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">方法和参数装饰器一起工作</h1><p id="b9eb" class="pw-post-body-paragraph kd ke ir kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ik bi translated">我们已经建议这两种类型的装饰器可以一起工作来产生一个有用的结果。我们想要尝试的概念是一个参数装饰器，如果没有提供可选参数，它可以提供一个默认值。</p><p id="22de" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">这就是它的含义:</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="c323" class="ll lm ir lh b gz ln lo l lp lq">class DefaultExample {<br/>     @SetDefaults     volume(<br/>         z: number,<br/>         @ParamDefault&lt;number&gt;(10) x?: number,<br/>         @ParamDefault&lt;number&gt;(15) y?: number,<br/>         title?: string<br/>     ) {<br/>         const ret = {<br/>             x, y, z, volume: x * y * z, title<br/>         };<br/>         console.log(`volume `, ret);<br/>         return ret;<br/>     } <br/>}</span></pre><p id="7e76" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">一个类，它有一个基于<code class="fe nk nl nm lh b">x</code>、<code class="fe nk nl nm lh b">y</code>和<code class="fe nk nl nm lh b">z</code>值计算<em class="mf">音量</em>的方法。<code class="fe nk nl nm lh b">@ParamDefault</code>装饰器将让我们指定一个默认值。注意，参数有一个<code class="fe nk nl nm lh b">?</code>,表示它是可选的。因此，我们需要一些代码来检测何时没有提供参数，并进行替换。</p><p id="dbca" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">由于<code class="fe nk nl nm lh b">@ParamDefault</code>是一个参数装饰器，它除了将它的存在记录到一个数组中之外不能做任何事情，正如我们在研究参数装饰器时所讨论的。为了替换默认值，我们需要一些代码来执行这个类的实例。我们刚刚展示了方法装饰者可以覆盖方法的函数，以便针对类实例执行。计划是在实际函数之前注入一个要调用的函数，并使用注入的函数来设置任何默认值。</p><p id="e861" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">让我们看看如何实现这一切，从<code class="fe nk nl nm lh b">ParamDefault</code>开始:</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="5472" class="ll lm ir lh b gz ln lo l lp lq">const paramDefaults = []; <br/>... <br/>function ParamDefault&lt;T&gt;(value: T) {<br/>    return (target: Object, propertyKey: string | symbol,<br/>                    parameterIndex: number ) =&gt; {<br/>           paramDefaults.push({<br/>                  target, propertyKey, parameterIndex, value <br/>           }); <br/>    } <br/>}</span></pre><p id="3b00" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">这存储了关于decorator参数的数据，以及要使用的默认值。<code class="fe nk nl nm lh b">paramDefaults</code>数组存储这些数据。</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="3c93" class="ll lm ir lh b gz ln lo l lp lq">function findDefaults(target: Object, propertyKey: string) {<br/>     const ret = [];<br/>     for (const def of paramDefaults) {<br/>         if (target === def.target<br/>          &amp;&amp; propertyKey === def.propertyKey) {<br/>             ret.push(def);<br/>         }<br/>     }<br/>     return ret; <br/>}  </span><span id="16c0" class="ll lm ir lh b gz nj lo l lp lq">function SetDefaults(target: Object, propertyKey: string,<br/>                          descriptor: PropertyDescriptor) {<br/>     const originalMethod = descriptor.value;<br/>     descriptor.value = function (...args: any[]) {<br/>         console.log(`SetDefaults before ${propertyKey}`, args);<br/>         for (const def of findDefaults(target, propertyKey)) {<br/>             if (typeof args[def.parameterIndex] === 'undefined'<br/>              || args[def.parameterIndex] === null) {<br/>                 args[def.parameterIndex] = def.value;<br/>             }<br/>         }<br/>         console.log(`SetDefaults after substitution ${propertyKey}`, args);<br/>         const result = originalMethod.apply(this, args);<br/>         console.log(`SetDefaults after ${propertyKey}`, result);<br/>         return result;<br/>     } <br/>}</span></pre><p id="a81b" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated"><code class="fe nk nl nm lh b">SetDefaults</code> decorator函数安装了一个函数，它将根据所声明的默认值来处理替换值。<code class="fe nk nl nm lh b">findDefaults</code>功能在<code class="fe nk nl nm lh b">paramDefaults</code>中搜索与<code class="fe nk nl nm lh b">target</code>和<code class="fe nk nl nm lh b">propertyKey</code>匹配的所有项目。选择了缺省值后，我们可以查看实际的参数，看看是否有任何参数没有提供——我们将其定义为<code class="fe nk nl nm lh b">undefined</code>或<code class="fe nk nl nm lh b">null</code>。如果参数没有给出，那么进行替换，然后调用原始函数，并返回结果。</p><p id="d70e" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">回到我们的例子，有四种组合可以尝试:</p><ol class=""><li id="eb09" class="lr ls ir kf b kg kh kk kl ko lt ks lu kw lv la ni lx ly lz bi translated">未提供<code class="fe nk nl nm lh b">x</code>和<code class="fe nk nl nm lh b">y</code>值。</li><li id="daea" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la ni lx ly lz bi translated">仅<code class="fe nk nl nm lh b">x</code>未提供。</li><li id="e45b" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la ni lx ly lz bi translated">仅<code class="fe nk nl nm lh b">y</code>未提供。</li><li id="a6d9" class="lr ls ir kf b kg ma kk mb ko mc ks md kw me la ni lx ly lz bi translated"><code class="fe nk nl nm lh b">x</code>和<code class="fe nk nl nm lh b">y</code>均已供应。</li></ol><p id="fa44" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">这处理了替换缺失参数值的所有四种可能性。此外，我们添加了另一个参数title，在这里我们不提供缺省值，以验证缺少替换。最后，参数<code class="fe nk nl nm lh b">z</code>是一个非可选参数，用于确保这些值得到正确处理。</p><p id="860e" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">这构成了我们的测试代码:</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="4fc1" class="ll lm ir lh b gz ln lo l lp lq">const de = new DefaultExample();<br/>// both x and y missing <br/>console.log(de.volume(10)); <br/>console.log('----------------------'); <br/>// only x missing <br/>console.log(de.volume(20, null, 20, "Second")); <br/>console.log('----------------------'); <br/>// only y missing <br/>console.log(de.volume(30, 30, null)); <br/>console.log('----------------------'); <br/>// both x and y supplied <br/>console.log(de.volume(40, 40, 50, "Fourth"));</span></pre><p id="a5cd" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">它处理刚才提到的四种情况，并确保为每个参数传递不同的值，以确保调用之间没有值的流失。</p><p id="9ece" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">结果看起来像这样:</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="63a4" class="ll lm ir lh b gz ln lo l lp lq">$ npx ts-node lib/methods/defaults.ts  <br/>SetDefaults before volume [ 10 ] <br/>SetDefaults after substitution volume [ 10, 10, 15 ] <br/>volume  { x: 10, y: 15, z: 10, volume: 1500, title: undefined } <br/>SetDefaults after volume { x: 10, y: 15, z: 10, volume: 1500, title: undefined } <br/>{ x: 10, y: 15, z: 10, volume: 1500, title: undefined } <br/>---------------------- <br/>SetDefaults before volume [ 20, null, 20, 'Second' ] <br/>SetDefaults after substitution volume [ 20, 10, 20, 'Second' ] <br/>volume  { x: 10, y: 20, z: 20, volume: 4000, title: 'Second' } <br/>SetDefaults after volume { x: 10, y: 20, z: 20, volume: 4000, title: 'Second' } <br/>{ x: 10, y: 20, z: 20, volume: 4000, title: 'Second' } <br/>---------------------- <br/>SetDefaults before volume [ 30, 30, null ] <br/>SetDefaults after substitution volume [ 30, 30, 15 ] <br/>volume  { x: 30, y: 15, z: 30, volume: 13500, title: undefined } <br/>SetDefaults after volume { x: 30, y: 15, z: 30, volume: 13500, title: undefined } <br/>{ x: 30, y: 15, z: 30, volume: 13500, title: undefined } <br/>---------------------- <br/>SetDefaults before volume [ 40, 40, 50, 'Fourth' ] <br/>SetDefaults after substitution volume [ 40, 40, 50, 'Fourth' ] <br/>volume  { x: 40, y: 50, z: 40, volume: 80000, title: 'Fourth' } <br/>SetDefaults after volume { x: 40, y: 50, z: 40, volume: 80000, title: 'Fourth' } <br/>{ x: 40, y: 50, z: 40, volume: 80000, title: 'Fourth' }</span></pre><p id="0b94" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">虚线是为了清楚地阅读结果。</p><p id="cd41" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">仔细查看这些结果，您会发现所有的替换都如预期的那样发生了。</p><h1 id="0049" class="mg lm ir bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">摘要</h1><p id="f4a0" class="pw-post-body-paragraph kd ke ir kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ik bi translated">我们已经实现了一个非常有趣的特性，用方法和参数装饰器的组合来替换缺省方法参数的能力。参数装饰器函数保存了关于默认值的数据，方法装饰器函数检测到缺少有默认值可用的参数。</p><h1 id="2043" class="mg lm ir bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">关于作者</h1><p id="a473" class="pw-post-body-paragraph kd ke ir kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ik bi translated"><a class="ae lb" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="kf is"> <em class="mf">大卫·赫伦</em> </strong> </a> <em class="mf">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><p id="dd31" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated"><em class="mf">最初发表于</em><a class="ae lb" href="https://techsparx.com/nodejs/typescript/decorators/methods.html" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://techsparx.com</em></a><em class="mf">。</em></p><p id="2e52" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated"><em class="mf">更多内容看</em> <a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf is"> <em class="mf">说白了就是</em> </strong> </a> <em class="mf">。报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf is"> <em class="mf">免费每周简讯</em> </strong> </a> <em class="mf">。关注我们</em> <a class="ae lb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kf is"> <em class="mf">推特</em> </strong> </a> <em class="mf">和</em><a class="ae lb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf is"><em class="mf">LinkedIn</em></strong></a><em class="mf">。加入我们的</em> <a class="ae lb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf is"> <em class="mf">社区不和谐</em> </strong> </a> <em class="mf">。</em></p></div></div>    
</body>
</html>