<html>
<head>
<title>How to Maximally Reduce Loading Times with useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用useEffect最大限度地减少加载次数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-maximally-reduce-loading-times-with-useeffect-89f0f150bdba?source=collection_archive---------2-----------------------#2022-10-19">https://javascript.plainenglish.io/how-to-maximally-reduce-loading-times-with-useeffect-89f0f150bdba?source=collection_archive---------2-----------------------#2022-10-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="74e8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用简单的设计模式重构React代码</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6b4a8c6e7bdfb1130ea80eceb60c38e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hq7DdYfrv4PCZWS8XBC79w.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@hautier?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Christophe Hautier</a> on <a class="ae ks" href="https://unsplash.com/s/photos/spinner?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6eb8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最近我一直在做两件事——重构大量的React代码和阅读软件设计模式。</p><p id="f2b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在重构一些旧代码时，我一直在尝试让一些页面加载得更快。这就是问题所在——为了加载一个页面，我必须对不同的后端服务进行五六次网络调用。这实际上比旧代码要做的要多得多，因为后端已经被重新设计为使用微服务模式。</p><p id="ba79" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我没有读过太多这方面的内容，但我突然想到，或许切换到微服务驱动架构的一个代价就是这个！您的前端必须调用更多的服务来获得它需要的数据。</p><p id="aa23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，如果你正在做前端的工作，你如何以一种简单且可重复的方式解决这个问题呢？</p><p id="bf03" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">提示一个设计模式…看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="0824" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里的关键是第16行，它利用<code class="fe lr ls lt lu b">Promise.all</code>异步运行所有不同的数据查询。然后，如果您只是在等待之后将您的<code class="fe lr ls lt lu b">loading</code>状态设置为false，那么您可以确保在所有不同的数据查询运行之后，您只将页面显示为已加载。</p><p id="f175" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我还认为这是一种可读性很强的方法，因为你只需要在第19行的<code class="fe lr ls lt lu b">useEffect</code>钩子中调用一个函数。我个人已经用这种模式重构了很多代码，并发现它确实有助于缩短加载时间，并使在单个React组件中进行多个后端调用变得非常容易，而事情不会变得复杂。</p><p id="4e34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里需要注意的一点是，我没有处理钩子的依赖关系。有很多不同的方法可以做到这一点，所以这超出了本文的范围——例如，您可以将函数包装在useCallback钩子中，或者将所有内容都放在useEffect钩子中。</p><p id="480a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我希望这是有用的🙂</p></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><p id="2ec9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mc">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mc">plain English . io</em></strong></a><em class="mc">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mc">免费周报</em> </strong> </a> <em class="mc">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mc">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mc">LinkedIn</em></strong></a><em class="mc"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mc">YouTube</em></strong></a><em class="mc"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mc">不和</em> </strong> </a> <em class="mc">。对增长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mc">电路</em> </strong> </a> <em class="mc">。</em></p></div></div>    
</body>
</html>