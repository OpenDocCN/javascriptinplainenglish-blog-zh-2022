<html>
<head>
<title>How Redis Can Make Authentication 10x Easier For Your Users</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis如何让用户的身份验证变得简单10倍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-redis-can-make-authentication-10x-easoer-for-your-users-cd8c0601d38?source=collection_archive---------1-----------------------#2022-08-15">https://javascript.plainenglish.io/how-redis-can-make-authentication-10x-easoer-for-your-users-cd8c0601d38?source=collection_archive---------1-----------------------#2022-08-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7f64c1651cf0fad0be1c6f3b684e6f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFfYvLcvoft-HNdQYXliBg.jpeg"/></div></div></figure><p id="170f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您是一名开发人员，可能已经为一些用户构建了一些应用程序。您的用户需要注册才能访问您的应用程序上的一些资源。要完成注册，他们还必须验证他们的电子邮件。虽然有些用户完全可以接受这一额外的步骤，但大多数人并不觉得愉快，即使他们知道他们不得不这样做。为什么？太手动了。</p><p id="bc10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果有一种更好的方法来验证用户的电子邮件，而不使其过于露骨，会怎么样？那么，让我向您介绍一下Magic Link认证模型。你可能已经听说过它，甚至以前在什么地方用过它。注册时，从用户的角度来看是这样的:</p><ul class=""><li id="41d9" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">他们输入自己的电子邮件地址</li><li id="ee63" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">一个链接被发送到该电子邮件地址</li><li id="c7a5" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">他们进入收件箱并打开链接(这是验证被巧妙应用的地方)</li><li id="2327" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">他们将被重定向到一个注册页面，在这里他们将输入自己的其他详细信息，如姓名、密码、电话等。</li><li id="5398" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">他们注册并立即被登录</li></ul><p id="816e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很简单！没有人需要知道他们必须验证他们的电子邮件——他们只是在没有注意到的情况下这么做了。这就是为什么魔链模型在现代认证系统中被直观地接受的原因。但是在这个过程中，幕后发生了很多事情。这就是本教程的重点。</p><p id="9dfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一些方法可以在后端实现这个概念，选择权在你。但是不一定要选择效率较低的。想想吧。如果你想用Express实现这个，你会怎么做？也许您会创建一个端点(端点1 ),实现以下算法:</p><ol class=""><li id="7c71" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lh kz la lb bi translated">从请求主体收集电子邮件</li><li id="3a1e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">使用Node.js内置加密包生成令牌</li><li id="dfc4" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">将电子邮件和令牌以及过期时间存储在数据库中的一个单独的(来自您的用户)表中</li><li id="c182" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">将令牌注入一个URL(匹配前端的一个页面),并将其发送到给定的电子邮件地址</li></ol><p id="9c48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，另一个端点(端点2，通常是注册路由)执行以下操作:</p><ol class=""><li id="5614" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lh kz la lb bi translated">检查请求对象中是否提供了令牌</li><li id="4ad1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">收集用户的详细信息，尤其是电子邮件地址</li><li id="f3a8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">尝试从数据库的“特殊”表中提取带有给定标记的记录</li><li id="9228" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">如果记录不存在，返回一个禁止的错误</li><li id="ec61" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">如果记录存在，但过期时间已到，则返回一个错误请求错误</li><li id="2a15" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lh kz la lb bi translated">如果记录存在并且到期时间仍然有效，则使用给定的详细信息创建一个新用户</li></ol><p id="00ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们考虑一下这种方法。你觉得有效吗？嗯，除了端点1的第3步，一切看起来都很理想。我这么想的原因如下:</p><ul class=""><li id="0bce" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">将令牌存储在数据库中是没有意义的，因为它只是初步数据，以后将变得无用。</li><li id="e07f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">你的数据库会被瘾君子的数据塞满。您可能会争辩说，您可以应用endpoint 2中的第7步来删除记录，但在我看来，使用数据库来删除记录效率较低，而且对生产来说也不理想。我相信你能想到这种方法的其他缺点。</li></ul><p id="d31e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更好的方法是使用JWT。使用JWT将处理端点1的步骤2和3。然后，端点2的步骤3将适合于用JWT而不是数据库来验证令牌。尽管如此，这并不是最好的解决方案。原因是，对于这个简单的问题，使用JWT是多余的。</p><p id="f377" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更好的解决方案是使用RedisJSON。</p><p id="a12a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">RedisJSON是一个高性能的NoSQL文档存储库，它提供本机API来接收、索引、查询和运行JSON文档的全文搜索，既可以在本地进行，也可以作为云中的托管服务。这意味着您可以使用RedisJSON内存[键-值]数据结构存储作为数据库和缓存。你可以在这里了解更多信息。让我向您展示<a class="ae li" href="https://www.linkedin.com/company/redisinc/" rel="noopener ugc nofollow" target="_blank"> Redis </a>如何根除端点1的步骤3的低效。</p><h1 id="c1e7" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">该项目</h1><p id="8efa" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">对于本教程，我创建了一个项目，我们将使用整个。这是一个非常简单的Express应用程序，它公开了三个RESTful API端点— /users、/users/magic_link和/users/signup。你可以在这里克隆或下载源代码<a class="ae li" href="https://github.com/Glitzyken/magic-link-redis" rel="noopener ugc nofollow" target="_blank"/>。这是一个文档化的应用程序。</p><h1 id="2994" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">先决条件</h1><ul class=""><li id="0fce" class="kt ku in jx b jy mh kc mi kg mm kk mn ko mo ks ky kz la lb bi translated">我假设您已经了解了容器的基本知识，并且在您的机器上安装了docker。如果您没有安装它，请遵循本指南并从支持的平台中选择一个。你根本不知道容器的概念？没问题。只要按照教程一步一步来，并确保安装所有必要的依赖关系。</li><li id="92b1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在这里安装docker-compose<a class="ae li" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"/>。使用这两个命令在Linux上安装要容易得多:</li></ul><p id="f943" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">1.</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="98ca" class="my lk in mu b gy mz na l nb nc">sudo curl -L “https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)” -o /usr/local/bin/docker-compose</span></pre><p id="ecbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">2.</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="97c4" class="my lk in mu b gy mz na l nb nc">sudo chmod +x /usr/local/bin/docker-compose</span></pre><ul class=""><li id="e904" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">当然，还要确保安装了Node.js和NPM。</li></ul><h1 id="0734" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">项目之旅</h1><p id="0ba5" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">让我给你介绍一下这个项目。在您喜欢的代码编辑器中打开项目文件夹。请注意，项目文件夹包含两个文件夹— starter和final。starter文件夹包含我们需要开始的不完整的代码和文件。最后一个文件夹包含完整的源代码。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/975aaacc47c79fe90b9ae53127aec58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*FDsHNI_WnMrDwz2y5fYcJw.jpeg"/></div></figure><p id="81be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您希望快速浏览一下我们将要构建的内容，首先确保docker已经启动并正在运行，然后打开您的终端并运行以下命令:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9dca" class="my lk in mu b gy mz na l nb nc">❯ cd final</span><span id="d951" class="my lk in mu b gy ne na l nb nc">final ❯ docker-compose up -d --build</span></pre><p id="7f73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Docker-compose将执行docker-compose.yml文件中的所有指令。如果你对docker-compose一无所知，也不用担心。毕竟这不是docker教程😊。</p><p id="fe0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，你应该访问<a class="ae li" href="http://localhost:4000/users" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/users</a>。如果一切正常运行，您应该会看到如下成功响应:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/edaeea31efae9357be507baa174516fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*EpCHlmOC-IM-JDLdh9GnBA.jpeg"/></div></figure><p id="5e87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要停止所有正在运行的容器，请执行:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="486e" class="my lk in mu b gy mz na l nb nc">final ❯ docker-compose down</span></pre><h1 id="c0e7" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">现在，让我们开始吧！</h1><p id="47fe" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">将目录改回起始文件夹。在这个文件夹中，您应该看到包含两个env文件的env文件夹—一个用于MongoDB，另一个用于app。starter文件夹中的另一个文件夹是utils文件夹，目前只包含邮件程序模块。我们将使用这个模块发送电子邮件。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/89002fdcbd1544569862af89e46c422f.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*ZURIUjkCGaW9PkjCMwc4Mg.jpeg"/></div></figure><p id="98f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其余的是:</p><ul class=""><li id="724d" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">。dockerignore文件</li><li id="5009" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">包含一组可执行指令的docker-compose.yml文件，使用它们各自的容器名来启动mongodb、redis和我们的magiclinkredis应用程序映像</li><li id="cb5c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">一个docker文件，具有docker识别的语法，用于创建我们的应用程序映像</li><li id="7893" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">一个空的index.mjs文件，它将很快包含我们的应用程序逻辑</li><li id="9ba2" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">以及描述我们的应用程序依赖关系的package.json文件</li></ul><p id="c498" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，让我们启动所有的容器。运行:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9524" class="my lk in mu b gy mz na l nb nc">starter ❯ docker-compose up -d --build</span></pre><p id="f8c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将查看docker-compose文件，并按照文件中的描述逐行执行指令。它将尝试提取为每个服务规定的图像，并旋转它们各自的容器。下面我们来分析一下Redis服务:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/623292650e9f31cbd9f54574bf4ef000.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*zmrFpkXHeyPWusLFYtgngw.jpeg"/></div></figure><p id="0300" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将从docker hub中调出标签为7.0.2-alpine的官方Redis docker图片。然后，我们为用这个映像创建的容器提供名称“redis”。或者，我们可以在发生意外时“重启”容器。最后，我们执行命令来启动Redis服务器。你可以在<a class="ae li" href="https://hub.docker.com/_/redis" rel="noopener ugc nofollow" target="_blank">官方Redis docker hub页面</a>上找到这个配置和更多信息。</p><p id="8528" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们应用了一个<a class="ae li" href="https://docs.docker.com/storage/bind-mounts/" rel="noopener ugc nofollow" target="_blank">绑定挂载</a>，每当我们在index.mjs文件中做了更改，服务器就会重新加载，这些更改会立即反映出来，这在开发中非常有用。</p><p id="81c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过运行以下命令来跟踪应用程序的日志:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c348" class="my lk in mu b gy mz na l nb nc">starter ❯ docker logs magic-link-redis -f</span></pre><p id="d361" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在index.mjs文件中，让我们导入express、mongoose、morgan和dotenv模块。然后初始化我们的express服务器，并将其连接到MongoDB数据库:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4c89" class="my lk in mu b gy mz na l nb nc"> import express from "express"</span><span id="8111" class="my lk in mu b gy ne na l nb nc"> import mongoose from "mongoose";</span><span id="19da" class="my lk in mu b gy ne na l nb nc"> import morgan from "morgan";</span><span id="ddb8" class="my lk in mu b gy ne na l nb nc"> import { config } from "dotenv";</span><span id="0868" class="my lk in mu b gy ne na l nb nc"> <br/> config({ path: "./env/.env" });</span><span id="6b51" class="my lk in mu b gy ne na l nb nc"> const app = express();</span><span id="b74c" class="my lk in mu b gy ne na l nb nc"> app.use(morgan("combined"));</span><span id="af21" class="my lk in mu b gy ne na l nb nc"> app.use(express.json());</span><span id="5eec" class="my lk in mu b gy ne na l nb nc"> app.use((req, res, next) =&gt; {</span><span id="d6e0" class="my lk in mu b gy ne na l nb nc">  res.setHeader("Access-Control-Allow-Origin", "*");</span><span id="ff00" class="my lk in mu b gy ne na l nb nc">  res.setHeader("Access-Control-Allow-Methods", "GET, POST, DELETE,  OPTIONS");</span><span id="f677" class="my lk in mu b gy ne na l nb nc">  res.setHeader("Access-Control-Allow-Headers", "Content-Type");</span><span id="5902" class="my lk in mu b gy ne na l nb nc">  next();</span><span id="cc6a" class="my lk in mu b gy ne na l nb nc"> });</span><span id="27c2" class="my lk in mu b gy ne na l nb nc"> mongoose.connect(</span><span id="864a" class="my lk in mu b gy ne na l nb nc"> `mongodb://${process.env.MONGODB_USERNAME}:${process.env.MONGODB_PASSWORD}@mongodb:27017/migic-link-redis?authSource=admin`,</span><span id="d74d" class="my lk in mu b gy ne na l nb nc">  {</span><span id="bebb" class="my lk in mu b gy ne na l nb nc">    useNewUrlParser: true,</span><span id="311f" class="my lk in mu b gy ne na l nb nc">    useUnifiedTopology: true,</span><span id="babc" class="my lk in mu b gy ne na l nb nc">  },</span><span id="33c9" class="my lk in mu b gy ne na l nb nc">  (err) =&gt; {</span><span id="f553" class="my lk in mu b gy ne na l nb nc">    if (err) {</span><span id="449b" class="my lk in mu b gy ne na l nb nc">      console.error("FAILED TO CONNECT TO MONGODB");</span><span id="c97e" class="my lk in mu b gy ne na l nb nc">      console.error(err);</span><span id="952b" class="my lk in mu b gy ne na l nb nc">    } else {</span><span id="bfda" class="my lk in mu b gy ne na l nb nc">      console.log("CONNECTED TO MONGODB!!");</span><span id="28ed" class="my lk in mu b gy ne na l nb nc">      app.listen(4000, () =&gt;</span><span id="5bd1" class="my lk in mu b gy ne na l nb nc">        console.log(</span><span id="358b" class="my lk in mu b gy ne na l nb nc">          `App listening on port 4000 in ${process.env.NODE_ENV} mode.`</span><span id="df23" class="my lk in mu b gy ne na l nb nc">        )</span><span id="03ea" class="my lk in mu b gy ne na l nb nc">      );</span><span id="8375" class="my lk in mu b gy ne na l nb nc">    }</span><span id="3515" class="my lk in mu b gy ne na l nb nc">  }</span><span id="9d01" class="my lk in mu b gy ne na l nb nc">);<br/>;</span></pre><p id="dd47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该会在日志中看到这样的消息:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b144aae2094c225bad455ac022ce2b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*5ifLJpWFQZ2UV8wN9_lQCg.jpeg"/></div></figure><p id="185a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个好迹象😉。深呼吸…你做得很好。</p><p id="bf14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建用户模式。从相对于“starter”文件夹的根文件夹中，创建一个新文件夹，并将其命名为“models”。在这个新文件夹中，创建一个“user.mjs”文件。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/447ea55e01a655c052bb40ecddc253eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*Ckaj3TtXu-fRXx6oCc2QvQ.jpeg"/></div></figure><p id="e358" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将以下代码放入user.mjs文件中:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1c1a" class="my lk in mu b gy mz na l nb nc">import mongoose from "mongoose";</span><span id="6be8" class="my lk in mu b gy ne na l nb nc"> import bcrypt from "bcryptjs";</span><span id="cbe3" class="my lk in mu b gy ne na l nb nc"> import validator from "validator";<br/> </span><span id="0fb5" class="my lk in mu b gy ne na l nb nc"> const Schema = mongoose.Schema;<br/> </span><span id="aab1" class="my lk in mu b gy ne na l nb nc"> const userSchema = new Schema(</span><span id="c18c" class="my lk in mu b gy ne na l nb nc">  {</span><span id="2ddc" class="my lk in mu b gy ne na l nb nc">    name: {</span><span id="f1db" class="my lk in mu b gy ne na l nb nc">      type: String,</span><span id="f8da" class="my lk in mu b gy ne na l nb nc">      trim: true,</span><span id="9151" class="my lk in mu b gy ne na l nb nc">    },</span><span id="e8c8" class="my lk in mu b gy ne na l nb nc">    email: {</span><span id="6a2e" class="my lk in mu b gy ne na l nb nc">      type: String,</span><span id="598e" class="my lk in mu b gy ne na l nb nc">      required: true,</span><span id="4160" class="my lk in mu b gy ne na l nb nc">      unique: true,</span><span id="3b85" class="my lk in mu b gy ne na l nb nc">      lowercase: true,</span><span id="24b4" class="my lk in mu b gy ne na l nb nc">      validate: [validator.isEmail, "Email is invalid."],</span><span id="427f" class="my lk in mu b gy ne na l nb nc">    },</span><span id="6a17" class="my lk in mu b gy ne na l nb nc">    password: {</span><span id="7afc" class="my lk in mu b gy ne na l nb nc">      type: String,</span><span id="4fb3" class="my lk in mu b gy ne na l nb nc">      required: true,</span><span id="cedc" class="my lk in mu b gy ne na l nb nc">      select: false,</span><span id="b9da" class="my lk in mu b gy ne na l nb nc">    },</span><span id="278b" class="my lk in mu b gy ne na l nb nc">  },</span><span id="6210" class="my lk in mu b gy ne na l nb nc">  {<br/>    timestamps: true,<br/>  }</span><span id="764c" class="my lk in mu b gy ne na l nb nc"> );<br/> <br/> userSchema.pre("save", async function (next) {</span><span id="9bc0" class="my lk in mu b gy ne na l nb nc">  if (!this.isModified("password")) return next();</span><span id="39dc" class="my lk in mu b gy ne na l nb nc">  // Hash password with a cost of 12</span><span id="1c2d" class="my lk in mu b gy ne na l nb nc">  this.password = await bcrypt.hash(this.password, 12);</span><span id="d73d" class="my lk in mu b gy ne na l nb nc">  next();</span><span id="26a4" class="my lk in mu b gy ne na l nb nc"> });</span><span id="1ded" class="my lk in mu b gy ne na l nb nc"> const UserModel = mongoose.model("User", userSchema);</span><span id="8ebc" class="my lk in mu b gy ne na l nb nc"> export default UserModel;</span></pre><p id="23eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将用户模式模块导入index.mjs文件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="78c2" class="my lk in mu b gy mz na l nb nc">import User from "./models/user.mjs";</span></pre><p id="01b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们创建一个GET /users端点来获取所有用户文档。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4d67" class="my lk in mu b gy mz na l nb nc">app.get("/users", async (req, res) =&gt; {</span><span id="bd0f" class="my lk in mu b gy ne na l nb nc">  try {</span><span id="655c" class="my lk in mu b gy ne na l nb nc">    const users = await User.find();</span><span id="592f" class="my lk in mu b gy ne na l nb nc">    res.status(200).json({</span><span id="44b3" class="my lk in mu b gy ne na l nb nc">      status: "SUCCESS",</span><span id="261e" class="my lk in mu b gy ne na l nb nc">      users,</span><span id="9920" class="my lk in mu b gy ne na l nb nc">    });</span><span id="b6ef" class="my lk in mu b gy ne na l nb nc">  } catch (err) {</span><span id="2f8a" class="my lk in mu b gy ne na l nb nc">    console.error(err.message);</span><span id="5f2b" class="my lk in mu b gy ne na l nb nc">    res.status(500).json({ status: "FAIL", message: "Failed to fetch  users." });</span><span id="dcb4" class="my lk in mu b gy ne na l nb nc">  }</span><span id="31e2" class="my lk in mu b gy ne na l nb nc"> });</span></pre><p id="f1ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开您的Postman(可能)并尝试在GET<a class="ae li" href="http://localhost:4000/users" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/users</a>处调用端点。您应该得到以下响应(否则，请跟我唱二重唱😜):</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/edaeea31efae9357be507baa174516fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*EpCHlmOC-IM-JDLdh9GnBA.jpeg"/></div></figure><h1 id="e39c" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">开始有趣的部分</h1><p id="bad6" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">这是更有趣的地方。我们将创建另一个端点来处理神奇链接逻辑。这个端点将执行开头提到的“端点1”的逻辑。这一次，我们将利用RedisJSON的特性。</p><p id="6b93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在创建此端点之前，我们需要首先创建两个模块:tokenGenerator.mjs和cacheHandler.mjs。因此，在utils文件夹中，创建上述文件并将以下代码放入tokenGenerator.mjs文件中:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="01a0" class="my lk in mu b gy mz na l nb nc">import crypto from "crypto";</span><span id="39ab" class="my lk in mu b gy ne na l nb nc">export default () =&gt; crypto.randomBytes(32).toString("hex");</span></pre><p id="b002" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个模块将用于生成一个随机哈希值，该值被转换成一个字符串并用于注册令牌。</p><p id="2542" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，更重要的是，缓存处理程序。这个文件是我们实现和连接Redis到我们的应用程序的地方。它处理三个函数:getCache用于查询RedisJSON API以通过给定的键获取数据，setCache用于存储具有给定的键、数据和过期时间(以秒为单位)的新缓存，deleteCache用于从内存中删除缓存。如果你想了解更多关于这个概念的内容，请看我之前关于如何使用Redis <a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/how-to-implement-daily-active-users-metric-using-redis-4a7d7c4aca8f">创建活跃用户指标的文章。</a></p><p id="1e9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该模块的代码如下:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2e7a" class="my lk in mu b gy mz na l nb nc">import { createClient } from "redis";</span><span id="4fda" class="my lk in mu b gy ne na l nb nc"> let client;</span><span id="7444" class="my lk in mu b gy ne na l nb nc"> if (process.env.NODE_ENV === "production") {</span><span id="70f5" class="my lk in mu b gy ne na l nb nc">  client = createClient({</span><span id="7294" class="my lk in mu b gy ne na l nb nc">    url: `redis://${process.env.REDIS_USER}:${process.env.REDIS_PASSWORD}@${process.env.REDIS_HOSTNAME}:${process.env.REDIS_PORT}`,</span><span id="5917" class="my lk in mu b gy ne na l nb nc">  });</span><span id="2cda" class="my lk in mu b gy ne na l nb nc"> } else {</span><span id="059a" class="my lk in mu b gy ne na l nb nc">  client = createClient({</span><span id="8a76" class="my lk in mu b gy ne na l nb nc">    url: "redis://redis:6379",</span><span id="3fd0" class="my lk in mu b gy ne na l nb nc">  });</span><span id="5a50" class="my lk in mu b gy ne na l nb nc"> }</span><span id="1189" class="my lk in mu b gy ne na l nb nc">  client.on("error", (err) =&gt; console.log("Redis Client Error", err));</span><span id="e4f4" class="my lk in mu b gy ne na l nb nc">  async function connectRedis() {</span><span id="bab2" class="my lk in mu b gy ne na l nb nc">  await client.connect();</span><span id="b707" class="my lk in mu b gy ne na l nb nc"> }</span><span id="01e3" class="my lk in mu b gy ne na l nb nc">  connectRedis();</span><span id="83af" class="my lk in mu b gy ne na l nb nc">  const defaultExpirationTime = 60 * 10; // 60 seconds times 10 -&gt; 10 minutes</span><span id="7859" class="my lk in mu b gy ne na l nb nc">  const handleCache = (cb) =&gt; cb();</span><span id="8fe1" class="my lk in mu b gy ne na l nb nc">  export const getCache = (key) =&gt;</span><span id="267c" class="my lk in mu b gy ne na l nb nc">   new Promise((resolve, reject) =&gt; {</span><span id="fac2" class="my lk in mu b gy ne na l nb nc">    try {</span><span id="4203" class="my lk in mu b gy ne na l nb nc">      handleCache(async () =&gt; {</span><span id="dcb1" class="my lk in mu b gy ne na l nb nc">        const data = await client.get(key);</span><span id="4e87" class="my lk in mu b gy ne na l nb nc">        if (data) {</span><span id="5ee3" class="my lk in mu b gy ne na l nb nc">          console.log("DATA FOUND! 🥳");</span><span id="1795" class="my lk in mu b gy ne na l nb nc">        }</span><span id="efe1" class="my lk in mu b gy ne na l nb nc">        resolve(JSON.parse(data));</span><span id="4ce2" class="my lk in mu b gy ne na l nb nc">      });</span><span id="56ef" class="my lk in mu b gy ne na l nb nc">    } catch (error) {</span><span id="8e15" class="my lk in mu b gy ne na l nb nc">      reject(error);</span><span id="e953" class="my lk in mu b gy ne na l nb nc">    }</span><span id="2ae1" class="my lk in mu b gy ne na l nb nc">  });</span><span id="b681" class="my lk in mu b gy ne na l nb nc">  export const setCache = (key, data, expTime) =&gt; {</span><span id="f455" class="my lk in mu b gy ne na l nb nc">  if (typeof expTime === "undefined") {</span><span id="9a95" class="my lk in mu b gy ne na l nb nc">    expTime = defaultExpirationTime;</span><span id="ebeb" class="my lk in mu b gy ne na l nb nc">  }</span><span id="61a3" class="my lk in mu b gy ne na l nb nc">  return new Promise((resolve, reject) =&gt; {</span><span id="092d" class="my lk in mu b gy ne na l nb nc">    try {</span><span id="fa2b" class="my lk in mu b gy ne na l nb nc">      handleCache(async () =&gt; {</span><span id="e211" class="my lk in mu b gy ne na l nb nc">        const isOk = await client.set(key, JSON.stringify(data), {</span><span id="039e" class="my lk in mu b gy ne na l nb nc">          EX: expTime,</span><span id="0dd8" class="my lk in mu b gy ne na l nb nc">        });</span><span id="22df" class="my lk in mu b gy ne na l nb nc">        if (isOk) {<br/>          console.log("CACHED! ✅");<br/>        }</span><span id="642a" class="my lk in mu b gy ne na l nb nc">        resolve();</span><span id="a6e3" class="my lk in mu b gy ne na l nb nc">      });</span><span id="5142" class="my lk in mu b gy ne na l nb nc">    } catch (error) {</span><span id="321e" class="my lk in mu b gy ne na l nb nc">      reject(error);</span><span id="6188" class="my lk in mu b gy ne na l nb nc">    }</span><span id="9f6c" class="my lk in mu b gy ne na l nb nc">  });</span><span id="18e8" class="my lk in mu b gy ne na l nb nc"> };</span><span id="a618" class="my lk in mu b gy ne na l nb nc"> export const deleteCache = (key) =&gt;</span><span id="cb49" class="my lk in mu b gy ne na l nb nc">  new Promise((resolve, reject) =&gt; {</span><span id="8f52" class="my lk in mu b gy ne na l nb nc">    try {</span><span id="ae8b" class="my lk in mu b gy ne na l nb nc">      handleCache(async () =&gt; {</span><span id="fea0" class="my lk in mu b gy ne na l nb nc">        const response = await client.del(key);</span><span id="05be" class="my lk in mu b gy ne na l nb nc">        if (response === 1) {</span><span id="8d66" class="my lk in mu b gy ne na l nb nc">          console.log("CACHE DELETED!");</span><span id="6877" class="my lk in mu b gy ne na l nb nc">        }</span><span id="0a19" class="my lk in mu b gy ne na l nb nc">        resolve(JSON.parse(response));</span><span id="e84c" class="my lk in mu b gy ne na l nb nc">      });</span><span id="2660" class="my lk in mu b gy ne na l nb nc">    } catch (error) {</span><span id="dd52" class="my lk in mu b gy ne na l nb nc">      reject(error);</span><span id="ba46" class="my lk in mu b gy ne na l nb nc">    }</span><span id="d429" class="my lk in mu b gy ne na l nb nc">  });</span></pre><p id="5209" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，初始化Redis客户机的实现受到两个条件的限制:如果应用程序运行在开发环境上，则连接到本地Redis服务(运行在docker容器的6379端口上)。否则，使用“您的”凭证连接到redis云服务。这一点至关重要，因为您应该在生产中使用云服务。如果你想了解更多关于Redis Cloud的信息，请访问<a class="ae li" href="https://redis.com/try-free/?utm_campaign=write_for_redis" rel="noopener ugc nofollow" target="_blank">官方页面</a>。最棒的是你可以从免费计划开始。</p><p id="8124" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧！现在，让我们将模块导入index.mjs文件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="af09" class="my lk in mu b gy mz na l nb nc">import tokenGenerator from "./utils/tokenGenerator.mjs";</span><span id="187b" class="my lk in mu b gy ne na l nb nc"> import { setCache, getCache, deleteCache } from  "./utils/cacheHandler.mjs";</span><span id="ea05" class="my lk in mu b gy ne na l nb nc"> import { sendMagicLink } from "./utils/mailer.mjs";</span></pre><p id="21f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，我们还导入了邮件模块。</p><p id="05cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们创建神奇链接端点(端点1):</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="468b" class="my lk in mu b gy mz na l nb nc">app.post("/users/magic_link", async (req, res) =&gt; {</span><span id="227f" class="my lk in mu b gy ne na l nb nc">  const { email } = req.body;</span><span id="ec30" class="my lk in mu b gy ne na l nb nc">  if (!email)</span><span id="36ab" class="my lk in mu b gy ne na l nb nc">    return res.status(400).json({ status: "FAIL", message: "Email required." });</span><span id="aab9" class="my lk in mu b gy ne na l nb nc">  try {</span><span id="4450" class="my lk in mu b gy ne na l nb nc">    // 1) check if user exists already</span><span id="3c92" class="my lk in mu b gy ne na l nb nc">    const userExists = await User.findOne({ email });</span><span id="63f4" class="my lk in mu b gy ne na l nb nc">    if (userExists)</span><span id="57bb" class="my lk in mu b gy ne na l nb nc">      return res</span><span id="3820" class="my lk in mu b gy ne na l nb nc">        .status(400)</span><span id="1d93" class="my lk in mu b gy ne na l nb nc">        .json({ status: "FAIL", message: "Email already in use." });</span><span id="fbe9" class="my lk in mu b gy ne na l nb nc">    // 2) generate token</span><span id="5360" class="my lk in mu b gy ne na l nb nc">    const token = tokenGenerator();</span><span id="98c6" class="my lk in mu b gy ne na l nb nc">    // 3) store email and token in redisJSON for 24 hours</span><span id="c753" class="my lk in mu b gy ne na l nb nc">    const hours24 = 60 * 60 * 24;</span><span id="302c" class="my lk in mu b gy ne na l nb nc">    await setCache(token, { email, token }, hours24);</span><span id="dd2f" class="my lk in mu b gy ne na l nb nc">    // 4) send token to user's email address</span><span id="0fa4" class="my lk in mu b gy ne na l nb nc">    sendMagicLink(email, token);</span><span id="22c0" class="my lk in mu b gy ne na l nb nc">    res.status(200).json({</span><span id="7887" class="my lk in mu b gy ne na l nb nc">      status: "SUCCESS",</span><span id="1953" class="my lk in mu b gy ne na l nb nc">      message: "Link sent to your email!",</span><span id="fb91" class="my lk in mu b gy ne na l nb nc">    });</span><span id="ec4f" class="my lk in mu b gy ne na l nb nc">  } catch (err) {</span><span id="bf7b" class="my lk in mu b gy ne na l nb nc">    console.error(err.message);</span><span id="5845" class="my lk in mu b gy ne na l nb nc">    res</span><span id="33d9" class="my lk in mu b gy ne na l nb nc">      .status(500)</span><span id="d306" class="my lk in mu b gy ne na l nb nc">      .json({ status: "FAIL", message: "Something went terribly wrong."       });</span><span id="7e4a" class="my lk in mu b gy ne na l nb nc">  }</span><span id="f571" class="my lk in mu b gy ne na l nb nc"> });</span></pre><p id="24c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们在端点1中实现了开始时提到的逻辑，但是增加了一个额外的验证步骤，检查给定电子邮件地址的帐户是否已经存在。然后，我们用RedisJSON缓存时态文档，并将到期时间设置为24小时，而不是将它存储在数据库中。简单的👌🏾。</p><p id="2901" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我能感觉到你想测试这个终点的冲动，但是不要这么快😜。注意，邮件模块实现了nodemailer transporter，它需要一些Zoho邮件凭证。这意味着你应该在这里创建一个Zoho账户<a class="ae li" href="https://www.zoho.com/signup.html" rel="noopener ugc nofollow" target="_blank">。然后，替换。env文件分别与您的Zoho电子邮件和密码。现在我们可以走了。</a></p><p id="eff4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用以下有效负载向<a class="ae li" href="http://localhost:4000/users/magic_link" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/users/magic _ link</a>发出POST请求:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/4032030a71900242ed1c8cd8b786844f.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*krp0oK4wRDe1rE-GPOxdNQ.jpeg"/></div></figure><p id="8da6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的邮件应该是你的邮件，否则我会吃掉你的邮件😁。</p><p id="08ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一切正常，您应该会在您的应用程序日志中看到如下消息:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4ae0fe88be804623fedfca5acffb2b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*8S4deDGM3W9YMf5yKPlRcA.jpeg"/></div></figure><p id="c2d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着电子邮件已经发送到您的电子邮件地址。</p><p id="2146" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，让我们创建注册端点(端点2):</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="101b" class="my lk in mu b gy mz na l nb nc">app.post("/users/signup", async (req, res) =&gt; {</span><span id="254d" class="my lk in mu b gy ne na l nb nc">  const { email, name, password } = req.body;</span><span id="f3cc" class="my lk in mu b gy ne na l nb nc">  const { token } = req.query;</span><span id="4c40" class="my lk in mu b gy ne na l nb nc">  // 1) check if user exists already</span><span id="4efe" class="my lk in mu b gy ne na l nb nc">  const userExists = await User.findOne({ email });</span><span id="7621" class="my lk in mu b gy ne na l nb nc">  if (userExists)</span><span id="4b03" class="my lk in mu b gy ne na l nb nc">    return res</span><span id="c7e2" class="my lk in mu b gy ne na l nb nc">      .status(400)</span><span id="5b18" class="my lk in mu b gy ne na l nb nc">      .json({ status: "FAIL", message: "Email already in use." });</span><span id="793e" class="my lk in mu b gy ne na l nb nc">  // 2) require token</span><span id="38a4" class="my lk in mu b gy ne na l nb nc">  if (!token)</span><span id="6a34" class="my lk in mu b gy ne na l nb nc">    return res.status(400).json({ status: "FAIL", message: "Token required." });</span><span id="b6fa" class="my lk in mu b gy ne na l nb nc">  // 3) validate body</span><span id="e811" class="my lk in mu b gy ne na l nb nc">  if (!email || !name || !password)</span><span id="96ef" class="my lk in mu b gy ne na l nb nc">    return res</span><span id="fad2" class="my lk in mu b gy ne na l nb nc">      .status(400)</span><span id="1bd8" class="my lk in mu b gy ne na l nb nc">      .json({ status: "FAIL", message: "Invalid request." });</span><span id="7297" class="my lk in mu b gy ne na l nb nc">  // 4) check if data exists on redisJSON and client email matches data email. if  NOT, return "Access denied"</span><span id="1f66" class="my lk in mu b gy ne na l nb nc">  const data = await getCache(token);</span><span id="d5c5" class="my lk in mu b gy ne na l nb nc">  if (!data || data.email !== email)</span><span id="0e31" class="my lk in mu b gy ne na l nb nc">    return res.status(403).json({ status: "FAIL", message: "Access denied." });</span><span id="a4d3" class="my lk in mu b gy ne na l nb nc">  // 5) if exists, create new user account</span><span id="7081" class="my lk in mu b gy ne na l nb nc">  let user;</span><span id="3a2e" class="my lk in mu b gy ne na l nb nc">  try {</span><span id="5743" class="my lk in mu b gy ne na l nb nc">    user = await User.create({ name, email, password });</span><span id="a8b8" class="my lk in mu b gy ne na l nb nc">    await deleteCache(email);</span><span id="744a" class="my lk in mu b gy ne na l nb nc">    res.status(201).json({</span><span id="cad0" class="my lk in mu b gy ne na l nb nc">      status: "SUCCESS",</span><span id="acf9" class="my lk in mu b gy ne na l nb nc">      message: "User saved!",</span><span id="0f17" class="my lk in mu b gy ne na l nb nc">      user,</span><span id="cf8a" class="my lk in mu b gy ne na l nb nc">    });</span><span id="b75f" class="my lk in mu b gy ne na l nb nc">  } catch (err) {</span><span id="a5c7" class="my lk in mu b gy ne na l nb nc">    console.error(err.message);</span><span id="4030" class="my lk in mu b gy ne na l nb nc">    res.status(500).json({ status: "FAIL", message: "Failed to save user." });</span><span id="aa2f" class="my lk in mu b gy ne na l nb nc">  }</span><span id="b837" class="my lk in mu b gy ne na l nb nc">});</span></pre><p id="7b7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们还要确保不要用已经存在的电子邮件地址创建帐户。我们确保将令牌和所需的主体细节传递给请求对象。然后，我们检查Redis上的令牌是否存在。如果令牌存在，并且提供的电子邮件与Redis上存储的数据电子邮件相匹配，那么我们继续创建用户文档。此后，出于安全考虑，我们会删除缓存，即使它无论如何都会过期。</p><p id="8c42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多酷啊。使用Redis简单而有效地解决了这个问题。现在，让我们测试这个端点。转到您的收件箱，复制URL字符串中的令牌。将令牌附加到请求查询对象，并将请求发送到<a class="ae li" href="http://localhost:4000/users/signup?token=YOUR_TOKEN" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/users/sign up？token=YOUR_TOKEN </a>具有以下有效载荷:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f437879cc9f5724b13eebb71cee16757.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*xJVCjFmZR5SGnRU3yzP4NQ.jpeg"/></div></figure><p id="fc1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一切正常，您应该会得到一个成功的201响应👍🏾。</p><h1 id="2a2e" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="d20f" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">每个用户都想要轻松的生活。如果你想让你的应用程序的认证对你的用户来说简单10倍，利用RedisJSON。我希望这篇教程对你有所帮助。</p><p id="17e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章是与Redis合作的。</p><p id="be8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解更多信息:</p><ul class=""><li id="b730" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><a class="ae li" href="https://redis.info/3NBGJRT" rel="noopener ugc nofollow" target="_blank">免费试用Redis Cloud】</a></li><li id="e16b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><a class="ae li" href="https://redis.info/3Ga9YII" rel="noopener ugc nofollow" target="_blank">观看此视频，了解Redis云相对于其他Redis提供商的优势</a></li><li id="71b3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><a class="ae li" href="https://redis.info/3LC4GqB" rel="noopener ugc nofollow" target="_blank"> Redis开发者中心——关于Redis的工具、指南和教程</a></li><li id="c27a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><a class="ae li" href="https://redis.info/3wMR7PR" rel="noopener ugc nofollow" target="_blank"> RedisInsight桌面图形用户界面</a></li></ul><p id="39fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nm">更多内容请看</em><a class="ae li" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nm">plain English . io</em></strong></a><em class="nm">。报名参加我们的</em> <a class="ae li" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nm">免费周报</em> </strong> </a> <em class="nm">。关注我们关于</em> <a class="ae li" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nm">推特</em></strong></a><a class="ae li" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nm">领英</em></strong></a><strong class="jx io"><em class="nm"/></strong><em class="nm">和</em> <a class="ae li" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="nm">不和</em> </strong> </a> <strong class="jx io"> <em class="nm">。</em>T45】</strong></p></div></div>    
</body>
</html>