<html>
<head>
<title>7 Must-Know React Hooks for Improved Efficiency and Maintainability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高效率和可维护性的7个必备React挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-must-know-react-hooks-for-improved-efficiency-and-maintainability-a39fe7c0656e?source=collection_archive---------5-----------------------#2022-12-13">https://javascript.plainenglish.io/7-must-know-react-hooks-for-improved-efficiency-and-maintainability-a39fe7c0656e?source=collection_archive---------5-----------------------#2022-12-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d2ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的日常发展行动挂钩</p><p id="0f97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一名软件工程师，我发现React挂钩是一个改变游戏规则的工具，可以为功能组件添加状态和其他React特性。在这篇博文中，我将分享我认为每个开发人员都应该熟悉的七个React挂钩。这些钩子为我节省了无数的编码时间，并使我的React应用程序更加高效和可维护。所以，让我们深入了解一下这些强大的钩子吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7587f7358dde6cbef5e6a20f502badc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28sPnyGYy4a6Bfuy0T2gww.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://forum.wordreference.com/threads/get-the-hook-get-it.3283268/" rel="noopener ugc nofollow" target="_blank">Get the hook. Get it?</a></figcaption></figure><h2 id="a696" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">使用状态</h2><p id="c665" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">useState钩子是最基本和最重要的React钩子。它允许功能组件拥有状态，这对于管理和更新React应用程序中的数据至关重要。useState挂钩将初始状态值作为参数，并返回包含两个元素的数组:当前状态值和更新状态值的函数。</p><pre class="kj kk kl km gt lx ly lz bn ma mb bi"><span id="70af" class="mc la in ly b be md me l mf mg">const [count, setCount] = useState(0);<br/><br/>const increment = () =&gt; setCount(count + 1);<br/>const decrement = () =&gt; setCount(count - 1);</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h2 id="574f" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">使用效果</h2><p id="30a9" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">useEffect钩子是一个通用的钩子，它允许功能组件执行副作用，比如数据获取、订阅和DOM更新。useEffect挂钩将一个函数作为参数，并在每次渲染后执行它。它还带有一个可选的依赖数组，允许开发人员控制何时应该执行效果。</p><pre class="kj kk kl km gt lx ly lz bn ma mb bi"><span id="670e" class="mc la in ly b be md me l mf mg">useEffect(() =&gt; {<br/>  document.title = `You clicked ${count} times`;<br/>}, [count]); // Only re-run the effect if count changes</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h2 id="c083" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">使用上下文</h2><p id="7cfa" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">useContext挂钩允许功能组件访问React上下文，这是一种通过组件树传递数据的方式，而不必在每一层手动传递属性。useContext挂钩将一个上下文对象作为参数，并返回该上下文的当前上下文值。</p><pre class="kj kk kl km gt lx ly lz bn ma mb bi"><span id="aa06" class="mc la in ly b be md me l mf mg">const theme = useContext(ThemeContext);</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h2 id="075d" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">useRef</h2><p id="d025" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">useRef钩子允许功能组件访问底层DOM元素，这对于管理焦点、文本选择或媒体回放非常有用。useRef钩子接受一个初始值作为参数，并返回一个可变的Ref对象，该对象可用于存储一个跨渲染持久的值。</p><pre class="kj kk kl km gt lx ly lz bn ma mb bi"><span id="6e6f" class="mc la in ly b be md me l mf mg">const inputRef = useRef();<br/><br/>const focusInput = () =&gt; {<br/>  inputRef.current.focus();<br/>};</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h2 id="a922" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">用户教育</h2><p id="4417" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">useReducer挂钩是useState挂钩的更高级版本，它允许功能组件管理复杂的状态逻辑，例如处理异步操作、数据加载和错误处理。useReducer挂钩将Reducer函数和初始状态作为参数，并返回当前状态和可用于更新状态的调度函数。这个钩子对于以可预测和一致的方式管理复杂的状态特别有用。</p><pre class="kj kk kl km gt lx ly lz bn ma mb bi"><span id="faba" class="mc la in ly b be md me l mf mg">const [state, dispatch] = useReducer(reducer, initialState);<br/><br/>dispatch({ type: 'increment' });</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h2 id="c159" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">使用回调</h2><p id="f500" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">useCallback挂钩是一个性能优化挂钩，允许开发人员记忆昂贵的或经常使用的函数。useCallback挂钩将一个函数和一组依赖项作为参数，并返回该函数的一个记忆版本，只有当其中一个依赖项发生变化时，该函数才会发生变化。这可以通过减少不必要的重新渲染次数来提高React应用程序的性能。</p><pre class="kj kk kl km gt lx ly lz bn ma mb bi"><span id="5541" class="mc la in ly b be md me l mf mg">const memoizedCallback = useCallback(() =&gt; {<br/>  doSomethingExpensive();<br/>}, [dependencies]);</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h2 id="1174" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">使用备忘录</h2><p id="0d76" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">useMemo挂钩类似于useCallback挂钩，但它允许开发人员记忆复杂表达式的值，而不是函数的值。useMemo钩子将一个函数和一组依赖项作为参数，并返回函数的记忆值，该值只在其中一个依赖项发生变化时才发生变化。这还可以通过减少不必要的计算来提高React应用程序的性能。</p><pre class="kj kk kl km gt lx ly lz bn ma mb bi"><span id="83e6" class="mc la in ly b be md me l mf mg">const memoizedValue = useMemo(() =&gt; {<br/>  return expensiveComputation(param);<br/>}, [param]);</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="2d52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总之，作为一名软件工程师，我发现React Hooks是我的工具箱中不可或缺的工具。这篇博文中讨论的七个钩子——useState、useEffect、useContext、useRef、useReducer、useCallback和use memo——极大地提高了我的React应用程序的效率和可维护性。我强烈建议所有开发人员熟悉这些挂钩，并将它们融入到自己的项目中。编码快乐！</p><p id="8fb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mo">更多内容请看</em><a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mo">plain English . io</em></strong></a><em class="mo">。报名参加我们的</em> <a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mo">免费周报</em> </strong> </a> <em class="mo">。关注我们关于</em><a class="ae ky" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mo">Twitter</em></strong></a><a class="ae ky" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mo">LinkedIn</em></strong></a><em class="mo"/><a class="ae ky" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mo">YouTube</em></strong></a><em class="mo"/><a class="ae ky" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mo">不和</em> </strong> </a> <strong class="jm io"> <em class="mo">。</em>T49】</strong></p><p id="bc41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mo">对缩放您的软件启动感兴趣</em> </strong> <em class="mo">？检查</em> <a class="ae ky" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mo">电路</em> </strong> </a> <em class="mo">。</em></p></div></div>    
</body>
</html>