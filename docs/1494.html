<html>
<head>
<title>Full JWT-Based Auth Implementation for Your React Apps Using a GraphQL API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL API为React应用程序实现完全基于JWT的身份验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/full-jwt-based-auth-implementation-for-your-react-apps-using-a-graphql-api-a8b83ad285f5?source=collection_archive---------1-----------------------#2022-03-29">https://javascript.plainenglish.io/full-jwt-based-auth-implementation-for-your-react-apps-using-a-graphql-api-a8b83ad285f5?source=collection_archive---------1-----------------------#2022-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7227" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何通过GraphQL API使用JWT为我们的React项目实现认证端到端解决方案的指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f409f737a26c3934a5c9958758afb63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xgj-bsf8_r89Ffzv"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@moneyphotos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">olieman.eth</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kw kx ky"><p id="a6fa" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">更新:在我发表这篇文章后，我收到了一些评论，告诉我不要使用本地存储来存储JWT，因为这是一个潜在的安全风险，他们是正确的。我还可以进一步说，你不应该在内部实现你自己的认证系统，因为这样做有很多警告，你可能会进入一个兔子洞。如果可能的话，你应该总是选择使用像Auth0、Okta或类似的服务。也就是说，我相信这篇文章仍然是有用的，因为它的结构对于认证服务来说是最不可思议的，您只需在代码中做一些修改就可以更改它。</p></blockquote><p id="aebb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在这篇文章中，我们将看到如何通过GraphQL API使用JWT为React项目实现一个端到端的认证解决方案。</p><p id="ca89" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">接下来的工具、库和概念将用于构建应用程序:</p><ul class=""><li id="3fac" class="lz ma iq lc b ld le lg lh lw mb lx mc ly md lv me mf mg mh bi translated"><a class="ae kv" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> CRA </a></li><li id="ad0c" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated"><a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a></li><li id="f710" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated"><a class="ae kv" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank">反应路由器</a></li><li id="ad72" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated"><a class="ae kv" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">阿波罗客户端</a></li><li id="b204" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated"><a class="ae kv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a></li><li id="c79f" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated"><a class="ae kv" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">代码拆分</a></li><li id="8719" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated"><a class="ae kv" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">定制挂钩</a></li></ul><p id="4079" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">但是在编写一行代码之前，让我们先了解我们将使用下面的图表构建什么。</p><h2 id="033a" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">注册</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a21d18e214b257f36f64da507be05414.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*6ZT0S6UmuZZkDuv2a54X1Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Sequence diagram: Login</figcaption></figure><h2 id="d551" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lw mw mx my lx mz na nb ly nc nd ne nf bi translated">受保护的资源</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/198a976d231bc910e46a39c4cbc4d36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*P-8ya0hqlT7Rarq6331EbA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Sequence diagram: Subsequent requests after logging in</figcaption></figure><p id="4a9a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在这篇文章中，我们不打算关注实际的API，我们只是假设我们已经有了一个带有下一个签名的<strong class="lc ir">突变</strong>，或者如果你没有，你可以使用类似<a class="ae kv" href="https://mswjs.io/docs/getting-started/mocks/graphql-api" rel="noopener ugc nofollow" target="_blank"> MSW </a>的东西来模仿一个，这非常容易。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="6e32" class="mn mo iq nj b gy nn no l np nq">login(email: String!, password: String!): AuthData</span><span id="18dc" class="mn mo iq nj b gy nr no l np nq">type AuthData {<br/> user: User<br/> token: String!<br/>}</span><span id="0483" class="mn mo iq nj b gy nr no l np nq">type User {<br/>  id: ID<br/>  email: String<br/>  firstName: String<br/>  lastName: String<br/>  created: Date<br/>}</span></pre><p id="7b26" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如您所见，我们正在发送<em class="lb">电子邮件</em>和<em class="lb">密码</em>，我们得到的响应是一个<strong class="lc ir"> AuthData </strong>对象，其中包括一个<strong class="lc ir">用户</strong>和一个<strong class="lc ir">令牌</strong>，该令牌将用于对API执行以下请求。</p><p id="2fc8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这是使用<strong class="lc ir"> MSW </strong>的特定签名的处理程序，以防您走那条路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">handlers.js</figcaption></figure><h1 id="4421" class="nu mo iq bd mp nv nw nx ms ny nz oa mv jw ob jx my jz oc ka nb kc od kd ne oe bi translated">初始设置</h1><p id="147e" class="pw-post-body-paragraph kz la iq lc b ld of jr lf lg og ju li lw oh ll lm lx oi lp lq ly oj lt lu lv ij bi translated">好了，现在我们理解了需求(我希望🤞)，我们开始吧。我将使用包含Typescript和其他代码质量友好工具的下一个模板，而不是从头开始。</p><div class="ok ol gp gr om on"><a href="https://github.com/drac94/code-quality-friendly-reactjs-template" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">GitHub-drac 94/code-quality-friendly-react js-模板</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">这个项目是用Create React App引导的。这个项目包括:在项目目录中，您可以运行:运行…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb kp on"/></div></div></a></div><p id="fb25" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">该模板缺少Apollo客户端和React路由器，以实现本文的预期结果，所以让我们安装它们。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="cb86" class="mn mo iq nj b gy nn no l np nq">npm install @apollo/client graphql react-router-dom@6</span></pre><h1 id="0dda" class="nu mo iq bd mp nv nw nx ms ny nz oa mv jw ob jx my jz oc ka nb kc od kd ne oe bi translated">初始路由</h1><p id="1924" class="pw-post-body-paragraph kz la iq lc b ld of jr lf lg og ju li lw oh ll lm lx oi lp lq ly oj lt lu lv ij bi translated">我们将在应用程序中有三个视图，<strong class="lc ir">登录</strong> ( <code class="fe pc pd pe nj b">/login</code>)，<strong class="lc ir">主页</strong> ( <code class="fe pc pd pe nj b">/</code>)，以及一个<strong class="lc ir">未找到</strong> ( <code class="fe pc pd pe nj b">/404</code>)，以防用户试图导航到未知的路线。</p><p id="b6f6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">因此，让我们从创建三个视图开始，<strong class="lc ir">登录</strong>、<strong class="lc ir">主页、</strong>和<strong class="lc ir">未找到</strong>在<em class="lb">视图</em>文件夹内，如果您正在使用模板，您可以看到里面已经有一个<strong class="lc ir">应用</strong>文件夹(如果您使用CRA创建您的项目，您也会有它)，我们将使用这个视图来处理路由。</p><p id="8981" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这个项目现在应该是这样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/1304e5b2a7ffd35a3ca994586c061958.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*pZoBYTD6E2w5RIVQqWMMBA.png"/></div></div></figure><p id="85d7" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在<em class="lb"> App.tsx </em>文件中导入您刚刚创建的视图，以一种懒惰的方式进行，这样它们只在需要的时候才被加载。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="2785" class="mn mo iq nj b gy nn no l np nq">const Login = lazy(() =&gt; import(‘../Login’));<br/>const NotFound = lazy(() =&gt; import(‘../NotFound’));<br/>const Home = lazy(() =&gt; import(‘../Home’));</span></pre><p id="12ea" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在，删除渲染函数中的所有内容，并添加以下代码来配置路由，我不会解释React Router如何工作，但如果您对以下代码有不理解的地方，可以直接查看他们的<a class="ae kv" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="9d4a" class="mn mo iq nj b gy nn no l np nq">&lt;Suspense <em class="lb">fallback</em>={&lt;p&gt;Loading&lt;/p&gt;}&gt;<br/>  &lt;Routes&gt;<br/>    &lt;Route <em class="lb">path</em>="/login" <em class="lb">element</em>={&lt;Login /&gt;} /&gt;<br/>    &lt;Route <em class="lb">path</em>="/" <em class="lb">element</em>={&lt;Home /&gt;} /&gt;<br/>    &lt;Route <em class="lb">path</em>="/404" <em class="lb">element</em>={&lt;NotFound /&gt;} /&gt;<br/>    &lt;Route <em class="lb">path</em>="*" <em class="lb">element</em>={&lt;Navigate <em class="lb">replace</em> <em class="lb">to</em>="/404" /&gt;} /&gt;<br/>  &lt;/Routes&gt;<br/>&lt;/Suspense&gt;</span></pre><p id="8172" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">您可能会在浏览器中看到一个错误，这是因为我们需要将所有这些代码包装在路由器中，所以现在转到<em class="lb"> src/index.tsx </em>文件，并像这样包装<strong class="lc ir"> App </strong>组件。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="4b21" class="mn mo iq nj b gy nn no l np nq">&lt;BrowserRouter&gt;<br/>  &lt;App /&gt;<br/>&lt;/BrowserRouter&gt;</span></pre><p id="04dd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不要忘记导入浏览器路由器</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="9c8e" class="mn mo iq nj b gy nn no l np nq">import { BrowserRouter } from 'react-router-dom';</span></pre><p id="c7f0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">就这样，你可以在<code class="fe pc pd pe nj b">/login</code>、<code class="fe pc pd pe nj b">/</code>和<code class="fe pc pd pe nj b">/404</code>之间导航，你会看到你在这些组件中渲染的任何东西。另外，请注意，如果您导航到任何其他未定义的路线，您将被重定向到<code class="fe pc pd pe nj b">/404</code> <em class="lb">。</em></p><h1 id="a660" class="nu mo iq bd mp nv nw nx ms ny nz oa mv jw ob jx my jz oc ka nb kc od kd ne oe bi translated">初始联网</h1><p id="8f8c" class="pw-post-body-paragraph kz la iq lc b ld of jr lf lg og ju li lw oh ll lm lx oi lp lq ly oj lt lu lv ij bi translated">现在是时候配置应用程序，使其能够向API发出请求，为此，使用我直接从他们的<a class="ae kv" href="https://www.apollographql.com/docs/react/networking/basic-http-networking/" rel="noopener ugc nofollow" target="_blank">文档</a>中提取的下一个代码，在<em class="lb"> src </em>文件夹下创建一个名为<em class="lb"> apolloConfig.ts </em>的文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><em class="pg">apolloConfig.ts</em></figcaption></figure><p id="d4fd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在转到<em class="lb"> src/index.tsx </em>，用<strong class="lc ir"> ApolloProvider </strong>包装所有东西。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="c2d5" class="mn mo iq nj b gy nn no l np nq">import { ApolloProvider } from '@apollo/client';</span><span id="7bc7" class="mn mo iq nj b gy nr no l np nq">import { client } from './apolloConfig';</span><span id="faa0" class="mn mo iq nj b gy nr no l np nq">...</span><span id="2922" class="mn mo iq nj b gy nr no l np nq">&lt;ApolloProvider <em class="lb">client</em>={client}&gt;<br/>  &lt;BrowserRouter&gt;<br/>    &lt;App /&gt;<br/>  &lt;/BrowserRouter&gt;<br/>&lt;/ApolloProvider&gt;</span></pre><h1 id="802f" class="nu mo iq bd mp nv nw nx ms ny nz oa mv jw ob jx my jz oc ka nb kc od kd ne oe bi translated">登录视图</h1><p id="c9fd" class="pw-post-body-paragraph kz la iq lc b ld of jr lf lg og ju li lw oh ll lm lx oi lp lq ly oj lt lu lv ij bi translated">现在我们已经有了路由和初始网络，是时候实现<strong class="lc ir">登录</strong>视图了。因为这是一个非常基本的形式，我们将使用不受控制的组件。将下一个代码放在<em class="lb"> Login.tsx </em>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><em class="pg">Login.tsx</em></figcaption></figure><p id="13ea" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">看看我们是如何呈现一个基本表单并直接在提交处理程序上获取输入值的，这样我们就不需要使用状态或引用了。有些挑战是我们需要在处理程序上使用的类型，但是我为你解决了这个问题。此外，看看我们如何使用本机浏览器验证电子邮件具有有效的结构，并且两个字段都是必需的，因此您不需要自己实现它们。</p><p id="3c41" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在处理程序内部，我们只在控制台上打印输入值，让我们实现实际的功能。</p><p id="515e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我喜欢将逻辑与视图分开，所以让我们在<strong class="lc ir"> Login </strong>文件夹中创建两个新文件，一个名为<em class="lb"> Login.query.ts </em>，另一个名为<em class="lb"> Login.compound.tsx </em>，其中包含下一段代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Login.query.ts</figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Login.compound.tsx</figcaption></figure><p id="2e1e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">并将<em class="lb"> Login.tsx </em>文件更新如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><em class="pg">Login.tsx</em></figcaption></figure><p id="8715" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这里似乎进行了很多工作，但实际上并没有，在<em class="lb"> Login.query.ts </em>文件中，我们只是放入了我们将使用的GraphQL变异定义，在<em class="lb">log in . compound . tsx</em>文件中，我们只是使用之前定义的查询创建了<a class="ae kv" href="https://www.apollographql.com/docs/react/data/mutations/#executing-a-mutation" rel="noopener ugc nofollow" target="_blank"> Apollo客户端变异</a>，然后在用户使用<em class="lb"> handleLogin </em>函数单击提交按钮时触发它，传递输入值。还有，我们更新了<em class="lb"> Login.tsx </em>文件来接收一些道具。</p><p id="3b97" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不要忘记将<strong class="lc ir">登录</strong>文件夹内的<em class="lb"> index.ts </em>文件改为现在指向复合。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="f985" class="mn mo iq nj b gy nn no l np nq">export { default } from './Login.compound';</span></pre><h1 id="c2fb" class="nu mo iq bd mp nv nw nx ms ny nz oa mv jw ob jx my jz oc ka nb kc od kd ne oe bi translated">用户上下文</h1><p id="5562" class="pw-post-body-paragraph kz la iq lc b ld of jr lf lg og ju li lw oh ll lm lx oi lp lq ly oj lt lu lv ij bi translated">在<em class="lb"> Login.compound.tsx </em>文件的第37行中，我们只是将<strong class="lc ir">令牌</strong>和<strong class="lc ir">用户</strong>对象打印到控制台，但是我们想要的是存储这些信息，以便所有应用程序都可以访问它们。对于第一个目标，我们将把它们存储在本地存储中，对于第二个目标，我们将使用上下文API镜像这些信息，这样我们就可以获得这些信息，而不必每次都查询本地存储。</p><p id="4ca0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们在src下创建一个名为<em class="lb"> userContext.tsx </em>的新文件，因为我们将开始重用一些常量和类型，所以我们也在src下创建两个新文件，<em class="lb"> types.ts </em>和<em class="lb"> constants.ts </em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">types.ts</figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">constants.ts</figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><em class="pg">userContext.tsx</em></figcaption></figure><p id="dc5d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们解开<em class="lb"> userContext.tsx </em>文件，我们只是创建了一个新的上下文，它将公开三个东西，即<strong class="lc ir">用户</strong>对象，以及两个函数<strong class="lc ir">登录</strong>，它将令牌和用户存储在本地存储区和状态中，以及<strong class="lc ir">注销</strong>，它将删除这些值。此外，我们有一个useEffect，用于在用户重新加载页面时将值从本地存储恢复到状态，还有一个自定义钩子，用于在我们使用提供者之外的上下文时防止应用程序崩溃。</p><p id="6d73" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在让我们更新文件<em class="lb"> src/index.tsx </em>,使上下文在任何地方都可用。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="b76d" class="mn mo iq nj b gy nn no l np nq">import UserContextProvider from './userContext';</span><span id="661e" class="mn mo iq nj b gy nr no l np nq">...</span><span id="ae2a" class="mn mo iq nj b gy nr no l np nq">&lt;ApolloProvider <em class="lb">client</em>={client}&gt;<br/>  &lt;BrowserRouter&gt;<br/>    &lt;UserContextProvider&gt;<br/>      &lt;App /&gt;<br/>    &lt;/UserContextProvider&gt;<br/>  &lt;/BrowserRouter&gt;<br/>&lt;/ApolloProvider&gt;</span></pre><p id="e418" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">此外，让我们更新<em class="lb"> Login.compound.tsx </em>文件，以使用新的闪亮<strong class="lc ir">登录</strong>功能。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="e637" class="mn mo iq nj b gy nn no l np nq">import { useUserContext } from '../../userContext';</span><span id="3215" class="mn mo iq nj b gy nr no l np nq">...</span><span id="ddcd" class="mn mo iq nj b gy nr no l np nq">const LoginCompound = (): JSX.Element =&gt; {<br/>  const { signIn } = useUserContext();</span><span id="ce58" class="mn mo iq nj b gy nr no l np nq">...</span><span id="0eb6" class="mn mo iq nj b gy nr no l np nq">onCompleted: (<em class="lb">data</em>) =&gt; {<br/>  const {<br/>    login: { token, user },<br/>  } = <em class="lb">data</em>;<br/>  signIn(user, token);<br/>  navigate('/', { replace: true });<br/>},</span></pre><p id="61f8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">好了，我们休息一下，总结一下我们到现在为止所建立的东西。我们已经完成了<strong class="lc ir">登录</strong>流程，我们有了<strong class="lc ir">登录</strong>视图，用户可以输入他们的凭证并提交表单，然后我们发出API请求，根据我们得到的响应，我们显示一个错误，或者我们将<strong class="lc ir">令牌</strong>和<strong class="lc ir">用户</strong>详细信息存储到本地存储和用户上下文中，并将用户重定向到<strong class="lc ir">主页</strong>页面。但是现在用户仍然可以导航到主页，即使它没有登录，所以让我们实现我们的第二个流。</p><h1 id="4e1e" class="nu mo iq bd mp nv nw nx ms ny nz oa mv jw ob jx my jz oc ka nb kc od kd ne oe bi translated">受保护的路线</h1><p id="91c1" class="pw-post-body-paragraph kz la iq lc b ld of jr lf lg og ju li lw oh ll lm lx oi lp lq ly oj lt lu lv ij bi translated">让我们创建两个新文件，一个在<strong class="lc ir"> App </strong>文件夹中，名为<em class="lb"> ProtectedRoute.tsx </em>，另一个在src文件夹下，名为<em class="lb"> auth.ts </em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">auth.ts</figcaption></figure><p id="f326" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> isAuthenticated </strong>是一个简单的函数，用于从本地存储中获取令牌，并检查到期时间是否大于当前时间，如果是，则意味着令牌仍然有效。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">ProtectedRoute.tsx</figcaption></figure><p id="57dd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> ProtectedRoute </strong>组件利用先前的函数来知道它是否应该显示用户试图导航的视图，或者它是否应该将用户重定向到<strong class="lc ir">登录</strong>视图。<strong class="lc ir">导航</strong>组件中的<em class="lb">状态</em>属性是为了知道用户试图访问哪条路线，这样我们可以在用户正确登录后将他们重定向到该视图。</p><p id="4561" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们需要更新<em class="lb"> App.tsx </em>文件，这样我们就可以通过将<strong class="lc ir"> Home </strong>视图放入<strong class="lc ir"> ProtectedRoute </strong>组件来保护它。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="4db4" class="mn mo iq nj b gy nn no l np nq">import ProtectedRoute from './ProtectedRoute';</span><span id="090e" class="mn mo iq nj b gy nr no l np nq">...</span><span id="7318" class="mn mo iq nj b gy nr no l np nq">&lt;Route<br/>  <em class="lb">path</em>="/"<br/>  <em class="lb">element</em>={<br/>    &lt;ProtectedRoute&gt;<br/>      &lt;Home /&gt;<br/>    &lt;/ProtectedRoute&gt;<br/>  }<br/>/&gt;</span></pre><p id="f1b8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在，如果你试图导航到<code class="fe pc pd pe nj b">/</code>而你还没有登录，你将被重定向到<code class="fe pc pd pe nj b">/login</code> <em class="lb">，</em>试试吧！。</p><h1 id="e34b" class="nu mo iq bd mp nv nw nx ms ny nz oa mv jw ob jx my jz oc ka nb kc od kd ne oe bi translated">高级网络</h1><p id="e859" class="pw-post-body-paragraph kz la iq lc b ld of jr lf lg og ju li lw oh ll lm lx oi lp lq ly oj lt lu lv ij bi translated">用户登录后，我们需要将令牌发送给后续的API调用，以查看用户是否可以访问资源，让我们修改我们的<em class="lb"> apolloConfig.ts </em>文件来添加这个功能。我刚刚从官方<a class="ae kv" href="https://www.apollographql.com/docs/react/networking/authentication/#header" rel="noopener ugc nofollow" target="_blank"> Apollo客户端文档</a>中抓取了下一个代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">apolloConfig.ts</figcaption></figure><p id="229f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们从本地存储中获取头部，并通过链接Apollo链接将其作为授权头部添加到每个HTTP请求中。</p><p id="1a75" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在可能发生的情况是，令牌可以通过使用开发工具修改本地存储而被篡改，或者它可以在到达后端之前过期，在这种情况下，后端应该返回一个<code class="fe pc pd pe nj b">401</code>状态代码错误，因为令牌不再有效，在前端，我们需要通过邀请用户再次登录来让他们知道。我们也可以像这样使用Apollo客户机来实现它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">apolloConfig.ts</figcaption></figure><p id="0179" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们向Apollo链添加了一个<strong class="lc ir"> onError </strong>链接，该链接在请求完成之后、到达您的视图之前被调用，在该链接中，我们可以检查是否有错误，以及错误是否有一个<code class="fe pc pd pe nj b">401</code>状态代码，这样我们就可以重定向到用户的<strong class="lc ir">登录</strong>视图。</p><p id="db07" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">但是现在我们有一个小问题，我们不能在React上下文之外使用路由器，这就是为什么第32行有一个<em class="lb"> TODO </em>注释，我们应该将用户重定向到<strong class="lc ir"> Login </strong>视图，但是我们不能，因为这个函数在React上下文之外。不过不用担心，有办法，总会有办法的。</p><p id="cbc5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了解决这个问题，我们将创建自己的历史，并将其传递给路由器，如这里的<a class="ae kv" href="https://reactrouter.com/docs/en/v6/api#unstable_historyrouter" rel="noopener ugc nofollow" target="_blank">所述</a>。首先在<em class="lb"> src </em>下创建一个名为<em class="lb"> browserHistory.ts </em>的新文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">browserHistory.ts</figcaption></figure><p id="86c4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">然后将index.tsx文件中的<strong class="lc ir"> BrowserRouter </strong>更改为<strong class="lc ir">不稳定历史路由器</strong>。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="7ab1" class="mn mo iq nj b gy nn no l np nq">̶i̶m̶p̶o̶r̶t̶ ̶{̶ ̶B̶r̶o̶w̶s̶e̶r̶R̶o̶u̶t̶e̶r̶ ̶}̶ ̶f̶r̶o̶m̶ ̶'̶r̶e̶a̶c̶t̶-̶r̶o̶u̶t̶e̶r̶-̶d̶o̶m̶'̶;̶</span><span id="9efe" class="mn mo iq nj b gy nr no l np nq">import { unstable_HistoryRouter as HistoryRouter } from 'react-router-dom';</span><span id="3503" class="mn mo iq nj b gy nr no l np nq">import browserHistory from './browserHistory';</span><span id="c29a" class="mn mo iq nj b gy nr no l np nq">&lt;ApolloProvider <em class="lb">client</em>={client}&gt;<br/>  ̶&lt;̶B̶r̶o̶w̶s̶e̶r̶R̶o̶u̶t̶e̶r̶&gt;̶<br/>  &lt;HistoryRouter <em class="lb">history</em>={browserHistory}&gt;<br/>    &lt;UserContextProvider&gt;<br/>      &lt;App /&gt;<br/>    &lt;/UserContextProvider&gt;<br/>  &lt;/HistoryRouter&gt;<br/>  &lt;̶B̶r̶o̶w̶s̶e̶r̶R̶o̶u̶t̶e̶r̶&gt;̶<br/>&lt;/ApolloProvider&gt;</span></pre><p id="c5dc" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在转到<em class="lb"> apolloConfig.ts </em>文件的第32行，修改这一行的注释。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="8104" class="mn mo iq nj b gy nn no l np nq">browserHistory.push('/login');</span></pre><p id="c032" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">别忘了先导入。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="af16" class="mn mo iq nj b gy nn no l np nq">import browserHistory from './browserHistory';</span></pre><h1 id="89e7" class="nu mo iq bd mp nv nw nx ms ny nz oa mv jw ob jx my jz oc ka nb kc od kd ne oe bi translated">结论</h1><p id="9d9f" class="pw-post-body-paragraph kz la iq lc b ld of jr lf lg og ju li lw oh ll lm lx oi lp lq ly oj lt lu lv ij bi translated">就这样，我们实施了一个功能性的端到端身份认证流程。我们仍然可以在这里改进一些东西，比如防止用户导航到已经认证的<code class="fe pc pd pe nj b">/login</code>路径，一种注销用户的方法，还包括基于角色的流授权，但我认为这篇文章已经太大了，所以我将在下一篇文章中做这些事情。你可以在这里找到我们在这篇文章<a class="ae kv" href="https://github.com/drac94/react-auth-graphql" rel="noopener ugc nofollow" target="_blank">中实现的完整代码。</a></p><p id="e308" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">感谢阅读和快乐编码！</p><p id="06ea" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><em class="lb">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="lb">plain English . io</em></strong></a><em class="lb">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="lb">免费周报</em> </strong> </a> <em class="lb">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="lb">Twitter</em></strong></a><em class="lb">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"><em class="lb">LinkedIn</em></strong></a><em class="lb">。加入我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="lb">社区不和谐</em> </strong> </a> <em class="lb">。</em></p></div></div>    
</body>
</html>