<html>
<head>
<title>You Think You Know the Difference Between var, let, and const?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你认为你知道var，let和const的区别吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-think-you-know-the-difference-between-var-let-and-const-b55b638529fc?source=collection_archive---------3-----------------------#2022-04-07">https://javascript.plainenglish.io/you-think-you-know-the-difference-between-var-let-and-const-b55b638529fc?source=collection_archive---------3-----------------------#2022-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1e3d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">来分享你的想法。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4ccb8e610791d1469b8f6e47f4617bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d1dkJz8pTySjlkWe"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo By <a class="ae ks" href="https://www.instagram.com/oskaryil/" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">Oskar Yildiz</strong></a></figcaption></figure><p id="745c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">嘿朋友们，</p><p id="121b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">很久以前我讲过<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/3-ways-javascript-hoisting-affects-your-code-a6a93626c600"><strong class="kw io">JavaScript提升影响你代码的3种方式</strong> </a> <strong class="kw io">。</strong>剧透警告:提升对用<code class="fe lq lr ls lt b">var</code>、<code class="fe lq lr ls lt b">let</code>和<code class="fe lq lr ls lt b">const </code>声明的变量有不同的影响。如果您想了解更多，请查看这篇文章。</p><p id="fe1e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在本文中，我想通过区分这三个关键词来进一步展开讨论。具体来说，我想回答以下几个问题:<strong class="kw io">有什么区别？什么时候应该使用它们？</strong></p><p id="0b5c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">最近，我在一个专业场合被问到这两个问题。虽然我提供了一个充分的答案，但我更愿意提供一个特别的、有见地的答案。既然我错过了机会，我现在就要帮你提供一个华丽的答案，当将来有人问你的时候。我保证你会是这个街区最聪明的人。</p><p id="c6bd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们开始吧。</p><h1 id="05a1" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">关键词:常量</h1><p id="362c" class="pw-post-body-paragraph ku kv in kw b kx mm jo kz la mn jr lc ld mo lf lg lh mp lj lk ll mq ln lo lp ig bi translated">真正的讨论更多的是关于<code class="fe lq lr ls lt b">let</code>和<code class="fe lq lr ls lt b">var</code>的，所以让我们快速解决<code class="fe lq lr ls lt b">const</code>的问题。</p><p id="b7e4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe lq lr ls lt b">const</code>用于<strong class="kw io">运行时</strong>值不变的变量。一个非常流行的例子是圆周率的值。</p><p id="ff31" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果我们想创建一个存储pi值的变量<code class="fe lq lr ls lt b">pi</code>，我们可以将它存储在一个const中。为什么？因为我们永远不会更新圆周率的值。</p><p id="ad60" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这里有一个例子:</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="e7ae" class="mv lv in lt b gy mw mx l my mz">function findPerimeterCircle(radius){<br/>    const pi = 3.14159265359;<br/>    return 2 * pi * radius;<br/>}</span><span id="5a36" class="mv lv in lt b gy na mx l my mz">console.log(findPerimeterCircle(5))</span></pre><p id="6637" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">再举个例子？</p><p id="5d03" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设我们正在创建一个棋盘。标准棋盘有64个方块。它们是8x8的。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="c611" class="mv lv in lt b gy mw mx l my mz">const numRows = 8;<br/>const numCols = 8;</span></pre><p id="5974" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在运行时，我们不会神奇地改变行数或列数。如果你真的想，在未来的更新中，你可以让董事会更大。然而，在运行时，这些值永远不会改变。</p><p id="17de" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">那真的很重要。</p><p id="8dbb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">const的另一个真正重要的属性是它有一个块级范围。</strong></p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="b865" class="mv lv in lt b gy mw mx l my mz">function findPerimeterCircle(radius){<br/>    const pi = 3.14159265359;<br/>    return 2 * pi * radius;<br/>   <strong class="lt io"> console.log(pi) //3.14159265359</strong><br/>}</span><span id="8f3f" class="mv lv in lt b gy na mx l my mz"><strong class="lt io">console.log(pi) //not defined</strong></span><span id="ec51" class="mv lv in lt b gy na mx l my mz">if(true){<br/>    const x = 4;<br/>    <strong class="lt io">console.log(x); //4</strong><br/>}<br/><strong class="lt io">console.log(x); //not defined</strong></span></pre><p id="d16d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在Javascript中，我们有全局作用域、函数作用域和块作用域。全局范围基本上意味着一个变量在任何地方都是可访问的。函数作用域意味着变量只能在函数内部访问。块级作用域意味着变量包含在最近的一组花括号中。</p><p id="7b84" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在上面的示例代码中，我们看到pi存在于函数中。功能之外，不存在。如果你尝试打印到控制台，它会说“pi未定义”。这是有道理的。如果你有Javascript的经验，你会知道<code class="fe lq lr ls lt b">let</code>、<code class="fe lq lr ls lt b">var</code>和<code class="fe lq lr ls lt b">const </code>都是这样反应的。</p><p id="cf51" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是让我们看看接下来的几行，这是一个if语句。</p><p id="32d5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">变量x包含在一组花括号中。而且由于是一个<code class="fe lq lr ls lt b">const</code>变量，变量x不存在于花括号之外。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="7ad6" class="mv lv in lt b gy mw mx l my mz">if(true){<br/>    var x = 4;<br/>    <strong class="lt io">console.log(x); //4</strong><br/>}<br/><strong class="lt io">console.log(x); //4</strong></span></pre><p id="1af4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果我们用var代替const，那么它实际上是可行的。如上图所示。因为我们使用的是const，所以它不起作用。</p><p id="ae3c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这也称为块级范围。同样，常量变量只存在于最接近的花括号中。</p><p id="5993" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是概要。如果你需要存储一个永远不会改变值的变量，并且有一个块级的作用域，const是你的好朋友。大多数情况下，您可能不会使用const。</p><h1 id="e9d6" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">关键词:让</h1><p id="781c" class="pw-post-body-paragraph ku kv in kw b kx mm jo kz la mn jr lc ld mo lf lg lh mp lj lk ll mq ln lo lp ig bi translated">希望你注意到了前面的部分。与<code class="fe lq lr ls lt b">const</code>类似，用<code class="fe lq lr ls lt b">let </code>声明的变量有一个块级范围。那是什么意思？跟我重复一遍:变量只存在于最接近的一组花括号中。</p><p id="92a1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">与<code class="fe lq lr ls lt b">const</code>不同，用<code class="fe lq lr ls lt b">let </code>声明的变量值可以在运行时改变。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="a40e" class="mv lv in lt b gy mw mx l my mz">let x = 2;<br/>x= 5;<br/>x= 200;</span></pre><p id="b51f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这完全合法。如果您有Java或C之类的其他语言的经验，您可能也会喜欢Javascript中类型转换的惊人之处。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="6709" class="mv lv in lt b gy mw mx l my mz">let x = 2; //number <br/>x = false; //boolean<br/>x = "Kyle DeGuzman" //string</span></pre><p id="e794" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上面的示例代码也是完全合法的！这是惊人的东西。</p><p id="f8bc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是，使用<code class="fe lq lr ls lt b">let </code>关键字，您不能“重新声明”变量。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="0cc5" class="mv lv in lt b gy mw mx l my mz">let x = 5;<br/>let x = 400;  //ERROR<br/>let x = "Kyle needs a French Bulldog"; //ERROR</span></pre><p id="72b8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是不允许的。它会告诉你x已经存在。这是<code class="fe lq lr ls lt b">let</code>和<code class="fe lq lr ls lt b">var</code>的主要区别。</p><p id="9d44" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果我们用<code class="fe lq lr ls lt b">var</code>代替<code class="fe lq lr ls lt b">let</code>，你会得到如下结果:</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="3746" class="mv lv in lt b gy mw mx l my mz">var x = 5;<br/>var x = 400;<br/>var x = "Kyle needs a French Bulldog";</span></pre><p id="cfc2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">…这很好。这会有用的。这将只是更新x的值。</p><p id="c57a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">以上是<code class="fe lq lr ls lt b">let</code>的概要。同样，<code class="fe lq lr ls lt b">let</code>有一个块级范围。您可以在运行后更改该值，但不能重新声明同一个变量。在提升方面也有不同，但是你可以在其他地方读到。</p><h1 id="8dbe" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">关键词:var</h1><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="3710" class="mv lv in lt b gy mw mx l my mz">var x = 5;<br/>var x = 400;<br/>var x = "Kyle needs a French Bulldog";</span></pre><p id="afb9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们知道这很好。</p><p id="57d8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您现在可能知道，与<code class="fe lq lr ls lt b">let </code>和<code class="fe lq lr ls lt b">const</code>不同，<code class="fe lq lr ls lt b">var </code>没有块级范围。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="8474" class="mv lv in lt b gy mw mx l my mz">if (true){<br/>   var x = 4;<br/>}<br/>console.log(x); //4</span></pre><p id="9a64" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是可行的。4将被打印到控制台。如果那是<code class="fe lq lr ls lt b">let </code>或<code class="fe lq lr ls lt b">const</code>，那就不行。它会说x是未定义的。</p><p id="b93a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">与<code class="fe lq lr ls lt b">let </code>和<code class="fe lq lr ls lt b">const</code>不同，<code class="fe lq lr ls lt b">var</code>有一个函数级的作用域。同样，这意味着变量存在于函数的任何地方。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="5ed0" class="mv lv in lt b gy mw mx l my mz">function add(){<br/>    var x  = 5;<br/>    console.log(x); //5<br/>}</span></pre><p id="3d0e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">以上，直截了当。5将被打印到控制台。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="c10b" class="mv lv in lt b gy mw mx l my mz">function add1(){<br/>    console.log(x); //undefined<br/>    var x  = 5; <br/>}<br/>function add2(){<br/>    console.log(x); //ERROR: x is not defined<br/>    let x  = 5; <br/>}</span></pre><p id="e3de" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这个呢？在给<code class="fe lq lr ls lt b">x</code>赋值之前，看看我们是如何将<code class="fe lq lr ls lt b">x</code>打印到控制台的。</p><p id="2902" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果我们使用<code class="fe lq lr ls lt b">var</code>，变量x将在函数中处处存在<strong class="kw io">。这也意味着变量在声明或初始化之前就已经存在了！所以当add1()说‘undefined’时，这意味着“是的，变量存在，但是它还没有赋值”。</strong></p><p id="e29c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">相比之下，使用<code class="fe lq lr ls lt b">let</code>变量，变量x将在声明或初始化之后开始存在。因此，当add2()呈现错误时，这意味着“变量不存在。我们不知道你在说什么。”</p><p id="c9ce" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这里是要点:如果您需要函数级作用域，var是很好的选择。如果你想一遍又一遍地重新声明变量，var是很棒的。</p><p id="9e60" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是，您真的需要var来做到这一点吗？</p><h1 id="6d6a" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">let vs var</h1><p id="9bc0" class="pw-post-body-paragraph ku kv in kw b kx mm jo kz la mn jr lc ld mo lf lg lh mp lj lk ll mq ln lo lp ig bi translated">如果你真的需要一个函数级的作用域，那么在函数的顶部声明一个<code class="fe lq lr ls lt b">let</code>变量。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="cdb3" class="mv lv in lt b gy mw mx l my mz">function add(){<br/>    let x=5; <br/>    console.log(x)<br/>}</span></pre><p id="6a4b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在你有了一个函数级变量。</p><p id="2d82" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">不要一遍又一遍地声明同一个变量，而是选择一个新的变量名或更新变量值。</p><pre class="kd ke kf kg gt mr lt ms mt aw mu bi"><span id="c790" class="mv lv in lt b gy mw mx l my mz">let x = 5;<br/>let x = 6; //ERROR<br/>let x = 7; //ERROR</span></pre><p id="83d6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">首先，没有其他语言允许这样做。</p><p id="bbb1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">没有其他语言允许你在声明变量之前使用它们。可以说，如果在声明变量之前就使用它们，看起来很糟糕。这肯定会影响代码的可读性，尤其是当别人要查看它的时候。</p><p id="ea34" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果你看，很多人远离<code class="fe lq lr ls lt b">var</code>。人们认为<code class="fe lq lr ls lt b">var</code>是杂乱和不必要的。随着ES6和let关键字的引入，很多人会告诉新人只需坚持<code class="fe lq lr ls lt b">let</code>。在很大程度上，我同意。</p><p id="db47" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了这篇文章，我看了许多不同的意见和论点。普遍的共识是没有人应该使用<code class="fe lq lr ls lt b">var</code>。几乎没有什么情况下，你应该使用<code class="fe lq lr ls lt b">var </code>而不是<code class="fe lq lr ls lt b">let</code>。</p><p id="e6a2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我会说，有一个论点我可以提供一盎司的支持。一定要读一读。</p><div class="nb nc gp gr nd ne"><a href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md#var-and-let" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">第二版getify/You-don-Know-JS/APA . MD</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">现在，我们将围绕本书正文中涵盖的许多主题探讨一些细微差别和边缘。这个…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns km ne"/></div></div></a></div><p id="01a6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在这个md文件中，作者为<code class="fe lq lr ls lt b">var</code>做了一个公平的案例。他们的论点是语义学。我真的鼓励你阅读部分<strong class="kw io"> var和let。</strong>很有启发。</p><p id="fff6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">其中一句关键的名言是:</p><blockquote class="nt"><p id="1445" class="nu nv in bd nw nx ny nz oa ob oc lp dk translated">如果你在任何地方都使用<code class="fe lq lr ls lt b">let</code>，那么哪些声明被设计成本地化的，哪些声明打算在整个函数中使用就不那么明显了。</p></blockquote><p id="edec" class="pw-post-body-paragraph ku kv in kw b kx od jo kz la oe jr lc ld of lf lg lh og lj lk ll oh ln lo lp ig bi translated">所以，再一次，这个想法是通过有策略地选择你使用的关键字来为你的代码提供语义。</p><p id="f7a4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我喜欢这样。</p><p id="d92d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是我的问题是:如果普遍的共识或者流行的观点是<code class="fe lq lr ls lt b">var </code>是无用的，大多数开发者可能不会理解你选择使用<code class="fe lq lr ls lt b">var </code>和<code class="fe lq lr ls lt b">let</code>背后的语义。他们可能不会再考虑你两个都用的事实。</p><p id="dae3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">因此，虽然我认为它很聪明，但我不认为它会有效。如果你选择赋予它那个语义，只有你会知道它。其他人都不知道这件事。</p><p id="680d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但当然，我的观点是建立在大多数人认为<code class="fe lq lr ls lt b">var </code>没用的前提下。你同意前提为真吗？你个人对什么时候用<code class="fe lq lr ls lt b">var</code>和<code class="fe lq lr ls lt b">let</code>有偏好吗？</p><p id="6377" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果面试官问你什么时候会使用其中一个，你会怎么回答？我真的很好奇。</p></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><p id="094d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这就是我对<code class="fe lq lr ls lt b">const</code>、<code class="fe lq lr ls lt b">var</code>和<code class="fe lq lr ls lt b">let</code>的看法。</p><p id="ea87" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我对别人说的话非常感兴趣。</p><p id="3611" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">感谢阅读。</p><p id="e1fa" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="op">更多内容请看</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="op">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="op">免费周报</em> </strong> </a> <em class="op">。关注我们</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="op">Twitter</em></strong></a><em class="op">和</em><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="op">LinkedIn</em></strong></a><em class="op">。加入我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="op">社区不和谐</em> </strong> </a> <em class="op">。</em></strong></a></p></div></div>    
</body>
</html>