<html>
<head>
<title>Understand Shallow and Deep Copies in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的浅层和深层拷贝</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-shallow-and-deep-copies-in-javascript-7f8d7d340d48?source=collection_archive---------8-----------------------#2022-04-19">https://javascript.plainenglish.io/understand-shallow-and-deep-copies-in-javascript-7f8d7d340d48?source=collection_archive---------8-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ccf9f0598dcce6db67b81d30d1283d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A08-1sb_xKLgYmgmefw4BQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by <a class="ae kc" href="https://stock.adobe.com/contributor/201245900/patryk-kosmider?load_type=author&amp;prev_url=detail" rel="noopener ugc nofollow" target="_blank">Patryk Kosmider</a> viaAdobe Stock Photos</figcaption></figure><p id="8e1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript中并非所有副本都是相同的。当新开发人员遇到这种情况时，他们可能会感到困惑。当你在JavaScript中拷贝一个变量时，它被分为浅层拷贝和深层拷贝。不知道这两者之间的区别或者它们是如何产生的会导致一些混乱的行为。当我第一次开始时，它是许多令人挠头的错误的来源。希望这篇文章能让你避免犯同样的错误。首先，我将介绍一些复制变量的基本示例。</p><p id="7b41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举个例子:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4032" class="lk ll iq lg b gy lm ln l lo lp">let apple = "apple";<br/>let pear = apple</span><span id="623d" class="lk ll iq lg b gy lq ln l lo lp">pear = "pear"</span><span id="a077" class="lk ll iq lg b gy lq ln l lo lp">console.log("apple: ", apple);<br/>console.log("pear: ", pear);</span></pre><p id="2fce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您猜测apple的输出是“apple ”, pear是“pear ”,那么您将是正确的。现在我们来看另一个。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5f76" class="lk ll iq lg b gy lm ln l lo lp">const fruitStand = {<br/> apples: 3<br/>}</span><span id="cc29" class="lk ll iq lg b gy lq ln l lo lp">const fruitStandCopy = fruitStand;</span><span id="1c16" class="lk ll iq lg b gy lq ln l lo lp">fruitStandCopy.apples = 7</span><span id="c8ed" class="lk ll iq lg b gy lq ln l lo lp">console.log("Fruit Stand: ", fruitStand.apples);<br/>console.log("Fruit Stand Copy: ", fruitStandCopy.apples);</span></pre><p id="1213" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能认为<code class="fe lr ls lt lg b">fruitStand.apples</code>的输出是3，而<code class="fe lr ls lt lg b">fruitStandCopy.apples</code>的输出是7。然而，<code class="fe lr ls lt lg b">fruitStand.apples</code>和<code class="fe lr ls lt lg b">fruitStandCopy.apples</code>都等于7。这个行为是JavaScript如何处理深层和浅层拷贝的一个例子。</p><h2 id="aef0" class="lk ll iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">记忆</h2><p id="aebf" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在我们深入研究深层和浅层拷贝之前，我们需要了解内存是如何工作的。当你在JavaScript中创建一个变量时，它必须存在于某个地方。它不能只是文件中的一行，它需要被记录下来，以防我们以后要再次引用它。每次你创建一个新变量，它都会在内存中被分配一个空间。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="397d" class="lk ll iq lg b gy lm ln l lo lp">const variable1 = "Hello" // memory address: 0x001<br/>const variable2 = 100     // memory address: 0x002</span></pre><p id="de6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的两个变量都有单独的空间来存储值。当您稍后在应用程序中引用变量时，您引用的不是创建变量的行，而是存储变量值的内存地址。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2f56" class="lk ll iq lg b gy lm ln l lo lp">const variable1 = "Hello" // points to memory address: 0x001<br/>const variable2 = 100     // points to memory address: 0x002</span><span id="ce16" class="lk ll iq lg b gy lq ln l lo lp">console.log(variable1)</span></pre><p id="4b0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，当我们在<code class="fe lr ls lt lg b">console.log</code>中引用<code class="fe lr ls lt lg b">variable1</code>时，JavaScript不会向上3行到variable1被创建的地方并检查值。它要去与变量1相关的内存地址。</p><h2 id="4a0c" class="lk ll iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">原语与引用</h2><p id="46db" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">就深层和浅层复制而言，您可以创建两种变量。第一个是原语，基本的原语类型有字符串、数字、布尔、未定义和空。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9519" class="lk ll iq lg b gy lm ln l lo lp">const name = "Jesse"<br/>const age = 30</span></pre><p id="de48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是引用变量，也称为对象。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cb0a" class="lk ll iq lg b gy lm ln l lo lp">const person = {<br/>  name: "Jesse",<br/>  age: 30<br/>}</span></pre><p id="27dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在浅拷贝和深拷贝的讨论中区分这两者的原因是，当你拷贝一个原始值时，一个新的内存地址被分配给它。当引用变量被复制时，新的变量将指向内存中被复制的变量空间。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ff3a" class="lk ll iq lg b gy lm ln l lo lp">// primitive value<br/>const name = "Jesse"               // memory address: 0x001</span><span id="35f4" class="lk ll iq lg b gy lq ln l lo lp">// reference value               <br/>const person = { name: "Jesse" }   // memory address: 0x002</span><span id="491d" class="lk ll iq lg b gy lq ln l lo lp">// primitive copy points to new memory address<br/>const nameCopy = name              // memory address: 0x003</span><span id="05b6" class="lk ll iq lg b gy lq ln l lo lp">// reference copy points to orginial memory address<br/>const personCopy = person          // memory address: 0x002</span></pre><h2 id="393c" class="lk ll iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">浅显的副本</h2><p id="9b65" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">让我们回到这个例子</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3c60" class="lk ll iq lg b gy lm ln l lo lp">const fruitStand = {<br/> apples: 3<br/>}</span><span id="fdd9" class="lk ll iq lg b gy lq ln l lo lp">const fruitStandCopy = fruitStand;</span><span id="3e69" class="lk ll iq lg b gy lq ln l lo lp">fruitStandCopy.apples = 7</span><span id="5e13" class="lk ll iq lg b gy lq ln l lo lp">console.log("Fruit Stand: ", fruitStand.apples);<br/>console.log("Fruit Stand Copy: ", fruitStandCopy.apples);</span></pre><p id="0730" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个浅拷贝的例子。浅表副本指向与原始副本相同的内存空间。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a44e" class="lk ll iq lg b gy lm ln l lo lp">const fruitStand = {               // memory address: 0x001<br/> apples: 3<br/>}</span><span id="74e3" class="lk ll iq lg b gy lq ln l lo lp">fruitStandCopy = fruitStand // memory address: 0x001</span><span id="d653" class="lk ll iq lg b gy lq ln l lo lp">fruitStandCopy.apples = 7</span></pre><p id="6df3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有两个变量，但都指向内存中的同一个位置。这就是为什么<code class="fe lr ls lt lg b">fruitStand.apples</code>和<code class="fe lr ls lt lg b">fruitStandCopy.apples</code>在更新其中一个变量后，值是一样的。当我们改变这个值时，我们改变了存储在这个变量的内存地址中的值。因为两个变量指向同一个地方，所以变化会反映在两者中。</p><p id="3a5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所做的并没有什么本质上的错误。这就是JavaScript处理复制对象的方式。</p><h2 id="68f8" class="lk ll iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">深层副本</h2><p id="209d" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">深层副本是不与源变量共享相同引用的副本。这样做的意义在于，一个变量中的更新不会反映在其他变量中。</p><p id="a004" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在前面的例子中，我们看到原始变量在被复制时会获得新的内存地址。这在技术上是深度复制的一个例子，然而，术语深度复制通常是为复制的引用变量保留的。</p><p id="cc16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，当我们复制一个引用变量时，我们不会自动得到这种行为。因为无法知道一个对象可能有多大，所以默认情况下JavaScript浅层复制对象更有效。</p><h2 id="c8bf" class="lk ll iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">创建深层副本</h2><p id="997d" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">如果您需要创建引用变量的深层副本，可以使用一些技术。</p><p id="c7eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您需要复制的对象只有一层深度，我建议使用spread操作符进行深度复制。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="555f" class="lk ll iq lg b gy lm ln l lo lp">const fruitStand = {<br/> apples: 3<br/>}<br/>const fruitStandCopy = {...fruitStand};</span><span id="b93d" class="lk ll iq lg b gy lq ln l lo lp">fruitStandCopy.apples = 7</span><span id="33c8" class="lk ll iq lg b gy lq ln l lo lp">console.log(fruitStand.apples)      // 3<br/>console.log(fruitStandCopy.apples)  // 7</span></pre><p id="7938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于比这更复杂的情况，可以结合使用JSON.parse()和JSON.stringify()。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a5fe" class="lk ll iq lg b gy lm ln l lo lp">const fruitStand = {<br/> apples: 3<br/>}</span><span id="f15f" class="lk ll iq lg b gy lq ln l lo lp">const fruitStandCopy = JSON.parse(JSON.stringify(fruitStand))</span><span id="4d48" class="lk ll iq lg b gy lq ln l lo lp">fruitStandCopy.apples = 7</span><span id="2497" class="lk ll iq lg b gy lq ln l lo lp">console.log(fruitStand.apples)      // 3<br/>console.log(fruitStandCopy.apples)  // 7</span></pre><p id="3b48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种技术很危险，因为原始对象内部的函数不会被复制。</p><p id="5391" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以使用lodash这样的第三方库进行深度复制。如果你在一个大的应用程序中工作，有可能已经为其他方法安装了它。</p><h2 id="97cd" class="lk ll iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">包扎</h2><p id="d997" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我希望这篇文章对那些对用JavaScript复制变量感到困惑的人有所帮助。看到摆在你面前的行为可能会很奇怪。随着时间的推移，这将成为您的第二天性，您将能够避免浅拷贝和深拷贝对代码库造成的棘手错误。根据我自己的经验，我知道这些可能是最难调试的，你越快记住它们，从长远来看你就越好。</p><p id="0e3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mq">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mq">plain English . io</em></strong></a><em class="mq">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mq">免费周报</em> </strong> </a> <em class="mq">。关注我们关于</em><a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mq">Twitter</em></strong></a><em class="mq">和</em><a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mq">LinkedIn</em></strong></a><em class="mq">。加入我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mq">社区不和谐</em> </strong> </a> <em class="mq">。</em></p></div></div>    
</body>
</html>