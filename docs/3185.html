<html>
<head>
<title>A Simple &amp; Powerful Router Based on the Modern API for Client-side Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于现代客户端路由API的简单而强大的路由器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-simple-and-powerful-router-based-on-the-modern-api-for-client-side-routing-b40e9f6eb5bd?source=collection_archive---------4-----------------------#2022-08-07">https://javascript.plainenglish.io/a-simple-and-powerful-router-based-on-the-modern-api-for-client-side-routing-b40e9f6eb5bd?source=collection_archive---------4-----------------------#2022-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d7cf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们探索一下直接开发单页面应用程序的最新API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f5c213248702ed6cddb1b185a43312c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7wtCy7abuA5LZrA-VWN-w.png"/></div></div></figure><p id="cb48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一般来说，将用户界面做成单页应用程序(SPA)比做成传统的多页应用程序更容易。当应用程序内容不必被web搜索引擎索引时(例如在机构内部网应用程序或公共互联网银行站点中)，开发服务器端呈现纯粹是浪费时间。</p><p id="4bc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在传统的web应用程序中，每次点击链接时，浏览器都会向服务器请求一个新的HTML页面。相比之下，spa只加载一个HTML页面。服务器为SPA处理的任何URL发送完全相同的HTML页面。例如，在本文的示例SPA中，服务器为具有三个不同URL路径的请求返回完全相同的HTML、JavasScript和CSS代码<a class="ae ln" href="https://navigationapi.onrender.com/defaultScroll/" rel="noopener ugc nofollow" target="_blank"> /defaultScroll/ </a>、<a class="ae ln" href="https://navigationapi.onrender.com/defaultScroll/edit/wbr" rel="noopener ugc nofollow" target="_blank"> /defaultScroll/edit/wbr </a>和<a class="ae ln" href="https://navigationapi.onrender.com/defaultScroll/edit/" rel="noopener ugc nofollow" target="_blank"> /defaultScroll/edit/ </a>。</p><p id="195c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当加载SPA代码时，对当前URL的更改会被其路由器模块截获。当用户单击链接时，路由器会在地址栏中显示目标URL，将目标URL保存在浏览器历史记录中，并调用显示目标URL内容的函数。该函数通常从服务器加载一些数据，将数据包装在HTML元素中，将它们插入到DOM中，并隐藏以前可见的元素。</p><p id="fa06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按钮点击事件也可以由路由器处理。但是链接和按钮之间有一个重要的区别。由<code class="fe lo lp lq lr b">&lt;a&gt;</code>标签形成的链接可以在新窗口中打开，从另一个网络应用程序引用，或者加入书签。链接的一个新颖的优点是，要被拦截，它们不需要点击事件监听器。</p><p id="8d6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现代导航API提供了一个简单的机制来拦截任何即将到来的导航。可被拦截的导航事件最常见的触发器是链接、表单、<em class="ls">后退</em>或<em class="ls">前进</em>浏览器按钮、<code class="fe lo lp lq lr b">location.href</code>或<code class="fe lo lp lq lr b">location.assign()</code>。</p><p id="55c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">导航API在<a class="ae ln" href="https://developer.chrome.com/docs/web-platform/navigation-api/" rel="noopener ugc nofollow" target="_blank">现代客户端路由:导航API </a>中有描述。这篇文章过于详细和不完整——它描述了通常不相关的细节，但没有实际的例子。在这篇文章中，我跳过了不可替代但很少需要的特性，旨在回顾导航API最常用的特性。</p><h2 id="604b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">样本SPA</h2><p id="d40b" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在这篇文章中，我想探索导航API最实用的特性，尤其是滚动状态管理。为此，我使用了一个带有两个视图的示例SPA，重用了我之前的文章中的示例数据。列表视图列出了HTML标签的描述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/af27d875d17a902a08c501c48402e0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6ftHZ2SmMOlpLCt9"/></div></div></figure><p id="3f07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">表格中的每一行都是引用相应编辑视图的链接。当我单击标签名称时，我可以看到并修改它的完整描述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/8ed534a08f44e2451556b6f7d9daa6df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xuhhFh-gviiOkcEN"/></div></div></figure><p id="99b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在编辑视图中，我可以通过点击<em class="ls">返回列表</em>按钮返回列表。如果编辑视图是从列表视图打开的，我也可以使用浏览器的<em class="ls">后退</em>按钮。在任一视图中，我还可以单击一个外部链接<em class="ls"> API </em>。然后，我可以通过单击浏览器的<em class="ls">后退</em>和<em class="ls">前进</em>按钮在已访问的视图和外部页面之间导航。</p><p id="15ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">样本SPA中与路由相关的代码非常简单。<em class="ls"> main.js </em>注册三个路由(列表视图、编辑视图、空编辑视图)并启动路由器。为了简化代码，我直接以正则表达式的形式使用路由。正则表达式允许使用它们的捕获组作为回调的参数。在示例SPA中，编辑视图需要参数。</p><pre class="kg kh ki kj gt ms lr mt mu aw mv bi"><span id="e41c" class="lt lu iq lr b gy mw mx l my mz">// main.js<br/>import { renderList } from '/js/views/list.js';<br/>import { renderEdit, renderNew } from '/js/views/edit.js';<br/>import { addRoute, start } from './router.js';</span><span id="eb85" class="lt lu iq lr b gy na mx l my mz"><strong class="lr ir">addRoute(/^$/, renderList);</strong></span><span id="f721" class="lt lu iq lr b gy na mx l my mz"><strong class="lr ir">addRoute(/^edit\/([a-z]+)$/, id =&gt; renderEdit(id));</strong></span><span id="7a69" class="lt lu iq lr b gy na mx l my mz"><strong class="lr ir">addRoute(/^edit(\/)?$/, renderNew);</strong></span><span id="8a6f" class="lt lu iq lr b gy na mx l my mz"><strong class="lr ir">start();</strong></span></pre><p id="ba92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">路由器的代码也一样简单。</p><pre class="kg kh ki kj gt ms lr mt mu aw mv bi"><span id="bdd0" class="lt lu iq lr b gy mw mx l my mz">// router.js<br/>const handlers = [];</span><span id="0810" class="lt lu iq lr b gy na mx l my mz">export function addRoute(route, callback) {<br/>    handlers.unshift({ route, callback });<br/>}</span><span id="9a18" class="lt lu iq lr b gy na mx l my mz"><strong class="lr ir">export function start() {<br/>    navigation.addEventListener('navigate', onNavigate);<br/>    location.assign(location.href);<br/>}</strong></span><span id="c436" class="lt lu iq lr b gy na mx l my mz"><strong class="lr ir">function onNavigate(e) {<br/>    const callback = findHandler(e.destination.url);</strong></span><span id="16c8" class="lt lu iq lr b gy na mx l my mz"><strong class="lr ir">    if (callback) {<br/>        e.intercept({<br/>            handler() {<br/>                return callback();<br/>            }<br/>        });<br/>    }<br/>}</strong></span><span id="3e52" class="lt lu iq lr b gy na mx l my mz">function argumentsInUrl(route, path) {<br/>    return route.exec(path).slice(1);<br/>}</span><span id="419c" class="lt lu iq lr b gy na mx l my mz">function findHandler(url) {<br/>    const path = url.replace(document.baseURI, '').split('?')[0]; <br/>    const handler = handlers.find(o =&gt; o.route.test(path));<br/>    if (handler)<br/>        return () =&gt;   handler.callback(...argumentsInUrl(handler.route, path));<br/>}</span></pre><p id="32e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">addRoute()</code>保存URL路径以及处理其渲染的函数。为了精确地处理滚动位置，处理程序必须返回仅在请求的视图被插入DOM后才解析的承诺。</p><p id="9034" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">start()</code>首先在新的<code class="fe lo lp lq lr b">navigation</code>对象上注册一个事件监听器<code class="fe lo lp lq lr b">onNavigate()</code>，该对象在任何即将到来的导航之前触发一个<code class="fe lo lp lq lr b">navigate</code>事件。然后，呈现第一个视图<code class="fe lo lp lq lr b">start()</code>用加载SPA的URL触发一个<code class="fe lo lp lq lr b">navigate</code>事件。</p><p id="33f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">onNavigate()</code>监听器为目标URL查找一个注册的处理程序，并与<code class="fe lo lp lq lr b">intercept()</code>一起执行，后者是<code class="fe lo lp lq lr b">preventDefault()</code>的专用替代。需要调用<code class="fe lo lp lq lr b">intercept()</code>来指示浏览器不要向网络请求目的URL。如果没有找到与目标URL匹配的处理程序，通常当点击外部链接时，<code class="fe lo lp lq lr b">onNavigate()</code>不会调用<code class="fe lo lp lq lr b">intercept()</code> <em class="ls"> </em>，浏览器会从网络上加载目标URL。</p><p id="1fe1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">路由器拦截由所有可能的触发器引起的导航。除了添加路由处理器的模块之外，任何应用程序模块都不需要知道路由器。</p><h1 id="9641" class="nb lu iq bd lv nc nd ne ly nf ng nh mb jw ni jx me jz nj ka mh kc nk kd mk nl bi translated">基于导航API的路由器的高效滚动状态管理</h1><p id="9a15" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">正确的滚动位置是视图中用户友好导航的一个重要方面。当用户点击<em class="ls">后退</em>按钮时，他们希望返回到先前访问过的视图中的相同位置。相反，当用户点击一个链接时，他们不想停留在页面的中间。</p><p id="d072" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了探索新的API如何处理滚动，我让两个视图都溢出窗口。列表视图有一个滚动条，因为带有标签的表格足够长。为了在任何标签的编辑视图中显示滚动条，我将其最小高度设置为窗口高度的200%。因此，即使内容适合窗口，也会显示垂直滚动条。你可以在上面的截图中看到。</p><h2 id="d848" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">页面重新加载时，滚动位置会自动恢复</h2><p id="657f" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">为了证明这一点，我滚动到带有标签的表格的底部。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/3e86427d392c08e44dd818ee741d7222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I-3zAA6cda5Yu3_u"/></div></div></figure><p id="e88b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我点击浏览器的<em class="ls">重新加载</em>按钮。页面从网络重新加载，列表视图重新呈现，然后被浏览器滚动到底部，就像上面的截图一样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/59975d65e8e718897e800c2c03e71765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mf2I_fvFUi7sLnn6"/></div></div></figure><h2 id="8b2d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">单击链接时，页面不会滚动到顶部</h2><p id="9c07" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">现在让我们看看导航API的一个限制。</p><p id="4fa6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我再次移动到列表视图的底部。然后我点击一个标签。带有所单击标签的编辑视图会滚动到页面底部。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/c1c54b2888dc8b204fac29637fac5281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qQv1pLxbCRYtoRD6"/></div></div></figure><p id="4bf3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，导航API不会在单击链接时自动将滚动位置重置到页面顶部。但是解决问题很容易。重置滚动位置的代码很简单。您可以在下面我的下一版本示例路由器中看到额外的三行代码。</p><h2 id="2f3b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk ml bi translated">在浏览浏览器历史记录的过程中，滚动位置得到恢复</h2><p id="3c39" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">单击链接引起的导航和浏览以前访问过的URL的历史记录之间有一个重要的区别。如果点击浏览器的<em class="ls">后退</em>或<em class="ls">前进</em>按钮，浏览器恢复到之前访问页面的滚动位置。因此，如果用户界面中的一个按钮，例如<em class="ls">返回列表</em>，指向先前访问的页面，则可以使用浏览器历史，以便用户返回页面上完全相同的位置。这种思想在编辑视图中的<em class="ls">返回列表</em>按钮的点击监听器中实现。</p><pre class="kg kh ki kj gt ms lr mt mu aw mv bi"><span id="19a0" class="lt lu iq lr b gy mw mx l my mz">listBtn.addEventListener("click", () =&gt; {<br/>    <strong class="lr ir">if (navigation.entries()[navigation.currentEntry.index - 1]?.url === document.baseURI) {<br/>        navigation.back();</strong><br/><strong class="lr ir">    } else { <br/>        location.assign("");<br/>    }</strong><br/>});</span></pre><p id="59be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">方法<code class="fe lo lp lq lr b">navigation.entries()</code>返回用户打开页面后浏览过的URL。<code class="fe lo lp lq lr b">navigation.currentEntry.index</code>返回当前URL在<code class="fe lo lp lq lr b">navigation.entries()</code>返回的数组中的索引。当点击<em class="ls">返回列表</em>按钮时，监听器检查历史中的前一个条目是否是列表视图的URL。如果是，监听器通过指示浏览器返回到历史中的前一个条目来触发一个<code class="fe lo lp lq lr b">navigate</code>事件。或者，如果通过在新窗口中打开链接来打开编辑视图，则历史中没有列表视图。然后监听器通过用列表视图的相对URL调用<code class="fe lo lp lq lr b">location.assign()</code>来触发<code class="fe lo lp lq lr b">navigate</code>事件。</p><p id="674c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了说明代码是如何工作的，我从上面的截图开始，继续对<em class="ls"> wbr </em>标签进行不正确的滚动描述。如果我点击<em class="ls">返回列表</em>按钮或<em class="ls">返回</em>按钮，就会呈现正确滚动的列表视图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/0e12dcb75ca1fefbcc1e2e1425c84507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hyHpGqCm-YJwLAEm"/></div></div></figure><p id="47b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例页面很慢，因为它是免费的。但是对于这篇文章来说，这真的很棒，因为您可以观察到浏览器延迟恢复滚动位置，直到<code class="fe lo lp lq lr b">intercept()</code>从路由处理器收到的承诺解决。</p><h1 id="6284" class="nb lu iq bd lv nc nd ne ly nf ng nh mb jw ni jx me jz nj ka mh kc nk kd mk nl bi translated">路由器完美地重置和恢复滚动位置</h1><p id="8bc4" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">因此，使用导航API的开发人员需要提供代码，在单击链接后创建的视图中重置滚动位置。<code class="fe lo lp lq lr b">navigation</code>事件的<code class="fe lo lp lq lr b">navigationType</code>属性允许区分点击链接和浏览历史。当导航由链接引起时<code class="fe lo lp lq lr b">navigationType</code>等于<code class="fe lo lp lq lr b">push</code>。当浏览器在历史中后退或前进时，<code class="fe lo lp lq lr b">navigationType</code>等于<code class="fe lo lp lq lr b">traverse</code>。</p><p id="8413" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在示例SPA <a class="ae ln" href="https://navigationapi.onrender.com/restoreScroll/" rel="noopener ugc nofollow" target="_blank">的增强版本中，https://navigationapi.onrender.com/restoreScroll/</a><code class="fe lo lp lq lr b">onNavigate()</code>监听器等待路由处理程序返回，然后检查滚动位置是否必须归零。</p><pre class="kg kh ki kj gt ms lr mt mu aw mv bi"><span id="9e8e" class="lt lu iq lr b gy mw mx l my mz">function onNavigate(e) {<br/>    const callback = findHandler(e.destination.url);</span><span id="56e1" class="lt lu iq lr b gy na mx l my mz">if (callback) {<br/>        e.intercept({<br/>            async handler() {<br/>                await callback();<br/>                <strong class="lr ir">if (e.navigationType === 'push')<br/>                    document.scrollingElement.scrollTop = 0</strong><br/>            }<br/>        });<br/>    }<br/>}</span></pre><h1 id="c1ee" class="nb lu iq bd lv nc nd ne ly nf ng nh mb jw ni jx me jz nj ka mh kc nk kd mk nl bi translated">结论</h1><p id="7e65" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">从我的样本SPA中，我得出了几个实用的结论。与基于历史API的传统路由器相比，现代路由器更易于使用，因为:</p><ul class=""><li id="2f42" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">除了注册路由的主模块，其他模块都不需要导入路由器。路由器不需要有两个以上的公共方法— <code class="fe lo lp lq lr b">addRoute()</code>和<code class="fe lo lp lq lr b">start()</code>。路由器拦截所有导航触发，包括<code class="fe lo lp lq lr b">location.href</code>或<code class="fe lo lp lq lr b">location.assign()</code>，因此<code class="fe lo lp lq lr b"> router.navigate()</code>没有意义。</li><li id="c15c" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">如果链接上没有点击事件监听器，SPAs的代码会更短。</li><li id="efd9" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">无需任何额外的代码，在历史遍历和页面重新加载过程中，滚动位置会可靠地恢复。默认行为很容易修改。</li></ul></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="a700" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例代码可以从<a class="ae ln" href="https://github.com/marianc000/navigationAPI" rel="noopener ugc nofollow" target="_blank">https://github.com/marianc000/navigationAPI</a>下载或者在示例页面<a class="ae ln" href="https://navigationapi.onrender.com/" rel="noopener ugc nofollow" target="_blank">https://navigationapi.onrender.com/</a>查阅</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="5a84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ls">更多内容看</em> <a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ls">说白了。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。关注我们关于</em> <a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ls">推特</em> </strong> </a>，<a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ls">领英</em> </strong> </a> <em class="ls">，以及</em> <a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ls">不和</em> </strong> </a> <em class="ls">。</em></strong></a></p></div></div>    
</body>
</html>