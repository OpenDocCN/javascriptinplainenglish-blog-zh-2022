<html>
<head>
<title>How to Read Files via JavaScript in the Browser — Reading Files with Client-Side JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在浏览器中通过JavaScript读取文件—使用客户端JavaScript读取文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reading-files-via-javascript-in-the-browser-part-2-reading-files-with-client-side-javascript-98a359392e8e?source=collection_archive---------7-----------------------#2022-02-01">https://javascript.plainenglish.io/reading-files-via-javascript-in-the-browser-part-2-reading-files-with-client-side-javascript-98a359392e8e?source=collection_archive---------7-----------------------#2022-02-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b39d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:如何通过客户端JavaScript让<em class="kc">读取</em>文件。</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/a2a52391922385342ef77b39db30266c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-4Sup9rpxmhkoXkt"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6979" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><a class="ae kt" href="https://medium.com/@chad.campbell/reading-files-via-javascript-in-the-browser-part-1-choosing-files-to-read-af34a6daa63f" rel="noopener"><a class="ae kt" href="https://medium.com/@chad.campbell/reading-files-via-javascript-in-the-browser-introduction-ad40af01a1dd" rel="noopener">通过JavaScript读取文件系列</a>的第1部分</a>向您展示了如何从用户那里获取文件进行读取。本文将继续这个系列，并向您展示如何通过客户端JavaScript读取文件。本文将首先向您展示如何通过文件类型获取关于文件的信息。从那里，焦点将转移到读取文件的内容。首先要决定使用两个接口中的哪一个来读取文件:FileReader或FileReaderSync。最后，本文将基于这一决定，向您展示如何读取文件的内容。我们开始吧。</p><h1 id="2687" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">获取文件类型的文件详细信息</h1><p id="b0fb" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated"><a class="ae kt" href="https://medium.com/@chad.campbell/reading-files-via-javascript-in-the-browser-part-1-choosing-files-to-read-af34a6daa63f" rel="noopener">第1部分</a>介绍了files属性，但当时没有解释。您可能已经猜到这个属性代表用户选择的文件。这些文件以文件对象列表的形式出现。每个对象包括两种信息:1)关于文件的元数据和2)文件内容的句柄。本文稍后将向您展示如何使用该句柄。目前，下表显示了文件类型中可用的元数据。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/d3629cd4e549760feb5a7a08edded5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*bebj1E04vhiRHMTR1-S2ZA.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">table 2.1</figcaption></figure><p id="c0fd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">表2.1显示了文件对象的表面属性。这张表可供参考。不过，查看这些属性的另一个有用的方法是通过代码。使用这些属性的代码示例如下所示:</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi mp"><img src="../Images/0461ac1147ccd62550b9456a9fd72e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jw7Ewut1QZHtfaPC6MriOA.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">sample 2.1</figcaption></figure><p id="93b8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">示例2.1重新混合了第1部分中的代码，并展示了如何使用File对象的属性。第10行使用文件的元数据创建了一条消息。该消息打印到控制台的第11行。如果您要从包含的<a class="ae kt" href="https://github.com/ecofic/article-reading-files-via-javascript" rel="noopener ugc nofollow" target="_blank">源代码库</a>中选择receipt-01.png，您会看到类似下面的内容:</p><pre class="ke kf kg kh gt mq mr ms mt aw mu bi"><span id="c267" class="mv ls in mr b gy mw mx l my mz">File 'receipt-01.png' is a image/png with 4024 bytes and was last modified on 1637857591663</span></pre><p id="bddb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上面的结果显示了正在使用的文件对象的属性。它能完成任务。然而，它不是很漂亮。您可能会想到，通过以下方式可以改善结果:</p><ul class=""><li id="293d" class="na nb in kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">格式化文件的大小。特定于文化的格式会很好。使用4 KB这样的上下文格式会更好。</li><li id="8252" class="na nb in kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">将最后修改的值格式化为本地化的日期/时间。</li></ul><p id="ab53" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这些增强超出了本文的范围。然而，本节确实向您展示了可以从文件中获得的元数据。也许更有价值的是文件本身的内容。这个对话从FileReader和FileReaderSync接口开始。</p><h1 id="33a9" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">比较FileReader和FileReaderSync</h1><p id="5af2" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">JavaScript有两个读取文件的接口:FileReader和FileReaderSync。FileReader接口允许您异步读取文件<em class="lq"/>。而FileReaderSync接口让你同步读取文件<em class="lq"/>。本文将使用FileReader接口。做出这一决定的两个原因是基于a)读取文件的位置和b)可用的API。</p><h2 id="5c5a" class="mv ls in bd lt no np dn lx nq nr dp mb ld ns nt md lh nu nv mf ll nw nx mh ny bi translated">标识文件的读取位置</h2><p id="d05d" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated"><a class="ae kt" href="https://medium.com/@chad.campbell/reading-files-via-javascript-in-the-browser-part-1-choosing-files-to-read-af34a6daa63f" rel="noopener">本系列的第1部分</a>展示了如何通过a)输入元素和b)拖放来选择文件。值得注意的是，这两个场景发生在<em class="lq">主</em>线程上。</p><p id="e39d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">JavaScript有两种核心类型的线程:<em class="lq">主</em>和<em class="lq">工作线程</em>。默认情况下，主线程是运行所有JavaScript的单个线程。这意味着长时间运行的同步代码会阻塞UI。长时间运行的进程可以通过在工作线程上执行代码来确保UI的响应性。线程的细节超出了本文的范围。但是对于本文，理解文件可以从<em class="lq">或者</em>线程中读取是很重要的。下表显示了每个线程可用的接口。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/31f34ebf54a044d160be679ef96bd7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*nM5wKyhAV8bPmbTtaH0JiQ.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">table 2.2</figcaption></figure><p id="a871" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">表2.2显示了可以用来根据正在使用的线程读取文件的接口。FileReader接口可以用在任一类型的线程中。但是，FileReaderSync接口只能在工作线程中使用。这是本文将使用FileReader接口的一个原因。另一个原因来自可用的API。</p><h2 id="ca8d" class="mv ls in bd lt no np dn lx nq nr dp mb ld ns nt md lh nu nv mf ll nw nx mh ny bi translated">识别可用的API</h2><p id="2236" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">FileReader和FileReaderSync接口提供了类似的方法。大多数方法都在这两个接口中实现。下表显示了每个接口实现的和可用的方法。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b80b65f2baa2d100c22a87d43511cbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*v6HurfmxcH2QK9rZu11mrg.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">table 2.3</figcaption></figure><p id="9cac" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">从表2.3可以看出两个重要的细节。首先，readAsBinaryString方法已经被FileReaderSync接口的<em class="lq">弃用</em>。第二，中止方法是FileReaderSync接口上可用的<em class="lq">而不是</em>。基于这个表中的细节，FileReader接口给了我们更多的灵活性。表2.2中的信息强化了这一观点。这就是为什么在本文中使用FileReader接口来读取文件。</p><h1 id="7c92" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">使用FileReader API读取文件</h1><p id="89c8" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">FileReader接口允许您读取针对三种特定场景的文件。这些场景和相应的功能如下表所示。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b4e79bbb039ecbb0eae0e35bd6b37725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*AitXIUAtxVgg-7jvrLQtHQ.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">table 2.4</figcaption></figure><p id="37bd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">表2.4显示了可以通过FileReader API解决的三种情况。本节将涵盖这些情况。然而，在我们开始之前，我需要在这一部分之前提出两个警告。</p><p id="c01e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">首先，在获取二进制文件的内容时，有两个选项:readAsArrayBuffer和readAsBinaryString。如表2.3所示，readAsBinaryString已被弃用。尽可能编写健壮的、可重用的代码是最佳实践。因此，readAsBinaryString将在本节中<em class="lq">而不是</em>讨论。</p><p id="0f58" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">其次，将显示一个名为“onload”的事件。这个事件将在本系列的<em class="lq">下一篇</em>文章中详细讨论。出于这个原因，我推荐<a class="ae kt" href="https://medium.com/@chad.campbell" rel="noopener">关注我</a>，以便知道那篇文章何时发表。现在，在该事件中将使用名为“e”的参数从嵌套的target.result属性中获取文件的内容。在这一点上，这听起来可能令人困惑。不过，我相信当你看到以下场景中的示例时，会更清楚。</p><h2 id="1ef5" class="mv ls in bd lt no np dn lx nq nr dp mb ld ns nt md lh nu nv mf ll nw nx mh ny bi translated">获取文本文件内容</h2><p id="376e" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">readAsText函数允许你以文本形式读取文件的内容。您可以像这样简单地读取文件的内容:</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi oa"><img src="../Images/fc397bfa84d1df10a4ada3dd4cecc31e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtlN30Xk-79I4FJ_FjWtcQ.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">sample 2.2</figcaption></figure><p id="c64d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">示例2.2中的第12行显示了正在使用的readAsText函数。您可以使用本文的<a class="ae kt" href="https://github.com/ecofic/article-reading-files-via-javascript" rel="noopener ugc nofollow" target="_blank">源代码库</a>来试验readAsText函数的行为。我建议从files目录中选择utf-8.txt文件。如果你选择一个二进制文件，比如图片或视频，你会看到它的二进制内容，这不是很有帮助。如果你选择一个文本文件，比如utf-8.txt，你将<em class="lq">可能</em>看到打印到控制台窗口的文件内容。我说可能是因为这取决于文件内容的编码方式。</p><p id="2f17" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">默认情况下，readAsText函数使用UTF-8编码来读取文件的内容。但是，该函数允许您将编码作为第二个参数传递。该值不区分大小写，指定读取文件内容时使用的编码。为了进行演示，以下示例使用ISO-8859–2编码读取一个文件。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi oa"><img src="../Images/e5f30cc2bed68420e7a8a5d345766f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1gIds3c_16QtpUqcafKI9Q.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">sample 2.3</figcaption></figure><p id="6731" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">样本2.3中的第12行看起来与样本2.2几乎相同。不同之处在于添加了第二个参数。现在，如果您打开utf-8.txt文件，您会在控制台窗口中看到一些奇怪的东西。这是因为“ISO-8859–2”编码是在readAsText函数中指定的。当使用“ISO-8859–2”时，在这里找到的任何键<a class="ae kt" href="https://github.com/whatwg/encoding/blob/main/indexes.json" rel="noopener ugc nofollow" target="_blank">都是候选键。您需要验证您选择的编码，因为列表是<em class="lq">而不是</em>保证的。尽管如此，如果您使用无法识别的编码，您不会导致错误。相反，readAsText函数将退回到使用UTF-8。</a></p><p id="bc07" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您可能想知道是否有办法检测使用了什么编码。不幸的是，没有。十有八九，UTF 8号会成功。这是网络上最常用的编码。事实上，截至2021年，近98%的网站使用UTF-8字符编码。因此，读取不同编码的文件有点不常见。读取文件以在URL中使用，这是一个更常见的场景。</p><h2 id="d37a" class="mv ls in bd lt no np dn lx nq nr dp mb ld ns nt md lh nu nv mf ll nw nx mh ny bi translated">获取数据URL的文件内容</h2><p id="237e" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">readAsDataURL函数允许您读取base64编码字符串形式的文件内容。如果您需要立即在网页中显示媒体，这很有用。例如，您可能希望在用户选择图片或视频后显示它。readAsDataURL将为您提供一个可用于img或source元素的src属性的结果。以下示例显示了设置img src的readAsDataURL。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi oa"><img src="../Images/6705edcd26b5adfe8c25dae7ba751871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ogpivYh8jajeZLdEvvmAg.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">sample 2.4</figcaption></figure><p id="ba64" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">示例2.4显示了使用中的readAsDataURL。值得注意的是，第16行将请求的结果设置为img元素的src属性。这个结果将是代表文件内容的Base64编码字符串。就是这样。关于readAsDataURL函数，没有其他需要了解的特殊细节。它只是直接解决了readAsText和readAsArrayBuffer函数不能解决的问题。readAsArrayBuffer函数解决了另一种情况。</p><h2 id="4f7f" class="mv ls in bd lt no np dn lx nq nr dp mb ld ns nt md lh nu nv mf ll nw nx mh ny bi translated">正在检索二进制文件内容</h2><p id="22fe" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">readAsArrayBuffer函数允许您将文件内容读入ArrayBuffer。ArrayBuffer将原始文件二进制数据存储在固定长度的数组中。这对于处理像PDF文档这样的二进制文件很有用。事实上，下面的示例假设您将从本文源代码库中的files目录中选择receipt-04.pdf。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi oa"><img src="../Images/efb15869f28d221523569cc77259bac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0fBMALvcEREWRTgtW4omQ.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">sample 2.5</figcaption></figure><p id="8b22" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">示例2.5将文件的内容作为ArrayBuffer打印到控制台窗口。这个ArrayBuffer让你控制文件的数据。做这样的事情已经超出了本文或系列文章的范围。尽管如此，我还是想让您知道readAsArrayBuffer函数就像readAsDataURL和readAsText函数一样存在。我还希望您知道在读取多个文件时如何使用FileReader。</p><h1 id="3a23" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">读取多个文件</h1><p id="12a7" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">第1部分展示了如何选择多个文件。在<em class="lq">这篇</em>文章中，代码样本总是使用第一个文件。然而，有理由认为有人可能想在费用应用程序中一次选择多张收据。一旦被选中，这些收据需要被阅读。您可能想知道如何读取多个文件。在这一节中，我将向您展示如何顺序(即按顺序)或同时读取文件。下面的代码示例显示了这两种方法。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi ob"><img src="../Images/76f0ea75ad18a64b6e29577f62fde06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yi1YpbC50GUZj539dnqStw.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">sample 2.6</figcaption></figure><p id="4507" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">示例2.6向您展示了如何顺序和同时读取文件。如果您熟悉JavaScript，这里唯一的“新”部分是loadend事件的使用。该事件将在本系列的下一部分中讨论。不过现在，我想指出的是，无论是顺序读取文件还是同时读取文件，都会为每个文件创建一个唯一的FileReader。这很重要，因为如果你试图用同一个FileReader读取两个文件，你<em class="lq">可能会</em>看到以下错误之一:</p><p id="1af2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">未捕获的DOMException:无法对“FileReader”执行“readAsText”:该对象已忙于读取Blobs。</em></p><p id="7bdb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">未捕获的DOMException:无法对“FileReader”执行“readAsDataURL”:该对象已忙于读取Blobs。</em></p><p id="6812" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">未捕获的DOMException:无法对“FileReader”执行“readAsArrayBuffer”:该对象已忙于读取Blobs。</em></p><p id="ee1b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果文件读取器正在主动读取一个文件，并且在文件读取器完成读取初始文件之前就开始了对文件的读取操作，则可能会发生上述错误之一。基本上，如果一个竞争条件发生。从技术上讲，你可以用一个共享的文件阅读器读取多个文件。如果减少内存占用是至关重要的，这可能是有用的。如果你感兴趣，我在这里创建了一个样本<a class="ae kt" href="https://github.com/ecofic/article-reading-files-via-javascript/blob/live/src/part-02/shared-file-reader.html" rel="noopener ugc nofollow" target="_blank">。然而，对于大多数场景，建议为每个文件对象创建一个FileReader。建议这样做，因为您的代码更容易维护。</a></p><p id="61eb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在本文中，您看到了如何使用客户端JavaScript读取文件。如果这篇文章有帮助，请鼓掌(👏，)下面。这将让我和其他人知道，你发现它值得你的时间。这是系列文章的第二篇。因此，现在请<a class="ae kt" href="https://docs.google.com/document/d/1rpmLhxuLTdjIu1Vwzgop24GEvBm0Qkg9043cWGQdGwU/edit#" rel="noopener ugc nofollow" target="_blank">跟随我</a>以便您知道下一篇文章何时发表。下一篇文章将向您展示如何处理较大文件的进度更新和读取错误。感谢您的阅读。</p><p id="1def" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">更多内容请看</em> <a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="lq">说白了就是</em> </strong> </a> <em class="lq">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="lq">免费每周简讯</em> </strong> </a> <em class="lq">。在我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="lq">社区不和谐</em> </strong> </a> <em class="lq">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>