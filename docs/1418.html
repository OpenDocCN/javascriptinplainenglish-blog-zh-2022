<html>
<head>
<title>‘in’ vs. ‘hasOwn’ vs. ‘hasOwnProperty’ in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript的“与‘hasOwn’和‘hasOwnProperty’中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/in-vs-hasown-vs-hasownproperty-in-javascript-885771d2d100?source=collection_archive---------1-----------------------#2022-03-23">https://javascript.plainenglish.io/in-vs-hasown-vs-hasownproperty-in-javascript-885771d2d100?source=collection_archive---------1-----------------------#2022-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="74a4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你真的知道区别吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2fbcfdfdf9935fa67f75557722341943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g179PehYtRm-BxNc"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">in</code>操作符、<code class="fe ls lt lu lv b">Object.hasOwn()</code>和<code class="fe ls lt lu lv b">Object.prototype.hasOwnProperty()</code>都可以确定一个属性键是否在一个对象中，但是它们之间的区别是什么？跟我一起去看看吧！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="360d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">继承的属性</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/1cd5615b7471102b8f8242e234ba2a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2lQkHWiK4f3qU_gZPkC4w.png"/></div></div></figure><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="f21f" class="na me iq lv b gy nb nc l nd ne">const test = {<br/>  name: '1',<br/>  age: 2,<br/>};</span><span id="10e4" class="na me iq lv b gy nf nc l nd ne"><strong class="lv ir">// General properties</strong><br/>console.log('name' in test); // true<br/>console.log(Object.hasOwn(test, 'name')); // true<br/>console.log(test.hasOwnProperty('name')); // true</span><span id="acae" class="na me iq lv b gy nf nc l nd ne"><strong class="lv ir">// Inherited properties</strong><br/>console.log('constructor' in test); <strong class="lv ir">// true</strong><br/>console.log(Object.hasOwn(test, 'constructor')); // false<br/>console.log(test.hasOwnProperty('constructor')); // false</span></pre><p id="d551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看到，对于继承的属性，<code class="fe ls lt lu lv b">in</code>运算符返回true，而<code class="fe ls lt lu lv b">Object.hasOwn()</code>和<code class="fe ls lt lu lv b">Object.prototype.hasOwnProperty()</code>返回false，顾名思义，它们只检查属于自己属性的属性，忽略继承的属性。</p><h1 id="b5f9" class="md me iq bd mf mg ng mi mj mk nh mm mn jw ni jx mp jz nj ka mr kc nk kd mt mu bi translated">不是对象.原型</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/8aef2df7bd762c6390a131aed5c3ea4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOlzHKejYXJJafhcQoejgw.png"/></div></div></figure><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="e456" class="na me iq lv b gy nb nc l nd ne">let test = Object.create(null);<br/>test.name = '1';</span><span id="aa67" class="na me iq lv b gy nf nc l nd ne">console.log('name' in test); // true<br/>console.log(Object.hasOwn(test, 'name')); // true</span><span id="3b06" class="na me iq lv b gy nf nc l nd ne"><strong class="lv ir">// ❌ TypeError: test.hasOwnProperty is not a function</strong><br/>console.log(test.hasOwnProperty('name'));</span></pre><p id="3abf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到，当我们创建一个原型不是<code class="fe ls lt lu lv b">Object.prototype</code>的对象时，我们将无法访问hasOwnProperty方法，但是<code class="fe ls lt lu lv b">in</code>操作符和<code class="fe ls lt lu lv b">Object.own</code>都可以正常工作。</p><h1 id="df4b" class="md me iq bd mf mg ng mi mj mk nh mm mn jw ni jx mp jz nj ka mr kc nk kd mt mu bi translated">重写hasOwn或hasOwnProperty</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/d50e04d40cc4a68397e05842b593e980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RI9fES-lXErBbEhzoM9uCQ.png"/></div></div></figure><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="70b9" class="na me iq lv b gy nb nc l nd ne">const test = {<br/>  // 💡 We override the hasOwnProperty method here.<br/>  <strong class="lv ir">hasOwnProperty: () =&gt; false,</strong><br/>  name: '1',<br/>};</span><span id="ec01" class="na me iq lv b gy nf nc l nd ne">// 💡 We override the Object.hasOwn method here.<br/><strong class="lv ir">Object.hasOwn = () =&gt; false;</strong></span><span id="c28f" class="na me iq lv b gy nf nc l nd ne">console.log('name' in test); // true</span><span id="ee79" class="na me iq lv b gy nf nc l nd ne"><strong class="lv ir">console.log(Object.hasOwn(test, 'name')); // false<br/>console.log(test.hasOwnProperty('name')); // false</strong></span></pre><p id="7110" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们覆盖了<code class="fe ls lt lu lv b">test</code>对象上的<code class="fe ls lt lu lv b">hasOwnProperty</code>方法，同时也覆盖了<code class="fe ls lt lu lv b">Object.hasOwn</code>方法，这样无论属性是否实际存在于对象中，这两个方法都将返回false，甚至是您自定义的任何值。另一方面，<code class="fe ls lt lu lv b">in</code>操作符不能被覆盖，并且工作正常。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/435941e9187567f5b26e1dc7b5ef1daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDYxgK-E3_S57E-t3ri-gw.png"/></div></div></figure><p id="68ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很容易理解<code class="fe ls lt lu lv b">Object.prototype.hasOwnProperty()</code>方法可以被覆盖。从上图我们也可以看出<code class="fe ls lt lu lv b">Object.hasOwn</code>也是可以被覆盖的。</p><h1 id="cabc" class="md me iq bd mf mg ng mi mj mk nh mm mn jw ni jx mp jz nj ka mr kc nk kd mt mu bi translated">班级</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/54e30a691e6e3e73c932e5c762bee55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uoyFOeTv0cW2Sd0WoWO60Q.png"/></div></div></figure><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="2904" class="na me iq lv b gy nb nc l nd ne">class Test {<br/>  <strong class="lv ir">// The "hash mark" (#) is what marks a field as being private.</strong><br/>  #name = 1;<br/>  age = 2;</span><span id="8cb0" class="na me iq lv b gy nf nc l nd ne">  get name() {<br/>    return this.#name;<br/>  }</span><span id="d45d" class="na me iq lv b gy nf nc l nd ne">  set name(value) {<br/>    this.#name = value;<br/>  }<br/>}</span><span id="e858" class="na me iq lv b gy nf nc l nd ne">const test = new Test();</span><span id="5e10" class="na me iq lv b gy nf nc l nd ne">let height = 3;<br/>Reflect.defineProperty(test, 'height', {<br/>  get() {<br/>    return height;<br/>  },<br/>  set(value) {<br/>    height = value;<br/>  },<br/>});</span><span id="b940" class="na me iq lv b gy nf nc l nd ne"><strong class="lv ir">// private</strong><br/>console.log('#name' in test); // false<br/>console.log(Object.hasOwn(test, '#name')); // false<br/>console.log(test.hasOwnProperty('#name')); // false</span><span id="0829" class="na me iq lv b gy nf nc l nd ne"><strong class="lv ir">// class getter/setter</strong><br/>console.log('name' in test); // true<br/>console.log(Object.hasOwn(test, 'name')); // false<br/>console.log(test.hasOwnProperty('name')); // false</span><span id="c333" class="na me iq lv b gy nf nc l nd ne"><strong class="lv ir">// traditional getter/setter</strong><br/>console.log('height' in test); // true<br/>console.log(Object.hasOwn(test, 'height')); // true<br/>console.log(test.hasOwnProperty('height')); // true</span></pre><p id="c6fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们使用<code class="fe ls lt lu lv b">class</code>创建一个类，实例化一个对象的时候，可以看到新es特性的“hash mark”标记的私有属性找不到了。<strong class="ky ir">对于类声明的getter/setter属性，只有</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">in</strong></code> <strong class="ky ir">操作符可以找到，</strong><code class="fe ls lt lu lv b">Object.prototype.hasOwnProperty()</code>和<code class="fe ls lt lu lv b">Object.hasOwn</code>都找不到。相比之下，<strong class="ky ir">可以找到那些由非类定义的getter/setter。</strong>这是为什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/0864bd885d2d7a16eba3a6bc2314b3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QncB-RmaqiwkCe975XGFVQ.png"/></div></div></figure><p id="016f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在DevTools中打印<code class="fe ls lt lu lv b">test</code>对象，我们找到原因了！<strong class="ky ir">原来通过类声明的getter/setter属性(</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">name</strong></code> <strong class="ky ir">)是在原型</strong>上定义的，<code class="fe ls lt lu lv b">test</code>对象继承了它，所以<code class="fe ls lt lu lv b">Object.prototype.hasOwnProperty()</code>和<code class="fe ls lt lu lv b">Object.hasOwn</code>都找不到，而<code class="fe ls lt lu lv b">in</code>操作符可以找到。</p><h1 id="6e4a" class="md me iq bd mf mg ng mi mj mk nh mm mn jw ni jx mp jz nj ka mr kc nk kd mt mu bi translated">摘要</h1><p id="7392" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">总而言之，<code class="fe ls lt lu lv b">in</code>操作符可以找到继承的属性，而后两个不能。<code class="fe ls lt lu lv b">Object.hasOwn()</code>旨在取代<code class="fe ls lt lu lv b">Object.prototype.hasOwnProperty()</code>，因为它更健壮，但它们都可以被覆盖。</p><h1 id="3c39" class="md me iq bd mf mg ng mi mj mk nh mm mn jw ni jx mp jz nj ka mr kc nk kd mt mu bi translated">快餐</h1><p id="7e23" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">最后补充一些比较相关的知识点。</p><p id="5d85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Object.getOwnPropertyNames()</code>和<code class="fe ls lt lu lv b">Object.keys()</code>的区别:前者会返回对象的所有属性，而后者会返回所有可枚举的属性，即当属性描述符enumerate为true时，两者返回相同的结果。当然，这些属性不包含继承的属性。</p><p id="7156" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么<code class="fe ls lt lu lv b">for...in</code>和上面两个有什么区别呢？你可以看看这篇文章。</p><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/difference-between-for-of-and-for-in-7244104133bf"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">“for…of”和“for…in”的区别</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">它们看起来很像，那么如何正确使用呢？</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="500c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="on">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="on">中等会员</em> </a> <em class="on">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="on">我的链接</em> </a> <em class="on">报名，我会得到一点佣金。</em></p><p id="8aaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的支持对我来说非常重要——谢谢。</p></div></div>    
</body>
</html>