<html>
<head>
<title>Can console.log() cause memory leaks? How to make a browser crash with console.log()?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">console.log()会导致内存泄漏吗？如何用console.log()让浏览器崩溃？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/can-console-log-cause-memory-leaks-how-to-make-a-browser-crash-with-console-log-b94e4d248ed8?source=collection_archive---------2-----------------------#2022-02-02">https://javascript.plainenglish.io/can-console-log-cause-memory-leaks-how-to-make-a-browser-crash-with-console-log-b94e4d248ed8?source=collection_archive---------2-----------------------#2022-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eae1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您真的必须在生产中禁用console.log()吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f85df6490736f62a60643a182df112dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJ_8Y8xxGU7FWgovAJ9vmQ.png"/></div></div></figure><p id="e1b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有调试器。但是对于一些开发人员来说，在应用程序日志中更容易看到完整的图片。不知何故，人们认为服务器端保存日志是没问题的，但是在客户端看到详细的日志是不常见的。为什么？在许多抽象的原因中，有一种观点认为<code class="fe ln lo lp lq b">console.log()</code>导致了内存泄漏。让我们试着让一个浏览器因为几次调用<code class="fe ln lo lp lq b">console.log()</code>而耗尽内存。</p><h2 id="2ed5" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc le md me mf li mg mh mi mj bi translated">由于console.log()内存泄漏，浏览器可能会崩溃</h2><p id="2c8d" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">当按下按钮时，我的示例脚本开始打印对象，每个对象包含一个2亿字符长的字符串。每个新创建的字符串会占用额外的200 MB内存。创建的字符串不被任何变量引用，它们只作为<code class="fe ln lo lp lq b">console.log()</code>的参数存在:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="d160" class="lr ls iq lq b gy mt mu l mv mw">const MB = 1_000_000;</span><span id="5ea7" class="lr ls iq lq b gy mx mu l mv mw">runBtn.onclick = () =&gt; {<br/>  runBtn.remove();<br/>  addString();<br/>}</span><span id="20d3" class="lr ls iq lq b gy mx mu l mv mw">async function addString(prevMbs=0,i=1) {<br/>  <strong class="lq ir">console.log({ i, prevMbs, a: 'X'.repeat(200 * MB) });</strong><br/>  const memory = await performance.measureUserAgentSpecificMemory();<br/>  const mbs = Math.floor(memory.bytes / MB);<br/>  outputDiv.insertAdjacentHTML('beforeend',<br/>    `&lt;div class='data'&gt;&lt;div&gt;${i}&lt;/div&gt;&lt;div&gt;${mbs}&lt;/div&gt;&lt;/div&gt;`);</span><span id="5fef" class="lr ls iq lq b gy mx mu l mv mw">setTimeout(() =&gt; addString(mbs,++i), 1000);<br/>}</span></pre><p id="ac83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae my" href="https://medium.com/geekculture/how-to-determine-exactly-and-quickly-the-total-memory-used-by-a-web-page-d54cc3d90b46" rel="noopener">我使用精确内存API测量已用内存。</a>在不用于开发的浏览器中应该很慢。</p><p id="84be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">measureUserAgentSpecificMemory()</code>垃圾收集后立即测量内存。默认情况下，<code class="fe ln lo lp lq b">measureUserAgentSpecificMemory()</code>只有在20秒内没有发生时才会触发垃圾收集。如果你用命令行标志启动Chrome</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="dc45" class="lr ls iq lq b gy mt mu l mv mw">--enable-blink-features="ForceEagerMeasureMemory"</span></pre><p id="9ffe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">measureUserAgentSpecificMemory()</code>将强制垃圾收集并立即返回结果。</p><p id="5224" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">runBtn</code>和<code class="fe ln lo lp lq b">outputDiv</code>是按钮和div的id。<a class="ae my" href="https://medium.com/codex/a-popular-dispensable-method-b04598b2e608" rel="noopener">通常不需要用</a> <code class="fe ln lo lp lq b"><a class="ae my" href="https://medium.com/codex/a-popular-dispensable-method-b04598b2e608" rel="noopener">document.getElementById()</a></code>污染代码。</p><p id="40c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你愿意，你可以在你的电脑上执行示例页面<a class="ae my" href="https://consolelogmemory.onrender.com/" rel="noopener ugc nofollow" target="_blank">https://consolelogmemory.onrender.com/</a>，但是正如我上面解释的，每次内存测量可能需要20秒</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/81f55ed5eda63d95dfa5074412baf7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYjGlpp3Ki6QOhhpIkxgZw.png"/></div></div></figure><p id="aedb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击按钮<em class="na">运行</em>后，按钮消失，递归<code class="fe ln lo lp lq b">addString()</code>启动。创建14个字符串后，打开控制台的页面如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/bfe360a5e3a67d542e4dd6a4c07ea6bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01jlHQ-2CoPIaT0pnLb2FA.png"/></div></div></figure><p id="0b74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的普通计算机上，当大约4 GB的内存被填满并且创建了第21个字符串时，浏览器崩溃并显示<em class="na">内存不足</em>消息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/c58117598fad2cd71f8834a07c186963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3SAynuLas7c7dcUvsfbRg.png"/></div></div></figure><p id="96b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，很容易证明<code class="fe ln lo lp lq b">console.log()</code>可能会导致内存泄漏。</p><h2 id="3f1f" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc le md me mf li mg mh mi mj bi translated">通常，console.log()不会导致内存泄漏</h2><p id="7059" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">如果我重新加载同一个页面【https://consolelogmemory.onrender.com/<a class="ae my" href="https://consolelogmemory.onrender.com/" rel="noopener ugc nofollow" target="_blank">但是不打开控制台，当我点击按钮后内存泄漏不会发生</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/9700ec9410c7172cd2dae6f7f3e173e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxF3Vs6v1JY9hiFkvKycMA.png"/></div></div></figure><p id="8b19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我打开控制台，带有巨大字符串的未被任何变量引用的对象将无法作为垃圾被收集。在下面的截图中，在14个对象被打印到控制台后，我按下了F12:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/e977db58dae7bad09b6e6cea471e17a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgmCKU_r_6xOefuhjZpqwA.png"/></div></div></figure><p id="d108" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我关闭控制台，新对象停止在浏览器内存中累积，但是那些滞留在内存中的对象不能作为垃圾收集。在下面的截图中，我在打印了10个对象后按了F12，然后在打印了第18个对象后关闭了控制台:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/20b22a3eb667d32e8d33486e8276a64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKrH8P7WawVwP3FirC8JlA.png"/></div></div></figure><h1 id="f966" class="ng ls iq bd lt nh ni nj lw nk nl nm lz jw nn jx mc jz no ka mf kc np kd mi nq bi translated">结论</h1><p id="290a" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated"><code class="fe ln lo lp lq b">console.log()</code>导致内存泄漏，但仅在控制台打开时。通常用户不会打开控制台。因此，将任何巨大的对象打印到控制台是完全安全的。关闭的控制台不会阻止它们作为垃圾被收集。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="4e1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">源代码可以从https://github.com/marianc000/consoleLogMemory<a class="ae my" href="https://github.com/marianc000/consoleLogMemory" rel="noopener ugc nofollow" target="_blank">下载</a></p><p id="833d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="na">更多内容看</em> <a class="ae my" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="na">说白了就是io </em> </strong> </a> <em class="na">。报名参加我们的</em> <a class="ae my" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="na">免费周报</em> </strong> </a> <em class="na">。在我们的</em> <a class="ae my" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="na">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="na">。</em></p></div></div>    
</body>
</html>