<html>
<head>
<title>What is Depth-First Search?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是深度优先搜索？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-depth-first-search-5d221b676798?source=collection_archive---------7-----------------------#2022-02-20">https://javascript.plainenglish.io/what-is-depth-first-search-5d221b676798?source=collection_archive---------7-----------------------#2022-02-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3ebe" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解什么是深度优先搜索算法。</h2></div><p id="9577" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/what-is-a-breadth-first-search-f42652896d7c">上一期</a>中，我们谈到了“广度优先搜索”和“深度优先搜索”，这是我们在处理图形时最常用的两种算法。</p><p id="f7f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上次，我们看了广度优先搜索(BFS)。</p><p id="bdf4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，我们将讨论另一个，深度优先搜索(DFS)。</p><h1 id="12be" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">我为什么要在乎？</h1><p id="a7e4" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">作为你选择的语言的一部分，很多算法已经为你实现了。这意味着学习它们很有趣，但是你很少自己写。</p><p id="5c3f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图的遍历算法是不同的。</p><p id="09d5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们无时无刻不在使用图形，从在电子商务应用程序中链接相关产品，到在社交网络中映射人们之间的关系。</p><p id="5e11" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">搜索一个图不仅在理论上有用，而且在实践中你几乎肯定也需要这样做。</p><h1 id="6366" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">在5分钟或更短时间内:</h1><p id="7493" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">下面是一个图形数据结构:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/4c279abda5a49342528eeddc54f65fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*F9YcrYUyue0MclFI.png"/></div></figure><p id="9441" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图(A-F)中的“节点”称为“顶点”。每个顶点通过“边”连接到一个或多个其他顶点，边是节点之间的线。</p><p id="1ba5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是一个图只有在我们可以用它做一些事情的时候才有用；我们可能想要找出某个元素是否存储在我们的图中，或者在两个元素之间需要多少“跳”。</p><p id="3ff0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这类问题被称为“图遍历”，深度优先搜索(或“DFS”)是一种算法。</p><p id="8f74" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看。</p><h1 id="c15f" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">深度优先搜索的工作原理</h1><p id="a3d8" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在<a class="ae ky" href="https://www.baseclass.io/newsletter/linear-data-structures" rel="noopener ugc nofollow" target="_blank">这一期</a>中，我们看了“堆栈”数据结构。</p><p id="9525" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你会记得它是一种“先入后出”的数据结构；要添加到堆栈中的第一个项目将是要移除的最后一个项目:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/39683f5f1597a73740f9f71d8859dded.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/0*ofWjmR2V3fZ3m-Bc.png"/></div></figure><p id="881b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">堆栈是深度优先搜索的基础。</p><p id="87b7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是该算法的总结:</p><ul class=""><li id="75fa" class="mg mh in ke b kf kg ki kj kl mi kp mj kt mk kx ml mm mn mo bi translated">选取任何未访问的连接节点，将其添加到堆栈中，并将其标记为“已访问”</li><li id="9cf1" class="mg mh in ke b kf mp ki mq kl mr kp ms kt mt kx ml mm mn mo bi translated">从我们刚刚选择的节点，再次做同样的事情。</li><li id="9ceb" class="mg mh in ke b kf mp ki mq kl mr kp ms kt mt kx ml mm mn mo bi translated">重复直到我们在没有未访问连接的节点处结束</li><li id="6b83" class="mg mh in ke b kf mp ki mq kl mr kp ms kt mt kx ml mm mn mo bi translated">从堆栈中弹出第一个项目，并从下一个项目开始重复整个过程</li><li id="d72e" class="mg mh in ke b kf mp ki mq kl mr kp ms kt mt kx ml mm mn mo bi translated">当堆栈为空时，我们就完成了！</li></ul><p id="1e2c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这听起来比实际情况更令人困惑，所以让我们看一个例子。</p><h1 id="643e" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">实施DFS</h1><p id="c463" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们从选择一个地方开始，我们将选择<code class="fe mu mv mw mx b">A</code>。</p><p id="f807" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一步是将<code class="fe mu mv mw mx b">A</code>添加到堆栈中，并将其标记为‘visited’:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/76b7a0e0e34233162cc0d02c430c6d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*7TEwITtSDZzY6wWh.png"/></div></figure><p id="de8e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们需要重复以下步骤:</p><ul class=""><li id="d6c1" class="mg mh in ke b kf kg ki kj kl mi kp mj kt mk kx ml mm mn mo bi translated">选取任何未访问的连接节点，将其添加到堆栈中，并将其标记为“已访问”</li><li id="224d" class="mg mh in ke b kf mp ki mq kl mr kp ms kt mt kx ml mm mn mo bi translated">从我们刚刚选择的节点，再次做同样的事情。</li><li id="7ece" class="mg mh in ke b kf mp ki mq kl mr kp ms kt mt kx ml mm mn mo bi translated">重复直到我们在没有未访问连接的节点处结束</li></ul><p id="ea27" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，让我们挑选一个连接的节点，然后开始。</p><p id="ad5c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mu mv mw mx b">B</code>和<code class="fe mu mv mw mx b">C</code>都连接到<code class="fe mu mv mw mx b">A</code>。两个都没去过，接下来可以挑一个去参观。还是挑<code class="fe mu mv mw mx b">B</code>吧。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/23748d839323f11b7250f2383999fd8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*fX2QkCUh09RvbR3a.png"/></div></figure><p id="8a17" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从<code class="fe mu mv mw mx b">B</code>出发，我们可以参观<code class="fe mu mv mw mx b">A</code>、<code class="fe mu mv mw mx b">D</code>或<code class="fe mu mv mw mx b">E</code>。我们已经访问过<code class="fe mu mv mw mx b">A</code>，所以我们忽略它。还是挑<code class="fe mu mv mw mx b">D</code>吧。</p><p id="7fd0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将<code class="fe mu mv mw mx b">D</code>添加到堆栈中，并将其标记为‘visited ’,就像我们之前做的那样:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/07c43e864ed3d3fbb45dc641cee1c3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*7MwVNDzC_Yd8YjpD.png"/></div></figure><p id="c5b1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从<code class="fe mu mv mw mx b">D</code>开始，没有未访问的节点要访问。只连接到<code class="fe mu mv mw mx b">B</code>，我们刚去过。</p><p id="ff2e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，现在是时候这样做了:</p><ul class=""><li id="ba93" class="mg mh in ke b kf kg ki kj kl mi kp mj kt mk kx ml mm mn mo bi translated">从堆栈中弹出第一个项目，并从下一个项目开始重复整个过程</li></ul><p id="cdca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将从堆栈中弹出<code class="fe mu mv mw mx b">D</code>并返回到它下面的节点..也就是<code class="fe mu mv mw mx b">B</code>。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/6de3f35064cc8e697dc1b61a345f0753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*EwVNXVlTxlFvcrqX.png"/></div></figure><p id="6a72" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们回到了<code class="fe mu mv mw mx b">B</code>，我们将再次做同样的事情...</p><p id="f9e2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有一个未被访问的节点—<code class="fe mu mv mw mx b">E</code>—所以我们将访问它并将其添加到堆栈中:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5585fe15fbaac622faeed17ea7149249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*txczAG7UCnMBwCrJ.png"/></div></figure><p id="802b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有未访问的邻居。当我们将它从堆栈中弹出时，我们会看到<code class="fe mu mv mw mx b">B</code>也没有，所以我们也将它弹出:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/04ebdb09a00112b496da5ebc6c37606b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*ErcDKf_V_fVAyvOs.png"/></div></figure><p id="e940" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这让我们再次回到了图表的顶端，到了<code class="fe mu mv mw mx b">A</code>。</p><p id="283d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我相信你现在已经掌握了窍门；我们将继续挑选一个未访问的连通顶点，并将其添加到堆栈中。</p><p id="c7ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以这种方式添加了<code class="fe mu mv mw mx b">C</code>和<code class="fe mu mv mw mx b">F</code>之后，堆栈看起来是这样的:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1a9a71a96dcd758931eb779ac2082f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*4LxXD0nnmNqCOAQ2.png"/></div></figure><p id="537d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于<code class="fe mu mv mw mx b">F</code>没有未访问的连接，我们将其从堆栈中弹出。这同样适用于下一个项目- <code class="fe mu mv mw mx b">C</code> -然后是<code class="fe mu mv mw mx b">A</code>。</p><p id="73da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就给我们留下了一个空栈，意味着我们完成了！</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/673b8e4756c7ae48d6ff93b3bbb0d58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*_rS7atnteq7Zjuy_.png"/></div></figure><h1 id="c999" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">DFS的应用</h1><p id="33d8" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">当我们寻找一个我们知道可能在图表底部的项目时，DFS算法是有用的。与广度优先搜索不同，DFS会直接潜到图形的底部，然后再返回。</p><p id="7797" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个家谱，我们正在寻找最年轻的成员。我们知道它们将位于树的底部，因此在这种情况下，DFS可能是更好的选择。</p><p id="fd99" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你要搜索的项目可能在图的顶部，考虑“广度优先搜索”。当项目可能更接近底部时，考虑“深度优先搜索”</p><p id="3f60" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="me">我的</em> <a class="ae ky" href="https://www.baseclass.io/newsletter" rel="noopener ugc nofollow" target="_blank"> <em class="me">迅订户</em> </a> <em class="me">先收到这个。</em></p><p id="70a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="me">更多内容看</em> <a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="me">说白了。报名参加我们的</em><strong class="ke io"><em class="me"/></strong><a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="me">免费周报</em> </strong> </a> <em class="me">。在我们的</em> <a class="ae ky" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="me">社区不和谐</em> </strong> </a> <em class="me">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>