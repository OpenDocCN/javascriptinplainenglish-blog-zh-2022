<html>
<head>
<title>What is ‘Memoization’ in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的“记忆化”是什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-memoization-in-react-50c2d6f4f71e?source=collection_archive---------23-----------------------#2022-02-15">https://javascript.plainenglish.io/what-is-memoization-in-react-50c2d6f4f71e?source=collection_archive---------23-----------------------#2022-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a28c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用这两个有用的钩子优化React代码。</h2></div><p id="9362" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内存化是一种缓存计算结果(或函数本身)以优化性能的方法。例如，如果列表的结果已经更改，您可能只想重新呈现列表元素，或者如果另一个值已经更改，您可能只想更改一个值。</p><p id="c781" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的是，react默认情况下会尝试这样做，而且在大多数情况下，react的默认差异就足够了。记忆化实际上应该只在需要性能提升或者有特殊需求的项目中使用。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/b58b5880273b4c478540e983a503ef65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pIwCas6qc8WmGxoC"/></div></div></figure><h2 id="2104" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">我如何记忆？</h2><p id="b196" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在记忆反应中有两个“钩子”。一个是<a class="ae ml" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">【使用备忘录】</a>，另一个是<a class="ae ml" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">使用回调</a>。本质上，它们做同样的事情，但是useMemo保存一个结果(字符串、数字、HTML ),而useCallback保存一个函数。我不能说我完全理解useCallback的命名——在我看来，它应该更明确一些，比如“use<strong class="kh ir">Memo</strong>Callback”——但我不是脸书的明星开发人员😅。</p><p id="1d4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设您想要将计算结果保存在正在渲染的组件中。你可以根据React <a class="ae ml" href="https://reactjs.org/docs/hooks-reference.html#usememo'" rel="noopener ugc nofollow" target="_blank">文档</a>用useMemo来完成:</p><pre class="lc ld le lf gt mm mn mo mp aw mq bi"><span id="8a7c" class="ln lo iq mn b gy mr ms l mt mu">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span></pre><p id="fb5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个钩子末尾的数组是依赖项的列表。这些值如果发生变化，将告诉react组件在下次渲染时重新计算该值。因此，如果a或b发生了变化，显然需要重新计算值，否则用户将在UI中看到一个过时的值。</p><p id="c3ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在组件的上下文中，您可能会看到类似这样的内容(<a class="ae ml" href="https://codesandbox.io/s/factorial-with-memoization-65mkk?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">查看这里的示例代码</a>):</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0192" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，如果您要分析JavaScript代码执行的速度，第一次渲染可能需要几十毫秒的时间，而单击“rerender”按钮后触发的渲染将更接近1，甚至更快。这是因为useMemo钩子将在第一次调用该函数时保存该值，而不会在第二次重新运行计算。</p><p id="ebdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz mn b">useCallback</code>与useRef相同，但它缓存的是函数而不是值。你可能想确保你的函数不会在每次渲染时被不必要的重新创建。如果您在useCallback调用中包装您的方法，那么它的行为将与useMemo相同，被缓存并仅在依赖关系改变时重新计算。</p><p id="1e7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="lc ld le lf gt mm mn mo mp aw mq bi"><span id="2b52" class="ln lo iq mn b gy mr ms l mt mu">const [counter, setCounter] = useState(0)<br/>let func2 = useCallback(() =&gt; {</span><span id="6a28" class="ln lo iq mn b gy na ms l mt mu">    let c = counter;</span><span id="cf95" class="ln lo iq mn b gy na ms l mt mu">    return &lt;p&gt; useCallback function is processing the value &lt;b&gt;{c}&lt;/b&gt; in the count variable &lt;/p&gt;</span><span id="20f8" class="ln lo iq mn b gy na ms l mt mu">}, [counter])</span></pre><p id="d091" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，函数闭包将为输入“c”保存一个静态值，只有当该值改变时，函数才会被重新计算。如果您将一个空数组传递给useCallback方法，那么c的值永远不会改变，并且该函数只会处理计数器的第一个值。</p><p id="556c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，</p><p id="63ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">~亚历克斯</p><p id="5cea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nb">更多内容请看</em><a class="ae ml" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nb">plain English . io</em></strong></a><em class="nb">。报名参加我们的</em><strong class="kh ir"><em class="nb"/></strong><a class="ae ml" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nb">免费周报</em> </strong> </a> <em class="nb">。在我们的</em> <a class="ae ml" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="nb">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="nb">。</em></p></div></div>    
</body>
</html>