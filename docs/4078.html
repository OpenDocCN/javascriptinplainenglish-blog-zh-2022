<html>
<head>
<title>Intersection Observer in JavaScript: Everything You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的交集观察者:您需要知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-intersection-observer-cded4e80a377?source=collection_archive---------0-----------------------#2022-10-23">https://javascript.plainenglish.io/javascript-intersection-observer-cded4e80a377?source=collection_archive---------0-----------------------#2022-10-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6caf" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用交叉点观察器API实现延迟加载、无限滚动等。，而不使用复杂的逻辑或导致性能问题。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/43105dfeff3efb859615b1b606ce369f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEWG7OX6sG5npF2nYfw-1g.png"/></div></div></figure><p id="c692" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">交叉点观察器API用于异步观察元素与浏览器视窗的交叉点的变化。它使得检测一个元素的可见性，或者两个元素相对于彼此的可见性的任务变得容易，而不会使站点变得缓慢和降低用户体验。我们将在这篇文章中了解这一切。</p><h1 id="1a8c" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">交叉口观察器的用途</h1><p id="2866" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">在我们开始探索交叉点观察器API之前，让我们看看在我们的web应用程序中使用它的一些常见原因:</p><h2 id="3f79" class="mh ll in bd lm mi mj dn lq mk ml dp lu kx mm mn lw lb mo mp ly lf mq mr ma ms bi translated">无限滚动</h2><p id="8d15" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这是一种网页设计技术，当用户向下滚动时，内容被持续加载。它消除了分页的需要，并可以改善用户停留时间。</p><h2 id="ec7a" class="mh ll in bd lm mi mj dn lq mk ml dp lu kx mm mn lw lb mo mp ly lf mq mr ma ms bi translated">惰性装载</h2><p id="6cfb" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">延迟加载是一种设计模式，在这种模式下，只有当图像或其他内容滚动到用户的视图中时，才加载它们，以提高性能并节省网络资源。</p><h2 id="77c2" class="mh ll in bd lm mi mj dn lq mk ml dp lu kx mm mn lw lb mo mp ly lf mq mr ma ms bi translated">基于滚动的动画</h2><p id="4752" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这意味着当用户上下滚动页面时动画元素。有时，当到达某个滚动位置时，动画会完全播放。其他时候，动画中的时间会随着滚动位置的变化而变化。</p><h2 id="18be" class="mh ll in bd lm mi mj dn lq mk ml dp lu kx mm mn lw lb mo mp ly lf mq mr ma ms bi translated">广告收入计算</h2><p id="d478" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们可以使用交叉点观察器来检测广告何时对用户可见，并记录印象，从而影响广告收入。</p><h1 id="5a67" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">创建交叉点观察点</h1><p id="b9fe" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">让我们来看看JavaScript中交集观察器的一个简单用法。</p><p id="0437" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">index.js</code></p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="4609" class="mh ll in mw b gy nb nc l nd ne">const observer = new IntersectionObserver((entries) =&gt; {<br/>  for (const entry of entries) {<br/>    const intersecting = entry.isIntersecting;<br/>    entry.target.style.backgroundColor = intersecting ? 'blue' : 'orange';<br/>  }<br/>});</span><span id="2636" class="mh ll in mw b gy nf nc l nd ne">const box = document.getElementById('box');</span><span id="fddb" class="mh ll in mw b gy nf nc l nd ne">observer.observe(box);</span></pre><p id="d4a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回调函数接收一个包含<code class="fe mt mu mv mw b">IntersectionObserverEntry</code>接口对象的数组。此对象包含观察者当前正在观察的元素的交叉点相关信息。</p><p id="aa7f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每当目标元素与视口相交时，都会调用回调。它也被称为第一次要求观察者观察元素。</p><p id="93f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们使用<code class="fe mt mu mv mw b">for...of</code>循环来遍历传递给回调函数的条目。我们只观察一个元素，所以<code class="fe mt mu mv mw b">entries</code>数组将只包含代表盒子的<code class="fe mt mu mv mw b">IntersectionObserverEntry</code>元素，而<code class="fe mt mu mv mw b">for...of</code>循环将只有一次迭代。</p><p id="22c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">IntersectionObserverEntry</code>元素的<code class="fe mt mu mv mw b">isIntersecting</code>属性返回一个布尔值，表明该元素是否与视口相交。</p><p id="3568" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当<code class="fe mt mu mv mw b">isIntersection</code>为<code class="fe mt mu mv mw b">true</code>时，表示元素正在从不相交向相交过渡。但是当它是<code class="fe mt mu mv mw b">false</code>时，它表示元素正在从相交过渡到不相交。</p><p id="3591" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们使用<code class="fe mt mu mv mw b">isIntersection</code>属性将元素进入视口时的颜色设置为<code class="fe mt mu mv mw b">blue</code>，并在元素离开时返回到<code class="fe mt mu mv mw b">black</code>。</p><p id="aa03" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们在<code class="fe mt mu mv mw b">IntersectionObserver</code>对象上调用<code class="fe mt mu mv mw b">observe()</code>方法，让观察者开始观察元素的交集。</p><p id="65b2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的演示中，带有滚动条的白色区域代表视口。灰色部分表示页面上位于视窗之外的区域，通常在浏览器中不可见。</p><p id="b127" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">观察当一个像素进入视口时，长方体的颜色如何变化:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/82eaaddedc2db416b592709aa5ecd995.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/0*uiox0LouGU8pUOrj.gif"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The element changes color once a single pixel of it enters the viewport.</figcaption></figure><h1 id="9038" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">交叉点观察点选项</h1><p id="05a8" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">除了回调函数之外，<code class="fe mt mu mv mw b">IntersectionObserver()</code>构造函数还接受一个<code class="fe mt mu mv mw b">options</code>对象，我们用它来定制回调被调用所必须满足的条件。</p><h2 id="acbb" class="mh ll in bd lm mi mj dn lq mk ml dp lu kx mm mn lw lb mo mp ly lf mq mr ma ms bi translated"><code class="fe mt mu mv mw b">threshold</code></h2><p id="e9ca" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><code class="fe mt mu mv mw b">threshold</code>属性接受一个介于0和1之间的值，该值指定元素在视口中必须可见的百分比，以便调用回调。默认情况下，它的值为<code class="fe mt mu mv mw b">0</code>，这意味着一旦元素的单个像素进入视口，回调就会运行。</p><p id="d7e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们修改前面的例子，使用阈值<code class="fe mt mu mv mw b">1</code> (100%):</p><p id="d751" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">index.js</code></p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="cc1d" class="mh ll in mw b gy nb nc l nd ne">const observer = new IntersectionObserver(<br/>  (entries) =&gt; {<br/>    for (const entry of entries) {<br/>      const intersecting = entry.isIntersecting;<br/>      entry.target.style.backgroundColor = intersecting ? 'blue' : 'black';<br/>    }<br/>  },<br/>  // 👇 Threshold is 100%<br/>  { threshold: 1 }<br/>);</span><span id="1c2a" class="mh ll in mw b gy nf nc l nd ne">const box = document.getElementById('box');</span><span id="1b54" class="mh ll in mw b gy nf nc l nd ne">observer.observe(box);</span></pre><p id="d265" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，只有当元素的每个像素在视口中都可见时，才会执行改变颜色的回调。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/57c8ef8d35a16128206ca3a4d95397bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/0*Y8k5uOBctgUxmK9Q.gif"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The element changes color once every single pixel of it enters the viewport.</figcaption></figure><p id="01dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">threshold</code>也接受多个值，这使得每次元素通过一个阈值集时回调get。</p><p id="7684" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:</p><p id="c035" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">index.js</code></p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="e8be" class="mh ll in mw b gy nb nc l nd ne">const threshold = document.getElementById('threshold');</span><span id="48b0" class="mh ll in mw b gy nf nc l nd ne">const observer = new IntersectionObserver(<br/>  (entries) =&gt; {<br/>    for (const entry of entries) {<br/>      const ratio = entry.intersectionRatio;<br/>      threshold.innerText = `${Math.round(ratio * 100)}%`;<br/>    }<br/>  },<br/>  // 👇 Multiple treshold values<br/>  { threshold: [0, 0.25, 0.5, 0.75, 1] }<br/>);</span><span id="592c" class="mh ll in mw b gy nf nc l nd ne">const box = document.getElementById('box');</span><span id="0a0d" class="mh ll in mw b gy nf nc l nd ne">observer.observe(box);</span></pre><p id="d18e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将数组中的5个百分比值传递给<code class="fe mt mu mv mw b">threshold</code>属性，并在元素到达时显示每个值。为了做到这一点，我们使用了<code class="fe mt mu mv mw b">intersectionRatio</code>属性，一个介于0和1之间的数字表示元素在视口中的当前百分比。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f10cead1eb5ea62cd5778266efa2ed72.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/0*DERbkOPVp7JjwYPF.gif"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The text is updated each time a percentage of the element in the viewport reaches a certain threshold.</figcaption></figure><p id="0946" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意，显示的文本并不总是与我们的阈值相匹配，例如，在演示中，<code class="fe mt mu mv mw b">2%</code>是针对<code class="fe mt mu mv mw b">0%</code>阈值显示的。发生这种情况是因为当我们快速滚动并达到一个阈值时，等到回调可以触发以更新文本时，我们已经滚动了超过阈值的更多元素。</p><p id="83de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们滚动得更慢，回调将有时间在元素滚动超过当前阈值之前更新文本。</p><p id="9479" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">rootMargin</code></p><p id="16c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">rootMargin</code>属性在视窗或根元素周围应用边距。它接受CSS <code class="fe mt mu mv mw b">margin</code>属性可以接受的值，例如<code class="fe mt mu mv mw b">10px 20px 30px 40px</code>(上、右、下、左)。边距增大或缩小相交观察者观察的与目标元素相交的视口区域。</p><p id="daa5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是一个使用<code class="fe mt mu mv mw b">rootMargin</code>属性的例子:</p><p id="2a08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">index.js</code></p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="415e" class="mh ll in mw b gy nb nc l nd ne">const observer = new IntersectionObserver(<br/>  (entries) =&gt; {<br/>    for (const entry of entries) {<br/>      const intersecting = entry.isIntersecting;<br/>      entry.target.style.backgroundColor = intersecting ? 'blue' : 'black';<br/>    }<br/>  },<br/>  // 👇 Root margin 50px from bottom of viewport<br/>  { rootMargin: '50px' }<br/>);</span><span id="6e6e" class="mh ll in mw b gy nf nc l nd ne">const box = document.getElementById('box');</span><span id="d5f8" class="mh ll in mw b gy nf nc l nd ne">observer.observe(box);</span></pre><p id="0151" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在设置了一个<code class="fe mt mu mv mw b">50px</code>的<code class="fe mt mu mv mw b">rootMargin</code>之后，为了相交的目的，视口的高度被有效地增加了，当元素进入视口的<code class="fe mt mu mv mw b">50px</code>时，回调函数将被调用。</p><p id="e835" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">演示中的红线表示观察者观察的任何交叉点区域的边界。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/de6ce5af2f3f45a1e68737aa4ef1262e.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/0*EiLUrYbLnwizKpss.gif"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The element changes color when it comes within 50px of the viewport.</figcaption></figure><p id="f6c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还可以指定负边距来缩小用于相交的视口区域。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="e4ca" class="mh ll in mw b gy nb nc l nd ne">const observer = new IntersectionObserver(<br/>  (entries) =&gt; {<br/>    for (const entry of entries) {<br/>      const intersecting = entry.isIntersecting;<br/>      entry.target.style.backgroundColor = intersecting ? 'blue' : 'black';<br/>    }<br/>  },<br/>  // 👇 Negative margin<br/>  { rootMargin: '-50px' }<br/>);</span><span id="1532" class="mh ll in mw b gy nf nc l nd ne">const box = document.getElementById('box');</span><span id="67c0" class="mh ll in mw b gy nf nc l nd ne">observer.observe(box);</span></pre><p id="1bec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当元素的单个像素在视口内超过<code class="fe mt mu mv mw b">50px</code>时，就会触发回调。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7aa4b27b0e9a211607aee414a80b7e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/0*1R887qtRIqvzQyLg.gif"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The element changes color when a single pixel of the element is more than 50px inside the viewport.</figcaption></figure><p id="c90d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">root</code></p><p id="407b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">属性接受的元素必须是被观察元素的祖先。默认为<code class="fe mt mu mv mw b">null</code>，表示使用视口。您不需要经常使用该属性，但是当您的页面上有一个可滚动的容器，并且您希望检查它与其中一个子元素的交集时，该属性非常方便。</p><p id="2a84" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，为了创建本文中的演示，我将<code class="fe mt mu mv mw b">root</code>属性设置为页面上的一个可滚动容器，以便于您可视化视口及其外部区域，并更好地理解交叉点是如何工作的。</p><h1 id="be23" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">第二个回调参数</h1><p id="b6c1" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">传递给<code class="fe mt mu mv mw b">IntersectionObserver()</code>构造函数的回调实际上有两个参数。第一个参数是我们之前看的<code class="fe mt mu mv mw b">entries</code>参数。第二个是观察十字路口的观察者。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="897b" class="mh ll in mw b gy nb nc l nd ne">const observer = new IntersectionObserver((entries, o) =&gt; {<br/>  console.log(o === observer); // true<br/>});</span></pre><p id="5100" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此参数对于从回调中访问观察器很有用，尤其是在回调位于无法访问观察器变量的位置时，例如，在与包含观察器变量的文件不同的文件中。</p><h1 id="61b2" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">防止内存泄漏</h1><p id="6f8a" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">当不再需要观察元素时，我们需要停止观察它们，比如当它们从DOM中移除或者在一次基于滚动的动画之后，以防止内存泄漏或者性能问题。</p><p id="d451" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以用<code class="fe mt mu mv mw b">unobserve()</code>方法做到这一点。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="ee6d" class="mh ll in mw b gy nb nc l nd ne">new IntersectionObserver((entries, observer) =&gt; {<br/>  entries.forEach(entry =&gt; {<br/>    if (entry.isIntersecting) {<br/>      doAnim(entry.target);<br/>      observer.unobserve(entry.target);<br/>    }<br/>  });<br/>});</span></pre><p id="0e68" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">unobserver()</code>将单个元素作为其参数，并停止观察该元素。</p><p id="c0c7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还有一种<code class="fe mt mu mv mw b">disconnect()</code>方法，让观察者停止观察所有元素。</p><h1 id="f8e2" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">结论</h1><p id="e18e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">Intersection Observer是一个强大的JavaScript API，用于轻松检测元素何时与视口或父元素相交。它让我们可以实现延迟加载、基于滚动的动画、无限滚动等等，而不会导致性能问题，也不必使用复杂的逻辑。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="4499" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nu">原载于</em><a class="ae nv" href="https://cbdev.link/563df1" rel="noopener ugc nofollow" target="_blank"><em class="nu">【codingbeautydev.com】</em></a></p><h1 id="4436" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">JavaScript做的每一件疯狂的事情</h1><p id="e18c" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">一本关于JavaScript微妙的警告和鲜为人知的部分的迷人指南。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/143ee152ba78025ea8643ba5b9726a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*YS5Oub8REWy8vnOEqBnsyQ.png"/></div></figure><p id="7d6e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae nv" href="https://cbdev.link/d3c4eb" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">报名</strong> </a>立即免费领取一份。</p></div></div>    
</body>
</html>