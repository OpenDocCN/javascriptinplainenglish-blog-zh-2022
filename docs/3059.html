<html>
<head>
<title>Depth-First Tree Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度优先树遍历</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/depth-first-tree-traversal-93fa02da2f1f?source=collection_archive---------14-----------------------#2022-07-26">https://javascript.plainenglish.io/depth-first-tree-traversal-93fa02da2f1f?source=collection_archive---------14-----------------------#2022-07-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="deb6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这篇文章将涉及一个相当简单的算法专家问题——“深度优先搜索”</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f4946d419d861b69f6fdabe09bd87fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d44gjJXxTmFIuamfzeeTPA.jpeg"/></div></div></figure><p id="d4c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这篇文章将涉及一个相当简单的算法专家问题——“深度优先搜索”。</p><p id="ca3c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">乍一看，我误以为这是一个BST深度优先搜索问题，但幸运的是，在开始之前，我注意到这是一个树遍历。</p><p id="d82b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我对树很感兴趣，因为它们不像二叉树那样简单，但不知何故，它们看起来更直观。虽然这可能是因为我通常在二叉树中使用递归，在树中使用迭代。</p><p id="47e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">帮助我回忆如何处理树或图遍历的是，深度优先搜索通常利用堆栈，而广度优先搜索利用队列。</p><p id="fa35" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">想清楚</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/4b40548c3ddfe278b3bce708f4c390dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uJhR28anLp1mgako13ZhA.jpeg"/></div></div></figure><p id="fece" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么栈到底为什么要帮我遍历这个呢？</p><p id="a0b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们一步一步来看。</p><p id="e4d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我从根(“A”)开始，所以我将把它的孩子添加到堆栈中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/3ca9427a604b52be9901b03a2b01193f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sk8Ajlgmk6cAO170BgHR2A.jpeg"/></div></div></figure><p id="ffd1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我将通过从堆栈中弹出来移动到下一个节点。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/abf08cf81312680804c2f5cbd1c73c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63KhVtPx__kfrTdH9boBfQ.jpeg"/></div></div></figure><p id="3959" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在将它的子元素添加到堆栈中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/e20c809e0b067abe86bf98e1e6893f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIiRDIyPEw90D3YeMN8O1g.jpeg"/></div></div></figure><p id="16ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我将访问“E”和“F”，同时弹出它们。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/723e049cc9db5a23a3ad9fe5a34e6ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-b7mbvMvG7aSGguSqgWIg.jpeg"/></div></div></figure><p id="5004" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从这里很容易看出这是如何完成的，以及为什么栈如此适合深度优先搜索。LIFO(后进先出)过程自然会优先考虑深度。</p><p id="261a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">实施:</strong></p><p id="6c6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在AlgoExpert上，我们将得到一个实现DFS方法的节点类。</p><p id="6a0e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将给出我的完整解决方案(非常简单易懂),而不是分解这个过程。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="a654" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们返回的数组(如问题所指定的)将以正确的深度优先顺序包含所有节点名。</p><p id="2090" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这一次就这样了！</p><p id="61f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然这是一个相对简单的问题，但我仍然喜欢花时间来强化该方法的应用。简单的遍历是许多其他更复杂问题的基础，深刻理解这些似乎是一个好主意。</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><p id="34b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lu">更多内容看</em> <a class="ae lv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lu">说白了就是</em> </strong> </a> <em class="lu">。报名参加我们的</em> <a class="ae lv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lu">免费周报</em> </strong> </a> <em class="lu">。关注我们关于</em> <a class="ae lv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lu">推特</em></strong></a><a class="ae lv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lu">领英</em></strong></a><em class="lu">和</em><strong class="kq io"><em class="lu"/></strong><a class="ae lv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lu">不和</em> </strong> </a> <em class="lu">。</em></p></div></div>    
</body>
</html>