<html>
<head>
<title>Unit Testing Node.js Backend Models With Mocha and Chai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Mocha和Chai单元测试Node.js后端模型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-testing-node-js-backend-models-with-mocha-and-chai-1185c8ad9ff6?source=collection_archive---------6-----------------------#2022-08-23">https://javascript.plainenglish.io/unit-testing-node-js-backend-models-with-mocha-and-chai-1185c8ad9ff6?source=collection_archive---------6-----------------------#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88ab532e77000240df504abae0b3357e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2-6m-cnKG7jTyQrP-TVxg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Unit Tests with Mocha &amp; Chai</figcaption></figure><p id="4fe5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">大家好！</p><p id="d935" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇高度实用和动手操作的文章中，让我们看看如何为我们用Node.js编写的后端模型编写单元测试。在这篇文章中，我们将使用<a class="ae la" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>测试框架和<a class="ae la" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank"> Chai </a>断言库。</p><blockquote class="lb lc ld"><p id="6955" class="kc kd le ke b kf kg kh ki kj kk kl km lf ko kp kq lg ks kt ku lh kw kx ky kz ij bi translated"><strong class="ke ir">免责声明:</strong>这是一篇代码密集的文章，建议至少对JavaScript有中等程度的熟悉，以充分利用将进一步讨论的概念。还有，请做好大量阅读JS代码的准备。</p><p id="ae22" class="kc kd le ke b kf kg kh ki kj kk kl km lf ko kp kq lg ks kt ku lh kw kx ky kz ij bi translated"><strong class="ke ir">注:</strong>单元测试一般是指孤立地测试逻辑的最小单元(比如一个函数)，但在这里，我们将后端的单个实体(比如账户模型)作为一个单元来考虑。</p></blockquote><p id="deb1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以事不宜迟，让我们开始吧:</p><h1 id="70e3" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">摩卡是什么？</h1><p id="2ad2" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">摩卡是一个类似于<a class="ae la" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>的测试跑者。Mocha和Jest的主要区别在于Jest是一个包含电池的测试框架。这意味着它开箱即用，提供断言、嘲讽等帮助。但是摩卡缺少它们。你必须使用一个外部库来实现这些功能。</p><h1 id="65d9" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">为什么是摩卡？</h1><p id="6631" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">所以，你可能会想，为什么不用jest呢？你会是对的。但是，如果您必须在几年前构建的系统上工作，并且您刚刚加入团队。您的任务是实现您的第一个功能。那么对如何用Mocha编写测试有一个大致的了解将是在这样的场景中有用的知识。</p><p id="120a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，知道使用多种工具不会影响你的机会。事实上，这只会让他们进步很多。</p><h1 id="1def" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Chai.js是什么？</h1><p id="f858" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">正如我们前面讨论的，我们必须在Mocha中使用外部断言库。内置的Node.js断言对于简单的情况也能很好地工作。但是如果我们想写习惯性的和描述性的测试，我们需要一个第三方的断言库。这就是Chai.js出现的原因。它只是一个断言库，通过它公开了一些有用的方法。</p><h1 id="83a6" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">设置依赖关系:</h1><p id="05d4" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">为了使用这些工具，我们必须将它们作为依赖项添加到我们的项目中。由于它们只是用于测试的依赖项，我们不妨将它们作为<code class="fe ml mm mn mo b">devDependencies</code>添加到package.json文件中。</p><p id="57ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以我们的<code class="fe ml mm mn mo b">package.json</code>文件看起来会像下面这样:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="a70d" class="mx lj iq mo b gy my mz l na nb">{<br/>  "name": "mochachaidemo",<br/>  "version": "1.0.0",<br/>  "type": "module",<br/>  "description": "A POC app to demostrate unit testing with mocha and chai",<br/>  "main": "src/index.js",<br/>  "author": "Parthipan Natkunam",<br/>  "license": "MIT",<br/>  "scripts": {<br/>    "test:unit": "mocha --exit tests/unit/*/*",<br/>  },<br/>  "dependencies": {<br/>    "joi": "^17.4.0",<br/>  },<br/>  "devDependencies": {<br/>    "chai": "^4.3.4",<br/>    "mocha": "^8.4.0",<br/>  }<br/>}</span></pre><p id="9759" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还要注意，为了简单、简明和紧扣主题，我们将只为它建立一个模型和一个测试。在本文中，我们不会实现API路由。</p><p id="5aeb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，在本文中，我们不会看到任何数据库集成。</p><h1 id="c45a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">型号:</h1><p id="60c9" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">让我们建立一个模型来模拟一个银行账户。在项目的根目录下，让我们创建一个名为<code class="fe ml mm mn mo b">models</code>的目录，并将所有与模型相关的模块放在那里。</p><h2 id="da2b" class="mx lj iq bd lk nc nd dn lo ne nf dp ls kn ng nh lw kr ni nj ma kv nk nl me nm bi translated">基本模型类:</h2><p id="ec2a" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">当使用Node.js在后端工作时，我经常发现采用面向对象的方法来处理后端实体很方便。当然，这只是我个人的看法和喜好。您可以根据您的项目需求和偏好做出决定。</p><p id="ee7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">说到这里，让我们实现一些基类，从这些基类我们可以扩展子模型:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="9ae9" class="mx lj iq mo b gy my mz l na nb">// models/Base.js</span><span id="1481" class="mx lj iq mo b gy nn mz l na nb">export class DataObject {<br/>  toString() {<br/>    return JSON.stringify(this);<br/>  }<br/>}<br/><br/>export class Model {<br/>  constructor(name) {<br/>    this.modelName = name;<br/>  }<br/>}</span></pre><p id="ee21" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，从DataObject扩展的类将对数据建模，并充当对象关系映射(ORM)。而那些从Model类扩展而来的类将更像其他编程语言(如Java)中的存储库类。</p><h2 id="77e4" class="mx lj iq bd lk nc nd dn lo ne nf dp ls kn ng nh lw kr ni nj ma kv nk nl me nm bi translated">验证者:</h2><p id="7b2e" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">从技术上来说，这些不是模型的一部分，而是我们的模型将利用的函数和对象。为了方便起见，我将把它放在我们的<code class="fe ml mm mn mo b">models</code>目录中:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="2240" class="mx lj iq mo b gy my mz l na nb">// models/validators.js</span><span id="c90e" class="mx lj iq mo b gy nn mz l na nb">import joi from "joi";</span><span id="8bce" class="mx lj iq mo b gy nn mz l na nb">export const isValidAmount = (amount) =&gt; {<br/>  return !!amount &amp;&amp; !Number.isNaN(+amount) &amp;&amp; amount &gt; 0;<br/>};</span><span id="d116" class="mx lj iq mo b gy nn mz l na nb">export const account = {<br/>  validateAccountObject: (accountObject) =&gt; {<br/>    const schema = joi.object({<br/>      id: accountNumberValidationRule,<br/>      holderId: joi.number().required(),<br/>      currency: currencyShortCodeValidationRule,<br/>      balance: joi.number().positive().precision(2).required(),<br/>    });<br/>    return schema.validate(accountObject);<br/>  },<br/>  validateWithdrwal: (balance, amount) =&gt; {<br/>    if (isValidAmount(amount)) {<br/>      if (balance &lt; amount) {<br/>        throw new Error("Insufficient balance in your account");<br/>      }<br/>      return;<br/>    }<br/>    throw new Error("Invalid amount");<br/>  },<br/>  validateDeposit: (amount) =&gt; {<br/>    if (!isValidAmount(amount)) {<br/>      throw new Error("Invalid amount");<br/>    }<br/>  },<br/>};</span></pre><h2 id="a26d" class="mx lj iq bd lk nc nd dn lo ne nf dp ls kn ng nh lw kr ni nj ma kv nk nl me nm bi translated">客户模型:</h2><p id="7cc8" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">现在，让我们创建帐户数据对象和帐户存储库。同样，为了简单起见，我将两个类放在一个文件中。如果您正在进行一个生产项目，我建议您将它们作为单独的文件。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Account DAO and Repository as a unified Model</figcaption></figure><p id="6658" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如您所看到的，模型和存储库只是模拟了一个银行账户。</p><p id="9e69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有一件事我们还没有讨论过，但是在上面的代码中出现了，那就是<code class="fe ml mm mn mo b">inMemoryStore</code>。如前所述，为了进行概念验证，我们没有将模型连接到实际的数据库，而是在内存中有一个对象来存储数据。</p><h1 id="d1c9" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内存中的数据存储:</h1><p id="c24f" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">让我们快速在内存中创建一个对象来保存我们的数据，如下所示:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="d638" class="mx lj iq mo b gy my mz l na nb">// store/db.js</span><span id="d163" class="mx lj iq mo b gy nn mz l na nb">export const store = {<br/>  customers: [],<br/>  accounts: [],<br/>};</span></pre><p id="04a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们为内存中的数据对象创建一些助手方法:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Custom In-memory store</figcaption></figure><h1 id="24d1" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">单元测试:</h1><p id="048c" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">让我们在项目的根目录下创建一个目录，并将其命名为<code class="fe ml mm mn mo b">tests</code>。这将为我们的应用程序代码和测试提供清晰的分离。同样值得注意的是，我们将把Account DAO和Account repository看作一个单独的实体。</p><p id="7726" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好的单元测试的主要组成部分之一是模拟数据。让我们首先为我们的测试创建一些模拟:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="9dd9" class="mx lj iq mo b gy my mz l na nb">// tests/mocks.js</span><span id="462f" class="mx lj iq mo b gy nn mz l na nb">export const account = {<br/>  validAccount: {<br/>    id: "1627898927",<br/>    holderId: 1,<br/>    currency: "INR",<br/>    balance: 23000,<br/>  },<br/>};</span></pre><p id="bfc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们测试开立新账户的方法:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="6f10" class="mx lj iq mo b gy my mz l na nb">// tests/unit/models/Account.test.js</span><span id="fcd9" class="mx lj iq mo b gy nn mz l na nb">import chai from "chai";<br/>import { Account } from "../../../models/Account.js";<br/>import { account as accountMock } from "../../mocks.js";<br/><br/>const account = new Account();</span><span id="d104" class="mx lj iq mo b gy nn mz l na nb">describe("Account Model", () =&gt; {<br/>  it("creates an account", () =&gt; {<br/>    account.openAccount(accountMock.validAccount);<br/>    const openedAccount = account.getByAccountNumber(<br/>      accountMock.validAccount.id<br/>    );<br/>    chai<br/>      .expect(openedAccount.accountNumber)<br/>      .to.equal(accountMock.validAccount.id);<br/>    chai<br/>      .expect(openedAccount.currencyShortCode)<br/>      .to.equal(accountMock.validAccount.currency);<br/>    chai<br/>      .expect(openedAccount.balance)<br/>      .to.equal(accountMock.validAccount.balance);<br/>    chai<br/>      .expect(openedAccount.customerId)<br/>      .to.equal(accountMock.validAccount.holderId);<br/>  });<br/>});</span></pre><p id="6c69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们运行我们在package.json中定义的脚本来运行单元测试:</p><p id="f36a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ml mm mn mo b">yarn test:unit</code></p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/58d0f66789dd1447347d17b3f3f3a2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kN1UFSP3LnV8xAy9Gg-s-Q.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">run the unit test case</figcaption></figure><h1 id="f5f0" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">添加剩余的案例:</h1><p id="2038" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">现在我们有了一个可测试的单个案例，让我们添加其他功能的测试，比如检索账户细节、存款和取款。让我们也给这些功能添加一些负面案例，使测试完整可靠。</p><p id="c5d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以<code class="fe ml mm mn mo b">Account.test.js</code>文件会变成如下:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Complete test suite for Account model</figcaption></figure><p id="b63b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们一起运行它:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/742b5360bffdcd1a66914a0c38c1ba05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*z6Lvtxehvl2sT99EKmbkpQ.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">All cases for the Account Model</figcaption></figure><h1 id="b66e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论:</h1><p id="a791" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">因此，我们使用Mocha和Chai为Node.js代码编写了一个完整的单元测试套件。</p><p id="4f4e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果将来需求发生变化，拥有这些测试将使我们更有信心进行重构。</p><p id="8e70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望这些内容对你有用。如果我对这篇文章有足够的兴趣，我会写另一篇关于用相同的Mocha和Chai设置执行集成测试的文章。</p><p id="b35c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想看更多关于编程和web开发的实用技术内容，可以考虑在这里关注我。</p><p id="4131" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我的下一篇文章中，我将很快与您交流。</p><p id="0f0d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">干杯！:)</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="636b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="le">更多内容请看</em><a class="ae la" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="le">plain English . io</em></strong></a><em class="le">。报名参加我们的</em> <a class="ae la" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="le">免费周报</em> </strong> </a> <em class="le">。关注我们关于</em><a class="ae la" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="le">Twitter</em></strong></a><a class="ae la" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="le">LinkedIn</em></strong></a><em class="le"/><a class="ae la" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="le">YouTube</em></strong></a><em class="le"/><a class="ae la" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="le">不和</em> </strong> </a> <em class="le">。</em></p></div></div>    
</body>
</html>