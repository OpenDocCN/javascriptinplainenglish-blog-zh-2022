<html>
<head>
<title>3 Concepts of Functions to Add to Your Arsenal as a JavaScript Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为一名JavaScript开发人员，3个函数概念将成为你的武器库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-functions-part-1-definitions-and-arguments-ef2643e73233?source=collection_archive---------6-----------------------#2022-03-06">https://javascript.plainenglish.io/javascript-functions-part-1-definitions-and-arguments-ef2643e73233?source=collection_archive---------6-----------------------#2022-03-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b020" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript函数第1部分:函数定义和参数赋值</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a616e6be5d6c5b339c80d26bd768cc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8jASB_aq14Jzltmfvy44Q.jpeg"/></div></div></figure><p id="ba98" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这篇博客中，我们将讨论以下主题:</p><ol class=""><li id="958c" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">充当一级对象</li><li id="ec7a" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">定义函数的各种方法</li><li id="7ec9" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">参数赋值的真实性</li></ol><h1 id="1eea" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated"><strong class="ak"> 1。充当一级对象</strong></h1><p id="c073" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">JavaScript中的函数拥有对象的所有功能，因此和语言中的其他对象一样。我们说函数是<em class="mv">一级</em>对象，也可以是:</p><ul class=""><li id="87ae" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mw lq lr ls bi translated"><strong class="kq io">通过文字创建</strong></li></ul><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="11e7" class="nc lz in my b gy nd ne l nf ng">function testFunction() {}</span></pre><ul class=""><li id="a75d" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mw lq lr ls bi translated"><strong class="kq io">赋给变量、数组条目和其他对象的属性</strong></li></ul><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="b328" class="nc lz in my b gy nd ne l nf ng">const testFunction = function() {}  // Assigned to a variable<br/>testArray.push(function(){})  // Added to an array<br/>test.data = function(){}  // Assigned to property of another object</span></pre><ul class=""><li id="fbf7" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mw lq lr ls bi translated"><strong class="kq io">作为参数传递给其他函数</strong></li></ul><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="2bf9" class="nc lz in my b gy nd ne l nf ng">function call(testFunction) {<br/>    testFunction();<br/>}<br/>call(testFunction(){})  // Newly created function passed as argument</span></pre><ul class=""><li id="1645" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mw lq lr ls bi translated"><strong class="kq io">作为函数</strong>的值返回</li></ul><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="b751" class="nc lz in my b gy nd ne l nf ng">function returnNewTestFunction(){<br/>    return function(){};  // Return a new function<br/>}</span></pre><ul class=""><li id="933c" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mw lq lr ls bi translated"><strong class="kq io">它们可以拥有可动态创建和分配的属性</strong></li></ul><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="f7b0" class="nc lz in my b gy nd ne l nf ng">let testFunction  = function(){}<br/>testFunction.name = "Naruto"   // add property to a function</span></pre><p id="7aca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">无论我们能对对象做什么，我们也能对函数做什么。函数是对象，只是有一个额外的特殊能力，即<em class="mv">可调用</em>:函数可以被调用以执行一个动作。</p><p id="6b87" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同时将一个函数作为参数传递给另一个函数，该函数可能会在应用程序执行的后期调用传入的函数。这是一个更一般的概念，称为<em class="mv">回调函数</em>。</p><ul class=""><li id="fea1" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mw lq lr ls bi translated"><strong class="kq io">回调函数</strong></li></ul><p id="e46c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回调是有效使用JavaScript的重要部分，我敢打赌你已经在代码中大量使用了回调。</p><p id="15a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将从一个完全无用的函数的示例开始，该函数接受对另一个函数的引用作为参数，并将该函数作为回调调用:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="08a3" class="nc lz in my b gy nd ne l nf ng">function useless(testCallback){<br/>    return testCallback();<br/>}</span></pre><p id="d004" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个函数解释了如何将一个函数作为参数传递给另一个函数，然后使用传递的参数调用那个函数，尽管它毫无意义。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="830d" class="nc lz in my b gy nd ne l nf ng">var text = "Uzumaki Naruto!";</span><span id="8757" class="nc lz in my b gy nh ne l nf ng">function useless(testCallback){<br/>    return testCallback();<br/>}</span><span id="6a1b" class="nc lz in my b gy nh ne l nf ng">console.log(useless(function (){return text:}))</span><span id="40d8" class="nc lz in my b gy nh ne l nf ng">// Prints: Uzumaki Naruto!</span></pre><p id="5d71" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript最重要的特性是能够在表达式出现的地方创建函数。当一个函数不会从代码中的很多地方被访问时，这个特性还可以避免用无关的名字污染全局名称空间，从而使代码更加紧凑和易于理解。</p><p id="e8c5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">带函数的简单排序示例:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="57a9" class="nc lz in my b gy nd ne l nf ng">const values = [0,2,5,3,9,6,8,7]<br/>values.sort(function(v0, v1){<br/>   return v0 - v1<br/>})</span></pre><p id="2fcc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以提供一个回调函数，JavaScript引擎每次需要比较两个条目时都会调用这个函数。</p><h1 id="b687" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">2.定义函数的各种方法</h1><p id="b923" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">声明JavaScript函数的最常见方式是使用函数文字，它的工作方式类似于数字文字，因为它创建一个函数值。请记住，像字符串和数字一样，函数是一级对象，可以在语言中作为值使用。</p><p id="799f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你已经在做了，不管你有没有意识到。</p><p id="d795" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript中有几种定义函数的方法，可以分为四类:</p><h2 id="865a" class="nc lz in bd ma ni nj dn me nk nl dp mi kx nm nn mk lb no np mm lf nq nr mo ns bi translated"><strong class="ak"> 2.1函数声明和函数表达式</strong></h2><p id="a9bf" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">定义函数的两种最常见但又微妙不同的方式。通常人们甚至不认为它们是独立的，但是正如您将看到的，意识到它们的差异可以帮助我们理解何时我们的函数可供调用:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="4cdb" class="nc lz in my b gy nd ne l nf ng">function myFun(){ return 1; }</span></pre><h2 id="e4fa" class="nc lz in bd ma ni nj dn me nk nl dp mi kx nm nn mk lb no np mm lf nq nr mo ns bi translated"><strong class="ak"> 2.1.1函数声明</strong></h2><p id="e685" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">在每个函数声明中，强制function关键字后面跟一个强制function名和一列用逗号分隔的可选参数名，这些参数名用强制括号括起来。必须使用左大括号和右大括号来封装函数体，函数体可能是一个空的语句列表。除此之外，还有一个标准，每个函数声明都必须满足:函数声明应该包含在它自己的JavaScript语句中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ca9cb6a3ac5bc4a5d6a41ca8557046f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8NC2IqMPj2SZTmmwYzoHmA.png"/></div></figure><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="d9b8" class="nc lz in my b gy nd ne l nf ng">//defines headphone in global code<br/>function headphone() {<br/>   return 'boat headphone'<br/>}</span><span id="5d3e" class="nc lz in my b gy nh ne l nf ng">//defines laptop in global code<br/>function laptop() {   <br/>    // defines keyboard within laptop<br/>    function keyboard() { return 'keyboard here' }<br/>return hiddenMouse()<br/>}<br/></span></pre><h2 id="9adb" class="nc lz in bd ma ni nj dn me nk nl dp mi kx nm nn mk lb no np mm lf nq nr mo ns bi translated"><strong class="ak"> 2.1.2函数表达式</strong></h2><p id="6be3" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">如前所述，JavaScript对象是一级对象，这意味着它们可以使用文字创建，分配给变量和属性，并在其他函数中用作参数和返回值。</p><p id="487f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以像JavaScript中的其他表达式一样考虑函数，因为它们是如此基本的实体。总是另一个语句的一部分的语句称为函数表达式。它们很有帮助，因为它们允许我们准确地在需要的地方声明函数，使我们的代码更容易理解。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="549c" class="nc lz in my b gy nd ne l nf ng">//Standalone function declaration<br/>function myTestDeclarations(){<br/>    // inner function declaration<br/>    function innerFunction(){}<br/>}<br/></span><span id="7e77" class="nc lz in my b gy nh ne l nf ng">// function expressions<br/>const myFun = function() {};</span><span id="3ead" class="nc lz in my b gy nh ne l nf ng">//call function expression, with function expression as return value <br/>myFun(function () { return function (){}})</span><span id="debb" class="nc lz in my b gy nh ne l nf ng">//named function expression as part of function call<br/>( function <strong class="my io">namedFunctionExpression</strong>() {})();</span></pre><h2 id="9a2f" class="nc lz in bd ma ni nj dn me nk nl dp mi kx nm nn mk lb no np mm lf nq nr mo ns bi translated"><strong class="ak"> 2.2箭头函数(或λ函数)</strong></h2><p id="5f0c" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">JavaScript标准的最新增强ES6允许我们用更少的语法负担来定义函数。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="3000" class="nc lz in my b gy nd ne l nf ng">const values = [0,2,5,3,9,6,8,7]<br/>values.sort(function(v0, v1){<br/>   return v0 - v1<br/>})</span></pre><p id="82f0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个例子使用了一个回调函数表达式发送给array对象的sort方法:这个回调函数将被JavaScript调用，以降序对数组的值进行排序。</p><p id="2d61" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们用箭头函数来做这个例子:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="9a35" class="nc lz in my b gy nd ne l nf ng">const values = [0,2,5,3,9,6,8,7]<br/>values.sort((v0, v1) =&gt; v0 - v1)</span></pre><p id="86df" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">function关键字、括号和return语句不会增加任何混乱。arrow函数声明:这个函数接受两个参数，并以比函数表达式更简单的形式返回它们的差。注意一个新的操作符<strong class="kq io"> = &gt; </strong>是如何引入的，即所谓的胖箭头操作符(等号后面紧跟一个大于号)，它对于构建箭头函数是必不可少的。</p><h2 id="2e27" class="nc lz in bd ma ni nj dn me nk nl dp mi kx nm nn mk lb no np mm lf nq nr mo ns bi translated"><strong class="ak"> 2.3函数构造器</strong></h2><p id="eb2c" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">一种不常使用的函数定义方式，它使我们能够从一个也可以动态生成的字符串中动态构造一个新函数。此示例动态创建了一个带有两个参数a和b的函数，该函数返回这两个参数的和:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="6fb0" class="nc lz in my b gy nd ne l nf ng">new Function('a', 'b', 'return a+b')</span></pre><div class="nu nv gp gr nw nx"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd io gy z fp oc fr fs od fu fw im bi translated">Function()构造函数- JavaScript | MDN</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">函数构造器创建一个新的函数对象。直接调用构造函数可以创建函数…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">developer.mozilla.org</p></div></div><div class="og l"><div class="oh l oi oj ok og ol km nx"/></div></div></a></div><h2 id="472b" class="nc lz in bd ma ni nj dn me nk nl dp mi kx nm nn mk lb no np mm lf nq nr mo ns bi translated"><strong class="ak"> 2.4发电机功能</strong></h2><p id="817e" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">ES6对JavaScript的这一创新允许我们编写不同于常规函数的函数，这些函数可以在应用程序执行过程中的任何时候离开和重新进入，同时保持它们的变量值。<br/>函数声明、函数表达式、函数构造器都可以定义为生成器:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="4789" class="nc lz in my b gy nd ne l nf ng">function* tesGen(){ yield 1; }</span></pre><p id="93fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以在本文中阅读关于生成器函数的更多内容:</p><div class="nu nv gp gr nw nx"><a href="https://medium.com/@shriomtripathi33/the-alchemy-of-javascript-generators-f58e81c9f269" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd io gy z fp oc fr fs od fu fw im bi translated">JavaScript生成器的魔力</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这是JavaScript函数第2部分的延续</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol km nx"/></div></div></a></div><h1 id="0cac" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">3.参数赋值的真实性</h1><p id="5c13" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">在讨论函数时，我们通常互换使用实参和形参这两个词，就好像它们是同一个词一样。<br/>现在，让我们变得正式一点:</p><ul class=""><li id="32c1" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mw lq lr ls bi translated"><em class="mv">参数</em>是我们作为函数定义的一部分列出的变量。</li><li id="ab40" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj mw lq lr ls bi translated">一个<em class="mv">参数</em>是我们在调用函数时传递给它的一个值。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi on"><img src="../Images/1b5f38f875b9dbaa0e14dbf132270560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ovR9v2B33NZaxYNQFOwPJQ.jpeg"/></div></figure><p id="a3f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如您所见，函数参数是用函数的定义来指定的，所有类型的函数都可以有参数:</p><ul class=""><li id="c2a1" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mw lq lr ls bi translated">函数声明</li><li id="ee2e" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj mw lq lr ls bi translated">函数表达式</li><li id="bb72" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj mw lq lr ls bi translated">箭头功能</li></ul><p id="9cc0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一方面，参数与函数调用相关联；它们是在调用函数时提供给函数的值。当一个函数调用包含一个实参列表时，实参按照指定的顺序被分配给函数定义的形参。第一个参数与第一个参数相关联，第二个参数与第二个参数相关联，依此类推。<br/>参数个数超过形参个数没有错误。这种情况对JavaScript来说完全没问题，它以下面的方式处理。当实参多于形参时，不会将“额外”实参赋给形参名。</p><h2 id="c301" class="nc lz in bd ma ni nj dn me nk nl dp mi kx nm nn mk lb no np mm lf nq nr mo ns bi translated"><strong class="ak"> 3.1休息参数</strong></h2><p id="62d4" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">其余参数以<code class="fe oo op oq my b">…</code>为前缀</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi or"><img src="../Images/8cc4bc471c2c6ca9826c8780a1ab5ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*0_zxlOwEXjRmhvES1Xw_eQ.jpeg"/></div></figure><p id="6e83" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们通过在函数的最后一个参数前面加一个省略号(…)将它改为一个名为remainder parameters的数组，该数组包含其余传入的参数。</p><p id="3983" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">rest参数只能用作最后一个函数参数。试图将省略号放在任何不是最后一个的参数前面只会导致失望。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="bedc" class="nc lz in my b gy nd ne l nf ng">SyntaxError: parameter after rest parameter</span></pre><h2 id="ef5a" class="nc lz in bd ma ni nj dn me nk nl dp mi kx nm nn mk lb no np mm lf nq nr mo ns bi translated"><strong class="ak"> 3.2默认参数</strong></h2><p id="72d5" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">如下表所示，ES6标准现在包括对默认参数的支持。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi os"><img src="../Images/4c359e8a8716457ae5b352b118eb1c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRjEPiFC7Gcv5RkpjhaxLQ.jpeg"/></div></div></figure><p id="5a57" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript中默认函数参数的语法如下所示。<br/>我们给一个函数参数赋值来创建一个默认参数。</p><p id="f286" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以给默认参数任何我们想要的值:简单的原始值，如数字或文本，以及更复杂的类型，如对象、数组，甚至函数。在每个函数调用中，这些值是从左到右进行评估的，我们可以在为后面的默认参数提供值时引用前面的默认参数，如下面的清单所示。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="5ae7" class="nc lz in my b gy nd ne l nf ng">// <strong class="my io">We can place arbitrary expressions as default parameter values, in the process even referencing previous function parameters.</strong></span><span id="12ec" class="nc lz in my b gy nh ne l nf ng">function performSomeThing(<br/>  p0, <br/>  something = 'schooling', <br/>  somewhere = p0 + " "+ something<br/>) {<br/>   return somewhere;<br/>}</span></pre><p id="d2b3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">尽管JavaScript允许我们做类似的事情，我还是建议谨慎。在我们看来，这并不能提高代码的可读性，应该尽可能避免。然而，明智地使用缺省参数——作为避免空值的一种方式，或者作为设置函数行为的相对基本的标志——可以产生更干净、更优雅的代码。</p><p id="2f21" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些都是关于函数的。我希望你已经发现这是有用的。感谢您的阅读。</p><p id="fcce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mv">更多内容请看</em><a class="ae ot" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mv">plain English . io</em></strong></a><em class="mv">。报名参加我们的</em> <a class="ae ot" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mv">免费周报</em> </strong> </a> <em class="mv">。关注我们关于</em><a class="ae ot" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mv">Twitter</em></strong></a><em class="mv">和</em><a class="ae ot" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mv">LinkedIn</em></strong></a><em class="mv">。加入我们的</em> <a class="ae ot" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mv">社区不和谐</em> </strong> </a> <em class="mv">。</em></p></div></div>    
</body>
</html>