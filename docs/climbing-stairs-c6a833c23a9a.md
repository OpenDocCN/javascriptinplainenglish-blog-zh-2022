# LeetCode:爬楼梯问题

> 原文：<https://javascript.plainenglish.io/climbing-stairs-c6a833c23a9a?source=collection_archive---------6----------------------->

LeetCode #70，JavaScript

![](img/9c32b691b61e43a208ad87374e1d58a9.png)

今天我开始探索动态编程，解决 LeetCode 的[爬楼梯](https://leetcode.com/problems/climbing-stairs/)问题。

这个概念很简单，我们会得到一个 n 级楼梯。我们可以一次走一两步，我们需要返回我们可以登上楼梯的独特方式的数量。

所以，如果给我们一个只有两级台阶高的楼梯，我们可以用两种方式爬上去—

每个步骤单独进行，或两个步骤同时进行。我们在这里的返回值是 2。

谁知道有多少方法可以解决这个问题。我认为使用置换框架，或者甚至通过一些费力的嵌套迭代工作，这是可以解决的。

但是我的最终目标和 Leetcode 问题是一样的——理解我面前事物最简单、最基本的本质。在几次没有结果的尝试之后，我意识到从第 0 步开始，解决方案的数量有上升的趋势…

1 步= 1

两步= 2

3 步= 3

4 步= 5 步

5 步= 8 步…

***惊喜！****……这是一个斐波那契数列*

这就是说，每一步的解，就是前两步的解的数量。(步骤 3 有步骤 1 +步骤 2 的解决方案数)

所以我们的子问题是 1 步和 2 步的解。从这里，我们可以得到此后任何一步的解的数目。

那么，为什么不实现一个斐波纳契函数，并完成它。

毕竟，这很简单，也实现了我们的目标。从技术上讲，这是可行的。然而，由于递归涉及的所有开销，您可能会从 Leetcode 得到一个超时。

在这种情况下，基本的迭代方法是有效的:

但是这个问题的目的之一就是练习动态编程或者记忆。

我听到这些术语几乎可以互换，但在解决这个问题时，我真的想抓住它们的区别。

**记忆化**

记忆是一种技术，我们把以前的计算结果储存起来以备将来使用。

因此，让我们改变上面的递归方法来做到这一点。

所以，现在我们将在每次递归调用的返回中添加备忘录。

值得一提的是，当用递归解决爬楼梯问题时，我是这样想的——我们实际上是从最高的一级开始下降。

在第 5 行，当进行第一次 climbStairs 递归调用时，我们将继续打开新的执行上下文，直到我们从原始 memo ([0，1])中返回一个值。然后，这些上下文将开始关闭并建立我们的备忘录。

从现在开始，我们可以通过访问这些先前存储的值来减少大量的递归函数调用。

**动态编程**

现在，正如我所读到的，动态编程是当一个人使用制表或记忆迭代地解决一个递归问题。为了保持简洁，我不会深入探究其中的区别。可以说，记忆(如上面的例子所示)最终采用了自顶向下的方法，向下处理子问题。

另一方面，制表是一种自下而上的方法，首先解决子问题，然后用它们来构建最终的解决方案。

现在，我们从“最底层”开始，一路上缓存计算，减少工作负载，并逐步达到我们的目标。

***速度试炼***

哪一种更快——递归记忆还是使用制表的动态编程方法？

为了回答这个问题，我设置了一些 performance.now()调用来用特别大的参数来计时每个函数。我能传递给递归函数的最大值是~7000，而不超过最大调用堆栈，所以这是我的限制因素。

有了这个输入大小，动态方法能够比递归(memoized)版本快 5.6 倍。

这足以让我相信，我需要投入更多的时间来让动态编程成为我技能集中的一项熟悉的技术。

*更多内容见于*[](https://plainenglish.io/)**。报名参加我们的* [***免费周报***](http://newsletter.plainenglish.io/) *。* [***推特***](https://twitter.com/inPlainEngHQ) 和 [***领英***](https://www.linkedin.com/company/inplainenglish/) *上跟随我们。加入我们的* [***社群不和***](https://discord.gg/GtDtUAvyhW) *。**