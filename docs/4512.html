<html>
<head>
<title>Summarizing several JavaScript async solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">总结几种JavaScript异步解决方案</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/summarizing-several-javascript-async-solutions-dd4a0fe2a99c?source=collection_archive---------11-----------------------#2022-12-09">https://javascript.plainenglish.io/summarizing-several-javascript-async-solutions-dd4a0fe2a99c?source=collection_archive---------11-----------------------#2022-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="02ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript异步解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e44a6425d508fe61d217c7301549138f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBReFtzP3Jx3cvx7LeRBfA.jpeg"/></div></div></figure><h2 id="baa6" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.回收</h2><p id="b4a6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">回调简单地理解为一个函数作为参数传递给另一个函数。回调是早期最常用的异步解决方案之一。</p><p id="5b46" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">回调不一定是异步的，也不直接相关。</p><p id="ad29" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">举个简单的例子:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="6726" class="mq ks iq mm b be mr ms l mt mu">function f1(cb) {<br/>  setTimeout(() =&gt; {<br/>    cb &amp;&amp; cb();<br/>  }, 2000);<br/>}<br/><br/>f1(() =&gt; {<br/>  console.log("1");<br/>});</span></pre><p id="8471" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">如上，我们使用setTimeout模拟函数f1中的一个任务，该任务占用2s，在耗时任务结束时抛出一个回调，这样我们就可以调用它，使得回调函数在函数f1中耗时任务结束时执行。这样，我们就把同步操作变成了异步操作。f1不会阻塞程序，相当于先执行程序的主逻辑，推迟执行耗时的操作。</p><p id="1b5c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">回调利弊</strong></p><p id="cd7c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">优点:简单，易懂。</p><p id="ab76" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">缺点:代码不雅，可读性差，不易维护，高度耦合，层层嵌套造成回调地狱。</p><h2 id="548a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.事件监听(发布-订阅模式)</h2><p id="fe52" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">发布-订阅模式定义了对象之间的一对多依赖关系，这样当一个对象的状态改变时，所有依赖于它的对象都会得到通知。</p><p id="11ea" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们都使用过发布-订阅模式，例如，如果我们将一个事件函数绑定到一个DOM节点。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="f239" class="mq ks iq mm b be mr ms l mt mu">document.body.addEventListener('click', function () {<br/>  console.log('click');<br/>})</span></pre><p id="440a" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">但这只是发布-订阅模式最简单的应用，在许多场景中，我们经常使用一些自定义事件来满足我们的需求。</p><p id="1538" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">有许多方法可以实现发布-订阅模式，所以这里有一个使用class的简单实现。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="7371" class="mq ks iq mm b be mr ms l mt mu">class Emitter {<br/>  constructor() {<br/>    // _listener array, key is the custom event name, value is the execution callback array - as there may be more than one<br/>    this._listener = []<br/>  }<br/><br/>  // 订阅 监听事件<br/>  on(type, fn) {<br/>    // Determine if the event exists in the _listener array.<br/>    // Exists to push the callback to the value array corresponding to the event name, does not exist to add directly<br/>    this._listener[type] <br/>      ? this._listener[type].push(fn) <br/>     : (this._listener[type] = [fn])<br/>  }<br/><br/>  // Publish Trigger Event<br/>  trigger(type, ...rest) {<br/>    // Determine if the trigger event exists<br/>    if (!this._listener[type]) return<br/>    // Iterate through the array of callbacks executing the event and pass the parameters<br/>    this._listener[type].forEach(callback =&gt; callback(...rest))<br/>  }<br/>}</span></pre><p id="0620" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">如上所示，我们使用下面的代码创建了一个发射器类，并在和trigger上添加了两个原型方法。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="3223" class="mq ks iq mm b be mr ms l mt mu">// Create an emitter instance<br/>const emitter = new Emitter()<br/><br/>emitter.on("done", function(arg1, arg2) {<br/>  console.log(arg1, arg2)<br/>})<br/><br/>emitter.on("done", function(arg1, arg2) {<br/>  console.log(arg2, arg1)<br/>})<br/><br/>function fn1() {<br/>  console.log('I am the main program')<br/>  setTimeout(() =&gt; {<br/>    emitter.trigger("done", "Asynchronous parameter I", "Asynchronous parameter II")<br/>  }, 1000)<br/>}<br/><br/>fn1()</span></pre><p id="2e8c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们先创建一个发射器实例，然后注册事件，再触发事件，这样也解决了异步问题。</p><p id="fb6c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">事件聆听的利弊</strong></p><p id="6901" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">优点:它更符合模块化的思想，我们可以在编写自己的监听器时做很多优化，以便更好地监控程序的运行。</p><p id="f433" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">缺点:整个程序变成事件驱动，流程或多或少受到影响，每次使用都要注册事件监听器再触发，相当麻烦，代码也不是很优雅。</p><h2 id="40ea" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">3.承诺</h2><p id="e7cd" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">ES6标准化并引入了Promise对象，这是一个异步编程的解决方案。</p><p id="8a91" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">简单来说就是用同步的方式写异步代码，可以用来解决回调地狱问题。</p><p id="b394" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">许诺对象的状态一旦发生变化，就不会再发生变化，只有两种可能的变化。</p><blockquote class="mv mw mx"><p id="f62b" class="ln lo my lp b lq mg jr ls lt mh ju lv mz mi lx ly na mj ma mb nb mk md me mf ij bi translated">1.已从待定更改为已解决。</p><p id="4d95" class="ln lo my lp b lq mg jr ls lt mh ju lv mz mi lx ly na mj ma mb nb mk md me mf ij bi translated">2.已从待定更改为已拒绝。</p></blockquote><p id="78b5" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们使用setTimeout来模拟异步操作。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="b688" class="mq ks iq mm b be mr ms l mt mu">function analogAsync(n) {<br/>  return new Promise((resolve) =&gt; {<br/>    setTimeout(() =&gt; resolve(n + 500), n);<br/>  });<br/>}<br/><br/>function fn1(n) {<br/>  console.log(`step1 with ${n}`);<br/>  return analogAsync(n);<br/>}<br/><br/>function fn2(n) {<br/>  console.log(`step2 with ${n}`);<br/>  return analogAsync(n);<br/>}<br/><br/>function fn3(n) {<br/>  console.log(`step3 with ${n}`);<br/>  return analogAsync(n);<br/>}</span></pre><p id="ab38" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">用承诺去实现。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="aeeb" class="mq ks iq mm b be mr ms l mt mu">function fn() {<br/>  let time1 = 0;<br/>  fn1(time1)<br/>    .then((time2) =&gt; fn2(time2))<br/>    .then((time3) =&gt; fn3(time3))<br/>    .then((res) =&gt; {<br/>      console.log(`result is ${res}`);<br/>    });<br/>}<br/><br/>fn();</span></pre><p id="c5f2" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">承诺优缺点</strong></p><p id="6239" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">优点:Promise以同步方式编写异步代码，避免了多层嵌套回调函数，可读性更好。链式操作，可以在then中继续写Promise对象并返回，然后继续调用then进行回调操作。<br/>缺点:承诺对象一旦创建就立即执行，中途不能取消。如果没有设置回调函数，Promise会在内部抛出错误，不会对外流动。</p><h2 id="cc8e" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">4.发电机</h2><p id="80c3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">生成器实际上是一个函数，但它是一个特殊的函数。发电机的特别之处在于它可以中途停止。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="5906" class="mq ks iq mm b be mr ms l mt mu">function *generatorFn() {<br/>  console.log("a");<br/>  yield '1';<br/>  console.log("b");<br/>  yield '2'; <br/>  console.log("c");<br/>  return '3';<br/>}<br/><br/>let it = generatorFn();<br/>it.next();<br/>it.next();<br/>it.next();<br/>it.next();</span></pre><p id="5d14" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">上面的例子是一个具有以下特征的生成器函数。</p><ul class=""><li id="b4da" class="nc nd iq lp b lq mg lt mh la ne le nf li ng mf nh ni nj nk bi translated">与普通函数不同，生成器函数在函数后和函数名前有一个*</li><li id="c0fc" class="nc nd iq lp b lq nl lt nm la nn le no li np mf nh ni nj nk bi translated">该函数有一个内部<code class="fe nq nr ns mm b">yield </code>字段</li><li id="1bbf" class="nc nd iq lp b lq nl lt nm la nn le no li np mf nh ni nj nk bi translated">调用后函数的返回值使用<code class="fe nq nr ns mm b">next </code>方法。</li></ul><p id="6fd1" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">发电机优缺点</strong></p><p id="64ab" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">优点</strong>:优雅的流量控制方式，允许中断执行功能。</p><p id="ee5c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">缺点</strong>:生成器函数的执行必须依赖执行器，只做异步处理还是不太方便。</p><h2 id="65ac" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">5.异步/等待</h2><p id="71a2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">ES2017标准引入了异步功能，使异步操作更加方便。async的意思是异步，await是async wait的简写，也就是异步等待。async/await被许多人认为是js中异步操作的终极和最优雅的解决方案。</p><p id="1221" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe nq nr ns mm b">async </code>在做什么？</p><p id="1f71" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">异步函数返回一个Promise对象。如果在async函数中直接返回直接数量，async将通过Promise.resolve()将直接数量包装在Promise对象中。</p><p id="a48f" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe nq nr ns mm b">await</code>，还在等什么？</p><p id="2647" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">await是一个表达式，它的计算结果是一个Promise对象或其他值(换句话说，没有任何特殊限定)。</p><ul class=""><li id="e8dc" class="nc nd iq lp b lq mg lt mh la ne le nf li ng mf nh ni nj nk bi translated">如果await后面没有Promise对象，它将被直接执行</li><li id="9320" class="nc nd iq lp b lq nl lt nm la nn le no li np mf nh ni nj nk bi translated">如果await后面跟着一个Promise对象，它会阻塞后面的代码，Promise对象解析，然后获取resolve的值作为await表达式的结果。</li><li id="b7ff" class="nc nd iq lp b lq nl lt nm la nn le no li np mf nh ni nj nk bi translated">await只能在异步函数中使用</li></ul><p id="8468" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">上面用setTimeout模拟异步操作，我们用async/await来实现。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="d170" class="mq ks iq mm b be mr ms l mt mu">async function fn() {<br/>  let time1 = 0;<br/>  let time2 = await fn1(time1);<br/>  let time3 = await fn2(time2);<br/>  let res = await fn3(time3);<br/>  console.log(`result is ${res}`);<br/>}<br/><br/>fn();</span></pre><p id="3f81" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">输出与上面的Promise实现相同，但是async/await代码结构看起来更清晰，几乎与同步编写一样优雅。</p><p id="14ad" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">异步/等待优缺点</strong></p><p id="dab7" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">优点</strong>:内置执行器，语义更好，适用性更广</p><p id="f917" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">缺点</strong>:误用await可能会导致性能问题，因为await会阻塞代码。</p><p id="d264" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><em class="my">更多内容请看</em><a class="ae nt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">plain English . io</em></strong></a><em class="my">。</em></p><p id="fb46" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><em class="my">报名参加我们的</em> <a class="ae nt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="my">免费每周简讯</em> </strong> </a> <em class="my">。关注我们关于</em> <a class="ae nt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="my">推特</em></strong></a><a class="ae nt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">LinkedIn</em></strong></a><em class="my"/><a class="ae nt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">YouTube</em></strong></a><em class="my"/><a class="ae nt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"><em class="my">不和</em> </strong> </a> <strong class="lp ir"> <em class="my">。</em>T51】</strong></p><p id="d6e8" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir"> <em class="my">对缩放您的软件启动感兴趣</em> </strong> <em class="my">？检查</em> <a class="ae nt" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="my">电路</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>