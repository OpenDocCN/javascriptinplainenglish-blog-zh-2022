<html>
<head>
<title>Create a Websocket Server in Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Vue.js中创建一个Websocket服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-websocket-server-in-vue-js-acfe8df9ebb1?source=collection_archive---------14-----------------------#2022-02-04">https://javascript.plainenglish.io/creating-a-websocket-server-in-vue-js-acfe8df9ebb1?source=collection_archive---------14-----------------------#2022-02-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fd51c3ba28473fe8c1ffe363f9959d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkPZlQKMp_wrPxnrocrfFw.png"/></div></div></figure><p id="dcd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用websocket服务器是加速应用程序的一个好方法。API天生就有自己的HTTP开销，这意味着每次你调用一个API时，你都必须等待一会儿HTTP响应。</p><p id="059d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这基本上没问题，但是如果您的应用程序有很多对时间敏感的、频繁的服务器请求，这可能会成为一个问题。一个很好的例子是聊天应用程序，你需要立即看到对方在说什么。在这种情况下，API仍然可以工作，但是它不是最佳的解决方案。</p><p id="43d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们将介绍如何在Vue中设置一个websocket服务器。JS，使用Node.js和Express内置的websocket服务器。请继续阅读。我还在这里写了另一篇关于如何用Express和JavaScript<a class="ae kt" href="https://fjolt.com/article/javascript-websockets" rel="noopener ugc nofollow" target="_blank">创建websocket服务器的教程。</a></p><h1 id="ef68" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">入门:创建您的Vue应用程序</h1><p id="ab6d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">像往常一样，使用Vue CLI启动Vue应用程序。例如，编写以下代码来生成一个名为“fjolt-app”的Vue应用程序:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="953f" class="mg kv in mc b gy mh mi l mj mk">vue create fjolt-app</span></pre><p id="f4be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这不起作用，请尝试通过npm安装Vue CLI工具。这个包可以在<a class="ae kt" href="https://www.npmjs.com/package/@vue/cli" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="a1e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你是Vue的新手，你可以在你创建应用程序的目录下运行<code class="fe ml mm mn mc b">npm run serve</code>来启动这个虚拟应用程序。</p><h1 id="1752" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建websocket服务器</h1><p id="7fd9" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">下一步是创建一个websocket服务器。如前所述，<a class="ae kt" href="https://fjolt.com/article/javascript-websockets" rel="noopener ugc nofollow" target="_blank">我在这里写了一篇关于如何做到这一点的深入教程。</a>总之，您需要创建一个index.js文件。为了使事情更简单，我在Vue目录中创建了自己的文件，并将其命名为index.mjs，这样我就可以立即使用import语句。</p><p id="3af2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的文件结构是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="573e" class="mg kv in mc b gy mh mi l mj mk">| - node_modules<br/>| - package.lock.json<br/>| - package.json<br/>| - public<br/>| - README.md<br/>| - src<br/>  | - App.vue &lt; -- Our app!<br/>  | - assets<br/>  | - components<br/>  | - main.js<br/>| - index.mjs &lt;-- Our websocket server</span></pre><h1 id="302f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用Javascript创建我们的websocket服务器</h1><p id="d8cb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">接下来，让我们创建websocket索引文件。在<code class="fe ml mm mn mc b">index.mjs</code>中，如果你感到懒惰，你可以使用下面的代码。不要忘记<code class="fe ml mm mn mc b">npm i</code>你导入的所有模块。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e154" class="mg kv in mc b gy mh mi l mj mk"><strong class="mc io">import</strong> path <strong class="mc io">from</strong> 'path'<br/>    <strong class="mc io">import</strong> { fileURLToPath } <strong class="mc io">from</strong> 'url'<br/>    <br/>    <strong class="mc io">const</strong> __filename = <strong class="mc io"><em class="mo">fileURLToPath</em></strong>(<strong class="mc io">import</strong>.meta.url);<br/>    <strong class="mc io">const</strong> __dirname = path.<strong class="mc io"><em class="mo">dirname</em></strong>(__filename);<br/>    <br/>    <strong class="mc io">import</strong> express <strong class="mc io">from</strong> 'express'<br/>    <strong class="mc io">import</strong> expressWs <strong class="mc io">from</strong> 'express-ws'<br/>    <strong class="mc io">import</strong> http <strong class="mc io">from</strong> 'http'<br/>    <br/>    // Our port<br/>    <strong class="mc io">let</strong> port = <strong class="mc io">3000</strong>;<br/>    <br/>    // App and server<br/>    <strong class="mc io">let</strong> app = <strong class="mc io"><em class="mo">express</em></strong>();<br/>    <strong class="mc io">let</strong> server = http.<strong class="mc io"><em class="mo">createServer</em></strong>(app).<strong class="mc io"><em class="mo">listen</em></strong>(port);    <br/>    <br/>    // Apply expressWs<br/>    <strong class="mc io"><em class="mo">expressWs</em></strong>(app, server);<br/>    <br/>    app.<strong class="mc io"><em class="mo">use</em></strong>(express.<strong class="mc io"><em class="mo">static</em></strong>(__dirname + '/views'));<br/>    <br/>    // Get the route / <br/>    app.<strong class="mc io"><em class="mo">get</em></strong>('/', (req, res) =&gt; {<br/>        res.<strong class="mc io"><em class="mo">status</em></strong>(<strong class="mc io">200</strong>).<strong class="mc io"><em class="mo">send</em></strong>("Welcome to our app");<br/>    });<br/>    <br/>    // Get the /ws websocket route<br/>    app.<strong class="mc io"><em class="mo">ws</em></strong>('/ws', <strong class="mc io">async</strong> <strong class="mc io">function</strong>(ws, req) {<br/>        ws.<strong class="mc io"><em class="mo">on</em></strong>('message', <strong class="mc io">async</strong> <strong class="mc io">function</strong>(msg) {<br/>            <strong class="mc io"><em class="mo">console</em></strong>.<strong class="mc io"><em class="mo">log</em></strong>(msg);            <br/>            ws.<strong class="mc io"><em class="mo">send</em></strong>(<strong class="mc io"><em class="mo">JSON</em></strong>.<strong class="mc io"><em class="mo">stringify</em></strong>({ "message" : "hello" }));<br/>            // Start listening for messages<br/>        });<br/>    });</span></pre><p id="3ee6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以客户端会将数据发送到我们的websocket服务器。该数据将作为<code class="fe ml mm mn mc b">msg</code>变量到达，如上面代码的底部所示。然后，我们可以获取消息数据，存储或处理它。有时，我们可能希望将它发送到数据库。其他时候，我们可能想把它发送给用户。</p><p id="ea8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论哪种方式，在<code class="fe ml mm mn mc b">ws.on</code>中，我们都可以将消息发送回客户端。比方说，当收到一条消息时，我想向用户发回一个写着<code class="fe ml mm mn mc b">{ "message" : "hello" }</code>的对象。为此，我会执行以下操作:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="f627" class="mg kv in mc b gy mh mi l mj mk">// Get the /ws websocket route<br/>    app.<strong class="mc io"><em class="mo">ws</em></strong>('/ws', <strong class="mc io">async</strong> <strong class="mc io">function</strong>(ws, req) {<br/>        ws.<strong class="mc io"><em class="mo">on</em></strong>('message', <strong class="mc io">async</strong> <strong class="mc io">function</strong>(msg) {<br/>            // Let's put our message in JSON.stringify, and send it to the user who just sent the message<br/>            ws.<strong class="mc io"><em class="mo">send</em></strong>(<strong class="mc io"><em class="mo">JSON</em></strong>.<strong class="mc io"><em class="mo">stringify</em></strong>({ "message" : "hello" }));<br/>        });<br/>    });</span></pre><p id="68e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们对我们的websocket服务器满意时，我们可以在index.mjs所在的目录中，通过键入<code class="fe ml mm mn mc b">node index.mjs</code>在终端中运行它。现在我们有了一个可以连接的活动websocket。</p><p id="d97f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，我们现在有了一种方法，可以在我们的服务器和用户之间建立直接的连接，基本上是即时的消息传递。现在我们已经解决了这个问题，我们需要能够从Vue发送和接收数据。接下来让我们来看看。</p><h1 id="2411" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">向Vue.js添加websocket</h1><p id="a759" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">打开src文件夹中的App.vue。编辑JavaScript，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1cfd" class="mg kv in mc b gy mh mi l mj mk"><strong class="mc io">export</strong> <strong class="mc io">default</strong> {<br/>    name: 'App',<br/>    <strong class="mc io"><em class="mo">data</em></strong>() {<br/>        <strong class="mc io">return</strong> {<br/>            socket: {},<br/>            connectedStatus: 'Not connected!',<br/>            message: 'No message yet!'<br/>        }<br/>    },<br/>    <strong class="mc io">async</strong> <strong class="mc io"><em class="mo">mounted</em></strong>() {<br/>        // Calculate the URL for the websocket. If you have a fixed URL, then you can remove all this and simply put in<br/>        // ws://your-url-here.com or wss:// for secure websockets.<br/>        <strong class="mc io">const</strong> socketProtocol = (window.location.protocol === 'https:' ? 'wss:' : 'ws:')<br/>        <strong class="mc io">const</strong> port = ':3000';<br/>        <strong class="mc io">const</strong> echoSocketUrl = socketProtocol + '//' + window.location.hostname + port + '/ws'<br/>    <br/>        // Define socket and attach it to our data object<br/>        <strong class="mc io">this</strong>.socket = <strong class="mc io">await</strong> <strong class="mc io">new</strong> <strong class="mc io"><em class="mo">WebSocket</em></strong>(echoSocketUrl); </span><span id="6f10" class="mg kv in mc b gy mp mi l mj mk">        // When it opens, console log that it has opened. and send a message to the server to let it know we exist<br/>        <strong class="mc io">this</strong>.socket.<strong class="mc io"><em class="mo">onopen</em></strong> = () =&gt; {<br/>            <strong class="mc io"><em class="mo">console</em></strong>.<strong class="mc io"><em class="mo">log</em></strong>('Websocket connected.');<br/>            <strong class="mc io">this</strong>.connectedStatus = 'Connected';<br/>            <strong class="mc io">this</strong>.<strong class="mc io"><em class="mo">sendMessage</em></strong>(<strong class="mc io"><em class="mo">JSON</em></strong>.<strong class="mc io"><em class="mo">stringify</em></strong>({"message" : "Hello, server."}));<br/>        }</span><span id="8b50" class="mg kv in mc b gy mp mi l mj mk">        // When we receive a message from the server, we can capture it here in the onmessage event.<br/>        <strong class="mc io">this</strong>.socket.<strong class="mc io"><em class="mo">onmessage</em></strong> = (event) =&gt; {<br/>            // We can parse the data we know to be JSON, and then check it for data attributes<br/>            <strong class="mc io">let</strong> parsedMessage = <strong class="mc io"><em class="mo">JSON</em></strong>.<strong class="mc io"><em class="mo">parse</em></strong>(event.data);<br/>            // If those data attributes exist, we can then console log or show data to the user on their web page.<br/>            <strong class="mc io"><em class="mo">console</em></strong>.<strong class="mc io"><em class="mo">log</em></strong>(parsedMessage);<br/>            <strong class="mc io">if</strong>(<strong class="mc io">typeof</strong> parsedMessage.message !== "undefined" &amp;&amp; parsedMessage.message == "hello") {<br/>                <strong class="mc io">this</strong>.message = parsedMessage.message;<br/>                <strong class="mc io"><em class="mo">console</em></strong>.<strong class="mc io"><em class="mo">log</em></strong>('We have received a message from the server!')<br/>            }<br/>        }<br/>    },<br/>    methods: {<br/>        <strong class="mc io"><em class="mo">waitForOpenConnection</em></strong>: <strong class="mc io">function</strong>() {<br/>            // We use this to measure how many times we have tried to connect to the websocket server<br/>            // If it fails, it throws an error.<br/>            <strong class="mc io">return</strong> <strong class="mc io">new</strong> <strong class="mc io"><em class="mo">Promise</em></strong>((resolve, reject) =&gt; {<br/>                <strong class="mc io">const</strong> maxNumberOfAttempts = <strong class="mc io">10</strong><br/>                <strong class="mc io">const</strong> intervalTime = <strong class="mc io">200</strong> </span><span id="c2f5" class="mg kv in mc b gy mp mi l mj mk">                <strong class="mc io">let</strong> currentAttempt = <strong class="mc io">0</strong><br/>                <strong class="mc io">const</strong> interval = <strong class="mc io"><em class="mo">setInterval</em></strong>(() =&gt; {<br/>                    <strong class="mc io">if</strong> (currentAttempt &gt; maxNumberOfAttempts - <strong class="mc io">1</strong>) {<br/>                        <strong class="mc io"><em class="mo">clearInterval</em></strong>(interval)<br/>                        <strong class="mc io"><em class="mo">reject</em></strong>(<strong class="mc io">new</strong> <strong class="mc io"><em class="mo">Error</em></strong>('Maximum number of attempts exceeded.'));<br/>                    } <strong class="mc io">else</strong> <strong class="mc io">if</strong> (<strong class="mc io">this</strong>.socket.readyState === <strong class="mc io">this</strong>.socket.OPEN) {<br/>                        <strong class="mc io"><em class="mo">clearInterval</em></strong>(interval)<br/>                        <strong class="mc io"><em class="mo">resolve</em></strong>()<br/>                    }<br/>                    currentAttempt++<br/>                }, intervalTime)<br/>            })<br/>        },<br/>        <strong class="mc io"><em class="mo">sendMessage</em></strong>: <strong class="mc io">async</strong> <strong class="mc io">function</strong>(message) {<br/>            // We use a custom send message function, so that we can maintain reliable connection with the<br/>            // websocket server.<br/>            <strong class="mc io">if</strong> (<strong class="mc io">this</strong>.socket.readyState !== <strong class="mc io">this</strong>.socket.OPEN) {<br/>                <strong class="mc io">try</strong> {<br/>                    <strong class="mc io">await</strong> <strong class="mc io">this</strong>.<strong class="mc io"><em class="mo">waitForOpenConnection</em></strong>(<strong class="mc io">this</strong>.socket)<br/>                    <strong class="mc io">this</strong>.socket.<strong class="mc io"><em class="mo">send</em></strong>(message)<br/>                } <strong class="mc io">catch</strong> (err) { <strong class="mc io"><em class="mo">console</em></strong>.<strong class="mc io"><em class="mo">error</em></strong>(err) }<br/>            } <strong class="mc io">else</strong> {<br/>                <strong class="mc io">this</strong>.socket.<strong class="mc io"><em class="mo">send</em></strong>(message)<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="77f4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何创建Vue.js websocket服务器:细节</h1><p id="f6e3" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">虽然行内有注释，但让我们更详细地看一下。我们首先创建两个方法:</p><ul class=""><li id="d6d9" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">sendMessage —这是一个使用<code class="fe ml mm mn mc b">socket.send()</code>的自定义发送消息功能。唯一的区别是我们在发送之前测试了websocket服务器连接，省去了一点麻烦。</li><li id="cbf2" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">waitForOpenConnection —仅由sendMessage使用，它设置检查套接字连接的时间间隔，否则会引发错误。</li></ul><h1 id="2cac" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">将我们的套接字保存为数据</h1><p id="8bd6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">然后，我们在<code class="fe ml mm mn mc b">mounted()</code>中使用下面几行创建一个新的websocket连接。这意味着当应用程序被安装到浏览器窗口中时(或者当它被加载时)，我们创建一个新的websocket连接，然后通过将<code class="fe ml mm mn mc b">this.socket</code>设置为新的websocket服务器连接，将该连接附加到我们的<code class="fe ml mm mn mc b">data()</code>。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3952" class="mg kv in mc b gy mh mi l mj mk"><strong class="mc io">const</strong> socketProtocol = (window.location.protocol === 'https:' ? 'wss:' : 'ws:')<br/><strong class="mc io">const</strong> port = ':3000';<br/><strong class="mc io">const</strong> echoSocketUrl = socketProtocol + '//' + window.location.hostname + port + '/ws'</span><span id="e4cd" class="mg kv in mc b gy mp mi l mj mk">// Define socket and attach it to our data object<br/><strong class="mc io">this</strong>.socket = <strong class="mc io">await</strong> <strong class="mc io">new</strong> <strong class="mc io"><em class="mo">WebSocket</em></strong>(echoSocketUrl);</span></pre><p id="e9be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做的额外好处是，我们现在可以跨方法、观察器和所有其他类型的Vue功能引用我们的套接字。当我们的连接被创建时，我们添加两个事件。一个是检查套接字何时打开，另一个是中继消息。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6188" class="mg kv in mc b gy mh mi l mj mk">// When it opens, console log that it has opened. and send a message to the server to let it know we exist<br/>    <strong class="mc io">this</strong>.socket.<strong class="mc io"><em class="mo">onopen</em></strong> = () =&gt; {<br/>        <strong class="mc io"><em class="mo">console</em></strong>.<strong class="mc io"><em class="mo">log</em></strong>('Websocket connected.');<br/>        <strong class="mc io">this</strong>.connectedStatus = 'Connected';<br/>        <strong class="mc io">this</strong>.<strong class="mc io"><em class="mo">sendMessage</em></strong>(<strong class="mc io"><em class="mo">JSON</em></strong>.<strong class="mc io"><em class="mo">stringify</em></strong>({"message" : "Hello, server."}));<br/>    }</span><span id="f371" class="mg kv in mc b gy mp mi l mj mk">    // When we receive a message from the server, we can capture it here in the onmessage event.<br/>    <strong class="mc io">this</strong>.socket.<strong class="mc io"><em class="mo">onmessage</em></strong> = (event) =&gt; {<br/>        // We can parse the data we know to be JSON, and then check it for data attributes<br/>        <strong class="mc io">let</strong> parsedMessage = <strong class="mc io"><em class="mo">JSON</em></strong>.<strong class="mc io"><em class="mo">parse</em></strong>(event.data);<br/>        // If those data attributes exist, we can then console log or show data to the user on their web page.<br/>        <strong class="mc io"><em class="mo">console</em></strong>.<strong class="mc io"><em class="mo">log</em></strong>(parsedMessage);<br/>        <strong class="mc io">if</strong>(<strong class="mc io">typeof</strong> parsedMessage.message !== "undefined" &amp;&amp; parsedMessage.message == "hello") {<br/>            <strong class="mc io">this</strong>.message = parsedMessage.message;<br/>            <strong class="mc io"><em class="mo">console</em></strong>.<strong class="mc io"><em class="mo">log</em></strong>('We have received a message from the server!')<br/>        }<br/>    }</span></pre><p id="38d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">websocket创建者可能对<code class="fe ml mm mn mc b">onmessage</code>函数最感兴趣，因为来自服务器的数据就是在这里被处理的。我们之前创建的消息将到达这个事件，我们可以在页面上显示它。其他数据也可以在这里处理。</p><p id="ad07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我还创建了另外两个数据变量<code class="fe ml mm mn mc b">message</code>和<code class="fe ml mm mn mc b">connectedStatus</code>，所以我们可以在模板中使用它们来显示来自websocket服务器的响应:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1184" class="mg kv in mc b gy mh mi l mj mk">&lt;template&gt;<br/>    &lt;h2&gt;Welcome to Websockets&lt;/h2&gt;<br/>    &lt;p&gt;You are: {{ connectedStatus }}&lt;/p&gt;<br/>    &lt;p&gt;Your message is: {{ message }}&lt;/p&gt;<br/>&lt;/template&gt;</span></pre><h2 id="b3ad" class="mg kv in bd kw ne nf dn la ng nh dp le kg ni nj li kk nk nl lm ko nm nn lq no bi translated">我们的websocket服务器页面</h2><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/07f30c8b6bfab4f9be566ba9f796fe05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*600B2mGJrqkAfaGmWkHEQA.png"/></div></div></figure><h1 id="e9f6" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="c834" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Vue中的Websocket服务器实际上工作得相当优雅。在本教程中，我们已经涵盖了所有的基础知识。现在，您可以继续从websocket服务器向您的浏览器发送或接收数据。websockets带来的效率意味着你的网站看起来会更快，如果你从HTTP。</p><p id="4187" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">别忘了，在单独的终端窗口运行<code class="fe ml mm mn mc b">npm run serve</code>和<code class="fe ml mm mn mc b">node index.mjs</code>，这样你的websocket服务器和Vue.js应用都在运行。像往常一样，这里有一些有用的链接:</p><ul class=""><li id="fbc7" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated"><a class="ae kt" href="https://fjolt.com/article/javascript-websockets" rel="noopener ugc nofollow" target="_blank">制作websocket服务器的原始教程</a></li><li id="bc7e" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><a class="ae kt" href="https://github.com/smpnjn/vuejs-web-socket-server" rel="noopener ugc nofollow" target="_blank">本教程的git回购</a></li></ul><p id="6a90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mo">更多内容看</em> <a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mo">说白了就是</em> </strong> </a> <em class="mo">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mo">免费周报</em> </strong> </a> <em class="mo">。在我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mo">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="mo">。</em></p></div></div>    
</body>
</html>