<html>
<head>
<title>Web Components Can Now Be Native Form Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件现在可以是本机表单元素</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-components-can-now-be-native-form-elements-107c7a93386?source=collection_archive---------1-----------------------#2022-08-10">https://javascript.plainenglish.io/web-components-can-now-be-native-form-elements-107c7a93386?source=collection_archive---------1-----------------------#2022-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="43d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是定制表单控件的完整指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a2a64266a9dd589fdd0345685a0fde58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KVCSbG2s73vZzmwb"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@chrishainto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Hainto</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8b20" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">自定义表单控件</h1><p id="f139" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">开发人员一直想定制元素的一个领域是表单。</p><p id="b4da" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从历史上看，通常很难对窗体控件进行样式化，以使它们具有您想要的外观和感觉。</p><p id="c60e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">样式选项通常是有限的，直到今天，像日期和颜色选择器这样的表单控件在不同的浏览器中仍然不一致。</p><p id="cee5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">许多网站还需要更高级的表单控件，而本地平台还没有提供。</p><p id="051d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Web组件是定制表单控件的理想选择，因为它们是一流的HTML标签，但不幸的是，它们不提供开箱即用的内置表单控件的功能。</p><p id="5226" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，提交表单时，用自定义元素构建的自定义表单控件不包含在表单数据中。</p><p id="1737" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">表单验证和自动填充等其他功能也无法用于自定义元素，并且很难复制。</p><p id="4959" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">幸运的是，这些问题有两种解决方案:事件<code class="fe mp mq mr ms b">formdata</code>和接口<code class="fe mp mq mr ms b">ElementInternals</code>。</p><h1 id="4466" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">FormData事件</h1><p id="fb94" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">提交表单时会触发<code class="fe mp mq mr ms b">formdata</code>事件，该事件允许任何JavaScript代码向提交的表单数据中添加任意数据。</p><p id="59e9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以为这个事件设置一个事件监听器，它将接收带有<code class="fe mp mq mr ms b">formData</code>属性的事件对象，该属性包含表单提交的所有数据。</p><p id="1bf4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，每个事件侦听器可以在提交数据之前添加或修改数据:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="f90b" class="mx kx iq ms b gy my mz l na nb">const form = document.querySelector(‘form’);<br/>form.addEventListener(‘formdata’, ({formData}) =&gt; {</span><span id="e3a5" class="mx kx iq ms b gy nc mz l na nb">// add data<br/> formData.append(‘custom-control’, customValue);</span><span id="d0e9" class="mx kx iq ms b gy nc mz l na nb">// modify data<br/> formData.set(‘email’, formData.get(‘email’).toLowerCase());<br/>});</span></pre><p id="2cb8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">事件的<code class="fe mp mq mr ms b">formData</code>属性是一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank"> FormData </a>对象。</p><h1 id="865e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">元素内部接口</h1><p id="c845" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">虽然<code class="fe mp mq mr ms b">formData</code>事件非常方便，但它仅限于向表单提交的数据中添加任意数据。</p><p id="75c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要使自定义元素成为真正的表单控件，它还应该自动与表单关联并参与表单验证。</p><p id="4a8c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是<code class="fe mp mq mr ms b">ElementInternals</code>接口的用途。</p><p id="2f26" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它允许自定义元素与表单相关联，因此它们被添加到表单的<code class="fe mp mq mr ms b">elements</code>属性中，元素的值将自动与表单一起提交。</p><p id="3f71" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它还使自定义元素能够参与表单验证。</p><p id="3d78" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该元素可以指示其值是有效还是无效，并防止表单在无效时被提交。</p><p id="5e35" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它也可以用一个<code class="fe mp mq mr ms b">&lt;label&gt;</code>元素来标记，这意味着标签以编程方式与表单元素相关联。</p><p id="55ca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当用户单击或点击标签时，表单元素将获得焦点。</p><p id="6113" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这增加了关注提供良好用户体验的元素的区域，尤其是在移动设备上。</p><p id="9835" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当用户关注表单元素时，它还会使屏幕阅读器读出标签。</p><h1 id="793d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">将自定义元素与表单相关联</h1><p id="5b03" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">创建带有自定义元素的自定义窗体控件的第一步是将其与窗体相关联。</p><p id="221e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着它将是表单的<code class="fe mp mq mr ms b">elements</code>属性的一部分，该属性是一个包含表单包含的所有表单控件的<code class="fe mp mq mr ms b">HTMLFormControlsCollection</code>。</p><p id="ac63" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在前面的例子中，您已经看到了如何使用<code class="fe mp mq mr ms b">append</code>方法向<code class="fe mp mq mr ms b">FormData</code>对象添加条目。</p><p id="4bee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">也可以通过将表单传递给<code class="fe mp mq mr ms b">FormData</code>构造函数，直接从表单中的所有元素及其值创建一个<code class="fe mp mq mr ms b">FormData</code>对象:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="7cfc" class="mx kx iq ms b gy my mz l na nb">const form = document.querySelector(‘form’); </span><span id="5621" class="mx kx iq ms b gy nc mz l na nb">// formData now contains all data of form<br/>const formData = new FormData(form);</span></pre><p id="4b7f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mp mq mr ms b">formData</code>现在包含表单的所有数据，包括已经与表单关联的任何自定义元素。</p><p id="2c3a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是一个与表单相关的定制元素的<code class="fe mp mq mr ms b">class</code>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="77d2" class="mx kx iq ms b gy my mz l na nb">class FormInput extends HTMLElement {<br/>  static formAssociated = true;<br/> <br/>  constructor() {<br/>    super();<br/>    this.internals = this.attachInternals();<br/>  }</span><span id="b1ee" class="mx kx iq ms b gy nc mz l na nb">  get value() {<br/>    return this._value;<br/>  }</span><span id="d923" class="mx kx iq ms b gy nc mz l na nb">  set value(value) {<br/>    this._value = value;<br/>    this.internals.setFormValue(value);<br/>  }</span><span id="9250" class="mx kx iq ms b gy nc mz l na nb">  get form() {<br/>    return this.internals.form;<br/>  }<br/> <br/>  get name() {<br/>    return this.getAttribute(‘name’);<br/>  }<br/> <br/>  get type() {<br/>    return this.localName;<br/>  }<br/>}</span></pre><p id="78a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此示例显示了一个与窗体关联的自定义元素的最小实现。让我们来看看各个部分。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="b7b7" class="mx kx iq ms b gy my mz l na nb">static formAssociated = true;</span></pre><p id="e8ba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过将静态<code class="fe mp mq mr ms b">formAssociated</code>属性设置为<code class="fe mp mq mr ms b">true</code>，自定义元素将与表单相关联，并且将包含在表单的<code class="fe mp mq mr ms b">elements</code>属性中。</p><p id="5b50" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，这还不包括表单数据中自定义元素的值。</p><p id="ce70" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为此，需要将<code class="fe mp mq mr ms b">ElementInternals</code>接口附加到元素上:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0a5e" class="mx kx iq ms b gy my mz l na nb">this.internals = this.attachInternals();</span></pre><p id="85bd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mp mq mr ms b">attachInternals</code>返回<code class="fe mp mq mr ms b">ElementInternals</code>对象，然后存储在自定义元素的<code class="fe mp mq mr ms b">internals</code>属性中。</p><p id="5bee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了获得将与表单一起提交的自定义元素的值，需要使用以下内容来设置该值:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="f476" class="mx kx iq ms b gy my mz l na nb">this.internals.setFormValue(value);.</span></pre><p id="7151" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在示例中，这一行被添加到了<code class="fe mp mq mr ms b">value</code>属性的设置器中，以确保无论何时设置了<code class="fe mp mq mr ms b">value</code>，其表单值也将被设置。</p><p id="f813" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是将与表单一起提交的值。</p><p id="58b8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">用于<code class="fe mp mq mr ms b">form</code>、<code class="fe mp mq mr ms b">name</code>和<code class="fe mp mq mr ms b">type</code>的其他getters是本地表单元素所具有的标准属性。</p><p id="82cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nd">这是你的组件成为定制表单元素的最低要求。</em></p><p id="8ffb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当然，这个组件还没有呈现任何东西，所以它不是很有用。让我们通过添加一个带有<code class="fe mp mq mr ms b">&lt;input&gt;</code>元素的阴影根来改变它:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="75f2" class="mx kx iq ms b gy my mz l na nb">constructor() {<br/>  super();<br/>  this.internals = this.attachInternals();</span><span id="fe48" class="mx kx iq ms b gy nc mz l na nb">  const shadowRoot = this.attachShadow({mode: ‘open’});</span><span id="daf3" class="mx kx iq ms b gy nc mz l na nb">  shadowRoot.innerHTML = `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: inline-block;<br/>      }</span><span id="422d" class="mx kx iq ms b gy nc mz l na nb">      input {<br/>        display: block;<br/>        padding: 5px;<br/>      }<br/>    &lt;/style&gt;</span><span id="50be" class="mx kx iq ms b gy nc mz l na nb">    &lt;input type=”text”&gt;<br/> `;<br/>}</span></pre><p id="7ec3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">既然组件有了一个<code class="fe mp mq mr ms b">&lt;input&gt;</code>，我们首先需要确保输入的值可以作为表单中提交的组件的值。</p><p id="d024" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">回想一下，我们为调用<code class="fe mp mq mr ms b">this.internals.setFormValue(value)</code>的<code class="fe mp mq mr ms b">value</code>属性创建了一个setter。</p><p id="11c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以通过它的<code class="fe mp mq mr ms b">change</code>事件得到每次输入改变时的值。</p><p id="724b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当该事件被触发时，我们只需设置组件的<code class="fe mp mq mr ms b">value</code>属性，该属性将调用调用<code class="fe mp mq mr ms b">this.internals.setFormValue(value)</code>的setter。</p><p id="2c29" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们添加所需的事件监听器:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0433" class="mx kx iq ms b gy my mz l na nb">this.input = this.shadowRoot.querySelector(‘input’);</span><span id="98e3" class="mx kx iq ms b gy nc mz l na nb">this.input.addEventListener(‘change’, (e) =&gt; {<br/>  this.value = this.input.value;<br/>});</span></pre><p id="fa49" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，每次输入的值发生变化时，组件的值都会更新，正确的值会随表单一起提交。</p><p id="9ee1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当然，反过来也应该可以:当组件的<code class="fe mp mq mr ms b">value</code>属性被设置时，<code class="fe mp mq mr ms b">&lt;input&gt;</code>的<code class="fe mp mq mr ms b">value</code>属性也应该被设置。</p><p id="3a4a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">设置器应改为:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="094b" class="mx kx iq ms b gy my mz l na nb">set value(value) {<br/>  this._value = value;<br/>  this.input.value = value; // set the value of the input <br/>  this.internals.setFormValue(value);<br/>}</span></pre><p id="1813" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用我们组件的代码也将期望触发一个<code class="fe mp mq mr ms b">change</code>事件，因为它现在包含了一个<code class="fe mp mq mr ms b">&lt;input&gt;</code>元素。</p><p id="12e5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，来自<code class="fe mp mq mr ms b">&lt;input&gt;</code>的<code class="fe mp mq mr ms b">event</code>应该被转发。</p><p id="c4c3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们不能简单地再次调度它，因为这将抛出一个错误，表明事件已经被调度，但我们可以克隆它，然后转发它:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c23f" class="mx kx iq ms b gy my mz l na nb">this.input.addEventListener(‘change’, (e) =&gt; {<br/>  const clone = new e.constructor(e.type, e); // clone the event</span><span id="027e" class="mx kx iq ms b gy nc mz l na nb">  this.dispatchEvent(clone); // and then forward it</span><span id="b6fc" class="mx kx iq ms b gy nc mz l na nb">  this.value = this.input.value;<br/>});</span></pre><p id="4269" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在组件的值和输入保持同步，组件触发了一个<code class="fe mp mq mr ms b">change</code>事件。</p><h1 id="ed9d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">标记自定义窗体控件</h1><p id="35f2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">既然您已经将您的定制元素与表单相关联，那么您也可以将它与一个<code class="fe mp mq mr ms b">&lt;label&gt;</code>相关联。</p><p id="f416" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样做的好处是，自定义元素也将通过编程方式与标签相关联。</p><p id="3217" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着，例如，当用户聚焦输入时，屏幕阅读器将读出标签文本，并且当标签被点击或轻击时，相关联的输入将被聚焦。</p><p id="9794" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这增加了输入的触摸面积，使其更容易聚焦，尤其是在移动设备上。</p><p id="2ad2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有两种方法可以将表单控件与<code class="fe mp mq mr ms b">&lt;label&gt;</code>相关联。</p><p id="d5e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最简单的方法是将表单控件放在<code class="fe mp mq mr ms b">&lt;label&gt;</code>中。</p><p id="2c75" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这使得这种关联非常明显:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="fec9" class="mx kx iq ms b gy my mz l na nb">&lt;label&gt;<br/>  City<br/>  &lt;input type=”text” name=”city”&gt;<br/>&lt;/label&gt;</span></pre><p id="ebcf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一种方法是使用<code class="fe mp mq mr ms b">&lt;label&gt;</code>的<code class="fe mp mq mr ms b">for</code>属性。</p><p id="4692" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该属性的值应该是您要与之关联的表单控件的<code class="fe mp mq mr ms b">id</code>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="70c7" class="mx kx iq ms b gy my mz l na nb">&lt;label for=”city”&gt;City&lt;/label&gt;<br/>&lt;input type=”text” id=”city”&gt;</span></pre><p id="a2af" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当标签和表单控件在DOM中的不同位置，或者由于某种原因不能将控件放在标签中时，这可能会很方便。</p><p id="afd3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在定制表单控件中点击标签焦点<code class="fe mp mq mr ms b">&lt;input&gt;</code>还需要做两件事情。</p><p id="c065" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，组件应该是可聚焦的。这是通过添加一个<code class="fe mp mq mr ms b">tabindex</code>属性来完成的。</p><p id="4eae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此属性指示元素是可聚焦的，以及当用户使用TAB键在表单控件中导航时元素聚焦的顺序。</p><p id="dff7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通常，焦点顺序依赖于元素在DOM中出现的顺序，但是使用<code class="fe mp mq mr ms b">tabindex</code>可以改变这种顺序。</p><p id="3576" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着，例如，具有<code class="fe mp mq mr ms b">tabindex</code> 4的元素将被聚焦在具有<code class="fe mp mq mr ms b">tabindex</code> 5的元素之前，但是在具有<code class="fe mp mq mr ms b">tabindex</code> 3的元素之后。</p><p id="d897" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当两个元素有相同的<code class="fe mp mq mr ms b">tabindex</code>时，DOM中的顺序优先，所以如果你想保持这个顺序，但需要添加<code class="fe mp mq mr ms b">tabindex</code>使元素可聚焦，你可以对所有元素使用<code class="fe mp mq mr ms b">tabindex="0"</code>。</p><p id="d821" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了确保元素总是有一个<code class="fe mp mq mr ms b">tabindex</code>属性，您可以检查它是否存在，如果不存在就添加它:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="2002" class="mx kx iq ms b gy my mz l na nb">if (!this.hasAttribute(‘tabindex’)) {<br/>  this.setAttribute(‘tabindex’, ‘0’);<br/>}</span></pre><p id="b6e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在你的组件是可聚焦的了，当它关联的<code class="fe mp mq mr ms b">&lt;label&gt;</code>被点击或轻击时，它将被聚焦。</p><p id="de04" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是因为它里面的<code class="fe mp mq mr ms b">&lt;input&gt;</code>需要被聚焦，所以焦点应该用下面的代码来委托:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="7483" class="mx kx iq ms b gy my mz l na nb">this.addEventListener(‘focus’, () =&gt; this.input.focus());</span></pre><p id="e9db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，当点击<code class="fe mp mq mr ms b">&lt;label&gt;</code>时，组件内的<code class="fe mp mq mr ms b">&lt;input&gt;</code>将被聚焦。</p><p id="5e3d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是完整的组件:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="e61f" class="mx kx iq ms b gy my mz l na nb">class FormInput extends HTMLElement {<br/>  static formAssociated = true;</span><span id="f87b" class="mx kx iq ms b gy nc mz l na nb">  constructor() {<br/>    super();<br/>    this.internals = this.attachInternals();</span><span id="3752" class="mx kx iq ms b gy nc mz l na nb">    const shadowRoot = this.attachShadow({mode: ‘open’});</span><span id="a87c" class="mx kx iq ms b gy nc mz l na nb">    shadowRoot.innerHTML = `<br/>      &lt;style&gt;<br/>        :host {<br/>          display: inline-block;<br/>        }</span><span id="b32c" class="mx kx iq ms b gy nc mz l na nb">        input {<br/>          display: block;<br/>          padding: 5px;<br/>        }<br/>      &lt;/style&gt;</span><span id="1883" class="mx kx iq ms b gy nc mz l na nb">      &lt;input type=”text”&gt;<br/>   `;<br/> }</span><span id="2dca" class="mx kx iq ms b gy nc mz l na nb">  connectedCallback() {<br/>    this.input = this.shadowRoot.querySelector(‘input’);</span><span id="b12c" class="mx kx iq ms b gy nc mz l na nb">    this.input.addEventListener(‘change’, (e) =&gt; {<br/>      const clone = new e.constructor(e.type, e);</span><span id="80ac" class="mx kx iq ms b gy nc mz l na nb">      this.dispatchEvent(clone);</span><span id="6260" class="mx kx iq ms b gy nc mz l na nb">      this.value = this.input.value;<br/>    });</span><span id="5eed" class="mx kx iq ms b gy nc mz l na nb">    this.addEventListener(‘focus’, () =&gt; this.input.focus());</span><span id="3ea7" class="mx kx iq ms b gy nc mz l na nb">    if (!this.hasAttribute(‘tabindex’)) {<br/>      this.setAttribute(‘tabindex’, ‘0’);<br/>    }<br/>  }</span><span id="db6d" class="mx kx iq ms b gy nc mz l na nb">  get value() {<br/>    return this._value;<br/>  }</span><span id="d47f" class="mx kx iq ms b gy nc mz l na nb">  set value(value) {<br/>    this._value = value;<br/>    this.internals.setFormValue(value);<br/>  }</span><span id="fc18" class="mx kx iq ms b gy nc mz l na nb">  get form() {<br/>    return this.internals.form;<br/>  }<br/> <br/>  get name() {<br/>    return this.getAttribute(‘name’);<br/>  }<br/> <br/>  get type() {<br/>    return this.localName;<br/>  }<br/>}</span></pre><p id="784f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是一个可用的密码笔:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Custom Element form control</figcaption></figure><p id="6c20" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请务必阅读我的后续文章<a class="ae kv" href="https://medium.com/itnext/native-form-validation-of-web-components-a599e85176c7" rel="noopener">解释Web组件如何参与原生表单验证。</a></p><p id="3e32" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在Twitter上关注我，在那里我写了现代网络能做什么，PWAs，和网络组件。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="4c79" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nd">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="nd">plain English . io</em></strong></a><em class="nd">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nd">免费周报</em> </strong> </a> <em class="nd">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="nd">Twitter</em></strong></a><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="nd">LinkedIn</em></strong></a><em class="nd">，以及</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nd">不和</em> </strong> </a> <em class="nd">。</em></p></div></div>    
</body>
</html>